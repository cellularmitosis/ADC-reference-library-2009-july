<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Fragment Tool - /DialogStuff.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxRuntimeArchitecture-date.html">Runtime Architecture</a> &gt; <A HREF="javascript:location.replace('index.html');">Fragment Tool</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Fragment Tool</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/DialogStuff.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AppleEventStuff.c</option>
<option value="listing2.html">/AppleEventStuff.h</option>
<option value="listing3.html">/DialogStuff.c</option>
<option value="listing4.html">/DialogStuff.h</option>
<option value="listing5.html">/DragStuff.c</option>
<option value="listing6.html">/Fragments.c</option>
<option value="listing7.html">/FragmentStuff.h</option>
<option value="listing8.html">/FragmentTool.c</option>
<option value="listing9.html">/FragmentTool.h</option>
<option value="listing10.html">/Initialize.c</option>
<option value="listing11.html">/Lists.c</option>
<option value="listing12.html">/MenusStuff.c</option>
<option value="listing13.html">/MenuStuff.h</option>
<option value="listing14.html">/Prototypes.h</option>
<option value="listing15.html">/Streams.c</option>
<option value="listing16.html">/Streams.h</option>
<option value="listing17.html">/Utilities.c</option>
<option value="listing18.html">/Utilities.h</option>
<option value="listing19.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Fragment_Tool.zip">Download Sample</a></strong> (&#147;Fragment_Tool.zip&#148;, 86.8K)<BR>
<strong><a href="Fragment_Tool.dmg">Download Sample</a></strong> (&#147;Fragment_Tool.dmg&#148;, 151.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    DialogStuff.c  Contains:  Handle application's dialogs  Written by: Chris White    Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/5/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &lt;Types.h&gt;#include &lt;Quickdraw.h&gt;#include &lt;QDOffscreen.h&gt;#include &lt;Devices.h&gt;#include &lt;LowMem.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Dialogs.h&gt;//#include &lt;stddef.h&gt;#include &lt;CodeFragments.h&gt;#include &lt;StandardFile.h&gt;#include &lt;Folders.h&gt;#include &quot;FragmentTool.h&quot;#include &quot;FragmentStuff.h&quot;#include &quot;DialogStuff.h&quot;#include &quot;Streams.h&quot;#include &quot;Utilities.h&quot;#include &quot;Prototypes.h&quot;static OSErr CreateContentList ( WindowRef theWindow, tContentsProcPtr contentsProc, void* refCon );static void AddContentsToList ( WindowRef theWindow );static int8 GetStageFromItem ( int16 theItem );static int16 GetItemFromStage ( int8 theStage );void GetNameFromDialog ( DialogRef theDialog, StringPtr theName );//// Creates a simple dialog with a single list. A routine pointer is passed// as an argument which add the list contents.//OSErr CreateListDialog ( DialogRef* dialogRef, int16 dialogID, StringPtr dialogTitle,              tContentsProcPtr contentsProc, void* refCon ){  int16      theType;  OSErr      theErr;  GrafPtr      savePort;  DialogRef    theDialog = nil;  ListRef      theList = nil;  Handle      theHandle;  Point      cellSize = {0, 0};  Cell      firstCell = {0, 0};  Rect      dataRect = {0, 0, 0, 1};  Rect      theRect;        theDialog = GetNewDialog ( dialogID, nil, (WindowRef) -1L );  if ( theDialog == nil )    return kGenericError;    // Creates the data structure assigned to the window's refCon field  theErr = CreateWindowInfo ( theDialog, sizeof ( tDialogInfo ) );  if ( theErr )  {    // Don't forget to free any storage we've used so far    DestroyDialog ( theDialog );    return theErr;  }    GetPort ( &amp;savePort );  SetPortWindowPort ( theDialog );  TextFont ( kFontIDGeneva );  TextFace ( normal );  TextSize ( 9 );    SetWindowType ( theDialog, kListWindowType );  SetWTitle ( theDialog, dialogTitle );    GetDialogItem ( theDialog, kListUserItem, &amp;theType, &amp;theHandle, &amp;theRect );  SetDialogItem ( theDialog, kListUserItem, theType, (Handle) gOutlineUserItemUPP, &amp;theRect );    theRect.right -= 15;  theList = LNew ( &amp;theRect, &amp;dataRect, cellSize, 0, theDialog,             false, false, false, true );  if ( theList )  {    tDialogInfoPtr  theInfo;        theInfo = (tDialogInfoPtr) GetWRefCon ( theDialog );    theInfo-&gt;listRef = theList;    (*theList)-&gt;selFlags = lOnlyOne;        // Since the calling routine is always in the same architecture type as    // the callback routine, we don't need to worry about any Mixed Mode    // complications. We just treat it as a straight forward routine pointer.        theErr = (*contentsProc) ( theList, refCon );    if ( theErr )    {      // Don't forget to free any storage we've used so far      DestroyDialog ( theDialog );      SetPort ( savePort );      return theErr;    }        LSetSelect ( true, firstCell, theList );    // Now the list has been fully prepared, turn the drawing mode on. This    // isn't srictly necessary since the window isn't supposed to visible.    LSetDrawingMode ( true, theList );  }    SetPort ( savePort );    SelectWindow ( theDialog );  ShowWindow ( theDialog );  *dialogRef = theDialog;    return noErr;}//// Creates the dialog used for the GetInfo command. Displays information about// the code fragment. This is the stuff contained within the 'cfrg' resource//OSErr CreateInfoDialog ( DialogRef* dialogRef, StringPtr dialogTitle, WindowRef theWindow, int16 theIndex ){  OSErr      theErr;  GrafPtr      savePort = nil;  DialogRef    theDialog = nil;  TEHandle    textH;  tDialogInfoPtr  theInfo;  tStreamRef    theStream = nil;  tItemPtr    theItem;  FontInfo    theFontInfo;    theDialog = GetNewDialog ( 2002, nil, (WindowRef) -1L );  if ( theDialog == nil )    return kGenericError;    theErr = CreateWindowInfo ( theDialog, sizeof ( tDialogInfo ) );  if ( theErr )    goto CleanupAndBail;    GetPort ( &amp;savePort );  SetPortWindowPort ( theDialog );  TextFont ( kFontIDGeneva );  TextFace ( normal );  TextSize ( 9 );    // We're using a different font than the standard, so we need to  // change the fields in the textedit record. Otherwise, any text  // that is being edited will be display in the standard font.  GetFontInfo ( &amp;theFontInfo );  textH = ((DialogPeek) theDialog)-&gt;textH;  (*textH)-&gt;txFont = kFontIDGeneva;  (*textH)-&gt;txFace = normal;  (*textH)-&gt;txSize = 9;  (*textH)-&gt;lineHeight = theFontInfo.ascent + theFontInfo.descent + theFontInfo.leading;  (*textH)-&gt;fontAscent = theFontInfo.ascent;    SetWindowType ( theDialog, kGetInfoWindowType );  SetWTitle ( theDialog, dialogTitle );      // The window is needed to make the document dirty if the user makes  // a change. The item points to the information displayed in the dialog.    theErr = NewStream ( &amp;theStream, sizeof ( WindowRef ) + sizeof ( int16 ) );  if ( theErr ) goto CleanupAndBail;    theErr = SetStreamData ( theStream, (Ptr) &amp;theWindow, sizeof ( WindowRef ) );  if ( theErr ) goto CleanupAndBail;    theErr = SetStreamData ( theStream, (Ptr) &amp;theIndex, sizeof ( int16 ) );  if ( theErr ) goto CleanupAndBail;  theErr = CompactStream ( theStream );  if ( theErr ) goto CleanupAndBail;    theInfo = (tDialogInfoPtr) GetWRefCon ( theDialog );  theInfo-&gt;refCon = (int32) theStream;    // Set up the dialog with the information from the selected item   theItem = GetNthWindowItem ( theWindow, theIndex );  theErr = SetDialogValues ( theDialog, theItem );  if ( theErr ) goto CleanupAndBail;    SetPort ( savePort );    SelectWindow ( theDialog );  ShowWindow ( theDialog );    *dialogRef = theDialog;    return noErr;  CleanupAndBail:  // Don't forget to free any storage we've used so far. goto's are very useful  // for things like error recovery. That's how many of the exception stack  // implementations work in class frameworks.    if ( theStream )    DisposeStream ( theStream );  if ( theDialog )    DestroyDialog ( theDialog );  if ( savePort )    SetPort ( savePort );      return theErr;}//// Our one-fits-all routine to free up everything// to do with a  dialog.//DialogRef DestroyDialog ( DialogRef theDialog ){  if ( theDialog )  {    tDialogInfoPtr  theInfo;        theInfo = (tDialogInfoPtr) GetWRefCon ( theDialog );    if ( theInfo )    {      if ( theInfo-&gt;listRef )        LDispose ( theInfo-&gt;listRef );      DisposePtr ( (Ptr) theInfo );    }        DisposeDialog ( theDialog );  }    // We'll return nil so the result can assigned to  // the dialog reference that was passed in.  return nil;}//// This routine's pointer is passed into CreateListDialog// to add the contents to a newly created list.//OSErr AddFragmentExports ( ListRef theList, void* refCon ){  int            i;  int32          theCount;  OSErr          theErr = noErr;  CFragLoadOptions    theFlags = kLoadCFrag;  tItemPtr        theItem;  Ptr            mainAddr, symAddr;  CFragConnectionID    theConnID;  CFragSymbolClass    symClass;  tAddFragmentExportsRec*  theRec;  Str255          symName;  static Str255      errName;      theRec = (tAddFragmentExportsRec*) refCon;  theItem = theRec-&gt;u.out.theItem;  if ( theItem == nil )    return kGenericError;      // Since 'errName' must be valid after the routine has  // gone out of scope, the variable is declaired static.      // The fragment may not exist in the document yet. If this is the  // case, we'll need to get the fragment from the temporary file.   if ( theItem-&gt;bExistsInDocument )    theErr = GetDiskFragment ( theRec-&gt;u.out.theSpecPtr, theItem-&gt;codeOffset, theItem-&gt;codeLength,                  theItem-&gt;name, theFlags, &amp;theConnID, &amp;mainAddr, errName );  else    theErr = GetDiskFragment ( GetTempSpecPtr ( theItem ), 0, 0, theItem-&gt;name, theFlags, &amp;theConnID, &amp;mainAddr, errName );    if ( theErr )  {    theRec-&gt;bIn = true;    theRec-&gt;u.in.theErrorStr = errName;    return theErr;  }    theErr = CountSymbols ( theConnID, &amp;theCount );  if ( theErr ) goto CleanupAndBail;    for ( i = 0; i &lt; theCount; i++ )  {    theErr = GetIndSymbol ( theConnID, i, symName, &amp;symAddr, &amp;symClass );    if ( theErr ) goto CleanupAndBail;        AddToList ( theList, symName );  }    CleanupAndBail:    CloseConnection ( &amp;theConnID );    return theErr;}//// This routine's pointer is passed into CreateListDialog// to add the names of each document, except the front-most.//OSErr AddDocuments ( ListRef theList, void* refCon ){  #pragma unused(refCon)  int      theIndex = 0;  WindowRef  theWindow;        // By structuring the routines this way, we can ensure that the index we  // retrive from the List Manager (as the selected item) can be passed into  // the GetIndexedDocumentWindow routine to get the correct window. This  // minimizes any logical dependencies between different routines. Most  // of the logic is contained within the GetIndexedDocumentWindow routine.    while ( 0 != (theWindow = GetIndexedDocumentWindow(theIndex++)))  {    Str255  theText;        GetWTitle ( theWindow, theText );    AddToList ( theList, theText );  }    return noErr;}// This routine is called to setup all the dialog items with the information// from a fragment. We pass in a pointer to its data structure.OSErr SetDialogValues ( DialogRef theDialog, tItemPtr theItem ){  int16  itemType;  int16  tmpNum;  Handle  theHandle;  Rect  theRect;  Str255  tmpString = &quot;\p&quot;;    // Name of the fragment  GetDialogItem ( theDialog, kNameEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  SetDialogItemText ( theHandle, theItem-&gt;name );    // The fragment's arichtecture. For example, m68k  GetDialogItem ( theDialog, kArchitectureStaticText, &amp;itemType, &amp;theHandle, &amp;theRect );  OSTypeToPStr ( theItem-&gt;archType, tmpString );  SetDialogItemText ( theHandle, tmpString );    // The update level. We use a popup menu for this information  GetDialogItem ( theDialog, kUpdateLevelPopup, &amp;itemType, &amp;theHandle, &amp;theRect );  SetControlValue ( (ControlHandle) theHandle, theItem-&gt;updateLevel + 1 );    // Current Version  GetDialogItem ( theDialog, kCurrentMajorEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( (*(NumVersion*)&amp;theItem-&gt;currVersion).majorRev, tmpString );  SetDialogItemText ( theHandle, tmpString );    GetDialogItem ( theDialog, kCurrentMinorEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( (*(NumVersion*)&amp;theItem-&gt;currVersion).minorAndBugRev &amp; 0xF0, tmpString );  SetDialogItemText ( theHandle, tmpString );    GetDialogItem ( theDialog, kCurrentBugRevEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( (*(NumVersion*)&amp;theItem-&gt;currVersion).minorAndBugRev &amp; 0x0F, tmpString );  SetDialogItemText ( theHandle, tmpString );    GetDialogItem ( theDialog, kCurrentStagePopup, &amp;itemType, &amp;theHandle, &amp;theRect );  tmpNum = GetItemFromStage ( (*(NumVersion*)&amp;theItem-&gt;currVersion).stage );  SetControlValue ( (ControlHandle) theHandle, tmpNum );  GetDialogItem ( theDialog, kCurrentNonRelEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( (*(NumVersion*)&amp;theItem-&gt;currVersion).nonRelRev, tmpString );  SetDialogItemText ( theHandle, tmpString );    // Old Version  GetDialogItem ( theDialog, kOldMajorEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).majorRev, tmpString );  SetDialogItemText ( theHandle, tmpString );    GetDialogItem ( theDialog, kOldMinorEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).minorAndBugRev &amp; 0xF0, tmpString );  SetDialogItemText ( theHandle, tmpString );    GetDialogItem ( theDialog, kOldBugRevEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).minorAndBugRev &amp; 0x0F, tmpString );  SetDialogItemText ( theHandle, tmpString );    GetDialogItem ( theDialog, kOldStagePopup, &amp;itemType, &amp;theHandle, &amp;theRect );  tmpNum = GetItemFromStage ( (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).stage );  SetControlValue ( (ControlHandle) theHandle, tmpNum );    GetDialogItem ( theDialog, kOldNonRelEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).nonRelRev, tmpString );  SetDialogItemText ( theHandle, tmpString );    // Stack size. Only relevant if this thing's an application  GetDialogItem ( theDialog, kStackSizeEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( theItem-&gt;appStackSize / 1024, tmpString );  SetDialogItemText ( theHandle, tmpString );    // Resource ID of an alias record to look for fragments. We don't do much with this.  GetDialogItem ( theDialog, kSubFolderIDEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( theItem-&gt;appStackSize, tmpString );  SetDialogItemText ( theHandle, tmpString );    // Usage. Is this an application, library, or what.  GetDialogItem ( theDialog, kUsagePopup, &amp;itemType, &amp;theHandle, &amp;theRect );  SetControlValue ( (ControlHandle) theHandle, theItem-&gt;usage + 1 );    // This is currently &quot;hard-coded&quot; in the dialog resource. We'll leave it alone.  GetDialogItem ( theDialog, kLocationStaticText, &amp;itemType, &amp;theHandle, &amp;theRect );  // NumToString ( theItem-&gt;location, tmpString );  // SetDialogItemText ( theHandle, tmpString );    // Offset to the fragment in the data fork.  if ( theItem-&gt;bExistsInDocument ) // Has it been saved? We don't know the offset otherwise  {    GetDialogItem ( theDialog, kOffsetStaticText, &amp;itemType, &amp;theHandle, &amp;theRect );    NumToString ( theItem-&gt;codeOffset, tmpString );    SetDialogItemText ( theHandle, tmpString );  }    // Length of the fragment in the data fork  GetDialogItem ( theDialog, kLengthStaticText, &amp;itemType, &amp;theHandle, &amp;theRect );  NumToString ( theItem-&gt;codeLength, tmpString );  SetDialogItemText ( theHandle, tmpString );    return noErr;}//// The opposite of the above routine. This one gets the values from the dialog// fields and puts them in the fragment's data structure//OSErr GetDialogValues ( DialogRef theDialog, tItemPtr theItem ){  int16  itemType;  int32  tmpNum;  Handle  theHandle;  Rect  theRect;  Str255  tmpString = &quot;\p&quot;;    // Name of the fragment  GetDialogItem ( theDialog, kNameEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, theItem-&gt;name );    // The update level. We use a popup menu for this information  GetDialogItem ( theDialog, kUpdateLevelPopup, &amp;itemType, &amp;theHandle, &amp;theRect );  theItem-&gt;updateLevel = GetControlValue ( (ControlHandle) theHandle ) - 1;    // Current Version  GetDialogItem ( theDialog, kCurrentMajorEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;tmpNum );  (*(NumVersion*)&amp;theItem-&gt;currVersion).majorRev = tmpNum;    GetDialogItem ( theDialog, kCurrentMinorEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;tmpNum );  (*(NumVersion*)&amp;theItem-&gt;currVersion).minorAndBugRev = tmpNum &lt;&lt; 4;    GetDialogItem ( theDialog, kCurrentBugRevEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;tmpNum );  (*(NumVersion*)&amp;theItem-&gt;currVersion).minorAndBugRev += tmpNum;    GetDialogItem ( theDialog, kCurrentStagePopup, &amp;itemType, &amp;theHandle, &amp;theRect );  tmpNum = GetControlValue ( (ControlHandle) theHandle );  (*(NumVersion*)&amp;theItem-&gt;currVersion).stage = GetStageFromItem ( tmpNum );    GetDialogItem ( theDialog, kCurrentNonRelEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;tmpNum );  (*(NumVersion*)&amp;theItem-&gt;currVersion).nonRelRev = tmpNum;    // Old Version  GetDialogItem ( theDialog, kOldMajorEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;tmpNum );  (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).majorRev = tmpNum;    GetDialogItem ( theDialog, kOldMinorEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;tmpNum );  (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).minorAndBugRev = tmpNum &lt;&lt; 4;    GetDialogItem ( theDialog, kOldBugRevEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;tmpNum );  (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).minorAndBugRev += tmpNum;    GetDialogItem ( theDialog, kOldStagePopup, &amp;itemType, &amp;theHandle, &amp;theRect );  tmpNum = GetControlValue ( (ControlHandle) theHandle );  (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).stage = GetStageFromItem ( tmpNum );    GetDialogItem ( theDialog, kOldNonRelEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;tmpNum );  (*(NumVersion*)&amp;theItem-&gt;oldDefVersion).nonRelRev = tmpNum;    // Stack size. Only relevant if this thing's an application  GetDialogItem ( theDialog, kStackSizeEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;theItem-&gt;appStackSize );    // Resource ID of an alias record to look for fragments. We don't do much with this.  GetDialogItem ( theDialog, kSubFolderIDEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, tmpString );  StringToNum ( tmpString, &amp;theItem-&gt;appStackSize );    // Usage. Is this an application, library, or what.  GetDialogItem ( theDialog, kUsagePopup, &amp;itemType, &amp;theHandle, &amp;theRect );  theItem-&gt;usage = GetControlValue ( (ControlHandle) theHandle ) - 1;      return noErr;}void GetNameFromDialog ( DialogRef theDialog, StringPtr theName ){  int16  itemType;  Handle  theHandle;  Rect  theRect;    // Just the name of the fragment  GetDialogItem ( theDialog, kNameEditText, &amp;itemType, &amp;theHandle, &amp;theRect );  GetDialogItemText ( theHandle, theName );}//// Convert between the popup item number and what it means//int8 GetStageFromItem ( int16 theItem ){  int8 theStage = 0;    switch ( theItem )  {    case 1:      theStage = 0x20;    break;        case 2:      theStage = 0x40;    break;        case 3:      theStage = 0x60;    break;        case 4:      theStage = 0x80;    break;  }    return theStage;}//// Convert between the popup item number and what it means//int16 GetItemFromStage ( int8 theStage ){  int16 theItem = 0;    switch ( theStage )  {    case 0x20:      theItem = 1;    break;        case 0x40:      theItem = 2;    break;        case 0x60:      theItem = 3;    break;        case 0x80:      theItem = 4;    break;  }    return theItem;}//// Handle a click in a dialog//void DoDialogContentClick ( DialogRef theDialog, EventRecord* theEvent ){  SInt16 itemHit;      SetPort ( theDialog );    if ( DialogSelect ( theEvent, &amp;theDialog, &amp;itemHit ) )    DoDialogItemHit ( theDialog, itemHit );  else  {    if ( GetWindowType ( theDialog ) == kListWindowType )    {      ListRef      theList;      tDialogInfoPtr  theInfo;      Point      localPt;                  theInfo = (tDialogInfoPtr) GetWRefCon ( theDialog );      theList = theInfo-&gt;listRef;            localPt = theEvent-&gt;where;      GlobalToLocal ( &amp;localPt );            if ( LClick ( localPt, theEvent-&gt;modifiers, theList ) )    /* double clicked? */        DoDialogItemHit ( theDialog, kStdOkItemIndex );    }    }      return;}//// Handle a dialog item hit//void DoDialogItemHit ( DialogRef theDialog, int16 theItem ){  switch ( theItem )  {    case kStdOkItemIndex:    {      int16  theSubType;            theSubType = GetWindowSubType ( theDialog );      switch ( theSubType )      {        case kMoveFragmentWindowSubType:          MoveCopySelectedFragments ( theDialog, true );        break;                case kCopyFragmentWindowSubType:          MoveCopySelectedFragments ( theDialog, false );        break;                default:          if ( GetWindowType ( theDialog ) == kGetInfoWindowType )          {            tDialogInfoPtr  theInfo;            tStreamRef    theStream;                                    theInfo = (tDialogInfoPtr) GetWRefCon ( theDialog );            theStream = (tStreamRef) theInfo-&gt;refCon;            if ( theStream )            {              OSErr    theErr;              int16    theIndex;              WindowRef  theWindow;              tItemPtr  theItem;              Str255    theName;                                          ResetStreamCursor ( theStream );              theErr = GetStreamData ( theStream, (Ptr) &amp;theWindow, sizeof ( WindowRef ) );              theErr = GetStreamData ( theStream, (Ptr) &amp;theIndex, sizeof ( int16 ) );              DisposeStream ( theStream );                            theItem = GetNthWindowItem ( theWindow, theIndex );              GetNameFromDialog ( theDialog, theName );              UpdateFragInList ( theWindow, theIndex, theName );              GetDialogValues ( theDialog, theItem );                            SetDocumentDirty ( theWindow, true );            }          }        break;      }      DestroyDialog ( theDialog );    }    break;        case kStdCancelItemIndex:      DestroyDialog ( theDialog );    break;  }  return;  } // DoDialogItemHit//// Perform's the copy/move after the user selects a traget document// from the dialog.//void MoveCopySelectedFragments ( DialogRef theDialog, Boolean bMove ){  int16      theIndex = 0;  tDialogInfoPtr  theInfo;      theInfo = (tDialogInfoPtr) GetWRefCon ( theDialog );  if ( GetSelection ( theInfo-&gt;listRef, &amp;theIndex ) )  {    OSErr      theErr;    int        theCount, i;    WindowRef    sourceWindow, targetWindow;    tStreamRef    theStream;                // All the information is passed in a data stream    // built by the PackageWindowData routine. It consists of the source    // window reference, the number of fragments to copy or move, and    // then an array of index values.        targetWindow = GetIndexedDocumentWindow ( theIndex );    if ( targetWindow == nil )    {      AlertUser ( kGenericErrorStr, 0, nil );      return;    }        theStream = (tStreamRef) theInfo-&gt;refCon;    ResetStreamCursor ( theStream );    theErr = GetStreamData ( theStream, (Ptr) &amp;sourceWindow, sizeof ( WindowRef ) );    theErr = GetStreamData ( theStream, (Ptr) &amp;theCount, sizeof ( int ) );        for ( i = 0; i &lt; theCount; i++ )    {      theErr = GetStreamData ( theStream, (Ptr) &amp;theIndex, sizeof ( int16 ) );      if ( bMove )        theErr = MoveWindowFragment ( sourceWindow, theIndex, targetWindow );      else        theErr = CopyWindowFragment ( sourceWindow, theIndex, targetWindow );    }        DisposeStream ( theStream );      }    return;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Fragment_Tool/listing3.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Fragment_Tool/listing3.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Fragment_Tool/listing3.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>