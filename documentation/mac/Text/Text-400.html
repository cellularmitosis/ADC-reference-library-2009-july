<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>IntlTokenize(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING400></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-399.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-401.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-354.html"><B>Chapter 6 - Script Manager</B></A> / <A HREF="Text-365.html"><B>Script Manager Reference</B></A><BR><DL><DD><A HREF="Text-375.html"><B>Routines</B></A> / <A HREF="Text-399.html"><B>Tokenization</B></A></DL></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING400-0></A>
<H3><A NAME=MARKER-9-980></A>IntlTokenize</H3>
 <A NAME=MARKER-2-981></A>The <CODE>IntlTokenize</CODE> function allows your application to convert text into a sequence of language-independent tokens. It returns a list of tokens that correspond to the text that you pass it.<P>
<PRE>
FUNCTION IntlTokenize (tokenParam: TokenBlockPtr): TokenResults;
</PRE>
<DL>
<DT><CODE>tokenParam</CODE>
<DD> A pointer to a token block record. The record specifies the text to be converted to tokens, the destination of the token list, a handle to the tokens (<CODE>'itl4'</CODE>) resource, and a set of options.
</DL>
 <A NAME=MARKER-2-982></A>The token block record is a parameter block and a data structure of type <CODE>TokenBlock</CODE>, described on <A HREF=Text-373.html#MARKER-9-920>page 6-74</A>. You specify input values and receive return values in as <BR>shown here:<P>
<B>
<TABLE BORDER="0" CELLPADDING=3><TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-316></A>source</CODE><TD><CODE>Ptr</CODE><TD>A pointer to the beginning of the source text (not a Pascal string) to <BR>be converted.<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-317></A>sourceLength</CODE><TD><CODE>LongInt</CODE><TD>The number of bytes in the source text.<TR>
<TD><--><TD><CODE><A NAME=MARKER-2-318></A>tokenList</CODE><TD><CODE>Ptr</CODE><TD>A pointer to a buffer you have allocated, into which the <CODE>IntlTokenize</CODE> function places the list of token records it generates.<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-319></A>tokenLength</CODE><TD><CODE>LongInt</CODE><TD>The maximum size of token list (in number of tokens, not bytes) that will fit into the buffer pointed to by the <CODE>tokenList</CODE> field.<TR>
<TD><--><TD><CODE><A NAME=MARKER-2-320></A>tokenCount</CODE><TD><CODE>LongInt</CODE><TD><A NAME=MARKER-2-196></A>On input: If <CODE>doAppend</CODE> = <CODE>TRUE</CODE>, must contain the correct number of tokens currently in the token list. (Ignored if <CODE>doAppend</CODE> = <CODE>FALSE</CODE>.)<BR>On output: The number of tokens currently in the token list.<TR>
<TD><--><EM></EM><TD><CODE><A NAME=MARKER-2-322></A>stringList</CODE><TD><CODE>Ptr</CODE><TD><A NAME=MARKER-2-32></A>If <CODE>doString</CODE> = <CODE>TRUE</CODE>, must contain a pointer to a buffer into which <CODE>IntlTokenize</CODE> can place a list of strings it generates. (Ignored if <CODE>doString</CODE> = <CODE>FALSE</CODE>.)<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-324></A>stringLength</CODE><TD><CODE>LongInt</CODE><TD>If <CODE>doString</CODE> = <CODE>TRUE</CODE>, must contain the size in bytes of the string list buffer pointed to by the <CODE>stringList</CODE> field. (Ignored if <CODE>doString</CODE> = <CODE>FALSE</CODE>.)<TR>
<TD><--><TD><CODE><A NAME=MARKER-2-326></A>stringCount</CODE><TD><CODE>LongInt</CODE><TD><A NAME=MARKER-2-327></A>On input: If <CODE>doString</CODE> = <CODE>TRUE</CODE> and <CODE>doAppend</CODE> = <CODE>TRUE</CODE>, must contain the correct current size in bytes of the string list. (Ignored if <CODE>doString</CODE> = <CODE>FALSE</CODE>  or <CODE>doAppend</CODE> = <CODE>FALSE</CODE>.) <BR>On output: The current size in bytes of the string list. (Indeterminate if <CODE>doString</CODE> = <CODE>FALSE</CODE>.)<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-328></A>doString</CODE><TD><CODE>Boolean</CODE><TD><A NAME=MARKER-2-287></A>If <CODE>TRUE</CODE>, instructs <CODE>IntlTokenize</CODE> to create a Pascal string representing the contents of each token it generates. <BR>If <CODE>FALSE</CODE>, <CODE>IntlTokenize</CODE> generates <BR>a token list without an associated string list.<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-330></A>doAppend</CODE><TD><CODE>Boolean</CODE><TD><A NAME=MARKER-2-310></A>If <CODE>TRUE</CODE>, instructs <CODE>IntlTokenize</CODE> to append tokens and strings it generates to the current token list and string list. If <CODE>FALSE</CODE>, <CODE>IntlTokenize</CODE> writes over any previous contents of the buffer pointed to by <CODE>tokenList</CODE> and <CODE>stringList</CODE>.<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-332></A>doAlphanumeric</CODE><TD><CODE>Boolean</CODE><TD><A NAME=MARKER-2-333></A>If <CODE>TRUE</CODE>, instructs <CODE>IntlTokenize</CODE> to interpret numeric characters as alphabetic when mixed with alphabetic characters. If <CODE>FALSE</CODE>, all numeric characters are interpreted as numbers.<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-334></A>doNest</CODE><TD><CODE>Boolean</CODE><TD><A NAME=MARKER-8-186></A>If <CODE>TRUE</CODE>, instructs <CODE>IntlTokenize</CODE> to allow nested comments (to any depth of nesting). If <CODE>FALSE</CODE>, comment delimiters may not be nested within other comment delimiters.<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-336></A>leftDelims</CODE><TD>DelimType<TD><A NAME=MARKER-8-187></A>An array of two integers, each of which contains the token code of the symbol that may be used as an opening delimiter for a quoted literal. If only one opening delimiter is needed, the other must be specified to be <CODE>delimPad</CODE>.<TR>
<TD><EM>--></EM><TD><CODE>rightDelims</CODE><TD>DelimType<TD>An array of two integers, each of which contains the token code of the symbol that may be used as the matching closing delimiter for the corresponding opening delimiter in the <CODE>leftDelims</CODE> field.<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-339></A>leftComment</CODE><TD>CommentType<TD>An array of two pairs of integers, each pair of which contains codes for the two token types that may be used as opening delimiters for comments.<TR>
<TD><EM>--></EM><TD><CODE>rightComment</CODE><TD>CommentType<TD><A NAME=MARKER-8-189></A>An array of two pairs of integers, each pair of which contains codes for the two token types that may be used as closing delimiters for comments.<TR>
<TD><EM>--></EM><TD><CODE><A NAME=MARKER-2-342></A>escapeCode</CODE><TD>TokenType<TD><A NAME=MARKER-8-190></A>A single integer that contains the token code for the symbol that may be an escape character within a quoted literal.<TR>
<TD><EM>--></EM><TD><CODE>decimalCode</CODE><TD>TokenType<TD>A single integer that contains the token type of the symbol to be used for a decimal point.<TR>
<TD><EM>--></EM><TD>itlResource<TD>Handle<TD>A handle to the tokens (<CODE>'itl4'</CODE>) resource of the script system under which the source text was created.<TR>
<TD><EM>--></EM><TD>reserved<TD>ARRAY<BR> [0..7] OF<BR> LongInt<TD>Must be set to 0.</TABLE>
</B><P>
<A NAME=HEADING400-6></A>
<H5>DESCRIPTION</H5>
 The <CODE>IntlTokenize</CODE> function returns a list of tokens that correspond to the input text. The token list is an array of token records (type <CODE>TokenRec</CODE>). Each token record describes the token generated, specifies the part of the source text it came from, and optionally provides a character string that is a normalized version of the text that generated the token.<P>
 <CODE>IntlTokenize<B> also returns a result code that specifies the type of error that occurred, if any.</B></CODE><P>
 Before calling the <CODE>IntlTokenize</CODE> function, allocate memory for and set up the following data structures:<P>
<UL>
<LI>A token block record (data type <CODE>TokenBlock</CODE>). The token block record is a parameter block that holds both input and output parameters for the <CODE>IntlTokenize</CODE> function.
<LI><A NAME=MARKER-2-983></A>A token list to hold the results of the tokenizing operation. To set up the token list, estimate how many tokens will be generated from your text, multiply that by the size of a token record, and allocate a memory block of that size in bytes. An upper limit to the possible number of tokens is the number of characters in the source text.
<LI><A NAME=MARKER-2-984></A>A string list, if you want the <CODE>IntlTokenize</CODE> function to generate character strings for all the tokens. To set up the string list, multiply the estimated number of tokens by the expected average size of a string, and allocate a memory block of that size in bytes. An upper limit is twice the number of tokens plus the number of bytes in the source text.<P>
</UL>
 <CODE><A NAME=MARKER-2-985></A>IntlTokenize</CODE> creates tokens based on information in the tokens (<CODE>'itl4'</CODE>) resource of the script system under which the source text was created. You must load the tokens resource and place its handle in the token block record before calling the <CODE>IntlTokenize</CODE> function.<P>
 The token block record contains both input and output values. At input, you must provide values for the fields that specify the source text location, the token list location, the size of the token list, the tokens (<CODE>'itl4'</CODE>) resource to use, and several options that affect the operation. You must set reserved locations to 0 before calling <CODE>IntlTokenize</CODE>.<P>
 On output, the token block record specifies how many tokens have been generated and the size of the string list (if you have selected the option to generate strings).<P>
 <A NAME=MARKER-2-986></A>The results of the tokenizing operation are contained in the token list, an array of token records. A token record (data type <CODE>TokenRec</CODE>) consists of a token code, a pointer to a location in the source text, the length of a character sequence in the source text, and an optional pointer to a Pascal string:<P>
<PRE>
TYPE 
   TokenRec = 
   RECORD
      theToken:         TokenType;  {numeric code for token}
      position:         Ptr;        {pointer to source text from }
                                    { which token was generated}
      length:           LongInt;    {length of source text from }
                                    { which token was generated}
      stringPosition:   StringPtr;  {pointer to Pascal string }
                                    { generated from token}
   END;
   TokenRecPtr = ^TokenRec;
</PRE>
<DL>
<H5>Field Description</H5>
<DT><CODE><A NAME=MARKER-2-987></A>theToken</CODE>
<DD> The token code that specifies the type of token (such as whitespace, opening parenthesis, alphabetic or numeric sequence) described by this token record. Constants for all defined token codes are listed on <A HREF=Text-370.html#MARKER-9-796>page 6-58</A>.
<DT><CODE><A NAME=MARKER-2-988></A>position </CODE>
<DD> A pointer to the first character in the source text that caused this particular token to be generated.
<DT><CODE><A NAME=MARKER-2-989></A>length</CODE>
<DD> The length in bytes of the source text that caused this particular token to be generated.
<DT><CODE><A NAME=MARKER-2-990></A>stringPosition</CODE>
<DD> If <CODE>doString</CODE> = <CODE>TRUE</CODE>, a pointer to a null-terminated Pascal string, padded if necessary so that its total number of bytes (length byte + text + null byte + padding) is even. If <CODE>doString</CODE> = <CODE>FALSE</CODE>, this field is <CODE>NIL</CODE>.
<DT><B>Note</B>
<DD>The value in the length byte of the null-terminated Pascal string does not include either the terminating zero byte or the possible additional padding byte. There may be as many as two additional bytes beyond the specified length.<EM></EM>  <A NAME=MARKER-2-991></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-2-992></A>Pascal strings are generated if the <CODE>doString</CODE> parameter in the token block record is set to <CODE>TRUE</CODE>. The string is a normalized version of the source text that generated the token; alternate digits are replaced with ASCII numerals, the decimal point is always an ASCII period, and 2-byte Roman letters are replaced with low-ASCII equivalents.<P>
 <A NAME=MARKER-2-993></A>To make a series of calls to <CODE>IntlTokenize</CODE> and append the results of each call to the results of previous calls, set <CODE>doAppend</CODE> to <CODE>FALSE</CODE> and initialize <CODE>tokenCount</CODE> and <CODE>stringCount</CODE> to 0 before making the first call to <CODE>IntlTokenize</CODE>. (You can ignore <CODE>stringCount</CODE> if you set <CODE>doString</CODE> to <CODE>FALSE</CODE>.) Upon completion of the call, <CODE>tokenCount</CODE> and <CODE>stringCount</CODE> will contain the number of tokens and the length in bytes of the string list, respectively, generated by the call. On subsequent calls, set <CODE>doAppend</CODE> to <CODE>TRUE</CODE>, reset the <CODE>source</CODE> and <CODE>sourceLength</CODE> parameters (and any other parameters as appropriate) for the new source text, but maintain the output values for <CODE>tokenCount</CODE> and <CODE>stringCount</CODE> from each call as input values to the next call. At the end of your sequence of calls, the token list and string list will contain, in order, all the tokens and strings generated from the calls to <CODE>IntlTokenize</CODE>.<P>
 If you are making tokens from text that was created under more than one script system, you must load the proper tokens resource and place its handle in the token block record separately for each script run in the text,  appending the results each time. <P>
 <A NAME=MARKER-2-994></A>Delimiters for quoted literals are passed to <CODE>IntlTokenize</CODE> in a two-integer array:<P>
<PRE>
TYPE DelimType = ARRAY[0..1] OF TokenType;
</PRE>
 The individual delimiters, as specified in the <CODE>leftDelims</CODE> and <CODE>rightDelims</CODE> parameters, are paired by position. The first (in storage order) opening delimiter in<CODE> leftDelims</CODE> is paired with the first closing delimiter in <CODE>rightDelims</CODE>.<P>
 Comment delimiters may be 1 or 2 tokens each and there may be two sets of opening and closing pairs. They are passed to <CODE>IntlTokenize</CODE> in a <CODE>commentType</CODE> array:<P>
<PRE>
TYPE CommentType = ARRAY[0..3] OF TokenType;
</PRE>
 If only one token is needed for a delimiter, the second token must be specified to be <CODE>delimPad</CODE>. If only one delimiter of an opening-closing pair is needed, then both of the tokens allocated for the other symbol must be <CODE>delimPad</CODE>. The first token of a two-token sequence is at the higher position in the <CODE>leftComment</CODE> or <CODE>rightComment</CODE> array. For example, if the two opening (in this case, left) delimiters were "<CODE>(*</CODE>" and "<CODE>{</CODE>", they would be specified as follows:<P>
<PRE>
leftComment[0] := tokenAsterisk;    (*asterisk*)
leftComment[1] := tokenLeftParen;   (*left parenthesis*)
leftComment[2] := delimPad ;        (*nothing*)
leftComment[3] := tokenLeftCurly;   (*curly brace*)
</PRE>
 <A NAME=MARKER-2-995></A>When <CODE>IntlTokenize</CODE> encounters an escape character within a quoted literal, it places the portion of the literal before the escape character into a single token (of type <CODE>tokenLiteral</CODE>), places the escape character into another token (<CODE>tokenEscape</CODE>), places the character following the escape character into another token (whatever token type it corresponds to), and places the portion of the literal following the escape sequence into another token (<CODE>tokenLiteral</CODE>). Outside of a quoted literal, the escape character has no special significance.<P>
 <CODE>IntlTokenize</CODE> considers the character specified in the <CODE>decimalCode</CODE> parameter to be a decimal character only when it is flanked by numeric or alternate numeric characters, or when it follows them.<P>
<A NAME=HEADING400-36></A>
<H5>SPECIAL CONSIDERATIONS</H5>
 <CODE>IntlTokenize</CODE> may move memory; your application should not call this function at interrupt time.<P>
 Because each call to <CODE>IntlTokenize</CODE> must be for a single script run, there can be no change of script within a comment or quoted literal. <P>
 Comments and quoted literals must be complete within a single call to <CODE>IntlTokenize</CODE> in order to avoid syntax errors.<P>
 <CODE>IntlTokenize</CODE> always uses the tokens resource whose handle you pass it in the token block record. Therefore, it is not directly affected by the state of the font force flag or the international resources selection flag. However, if you use the <CODE>GetIntlResource</CODE> function to get a handle to the tokens resource to pass to <CODE>IntlTokenize</CODE>, remember that <CODE>GetIntlResource</CODE> is affected by the state of the international resources selection flag. See <A HREF=Text-362.html#MARKER-9-678>"Determining Script Codes From Font Information" beginning on page 6-21</A>.<P>
<A NAME=HEADING400-41></A>
<H5>RESULT CODES<B>
<TABLE BORDER="0" CELLPADDING=3><TD><A NAME=MARKER-2-564></A>tokenOK<TD>0<TD>Valid token<TR>
<TD><A NAME=MARKER-2-565></A>tokenOverflow<TD>1<TD>Number of tokens exceeded maximum specified in <CODE>tokenList</CODE> field of token block record<TR>
<TD><A NAME=MARKER-2-566></A>stringOverflow<TD>2<TD>Size of string list larger than maximum specified in <CODE>stringList</CODE> field of token block record<TR>
<TD><A NAME=MARKER-2-567></A>badDelim<TD>3<TD>Invalid delimiter<TR>
<TD><A NAME=MARKER-2-568></A>badEnding<TD>4<TD>(currently unused)<TR>
<TD><A NAME=MARKER-2-569></A>crash<TD>5<TD>Unknown error</TABLE>
</B></H5>
<A NAME=HEADING400-42></A>
<H5>SEE ALSO</H5>
  See the appendix "International Resources" in this book for a description of the tokens (<CODE>'itl4'</CODE>) resource.<A NAME=MARKER-2-996></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-399.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-401.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
