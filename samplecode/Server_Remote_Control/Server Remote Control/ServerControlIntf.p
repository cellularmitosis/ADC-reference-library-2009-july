{Created: Monday, April 27, 1992 at 2:50 PM    ServerControlIntf.p    Pascal Interface to the Macintosh Libraries        Copyright Apple Computer, Inc. 1990-1992        All rights reserved}UNIT ServerControlIntf;INTERFACE	USES		AppleTalk;	CONST		ServerDispatch = $A094;	{ The server control dispatch trap. }		{ scCode values }		SCStartServer				= 0;		SCShutDown					= 2;		SCCancelShutDown			= 3;		SCDisconnect				= 4;		SCPollServer				= 5;		SCGetExpFldr				= 6;		SCGetSetupInfo				= 7;		SCSetSetupInfo				= 8;		SCSendMessage				= 9;		SCGetServerStatus			= 10;		SCInstallServerEventProc	= 11;		SCRemoveServerEventProc		= 12;		SCGetServerEventProc		= 13;		SCServerVersion				= 14;		SCSetCopyProtect			= 16;		SCClrCopyProtect			= 17;		SCDisconnectVolUsers		= 18;		SCGetUserNameRec			= 19;		SCGetUserMountInfo			= 20;		SCWakeServer				= 21;		SCSleepServer				= 22;		{ all other values of scCode are reserved }		{ scFlags bits and masks for disconnectPB }		bUNRFSendMsg				= 13;		{ send a message }		UNRFSendMsgMask				= $2000;	{ send a message }		{ These are error codes that are returned from an SCDisconnect trap }		AlreadyShuttingDown			= -1;		{ the server is already shutting down }		AlreadyDisconnecting		= -2;		{ the server is already disconnecting }		{ scServerType contains the server type, which is interpreted as follows: }		MFSType						= $0000;	{ Macintosh File Sharing }		AFSType						= $0001;	{ AppleShare File Server }		{ scServerVersion is the server version, which is currently interpreted as follows: }		{	$0030 : File Sharing Extension, versions 7.0 and 7.0.1 }		{	$0031 : File Server Extension, version 3.0 }		{	$0032 : File Sharing Extension, version 7.0.2 }		{ These are some random constants for SCStartServer }		kCurInstalled				= 0;		{ the currently installed server }		kFinderExtn					= 0;		{ send high level events to the finder extension }		{ scServerFlags bits returned by SCGetServerStatus }		bJBSEnabled 				= 12;		{ Set if Apple II boot service is enabled }		{ These "SCPS" integers are passed back from a SCPollServer call in scServerState: }		{ 0 means: 0 <= seconds left < 30 and Network Setup says : "Less than a minute"}		{ 1 means: 30 <= seconds left < 90 and Network Setup says : "About a minute"}		{ 2 thru 4094: x*60-30 <= seconds left < x*60+30 and NS says: "About X minutes" }		SCPSRunning					= -1;		{ Server running normally }		SCPSStartingUp				= -2;		{ Server is in the process of starting up }		SCPSJustDisabled			= -3;		{ Server is just disabled and there was no startup error }		SCPSDisabledwErr			= -4;		{ Server is disabled and there is an "SE" error in scServerError }		SCPSSleeping				= -5;		{ Server is temporarily disabled }		{ These "SCPD" integers are passed back from a SCPollServer call in scDisconnectState: }		{ 0 means: 0 <= seconds left < 30 and FileShare Monitor says : "Less than a minute"}		{ 1 means: 30 <= seconds left < 90 and FileShare Monitor says : "About a minute"}		{ 2 thru 4094: x*60-30 <= seconds left < x*60+30 and FM says: "About X minutes" }		SCPDNotDisconnecting		= -1;		{ Server not disconnecting some one or some group of users }		{ These are Server Errors ("SE") error codes returned in scServerError by }		{ a SCPollServer call }		SENoUGFileOpenErr			= 1; 		{ "The Users & Groups file could not be opened." }		SENoRealVolsErr				= 2;		{ "There are no volumes for AppleShare to use." }		SEInsuffMFMemErr			= 4;		{ "There was not enough memory available to start AppleShare File Service." }		SECantRegNameErr			= 5;		{ "The File Server's name could not be registered on the AppleTalk Network." }		SECantFindExtnFolder		= 6;		{ "The File Server could not be started because the Extensions folder could not be found" }		SEUnExATalkErr				= 7;		{ "An unexpected AppleTalk error occurred." }		SENoMachineName				= 8;		{ "You must have a machine name." }		SECantFindFSExtn			= 9;		{ "The File Server could not be started because the File Sharing Extension could not be found" }		SEATalkOffErr				= 10;		{ "Appletalk is turned off." }		SEAppleTalkErr				= 11;		{ "AppleTalk could not be activated." }		SENoInitRunErr				= 12;		{ "AppleShare Setup file is not installed in the Server Folder." }		SESysTooOldErr				= 13;		{ "The System File is too old for AppleShare (v3.0)." }		SEInsuffAppMemErr			= 14;		{ "There was not enough memory for FileShare to startup." }		SEBadConfigErr				= 15;		{ "AppleShare encountered a problem with the current configuration." }		SENoDTOnStartupErr			= 16;		{ "The Desktop database on volume the startup volume could not be opened." }		SEDupNameErr				= 17;		{ "Duplicate name error when registering.  Please choose another name." }	TYPE		{ The SetupInfoRec used by the SCGetSetupInfo and SCSetSetupInfo calls. }		tLoginMsg = STRING[199];		SetupInfoRecPtr = ^SetupInfoRec;		SetupInfoRec = RECORD				SIVersion: Integer;			{ SetupInfoRec version: 1 for File Sharing and AppleShare 3.0 }				SIFlags: Integer;			{ 0 for File Sharing and AppleShare 3.0 }				SIMaxLogins: Integer;		{ 1..11 for File Sharing; 1..121 for AppleShare 3.0 }				SISrvrUsageLimit: Integer;	{ 10 to 100 (percent) }				{ All remaining fields in record are only used by the AppleShare file server }				SIVolInfoLocation: Point;	{ location of Volume Info window (default is -1,-1) }				SIVolInfoVisible: Boolean;	{ is Volume Info window visible (default is TRUE) }				SIUserInfoLocation: Point;	{ location of Connected Users window (default is -1,-1) }				SIUserInfoVisible: Boolean;	{ is Connected Users window visible (default is TRUE) }				SIShutDownMins: Integer;	{ default minutes until shutdown }				SISpare: ARRAY[1..17] OF Integer;	{ reserved }				SILoginMsg: tLoginMsg;		{ the current Login message }			END;		startParam = RECORD				reserved: LongInt;				reserved2: Integer;				reserved3: Integer;				scCode: Integer;				scStartSelect: Integer;				scEventSelect: Integer;				reserved4: ARRAY[1..4] OF LongInt;			END;		disconnectParam = RECORD				scDiscArrayPtr: LongIntPtr;				scArrayCount: Integer;				reserved: Integer;				scCode: Integer;				scNumMinutes: Integer;				scFlags: Integer;				scMessagePtr: StringPtr;			END;		pollServerParam = RECORD				reserved: LongInt;				reserved2: Integer;				reserved3: Integer;				scCode: Integer;				scServerState: Integer;				scDisconnectState: Integer;				scServerError: Integer;				scSecondsLeft: LongInt;			END;		standardParam = RECORD				scNamePtr: StringPtr;				scVRefNum: Integer;				scLogins: Integer;				scCode: Integer;				scIndex: Integer;				scDirID: LongInt;			END;		setupParam = RECORD				scSetupPtr: SetupInfoRecPtr;				scMaxVolumes: Integer;				scMaxExpFolders: Integer;				scCode: Integer;				scCurMaxSessions: Integer;			END;		statusParam = RECORD				scNamePtr: StringPtr;				reserved2: Integer;				reserved3: Integer;				scCode: Integer;				scServerFlags: Integer;				scNumSessions: Integer;				scUserListModDate: LongInt;				scActivity: Integer;				scVolListModDate: LongInt;			END;		serverEventParam = RECORD				scSEQEntryPtr: Ptr;				reserved2: Integer;				reserved3: Integer;				scCode: Integer;			END;		versionParam = RECORD				scExtNamePtr: StringPtr;				reserved2: Integer;				reserved3: Integer;				scCode: Integer;				scServerType: Integer;				scServerVersion: Integer;			END;		userInfoParam = RECORD				scNamePtr: StringPtr;				reserved2: Integer;				reserved3: Integer;				scCode: Integer;				scPosition: LongInt;				scUNRecID: LongInt;				scUserID: LongInt;				scLoginTime: LongInt;				scLastUseTime: LongInt;				scSocketNum: AddrBlock;			END;		volMountedParam = RECORD				reserved: Ptr;				scVRefNum: Integer;				reserved3: Integer;				scCode: Integer;				scFilesOpen: Integer;				scWriteableFiles: Integer;				scUNRecID: LongInt;				scMounted: Boolean;				scMountedAsOwner: Boolean;			END;		SCParamBlockPtr = ^SCParamBlockRec;		SCParamBlockRec = RECORD				qLink: QElemPtr;				qType: INTEGER;				ioTrap: INTEGER;				ioCmdAddr: Ptr;				ioCompletion: ProcPtr;				ioResult: OSErr;				CASE Integer OF					1: (							startPB: startParam					);					2: (							disconnectPB: disconnectParam					);					3: (							pollServerPB: pollServerParam					);					4: (							standardPB: standardParam					);					5: (							setupPB: setupParam					);					6: (							statusPB: statusParam					);					7: (							serverEventPB: serverEventParam					);					8: (							versionPB: versionParam					);					9: (							userInfoPB: userInfoParam					);					10: (							volMountedPB: volMountedParam					);			END;	{ ServerDispatch can be called synchronously only.  Asynchronous server control }	{ calls are not supported. }	{ Inputs: 	A0 points to the SCParamBlockRec. }	{			D0 must be zero. }	{			SCParamBlockRec.scCode indicates the server control call. }	{ Outputs:	D0.w and SCParamBlockRec.ioResult contain the result code. }	{ Note:		Macintosh File Sharing does not return the result in D0.w }	{			so the glue code below moves it there for you. }	{ The glue to call the ServerDispatch trap }	FUNCTION SyncServerDispatch (PBPtr: SCParamBlockPtr): OSErr;	INLINE		$205F,  		{ MOVEA.L    (A7)+,A0   	}		$7000,  		{ MOVEQ      #$00,D0    	}		$A094,  		{ _ServerDispatch       	}		$3028, $0010,	{ MOVE.W	ioResult(A0),D0	}		$3E80;  		{ MOVE.W     D0,(A7)    	}IMPLEMENTATIONEND.