<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h2><a name="//apple_ref/occ/cl/EOEditingContext">EOEditingContext</a>

 <BR>

</h2>

<p><B>Inherits From:</B><BR>  

EOObjectStore : NSObject



<p><B>Conforms To:</B>

EOObserving<em> 

</em>

<p><B>Declared in:</B>

EOControl/EOEditingContext.h



<p><h3>Class At a Glance:</h3>

<p><dl><dt><h4>Purpose</h4>

</dl>EOEditingContext manages a graph of enterprise objects in an application; this object graph represents an internally consistent view of one or more external stores.<p>

<dl><dt><h4>Principal Attributes</h4>

</dl><li>The set of enterprise objects managed by the EOEditingContext





<li>The EOEditingContext's parent EOObjectStore





<li>The set of EOEditor objects managed by the EOEditingContext





<li>The EOEditingContext's message handler 





<dl><dt><h4>Creation</h4>

</dl><dl><dt>- initWithParentObjectStore:

<dl><dt>	Designated initializer.

</dl></dl><dl><dt><h4>Commonly Used Methods</h4>

</dl><dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectsWithFetchSpecification:">- objectsWithFetchSpecification:</a>

<dl><dt>	Fetches objects from an external store.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/insertObject:">- insertObject:</a>

<dl><dt>	Registers a new object to be inserted into the parent EOObjectStore.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/deleteObject:">- deleteObject:</a>

<dl><dt>	Registers that an object should be removed from the parent 

EOObjectStore when changes are saved.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/lockObject:">- lockObject:</a>

<dl><dt>	Attempts to lock an object in the external store.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/hasChanges">- hasChanges</a>

<dl><dt>	Returns YES if any of the receiver's enterprise objects have been 

modified.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/saveChanges">- saveChanges</a>

<dl><dt>	Commits changes made in the receiver to the parent EOObjectStore.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/revert">- revert</a>

<dl><dt>	Removes everything from the undo stack, discards all insertions and 

deletions, and restores updated objects to their original values.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectForGlobalID:">- objectForGlobalID:</a>

<dl><dt>	Given a globalID, returns its associated object.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/globalIDForObject:">- globalIDForObject:</a>

<dl><dt>	Given an object, returns its globalID.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/setDelegate:">- setDelegate:</a>

<dl><dt>	Sets the receiver's delegate.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/delegate">- delegate</a>

<dl><dt>	Returns the receiver's delegate.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/parentObjectStore">- parentObjectStore</a>

<dl><dt>	Returns the receiver's parent EOObjectStore.

</dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/rootObjectStore">- rootObjectStore</a>

<dl><dt>	Returns the receiver's root EOObjectStore.

</dl></dl><p>

<a name="980">

<a name="description"></a>

<h3>Class Description  </h3>

</a>EOEditingContext represents a single "object space" or document in an application. Its primary responsibility is managing a graph of enterprise objects. This <em>object graph</em> is a group of related business objects that represent an internally consistent view of one or more external stores.<p>

All objects fetched from an external store are registered in an EOEditingContext along with a global identifier (EOGlobalID) that's used to uniquely identify each object to the external store. The EOEditingContext is responsible for watching for changes in its objects (using the EOObserving protocol) and recording snapshots for object-based undo. A single enterprise object instance exists in one and only one EOEditingContext, but multiple copies of an object can exist in different EOEditingContexts. Thus object uniquing is scoped to a particular EOEditingContext.<p>

<a name="983">

<h3> Other Classes that Participate in Object Graph Management</h3>

</a>EOEditingContext works in conjunction with other classes to manage the object graph. Two other classes that play a significant role in object graph management are EOUndoManager and EOObserverCenter. EOUndoManager is a general-purpose undo stack. As a client of EOUndoManager, EOEditingContext registers undo events for all changes made the enterprise objects that it watches.<p>

The other class that plays a significant role in object graph management is EOObserverCenter. EOObserverCenter provides a notification mechanism for an observing object to find out when another object is about to change its state. "Observable" objects (typically all enterprise objects) are responsible for invoking <code>[self willChange]</code> prior to altering their state (in a "set" method, for instance). Objects (such as instances of EOEditingContext) can add themselves as observers to the objects they care about in the EOObserverCenter. They will then receive <B>objectWillChange:</B> notification whenever an observed object invokes <code>[self willChange]</code>. <p>

<a name="986">

<h3> Programmatically Creating an EOEditingContext</h3>

</a>Typically, an EOEditingContext is created automatically for your application as a by product of some other operation. For example, the following operations result in the creation of network of objects that include an EOEditingContext:<p>

<ul><li>Running the EOF Wizard in Project Builder to create an OpenStep application with a graphical user interface<p><li>Dragging an entity from EOModeler into a nib file in Interface Builder<p><li>Accessing the default editing context of a WOSession in a WebObjects application<p></ul>Under certain circumstances, however, you may need to create an EOEditingContext programmatically-for example, if you're writing an application that doesn't include a graphical interface. To create an EOEditingContext, simply <B>alloc</B> and <B>init</B> one like this:<p>

<blockquote><pre>EOEditingContext *editingContext = [[EOEditingContext alloc] init];

</pre></blockquote><p>

This creates an editing context that's connected to the default EOObjectStoreCoordinator. You can change this default setting by initializing an EOEditingContext with a particular parent EOObjectStore. This is useful if you want your EOEditingContext to use a different EOObjectStoreCoordinator than the default, or if your EOEditingContext is nested. For example, the following code excerpt initializes <B>childEditingContext</B> with a parent object store <B>parentEditingContext</B>:<p>

<blockquote><pre>EOEditingContext *parentEditingContext;     // Assume this exists.

</pre></blockquote><p>

<blockquote><pre>EOEditingContext *childEditingContext = [[EOEditingContext alloc]

</pre></blockquote><p>

<blockquote><pre>    initWithParentObjectStore:parentEditingContext];

</pre></blockquote><p>

For more discussion of working programmatically with EOEditingContexts, see the chapter "Application Configurations" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>

<a name="1497">

<h4> Accessing An Editing Context's Adaptor Level Objects</h4>

</a>You can use an EOEditingContext with any EOObjectStore. However, in a typical configuration, you use an EOEditingContext with the objects in the access layer. To access an EOEditingContext's adaptor level objects, you get the editing context's EOObjectStoreCoordinator from the editing context, you get an EODatabaseContext from the object store coordinator, and you get the adaptor level objects from there. The following code demonstrates the process.<p>

<blockquote><pre>EOEditingContext *editingContext;    // Assume this exists.

</pre></blockquote><p>

<blockquote><pre>NSString *myEntityName;              // Assume this exists.     

</pre></blockquote><p>

<blockquote><pre>EOFetchSpecification *fspec;    

</pre></blockquote><p>

<blockquote><pre>EOObjectStoreCoordinator *rootStore;

</pre></blockquote><p>

<blockquote><pre>EODatabaseContext *dbContext;

</pre></blockquote><p>

<blockquote><pre>EOAdaptor *adaptor;

</pre></blockquote><p>

<blockquote><pre>EOAdaptorContext *adContext;

</pre></blockquote><p>

<blockquote><pre>fspec = [EOFetchSpecification fetchSpecificationWithEntityName:myEntityName<br>    qualifier:nil<br>    sortOrderings:nil];

</pre></blockquote><p>

<blockquote><pre>rootStore = (EOCooperatingObjectStore *)[editingContext rootObjectStore];

</pre></blockquote><p>

<blockquote><pre>dbContext = [rootStore objectStoreForFetchSpecification:fspec];

</pre></blockquote><p>

<blockquote><pre>adaptor = [[dbContext database] adaptor];

</pre></blockquote><p>

<blockquote><pre>adContext = [dbContext adaptorContext];

</pre></blockquote><p>

This example first creates a fetch specification, providing just the entity name as an argument. Of course, you can use a fetch specification that has non-<B>nil</B> values for all of its arguments, but only the entity name is used by the EOObjectStore <B>objectStoreForFetchSpecification:</B> method. Next, the example gets the editing context's EOObjectStoreCoordinator using the EOEditingContext method <B>rootObjectStore</B>. <B>rootObjectStore</B> returns an EOObjectStore and not an EOObjectStoreCoordinator, because it's possible to substitute a custom object store in place of an object store coordinator. Similarly, the EOObjectStoreCoordinator method <B>objectStoreForFetchSpecification:</B> returns an EOCooperatingObjectStore instead of an EODatabaseContext because it's possible to substitute a custom cooperating object store in place of a database context. If your code performs any such substitutions, you should alter the above code example to match your custom object store's API. See the class specifications for EOObjectStore, EOObjectStoreCoordinator, and EOCooperatingObjectStore for more information.<p>

An EOEditingContext's EOObjectStoreCoordinator can have more than one set of database and adaptor level objects. Consequently, to get a database context from the object store coordinator, you have to provide information that the coordinator can use to choose the correct database context. The code example above provides an EOFetchSpecification using the method <B>objectStoreForFetchSpecification:</B>, but you could specify different criteria by using one of the following EOObjectStoreCoordinator methods instead:<p>

<dl><dt><a href="../EOObjectStoreCoordinator/EOObjectStoreCoordinator.html#//apple_ref/occ/instm/EOObjectStoreCoordinator/cooperatingObjectStores" target="_top">cooperatingObjectStores</a>

<dl><dt>Returns an array of the EOObjectStoreCoordinator's cooperating object stores.

</dl><dt><a href="../EOObjectStoreCoordinator/EOObjectStoreCoordinator.html#//apple_ref/occ/instm/EOObjectStoreCoordinator/objectStoreForGlobalID:" target="_top">objectStoreForGlobalID:</a>

<dl><dt>Returns the cooperating object store for the enterprise object identified by the provided EOGlobalID<em>.

</em></dl><dt><a href="../EOObjectStoreCoordinator/EOObjectStoreCoordinator.html#//apple_ref/occ/instm/EOObjectStoreCoordinator/objectStoreForObject:" target="_top">objectStoreForObject:</a>

<dl><dt>Returns the cooperating object store for the provided enterprise object.

</dl></dl>After you have the database context, you can get the corresponding EOAdaptor and EOAdaptorContext as shown above.<p>

<a name="1025">

<h3> Using EOEditingContexts in Different Configurations</h3>

</a>The fundamental relationship an EOEditingContext has is to its parent EOObjectStore, which creates the object graph the EOEditingContext monitors. EOObjectStore is an abstract class that defines a source and sink of objects for an EOEditingContext. The EOObjectStore is responsible for constructing and registering objects, servicing object faults, and committing changes made in an EOEditingContext.<p>

You can augment the basic configuration of an EOEditingContext and its parent EOObjectStore in several different ways. For example, multiple EOEditingContexts can share the same EOObjectStore, one EOEditingContext can act as an EOObjectStore for another, and so on. The most commonly used scenarios are described in the following sections.<p>

<a name="989">

<h4> Peer EOEditingContexts</h4>

</a>One or more "peer" EOEditingContexts can share a single EOObjectStore (<a href="#992">Figure 1</a>). Each EOEditingContext has its own object graph-so, for example, a given Employee row in a database can have separate object instances in each EOEditingContext. Changes to an object in one EOEditingContext don't affect the corresponding object in another EOEditingContext until all changes are successfully committed to the shared object store. At that time the objects in all EOEditingContexts are synchronized with the committed changes. This arrangement is useful when an application allows the user to edit multiple independent "documents."<p>

<img src="../EOEditingContext.anc.gif"><p>

<a name="992">

<b>Figure 1 </b> Peer EOEditingContexts



</a><a name="993">

<h4> Nested EOEditingContexts</h4>

</a>EOEditingContext is a subclass of EOObjectStore, which gives its instances the ability to act as EOObjectStores for other EOEditingContexts. In other words, EOEditingContexts can be nested (<a href="#996">Figure 2</a>), thereby allowing a user to make edits to an object graph in one EOEditingContext and then discard or commit those changes to another object graph (which, in turn, may commit them to an external store). This is useful in a "drill down" style of user interface where changes in a nested dialog can be okayed (committed) or canceled (rolled back) to the previous panel.<p>

<img src="../EOEditingContext.anc1.gif"><p>

<a name="996">

<b>Figure 2 </b> Nested EOEditingContexts



</a>When an object is fetched into a nested EOEditingContext, it incorporates any uncommitted changes that were made to it in its parent EOEditingContext. For example, suppose that in one panel you have a list of employees that allows you to edit salaries, and that the panel includes a button to display a nested panel where you can edit detail information. If you edit the salary in the parent panel, you see the modified salary in the nested panel, not the old (committed) salary from the database. Thus, conceptually, nested EOEditingContexts fetch through their parents.<p>

EOEditingContext overrides several of EOObjectStore's methods:<p>

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/arrayFaultWithSourceGlobalID:relationshipName:editingContext:">- arrayFaultWithSourceGlobalID:relationshipName:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/faultForGlobalID:editingContext:">- faultForGlobalID:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/invalidateAllObjects">- invalidateAllObjects</a></a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/invalidateObjectsWithGlobalIDs:">- invalidateObjectsWithGlobalIDs:</a></a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectsForSourceGlobalID:relationshipName:editingContext:">- objectsForSourceGlobalID:relationshipName:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectsWithFetchSpecification:editingContext:">- objectsWithFetchSpecification:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/refaultObject:withGlobalID:editingContext:">- refaultObject:withGlobalID:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/saveChangesInEditingContext:">- saveChangesInEditingContext:</a></a>

</dl>These methods are generally used when an EOEditingContext acts as an EOObjectStore for another EOEditingContext. For more information, see the individual method descriptions. For information on setting up this configuration for interfaces loaded from nib files, see the method description for <B>setDefaultParentObjectStore:</B>.<p>

For a description of how to implement nested EOEditingContexts, see the chapter "Application Configurations" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>

<a name="1008">

<h4> Getting Data from Multiple Sources</h4>

</a>An EOEditingContext's object graph can contain objects from more than one external store (<a href="#1011">Figure 3</a>). In this scenario, the object store is an EOObjectStoreCoordinator, which provides the abstraction of a single object store by redirecting operations to one or more EOCooperatingObjectStores.<p>

<img src="../EOEditingContext.anc2.gif"><p>

<a name="1011">

<b>Figure 3 </b> An EOEditingContext Containing Objects from Multiple Sources



</a>In writing an application, it's likely that you'll use combinations of the different scenarios described in the above sections. <p>

<a name="1013">

<h3> Fetching Objects</h3>

</a>The most common way to explicitly fetch objects from an external store in an Enterprise Objects Framework application is to use EOEditingContext's <B>objectsWithFetchSpecification:</B> method. This method takes a fetch specification and returns an NSArray of objects. A fetch specification includes the name of the entity for which you want to fetch objects, the qualifier (query) you want to use in the fetch, and the sort order in which you want the objects returned (if any). For example, the following code excerpt uses <B>objectsWithFetchSpecification:</B> to fetch all video store members who have Visa credit cards:<p>

<blockquote><pre>EOFetchSpecification *fetchSpec;

</pre></blockquote><p>

<blockquote><pre>NSArray *results;

</pre></blockquote><p>

<blockquote><pre>fetchSpec = [EOFetchSpecification 

</pre></blockquote><p>

<blockquote><pre>    fetchSpecificationWithEntityName:@"Member"

</pre></blockquote><p>

<blockquote><pre>    qualifier:[EOQualifier qualifierWithQualifierFormat:

</pre></blockquote><p>

<blockquote><pre>    @"cardType = 'Visa' "]

</pre></blockquote><p>

<blockquote><pre>    sortOrderings:nil];    

</pre></blockquote><p>

<blockquote><pre>results = [editingContext objectsWithFetchSpecification:fetchSpec];

</pre></blockquote><p>

Note that objects are allocated in the same zone as the EOEditingContext into which they're fetched.<p>

<a name="1019">

<h3> Managing Changes in Your Application</h3>

</a>EOEditingContext provides several methods for managing the changes made to objects in your application. You can use these methods to get information about objects that have changed, to selectively undo and redo changes, and to discard all changes made to objects before these changes are committed to the database. These methods are described in the following sections.<p>

<a name="1021">

<h4> Getting Information About Changed Objects</h4>

</a>An EOEditingContext maintains information about three different kinds of changes to objects in its object graph: insertions, deletions, and updates. After these changes have been made and before they're committed to the database, you can find out which objects have changes in each of these categories by using the <B>insertedObjects</B>, <B>deletedObjects</B>, and <B>updatedObjects</B> methods. Each method returns an NSArray containing the objects that have been inserted, deleted, and updated, respectively. The <B>hasChanges</B> method returns YES or NO to indicate whether any of the objects in the object graph have been inserted, deleted, or updated.<p>

<a name="1023">

<h4> Undo and Redo</h4>

</a>EOEditingContext includes the <B><a href="#1361"></B><B>undo: </B><B></a></B>, <B><a href="#1281"></B><B>redo: </B><B></a></B>, and <B><a href="#1309"></B><B>revert: </B><B></a></B> methods for managing changes to objects in the object graph. <B><a href="#1361"></B><B>undo: </B><B></a></B> asks the EOEditingContext's EOUndoManager to reverse the latest changes to objects in the object graph. <B><a href="#1281"></B><B>redo: </B><B></a></B> asks the EOUndoManager to reverse the latest undo operation. <B><a href="#1309"></B><B>revert: </B><B></a></B> clears the undo stack, discards all insertions and deletions, and restores updated objects to their last committed (saved) values. The <a href="#1361"><B>undo: </B></a> and <a href="#1309"><B>revert: </B></a> methods are also discussed in the context of managing the object graph, below.<p>

<a name="1028">

<h4> Saving Changes</h4>

</a>The <B>saveChanges</B> method commits changes made to objects in the object graph to an external store. When you save changes, EOEditingContext's lists of inserted, updated, and deleted objects are flushed.<p>

Upon a successful save operation, the EOEditingContext's parent EOObjectStore broadcasts an EOObjectsChangedInStoreNotification. Peers of the saved EOEditingContext receive this notification and respond by synchronizing their objects with the committed versions.<p>

<a name="1449">

<h3> Methods for Managing the Object Graph</h3>

</a>EOEditingContext provides methods for managing the enterprise objects in the context's object graph. This section describes these methods, as well as other techniques you can use to manage the object graph.<p>

At different points in your application, you might want to do the following:<p>

<ul><li>Break retain cycles between enterprise objects<p><li>Discard changes that have been made to enterprise objects <p><li>Make sure that when you refetch objects from the database, any changed database values are used instead of the original values<p><li>Discard the view of objects cached in memory<p><li>Work with objects across multiple editing contexts<p></ul>These scenarios are discussed in the following sections.<p>

<a name="1454">

<h4> Breaking Retain Cycles</h4>

</a>You use the EOEditingContext methods <B>refaultObjects</B> and <B>refaultObject:withGlobalID:editingContext:</B> to break retain cycles between your enterprise objects. For example, suppose you have an Employee object that has a to-one relationship to its Department, and the Department object in turn has an array of Employee objects. This circular reference constitutes a retain cycle, which you can break using the <B>refault...</B> methods. <p>

<B>Note:	</B>

Retain cycles are automatically broken if you release the EOEditingContext. 

<p>You should use the <B>refault...</B> methods with caution, since refaulting an object doesn't remove the object snapshot from the undo stack. Objects that have been newly inserted or deleted should not be refaulted. In general, it's safer to use <a href="#1288"><B>refaultObjects </B></a> than it is to use <a href="#1291"><B>refaultObject:withGlobalID:editingContext: </B></a> since <a href="#1288"><B>refaultObjects </B></a> only refaults objects that haven't been inserted, deleted or updated. <a href="#1291"><B>refaultObject:withGlobalID:editingContext: </B></a> doesn't make this distinction, so you should only use it when you're sure you know what you're doing.<p>

If you want to reset your EOEditingContext and free all of its objects, do the following:<p>

<blockquote><pre>EOEditingContext *editingContext;     // Assume this exists.

</pre></blockquote><p>

<blockquote><pre>[editingContext revert];               // Discard uncommitted changes

</pre></blockquote><p>

<blockquote><pre>[editingContext refaultObjects];

</pre></blockquote><p>

Note that you must release any other retains on the enterprise objects in the EOEditingContext for them to actually be freed. For example, to clear a display group that references a list of enterprise objects, you'd do something like the following:<p>

<blockquote><pre>[displayGroup setObjectArray:nil];

</pre></blockquote><p>

Releasing the EODisplayGroup (and any user interface objects that refer to it) also has the effect of releasing the object array.<p>

Using the <B>invalidate...</B> methods (described below) also has the effect of breaking retain cycles, but these methods have a more far-reaching effect. It's not recommended that you use them simply to break retain cycles.<p>

<a name="1456">

<h4> Discarding Changes to Enterprise Objects</h4>

</a>EOEditingContext provides different techniques for discarding changes to enterprise objects. These techniques are as follows:<p>

<ul><li>Perform a simple <B><a href="#1361"></B><B>undo: </B><B></a></B>, which reverses the latest uncommitted changes applied to objects in the object graph.<p><li>Invoke the EOEditingContext method <B>revert</B>, which removes everything from the undo stack, discards all insertions and deletions, and restores updated objects to their last committed values. If you just want to discard uncommitted changes but you don't want to sacrifice the original values from the database cached in memory, use the <B>revert</B> method.<p></ul>A different approach is to use the <B>invalidate...</B> methods, described in "<a href="#1222">Discarding the View of Objects Cached in Memory</a>."<p>

<a name="1521">

<h4> Refreshing Objects </h4>

</a>One characteristic of an object graph is that it represents an internally consistent view of your application's data. By default, when you refetch data, Enterprise Objects Framework maintains the integrity of your object graph by not overwriting your object values with database values that have been changed by someone else. But what if you want your application to see those changes? You can accomplish this by using the EOFetchSpecification method <B>setRefreshesRefetchedObjects:</B>. Invoking <B>setRefreshesRefetchedObjects:</B> with the argument YES causes  existing objects to be overwritten with fetched values that have been changed. Alternatively, you can use the EODatabaseContext delegate method <B>databaseContext:shouldUpdateCurrentSnapshot:newSnapshot:globalID:channel:.</B><p>

Normally, when you set an EOFetchSpecification to refresh using <B>setRefreshesRefetchedObjects:</B>, it only refreshes the objects you're fetching. For example, if you refetch employees, you don't also refetch the employees' departments. However, if you use the EOPrefetchingRelationshipHintKey with an EOFetchSpecification in the EODatabaseContext method <B>objectsWithFetchSpecification:editingContext:</B>, the refetch is propagated for all of the fetched objects' relationships that are specified for the hint. For more discussion of this topic, see the EODatabaseContext class specification.<p>

Refreshing refetched objects only affects the objects you specify. If you want to refetch your entire object graph, you can use the EOEditingContext<B> invalidate...</B> methods, described below.<p>

<a name="1222">

<h4> Discarding the View of Objects Cached in Memory</h4>

</a>As described in the section "<a href="#1456">Discarding Changes to Enterprise Objects</a>," you can use <B>undo:</B> or <B>revert</B> to selectively discard the changes you've made to enterprise objects. Using these methods preserves the original cache of values fetched from the database. But what if you want to flush your in-memory object view all together-in the most likely scenario, to see changes someone else has made to the database? You can invalidate your enterprise objects using the <B>invalidateAllObjects</B> or the <B>invalidateObjectsWithGlobalIDs:</B> method. (You can also use the action method <B>refetch:</B>, which simply invokes <B>invalidateAllObjects</B>). Unlike fetching with the EOFetchSpecification method <B>setRefreshesRefetchedObjects: </B> set to YES (described above), the <B>invalidate...</B> methods result in the refetch of your entire object graph. <p>

The effect of the<B> <a href="#1220"></B><B>invalidateAllObjects </B><B></a></B> method depends on how you use it. For example, if you send<B> <a href="#1220"></B><B>invalidateAllObjects </B><B></a></B> to an EOEditingContext, it sends<B> <a href="#1225"></B><B>invalidateObjectsWithGlobalIDs: </B><B></a></B> to its parent object store with all the globalIDs for the objects registered in it. If the EOEditingContext is nested, its parent object store is another EOEditingContext; otherwise its parent object store is typically an EOObjectStoreCoordinator. Regardless, the message is propagated down the object store hierarchy. Once it reaches the EOObjectStoreCoordinator, it's propagated to the EODatabaseContext(s). The EODatabaseContext discards the row snapshots for these globalIDs and sends an EOObjectsChangedInStoreNotification, thereby refaulting all the enterprise objects in the object graph. This refaulting in turn releases all objects not retained by your application or by an EODisplayGroup. The next time you access one of these objects, it's refetched from the database.<p>

Sending <B>invalidateAllObjects</B> to an EOEditingContext affects not only that context's objects, but objects with the same globalIDs in other EOEditingContexts. For example, suppose <em>editingContext1</em> has <em>objectA</em> and <em>objectB</em>, and <em>editingContext2</em> has <em>objectA</em>, <em>objectB</em>, and <em>objectC</em>. When you send <B>invalidateAllObjects</B> to <em>editingContext1</em>, <em>objectA</em> and <em>objectB</em> are refaulted in both <em>editingContext1</em> and <em>editingContext2</em>. However, <em>objectC</em> in <em>editingContext2</em> is left intact since <em>editingContext1</em> doesn't have an <em>objectC</em>. <p>

If you send<B> <a href="#1220"></B><B>invalidateAllObjects </B><B></a></B> directly to the EOObjectStoreCoordinator, it sends<B> <a href="#1220"></B><B>invalidateAllObjects </B><B></a></B> to all of its EODatabaseContexts, which then discard all of the snapshots in your application and refault every single enterprise object in all of your EOEditingContexts.<p>

The <B>invalidate...</B> methods are the only way to get rid of a database lock without saving your changes.<p>

<a name="1525">

<h4> Working with Objects Across Multiple EOEditingContexts</h4>

</a>Any time your application is using more than one EOEditingContext (as described in the section "<a href="#1025">Using EOEditingContexts in Different Configurations</a>"), it's likely that one editing context will need to access objects in another.<p>

On the face of it, it may seem like the most reasonable solution would be for the first editing context to just get a pointer to the desired object in the second editing context and modify the object directly. But this would violate the cardinal rule of keeping each editing context's object graph internally consistent. Instead of modifying the second editing context's object, the first editing context needs to get its own copy of the object. It can then modify its copy without affecting the original. When it saves changes, they're propagated to the original object, down the object store hierarchy. The method that you use to give one editing context its own copy of an object that's in another editing context is <a href="#1182"><B>faultForGlobalID:editingContext: </B></a>.<p>

For example, suppose you have a nested editing context configuration in which a user interface displays a list of objects-this maps to the parent editing context. From the list, the user can select an object to inspect and modify in a "detail" panel-this maps to the child editing context. To give the child its own copy of the object to modify in the detail panel, you would do something like the following:<p>

<blockquote><pre>EOEditingContext *childEC, *parentEC;      // Assume these exist.

</pre></blockquote><p>

<blockquote><pre>id newObject = [childEC faultForGlobalID:[parentEC globalIDForObject:origObject]<br>    editingContext:childEC];

</pre></blockquote><p>

where <B>origObject</B> is the object the user selected for inspection in the list panel.<p>

The child can make changes to <B>newObject</B> without affecting <B>origObject</B> in the parent. Then when the child saves changes, <B>origObject</B> is updated accordingly. <p>

<a name="1031">

<h3> General Guidelines for Managing the Object Graph</h3>

</a>When you fetch objects into your application, you create a graph of objects instantiated from database data. From that point on, your focus should be on working with the object graph-not on interacting with your database. This distinction is an important key to working with Enterprise Objects Framework.<p>

<a name="1459">

<h4> You don't have to worry about the database...</h4>

</a>One of the primary benefits of Enterprise Objects Framework is that it insulates you from having to worry about database details. Once you've defined the mapping between your database and your enterprise objects in a model file, you don't need to think about issues such as foreign key propagation, how object deletions are handled, how operations in the object graph are reflected in your database tables, and so on. <p>

This can be illustrated by considering the common scenario in which one object has a relationship to another. For example, suppose an Employee has a relationship to a Department. In the object graph, this relationship is simply expressed as an Employee object having a pointer to its Department object. The Department object might in turn have a pointer to an array of Employee objects. When you manipulate relationships in the object graph (for example, by moving an Employee to a different Department), Enterprise Objects Framework changes the appropriate relationship pointers. For example, moving an Employee to a different Department changes the Employee's department pointer and adds the Employee to the new Department's employee array. When you save your changes to the database, Enterprise Objects Framework knows how to translate these object graph manipulations into database operations. <p>

<a name="1468">

<h4> ...but you do have to worry about the object graph</h4>

</a>As described above, you generally don't need to concern yourself with how changes to the object graph are saved to the database. However, you do need to concern yourself with managing the object graph itself. Since the object graph is intended to represent an internally consistent view of your application's data, one of your primary considerations should be maintaining its consistency. For example, suppose you have a relationship from Employee to Project, and from Employee to Manager. When you create a new Employee object, you must make sure that it has relationships to the appropriate Projects and to a Manager. <p>

Just as you need to maintain the internal consistency of an EOEditingContext's object graph, you should never directly modify the objects in one EOEditingContext from another EOEditingContext. If you do so, you risk creating major synchronization problems in your application. If you need to access the objects in one EOEditingContext from another, use the method <a href="#1182"><B>faultForGlobalID:editingContext: </B></a>, as described in "<a href="#1525">Working with Objects Across Multiple EOEditingContexts</a>." This gives the receiving EOEditingContext its own copy of the object, which it can modify without affecting the original. Then when it saves its changes, the original is updated accordingly.<p>

One of the implications of needing to maintain the consistency of your object graph is that you should never copy an enterprise object (though you can snapshot its properties), since this would be in conflict with uniquing. Uniquing dictates that an EOEditingContext can have one and only one copy of a particular object. For more discussion of uniquing, see the chapter "Behind the Scenes" in the <em>Enterprise Objects Framework Developer's Guide</em>. Similarly, you shouldn't override the <B>isEqual:</B> method in your enterprise objects. Enterprise Objects Framework relies on the default NSObject implementation to check instance (pointer) equality rather than value equality.<p>

<a name="1447">

<h3> Using EOEditingContext to Archive Custom Objects in Web Objects Framework </h3>

</a>In WebObjects, applications that use the Enterprise Objects Framework must enlist the help of the EOEditingContext to archive enterprise objects. The primary reason is so that the EOEditingContext can keep track, from one transaction to the next, of the objects it manages. But using an EOEditingContext for archiving also benefits your application in these other ways:<p>

<ul><li>During archiving, an EOEditingContext stores only as much information about its enterprise objects as is needed to reconstitute the object graph at a later time. For example, unmodified objects are stored as simple references (by globalID) that will allow the EOEditingContext to recreate the object from the database. Thus, your application can store state very efficiently by letting an EOEditingContext archive your enterprise objects.<p><li>During unarchiving, an EOEditingContext can recreate individual objects in the graph only as they are needed by the application. This approach can significantly improve application performance.<p></ul>An enterprise object (like any other object that uses the OpenStep archiving scheme) makes itself available for archiving by declaring that it conforms to the NSCoding protocol and by implementing the protocol's two methods, <B>encodeWithCoder:</B> and <B>initWithCoder:</B>. It implements these methods like this:<p>

<blockquote><pre>- (void)encodeWithCoder:(NSCoder *)aCoder {

</pre></blockquote><p>

<blockquote><pre>    [EOEditingContext encodeObject:self withCoder:aCoder];

</pre></blockquote><p>

<blockquote><pre>}

</pre></blockquote><p>

<blockquote><pre>- (id)initWithCoder:(NSCoder *)aDecoder {

</pre></blockquote><p>

<blockquote><pre>    [EOEditingContext initObject:self withCoder:aDecoder];

</pre></blockquote><p>

<blockquote><pre>    return self;

</pre></blockquote><p>

<blockquote><pre>}

</pre></blockquote><p>

The enterprise object simply passes on responsibility for archiving and unarchiving itself to the EOEditingContext class, by invoking the <B>encodeObject:withCoder:</B> and <B>initObject:withCoder:</B> class methods and passing a reference to itself (<B>self</B>) as one of the arguments. The EOEditingContext takes care of the rest. For more discussion of <B>encodeWithCoder:</B> and <B>initWithCoder:</B>, see the NSCoding protocol specification in the Foundation Framework.<p>

EOEditingContext includes two additional methods that affect the archiving and unarchiving of objects: <B>setUsesContextRelativeEncoding:</B> and <B>usesContextRelativeEncoding</B>. When you use context relative encoding, it means that enterprise objects that archive themselves using the EOEditingContext <B>encodeObject:withCoder:</B> method archive their current state (that is, all of their class properties) only if they (the objects) are marked as inserted or updated in the EOEditingContext. Otherwise, they archive just their globalID's since their state matches what's stored in the database and can be retrieved from there. If <B>usesContextRelativeEncoding</B> returns NO, it means the current state will always be archived, even if the enterprise object is unmodified. The default is NO for OpenStep applications, and YES for WebObjects applications.<p>

<HR WIDTH=50% ALIGN=LEFT>

<h2>Adopted Protocols</h2>  

 



<dl><dt> EOObserving

<dl><dt>- objectWillChange:

</dl></dl> <p>

<dl><dt>Initializing an EOEditingContext

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/initWithParentObjectStore:">- initWithParentObjectStore:</a>

</dl><dt>Fetching objects

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectsWithFetchSpecification:">- objectsWithFetchSpecification:</a>

</dl><dt>Nested EOEditingContext support

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectsWithFetchSpecification:editingContext:">- objectsWithFetchSpecification:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectsForSourceGlobalID:relationshipName:editingContext:">- objectsForSourceGlobalID:relationshipName:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/arrayFaultWithSourceGlobalID:relationshipName:editingContext:">- arrayFaultWithSourceGlobalID:relationshipName:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/faultForGlobalID:editingContext:">- faultForGlobalID:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/saveChangesInEditingContext:">- saveChangesInEditingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/refaultObject:withGlobalID:editingContext:">- refaultObject:withGlobalID:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/invalidateObjectsWithGlobalIDs:">- invalidateObjectsWithGlobalIDs:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/initializeObject:withGlobalID:editingContext:">- initializeObject:withGlobalID:editingContext:</a>

</dl><dt>Committing or discarding changes

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/saveChanges">- saveChanges</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/saveChanges:">- saveChanges:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/tryToSaveChanges">- tryToSaveChanges</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/refaultObjects">- refaultObjects</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/refault:">- refault:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/refetch:">- refetch:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/revert">- revert</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/revert:">- revert:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/invalidateAllObjects">- invalidateAllObjects</a>

</dl><dt>Object registration and snapshotting

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/forgetObject:">- forgetObject:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/recordObject:globalID:">- recordObject:globalID:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/committedSnapshotForObject:">- committedSnapshotForObject:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/currentEventSnapshotForObject:">- currentEventSnapshotForObject:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectForGlobalID:">- objectForGlobalID:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/registeredObjects">- registeredObjects</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/globalIDForObject:\t"><a href="#1195">- globalIDForObject:</a>	</a>

</dl><dt>Locking objects

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/lockObject:">- lockObject:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/lockObjectWithGlobalID:editingContext:">- lockObjectWithGlobalID:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/isObjectLockedWithGlobalID:editingContext:">- isObjectLockedWithGlobalID:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/setLocksObjectsBeforeFirstModification:">- setLocksObjectsBeforeFirstModification:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/locksObjectsBeforeFirstModification">- locksObjectsBeforeFirstModification</a>

</dl><dt>Registering changes

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/deleteObject:">- deleteObject:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/insertObject:">- insertObject:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/insertObject:withGlobalID:">- insertObject:withGlobalID:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/objectWillChange:">- objectWillChange:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/processRecentChanges">- processRecentChanges</a>

</dl><dt>Checking changes

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/deletedObjects">- deletedObjects</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/insertedObjects">- insertedObjects</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/updatedObjects">- updatedObjects</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/hasChanges">- hasChanges</a>

</dl><dt>Undo

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/redo:">- redo:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/undo:">- undo:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/undoManager">- undoManager</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/setUndoManager:">- setUndoManager:</a>

</dl><dt>Deletion and Validation Behavior

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/setPropagatesDeletesAtEndOfEvent:">- setPropagatesDeletesAtEndOfEvent:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/propagatesDeletesAtEndOfEvent">- propagatesDeletesAtEndOfEvent</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/setStopsValidationAfterFirstError:">- setStopsValidationAfterFirstError:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/stopsValidationAfterFirstError">- stopsValidationAfterFirstError</a>

</dl><dt>Unarchiving from nib

<dl><dt><a href="#//apple_ref/occ/clm/EOEditingContext/defaultParentObjectStore">+ defaultParentObjectStore</a>

<dt><a href="#//apple_ref/occ/clm/EOEditingContext/setDefaultParentObjectStore:"><a href="#1130">+ setDefaultParentObjectStore:</a> </a>

<dt><a href="#//apple_ref/occ/clm/EOEditingContext/setSubstitutionEditingContext:">+ setSubstitutionEditingContext:</a>

<dt><a href="#//apple_ref/occ/clm/EOEditingContext/substitutionEditingContext">+ substitutionEditingContext</a>

</dl><dt>Returning related object stores

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/parentObjectStore">- parentObjectStore</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/rootObjectStore">- rootObjectStore</a>

</dl><dt>Managing editors

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/editors">- editors</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/addEditor:">- addEditor:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/removeEditor:">- removeEditor:</a>

</dl><dt>Setting the delegate

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/setDelegate:">- setDelegate:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/delegate">- delegate</a>

</dl><dt>Setting the message handler

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/setMessageHandler:">- setMessageHandler:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/messageHandler">- messageHandler</a>

</dl><dt>Invalidating objects

<dl><dt><a href="#//apple_ref/occ/instm/EOEditingContext/setInvalidatesObjectsWhenFreed:">- setInvalidatesObjectsWhenFreed:</a>

<dt><a href="#//apple_ref/occ/instm/EOEditingContext/invalidatesObjectsWhenFreed">- invalidatesObjectsWhenFreed</a>

</dl><dt>Archiving and unarchiving objects

<dl><dt><a href="#//apple_ref/occ/clm/EOEditingContext/encodeObject:withCoder:">+ encodeObject:withCoder:</a>

<dt><a href="#//apple_ref/occ/clm/EOEditingContext/initObject:withCoder:">+ initObject:withCoder:</a>

<dt><a href="#//apple_ref/occ/clm/EOEditingContext/setUsesContextRelativeEncoding:">+ setUsesContextRelativeEncoding:</a>

<dt><a href="#//apple_ref/occ/clm/EOEditingContext/usesContextRelativeEncoding">+ usesContextRelativeEncoding</a>

</dl></dl><a name="1117">

<a name="clm"></a>

<h3>Class Methods  </h3>

</a><a name="1118">

<h4> <a name="//apple_ref/occ/clm/EOEditingContext/encodeObject:withCoder:">encodeObject:withCoder:</a></h4>

</a>+ (void)<B>encodeObject:</B>(id)<em>object</em> <B>withCoder:</B>(NSCoder *)<em>encoder</em><p>

Invoked by an enterprise object <em>object</em> to ask the EOEditingContext to encode <em>object</em> using <em>encoder</em>. For more discussion of this subject, see "<a href="#1447">Using EOEditingContext to Archive Custom Objects in Web Objects Framework</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/EOEditingContext/initObject:withCoder:">+ initObject:withCoder:</a> </B>, <a href="#//apple_ref/occ/clm/EOEditingContext/setUsesContextRelativeEncoding:"><B>+ setUsesContextRelativeEncoding:</a> </B>, 

<B><a href="#//apple_ref/occ/clm/EOEditingContext/usesContextRelativeEncoding">+ usesContextRelativeEncoding</a>

 </B><p><a name="1122">

<h4> <a name="//apple_ref/occ/clm/EOEditingContext/defaultParentObjectStore">defaultParentObjectStore</a></h4>

</a>+ (EOObjectStore *)<B>defaultParentObjectStore</B> <p>

Returns the default parent EOObjectStore. Normally this is the EOObjectStoreCoordinator returned from the invocation <code>[EOObjectStoreCoordinator defaultCoordinator]</code>. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/EOEditingContext/setDefaultParentObjectStore:">+ setDefaultParentObjectStore:</a>

 </B><p><a name="1126">

<h4> <a name="//apple_ref/occ/clm/EOEditingContext/initObject:withCoder:">initObject:withCoder:</a></h4>

</a>+ (id)<B>initObject:</B>(id)<em>object</em> <B>withCoder:</B>(NSCoder *)<em>decoder</em><p>

Invoked by an enterprise object <em>object</em> to ask the EOEditingContext to initialize <em>object</em> from data in <em>decoder</em>. For more discussion of this subject, see "<a href="#1447">Using EOEditingContext to Archive Custom Objects in Web Objects Framework</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/EOEditingContext/encodeObject:withCoder:">+ encodeObject:withCoder:</a> </B>, <a href="#//apple_ref/occ/clm/EOEditingContext/setUsesContextRelativeEncoding:"><B>+ setUsesContextRelativeEncoding:</a> </B>, 

<B><a href="#//apple_ref/occ/clm/EOEditingContext/usesContextRelativeEncoding">+ usesContextRelativeEncoding</a>

 </B><p><a name="1130">

<h4> <a name="//apple_ref/occ/clm/EOEditingContext/setDefaultParentObjectStore:">setDefaultParentObjectStore:</a></h4>

</a>+ (void)<B>setDefaultParentObjectStore:</B>(EOObjectStore *)<em>store</em> <p>

Sets to <em>store</em> the<em> </em>default parent EOObjectStore. You use this method before loading a nib file to change the default parent EOObjectStores of the EOEditingContexts in the nib file. The object you supply for <em>store</em> can be a different EOObjectStoreCoordinator or another EOEditingContext (if you're using a nested EOEditingContext). After loading a nib with an EOEditingContext substituted as the default parent EOObjectStore, you should restore the default behavior by setting the default parent EOObjectStore to <B>nil</B>. For example:<p>

<blockquote><pre>[EOEditingContext setDefaultParentObjectStore:editingContext];

</pre></blockquote><p>

<blockquote><pre>nibLoaded = [NSBundle loadNibNamed:@"thirdNib" owner:self];

</pre></blockquote><p>

<blockquote><pre>[EOEditingContext setDefaultObjectStore:nil]; // Restore default

</pre></blockquote><p>

This substitution is global until it is changed again. For more discussion of this topic, see the chapter "Application Configurations" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/clm/EOEditingContext/defaultParentObjectStore"></em><B>+ defaultParentObjectStore </a>

 </B><p><a name="1134">

<h4> <a name="//apple_ref/occ/clm/EOEditingContext/setSubstitutionEditingContext:">setSubstitutionEditingContext:</a></h4>

</a>+ (void)<B>setSubstitutionEditingContext:</B>(EOEditingContext *)<em>anEditingContext</em> <p>

Sets to <em>anEditingContext</em> an EOEditingContext you want to substitute for the one specified in a nib file you're about to load. Using this method causes all of the connections in your nib file to be redirected to <em>anEditingContext</em>. This can be useful when you want an interface loaded from a second nib file to use an existing EOEditingContext. After loading a nib with a substitution EOEditingContext, you should restore the default behavior by setting the substitution EOEditingContext to <B>nil</B>. For example: <p>

<blockquote><pre>[EOEditingContext setSubstitutionEditingContext:editingContext];

</pre></blockquote><p>

<blockquote><pre>nibLoaded = [NSBundle loadNibNamed:@"thirdNib" owner:self];

</pre></blockquote><p>

<blockquote><pre>[EOEditingContext setSubstitutionEditingContext:nil]; // Restore default

</pre></blockquote><p>

This substitution is global until it is changed again. For more discussion of this topic, see the chapter "Application Configurations" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/clm/EOEditingContext/substitutionEditingContext"></em><B>+ substitutionEditingContext</a>

 </B><p><a name="1138">

<h4> <a name="//apple_ref/occ/clm/EOEditingContext/setUsesContextRelativeEncoding:">setUsesContextRelativeEncoding:</a></h4>

</a>+ (void)<B>setUsesContextRelativeEncoding:</B>(BOOL)<em>flag</em><p>

Sets according to <em>flag</em> whether an EOEditingContext uses context-relative encoding. For more discussion of this subject, see "<a href="#1447">Using EOEditingContext to Archive Custom Objects in Web Objects Framework</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/EOEditingContext/usesContextRelativeEncoding">+ usesContextRelativeEncoding</a> </B>, <a href="#//apple_ref/occ/clm/EOEditingContext/encodeObject:withCoder:"><B>+ encodeObject:withCoder:</a> </B>, <a href="#//apple_ref/occ/clm/EOEditingContext/initObject:withCoder:"><B>+ initObject:withCoder:</a>

 </B><p><a name="1142">

<h4> <a name="//apple_ref/occ/clm/EOEditingContext/substitutionEditingContext">substitutionEditingContext</a></h4>

</a>+ (EOEditingContext *)<B>substitutionEditingContext</B> <p>

Returns the substitution EOEditingContext if one has been specified. Otherwise returns <B>nil</B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/EOEditingContext/setSubstitutionEditingContext:">+ setSubstitutionEditingContext:</a>

 </B><p><a name="1146">

<h4> <a name="//apple_ref/occ/clm/EOEditingContext/usesContextRelativeEncoding">usesContextRelativeEncoding</a></h4>

</a>+ (BOOL)<B>usesContextRelativeEncoding</B><p>

Returns YES to indicate that the EOEditingContext uses context relative encoding, NO otherwise. For more discussion of this subject, see "<a href="#1447">Using EOEditingContext to Archive Custom Objects in Web Objects Framework</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/EOEditingContext/setUsesContextRelativeEncoding:">+ setUsesContextRelativeEncoding:</a> </B>, <a href="#//apple_ref/occ/clm/EOEditingContext/encodeObject:withCoder:"><B>+ encodeObject:withCoder:</a> </B>, <a href="#//apple_ref/occ/clm/EOEditingContext/initObject:withCoder:"><B>+ initObject:withCoder:</a>

 </B><p><a name="1150">

<a name="instm"></a>

<h3>Instance Methods </h3>

</a><a name="1151">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/addEditor:">addEditor:</a></h4>

</a>- (void)<B>addEditor:</B>(id)<em>editor</em> <p>

Adds to the receiver the EOEditor <em>editor</em>. For more explanation, see the method description for <B>editors</B> and the EOEditors informal protocol specification.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/editors">- editors</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/removeEditor:"><B>- removeEditor: </a>

 </B><p><a name="1155">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/arrayFaultWithSourceGlobalID:relationshipName:editingContext:">arrayFaultWithSourceGlobalID:relationshipName:editingContext:</a></h4>

</a>- (NSArray *)<B>arrayFaultWithSourceGlobalID:</B>(EOGlobalID *)<em>globalID</em> <B>relationshipName:</B>(NSString *)<em>name</em> <br><B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em> <p>

Overrides EOObjectStore's <B>arrayFaultWithSourceGlobalID:relationshipName:editingContext:</B> method. If the objects associated with the EOGlobalID <em>globalID</em> are already registered in the receiver, returns those objects. Otherwise, propagates the message down the object store hierarchy, through the parent object store, ultimately to the associated EODatabaseContext. The EODatabaseContext creates and returns a to-many fault.<p>

When a parent EOEditingContext receives this on behalf of a child EOEditingContext and the EOGlobalID <em>globalID</em> identifies a newly inserted object in the parent, the parent returns a copy of its object's relationship NSArray with the member objects translated into objects in the child EOEditingContext. <p>

For more information on faults, see the EOObjectStore, EODatabaseContext, EOFault and EOFaultHandler class specifications.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/faultForGlobalID:editingContext:">- faultForGlobalID:editingContext:</a>

 </B><p><a name="1158">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/committedSnapshotForObject:">committedSnapshotForObject:</a></h4>

</a>- (NSDictionary *)<B>committedSnapshotForObject:</B>(id)<em>object</em> <p>

Returns an NSDictionary containing a snapshot of <em>object</em> that reflects its committed values (that is, its values as they were last committed to the database).<em> </em>In other words, this snapshot represents the state of the object before any modifications were made to it. The snapshot is updated to the newest object state after a save.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/currentEventSnapshotForObject:">- currentEventSnapshotForObject:</a>

 </B><p><a name="1162">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/currentEventSnapshotForObject:">currentEventSnapshotForObject:</a></h4>

</a>- (NSDictionary *)<B>currentEventSnapshotForObject:</B>(id)<em>object</em> <p>

Returns an NSDictionary containing a snapshot of <em>object</em> that reflects its state as it was at the beginning of the current event loop. After the end of the current event, this snapshot is updated to hold the modified state of the object.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/committedSnapshotForObject:">- committedSnapshotForObject:</a>

 </B><p><a name="1166">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/delegate">delegate</a></h4>

</a>- (id)<B>delegate</B> <p>

Returns the receiver's delegate. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/setDelegate:">- setDelegate: </a>

 </B><p><a name="1170">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/deleteObject:">deleteObject:</a></h4>

</a>- (void)<B>deleteObject:</B>(id)<em>object</em> <p>

Specifies that <em>object</em> should be removed from the receiver's parent EOObjectStore when changes are committed. At that time, the object will be removed from the uniquing tables.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/deletedObjects">- deletedObjects </a>

 </B><p><a name="1174">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/deletedObjects">deletedObjects</a></h4>

</a>- (NSArray *)<B>deletedObjects</B> <p>

Returns the objects that have been deleted from the receiver's object graph.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/updatedObjects">- updatedObjects</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/insertedObjects"><B>- insertedObjects</a>

 </B><p><a name="1178">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/editors">editors</a></h4>

</a>- (NSArray *)<B>editors</B> <p>

Returns the receiver's editors. Editors are special-purpose delegate objects that may contain uncommitted changes that need to be validated and applied to enterprise objects before the EOEditingContext saves changes. For example, EODisplayGroups register themselves as editors with the EOEditingContext of their data sources so that they can save any changes in the key text field. For more information, see the EOEditors informal protocol specification and the EODisplayGroup class specification.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/addEditor:">- addEditor:</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/removeEditor:"><B>- removeEditor: </a>

 </B><p><a name="1182">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/faultForGlobalID:editingContext:">faultForGlobalID:editingContext:</a></h4>

</a>- (id)<B>faultForGlobalID:</B>(EOGlobalID *)<em>globalID <br></em><B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em> <p>

Overrides EOObjectStore's <B>faultForGlobalID:editingContext: </B> method. If the object associated with the EOGlobalID <em>globalID</em> is already registered in the receiver, returns that object. Otherwise, propagates the message down the object store hierarchy, through the parent object store, ultimately to the associated EODatabaseContext. The EODatabaseContext creates and returns a to-one fault.<p>

For example, suppose you want the department object whose deptID has a particular value. The most efficient way to get it is to look it up by its globalID using <B>faultForGlobalID:editingContext:</B>:<p>

<blockquote><pre>EOEntity *entity = [[EOModelGroup defaultGroup] entityNamed:entityName];

</pre></blockquote><p>

<blockquote><pre>EOGlobalID *gid = [entity globalIDForRow:[NSDictionary<br>    dictionaryWithObjectsAndKeys:deptIdentifier, @"deptID", nil]];

</pre></blockquote><p>

<blockquote><pre>return [editingContext faultForGlobalID:gid editingContext:editingContext];

</pre></blockquote><p>

If the object is already registered in the EOEditingContext, this code returns it (without going to the database). If not, a fault for this object is created, and when you touch the fault the object is fetched.<p>

When a parent EOEditingContext is sent <B>faultForGlobalID:editingContext:</B> on behalf of a child EOEditingContext and <em>globalID</em> identifies a newly inserted object in the parent, the parent registers a copy of the object in the child. <p>

For more discussion of this method, see the section "<a href="#1525">Working with Objects Across Multiple EOEditingContexts</a>" in the class description. For more information on faults, see the EOObjectStore, EODatabaseContext, EOFault and EOFaultHandler class specifications.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/arrayFaultWithSourceGlobalID:relationshipName:editingContext:">- arrayFaultWithSourceGlobalID:relationshipName:editingContext:</a>

 </B><p><a name="1192">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/forgetObject:">forgetObject:</a></h4>

</a>- (void)<B>forgetObject:</B>(id)<em>object</em> <p>

Removes <em>object</em> from the uniquing tables and causes the receiver to remove itself as the object's observer. This method is invoked whenever an object being observed by an EOEditingContext is deallocated. Note that this method does <em>not</em> have the effect of releasing and freeing the object. You should not ever invoke this method directly. The correct way to remove an object from its editing context is to remove every reference to the object by refaulting any object pointing to it (by using <a href="#1288"><B>refaultObjects </B></a> or <a href="#1220"><B>invalidateAllObjects </B></a>). Also note that this method does<em> not</em> have the effect of deleting an object-to delete an object you should either use the <a href="#1170"><B>deleteObject: </B></a> method or remove the object from an owning relationship.<p>

<a name="1195">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/globalIDForObject:">globalIDForObject:</a></h4>

</a>- (EOGlobalID *)<B>globalIDForObject:</B><em>object</em> <p>

Returns the EOGlobalID for <em>object</em>. All objects fetched from an external store are registered in an EOEditingContext along with a global identifier (EOGlobalID) that's used to uniquely identify each object to the external store. If <em>object</em> hasn't been registered in the EOEditingContext (that is, if no match is found), this method returns <B>nil</B>. Objects are registered in an EOEditingContext using the <B>insertObject:</B> method, or, when fetching, with <B>recordObject:globalID:</B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/objectForGlobalID:">- objectForGlobalID: </a>

 </B><p><a name="1199">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/hasChanges">hasChanges</a></h4>

</a>- (BOOL)<B>hasChanges</B> <p>

Returns YES if any of the objects in the receiver's object graph have been modified-that is, if any objects have been inserted, deleted, or updated. <p>

<a name="1202">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/initWithParentObjectStore:">initWithParentObjectStore:</a></h4>

</a>- <B>initWithParentObjectStore:</B>(EOObjectStore *)<em>anObjectStore</em> <p>

Initializes the receiver with <em>anObjectStore</em> as its parent EOObjectStore. Returns <B>self</B>. This method is the designated initializer for EOEditingContext. For more discussion of parent EOObjectStores, see "<a href="#983">Other Classes that Participate in Object Graph Management</a>" in the class description.<p>

<a name="1205">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/initializeObject:withGlobalID:editingContext:">initializeObject:withGlobalID:editingContext:</a></h4>

</a>- (void)<B>initializeObject:</B>(id)<em>object</em> <B>withGlobalID:</B>(EOGlobalID *)<em>globalID</em> <B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides EOObjectStore's <B>initializeObject:withGlobalID:editingContext:</B> to build the properties for the <em>object</em> identified by <em>globalID</em>. When a parent EOEditingContext receives this on behalf of a child EOEditingContext (as represented by <em>anEditingContext</em>), and the <em>globalID</em> identifies an object instantiated in the parent, the parent returns properties extracted from its object and translated into the child's context. This ensures that a nested context "inherits" modified values from its parent EOEditingContext. If the receiver doesn't have <em>object</em>, the request is fowarded the receiver's parent EOObjectStore.<p>

<a name="1208">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/insertObject:">insertObject:</a></h4>

</a>- (void)<B>insertObject:</B>(id)<em>object</em> <p>

Registers (by invoking <a href="#1212"><B>insertObject:withGlobalID: </B></a>) <em>object</em> to be inserted in the receiver's parent EOObjectStore the next time changes are saved. In the meantime, <em>object</em> is registered in the receiver with a temporary globalID.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/insertedObjects">- insertedObjects</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/deletedObjects"><B>- deletedObjects</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/insertObject:withGlobalID:"><B>- insertObject:withGlobalID:</a>

 </B><p><a name="1212">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/insertObject:withGlobalID:">insertObject:withGlobalID:</a></h4>

</a>- (void)<B>insertObject:</B><em>object</em><B> withGlobalID:</B>(EOGlobalID *)<em>globalID</em><p>

Registers a new <em>object</em> identified by <em>globalID</em> that should be inserted in the parent EOObjectStore when changes are saved. Works by invoking <a href="#1278"><B>recordObject:globalID: </B></a>, unless the receiver already contains the object. Sends <em>object</em> the message <B>awakeFromInsertionInEditingContext:</B>. <em>globalID</em> must respond YES to <B>isTemporary</B>. When the external store commits <em>object</em>, it re-records it with the appropriate permanent globalID.<p>

It is an error to insert an object that's already registered in an editing context unless you are effectively undeleting the object by reinserting it.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/insertObject:">- insertObject:</a>

 </B><p><a name="1216">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/insertedObjects">insertedObjects</a></h4>

</a>- (NSArray *)<B>insertedObjects</B> <p>

Returns the objects that have been inserted into the receiver's object graph. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/deletedObjects">- deletedObjects</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/updatedObjects"><B>- updatedObjects </a>

 </B><p><a name="1220">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/invalidateAllObjects">invalidateAllObjects</a></h4>

</a>- (void)<B>invalidateAllObjects</B> <p>

Overrides the EOObjectStore method <B>invalidateAllObjects</B> to discard the values of objects cached in memory and refault them, which causes them to be refetched from the external store the next time they're accessed. This method sends the message <B>invalidateAllObjectsWithGlobalIDs:</B> to the parent object store with the globalIDs of all of the objects cached in the receiver. When an EOEditingContext receives this message, it propagates the message down the object store hierarchy. EODatabaseContexts discard their snapshots for invalidated objects and broadcast an EOObjectsChangedInStoreNotification. <p>

The final effect of this method is to refault all objects currently in memory. This refaulting in turn releases all objects not retained by your application or by an EODisplayGroup. The next time you access one of these objects, it's refetched from the database.<p>

To flush the entire application's cache of all values fetched from an external store, use a statement such as the following:<p>

<blockquote><pre>[[editingContext rootObjectStore] invalidateAllObjects];

</pre></blockquote><p>

If you just want to discard uncommitted changes but you don't want to sacrifice the values cached in memory, use the EOEditingContext <B>revert</B> method, which reverses all changes and clears the undo stack. For more discussion of this topic, see the section "<a href="#1449">Methods for Managing the Object Graph</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/refetch:">- refetch:</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/invalidateObjectsWithGlobalIDs:"><B>- invalidateObjectsWithGlobalIDs:</a>

 </B><p><a name="1225">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/invalidateObjectsWithGlobalIDs:">invalidateObjectsWithGlobalIDs:</a></h4>

</a>- (void)<B>invalidateObjectsWithGlobalIDs:</B>(NSArray *)<em>globalIDs</em> <p>

Overrides the EOObjectStore method <B>invalidateObjectsWithGlobalIDs:</B> to signal to the parent EOObjectStore that the cached values for the objects identified by <em>globalID</em>s should no longer be considered valid and that they should be refaulted. Invokes <a href="#1271"><B>processRecentChanges </B></a> before refaulting the objects. This message is propagated to any underlying EOObjectStore, resulting in a refetch the next time the objects are accessed. Any related (child or peer) EOObjectStores are notified that the objects are no longer valid. For more discussion of this topic, see the section "<a href="#1449">Methods for Managing the Object Graph</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/invalidateAllObjects">- invalidateAllObjects</a>

 </B><p><a name="1228">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/invalidatesObjectsWhenFreed">invalidatesObjectsWhenFreed</a></h4>

</a>- (BOOL)<B>invalidatesObjectsWhenFreed</B><p>

Returns YES to indicate that the receiver clears and "booby-traps" all of the objects registered with it when the receiver is deallocated, NO otherwise. The default is YES. In this method, "invalidate" has a different meaning than it does in the other <B>invalidate...</B> methods. For more discussion of this topic, see the method description for <B>setInvalidatesObjectsWhenFreed:</B>.<p>

<a name="1231">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/isObjectLockedWithGlobalID:editingContext:">isObjectLockedWithGlobalID:editingContext:</a></h4>

</a>- (BOOL)<B>isObjectLockedWithGlobalID:</B>(EOGlobalID *)<em>globalID</em> <br><B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em><p>

Returns YES if the object identified by <em>globalID</em> in <em>anEditingContext</em> is locked, NO otherwise. This method works by forwarding the message <B>isObjectLockedWithGlobalID:</B> to its parent EOObjectStore.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/lockObject:">- lockObject:</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/lockObjectWithGlobalID:editingContext:"><B>- lockObjectWithGlobalID:editingContext:</a> </B>,<a href="#//apple_ref/occ/instm/EOEditingContext/locksObjectsBeforeFirstModification"><br>

<B>- locksObjectsBeforeFirstModificatio</a>n </B>,<a href="#//apple_ref/occ/instm/EOEditingContext/setLocksObjectsBeforeFirstModification:"><B> - setLocksObjectsBeforeFirstModification</a>:

 </B><p><a name="1235">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/lockObject:">lockObject:</a></h4>

</a>- (void)<B>lockObject:</B>(id)<em>anObject</em> <p>

Attempts to lock <em>anObject</em> in the external store. This method works by invoking <B>lockObjectWithGlobalID:editingContext:</B>. Raises an NSInvalidArgumentException if it can't find the globalID for <em>anObject</em> to pass to <B>lockObjectWithGlobalID:editingContext:</B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/isObjectLockedWithGlobalID:editingContext:">- isObjectLockedWithGlobalID:editingContext:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EOEditingContext/lockObjectWithGlobalID:editingContext:">- lockObjectWithGlobalID:editingContext:</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/locksObjectsBeforeFirstModification"><B>- locksObjectsBeforeFirstModification</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EOEditingContext/setLocksObjectsBeforeFirstModification:">- setLocksObjectsBeforeFirstModification:</a>

 </B><p><a name="1239">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/lockObjectWithGlobalID:editingContext:">lockObjectWithGlobalID:editingContext:</a></h4>

</a>- (void)<B>lockObjectWithGlobalID:</B>(EOGlobalID *)<em>globalID</em> <br><B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method<B> lockObjectWithGlobalID:editingContext: </B>to attempt to lock the object identified by <em>globalID</em> in <em>anEditingContext</em> in the external store. Raises an NSInternalInconsistencyException if unable to obtain the lock. This method works by forwarding the message <B>lockObjectWithGlobalID:editingContext:</B> to its parent EOObjectStore.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/lockObject:">- lockObject:</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/isObjectLockedWithGlobalID:editingContext:"><B>- isObjectLockedWithGlobalID:editingContext:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EOEditingContext/locksObjectsBeforeFirstModification">- locksObjectsBeforeFirstModification</a> </B>,<a href="#//apple_ref/occ/instm/EOEditingContext/setLocksObjectsBeforeFirstModification:"><br>

<B>- setLocksObjectsBeforeFirstModification</a>:

 </B><p><a name="1243">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/locksObjectsBeforeFirstModification">locksObjectsBeforeFirstModification</a></h4>

</a>- (BOOL)<B>locksObjectsBeforeFirstModification</B><p>

Returns YES if the receiver invokes <code>[self lockObject:object]</code> to lock <em>object</em> in the external store the first time <em>object</em> is modified.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/setLocksObjectsBeforeFirstModification:">- setLocksObjectsBeforeFirstModification:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EOEditingContext/isObjectLockedWithGlobalID:editingContext:">- isObjectLockedWithGlobalID:editingContext:</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/lockObject:"><B>- lockObject:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EOEditingContext/lockObjectWithGlobalID:editingContext:">- lockObjectWithGlobalID:editingContext:</a>

 </B><p><a name="1247">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/messageHandler">messageHandler</a></h4>

</a>- (id)<B>messageHandler</B> <p>

Returns the EOEditingContext's message handler. A message handler is a special-purpose delegate responsible for presenting errors to the user. Typically, an EODisplayGroup registers itself as the message handler for its EOEditingContext. For more information, see the EOMessageHandelers informal protocol specification.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/setMessageHandler:">- setMessageHandler: </a>

 </B><p><a name="1251">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/objectForGlobalID:">objectForGlobalID:</a></h4>

</a>- (id)<B>objectForGlobalID:</B>(EOGlobalID *)<em>globalID</em> <p>

Returns the object identified by <em>globalID</em>, or <B>nil</B> if no object has been registered in the EOEditingContext with <em>globalID</em>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/globalIDForObject:">- globalIDForObject: </a>

 </B><p><a name="1255">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/objectsForSourceGlobalID:relationshipName:editingContext:">objectsForSourceGlobalID:relationshipName:editingContext:</a></h4>

</a>- (NSArray *)<B>objectsForSourceGlobalID:</B>(EOGlobalID *)<em>globalID</em> <br><B>relationshipName:</B>(NSString *)<em>name</em> <br><B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em> <p>

Overrides EOObjectStore's<B> objectsForSourceGlobalID:relationshipName:editingContext:</B> method to service a to-many fault for a relationship named <em>name</em>. When a parent EOEditingContext receives this on behalf of a child EOEditingContext and <em>globalID</em> matches an object instantiated in the parent, the parent returns a copy of its relationship NSArray and translates its objects into the child's EOEditingContext. This ensures that a nested EOEditingContext "inherits" modified values from its parent EOEditingContext. If the receiving EOEditingContext does not have the specified object or if the parent's relationship property is still an EOFault, the request is fowarded to its parent EOObjectStore.<B> </B><p>

<a name="1258">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/objectsWithFetchSpecification:">objectsWithFetchSpecification:</a></h4>

</a>- (NSArray *)<B>objectsWithFetchSpecification:</B>(EOFetchSpecification *)<em>fetchSpecification</em><p>

Invokes <B>objectsWithFetchSpecification: </B><B>editingContext:</B> with <B>self</B> as the EOEditingContext and returns the result.<p>

<a name="1261">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/objectsWithFetchSpecification:editingContext:">objectsWithFetchSpecification:editingContext:</a></h4>

</a>- (NSArray *)<B>objectsWithFetchSpecification:</B>(EOFetchSpecification *)<em>fetchSpecification</em> <B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em> <p>

Overrides EOObjectStore's <B>objectsWithFetchSpecification: </B><B>editingContext:</B> method to fetch objects from an external store according to the criteria specified by <em>fetchSpecification</em> and return them in an NSArray. If one of these objects is already present in memory, this method doesn't overwrite its values with the new values from the database. This method raises an exception if an error occurs; the error message indicates the nature of the problem.<p>

When an EOEditingContext receives this message, it forwards the message to its EOObjectStore (typically an EOObjectStoreCoordinator). Based on the entity name in <em>fetchSpecification</em>, the EOObjectStoreCoordinator in turn forwards the request to the appropriate EODatabaseContext. The EODatabaseContext then obtains an EODatabaseChannel and performs the fetch, registering all fetched objects in <em>anEditingContext</em>.<p>

<a name="1265">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/objectWillChange:">objectWillChange:</a></h4>

</a>- (void)<B>objectWillChange:</B>(id)<em>object</em> <p>

This method is automatically invoked when any of the objects registered in the receiver invokes <code>[self willChange]</code>. This method is EOEditingContext's implementation of the EOObserving protocol.<em> </em>  <p>

<a name="1268">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/parentObjectStore">parentObjectStore</a></h4>

</a>- (EOObjectStore *)<B>parentObjectStore</B> <p>

Returns the EOObjectStore from which the receiver fetches and to which it saves objects. <p>

<a name="1271">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/processRecentChanges">processRecentChanges</a></h4>

</a>- (void)<B>processRecentChanges</B> <p>

Forces the receiver to process pending insertions, deletions, and updates.<em> </em>Normally, when objects are changed, the processing of the changes is deferred until the end of the current event. At that point, an EOEditingContext moves objects to the inserted, updated, and deleted lists, delete propagation is performed, undos are registered, and EOObjectsChangedInStoreNotification and EOObjectsChangedInEditingContextNotification are posted (usually causing the user interface to update). You can use this method to explicitly force changes to be processed. An EOEditingContext automatically invokes this method on itself before performing certain operations such as <B>saveChanges</B>. <p>

<a name="1274">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/propagatesDeletesAtEndOfEvent">propagatesDeletesAtEndOfEvent</a></h4>

</a>- (BOOL)<B>propagatesDeletesAtEndOfEvent</B> <p>

Returns YES if the receiver propagates deletes at the end of the event in which a change was made, NO if it propagates deletes only right before saving changes. The default is YES.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/setPropagatesDeletesAtEndOfEvent:">- setPropagatesDeletesAtEndOfEvent: </a>

 </B><p><a name="1278">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/recordObject:globalID:">recordObject:globalID:</a></h4>

</a>- (void)<B>recordObject:</B>(id)<em>object </em><B>globalID:</B>(EOGlobalID *)<em>globalID</em> <p>

Makes the receiver aware of an object identified by <em>globalID</em> existing in its parent EOObjectStore. EOObjectStores (such as EODatabaseContext) usually invoke this method for each object fetched. When it receives this message, the receiver enters the object in its uniquing table and registers itself as an observer of the object. <em> </em> <p>

<a name="1281">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/redo:">redo:</a></h4>

</a>- (void)<B>redo:</B>(id)<em>sender</em> <p>

This action method forwards a <B>redo</B> message to the receiver's EOUndoManager, asking it to reverse the latest undo operation applied to objects in the object graph. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/undo:">- undo:</a>

 </B><p><a name="1285">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/refault:">refault:</a></h4>

</a>- (void)<B>refault:</B>(id)<em>sender</em> <p>

This action method simply invokes <B>refaultObjects</B>. <p>

<a name="1288">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/refaultObjects">refaultObjects</a></h4>

</a>- (void)<B>refaultObjects</B> <p>

Refaults all objects cached in the receiver that haven't been inserted, deleted, or updated. Invokes <a href="#1271"><B>processRecentChanges </B></a>, then invokes <a href="#1291"><B>refaultObject:withGlobalID:editingContext: </B></a> for all objects that haven't been inserted, deleted, or updated. For more discussion of this topic, see the section "<a href="#1449">Methods for Managing the Object Graph</a>" in the class description.<p>

<a name="1291">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/refaultObject:withGlobalID:editingContext:">refaultObject:withGlobalID:editingContext:</a></h4>

</a>- (void)<B>refaultObject: </B>(id)<em>anObject<br></em><B>withGlobalID: </B>(EOGlobalID *)<em>globalID<br></em><B>editingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method <B>refaultObject:withGlobalID:editingContext:</B> to refault the enterprise object <em>object</em> identified by <em>globalID</em> in <em>anEditingContext</em>. This method should be used with caution since refaulting an object does not remove the object snapshot from the undo stack. Objects that have been newly inserted or deleted should not be refaulted. <p>

The main purpose of this method is to break retain cycles between enterprise objects. For example, suppose you have an Employee object that has a to-one relationship to its Department, and the Department object in turn has an array of Employee objects. You can use this method to break the retain cycle. Note that retain cycles are automatically broken if you release the EOEditingContext. For more discussion of this topic, see the section "<a href="#1449">Methods for Managing the Object Graph</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/refault:">- refault:</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/refaultObjects"><B>- refaultObjects</a>

 </B><p><a name="1294">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/refetch:">refetch:</a></h4>

</a>- (void)<B>refetch:</B>(id)<em>sender</em> <p>

This action method simply invokes the <B>invalidateAllObjects</B><em> </em>method. <p>

<a name="1299">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/registeredObjects">registeredObjects</a></h4>

</a>- (NSArray *)<B>registeredObjects</B><p>

Returns the enterprise objects managed by the receiver. <p>

<a name="1302">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/removeEditor:">removeEditor:</a></h4>

</a>- (void)<B>removeEditor:</B>(id)<em>editor</em> <p>

Unregisters <em>editor</em> from the receiver. For more discussion of EOEditors, see the <B>editors</B> method description and the EOEditors informal protocol specification.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/addEditor:">- addEditor: </a>

 </B><p><a name="1306">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/revert">revert</a></h4>

</a>- (void)<B>revert</B> <p>

Removes everything from the undo stack, discards all insertions and deletions, and restores updated objects to their last committed values. Does not refetch from the database. Note that <B>revert</B> doesn't automatically cause EODisplayGroups to refetch. EODisplayGroups that allow insertion and deletion of objects need to be explicitly synchronized whenever this method is invoked on their EOEditingContext. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/invalidateAllObjects">- invalidateAllObjects</a>

 </B><p><a name="1309">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/revert:">revert:</a></h4>

</a>- (void)<B>revert:</B>(id)<em>sender</em> <p>

<em> </em>This action method simply invokes <B>revert</B>. <p>

<a name="1312">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/rootObjectStore">rootObjectStore</a></h4>

</a>- (EOObjectStore *)<B>rootObjectStore</B> <p>

Returns the non-EOEditingContext EOObjectStore at the base of the EOObjectStore hierarchy (usually an EOObjectStoreCoordinator). <p>

<a name="1315">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/saveChanges">saveChanges</a></h4>

</a>- (void)<B>saveChanges</B> <p>

Commits changes made in the receiver to its parent EOObjectStore by sending it the message <B>saveChangesInEditingContext:</B>. If the parent is an EOObjectStore Coordinator, it guides its EODatabaseContexts through a multi-pass save operation (see the EOObjectStoreCoordinator class specification for more information). If no message handler or delegate is available and a database error occurs, an exception is raised; the error message indicates the nature of the problem.<p>

<a name="1318">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/saveChanges:">saveChanges:</a></h4>

</a>- (void)<B>saveChanges</B>:(id)<em>sender</em> <p>

This action method simply invokes <B>saveChanges</B>. <p>

<a name="1321">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/saveChangesInEditingContext:">saveChangesInEditingContext:</a></h4>

</a>- (void)<B>saveChangesInEditingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method <B>saveChangesInEditingContext:</B> to tell the receiver's EOObjectStore to accept changes from a child EOEditingContext. This method shouldn't be invoked directly. It's invoked by a nested EOEditingContext when it's committing changes to a parent EOEditingContext. The receiving parent EOEditingContext incorporates all changes from the nested EOEditingContext into its own copies of the objects, but it doesn't immediately save those changes to the database. If the parent itself is later sent <B>saveChanges</B>, it propagates any changes received from the child along with any other changes to its parent EOObjectStore. Raises an exception if an error occurs; the error message indicates the nature of the problem.<p>

<a name="1324">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/setDelegate:">setDelegate:</a></h4>

</a>- (void)<B>setDelegate:</B>(id)<em>anObject</em> <p>

<em> </em>Set the receiver's delegate to be <em>anObject</em>, without retaining it.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/delegate">- delegate </a>

 </B><p><a name="1328">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/setInvalidatesObjectsWhenFreed:">setInvalidatesObjectsWhenFreed: </a></h4>

</a>- (void)<B>setInvalidatesObjectsWhenFreed:</B>(BOOL)<em>flag</em><p>

Sets according to <em>flag</em> whether the receiver clears and "booby-traps" all of the objects registered with it when the receiver is deallocated. Sends <B>clearProperties</B> to all of its objects, thereby breaking any retain cycles between objects that would prevent them from being freed. Leaves the objects in a state in which sending them any message other than <B>dealloc</B> or <B>release</B> raises an exception. The default is YES, and as a general rule, this setting must be YES for enterprise objects with cyclic references to be freed when their EOEditingContext is freed. Note that "invalidate" in this method has a different meaning than it does in the other <B>invalidate...</B> methods, which discard object values and refault them.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/invalidatesObjectsWhenFreed">- invalidatesObjectsWhenFreed</a>

 </B><p><a name="1332">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/setLocksObjectsBeforeFirstModification:">setLocksObjectsBeforeFirstModification:</a></h4>

</a>- (void)<B>setLocksObjectsBeforeFirstModification:</B>(BOOL)<em>flag</em><p>

Sets according to <em>flag</em> whether the receiver invokes <code>[self lockObject:object]</code> to lock <em>object</em> in the external store the first time <em>object</em> is modified. The default is NO. If <em>flag</em> is YES, an exception will be raised if a lock can't be obtained when <em>object</em> invokes <B>willChange</B>. There are two reasons a lock might fail: because the row is already locked in the server, or because your snapshot is out of date. If your snapshot is out of date, you can explicitly refetch the object using an EOFetchSpecification with <B>setRefreshesRefetchedObjects:</B> set to YES. To handle the exception, you can implement the EODatabaseContext delegate method <B>databaseContext:shouldRaiseExceptionForLockFailure:</B>.<p>

You should avoid using this method or pessimistic locking in an interactive end-user application. A user might make a change in a text field and neglect to save it, thereby leaving the data locked in the server indefinitely. Consider using optimistic locking or application level explicit check-in/check-out instead. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/locksObjectsBeforeFirstModification">- locksObjectsBeforeFirstModification</a>

 </B><p><a name="1336">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/setMessageHandler:">setMessageHandler:</a></h4>

</a>- (void)<B>setMessageHandler:</B>(id)<em>handler</em> <p>

Set the receiver's message handler to be <em>handler</em>. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/messageHandler">- messageHandler </a>

 </B><p><a name="1340">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/setPropagatesDeletesAtEndOfEvent:">setPropagatesDeletesAtEndOfEvent:</a></h4>

</a>- (void)<B>setPropagatesDeletesAtEndOfEvent:</B>(BOOL)<em>flag</em> <p>

Sets according to <em>flag</em> whether the receiver propagates deletes at the end of the event in which a change was made, or only just before saving changes.<p>

If <em>flag</em> is YES, deleting an enterprise object triggers delete propagation at the end of the event in which the deletion occurred (this is the default behavior). If <em>flag</em> is NO, delete propagation isn't performed until <B>saveChanges:</B> is invoked.<p>

You can delete enterprise objects explicitly by using the <B>deleteObject:</B> method or implicitly by removing the enterprise object from an owning relationship. Delete propagation uses the delete rules in the EOClassDescription to determine whether objects related to the deleted object should also be deleted (for more information, see the EOClassDescription class specification and NSObject Additions). If delete propagation fails (that is, if an enterprise object refuses to be deleted-possibly due to a deny rule), all changes made during the event are rolled back. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/propagatesDeletesAtEndOfEvent">- propagatesDeletesAtEndOfEvent</a>

 </B><p><a name="1346">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/setStopsValidationAfterFirstError:">setStopsValidationAfterFirstError:</a></h4>

</a>- (void)<B>setStopsValidationAfterFirstError:</B>(BOOL)<em>flag</em><p>

Sets according to <em>flag</em> whether the receiver stops validating after the first error is encountered, or continues for all objects (validation typically occurs during a save operation). The default is YES. Setting it to NO is useful if the delegate implements <B>editingContext:shouldPresentException:</B> to handle the presentation of aggregate exceptions. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/stopsValidationAfterFirstError">- stopsValidationAfterFirstError</a>

 </B><p><a name="1350">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/setUndoManager:">setUndoManager:</a></h4>

</a>- (void)<B>setUndoManager:</B>(EOUndoManager *)<em>undoManager</em> <p>

Sets the receiver's EOUndoManager to <em>undoManager</em>. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/undoManager">- undoManager </a>

 </B><p><a name="1354">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/stopsValidationAfterFirstError">stopsValidationAfterFirstError</a></h4>

</a>- (BOOL)<B>stopsValidationAfterFirstError</B> <p>

Returns YES to indicate that the receiver should stop validating after it encounters the first error, or NO to indicate that it should continue for all objects.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/setStopsValidationAfterFirstError:">- setStopsValidationAfterFirstError:</a>

 </B><p><a name="1358">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/tryToSaveChanges">tryToSaveChanges</a></h4>

</a>- (NSException *)<B>tryToSaveChanges</B><p>

Invokes the <B>saveChanges</B> method, and catches and returns any exceptions that are raised. This method is primarily for use with WebScript (the Web Objects Framework scripting language), since unlike Objective-C, WebScript isn't able to catch exceptions. <p>

<a name="1361">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/undo:">undo:</a></h4>

</a>- (void)<B>undo:</B>(id)<em>sender</em> <p>

This action method forwards an <B>undo</B> message to the receiver's EOUndoManager, asking it to reverse the latest uncommitted changes applied to objects in the object graph. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/redo:">- redo:</a>

 </B><p><a name="1365">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/undoManager">undoManager</a></h4>

</a>- (EOUndoManager *)<B>undoManager</B> <p>

Returns the receiver's EOUndoManager. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/setUndoManager:">- setUndoManager: </a>

 </B><p><a name="1369">

<h4> <a name="//apple_ref/occ/instm/EOEditingContext/updatedObjects">updatedObjects</a></h4>

</a>- (NSArray *)<B>updatedObjects</B> <p>

Returns the objects in the receiver's object graph that have been updated. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/deletedObjects">- deletedObjects</a> </B>, <a href="#//apple_ref/occ/instm/EOEditingContext/insertedObjects"><B>- insertedObjects </B><em> </a>

</em><p><p>

<a name="1374">

<h4> <a name="//apple_ref/occ/instm/NSObject/editingContext:shouldFetchObjectsDescribedByFetchSpecification:">editingContext:shouldFetchObjectsDescribedByFetchSpecification:</a></h4>

</a>(NSArray *)<B>editingContext:</B>(EOEditingContext *)<em>editingContext</em> <B>shouldFetchObjectsDescribedByFetchSpecification:</B>(EOFetchSpecification *)<em>fetchSpecification</em><p>

Invoked from <B>objectsWithFetchSpecification:editingContext:</B>. If the delegate has appropriate results cached it can return them and the fetch will be bypassed. Returning <B>nil</B> causes the fetch to be propagated to the parent object store.<p>

<a name="1377">

<h4> <a name="//apple_ref/occ/instm/NSObject/editingContext:shouldPresentException:">editingContext:shouldPresentException:</a></h4>

</a>- (BOOL)<B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em> <br><B>shouldPresentException:</B>(NSException *)<em>exception</em> <p>

Sent whenever an exception is caught by an EOEditingContext. If the delegate returns NO, <em>exception</em> is ignored. Otherwise <em>exception</em> is passed to the message handler for further processing.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/messageHandler">- messageHandler </a>

 </B><p><a name="1381">

<h4> <a name="//apple_ref/occ/instm/NSObject/editingContextShouldValidateChanges:">editingContextShouldValidateChanges:</a></h4>

</a>- (BOOL)<B>editingContextShouldValidateChanges:</B>(EOEditingContext *)<em>anEditingContext</em> <p>

Sent when an EOEditingContext receives a <B>saveChanges</B> message. If the delegate returns NO, changes are saved without first performing validation. This method can be useful if the delegate wants to provide its own validation mechanism.<B> </B><p>

<a name="1384">

<h4> <a name="//apple_ref/occ/instm/NSObject/editingContext:shouldInvalidateObject:globalID:">editingContext:shouldInvalidateObject:globalID:</a></h4>

</a>- (BOOL)<B>editingContext:</B>(EOEditingContext *)<em>anEditingContext</em> <br><B>shouldInvalidateObject:</B>(id)<em>object</em> <br><B>globalID:</B>(EOGlobalID *)<em>globalID</em> <p>

Sent when an <em>object</em> identified by <em>globalID</em> has been explicitly invalidated. If the delegate returns NO, the invalidation is refused. This allows the delegate to selectively override object invalidations.<B> </B><p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EOEditingContext/invalidateAllObjects">- invalidateAllObjects</a> </B>,<B> <a href="#//apple_ref/occ/instm/EOEditingContext/revert"></B><B>- revert</a>

 </B><p><a name="1388">

<h4> <a name="//apple_ref/occ/instm/NSObject/editingContextShouldUndoUserActionsAfterFailure:">editingContextShouldUndoUserActionsAfterFailure:</a></h4>

</a>- (BOOL)<B>editingContextShouldUndoUserActionsAfterFailure:</B>(EOEditingContext *)<em>anEditingContext</em><p>

Sent when a validation error occurs while processing a <B>processRecentChanges</B> message. If the delegate returns NO, it disables the automatic undoing of user actions after validation has resulted in an error. <p>

By default, if a user attempts to perform an action that results in a validation failure (such as deleting a department object that has a delete rule stating that the department can't be deleted if it contains employees), the user's action is immediately rolled back. However, if this delegate method returns NO, the user action is allowed to stand (though attempting to save the changes to the database without solving the validation error will still result in a failure). Returning NO gives the user an opportunity to correct the validation problem so that the operation can proceed (for example, the user might delete all of the department's employees so that the department itself can be deleted).<p>

<a name="1392">

<h4> <a name="//apple_ref/occ/instm/NSObject/editingContextWillSaveChanges:">editingContextWillSaveChanges:</a></h4>

</a>- (void)<B>editingContextWillSaveChanges:</B>(EOEditingContext *)<em>editingContext</em> <p>

Sent when an EOEditingContext receives a <B>saveChanges</B> message. The delegate can raise an exception to abort the save operation.<B> </B><p>

<p>

The following notifications are declared (except where otherwise noted) and posted by EOEditingContext. <p>

<a name="//apple_ref/c/data/EOObjectsChangedInStoreNotification">EOObjectsChangedInStoreNotification</a><p>

<dl><dt>Notification Object

<dl><dt>The EOEditingContext

</dl><dt>userInfo Dictionary

Key	Value<p>

updated	An NSArray of EOGlobalIDs for objects whose properties have<br>	changed. A receiving EOEditingContext typically responds by<br>	refaulting the objects.<p>

inserted	An NSArray of EOGlobalIDs for objects that have been inserted<br>	into the EOObjectStore.<p>

deleted	An NSArray of EOGlobalIDs for objects that have been deleted<br>	from the EOObjectStore.<p>

invalidated	An NSArray of EOGlobalIDs for objects that have been turned<br>	into EOFaults. Invalidated objects are those for which the <br>	cached view can should no longer be trusted. Invalidated objects<br> 	should be refaulted so that they are refetched when they're next<br> 	examined.<p>

</dl>This notification is broadcast whenever <B>objectWillChange</B> observer notifications are processed, which is usually as the end of the event in which the changes occurred. See the EOObjectStore class specification for more information on EOObjectsChangedInStoreNotification.<p>

<a name="//apple_ref/c/data/EOObjectsChangedInEditingContextNotification">EOObjectsChangedInEditingContextNotification</a><p>

<dl><dt>Notification Object

<dl><dt>The EOEditingContext

</dl><dt><B>userInfo Dictionar </B>y

Key	Value<p>

updated	An NSArray containing the changed objects<p>

deleted	An NSArray containing the deleted objects<p>

inserted	An NSArray containing the inserted objects<p>

invalidated	An NSArray containing invalidated objects. <p>

</dl>This notification is broadcast whenever changes are made in an EOEditingContext. EOObjectsChangedInEditingContextNotification is similar to EOObjectsChangedInStoreNotification, except that it contains objects rather than globalIDs. EODisplayGroups listen for this notification to redisplay their contents.<p>

<a name="//apple_ref/c/data/EOEditingContextDidSaveChangesNotification">EOEditingContextDidSaveChangesNotification</a><p>

<dl><dt>Notification Object

<dl><dt>The EOEditingContext

</dl><dt><B>userInfo Dictionar </B>y<p>

<Table Border="3">

<caption></caption>

<tr><td scope="row"><a name="3189">

Key

</a></td><td><a name="3191">

Value

</a></td></tr>

<tr><td scope="row"><a name="3193">

updated

</a></td><td><a name="3195">

An NSArray containing the changed objects

</a></td></tr>

<tr><td scope="row"><a name="3197">

deleted

</a></td><td><a name="3199">

An NSArray containing the deleted objects

</a></td></tr>

<tr><td scope="row"><a name="3201">

inserted

</a></td><td><a name="3203">

An NSArray containing the inserted objects

</a></td></tr>



</Table>



<Table>

<tr><td>

</Table>



</dl>This notification is broadcast after changes are saved to the EOEditingContext's parent EOObjectStore.<p>

<a name="//apple_ref/c/data/EOInvalidatedAllObjectsInStoreNotification">EOInvalidatedAllObjectsInStoreNotification</a><p>

<dl><dt>Notification Object

<dl><dt>The EOEditingContext

</dl><dt>userInfo Dictionary

<dl><dt>None.

</dl></dl>This notification is broadcast whenever an EOEditingContext is invalidating all its objects. When an EOEditingContext receives this notification from its parent EOObjectStore, it clears its lists of inserted, updated, and deleted objects, and resets its undo stack. EODisplayGroups listen for this notification to refetch their contents. See the EOObjectStore class specification for more information on this notification. <p>

<p>



 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 10/15/97 16:36:34 -->



</body>

</html>

