<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Fundamentals: Managing Data</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Managing Data"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP0000019" title="Managing Data"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP0000011-CH204-TPXREF101">I/O Kit Fundamentals</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HandlingEvents/HandlingEvents.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../PowerMgmt/PowerMgmt.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP0000019-BCIFGGBI" title="Managing Data"></a><h1>Managing Data</h1><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_338"></a><p>A driver’s essential work is to shuffle data in and out of the system in response to client requests as well as events such as hardware-generated interrupts. The I/O Kit defines standard mechanisms for drivers to do this using a handful of classes. Drivers use the IOMemoryDescriptor and IOMemoryCursor classes (and, in Mac OS X v10.4.7 and later, the IODMACommand class) to perform pre-I/O and post-I/O processing on data buffers, such as translating them between client formats and hardware-specific formats. This chapter discusses these classes and various issues related to device drivers and data management.</p><p>Drivers handle client requests and other events using the IOWorkLoop and IOEventSource classes to serialize access and thereby protect their critical data. Because of these mechanisms, drivers rarely have to worry about such issues as protecting critical data or disabling and enabling interrupts during the normal course of handling a request. See the chapter <span class="content_text"><a href="../HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFFJAD">“Handling Events”</a></span> for information. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-TPXREF108">Handling I/O Transfers</a>
				
			<br/>
			
        
			
			
				<a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-TPXREF110">Relaying I/O Requests</a>
				
			<br/>
			
        
			
			
				<a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-TPXREF103">More on Memory Descriptors</a>
				
			<br/>
			
        
			
			
				<a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-TPXREF104">More on Memory Cursors</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP0000019-TPXREF108" title="Handling I/O Transfers"></a><h2>Handling I/O Transfers</h2><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_339"></a><p>An I/O transfer is little more than a movement of data between one or more buffers in system memory and a device. “System memory” in this context, however, refers to actual physical memory, not the virtual memory address space used by both user and kernel tasks in Mac OS X. Because I/O transfers at the level of device drivers are sensitive to the limitations of hardware, and hardware can “see” only physical memory, they require special treatment. </p><p>Input/output operations in Mac OS X occur within the context of a virtual memory system with preemptive scheduling of tasks and threads. In this context, a data buffer with a stable virtual address can be located anywhere in physical memory, and that physical memory location can change as virtual memory is paged in and out. It’s possible for that data buffer to not be in physical memory at all at any given time. Even kernel memory, which isn’t subject to relocation, is accessed by the CPU in a virtual address space. </p><p>For a write operation, where data in the system is being sent out, a data buffer must be paged in if necessary from the virtual memory store. For a read operation, where a buffer will be filled by data brought into the system, the existing contents of the data buffer are irrelevant, so no page-in is necessary; a new page is simply allocated in physical memory, with the previous contents of that page being overwritten (after being paged out, if necessary).</p><p>Yet a requirement for I/O transfers is that the data in system memory not be relocated during the duration of the transfer. To guarantee that a device can access the data in buffers, the buffers must be resident in physical memory and must be wired down so that they don’t get paged out or relocated. Then the physical addresses of the buffers must be made available to the device. After the device is finished with the buffers, they must be unwired so that they can once again be paged out by the virtual memory system.</p><p>To help you deal with these and other constraints of hardware, the I/O Kit puts several classes at your disposal. </p><a name="//apple_ref/doc/uid/TP0000019-TPXREF101" title="Memory Descriptors and Memory Cursors"></a><h3>Memory Descriptors and Memory Cursors</h3><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_340"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_341"></a><p>In a preemptive multitasking operating system with built-in <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_342"></a>virtual memory, I/O transfers require special preparation and post-completion processing:</p><ul class="spaceabove"><li class="li"><p>The space needed for an I/O transfer must reside in <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_343"></a>physical memory and must be wired down so it can’t be paged out until the transfer completes.</p></li><li class="li"><p>The virtual memory addresses used by software must be converted to physical addresses, and the buffer addresses and lengths must be collected into the scatter/gather lists that describe the data to be transferred.</p></li><li class="li"><p>After the transfer completes, the memory must be unwired so it can be paged out.</p></li></ul><p>In the I/O Kit, all of this work is performed by objects of the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_344"></a>IOMemoryDescriptor and <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_345"></a>IOMemoryCursor classes (see <span class="content_text"><a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-SW2">“Supporting DMA on 64-Bit System Architectures”</a></span> for information on the IODMACommand class, which supersedes IOMemoryCursor in Mac OS X v10.4.7 and later). An I/O request typically includes an IOMemoryDescriptor object that describes the areas of memory involved in the transfer. Initially, the description takes the form of an array of structures, each consisting of a client task identifier (<code>task_t</code>), an offset into the client’s virtual address space, and a length in bytes. A driver uses the memory descriptor to prepare the memory pages—paging them into physical memory, if necessary, and wiring them down—by invoking the descriptor’s <code><!--a-->prepare<!--/a--></code> function<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_346"></a>. </p><p>When the memory is prepared, a driver at a lower level of the stack—typically a driver that controls a DMA (Direct Memory Access) <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_347"></a>engine—then uses a memory-cursor object to get the memory descriptor’s buffer segments and with them generate a <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_348"></a>scatter/gather list suitable for use with the hardware. It does this by invoking the <code><!--a-->getPhysicalSegments<!--/a--></code> function<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_349"></a> of the memory cursor and doing any necessary processing on the segments it receives. When the I/O transfer is complete, the driver originating the I/O request invokes the memory descriptor’s <code><!--a-->complete<!--/a--></code> function to unwire the memory and update the virtual-memory state. When all this is done, it informs the client of the completed request.</p><p>Beginning in Mac OS X v10.2, IOBufferMemoryDescriptor<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_350"></a> (a subclass of IOMemoryDescriptor) allows a buffer to be allocated in any task for I/O or sharing through mapping. In previous versions of Mac OS X, an IOBufferMemoryDescriptor object could only represent a buffer allocated in the kernel’s address space. In Mac OS X v10.2 and later, however, the changes to the IOBufferMemoryDescriptor API support a better way to handle I/O generated at the behest of a nonkernel client. Apple recommends that such I/O be sent to buffers the kernel allocates in the client’s address space using the IOBufferMemoryDescriptor API. This gives control of the allocation method to the kernel, ensuring that the buffer is allocated in accordance with internal guidelines dictated by the virtual-memory system. The user task can still specify the kind of buffer to be allocated, such as pageable or sharable. And, the user task can still access the buffer using the <code>vm_address_t</code> and <code>vm_size_t</code> variables it receives from the user client. For software running in Mac OS X v10.2 and later, Apple recommends that:</p><ul class="spaceabove"><li class="li"><p>User tasks no longer use <code><!--a-->malloc<!--/a--></code> or other user-level library functions to allocate I/O buffers in their own address space.</p></li><li class="li"><p>User clients use IOBufferMemoryDescriptor objects to represent kernel-allocated buffers instead of the IOMemoryDescriptor objects that represented user task–allocated buffers.</p></li></ul><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_351"></a>Network drivers are the exception to the use of IOMemoryDescriptor objects. The Network family instead uses the <code>mbuf</code> structure<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_352"></a> defined by the BSD kernel networking stacks. BSD <code>mbuf</code> structures are already optimized for handling network packets, and translating between them and memory descriptors would merely introduce unnecessary overhead. The network family defines subclasses of IOMemoryCursor for extracting scatter/gather lists directly from <code>mbuf</code> structures, essentially making this aspect of I/O handling the same for network drivers as for any other kind of driver.</p><p>IOMemoryDescriptor and IOMemoryCursor are capable of handling the management and reuse of memory buffers for most drivers. Drivers with special requirements, such as that all buffer memory be contiguous or located within a particular area in physical memory, must perform the extra work necessary to meet these requirements, but still use memory descriptors and cursors for their interaction with the I/O Kit.<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_353"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_354"></a></p><a name="//apple_ref/doc/uid/TP0000019-TPXREF102" title="Memory in an I/O Request"></a><h3>Memory in an I/O Request</h3><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_355"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_356"></a><p>Although the preceding section discusses how I/O Kit drivers transfer data between device and system memory by using objects of the IOMemoryDescriptor and IOMemoryCursor classes, it does so at a fairly general level. It’s also instructive to consider an I/O request at a more detailed level: What happens from the moment a user process makes a call to write or read data to the instant the data is transferred to or from a device? What are the exact roles played by IOMemoryDescriptors, IOMemoryCursors, and other I/O Kit objects in this chain of events? </p><p>All read and write operations in user space—that is, made by applications or other non-kernel processes—are based ultimately on I/O vectors. An I/O vector is an array of structures, each of which gives the address and length of a contiguous chunk of memory of a particular process; this memory is expressed in the virtual address space of the process. An I/O vector is sometimes known as a scatter/gather list.</p><p>To start with a more specific example, a process makes a call to write some data to a device. It must pass in a minimum set of parameters: a handle to the target of the call (<code>io_service_t</code>), a command (“write”), the base address of the I/O vector array, and the number of array elements. These parameters get passed down to the kernel. But how is the kernel to make sense of them, particularly the base address of the array, which is typed as <code>void</code> *. The kernel lives in its own virtual address space, and the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_357"></a>virtual address space of a user process, untranslated, means nothing to it.</p><p>Before going further, let’s review the memory maps maintained by the operating system. In Mac OS X there are three different kinds of address space:</p><ul class="spaceabove"><li class="li"><p>The virtual address space of individual user processes (such as applications and daemons)</p></li><li class="li"><p>The virtual address space of the kernel (which includes the I/O Kit)</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_358"></a>Physical address space (system memory)</p></li></ul><p>When a user process issues an I/O call, the call (with its parameters) percolates down to the kernel. There the I/O Kit converts the handle parameter to an object derived from an appropriate IOUserClient subclass. The user-client object logically sits astride the boundary separating the kernel and user space. There is one user client per user process per device. From the perspective of the kernel, the user client is a client driver at the top of the stack that communicates with the nub object below it (see <span class="content_text"><a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-BCIJGDAH">Figure 8-1</a></span>). </p><br/><div><a name="//apple_ref/doc/uid/TP0000019-BCIJGDAH" title="Figure 8-1The role of the user client in an I/O command"></a><p><strong>Figure 8-1&nbsp;&nbsp;</strong>The role of the user client in an I/O command</p><img src = "../art/userclient_iotransfer.gif" alt = "The role of the user client in an I/O command" width="296" height="215"></div><br/><p>The <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_359"></a>user client also translates between the address spaces, mapping the user-process buffers into the kernel’s virtual address space. To do this, it creates an IOMemoryDescriptor object from the other parameters specified in the original call. The particular power of an IOMemoryDescriptor object is that it can describe a piece of memory throughout its use in an I/O operation and in each of the system’s address spaces. It can be passed between various drivers up and down the driver stack, giving each driver an opportunity to refine or manipulate the command. A driver can also reuse a memory descriptor; in some circumstances, it is better—if continuous allocation is going to involve a performance hit—to create a pool of IOMemoryDescriptors ahead of time and recycle them.</p><p>After the user client creates (or reuses) the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_360"></a>IOMemoryDescriptor object, it immediately invokes the memory descriptor’s <code><!--a-->prepare<!--/a--></code> member <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_361"></a>function. The <code><!--a-->prepare<!--/a--></code> call first makes sure physical memory is available for the I/O transfer. Because this is a write operation, the virtual memory system may have to page in the data from its store. If it were a read operation, the virtual-memory (<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_362"></a>VM) pager might have to swap out some other pages from physical memory to make room for the I/O transfer. In either case, when the VM pager is involved in preparing physical memory, there are implications for bus controller drivers that program DMA engines or otherwise must deal directly with the requirements of devices (see <span class="content_text"><a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-BCIFHFJJ">“DMA and System Memory”</a></span>). After sufficient physical memory is secured for the I/O transfer, the <code><!--a-->prepare<!--/a--></code> function wires the memory down so it cannot be paged out.</p><p>The <code><!--a-->prepare<!--/a--></code> call must be made before the I/O command crosses formally into the I/O Kit, and it should also be made on the requesting client’s thread and before taking any locks. Never invoke <code><!--a-->prepare<!--/a--></code> within the command-gate context because <code><!--a-->prepare<!--/a--></code> is a synchronous call and can <em>block</em> (that is, wait for some other process to complete) indefinitely. When <code>prepare</code> returns, the user client (typically) initiates the call to schedule the I/O request, passing the memory descriptor to a driver down the stack (through established interfaces, as described in <span class="content_text"><a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-TPXREF110">“Relaying I/O Requests”</a></span>). The memory descriptor might be passed along to other drivers, each of which might manipulate its contents, until it eventually reaches an object that is close to the hardware itself—typically a bus controller driver or that driver’s client nub. This object schedules the I/O request and takes the command (see <span class="content_text"><a href="../HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP0000018-TPXREF104">“I/O Requests and Command Gates ”</a></span> for information on command gates). Within the command gate it usually queues up the request for processing as soon as the hardware is free.</p><br/><div><a name="//apple_ref/doc/uid/TP0000019-TPXREF106" title="Figure 8-2The principal I/O Kit objects in an I/O transfer"></a><p><strong>Figure 8-2&nbsp;&nbsp;</strong>The principal I/O Kit objects in an I/O transfer</p><img src = "../art/driverstack_iotransfer.gif" alt = "The principal I/O Kit objects in an I/O transfer" width="340" height="347"></div><br/><p>Ultimately receiving the request at the lower levels of the driver stack is a bus controller driver (such as for ATA or SCSI). This lower-level driver object must program the controller’s DMA engine or otherwise create a <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_363"></a>scatter/gather list to move data directly into and out of the device. Using an IOMemoryCursor object, this driver generates physical addresses and lengths from the memory descriptor’s buffer segments and does any other work necessary to create a scatter/gather list with the alignment, endian format, and size factors required by the hardware. To generate the segments, it must call the <code><!--a-->getPhysicalSegments<!--/a--></code> function of the memory cursor. This whole procedure is run in the work-loop context. At the completion of the transfer, a hardware interrupt is typically generated to initiate an I/O transfer in the other direction. </p><p>When the I/O transfer is complete, the object that called <code>prepare</code> invokes the memory descriptor’s <code><!--a-->complete<!--/a--></code> function to unwire the memory and update the virtual-memory state. It’s important to balance each <code>prepare</code> with a corresponding <code>complete</code>. When all this is done, the user client informs the originating process of the completed request.<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_364"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_365"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_366"></a></p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_2" title="Issues With 64-Bit System Architectures"></a><h3>Issues With 64-Bit System Architectures</h3><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_367"></a>Beginning with Mac OS X v10.3 and later, Apple introduced some changes to allow existing device drivers to work with the new 64-bit system architectures. The problem to be solved involved the communication between devices on the PCI bus, which can handle 32-bit addresses, and the 64-bit main memory.</p><p>Then, in Mac OS X v10.4.7, Apple introduced the IODMACommand class to allow device drivers that perform DMA to address 64-bit main memory in Intel-based Macintosh computers. The following sections describe these changes. </p><a name="//apple_ref/doc/uid/TP0000019-SW1" title="Address Translation on 64-Bit System Architectures"></a><h4>Address Translation on 64-Bit System Architectures</h4><p>Apple solved the problem with address translation which “maps” blocks of memory into the 32-bit address space of a PCI device. In this scheme, the PCI device still sees a 4-gigabyte space, but that space can be made up of noncontiguous blocks of memory. A part of the memory controller called the DART<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_368"></a> (device address resolution table) translates between the PCI address space and the much larger main memory address space. The DART handles this by keeping a table of translations to use when mapping between the physical addresses the processor sees and the addresses the PCI device sees (called I/O addresses<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_369"></a>).</p><p>The address-translation process is transparent if your driver adheres to documented, Apple-provided APIs. For example, when your driver calls the IOMemoryDescriptor method <code>prepare</code>, a mapping is automatically placed in the DART. Conversely, when your driver calls IOMemoryDescriptor’s <code>release</code> method, the mapping is removed. Although this has always been the recommended procedure, failure to do this in a driver running on Mac OS X v10.3 or later may result in random data corruption or panics. Be aware that the <code>release</code> method does not take the place of the <code>complete</code> method. As always, every invocation of <code>prepare</code> should be balanced with an invocation of <code>complete</code>.</p><p>If your driver experiences difficulty on a Mac OS X v10.3 system, you should first ensure that you are following these guidelines:</p><ul class="spaceabove"><li class="li"><p>Always call <code>IOMemoryDescriptor::prepare</code> to prepare the physical memory for the I/O transfer (this also places a mapping into the DART).</p></li><li class="li"><p>Balance each <code>IOMemoryDescriptor::prepare</code> with an <code>IOMemoryDescriptor::complete</code> to unwire the memory.</p></li><li class="li"><p>Always call <code>IOMemoryDescriptor::release</code> to remove the mapping from the DART.</p></li><li class="li"><p>On hardware that includes a DART, pay attention to the DMA direction for reads and writes. On a 64-bit system, a driver that attempts to write to a memory region whose DMA direction is set up for reading will cause a kernel panic.</p></li></ul><p>One side effect of these changes in the memory subsystem is that Mac OS X is likely to return physically contiguous page ranges in memory regions. In earlier versions of Mac OS X, the system returned multi-page memory regions in reverse order, beginning with the last page and moving towards the first page. Because of this, a multi-page memory region seldom contained a physically contiguous range of pages.</p><p>The greatly increased likelihood of seeing physically contiguous blocks of memory in memory regions might expose latent bugs in drivers that did not previously have to handle physically contiguous pages. Be sure to check for this possibility if your driver is behaving incorrectly or panicking.</p><p>Another result of the memory-subsystem changes concerns physical addresses a driver might obtain directly from the pmap layer. Because there is not a one-to-one correspondence between physical addresses and I/O addresses, physical addresses obtained from the pmap layer have no purpose outside the virtual memory system itself. Drivers that use pmap calls (such as <code><!--a-->pmap_extract<!--/a--></code>) to get such addresses will fail to work on systems with a DART. To prevent the use of these calls, Mac OS X v10.3 will refuse to load a kernel extension that uses them, even on systems without a DART.</p><a name="//apple_ref/doc/uid/TP0000019-SW2" title="Supporting DMA on 64-Bit System Architectures"></a><h4>Supporting DMA on 64-Bit System Architectures</h4><p>As described in <span class="content_text">“Address Translation on 64-Bit System Architectures”</span> drivers running in Mac OS X v10.3 and later that use documented, Apple-provided APIs experience few (if any) problems when addressing physical memory on 64-bit systems, because the address translation performed by the DART is transparent to them. However, current Intel-based Macintosh computers do not include a DART and this has ramifications for device drivers that need to use physical addresses, such as those that perform DMA.</p><p>Because there is no hardware-supported address translation, or remapping, performed in current Intel-based Macintosh computers, device drivers that need to access physical memory must be able to address memory above 4 gigabytes. In Mac OS X v10.4.7 and above, you can use the IODMACommand<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_370"></a> class to do this.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_12" title="Important:"></a><p><strong>Important:</strong>&nbsp;A device driver running in Mac OS X v10.4.7 and later that targets Intel-based Macintosh computers <em>must</em> be updated to use IODMACommand if it uses physical addresses. A device driver running in Mac OS X v10.4.7 and later that targets PowerPC-based Macintosh computers is not required to do so, but it’s recommended, especially if the driver uses physical addresses.</p><p></p></div><p>The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IODMACommand_h/Classes/IODMACommand/index.html#//apple_ref/cpp/cl/IODMACommand" target="_top">IODMACommand</a></code> class supersedes the IOMemoryCursor class: it provides all the functionality of IOMemoryCursor and adds a way for you to specify your hardware’s addressing capability and functions to copy memory to a bounce buffer when necessary. When you instantiate an IODMACommand object, you can specify the following attributes:</p><ul class="spaceabove"><li class="li"><p>The number of address bits your hardware can support (for example, 32, 40, or 64)</p></li><li class="li"><p>The maximum segment size</p></li><li class="li"><p>Any alignment restrictions required by your hardware</p></li><li class="li"><p>The maximum I/O transfer size</p></li><li class="li"><p>The format of the physical address segments IODMACommand returns (for example, 32-bit or 64-bit and big-endian, little-endian, or host-endian)</p></li></ul><p>In the typical case, you use an IODMACommand object in the following way:</p><ol class="ol"><li class="li"><p>Create an IODMACommand object per I/O transaction (you can create a pool of IODMACommand objects when your driver starts).</p></li><li class="li"><p>When an I/O request arrives, use <code>IODMACommand::setMemoryDescriptor</code> to target the IOMemoryDescriptor object representing the request.</p></li><li class="li"><p>Call <code>IODMACommand::prepare</code> (among other things, this function allocates the mapping resources that may be required for the transfer).</p></li><li class="li"><p>Use IODMACommand functions to generate the appropriate physical addresses and lengths (<code>IODMACommand::gen64IOVMSegments</code> returns 64-bit addresses and lengths and <code>IODMACommand::gen32IOVMSegments</code> returns 32-bit addresses and lengths).</p></li><li class="li"><p>Start the hardware I/O.</p></li><li class="li"><p>When the I/O is finished, call <code>IODMACommand::complete</code> (to complete the processing of DMA mappings), followed by <code>IODMACommand::clearMemoryDescriptor</code> (to copy data from the bounce buffer, if necessary, and release resources).</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;The IODMACommand <code>prepare</code> and <code>complete</code> functions are distinct from the IOMemoryDescriptor <code>prepare</code> and <code>complete</code> functions. The IODMACommand <code>prepare</code> and <code>complete</code> functions bracket the start and end of the DMA transaction, whereas the IOMemoryDescriptor <code>prepare</code> and <code>complete</code> functions wire and unwire the memory, and must be called as usual. </p></div><p>If your DMA engine does complicated things, such as performing partial I/Os or synchronizing multiple accesses to a single IOMemoryDescriptor, you should write your driver assuming that the memory will be bounced. You don’t need to add code that checks for bouncing, because IODMACommand functions, such as <code>synchronize</code>, are no-ops when they are unnecessary.<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_371"></a></p><a name="//apple_ref/doc/uid/TP0000019-TPXREF110" title="Relaying I/O Requests"></a><h2>Relaying I/O Requests</h2><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_372"></a><p>Client requests are delivered to drivers through specific functions defined by the driver’s family. A storage family driver, for example, handles read requests by implementing the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_373"></a>function <code><!--a-->read<!--/a--></code>. Similarly, a <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_374"></a>network family driver handles requests for transmitting network packets by implementing the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_375"></a>function <code><!--a-->outputPacket<!--/a--></code>.</p><p>An <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_376"></a>I/O request always includes a buffer containing data to write or providing space for data to be read. In the I/O Kit this buffer takes the form of an <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_377"></a>IOMemoryDescriptor object for all families except networking, which uses the <code>mbuf</code> structure defined by BSD for network packets. These two buffer mechanisms provide all drivers with optimized management of data buffers up and down the driver stacks, minimizing the copying of data and performing all the steps required to prepare and complete buffers for I/O operations.</p><p>An I/O Kit family defines I/O and other request interfaces. You typically don’t have to worry about protection of resources in a reentrant context for your driver, unless it specifically forgoes the protection offered by the family or the I/O Kit generally.</p><a name="//apple_ref/doc/uid/TP0000019-TPXREF103" title="More on Memory Descriptors"></a><h2>More on Memory Descriptors</h2><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_378"></a><p>A memory descriptor is an object inheriting from the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_379"></a>IOMemoryDescriptor class that describes how a stream of data, depending on direction, should either be laid into memory or extracted from memory. It represents a segment of memory holding the data involved in an I/O transfer and is specified as one or more physical or virtual address ranges (a range being a starting address and a length in bytes). </p><p>An IOMemoryDescriptor object permits objects at various levels of a driver stack to refer to the same piece of data as mapped into physical memory, the kernel’s virtual address space, or the virtual address space of a user process. The memory descriptor provides functions that can translate between the various address spaces. In a sense, it encapsulates the various mappings throughout the life of some piece of data involved in an I/O transfer.</p><p>IOMemoryDescriptor is an abstract base class defining common methods for describing physical or <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_380"></a>virtual memory. Although it is an abstract class, the I/O Kit provides a concrete general-purpose implementation of IOMemoryDescriptor for objects that are directly instantiated from the class. The I/O Kit also provides two specialized public subclasses of IOMemoryDescriptor: IOMultiMemoryDescriptor and IOSubMemoryDescriptor. <span class="content_text"><a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-BCIBJDGC">Table 8-1</a></span> describes these classes. </p><a name="//apple_ref/doc/uid/TP0000019-BCIBJDGC" title="Table 8-1Subclasses of IOMemoryDescriptor "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8-1&nbsp;&nbsp;</strong>Subclasses of IOMemoryDescriptor </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Class</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_381"></a>IOMultiMemoryDescriptor</p></td><td ><p>Wraps multiple general-purpose memory descriptors into a single memory descriptor. This is commonly done to conform to a bus protocol.</p></td></tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_382"></a>IOSubMemoryDescriptor</p></td><td ><p> Represents a memory area which comes from a specific subrange of some other IOMemoryDescriptor.</p></td></tr></table></div><p>The IOMemoryDescriptor base class itself defines several methods that can be usefully invoked from objects of all subclasses. Some methods return the descriptor’s physically contiguous memory segments (for use with an IOMemoryCursor object) and other methods map the memory into any address space with caching and placed-mapping options.</p><p>A related and generally useful class is <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_383"></a>IOMemoryMap. When you invoke IOMemoryDescriptor’s <code><!--a-->map<!--/a--></code> method to map a memory descriptor in a particular address space, an IOMemoryMap object is returned. Objects of the IOMemoryMap class represent a mapped range of memory as described by an IOMemoryDescriptor. The mapping may be in the kernel or a non-kernel task, or it may be in physical memory. The mapping can have various attributes, including processor cache mode.<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_384"></a></p><a name="//apple_ref/doc/uid/TP0000019-TPXREF104" title="More on Memory Cursors"></a><h2>More on Memory Cursors</h2><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_385"></a><p>An IOMemoryCursor lays out the buffer ranges in an IOMemoryDescriptor object in physical memory. By properly initializing a memory cursor and then invoking that object’s <code><!--a-->getPhysicalSegments<!--/a--></code> function on an IOMemoryDescriptor, a driver can build a scatter/gather list suitable for a particular device or DMA engine. The generation of the scatter/gather list can be made to satisfy the requirements of segment length, transfer length, endian format, and alignment imposed by the hardware.</p><p>A <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_386"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_387"></a>controller driver for a bus such as USB, ATA, or FireWire is typically the object that uses IOMemoryCursors. Such drivers should create an IOMemoryCursor and configure the memory cursor to the limitations of the driver’s DMA hardware or (if PIO is being used instead) the limitations of the device itself. For instance, the memory cursor used for the FireWire SBP-2 protocol should be configured to a maximum physical segment size of 65535 and an unlimited transfer size. </p><p>You can configure an IOMemoryCursor in a variety of ways. The most obvious way is to supply the initialization parameters: maximum segment size, maximum transfer length, and a pointer to a segment function. This callback function, typed <code>SegmentFunction</code>, writes out a single physical segment to an element in a vector array defining the scatter/gather list. Your driver can also perform post-processing on the extracted segments, swapping bytes or otherwise manipulating the contents of the segments. Finally, you can create a subclass of IOMemoryCursor or use one of the subclasses provided by Apple. See <span class="content_text"><a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-BCIGHCAI">“IOMemoryCursor Subclasses”</a></span> for more on this topic.<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_388"></a></p><a name="//apple_ref/doc/uid/TP0000019-BCIFHFJJ" title="DMA and System Memory"></a><h3>DMA and System Memory</h3><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_389"></a><p>Writers of <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_390"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_391"></a>bus controller drivers have two basic considerations<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_392"></a> when they effect I/O transfers. They are receiving data laid out in memory in a particular way and they must send that data to a destination that might expect a radically different memory layout. Depending on direction, the source and destination can be either a DMA <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_393"></a>engine (or a specific device) or the client memory represented by an IOMemoryDescriptor. Additionally, memory coming from the system might be conditioned by the Unified Buffer Cache (UBC) and this has implications for driver writers. This section discusses some of these factors.</p><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_394"></a>Direct Memory Access (DMA) is a built-in capability of certain bus controllers for directly transferring data between a device attached to the bus and system memory—that is, the physical memory on the computer’s motherboard. DMA enhances system performance by freeing the microprocessor from having to do the transfer of data itself.  The microprocessor can work on other tasks while the DMA engine takes care of moving data in and out of the system.</p><p>Each bus on a Mac OS X system has its own DMA engine and they all are different. The PCI bus controller on Mac OS X uses bus master DMA, a type of DMA wherein the controller controls all I/O operations on behalf of the microprocessor. Other bus controllers (ATA, SCSI, or USB, for example) implement different DMA engines. Each engine can have its own alignment, endian format, and size restrictions. </p><p>An alternative to DMA is the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_395"></a>Programmed Input/Output (PIO) interface, usually found on older or under-designed hardware. In PIO, all data transmitted between devices and system memory goes through the microprocessor. PIO is slower than DMA because it consumes more bus cycles to accomplish the same transfer of data. </p><p>Mac OS X supports both bus master DMA and PIO for moving data in and out of the system. In fact, some drivers could conceivably make use of both models for the same I/O transfer—for example, processing most bytes using DMA and then processing the last few bytes using PIO, or using PIO to handle error conditions.</p><p>The <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_396"></a>Unified Buffer Cache (UBC) is a kernel optimization that combines the file-system cache and the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_397"></a>virtual-memory (VM) cache. The UBC eliminates the situation where the same page is duplicated in both caches. Instead, there is just one image in memory and pointers to it from both the file system and the VM system. The underlying structure of the UBC is the <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_398"></a>Universal Page List (UPL). The <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_399"></a>VM pager deals with memory as defined by UPLs; when an I/O request is based on paged-in memory, it is called a conforming request. A non-conforming request is one that isn’t UPL-defined. A UPL segment of memory has certain characteristics; it:</p><ul class="spaceabove"><li class="li"><p>Is page sized (4 kilobytes)</p></li><li class="li"><p>Is page aligned</p></li><li class="li"><p>Has a maximum segment size of 128 kilobytes</p></li><li class="li"><p>Is already mapped into the kernel’s virtual address space</p></li></ul><p>The I/O Kit has adapted its APIs to the UPL model because it’s more efficient for I/O transfers; in addition, it makes it easier to batch I/O requests. An IOMemoryDescriptor object might be backed—entirely or partially—by UPL-defined memory. If the object is backed by a UPL, then there cannot be more than a prearranged number of physical segments. The bus controller driver that extracts the segments (using an IOMemoryCursor) must allocate sufficient resources to issue the I/O request associated with the memory descriptor<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_400"></a>. </p><a name="//apple_ref/doc/uid/TP0000019-TPXREF105" title="Dealing With Hardware Constraints "></a><h3>Dealing With Hardware Constraints </h3><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_401"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_402"></a><p>Apple’s policy on how drivers should deal with <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_403"></a>hardware constraints is generous toward clients of DMA controller drivers and places certain expectations on the drivers themselves.</p><ul class="spaceabove"><li class="li"><p>Clients of DMA controller drivers have no alignment restrictions placed on them. Generally, UPL-defined data (page-aligned and page-sized) should be optimal, but it is not required. </p></li><li class="li"><p>If the memory is UPL-defined, then in order to avoid deadlocking the driver should not allocate memory. Controller drivers must be able to process a UPL without allocating any buffers, or they must preallocate sufficient resources prior to any particular UPL-based I/O transfer. Operations that don’t meet the pager constraints (that is, that aren’t UPL-based) can allocate buffers.</p></li><li class="li"><p>A controller driver must do its best to honor any request that it receives. If necessary, it should even create a buffer (or even use a static buffer), or preallocate resources and copy the data. (Remember that allocation during an I/O request can cause a <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_404"></a>deadlock.) If the driver cannot execute the I/O request, it should return an appropriate error result code.</p></li></ul><p>In summary, driver writers must be prepared to handle a request for any alignment, size, or other restriction. They should first attempt to process the request as conforming to UPL specifications; if the assumption of UPL proves true, they should never allocate memory because doing so could lead to deadlock. If the request is non-conforming, the driver should (and can) do whatever it has to do to satisfy the request, including allocating resources.</p><a name="//apple_ref/doc/uid/TP0000019-BCIGHCAI" title="IOMemoryCursor Subclasses"></a><h3>IOMemoryCursor Subclasses</h3><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_405"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_406"></a><p>Apple provides several subclasses of IOMemoryCursor for different situations. If your <a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_407"></a>DMA engine requires a certain endian data format for its physical segments, your driver can use the subclasses that deal with big-endian and little-endian data formats (and thus will not have to perform this translation when it builds the scatter/gather lists for the DMA engine). Another subclass enables your driver to lay out data in the byte orientation expected by the system’s processor. <span class="content_text"><a href="DataMgmt.html#//apple_ref/doc/uid/TP0000019-BCICHDJC">Table 8-2</a></span> describes these subclasses.</p><a name="//apple_ref/doc/uid/TP0000019-BCICHDJC" title="Table 8-2Apple-provided subclasses of IOMemoryCursor"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8-2&nbsp;&nbsp;</strong>Apple-provided subclasses of IOMemoryCursor</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Subclass</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_408"></a>IONaturalMemoryCursor</p></td><td ><p>Extracts and lays out a scatter/gather list of physical segments in the natural byte order for the given CPU.</p></td></tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_409"></a>IOBigMemoryCursor</p></td><td ><p>Extracts and lays out a scatter/gather list of physical segments encoded in big-endian byte format. Use this memory cursor when the DMA engine requires a big-endian address and length for each segment.</p></td></tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_410"></a>IOLittleMemoryCursor</p></td><td ><p>Extracts and lays out a scatter/gather list of physical segments encoded in little-endian byte format. Use this memory cursor when the DMA engine requires a little-endian address and length for each segment.</p></td></tr></table></div><p>Of course, you can create your own subclass of the virtual IOMemoryCursor or of one of its subclasses to have your memory cursor accomplish exactly what you need it to do. But in many cases, you may not have to create a subclass to get the behavior you’re looking for. Using one of the provided memory-cursor classes, you can implement your own <code><!--a-->outputSegment<!--/a--></code> callback function (which must conform to the <code>SegmentFunction</code> prototype). This function is called by the memory cursor to write out a physical segment in the scatter/gather list being prepared for the DMA engine. In your implementation of this function, you can satisfy any special layouts required by the hardware, such as alignment boundaries.<a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_411"></a><a name="//apple_ref/doc/uid/TP0000019-DontLinkElementID_412"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HandlingEvents/HandlingEvents.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../PowerMgmt/PowerMgmt.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-17<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/DataMgmt/DataMgmt.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/DataMgmt/DataMgmt.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/DataMgmt/DataMgmt.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>