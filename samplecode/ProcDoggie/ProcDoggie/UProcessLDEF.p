{	File:		UProcessLDEF.p	Contains:	This LDEF is a simple replacement for the standard LDEF.  The only advantange				this LDEF has over the standard LDEF is that it contains information specific				to processes that aren’t displayed.  This is to make identifying processes in				the Process List window easier.					Once the icon utilities are released to the developer community, this LDEF				will be updated to display the icon of each process in the list.	Written by: Forrest Tanaka		Copyright:	Copyright © 1988-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/27/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				}UNIT UProcessLDEF;{[j=20/57/1$] Pasmat Options}INTERFACE(******************************************************************************** Used Units*******************************************************************************)	USES		Processes		,Lists		;(******************************************************************************** Types*******************************************************************************)	TYPE		ProcessListInfoRec = RECORD			processName:    Str255;               {Process’s name}			serialNumber:   ProcessSerialNumber  {Process’s serial number}		END;		ProcessListInfoPtr = ^ProcessListInfoRec;(******************************************************************************** ProcessList - Entry point to the List Definition Procedure** This is the entry point to the custom list defproc used in ProcDoggie.  ProcDoggie* actually uses the world's simplest LDEF.  All that LDEF does is call through* the ListRec's refCon field.  So we jam the address of ProcessListLDEF into that* field and, voila, we don't have to have a separate LDEF and we can debug* our LDEF in a high-level debugger.  It's kinda like the classic "6 byte LDEF"* trick, except we don't have to worry about cache flushing.*******************************************************************************)	PROCEDURE ProcessListLDEF (message:    Integer;	                       selectCell: Boolean;	                       VAR cellRect:   Rect;	                       theCell:    Cell;	                       dataOffset: Integer;	                       dataLength: Integer;	                       theList:    ListHandle);IMPLEMENTATION	USES		Script		,TextEdit		,LowMem		,ToolUtils		;	CONST		kCellMargin = 3; {Margin between list contents and list edge in pixels}	{$S Main}	(*******************************************************************************	* Private: HilightCell - Hilight the specified cell	*	* This routine hilights the cell whose rectangle is cellRect.  I also clear the	* hilight bit of the HiliteMode low-memory global.  If this is running on a	* Color QuickDraw machine, then background hilighting is done instead of	* the usual inversion.	*******************************************************************************)	PROCEDURE HilightCell (cellRect: Rect);	VAR		hiliteModeValue:	ByteParameter;			BEGIN		(* Do the fancy, new kind of hilighting on a Color QuickDraw Mac *)		hiliteModeValue := LMGetHiliteMode;		BitClr(Ptr(@hiliteModeValue), pHiliteBit);		LMSetHiliteMode(hiliteModeValue);		(* Now, hilight the cell *)		InvertRect (cellRect)	END;	{$S Main}	(*******************************************************************************	* Private: DrawCell - Draw the contents of the specified cell	*	* This routine draws the contents of the cell specified by theCell into it’s	* rectangle, which is specified by cellRect.  In case the font is too large for	* the cell rectangle, I set the clip region to cellRect before drawing the cell	* text, then set it back to what it was afterwards.	*	* If selected is TRUE, then theCell is selected.  In that case, my HilightCell	* routine is called to hilight the cell.	*	* The list that this all takes place in is specified by theList.	*******************************************************************************)	PROCEDURE DrawCell (cellRect:   Rect;	                    theCell:    Cell;	                    selected:   Boolean;	                    theList:    ListHandle;	                    dataOffset: Integer);		VAR			cellInfo:   ProcessListInfoRec; {Information for cell to be drawn}			currClip:   RgnHandle;          {Handle to the current clip region}			currPen:    PenState;           {Current pen characteristics}			currFont:   FontInfo;           {Current font characteristics}			dataLen:    Integer;            {Length of cell data in bytes}			marginRect: Rect;               {Rect that process name is drawn into}			alignment:  Integer;            {Alignment of process name text}			spareSpace: Integer;            {marginRect width - text width}	BEGIN		{$unused dataOffset}				(* Save the current pen state and set the default pen characteristics *)		GetPenState ((*<*)currPen);		PenNormal;		(* Save the current clip region and set it to cellRect *)		currClip := NewRgn;		GetClip ((*<*)currClip);		ClipRect (cellRect);		(* Will draw text into the cell rect with a margin on left and right *)		marginRect := cellRect;		InsetRect ((*◊*)marginRect, kCellMargin, 0);		(* Get the information for the specified cell *)		dataLen := SIZEOF (ProcessListInfoRec);		LGetCell ((*<*)Ptr(@cellInfo), (*◊*)dataLen, theCell, theList);		(* To find where to draw the cell’s text, get current font information *)		GetFontInfo ((*<*)currFont);		(* Position the pen for drawing the text *)		MoveTo (marginRect.left, marginRect.top + currFont.ascent);		(* Determine whether system script is left-to-right or right-to-left *)		IF GetSysDirection = 0 THEN			alignment := teFlushLeft		ELSE			alignment := teFlushRight;		(* Adjust the pen for right-aligned text if script is right-to-left *)		IF alignment = teFlushRight THEN			BEGIN				spareSpace := marginRect.right - marginRect.left -						StringWidth (cellInfo.processName);				Move (spareSpace, 0);			END;		(* Draw the cell’s contents *)		EraseRect (cellRect);		DrawString (cellInfo.processName);		(* If the cell is selected, hilight it *)		IF selected THEN			HilightCell (cellRect);		(* Restore the current clip region and pen *)		SetClip (currClip);		DisposeRgn (currClip);		SetPenState (currPen);	END;	{$S Main}	(*******************************************************************************	* Public: ProcessList	*	* Here’s the entry point to my custom LDEF.  Yup.	*******************************************************************************)	PROCEDURE ProcessListLDEF (message:    Integer;	                       selectCell: Boolean;	                       VAR cellRect:   Rect;	                       theCell:    Cell;	                       dataOffset: Integer;	                       dataLength: Integer;	                       theList:    ListHandle);	BEGIN		IF message = lDrawMsg THEN			BEGIN				IF dataLength > 0 THEN					DrawCell (cellRect, theCell, selectCell, theList, dataOffset)			END		ELSE IF message = lHiliteMsg THEN			HilightCell (cellRect)	END;END.