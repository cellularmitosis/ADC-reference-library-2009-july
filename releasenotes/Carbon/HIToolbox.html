<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="KEYWORDS" content="Leopard HIToolbox Release Notes" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="/favicon.ico" />
    <title>HIToolbox Release Notes for Mac OS X v10.5</title>
    <style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/mediawiki/skins/monobook/main.css"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css"  href="/mediawiki/skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "/mediawiki/skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "/mediawiki/skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if gte IE 6]><style type="text/css">@import "/mediawiki/skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="/mediawiki/skins/common/IEFixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript" src="/mediawiki/index.php?title=-&amp;action=raw&amp;smaxage=0&amp;gen=js"></script>    <script type="text/javascript" src="/mediawiki/skins/common/wikibits.js"></script>
    <style type="text/css">/*<![CDATA[*/
@import "/mediawiki/index.php?title=MediaWiki:Monobook.css&action=raw&ctype=text/css&smaxage=18000";
@import "/mediawiki/index.php?title=-&action=raw&gen=css&maxage=18000";
/*]]>*/</style>              </head>
  <body                 class="ns-0"><a name="//apple_ref/doc/uid/TP40004744" title="High Level Toolbox Release Notes (10.5)"></a>
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="contentTop"></a>
	  	  <h1 class="firstHeading">HIToolbox Release Notes for Mac OS X v10.5</h1>
	  <div id="bodyContent">
	    <div id="contentSub"></div>
	    	    	    <!-- start content -->
	    <table id='toc' class='toc'><tr><td scope="row"><div id='toctitle'><h2>Contents</h2></div>
<ul>
<li class='toclevel-1'><a href="#Mac_OS_X_Leopard_Developer_Release_Notes:_High_Level_Toolbox"><span class="tocnumber">1</span> <span class="toctext">Mac OS X Leopard Developer Release Notes: High Level Toolbox</span></a></li>
<li class='toclevel-1'><a href="#Features_and_Enhancements"><span class="tocnumber">2</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-1'><a href="#Tips_for_Compatibility_with_Mac_OS_X_Leopard"><span class="tocnumber">3</span> <span class="toctext">Tips for Compatibility with Mac OS X Leopard</span></a></li>
<li class='toclevel-1'><a href="#Bug_Reporting"><span class="tocnumber">4</span> <span class="toctext">Bug Reporting</span></a></li>
<li class='toclevel-1'><a href="#Feedback"><span class="tocnumber">5</span> <span class="toctext">Feedback</span></a></li>
<li class='toclevel-1'><a href="#Accessibility"><span class="tocnumber">6</span> <span class="toctext">Accessibility</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_2"><span class="tocnumber">6.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Appearance_Manager"><span class="tocnumber">7</span> <span class="toctext">Appearance Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_3"><span class="tocnumber">7.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#API_Deprecation"><span class="tocnumber">7.2</span> <span class="toctext">API Deprecation</span></a></li>
<li class='toclevel-2'><a href="#Implementation_Changes"><span class="tocnumber">7.3</span> <span class="toctext">Implementation Changes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#AppleEvents"><span class="tocnumber">8</span> <span class="toctext">AppleEvents</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_4"><span class="tocnumber">8.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Application_Manager"><span class="tocnumber">9</span> <span class="toctext">Application Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_5"><span class="tocnumber">9.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Carbon_Event_Manager"><span class="tocnumber">10</span> <span class="toctext">Carbon Event Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_6"><span class="tocnumber">10.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes"><span class="tocnumber">10.2</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Dialog_Manager"><span class="tocnumber">11</span> <span class="toctext">Dialog Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_7"><span class="tocnumber">11.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#Implementation_Changes_2"><span class="tocnumber">11.2</span> <span class="toctext">Implementation Changes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Drag_Manager"><span class="tocnumber">12</span> <span class="toctext">Drag Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_8"><span class="tocnumber">12.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#API_Deprecation_2"><span class="tocnumber">12.2</span> <span class="toctext">API Deprecation</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_2"><span class="tocnumber">12.3</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Help_Manager"><span class="tocnumber">13</span> <span class="toctext">Help Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_9"><span class="tocnumber">13.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#HIObjects"><span class="tocnumber">14</span> <span class="toctext">HIObjects</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_10"><span class="tocnumber">14.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_3"><span class="tocnumber">14.2</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#HIShape"><span class="tocnumber">15</span> <span class="toctext">HIShape</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_11"><span class="tocnumber">15.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#HIToolbar"><span class="tocnumber">16</span> <span class="toctext">HIToolbar</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_12"><span class="tocnumber">16.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#HIView_Manager"><span class="tocnumber">17</span> <span class="toctext">HIView Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_13"><span class="tocnumber">17.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_4"><span class="tocnumber">17.2</span> <span class="toctext">Notable Bug Fixes</span></a></li>
<li class='toclevel-2'><a href="#Notes"><span class="tocnumber">17.3</span> <span class="toctext">Notes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#IBCarbonRuntime"><span class="tocnumber">18</span> <span class="toctext">IBCarbonRuntime</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_14"><span class="tocnumber">18.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_5"><span class="tocnumber">18.2</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Icon_Services"><span class="tocnumber">19</span> <span class="toctext">Icon Services</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_15"><span class="tocnumber">19.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#API_Deprecation_3"><span class="tocnumber">19.2</span> <span class="toctext">API Deprecation</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Keyboard_Manager"><span class="tocnumber">20</span> <span class="toctext">Keyboard Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#API_deprecation"><span class="tocnumber">20.1</span> <span class="toctext">API deprecation</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_6"><span class="tocnumber">20.2</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Keyboard_Resources"><span class="tocnumber">21</span> <span class="toctext">Keyboard Resources</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_16"><span class="tocnumber">21.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#List_Manager"><span class="tocnumber">22</span> <span class="toctext">List Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#API_Deprecation_4"><span class="tocnumber">22.1</span> <span class="toctext">API Deprecation</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Menu_Manager"><span class="tocnumber">23</span> <span class="toctext">Menu Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_17"><span class="tocnumber">23.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#User_Interface_Changes"><span class="tocnumber">23.2</span> <span class="toctext">User Interface Changes</span></a></li>
<li class='toclevel-2'><a href="#API_Deprecation_5"><span class="tocnumber">23.3</span> <span class="toctext">API Deprecation</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_7"><span class="tocnumber">23.4</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#MLTE"><span class="tocnumber">24</span> <span class="toctext">MLTE</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_18"><span class="tocnumber">24.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#API_Deprecation_6"><span class="tocnumber">24.2</span> <span class="toctext">API Deprecation</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Navigation_Services"><span class="tocnumber">25</span> <span class="toctext">Navigation Services</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_19"><span class="tocnumber">25.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#API_Deprecation_7"><span class="tocnumber">25.2</span> <span class="toctext">API Deprecation</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_8"><span class="tocnumber">25.3</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Pasteboard_Manager"><span class="tocnumber">26</span> <span class="toctext">Pasteboard Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_20"><span class="tocnumber">26.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Scrap_Manager"><span class="tocnumber">27</span> <span class="toctext">Scrap Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#API_Deprecation_8"><span class="tocnumber">27.1</span> <span class="toctext">API Deprecation</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Script_Manager"><span class="tocnumber">28</span> <span class="toctext">Script Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#API_Deprecation_9"><span class="tocnumber">28.1</span> <span class="toctext">API Deprecation</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Text_Input_Sources"><span class="tocnumber">29</span> <span class="toctext">Text Input Sources</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_21"><span class="tocnumber">29.1</span> <span class="toctext">Features and Enhancements</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Text_Services_Manager"><span class="tocnumber">30</span> <span class="toctext">Text Services Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_22"><span class="tocnumber">30.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#API_Deprecation_10"><span class="tocnumber">30.2</span> <span class="toctext">API Deprecation</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_9"><span class="tocnumber">30.3</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Window_Manager"><span class="tocnumber">31</span> <span class="toctext">Window Manager</span></a>
<ul>
<li class='toclevel-2'><a href="#Features_and_Enhancements_23"><span class="tocnumber">31.1</span> <span class="toctext">Features and Enhancements</span></a></li>
<li class='toclevel-2'><a href="#User_Interface_Changes_2"><span class="tocnumber">31.2</span> <span class="toctext">User Interface Changes</span></a></li>
<li class='toclevel-2'><a href="#API_Deprecation_11"><span class="tocnumber">31.3</span> <span class="toctext">API Deprecation</span></a></li>
<li class='toclevel-2'><a href="#Notable_Bug_Fixes_10"><span class="tocnumber">31.4</span> <span class="toctext">Notable Bug Fixes</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Mac_OS_X_Leopard_Developer_Release_Notes:_High_Level_Toolbox"></a><h2>Mac OS X Leopard Developer Release Notes: High Level Toolbox</h2>
<p>For High Level Toolbox release notes for 10.4 and earlier, please refer to HIToolboxOlderNotes.
</p><p>The High Level Toolbox is a subsystem of the Carbon framework for Mac OS X. It is composed of three frameworks: HIToolbox, HIServices, and NavigationServices. This document discusses changes in these three frameworks for Mac OS X Leopard.
</p>
<a name="Features_and_Enhancements"></a><h2>Features and Enhancements</h2>
<p>The major new features in the HIToolbox, HIServices, and NavigationServices frameworks for Mac OS X Leopard are:
</p>
<ul><li> The HIToolbox and HIServices frameworks are available for use in 64-bit applications, but not all APIs are available. In particular, the HIToolbox APIs for creating and managing UI elements (menus, windows, and views) are not available. Use Cocoa to build the UI for a 64-bit application. The NavigationServices framework does not provide a 64-bit API.
</li><li> HIToolbox supports high-resolution displays via framework scaling for compositing windows, and automatic magnification for existing applications. This feature is still in a developer-preview state and is not intended for use by end users; there are known bugs in the current implementation. However, the implementation has significantly improved since Tiger and we encourage application developers to enable framework-scaled mode in compositing windows and test their apps with non-1.0 scaling factors.
</li><li> A new HIView, HICocoaView, allows wrapping an arbitrary NSView into an HIView so that the NSView can be used inside a Carbon window.
</li><li> Navigation Services dialogs are now implemented using the Cocoa NSOpenPanel and NSSavePanel APIs, ensuring that Carbon applications receive the same UI improvements as Cocoa applications.
</li><li> A new API set, Text Input Sources, replaces most of the existing Script Manager, Keyboard, and TextServices APIs.
</li><li> Many standard views support specifying the view image content using a CFURLRef or CFString naming a resource in the application's bundle.
</li><li> Carbon event handlers may be used to receive and handle AppleEvents.
</li><li> New HIObject APIs allow an HIObject to be attached as a delegate to another HIObject.
</li><li> A Carbon event suite for HIObject delegates has been defined, and a sample delegate HIObject is provided that can be used to automatically limit the length of a text-editing field.
</li><li> The Menu Manager supports embedding HIViews in menu items.
</li><li> You can now specify a custom HIObject subclass ID and custom init event parameters in InterfaceBuilder for all of the standard controls and views. This capability requires the use of IB 3.0.
</li><li> The visual appearance for all types of windows (standard, unified, and metal) has changed to use a single common appearance similar to the pre-Leopard unified appearance.
</li><li> The HIThemeDrawTextBox and HIThemeGetTextDimensions APIs now support drawing and measuring CFAttributedStrings.
</li><li> The standard views that draw text, except for the EditText and EditUnicodeText views and HITextView, now support setting the text font to a CTFontRef.
</li><li> The Menu Manager now supports setting a menu item's text using an attributed string, and setting a menu or menu item's font using a CTFontRef.
</li><li> A new header file, HIToolboxDebugging.h, declares the debugging utility functions provided by HIToolbox for use from within gdb.
</li><li> The Window Manager provides a variety of new APIs that take or return window positions and shapes using HIRects and HIShapes.
</li><li> The Window Manager now supports providing a custom view that is positioned in the location of the toolbar, for use by applications that cannot use the standard HIToolbar API.
</li><li> The Pasteboard Manager now defines a protocol for promising files as drag content that is not based on the deprecated FSSpec type.
</li><li> New APIs are provided for determining whether a window or view should draw its content with a focused appearance, and for determining the focused window during menu tracking. See "Modal Focus" in the Window Manager.
</li></ul>
<a name="Tips_for_Compatibility_with_Mac_OS_X_Leopard"></a><h2>Tips for Compatibility with Mac OS X Leopard</h2>
<p>We've noticed that some apps may be incompatible with Leopard due to changes in HIToolbox or HIServices. Here are some changes that may affect your application, and how you can adapt to remain compatible:
</p>
<ul><li> The windows created by the ShowStandardAlert and CreateStandardAlert APIs are now compositing. Some apps have added their own controls to these windows after the window is created and expect non-compositing-style event handling for the window (such as mouse coordinates in QuickDraw port coordinates rather than view-local coordinates). Apple does not recommend or support adding your own controls to a standard alert window, and if you do so, your application must be able to handle both non-compositing and compositing event handling.
</li></ul>
<ul><li> TrackDrag now returns dragNotAcceptedErr when the drag is not accepted by the receiver (4065651). Previously, userCanceledErr was returned in this case, but in Leopard userCanceledErr is reserved only for instances when the user explicitly cancels a drag via the escape or cmd-period key sequences. Your application should be prepared to receive dragNotAcceptedErr as a possible return value from TrackDrag.
</li></ul>
<ul><li> The Navigation Services dialogs offered prior to Mac OS X Leopard happened to work when displayed from a cooperative thread that was not the main thread, although this was not officially supported. The new Cocoa implementation of Navigation Services dialogs does not work from any thread other than the main thread. Therefore, any calls to create or display a Nav dialog from a non-main thread will cause Navigation Services to switch into a compatibility mode in which it will use the classic Carbon-based dialogs rather than the Cocoa dialogs.
</li></ul>
<ul><li> HIViewCreateOffscreenImage now creates native-endian images (4555266). Your application should not assume a particular endian-ness for the CGImage data.
</li></ul>
<ul><li> Prior to Leopard, calling InstallStandardEventHandler on the application target had no effect. In Leopard, it now installs the standard app handler that is used by RunApplicationEventLoop. This handler will dispatch AppleEvents if it receives a kEventAppleEvent Carbon event. Some applications were calling InstallStandardEventHandler on the app target (presumably not realizing that it did nothing) and assuming that AppleEvents would not be dispatched until the application called RunApplicationEventLoop. This assumption is no longer correct. If your app doesn't need AppleEvents to be dispatched, don't install the standard event handler on the app target.
</li></ul>
<ul><li> Keyboard event routing during menu tracking has changed. Prior to Leopard, a keystroke that caused a change in the menu selection (such as the arrow keys, or Tab) would be handled immediately during menu tracking and would not be sent to other event targets beyond the menu itself. In Leopard, in order to support HIViews with keyboard focus embedded inside a menu, all key events are sent to the event dispatcher target, which converts them into kEventClassTextInput events and resends them to the event dispatcher target. The Menu Manager performs keyboard navigation and type-select based on the kEventTextInputUnicodeForKeyEvent event. This change in routing has caused problems for applications that install kEventRawKeyDown/Repeat event handlers on the event dispatcher or application targets. Previously, these handlers would not be called for keyboard navigation keystrokes such as the arrow keys, but in Leopard they are. There are several ways to avoid this problem: (1) use the kEventMenuBeginTracking and kEventMenuEndTracking events to monitor when menu tracking is occurring, and ignore raw key events that are received by your handlers during menu tracking; (2) install your raw key event handlers on a window or view rather than on the app or event dispatcher targets; or (3) don't install handlers for kEventRawKeyDown/Repeat, but use kEventTextInputUnicodeForKeyEvent instead, and install your handler on a window, view, or app target rather than on the event dispatcher target.
</li></ul>
<ul><li> When drawing with QuickDraw into the Dock tile for an application or window, some applications use QDFlushPortBuffer to cause drawing to be flushed to the Dock tile without calling EndQDContextForApplicationDockTile or ReleaseQDContextForCollapsedWindowDockTile. Due to a change in the Dock implementation in Leopard, flushing the QuickDraw port for the tile no longer has any effect. We hope to address this in a future Leopard software update, but until then we recommend that applications use CoreGraphics to draw into the Dock tile (creating the CG context with BeginCGContextForApplicationDockTile or HIWindowCreateCollapsedDockTileContext) and CGContextFlush to cause the Dock tile to update.
</li></ul>
<a name="Bug_Reporting"></a><h2>Bug Reporting</h2>
<p>We encourage all developers to file bugs found in Mac OS X Leopard at &lt;<a href="http://bugreport.apple.com" class='external free' title="http://bugreport.apple.com" rel="nofollow">http://bugreport.apple.com</a>&gt;. Duplicate bugs are not a problem; please don't hesitate to file a bug with the thought that "surely someone else must have found this already."
</p>
<a name="Feedback"></a><h2>Feedback </h2>
<p>The primary method of submitting feedback, such as bug reports and enhancement requests, is to file bugs using Apple's bug reporter website, as described above. This is the only way to ensure that your feedback will be read and considered by Apple engineering.
</p><p>For feedback and comments about HIToolbox, HIServices, and Navigation Services APIs and features, you can email hitoolbox-feedback@group.apple.com. The intent of this address is to provide developers with a direct channel to the engineering team responsible for these technologies. We will read your input, and will try to acknowledge it, but we might not always have time for replies. Please use this address for feedback and comments on the APIs and features (for instance "please add QuickTime wrapper classes to HIToolbox" or "I need API to do this and that"), but not for support type questions (for instance, "I can't install OS X" or "How does one create a new bundle in Xcode?") or comments in other areas (for instance, "why is the dock centered in Aqua?").
</p><p>For discussion among developers, there is the carbon-dev@lists.apple.com mailing list.  Like all of Apple's mailing lists, you can subscribe to this list at <a href="http://lists.apple.com/" class='external free' title="http://lists.apple.com/" rel="nofollow">http://lists.apple.com/</a>.  Although some Apple employees do read and respond to this list, they do so on their own time, not as a part of their job duties. This list can help developers find solutions to their problems among themselves. Mentioning an issue on the list is not an channel for requesting help from Apple; the only ways to get help directly from Apple are by filing a bug or requesting assistance from Apple Developer Technical Support.
</p>
<a name="Accessibility"></a><h2>Accessibility</h2>
<p><b>Header files (HIServices): AXConstants.h, AXError.h, AXUIElement.h, AXValue.h</b><br />
<b>Header files (HIToolbox): HIAccessibility.h</b>
</p>
<a name="Features_and_Enhancements_2"></a><h4>Features and Enhancements</h4>
<p>The Accessibility Carbon events and HIObject APIs have been moved into a separate header file, HIToolbox/HIAccessibility.h.
</p>
<a name="Appearance_Manager"></a><h2>Appearance Manager</h2>
<p><b>Header files (HIToolbox): Appearance.h, HITheme.h</b>
</p>
<a name="Features_and_Enhancements_3"></a><h4>Features and Enhancements</h4>
<p>Exported kThemeAdornmentArrowRightArrow to be used with HIThemeDrawButton and kThemeDisclosureTriangle when drawing the intermediate animation stages of the triangle (2641747). This constant also works on Tiger.
</p><p>Added kThemeTrackHideTrack to be used in the attributes field of HIThemeTrackDrawInfo passed to HIThemeDrawTrack to omit the track part of the track (i.e. the gutter and arrows of a scroll bar or the groove of a slider) (3689743).
</p><p>Exported kThemeMetricButtonRoundedHeight and kThemeMetricButtonRoundedRecessedHeight (4192445). These are the heights of the round-ended buttons as used in the Finder's Search query interface. These metrics were introduced late in Tiger, and were not publicized as the headers were frozen.
</p><p>Added kThemeMetricSeparatorSize to get the height of a horizontal separator or the width of a vertical separator, where a separator is what is drawn by the separator control (which uses the HIThemeDrawSeparator theme primitive) (2885092).
</p><p>The new API HIThemeGetTextColorForThemeBrush has been added. In conjunction with the new API HIWindowGetThemeBackground and HIThemeSetTextFill, it can be used to replace SetThemeTextColorForWindow.
</p><p>Added HIThemeBeginFocus and HIThemeEndFocus to allow for drawing of focus around arbitrary Quartz drawing operations. HIThemeBegin/EndFocus can be used to replace calls to DrawThemeFocusRegion.
</p><p>A new API, HIThemeGetUIFontType, is provided to convert a ThemeFontID to a CTFontUIFontType. Once you have a CTFontUIFontType, you can get a CTFontRef for that font type using CTFontCreateUIFontForLanguage. In this way, you can determine the CTFontRef that corresponds to a particular ThemeFontID.
</p><p>Two new theme metrics, kThemeMetricTexturedPushButtonHeight and kThemeMetricTexturedSmallPushButtonHeight, are provided to return the optimum height for a button using the kThemePushButtonInset or kThemePushButtonInsetSmall theme button kinds. You can create such a button by creating a bevel button and calling SetControlData with kControlBevelButtonKindTag to set the bevel button's kind appropriately.
</p><p>The HIThemeDrawTextBox and HIThemeGetTextDimensions APIs now support CFAttributedStringRef. You may pass an attributed string to these APIs and it will be drawn or measured appropriately. The theme font that you specify to these APIs is applied to any part of the string that does not already have a specified font; parts of the string that already have a font attribute will retain that attribute.
</p><p>The inString parameter of the HIThemeDrawTextBox and HIThemeGetTextDimensions APIs is now typed as a CFTypeRef rather than a CFStringRef. This allows you to pass a CFAttributedStringRef without casting.
</p><p>The older theme text APIs (DrawThemeTextBox, GetThemeTextDimensions, and TruncateThemeText) do not support CFAttributedStringRef, and will return paramErr if passed an attributed string.
</p>
<a name="API_Deprecation"></a><h4>API Deprecation</h4>
<p>Most QuickDraw-based Appearance Manager APIs are now deprecated. You should switch to the CoreGraphics-based HITheme APIs instead. The following typedefs and APIs are deprecated for Leopard:
</p>
<dl><dd>ThemeTabTitleDrawProcPtr
</dd><dd>ThemeEraseProcPtr
</dd><dd>ThemeButtonDrawProcPtr
</dd><dd>WindowTitleDrawingProcPtr
</dd><dd>ThemeIteratorProcPtr
</dd><dd>MenuTitleDrawingProcPtr
</dd><dd>MenuItemDrawingProcPtr
</dd></dl>
<dl><dd>ApplyThemeBackground
</dd><dd>DrawThemeButton
</dd><dd>DrawThemeChasingArrows
</dd><dd>DrawThemeEditTextFrame
</dd><dd>DrawThemeFocusRect
</dd><dd>DrawThemeFocusRegion
</dd><dd>DrawThemeGenericWell
</dd><dd>DrawThemeListBoxFrame
</dd><dd>DrawThemeMenuBackground
</dd><dd>DrawThemeMenuBarBackground
</dd><dd>DrawThemeMenuItem
</dd><dd>DrawThemeMenuSeparator
</dd><dd>DrawThemeMenuTitle
</dd><dd>DrawThemeModelessDialogFrame
</dd><dd>DrawThemePlacard
</dd><dd>DrawThemePopupArrow
</dd><dd>DrawThemePrimaryGroup
</dd><dd>DrawThemeScrollBarArrows
</dd><dd>DrawThemeScrollBarDelimiters
</dd><dd>DrawThemeSecondaryGroup
</dd><dd>DrawThemeSeparator
</dd><dd>DrawThemeStandaloneGrowBox
</dd><dd>DrawThemeStandaloneNoGrowBox
</dd><dd>DrawThemeTab
</dd><dd>DrawThemeTabPane
</dd><dd>DrawThemeTextBox
</dd><dd>DrawThemeTickMark
</dd><dd>DrawThemeTitleBarWidget
</dd><dd>DrawThemeTrack
</dd><dd>DrawThemeTrackTickMarks
</dd><dd>DrawThemeWindowFrame
</dd><dd>DrawThemeWindowHeader
</dd><dd>DrawThemeWindowListViewHeader
</dd><dd>GetThemeButtonBackgroundBounds
</dd><dd>GetThemeButtonContentBounds
</dd><dd>GetThemeButtonRegion
</dd><dd>GetThemeFont
</dd><dd>GetThemeMenuBackgroundRegion
</dd><dd>GetThemeScrollBarTrackRect
</dd><dd>GetThemeStandaloneGrowBoxBounds
</dd><dd>GetThemeTabRegion
</dd><dd>GetThemeTextDimensions
</dd><dd>GetThemeTrackBounds
</dd><dd>GetThemeTrackDragRect
</dd><dd>GetThemeTrackLiveValue
</dd><dd>GetThemeTrackThumbPositionFromOffset
</dd><dd>GetThemeTrackThumbPositionFromRegion
</dd><dd>GetThemeTrackThumbRgn
</dd><dd>GetThemeWindowRegion
</dd><dd>GetThemeWindowRegionHit
</dd><dd>HitTestThemeScrollBarArrows
</dd><dd>HitTestThemeTrack
</dd><dd>IsThemeInColor
</dd><dd>IsValidAppearanceFileType
</dd><dd>IterateThemes
</dd><dd>SetTheme
</dd><dd>SetThemeBackground
</dd><dd>SetThemePen
</dd><dd>SetThemeTextColor
</dd><dd>TruncateThemeText
</dd><dd>UseThemeFont
</dd></dl>
<a name="Implementation_Changes"></a><h4>Implementation Changes</h4>
<p>The Appearance Manager supports high-resolution displays. It can now draw scalable artwork for all appearance primitives, providing a high-quality appearance at any resolution.
</p>
<a name="AppleEvents"></a><h2>AppleEvents</h2>
<p><b>Header file (HIToolbox): AEInteraction.h</b>
</p>
<a name="Features_and_Enhancements_4"></a><h4>Features and Enhancements</h4>
<p>The AEProcessEvent API has been introduced to allow handling of kEventAppleEvent Carbon events without first converting the Carbon event to an EventRecord. We expect to deprecate the classic Event Manager API in a future release of Mac OS X, and this new API allows your application to process AppleEvents without using the classic Event Manager.
</p>
<a name="Application_Manager"></a><h2>Application Manager</h2>
<p><b>Header file (HIToolbox): MacApplication.h</b>
</p>
<a name="Features_and_Enhancements_5"></a><h4>Features and Enhancements</h4>
<p>A new API, HIApplicationCreateDockTileContext, is now available for creating a CGContextRef to draw into an application's Dock tile. Applications may optionally choose to use this API instead of the existing BeginCGContextForApplicationDockTile API. The new API offers applications the ability to draw into Dock tiles at a resolution other than 128x128, which was the size of all Dock tiles prior to Leopard. Dock tiles may now use different sizes when a user interface scaling factor other than 1.0 is in use. In this case, the existing BeginCGContext API will apply a transform to the returned CGContextRef to allow applications to continue drawing at 128x128; the drawing will be scaled to the actual size of the tile. The new API does not apply a transform, but does return the actual size of the tile, so applications can draw into the appropriate bounding rect.
</p><p>Because the Dock's tile size can now change dynamically, applications that use HIApplicationCreateDockTileContext should be prepared to redraw their Dock tile as necessary. The kEventAppUpdateDockTile Carbon event is now sent when the application needs to redraw its Dock tile.
</p><p>The HIApplicationGetFocus API is provided to allow applications to retrieve either the traditional (modeless) focus window or the modal focus window. See the Window Manager section of this documentation for more discussion of modal focus.
</p><p>The kHIApplicationClassID constant is now published. This constant defines the HIObject class ID for the application object. It is valid in 10.3 and later. In 10.5 and later, you can create a subclass of this class ID and instantiate it as the first action in your main function, and your subclass will be used as the singleton Carbon application object for the process.
</p>
<a name="Carbon_Event_Manager"></a><h2>Carbon Event Manager</h2>
<p><b>Header files (HIToolbox): CarbonEvents.h, CarbonEventsCore.h</b>
</p>
<a name="Features_and_Enhancements_6"></a><h4>Features and Enhancements</h4>
<p>The Carbon Event Manager now uses CGEventRefs internally when acquiring events from the window server. Two new APIs have been added to allow conversion between a Carbon event and a CGEventRef: CreateEventWithCGEvent and CopyEventCGEvent.
</p><p>When the Carbon Event Manager receives a keyboard event from the window server, it now inspects the event to determine if it contains Unicode text that was added by the event creator using CGEventKeyboardSetUnicodeString. If so, rather than creating a kEventRawKeyDown Carbon event, a kEventTextInputUnicodeText event is created instead. This event is posted to the event queue as normal, and when the event dispatcher receives the event, the dispatcher calls SendTextInputEvent on the event. SendTextInputEvent converts the event into a kEventTextInputUnicodeForKeyEvent event and resends it to the event dispatcher. These changes allow direct introduction of Unicode text into Carbon and Cocoa applications using CGEventKeyboardSetUnicodeString, without needing to use virtual keycodes or the CGPostKeyboardEvent API.
</p><p>The kEventParamPostOptions event parameter has been documented. This parameter may be added to an event that is being posted to the main event queue with PostEventToQueue. If present, its contents are passed to SendEventToEventTargetWithOptions when the event is handled by the event dispatcher target. This parameter is supported on Mac OS X 10.0 and later.
</p><p>Several new event parameter types have been added to aid in making your application compatible with both 32-bit and 64-bit HIToolbox: typeRefCon, typeByteCount, and typeByteOffset.
</p><p>Event parameters that previously used typeGDHandle now use typeCGDisplayID (a CGDirectDisplayID).
</p><p>The following event parameter coercions have been added:
</p>
<dl><dd>typeVoidPtr		&lt;--&gt;		typeSInt32 (32-bit only)
</dd><dd>typeVoidPtr		&lt;--&gt;		typeUInt32 (32-bit only)
</dd><dd>typeByteCount		&lt;--&gt;		typeSInt32 (32-bit only)
</dd><dd>typeByteOffset		&lt;--&gt;		typeSInt32 (32-bit only)
</dd><dd>typeGDHandle		&lt;--&gt;		typeCGDisplayID (32-bit only)
</dd></dl>
<p>These new coercions provide compatibility with existing applications when requesting event parameters whose underlying data types have changed in Leopard.
</p><p>The RemoveStandardEventHandler API has been added. This API requests that an event target remove the standard handler installed by InstallStandardEventHandler (if any). Calls to InstallStandardEventHandler and RemoveStandardEventHandler are nestable; the standard handler for an event target will only be removed when the same number of calls have been made to remove the handler as were made to install the handler.
</p><p>The HIGetMousePosition API has been added. This is a modern replacement for the GetMouse API that will return the mouse position in an HIPoint parameter. Additionally, the position of the mouse can be requested relative to a window or view rather than just globally.
</p><p>The HIObjectGetEventHandlerObject API, added to the HIObject Manager in Leopard, is useful in many types of Carbon event handlers. This API returns the HIObject that is currently handling an event (i.e., the HIObject on which an event handler is installed), or if the handler is installed on an HIObject delegate object, it returns the HIObject on which the delegate object is installed. You might find this API useful when handling an event that does not have a direct object parameter; in this case, you can use the API to find out which object has received the event.
</p><p>The application event target now supports InstallStandardEventHandler. The standard application event handler is also installed automatically by RunApplicationEventLoop. The standard application event handler handles kEventCommandProcess (for the kHICommandAbout, kHICommandQuit, and kHICommandShowHideFontPanel command IDs) and kEventAppleEvent.
</p><p>The kHICommandCloseFile command ID has been added for use with a “Close File” menu item, as specified in the Mac OS X Human Interface Guidelines (4028591). There is no default handler for this command ID; applications must implement their own support for it.
</p><p>A new API, RemoveEventParameter, allows you to remove a parameter that had previously been stored in an event.
</p><p>The HIMouseTrackingGetParameters API supports three new selectors: kMouseParamsProxyIcon, kMouseParamsClickAndHold, and kMouseParamsDragInitiation.
</p><p>In Events.h, a new set of constants is available that defines the standard virtual keycode values for an ANSI-standard US keyboard layout, as well as keyboard layout-independent keys and some JIS and ISO keys (3320456).
</p><p>The documentation for the kEventWindowSetupProxyDragImage Carbon event now mentions that handlers for this event may return a CGImageRef instead of a GWorldPtr. Support for a CGImageRef parameter has actually been available since Mac OS X 10.2.
</p><p>The kEventWindowGetIdealStandardState event has been made public. This event is sent by IsWindowInStandardState and ZoomWindowIdeal to determine the standard (zoomed-out) state of a window. An application can override this event to customize the standard state; for example, if an application has tool palette windows around the edges of a display, it might want to adjust the standard state to avoid zooming underneath these palette windows. This event is actually available in Mac OS X 10.4 and later.
</p><p>A new option mask, kTrackMouseLocationOptionIncludeScrollWheel, is defined for use with TrackMouseLocationWithOptions, HIViewTrackMouseLocation, and HIViewTrackMouseShape (4537320). This option indicates that the tracking API should check for mouse-wheel Carbon events (kEventMouseWheelMoved and kEventMouseScroll) and return from the loop if either event is seen.
</p><p><b>New and Improved Carbon Events</b>
</p><p>The following Carbon events are new for Mac OS X Leopard:
</p>
<dl><dd>kEventMouseScroll (actually available since Mac OS X 10.4)
</dd><dd>kEventSystemDisplaysAsleep (actually available since Mac OS X 10.4)
</dd><dd>kEventSystemDisplaysAwake (actually available since Mac OS X 10.4)
</dd><dd>kEventWindowTitleChanged (actually available since Mac OS X 10.2)
</dd><dd>kEventControlFocusPartChanged
</dd><dd>kEventControlOptimalBoundsChanged
</dd><dd>kEventDataBrowserDrawCustomItem
</dd><dd>kEventTextInputIsMouseEventInInlineInputArea
</dd><dd>kEventTSMDocumentAccessGetFirstRectForRange
</dd><dd>kEventAppUpdateDockTile
</dd><dd>kEventWindowUpdateDockTile
</dd><dd>kEventWindowFocusLost
</dd><dd>kEventWindowFocusRestored
</dd><dd>kEventSystemDisplayReconfigured
</dd><dd>kEventHIObjectCreatedFromArchive
</dd><dd>kEventHIObjectGetInitParameters
</dd><dd>kEventDelegateInstalled
</dd><dd>kEventDelegateRemoved
</dd><dd>kEventDelegateGetTargetClasses
</dd><dd>kEventDelegateIsGroup
</dd><dd>kEventDelegateGetGroupClasses
</dd></dl>
<p>The following event parameter types, available in Leopard, allow clients to explicitly state the coordinate space of the point, size, rectangle or scalar. Automatic translations are provided between the various coordinate spaces and original typeHIPoint, typeHISize, typeHIRect and typeCGFloat parameter types. For more information on coordinate spaces see HIGeometry.h.
</p>
<dl><dd>typeHIPoint72DPIGlobal
</dd><dd>typeHIPointScreenPixel
</dd><dd>typeHISize72DPIGlobal
</dd><dd>typeHISizeScreenPixel
</dd><dd>typeHIRect72DPIGlobal
</dd><dd>typeHIRectScreenPixel
</dd><dd>typeCGFloat72DPIGlobal
</dd><dd>typeCGFloatScreenPixel 
</dd></dl>
<p>The kEventControlHit event now includes a kEventParamClickCount parameter indicating the click count of the original mouse-down event (3842062). Note that this parameter is optional and won't be present in all instances of this event, particularly if the Accessibility API is being used to simulate a click on the control, or if a client has called HIViewSimulateClick.
</p><p>Previously, scroll wheel events were always routed by the Window Server to the active application. Now, the Window Server routes these events to the application that owns the window under the mouse, even if that application is inactive. HIToolbox previously prevented scroll wheel events received by an inactive application from being turned into Carbon events, but now allows this conversion.
</p><p><b>Menu Context Flags</b>
</p><p>The Spotlight Help feature in Leopard requires scanning the contents of an application's menus to build an index of the menu item text. This index is used when you type into the Help menu to find menu items that match your search string.
</p><p>In order to support menu content that changes dynamically, the Spotlight Help feature has to re-index the menu content each time that the Help menu is opened. Before examining the content of a menu, Spotlight Help sends several Carbon events to allow the application to populate the menu with new menu content. This can be quite slow at times, especially if the menu content is expensive to determine.
</p><p>To allow applications to optimize menu content updating, several new bit flags have been defined as part of the MenuContext bitfield. These flags are:
</p>
<ul><li> kMenuContextInspection: indicates that a Carbon event is being sent because someone is inspecting the menu content.
</li><li> kMenuContentDontUpdate[Text|Icon|Key|Enabled]: indicates that the sender of the Carbon events does not need to inspect the specified menu content. This allows an event handler to optimize its content updating by not updating this content. For example, Spotlight Help doesn't need command keys, icons, or enable state, so it will set all of those flags.
</li></ul>
<p>These flags are included in Carbon events such as kEventMenuOpening, kEventMenuPopulate, kEventMenuEnableItems, and kEventCommandUpdateStatus.
</p><p><b>AppleEvent Handling with Carbon Events</b>
</p><p>The Carbon Event Manager in Leopard allows AppleEvents to be handled using Carbon Event handlers.
</p><p>To handle an AppleEvent using a Carbon event handler, you should:
</p>
<ul><li> Install your Carbon event handler using the AppleEvent class and kind on the application event target.
</li><li> Use GetEventParameter to retrieve parameters from the AppleEvent.
</li><li> Alternately, use kEventParamAppleEvent/typeAppleEvent with GetEventParameter to retrieve an AppleEvent structure from the Carbon event. This is the original AppleEvent that was sent to your application. You can use AppleEvent Manager API to retrieve AppleEvent parameters and attributes from the event.
</li><li> Use SetEventParameter to store parameters into the reply AppleEvent.
</li><li> Alternately, use kEventParamAppleEventReply/typeAppleEvent to retrieve a reply AppleEvent structure from the Carbon event. Modify the reply using AppleEvent Manager API.
</li></ul>
<p>If you need to retrieve an AppleEvent parameter that is a list (AEDescList), you can use GetEventParameter with typeAEDescList to do this. The output buffer should be an AEDescList. In this case, you must call AEDisposeDesc on the AEDescList when you're done with it (unlike normal Carbon event parameters, which do not need to be freed).
</p><p>As with normal Carbon event processing, if your handler returns eventNotHandledErr, the AppleEvent will be passed along to any other Carbon event handlers registered for the same AppleEvent, and then to any AppleEvent handlers. If your handler returns any other value, handling of the AppleEvent will stop with your handler.
</p><p>Note that, while you may call CallNextEventHandler in your Carbon event handler for an AppleEvent, doing so will only call other Carbon event handlers for that AppleEvent; it will not call AppleEvent handlers. The AppleEvent handlers will not be called until your Carbon event handler returns.
</p>
<a name="Notable_Bug_Fixes"></a><h4>Notable Bug Fixes</h4>
<p>The ReleaseWindowMouseTrackingRegions API has been fixed to correctly release the regions (3102994). This API was not functioning correctly in previous releases (back to and including Mac OS X 10.2). Prior to Leopard, clients must release MouseTrackingRefs with the ReleaseMouseTrackingRegion API for each reference.
</p><p>InstallEventLoopTimer now installs the timer into the runloop using the CommonModes constant rather than the DefaultMode constant (4357867). This change is primarily intended to benefit applications that use both Carbon and Cocoa windows. While a mouse-down is being tracked in a control, AppKit will run the runloop in a mode that is not the default mode, which previously would disable Carbon event loop timers. With this change, event loop timers will continue to fire while tracking controls in a Cocoa window. This behavior was already in place for mach-o applications linked on Mac OS X 10.3 and later; we have seen no compatibility issues from this change, so this behavior is now also used for mach-o applications linked on any release of Mac OS X, and for all CFM applications.
</p>
<a name="Dialog_Manager"></a><h2>Dialog Manager</h2>
<p><b>Header file (HIToolbox): Dialogs.h</b>
</p>
<a name="Features_and_Enhancements_7"></a><h4>Features and Enhancements</h4>
<p>StandardAlert and CreateStandardAlert now allow the defaultButton and cancelButton fields of their AlertStdAlertParamRec/AlertStdCFStringAlertParamRec parameter to be set to the same value (2265821). This allows a standard alert to have the same button respond to both default and cancel keyboard equivalents.
</p><p>StandardAlert and CreateStandardAlert now allow the defaultButton field of their AlertStdAlertParamRec/AlertStdCFStringAlertParamRec parameter to be set to zero (3484210). This allows a standard alert to have no default button at all.
</p><p>Two new constants, kDialogFlagsUseCompositing and kAlertFlagsUseCompositing, can be used in 'dlgx' and 'alrx' resources in the flags field. These constants specify that the Dialog Manager should create the dialog or alert window using compositing mode. Note that a compositing dialog window also uses the standard window event handler, so a ModalFilterProcPtr passed to ModalDialog with such a window will never receive any events; the events will all be handled by the standard event handler.
</p>
<a name="Implementation_Changes_2"></a><h4>Implementation Changes</h4>
<p>For HiDPI compatibility, the StandardAlert dialogs are now compositing windows, and use framework-scaled mode (4494014). Note that this may cause compatibility issues with applications that add their own controls to standard alerts. See "Tips for Compatibility with Mac OS X Leopard."
</p>
<a name="Drag_Manager"></a><h2>Drag Manager</h2>
<p><b>Header file (HIToolbox): Drag.h</b>
</p>
<a name="Features_and_Enhancements_8"></a><h4>Features and Enhancements</h4>
<p>ShowDragHilite and HideDragHilite now call HiliteWindowFrameForDrag. The HiliteWindowFrameForDrag documentation states that it is called by these APIs, but it appears that they have never actually done so, at least not on Mac OS X.
</p><p>TrackDrag now accepts a NULL RgnHandle.
</p>
<a name="API_Deprecation_2"></a><h4>API Deprecation</h4>
<p>All the Drag flavor APIs are deprecated for Leopard. Use GetDragPasteboard or NewDragWithPasteboard in addition to the Carbon Pasteboard APIs. The Drag hilite and scroll APIs have also been deprecated for Leopard. Use the kThemeBrushDragHilite theme brush and draw the highlight as part of your custom window or control drawing instead.
</p><p>The following APIs are deprecated for Leopard:
</p>
<dl><dd>GetStandardDropLocation
</dd><dd>SetStandardDropLocation
</dd><dd>ZoomRects
</dd><dd>ZoomRegion
</dd><dd>SetDragItemFlavorData
</dd><dd>InstallTrackingHandler
</dd><dd>InstallReceiveHandler
</dd><dd>RemoveTrackingHandler
</dd><dd>RemoveReceiveHandler
</dd><dd>SetDragSendProc
</dd><dd>CountDragItems
</dd><dd>GetDragItemReferenceNumber
</dd><dd>CountDragItemFlavors
</dd><dd>GetFlavorType
</dd><dd>GetFlavorFlags
</dd><dd>GetFlavorDataSize
</dd><dd>GetFlavorData
</dd><dd>GetDropLocation
</dd><dd>SetDropLocation
</dd><dd>ShowDragHilite
</dd><dd>HideDragHilite
</dd><dd>DragPreScroll
</dd><dd>DragPostScroll
</dd><dd>UpdateDragHilite
</dd><dd>GetDragHiliteColor
</dd></dl>
<a name="Notable_Bug_Fixes_2"></a><h4>Notable Bug Fixes</h4>
<p>The SetDragImageWithCGImage API now accepts images created with any type of alpha value (4031183). Prior to Leopard, only images with an alpha info value between kCGImageAlphaPremultipliedLast and kCGImageAlphaFirst inclusive were properly accepted.
</p><p>TrackDrag now returns dragNotAcceptedErr when the drag is not accepted by the receiver (4065651). userCanceledErr is reserved only for instances when the user explicitly cancels a drag via the escape or cmd-period key sequences.
</p>
<a name="Help_Manager"></a><h2>Help Manager</h2>
<p><b>Header file (HIToolbox): MacHelp.h</b>
</p>
<a name="Features_and_Enhancements_9"></a><h4>Features and Enhancements</h4>
<p>The Help Manager has always supported automatically adding an "&lt;appname&gt; Help" menu item to the the app's Help menu that will open the app's help book when selected. The implementation substitutes the application's name into a localized string to produce, for example, "My Great App Help".
</p><p>In some languages it is necessary to use a different form of application name to get proper agreement with the localized word for "Help". The Help Manager now supports a new Info.plist key, "CFBundleHelpItemAppName", which can be customized to the proper form for the current language. If present, the value of this key are used instead of the application name for substitution in the format string.
</p><p>For example, if you wanted your Help menu to contain "My Great App’s Help" instead of "My Great App Help", you could put a CFBundleHelpItemAppName key into your English InfoPlist.strings file and set the value of the key to be "My Great App’s".
</p><p>Note that if you use this key in any localization, you must add it to all localizations.
</p>
<a name="HIObjects"></a><h2>HIObjects</h2>
<p><b>Header file (HIToolbox): HIObject.h, HIArchive.h</b>
</p>
<a name="Features_and_Enhancements_10"></a><h4>Features and Enhancements</h4>
<p>The HIObject Manager supports several new APIs to allow attaching an HIObject as a delegate for Carbon events sent to another HIObject:
</p>
<dl><dd>HIObjectAddDelegate
</dd><dd>HIObjectRemoveDelegate
</dd><dd>HIObjectGetEventHandlerObject
</dd></dl>
<p>(The last API, HIObjectGetEventHandlerObject, may also be useful in a normal non-delegate Carbon event handler.)
</p><p>A delegate object may receive events sent to its target object either before or after the target object receives them. Using a delegate object is a convenient way to encapsulate the data and code for adding a particular behavior to an existing object, such as a standard HIToolbox view. 
</p><p>The HIArchiveCreateForDecoding API now supports a new option, kHIArchiveDecodingForEditor. This option is intended for use by UI editors that want to open an HIArchive without having the archived objects perform their typical actions when recreated from a nib. If this option is set, the kEventParamDecodingForEditor parameter of the kEventHIObjectInitialize and kEventHIObjectCreatedFromArchive events are set to true when these events are sent to objects in the archive.
</p><p>The HIObjectRegisterSubclass API now supports a new option, kHIClassOptionSingleton. This option indicates that only a single instance of the class should be created. If HIObjectCreate is called more than once on the class ID of a singleton class, the first-created instance is returned each time (with an appropriate increment in the instance's refcount).
</p><p>The kEventClassDelegate suite of Carbon events has been added. These Carbon events are for use by HIObject delegates. They allow a delegate object to be notified when it is installed on or removed from its target object, and to provide information about the behavior of the delegate.
</p><p>A new API, HIObjectFromEventTarget, returns the HIObject that owns an EventTargetRef.
</p><p>A new API, HIObjectCopyDelegates, returns a dictionary of the delegates that are attached to an HIObject.
</p><p>A new Carbon event, kEventHIObjectCreatedFromArchive, is now sent to objects that are created from an XML-based or HIArchive-based nib file (4169417). The event is sent from within the call to CreateWindow/Menu/MenuBarFromNib. In order to handle this event, you need to use either a custom HIView embedded in a window, or an HIObject delegate object whose class ID is specified in the nib file. A typical use of this event would be to allow a custom HIView subclass to initialize its subviews after they have been created when the custom view is loaded from a nib file. In this example, your custom HIView would register for this event, and when the event was sent to your view's event handler, your view could locate and initialize its subviews.
</p><p>A new sample HIObject delegate, HITextLengthFilter, is defined in HITextLengthFilter.h. This HIObject is designed to be instantiated by your application and installed as a delegate object on a text-editing object such as an EditUnicodeText view. Once installed as a delegate, the HITextLengthFilter object will ensure that the amount of text in the text-editing field is limited to a specific length (specified when you instantiated the HITextLengthFilter object).
</p>
<a name="Notable_Bug_Fixes_3"></a><h4>Notable Bug Fixes</h4>
<p>HIObjectCopyClassID may now be called from a kEventHIObjectConstruct handler without crashing (4347944).
</p>
<a name="HIShape"></a><h2>HIShape</h2>
<p><b>Header files (HIServices): HIShape.h</b>
</p>
<a name="Features_and_Enhancements_11"></a><h4>Features and Enhancements</h4>
<p>The HIShape API has been moved from HIToolbox (part of Carbon.framework) to HIServices (part of ApplicationServices.framework). Since Carbon.framework includes ApplicationServices.framework, this will not affect existing apps, but will allow apps that only link against ApplicationServices.framework to use the HIShape API.
</p><p>New HIShape APIs have been added:
</p>
<dl><dd>HIShapeInset
</dd><dd>HIShapeSetWithShape
</dd><dd>HIShapeCreateXor
</dd><dd>HIShapeXor
</dd><dd>HIShapeEnumerate
</dd><dd>HIShapeCreateMutableWithRect
</dd><dd>HIShapeUnionWithRect
</dd></dl>
<p>All of the APIs in HIShape.h are now thread safe, and are marked appropriately in the header documentation. Just the APIs themselves are thread safe -- HIShapeRefs are not. It is safe to call HIShape APIs on multiple threads, so long as no two threads try to operate on the same HIShapeRef at the same time. If you need multiple threads to operate on a single HIShapeRef at the same time, you must implement your own locking mechanism.
</p>
<a name="HIToolbar"></a><h2>HIToolbar</h2>
<p><b>Header file (HIToolbox): HIToolbar.h</b>
</p>
<a name="Features_and_Enhancements_12"></a><h4>Features and Enhancements</h4>
<p>A new API, HIToolbarItemCopyIconRef, returns the IconRef, if any, associated with a toolbar item.
</p><p>Several new command IDs have been defined and are sent by the standard window view in order to request various toolbar behaviors:
</p>
<dl><dd>kHICommandToggleToolbar
</dd><dd>kHICommandToggleAllToolbars
</dd><dd>kHICommandCycleToolbarModeSmaller
</dd><dd>kHICommandCycleToolbarModeLarger
</dd></dl>
<a name="HIView_Manager"></a><h2>HIView Manager</h2>
<p><b>Header files (HIToolbox): HIView.h, Controls.h, ControlDefinitions.h, various view-specific headers</b><br />
Note that the HIView Manager was previously known as the Control Manager.
</p>
<a name="Features_and_Enhancements_13"></a><h4>Features and Enhancements</h4>
<p>The view type and function declarations that were previously contained in ControlDefinitions.h and HIView.h have been split out into separate header files for easier maintainence and legibility. The new header files are:
</p>
<dl><dd>HIButtonViews.h
</dd><dd>HIClockView.h
</dd><dd>HIComboBox.h
</dd><dd>HIContainerViews.h
</dd><dd>HIDataBrowser.h
</dd><dd>HIDisclosureViews.h
</dd><dd>HIImageViews.h
</dd><dd>HILittleArrows.h
</dd><dd>HIMenuView.h
</dd><dd>HIPopupButton.h
</dd><dd>HIProgressViews.h
</dd><dd>HIRelevanceBar.h
</dd><dd>HIScrollView.h
</dd><dd>HISearchField.h
</dd><dd>HISeparator.h
</dd><dd>HISlider.h
</dd><dd>HITabbedView.h
</dd><dd>HITextViews.h
</dd><dd>HIWindowViews.h
</dd></dl>
<p>ControlDefinitions.h now only contains declarations for views that are deprecated and considered obsolete: the non-Unicode EditText view, the ListBox view, the Picture view, and the Scrolling TextBox view.
</p><p>A new set of APIs is available to manipulate the HIViewContentInfo structure introduced in Mac OS X 10.4:
</p>
<dl><dd>HIViewSetImageContent
</dd><dd>HIViewCopyImageContentWithSize
</dd><dd>HIViewRetainImageContent
</dd><dd>HIViewReleaseImageContent
</dd></dl>
<p>These APIs make it easier to set or retrieve the image content that is displayed by a view. The HIViewContentInfo structure has also been enlarged; new fields in this structure allow setting a view's image content to an IconRef specified by type and creator, an image file located in the application's Resources directory, or an image file located at a specified path. The views will automatically load an image file specified by name or path and create a CGImageRef from its contents.
</p><p>These new fields in the HIViewContentInfo structure are supported by the following views: BevelButton, Icon, ImageWell, HIImageView, PushButton, RoundButton, Segment, and Tab.
</p><p>A new API, HIViewSetSubviewsNeedDisplayInShape, allows invalidating both a view and all of its subviews. (The existing HIViewSetNeedsDisplay[InShape/Rect/Region] APIs only invalidate the specified view.)
</p><p>A new API, HIViewAdvanceFocusWithOptions, allows more control over which view is focused. This API takes extra option bits to allow you to specify whether to focus traditionally or focus on any control, regardless of the user's current preferences. You can also prevent focus from wrapping around to the beginning or end of the view hierarchy.
</p><p>Two new APIs, HIWindowGetFocus and HIWindowSetFocus, replace the existing SetKeyboardFocus and GetKeyboardFocus APIs. These APIs also allow you more control over whether a view becomes focused without consideration of the user's current focusing preferences.
</p><p>Two new APIs, HIViewTrackMouseLocation and HIViewTrackMouseShape, provide view-centric equivalents of the TrackMouseLocation and TrackMouseRegion APIs (3123470).
</p><p>A new API, HIViewSetUpTextColor, replaces the existing SetUpControlTextColor API. This API performs the same action as SetUpControlTextColor but with respect to the provided CGContextRef rather than the current port.  
</p><p>Two new APIs, HIImageViewGet/SetAutoTransform, allow image view images to automatically transform according to the state of the view (to behave like a deactivated/disabled ImageWell) (4030522).  
</p><p>Bevel buttons can now have implicit popup menu arrow sizes (2200323). Use SetControlData(..., kControlSizeTag, ...), where the default control size is kControlSizeAuto. kControlSizeAuto has the bevel button render its popup menu arrow at a size that is dependent on the size of the bevel button; this is the behavior on Tiger and earlier. kControlSizeNormal has it render the normal size arrow and kControlSizeSmall has it render the arrow small. All other sizes are invalid.
</p><p>All views now automatically adjust the font of their title or label text to match the view's ControlSize. Previously, you needed to set an ControlFontStyle on the view to match its size; this is no longer necessary.
</p><p>The Group Box view now supports the Normal, Small, and Mini sizes. Setting a ControlSize does not affect the appearance of the box, but it does cause the box label text to draw using an appropriately-sized font.
</p><p>The Chasing Arrows view now supports the Normal and Large sizes. Previously, the view chose an image size based on its view bounds. This is still the default behavior, but you can now also force the control to pick a specific image size by setting the view's ControlSize.
</p><p>Push buttons now support kControlPushButtonAnimatingTag to check if or control whether a button is animating (2903705).
</p><p>The static text control now supports CFAttributedStringRefs. You can provide an attributed string to the static text control using HIViewSetText or SetControlData(kControlStaticTextCFStringTag). When using HIViewSetText, just cast the CFAttributedStringRef to a CFStringRef.
</p><p>HIViewGetOptimalBounds (and GetBestControlRect) now take the title of a disclosure triangle into account when calculating (2231463). Also, the option to display the title has been exported through two new APIs: HIDisclosureTriangleSetDisplaysTitle and HIDisclosureTriangleGetDisplaysTitle. These APIs allow "drawTitle", set at creation in CreateDisclosureTriangleControl to be set on a disclosure triangle after it has been created.
</p><p>The slider control's tick mark count and thumb orientation are now settable after the slider has been created via HISliderGetThumbOrientation, HISliderSetThumbOrientation, HISliderGetTickMarkCount and HISliderSetTickMarkCount (2780970). Note that the client application should explicitly resize the slider (to optimal bounds) to adjust for any thumb orientation or tick mark changes.
</p><p>HIScrollView supports a new option, kHIScrollViewOptionsFillGrowArea, which requests that the scroll view should fill the grow area with white if both scrollbars are visible (3714266).
</p><p>The HIObject class IDs for the Picture view and PopupArrow view have been added to ControlDefinitions.h. These class IDs are actually valid on Panther and later. It is possible to subclass these views on Panther and later as well, but in order to register your subclass on Panther and Tiger, you will first need to create an instance of the type of view you are subclassing, in order to force the view's class to be registered. On Leopard and later, these views will automatically register their HIObject classes, so it is not necessary to create an instance of the view before subclassing it.
</p><p>The DataBrowser now supports kControlUseThemeFontIDMask in a ControlFontStyleRec.
</p><p>The GDBShowControlHierarchy function now prints the entire control hierarchy of a window, starting from the window's root view. It previously started from the window's content view.
</p><p>HIWindowViews.h now declares the HIViewIDs for all of the standard window frame views. Previously, only the view IDs for the content and grow box views were declared. Note that the window frame views use these view IDs on all versions of Mac OS X since Mac OS X 10.2, so even though the variables aren't exported, you can still declare your own HIViewID variables with the same contents if you need to access these views on earlier OS releases.
</p><p>The kEventControlInterceptSubviewClick event now contains a DirectObject parameter, as documented (4450275). 
</p><p>A new Carbon event, kEventControlFocusPartChanged, is now sent when a view's focused part has changed. This event is easier and more obvious to use than the old technique to detect when a view's focus changed, which was to handle the kEventControlSetFocusPart event, call CallNextEventHandler, and then retrieve the output focus part.
</p><p>The standard text-editing views now support spell-checking. Two new ControlData tags, kControlEditTextSpellCheckingTag and kControlEditTextSpellCheckAsYouTypeTag, may be used with Get/SetControlData to enable, disable, and inspect the current spell-checking state of a view.
</p><p>The Data Browser view now supports a compositing custom draw event kEventClassDataBrowser/kEventDataBrowserDrawCustomItem.
</p><p>The kControlContentAlertIconRes constant has been added to Controls.h, and the kHIViewAlertIconType constant has been added to HIView.h (2730877). The kControlContentAlertIconRes constant, actually supported in Mac OS X 10.1 and later, is used in the contentType field of a ControlImageContentInfo structure to tell an Icon control to draw a Note, Caution, or Stop icon using the approved Aqua appearance. On recent versions of Mac OS X, the Note and Stop icons are replaced by the application's icon, and the Caution icon is drawn with the application's icon as a badge. When using this content type with an Icon control, you should set the size of the control to 64x64. Likewise, the kHIViewAlertIconType constant is used in the contentType field of a HIViewContentInfo structure. This content type is supported by most controls that allow customizable image content on Mac OS X 10.5 and later.
</p><p>The HIViewShowsFocus API is provided to allow custom HIViews to determine whether they should draw focus indicators such as focus rings.
</p><p>The HIViewSetTextFont, HIViewSetTextHorizontalFlush, HIViewSetTextVerticalFlush, HIViewSetTextTruncation, and HIViewGetThemeTextInfo APIs are provided to allow callers to set and query custom font and text attributes for controls that draw text. New Control tags are available for Get/SetControlData for custom views: kControlThemeTextFontTag, kControlThemeTextHorizontalFlushTag, kControlThemeTextVerticalFlushTag, kControlThemeTextTruncationTag, and kControlThemeTextInfoTag.
</p><p>A new API, HIViewDrawNSImage, allows an HIView to draw NSImage content into the CGContextRef provided during the kEventControlDraw event.
</p><p>The Clock control supports a new ControlData tag, kControlClockAbsoluteTimeTag, which allows setting or getting the clock time using a CFAbsoluteTime.
</p><p>The Data Browser view supports two new attributes for use with DataBrowserChangeAttributes. The first, kDataBrowserAttributeAutoHideScrollBars, allows the Data Browser instance to automatically hide its horizontal and vertical scroll bars when they aren't necessary. The second, kDataBrowserAttributeReserveGrowBoxSpace, tells the Data Browser instance to always preserve room for a grow box at the bottom right of the view. The AutoHideScrollBars attribute is currently only implemented for list view; it may be set on a DataBrowser in column view, but currently has no effect. The ReserveGrowBoxSpace attribute is implemented for both list and column view.
</p><p>The kEventControlTrackingAreaEntered and Exited events now include a DirectObject parameter containing the HIViewRef that is receiving the event (5198507).
</p><p>When an HIView is archived, it now automatically archives all of its subviews for which HIObjectIsArchivingIgnored returns false.
</p><p>The EditUnicodeText and HITextView controls now support drag and drop.
</p>
<a name="Notable_Bug_Fixes_4"></a><h4>Notable Bug Fixes</h4>
<p>The popup button now positions its menu so that the menu item text aligns with the button title.
</p><p>Setting kControlTabInfoTag on a disabled tab no longer enables that tab. If you were relying on this undocumented and undesired side-effect, you may discover that your tabs are now disabled.
</p><p>The bevel button, image well, icon, and picture views now call HIViewSetNeedsDisplay on themselves after SetControlData is used to modify any aspect of the view that affects its visual appearance.
</p><p>The popup button once again supports drawing its button title using the style and font of the selected menu item (3385698). This capability was available in Mac OS 9 and early versions of Mac OS X, but was broken in Mac OS X 10.3 and 10.4.
</p><p>All views now automatically invalidate themselves when the view's ControlSize changes if the view is being used in composited mode. Previously, most views did not invalidate themselves.
</p><p>It is now possible to make the round button cease to be a help button by setting its ControlImageContentInfo.contentType to kControlContentNone (4413403).
</p><p>The HIViewCreateOffscreenImage API now supports being passed the root view of a window (4431494). Previously, passing the root view would corrupt the root view's state such that subsequent Quickdraw-based drawing in the window would not appear.
</p>
<a name="Notes"></a><h4>Notes</h4>
<p>Currently, an HICocoaView cannot be embedded in an HIScrollView. To workaround this, embed your scrollable content in an NSScrollView and associate that with the HICocoaView instead.
</p><p>Using an HICocoaView in your app requires that you call NSApplicationLoad() at init time. Also, for building, be sure to link to the appropriate frameworks that contain the NSView of interest (e.g. AppKit.framework) and that the module compiles with the ObjC or ObjC++ compiler.
</p>
<a name="IBCarbonRuntime"></a><h2>IBCarbonRuntime</h2>
<p><b>Header file (HIToolbox): IBCarbonRuntime.h</b>
</p>
<a name="Features_and_Enhancements_14"></a><h4>Features and Enhancements</h4>
<p>IBCarbonRuntime now supports the ability to create subclasses of the standard controls and views. A future version of InterfaceBuilder will allow you to set the HIObject class ID and init event parameters of standard controls when editing a nib file. When the nib file is loaded into memory, IBCarbonRuntime will create an instance of your custom class rather than of the standard control. You are responsible for ensuring that your custom class actually is registered as a subclass of the standard class for that control type.
</p>
<a name="Notable_Bug_Fixes_5"></a><h4>Notable Bug Fixes</h4>
<p>If you use InterfaceBuilder to assign a command ID to a menu title in the menubar, you are now able to find that item in the root menu with GetIndMenuItemWithCommandID after calling SetMenuBarFromNib (3518358). For example, you could give your File menu a command ID of 'FILE' in InterfaceBuilder, and then use GetIndMenuItemWithCommandID( NULL, 'FILE', 1, &amp;menu, &amp;item ) to find the item in the root menu that contains the File menu. You could then use GetMenuItemHierarchicalMenu( menu, item, &amp;fileMenu ) to get the MenuRef for the File menu. Note that you must use SetMenuBarFromNib to enable this behavior; you cannot use CreateMenuBarFromNib and then SetMenuBar, because the MenuBarHandle returned by CreateMenuBarFromNib has no room to keep the command ID for a top-level menu.
</p><p>When creating a DataBrowser from a nib, the row height specified in the nib is now obeyed (4234674). Previously, the row height was ignored, and you had to call SetDataBrowserTableViewRowHeight yourself after creating the DataBrowser control.
</p><p>When loading an object from an HIArchive-based nib, the CreateWindowFromNib and CreateMenuFromNib APIs now ensure that you get a new instance of the object each time, even if you are using the same IBNibRef (4424629). In Tiger, it is necessary to release the IBNibRef and reallocate it between multiple calls to get the same object from the nib in order to ensure that you get a new object each time; otherwise, you'll get back the same object with an incremented refcount.
</p>
<a name="Icon_Services"></a><h2>Icon Services</h2>
<p><b>Header file (HIServices): Icons.h</b>
</p>
<a name="Features_and_Enhancements_15"></a><h4>Features and Enhancements</h4>
<p>The Icon Services Manager provides three new APIs for combining IconRefs with modern HI types:
</p>
<dl><dd>IconRefContainsCGPoint
</dd><dd>IconRefIntersectsCGRect
</dd><dd>IconRefToHIShape
</dd></dl>
<p>A new API, GetIconRefFromComponent, returns an IconRef based on the componentIconFamily field of the component's 'thng' resource. This API replaces GetComponentIconSuite, which has been removed from the 64-bit API.
</p>
<a name="API_Deprecation_3"></a><h4>API Deprecation</h4>
<p>Most APIs for working with classic icon formats are now deprecated in Leopard, including:
</p>
<dl><dd>GetCIcon
</dd><dd>PlotCIcon
</dd><dd>DisposeCIcon
</dd><dd>GetIcon
</dd><dd>PlotIcon
</dd><dd>PlotIconID
</dd><dd>NewIconSuite
</dd><dd>AddIconToSuite
</dd><dd>GetIconFromSuite
</dd><dd>ForEachIconDo
</dd><dd>GetIconSuite
</dd><dd>DisposeIconSuite
</dd><dd>PlotIconSuite
</dd><dd>MakeIconCache
</dd><dd>LoadIconCache
</dd><dd>PlotIconMethod
</dd><dd>GetLabel
</dd><dd>PtInIconID
</dd><dd>PtInIconSuite
</dd><dd>PtInIconMethod
</dd><dd>RectInIconID
</dd><dd>RectInIconSuite
</dd><dd>RectInIconMethod
</dd><dd>IconIDToRgn
</dd><dd>IconSuiteToRgn
</dd><dd>IconMethodToRgn
</dd><dd>SetSuiteLabel
</dd><dd>GetSuiteLabel
</dd><dd>GetIconCacheData
</dd><dd>SetIconCacheData
</dd><dd>GetIconCacheProc
</dd><dd>SetIconCacheProc
</dd><dd>PlotIconHandle
</dd><dd>PlotSICNHandle
</dd><dd>PlotCIconHandle
</dd><dd>IconFamilyToIconSuite
</dd><dd>IconSuiteToIconFamily
</dd><dd>GetIconRefFromFile
</dd><dd>RegisterIconRefFromResource
</dd><dd>OverrideIconRefFromResource
</dd><dd>RegisterIconRefFromIconFile
</dd><dd>ReadIconFile
</dd><dd>WriteIconFile
</dd></dl>
<p>In addition, some QuickDraw-based IconRef APIs are now deprecated:
</p>
<dl><dd>PlotIconRef
</dd><dd>PtInIconRef
</dd><dd>RectInIconRef
</dd><dd>IconRefToRgn
</dd></dl>
<a name="Keyboard_Manager"></a><h2>Keyboard Manager</h2>
<p><b>Header file (HIToolbox): Keyboards.h</b>
</p>
<a name="API_deprecation"></a><h4>API deprecation</h4>
<p>Except for KBGetLayoutType, all of the functions in Keyboards.h are deprecated in Leopard and unavailable in the 64-bit API. The preferred alternatives are the functions in TextInputSources.h.
</p>
<a name="Notable_Bug_Fixes_6"></a><h4>Notable Bug Fixes</h4>
<p>KLGetCurrentKeyboardLayout previously returned the Script Manager's notion of current key layout - that is, the keyboard layout with numeric ID corresponding to GetScriptVariable( GetScriptManagerVariable(smKeyScript), smScriptKeys ). This had several problems: it would not return a Unicode-only layout if it was the current layout; it would not always return the current key layout in use if the calling application was not in focus; and it would not reflect the effect of key layout overrides, e.g. from calling TISSetInputMethodKeyboardLayoutOverride. Now KLGetCurrentKeyboardLayout returns the key layout that corresponds to the result of TISCopyCurrentKeyboardLayoutInputSource, which addresses these problems.
</p><p>KLSetCurrentKeyboardLayout now also sets the keyboard layout override for input methods (effectively calling TISSetInputMethodKeyboardLayoutOverride).
</p><p>KLGetKeyboardLayoutProperty now returns resNotFound if the requested property is kKLKCHRData but the value is NULL. This is a much more common scenario now that KCHR data is not available for many Apple-supplied keyboard layouts (for which the preferred format is uchr).
</p>
<a name="Keyboard_Resources"></a><h2>Keyboard Resources</h2>
<a name="Features_and_Enhancements_16"></a><h4>Features and Enhancements</h4>
<p>The preferred format for keyboard layout data is the 'uchr' Unicode format. Accordingly, all Apple keyboard layouts have been converted to 'uchr' format. This keyboard layout data is available through the TISGetInputSourceProperty function (or through the deprecated KLGetKeyboardLayoutProperty function). KCHR-format data is still available for some of these layouts, but only through KLGetKeyboardLayoutProperty or GetResource.
</p><p>HIToolbox provides KCAP resources describing the physical layout of various Apple keyboards.
These were not up to date in Tiger, but have now been updated to include KCAP resources for the desktop keyboards with F16 keys, for the keyboards in the PowerBook and MacBook Pro computers introduced in 2005, and for the new thin keyboards introduced with the new iMacs in August 2007.
</p>
<a name="List_Manager"></a><h2>List Manager</h2>
<p><b>Header file (HIToolbox): Lists.h</b>
</p>
<a name="API_Deprecation_4"></a><h4>API Deprecation</h4>
<p>The entire List Manager has been deprecated for Leopard. Applications should use the DataBrowser instead of the List Manager.
</p>
<a name="Menu_Manager"></a><h2>Menu Manager</h2>
<p><b>Header file (HIToolbox): Menus.h</b> 
</p>
<a name="Features_and_Enhancements_17"></a><h4>Features and Enhancements</h4>
<p>The Menu Manager now provides several new APIs to support embedding an HIView inside a menu item, as seen in the Finder's label color picker. These APIs are:
</p>
<dl><dd>HIMenuSetItemViewClass
</dd><dd>HIMenuCopyItemViewClass
</dd><dd>HIMenuGetItemView
</dd><dd>HIMenuItemViewGetEnclosingMenuItem
</dd><dd>HIMenuItemViewCancelMenuTracking 
</dd></dl>
<p>To embed an HIView in a menu item, an application simply calls HIMenuSetItemViewClass, passing the menu, menu item, HIObject class ID, and an optional initialization EventRef. The Menu Manager automatically instantiates the HIView as necessary when the menu is displayed. Note that the Menu Manager may choose to create more than one instance of a view, if the menu happens to be displayed in more than one window.
</p><p>A menu item view must support the kEventControlGetOptimalBounds Carbon event to return its preferred size. The Menu Manager will send this event during CalcMenuSize to determine how much space to allocate for the menu item view. A menu item view may send the new kEventControlOptimalBoundsChanged Carbon event to itself if its optimal bounds changes; this will cause the menu size to be recalculated and the menu to be resized.
</p><p>Once an HIView has been embedded in a menu item, the Menu Manager provides the following features automatically:
</p>
<ul><li>The view is resized to fit the width of the menu. Its height will be set to the optimal height returned by the view.
</li><li>The view is positioned to track the position of the menu item in the menu. The view will be repositioned if other menu items are inserted or removed in front of the item containing the view. The view will scroll with the rest of the menu contents.
</li><li>The Menu Manager does not draw the normal contents of the menu item. The view is responsible for all drawing of the menu item.
</li><li>The view is inserted into the accessibility hierarchy as a child of the menu item.
</li><li>The view is available for keyboard navigation. When the mouse passes over the view, the Menu Manager automatically attempts to focus on the first part of the view, allowing keyboard navigation within the view. Once focus is on a view part, the user may use Tab and Shift-Tab to move forwards and backwards within the's view's parts; when the focus reaches the last or first part in the view, the next Tab/Shift-Tab will close the current menu and open the next menu. Keyboard events are routed first to the view; if the view does not handle a keyboard event, the Menu Manager will provide its default keyboard navigation handling.
</li></ul>
<p>In general, an HIView does not need any special awareness that it has been embedded in a menu; the standard HIView Carbon events are sufficient. In some cases, a view may wish to vary its behavior when it is embedded. A view can use the HIMenuItemViewGetEnclosingMenuItem API to determine if it, or any superview, is embedded inside a menu item.
</p><p>The Menu Manager now supports dynamic resizing of an open menu. Any changes to a menu that occur while the menu is open (such as insertion or removal of menu items, hiding or showing items, or changing an item's text) will now cause the menu size to be recalculated and the menu window to resize appropriately. As part of this change, menus with dynamic items are now sized to fit just the currently visible items, and the menu resizes as the user presses the modifier keys to fit the newly visible dynamic items.
</p><p>The kEventMenuEndTracking event now contains an EventRef parameter with the event that caused menu tracking to end. This may be useful for applications that wish to vary their behavior depending on exactly how a menu item was selected.
</p><p>When a menu content view or another view embedded inside the content view of a menu receives a kEventControlSimulateHit event, the KeyModifiers parameter of the event now contains the most recently-pressed key modifier combination (4697376). Previously, it always contained zero. This change is meant to allow views that customize their behavior based on the modifiers to be able to easily access the modifier state.
</p><p>The kEventMenuDrawItem and kEventMenuDrawItemContent Carbon events that are sent when a menu item has the kMenuItemAttrCustomDraw attribute now include a new event parameter, kEventParamMenuContextHeight. This parameter contains the height by which the context should be flipped to convert it from Cartesian to HIView-oriented coordinates. Previously, we recommended that you use the height of the current port to flip the context, and this recommendation is still valid in 32-bit mode, but 64-bit mode does not have a current port, so this new event parameter provides the necessary information.
</p><p>Two new APIs, HIMenuSetAttributedItemText and HIMenuCopyAttributedItemText, allow a CFAttributedStringRef to be provided for a menu item. An item may have both attributed and non-attributed strings; setting an attributed string does not affect the non-attributed item text provided with SetMenuItemTextWithCFString. The Menu Manager will draw the menu item using the attributed text, but performs menu type-selection using the non-attributed text, so it is recommended that you always provide both. The non-attributed text is also used for accessibility.
</p><p>Two new APIs, HIMenuSetFont and HIMenuCopyFont, allow a CTFontRef to be provided for a menu or menu item. Setting a font for a menu causes all items in the menu to be drawn with that font by default.
</p><p>New "attributedText" and "font" fields have been added to the MenuItemDataRec structure to allow accessing an item's attributed text or a menu or item's CTFontRef. The kMenuItemDataAttributedText constant is now available to specify that the attributedText field should be used when setting or retrieving item data, and the kMenuItemDataFont constant is now available for accessing the font.
</p><p>A new API, HIMenuSetSelection, allows setting the initial selection in a menu before the menu opens, or changing the selected item of an open menu.
</p><p>A new API, HIMenuCopyParents, returns an array of the parent menus of a submenu (2811173).
</p><p>When a menu uses a custom CTFontRef for all menu content (via HIMenuSetFont with the item parameter set to zero), the font is now applied to all submenus of the menu as well. For compatibility with existing applications, a menu with a custom QD font does not apply this font to its submenus.
</p>
<a name="User_Interface_Changes"></a><h4>User Interface Changes</h4>
<p>When PopUpMenuSelect or ContextualMenuSelect is asked to display a popup menu, and the menu has zero width or height, these APIs now return immediately and do not enter a mouse-tracking loop (4058048).
</p><p>The ContextualMenuSelect API has previously displayed a disabled Help menu item as the first item in the menu when passed the kCMHelpItemNoHelp or kCMHelpItemAppleGuide constants (2580665). The API has been changed so that passing these constants results in no Help item being displayed at all. A help item will now only be displayed if the application passes kCMHelpItemOtherHelp and its own help string.
</p><p>The default positions for menu title and menu item help tags have changed (2828041). A menu title help tag with a tagSide of kHMDefaultSide is now displayed using kHMInsideBottomLeftCorner. A menu item help tag with a tagSide of kHMDefaultSide is now displayed using kHMOutsideRightTopAligned. The menu item positioning change, in particular, was meant to avoid obscuring other menu items.
</p>
<a name="API_Deprecation_5"></a><h4>API Deprecation</h4>
<p>The MenuDefProcPtr type and all related menu definition functionality are deprecated for Leopard. Custom menu appearance and behavior should be implemented using a custom HIView, available in Mac OS X 10.3 and later.
</p><p>The following APIs are deprecated for Leopard:
</p>
<dl><dd>NewMenu
</dd><dd>GetMenuTitle
</dd><dd>SetMenuTitle
</dd><dd>AppendMenu
</dd><dd>InsertMenuItem
</dd><dd>AppendMenuItemText
</dd><dd>InsertMenuItemText
</dd><dd>SetMenuItemText
</dd><dd>GetMenuItemText
</dd><dd>SetItemIcon
</dd><dd>GetItemIcon
</dd><dd>SetMenuItemHierarchicalID
</dd><dd>GetMenuItemHierarchicalID
</dd><dd>GetMenuRetainCount
</dd><dd>RetainMenu
</dd><dd>ReleaseMenu
</dd><dd>InsertResMenu
</dd><dd>AppendResMenu
</dd><dd>InsertFontResMenu
</dd><dd>InsertIntlResMenu
</dd><dd>MenuKey
</dd><dd>SetMenuFlashCount
</dd><dd>DeleteMCEntries
</dd><dd>GetMCInfo
</dd><dd>SetMCInfo
</dd><dd>DisposeMCInfo
</dd><dd>GetMCEntry
</dd><dd>SetMCEntries
</dd><dd>EraseMenuBackground
</dd><dd>ScrollMenuImage
</dd><dd>InitContextualMenus
</dd></dl>
<a name="Notable_Bug_Fixes_7"></a><h4>Notable Bug Fixes</h4>
<p>It is now possible to use SetMenuItemIconHandle with the kMenuIconResourceTypeIcon icon type to provide an icon for a menu item in a window's Dock tile menu (4102535). Previously, this icon type only worked for an application's Dock tile menu.
</p><p>When a menu item provided by a Contextual Menu plugin is added to the contextual menu, the item's command ID is now set to the command ID specified by the plugin (4161281). This allows a plugin to find its own menu items later, if necessary, via a kEventMenuOpening event handler installed on the application event target.
</p><p>When unarchiving a menu, its menu ID and menu title enable state are properly restored (4240282). Previously, an unarchived menu would always have a menu ID of zero and the menu title would always be enabled.
</p><p>The HIMenuViewGetMenu API now works properly for instances of the standard menu view (4137825). Previously, it returned NULL.
</p>
<a name="MLTE"></a><h2>MLTE</h2>
<p><b>Header file (HIToolbox): MacTextEditor.h</b>
</p>
<a name="Features_and_Enhancements_18"></a><h4>Features and Enhancements</h4>
<p>The TXNShowOffset API is provided to allow MLTE clients to show any offset, including offsets that are not part of the selected range.
</p><p>MLTE now supports a subset of emacs control key combinations (control+BFPNAEHD). There is no support for control+KL at this time.
</p><p>TXNControlData::uValue and TXNControlData::sValue changed from UInt32/SInt32 to unsigned long/long for 64-bit compatibility.
</p>
<a name="API_Deprecation_6"></a><h4>API Deprecation</h4>
<p>Deprecated all QD TXNTypeRunAttributes/TXNTypeRunAttributeSizes constants since QuickDraw is deprecated in 32-bit and does not exist in 64-bit mode.
</p><p>Deprecated TXNSetFontDefaults and TXNGetFontDefaults.
</p>
<a name="Navigation_Services"></a><h2>Navigation Services</h2>
<p><b>Header File: Navigation.h</b>
</p>
<a name="Features_and_Enhancements_19"></a><h4>Features and Enhancements</h4>
<p>In Leopard, Navigation Services has been reimplemented atop Cocoa's NSSavePanel. A NavDialogRef may be cast to an NSSavePanel* for put dialogs, an NSOpenPanel* for get and choose dialogs and an NSAlert* for the various ask save changes dialogs. Once cast to the appropriate Cocoa object you can call Cocoa APIs on that object normally. For instance, the custom area of the Nav dialog may be populated with Cocoa NSViews [(NSSavePanel*)myNavDialogRef setAccesoryView:myNSView]. Exception: Once a dialog is created via the NavgationServices API it must be invoked with NavDialogRun. Custom preview support is no longer available on Leopard. NavPreview procedures are no longer called, the kNavCBAdjustPreview Nav event callback messages are no longer sent and the NavCBRec previewRect field will always be empty. Navigation Services now depends on QuickLook for preview rendering. Clients may write a QuickLook plug-in to generate custom previews for open dialogs as well as Finder and Spotlight.
</p>
<a name="API_Deprecation_7"></a><h4>API Deprecation</h4>
<p>The legacy NavFooFile APIs have been deprecated for Leopard. Use the NavCreateFooDialog APIs instead.
</p><p>The following APIs are deprecated for Leopard:
</p>
<dl><dd>NavLoad
</dd><dd>NavUnload
</dd><dd>NavLibraryVersion
</dd><dd>NavGetDefaultDialogOptions
</dd><dd>NavGetFile
</dd><dd>NavPutFile
</dd><dd>NavAskSaveChanges
</dd><dd>NavCustomAskSaveChanges
</dd><dd>NavAskDiscardChanges
</dd><dd>NavChooseFile
</dd><dd>NavChooseFolder
</dd><dd>NavChooseVolume
</dd><dd>NavChooseObject
</dd><dd>NavNewFolder
</dd><dd>NavTranslateFile
</dd><dd>NavServicesCanRun
</dd><dd>NavServicesAvailable
</dd></dl>
<a name="Notable_Bug_Fixes_8"></a><h4>Notable Bug Fixes</h4>
<p>The kNavCBPopupMenuSelect header documentation has been updated on how to better identify when a client's type menu item has been selected (4087669).
</p>
<a name="Pasteboard_Manager"></a><h2>Pasteboard Manager</h2>
<p><b>Header file (HIServices): Pasteboard.h</b>
</p>
<a name="Features_and_Enhancements_20"></a><h4>Features and Enhancements</h4>
<p>Addition of the PasteboardSet/GetStandardPasteLocation and PasteboardSet/GetItemBounds APIs allows clients to perform what used to be drag-specific operations on any pasteboard.
</p><p>Addition of Pasteboard file url-based file promising with kPasteboardTypeFileURLPromise and kPasteboardTypeFilePromiseContent.
</p>
<a name="Scrap_Manager"></a><h2>Scrap Manager</h2>
<p><b>Header file (HIToolbox): Scrap.h</b>
</p>
<a name="API_Deprecation_8"></a><h4>API Deprecation</h4>
<p>The entire Scrap Manager has been deprecated for Leopard. Use the Carbon Pasteboard APIs instead.
</p><p>The following APIs are deprecated for Leopard:
</p>
<dl><dd>LoadScrap
</dd><dd>UnloadScrap
</dd><dd>GetScrapByName
</dd><dd>GetCurrentScrap
</dd><dd>GetScrapFlavorFlags
</dd><dd>GetScrapFlavorSize
</dd><dd>GetScrapFlavorData
</dd><dd>ClearCurrentScrap
</dd><dd>ClearScrap
</dd><dd>PutScrapFlavor
</dd><dd>SetScrapPromiseKeeper
</dd><dd>GetScrapFlavorCount
</dd><dd>GetScrapFlavorInfoList
</dd><dd>CallInScrapPromises
</dd></dl>
<a name="Script_Manager"></a><h2>Script Manager</h2>
<p><b>Header file (HIToolbox): Events.h</b>
 
</p>
<a name="API_Deprecation_9"></a><h4>API Deprecation</h4>
<p>The KeyScript function is deprecated in Leopard and unavailable in the 64-bit API.
</p><p>Positive verbs (i.e. ScriptCode) are replaced by the new TextInputSource API in TextInputSources.h.
</p><p>Negative verbs used to either restrict access to keyboard input sources in the context of a text field, or to disable keyboard switching altogether, are replaced as "input context state" via 2 new TSMDocument properties in TextServices.h:
</p>
<dl><dd>	kTSMDocumentEnabledInputSourcesPropertyTag
</dd><dd>	kTSMDocumentInputSourceOverridePropertyTag
</dd></dl>
<a name="Text_Input_Sources"></a><h2>Text Input Sources</h2>
<p><b>Header file (HIToolbox): TextInputSources.h</b>
 (also see Text Services Manager)
</p>
<a name="Features_and_Enhancements_21"></a><h4>Features and Enhancements</h4>
<p>This is a new API set designed to replace the text input management functions of Script Manager and Text Services Manager.
Most usage of the Script Manager is deprecated, and usage of the Text Services Manager should focus on management of text input context.
The Text Input Sources API provide the modern way to find information about text input sources, select/enable/disable them, and receive notifications about relevant changes.
</p><p>Text input sources are of three general categories:
</p>
<ul><li>Keyboard input sources (keyboard layouts, keyboard input methods and input modes)
</li><li>Palette input sources (e.g. Character Palette, Keyboard Viewer)
</li><li>Ink
</li></ul>
<p>A specific text input source is identified with a TISInputSourceRef, which refers to a CF object. The polymorphic CFBase functions can be used on this (CFRetain, CFRelease, etc.).
</p><p>Each text input source has associated properties. The function TISGetInputSourceProperty can obtain the value of a specified property for a specified input source. The value associated with each property is a specific pointer type (e.g. CFStringRef, CFNumberRef, IconRef); TISGetInputSourceProperty returns a void* for the specified value.
</p><p>Property keys include the following:
</p>
<ul><li>kTISPropertyInputSourceCategory
</li><li>kTISPropertyInputSourceType
</li><li>kTISPropertyInputSourceIsASCIICapable
</li><li>kTISPropertyInputSourceIsSelectable
</li><li>kTISPropertyInputSourceIsEnabled
</li><li>kTISPropertyInputSourceIsSelected
</li><li>kTISPropertyInputSourceID
</li><li>kTISPropertyBundleID
</li><li>kTISPropertyInputModeID
</li><li>kTISPropertyLocalizedName
</li></ul>
<p>(the following cannot be used in the dictionary passed to TISCreateInputSourceList)
</p>
<ul><li>kTISPropertyInputSourceLanguages
</li><li>kTISPropertyUnicodeKeyLayoutData
</li><li>kTISPropertyIconRef
</li><li>kTISPropertyIconImageURL
</li></ul>
<p>The function TISCreateInputSourceList is used to obtain an array of TISInputSourceRefs matching a filter dictionary of property keys and corresponding values.
</p><p>There are convenience functions for obtaining TISInputSourceRefs for various kinds of input sources:
</p>
<ul><li>TISCopyCurrentKeyboardInputSource
</li><li>TISCopyCurrentASCIICapableKeyboardInputSource
</li><li>TISCopyCurrentASCIICapableKeyboardLayoutInputSource
</li><li>TISCopyInputSourceForLanguage
</li><li>TISCreateASCIICapableInputSourceList
</li></ul>
<p>Functions for manipulating input sources include:
</p>
<ul><li>TISSelectInputSource
</li><li>TISDeselectInputSource
</li><li>TISEnableInputSource
</li><li>TISDisableInputSource
</li></ul>
<p>CF distributed notifications for input source changes include:
</p>
<ul><li>kTISNotifySelectedKeyboardInputSourceChanged
</li><li>kTISNotifyEnabledKeyboardInputSourcesChanged
</li></ul>
<p>Functions that pertain to input methods include:
</p>
<ul><li>TISSetInputMethodKeyboardLayoutOverride
</li><li>TISCopyInputMethodKeyboardLayoutOverride
</li><li>TISRegisterInputSource
</li></ul>
<p>Performance improvement: When rebuilding the registry of text input sources (due to the addition or removal of a source, for example), only the portion that corresponds to non-Apple input sources is rebuilt.
</p><p>Add support for datafile input methods: Text files of type ".cin" or ".inputplugin" (in [~]/Library/Input Methods/) that specify behavior for a particular style of CJK text input.
</p><p>Support new plist keys TISInputSourceID, TISIntendedLanguage for input methods/modes (as described in TextInputSources.h).
</p><p>Support new plist keys TISInputSourceID, TISIntendedLanguage for key layouts (as described in textInputSources.h).
</p><p>Add support for InputMethodKit-based palette input methods (plist key InputMethodType = palette).
</p>
<a name="Text_Services_Manager"></a><h2>Text Services Manager</h2>
<p><b>Header file (HIToolbox): TextServices.h</b>
(also see Text Input Sources) 
</p>
<a name="Features_and_Enhancements_22"></a><h4>Features and Enhancements</h4>
<p>TSM supports input methods based on the new IMKit.
	These input methods are located in "/Library/Input Method/" directories in the various /System, /, or ~/ domains.
</p><p>TSM Carbon Events  (kEventClassTextInput, kEventClassTSMDocumentAccess)
</p>
<ul><li>64-bit
</li></ul>
<p>	typeRefCon, typeByteCount, typeByteOffset
</p><p>	TSM events now specify these 64-bit friendly types instead of the old typeLongInteger (really a typeSInt32).
	See notes in CarbonEvents section and documentation in CarbonEvents.h for automatic type coercion between typeLongInteger
	and the modern types for binary compatibility on 32-bit.
</p><p><br />
</p>
<ul><li>Modern TSM event parameters and types - equivalence with older parameter "sets"
</li></ul>
<dl><dd>	typeCTFontRef
</dd><dd>	typeGlyphInfoRef
</dd><dd>	typeCFAttributedStringRef
</dd></dl>
<p>	TSM has defined modern event parameters with the above types in a way that is binary compatible with the existing
	event parameter sets.  TSM is able to "promise" either the new parameter or members of the old parameter set by inspecting
	an event both before it is dispatched to an application and before it is returned to an input method.
	TSM can do this because input methods always dispatch via the SendTextInputEvent bottleneck API.
</p><p><br />
</p>
<dl><dd>	kEventTSMDocumentAccessGetFont
</dd></dl>
<p>		kEventParamTSMDocAccessReplyCTFontRef (typeCTFontRef) encapsulates the following parameters:
			kEventParamTSMDocAccessReplyATSFont
			kEventParamTSMDocAccessReplyFontSize
</p>
<dl><dd>	kEventTSMDocumentAccessGetGlyphInfo
</dd></dl>
<p>		kEventParamTSMDocAccessReplyCTGlyphInfoRef (typeCTGlyphInfoRef) can be requested instead of:
			kEventParamTSMDocAccessReplyATSUGlyphSelector (typeGlyphSelector)
</p>
<dl><dd>	kEventTextInputUnicodeForKeyEvent
</dd></dl>
<p>		kEventParamTextInputSendAttributedString (typeCFAttributedStringRef) encapsulates the following
		parameters:
</p>
<dl><dd>			kEventParamTextInputSendText
</dd><dd>			kEventParamTextInputSendGlyphInfoArray
</dd></dl>
<dl><dd>	kEventTextInputUpdateActiveInputArea
</dd></dl>
<p>		kEventParamTextInputSendAttributedString (typeCFAttributedStringRef) encapsulates the following
		parameters:
</p>
<dl><dd>			kEventParamTextInputSendText
</dd><dd>			kEventParamTextInputSendUpdateRng
</dd><dd>			kEventParamTextInputSendHiliteRng
</dd><dd>			kEventParamTextInputSendClauseRng
</dd><dd>			kEventParamTextInputSendPinRng
</dd><dd>			kEventParamTextInputSendGlyphInfoArray
</dd></dl>
<p><br />
</p>
<ul><li>Support resolution independence in TSM events
</li></ul>
<dl><dd>	typeHIPoint instead of typeQDPoint
</dd></dl>
<p>		CarbonEvents provides automatic type coercion for binary compatibility (on 32-bit only).
</p>
<dl><dd>	typeHIPoint parameters in TSM events can be accessed using any of the variants that specify the coordinate
</dd></dl>
<p>		space of interest, i.e. typeHIPointScreenPixel.
</p>
<dl><dd>	typeCGFloat replaces TSM use of the following types:
</dd><dd>		typeFloat  (see kEventParamTSMDocAccessReplyFontSize)
</dd></dl>
<p>			See detailed note on use of the old typeFloat (typeIEEE64BitFloatingPoint) in CarbonEvents.h for
			this event parameter.
</p>
<dl><dd>		typeFixed  (see kEventParamTextInputReplyPointSize)
</dd></dl>
<dl><dd>		typeSInt16 (see kEventParamTextInputReplyLineHeight, kEventParamTextInputReplyLineAscent)
</dd></dl>
<p>			Note that LineHeight and LineAscent can be accessed using the coordinate space variants
			of typeCGFloat, such as typeCGFloatScreenPixel
</p><p><br />
</p>
<ul><li>Event Parameter deprecation
</li></ul>
<dl><dd>	typeComponentInstance
</dd></dl>
<p>		The typeComponentInstance parameters are deprecated with TSM support for non-Component based
		input methods  (see kEventParamTSMDocAccessSendComponentInstance and
		kEventParamTextInputSendComponentInstance)
</p>
<dl><dd>	typeIntlWritingCode
</dd></dl>
<p>		The typeIntlWritingCode event parameters are deprecated.  Most input methods are Unicode-based, and for
		those that aren't, the ScriptCode can be inferred using the new TextInputSource API.  In particular you can query the
		kTISPropertyInputSourceLanguages property of the input source returned by TISCopyCurrentKeyboardInputSource.
</p><p>Improved performance of ActivateTSMDocument (mostly eliminated calls to KLGetKeyboardLayoutProperty).
</p><p>Some TSM Carbon event parameters that had changed in Leopard to use the new typeByteCount/typeByteOffset, and later typeCFIndex (for signedness), now use the explicit types typeSignedByteCount/typeSignedByteOffset.  This is because typeCFIndex conveys some semantics when dealing with UniChar text buffers.  The event parameters that use these new types are:
</p>
<pre>    kEventParamTextInputSendFixLen
    kEventParamTextInputSendTextOffset
</pre>
<p>See CarbonEvents.h for more information on these.
</p>
<a name="API_Deprecation_10"></a><h4>API Deprecation</h4>
<p>All TSM API that deal with InputSource management have been deprecated and replaced by new TextInputSource (TIS) API
in TextInputSources.h:
</p>
<dl><dd>	GetServiceList
</dd><dd>	SetDefaultInputMethod
</dd><dd>	GetDefaultInputMethod
</dd><dd>	SetTextServiceLanguage
</dd><dd>	GetTextServiceLanguage
</dd><dd>	GetDefaultInputMethodOfClass
</dd><dd>	SetDefaultInputMethodOfClass
</dd><dd>	SelectTextService
</dd><dd>	DeselectTextService
</dd><dd>	IsTextServiceSelected
</dd></dl>
<dl><dd>	TSMCopyInputMethodEnabledInputModes
</dd><dd>	TSMSelectInputMode
</dd></dl>
<p>Other deprecated API:
</p>
<dl><dd>	OpenTextService
</dd><dd>	CloseTextService
</dd><dd>	SendAEFromTSMComponent
</dd><dd>	TSMSetInlineInputRegion
</dd><dd>	GetScriptLanguageSupport
</dd></dl>
<dl><dd>	TSMInputModePaletteLoadButtons
</dd><dd>	TSMInputModePaletteUpdateButtons
</dd><dd>	InputModePaletteItemHit
</dd><dd>	GetInputModePaletteMenu
</dd></dl>
<p>The following functions are not formally deprecated but are not available in the 64-bit API:
</p>
<dl><dd>	NewTSMDocument
</dd><dd>	DeleteTSMDocument
</dd><dd>	ActivateTSMDocument
</dd><dd>	DeactivateTSMDocument
</dd><dd>	FixTSMDocument
</dd><dd>	SendTextInputEvent
</dd><dd>	UseInputWindow
</dd><dd>	InitiateTextService
</dd><dd>	TerminateTextService
</dd><dd>	ActivateTextService
</dd><dd>	DeactivateTextService
</dd><dd>	GetTextServiceMenu
</dd><dd>	TextServiceEventRef
</dd><dd>	FixTextService
</dd><dd>	HidePaletteWindows
</dd><dd>	GetTextServiceProperty
</dd><dd>	SetTextServiceProperty
</dd><dd>	CopyTextServiceInputModeList
</dd></dl>
<a name="Notable_Bug_Fixes_9"></a><h4>Notable Bug Fixes</h4>
<p>Fixed problems in which typing Korean or Chinese characters in the middle of a Latin-script dead-key sequence would produce Latin characters.
</p><p>Fixed problems that prevented typing Chinese/Japanese/Korean in SecurityAgent's login window.
</p><p>Fixed an issue with use of JIS keyboard kana key in Setup Assistant user registration fields.
</p><p>Fixed a problem in which Carbon menu tracking could set the active TSMDocument to NULL for basic applications that only use the default TSMDocument (such as some basic Cocoa applications).
</p><p>Fixed problems with Command-space (switch to previous input source) and JIS keyboard kana key not working after upgrade install.
</p><p>When activating an input method (e.g. in  ActivateTSMDocument), make sure to clear any previous key layout overrides before calling input method's activation.
</p><p>Latin-script dead-key input was not working for key layouts without a 'KCHR' key layout resource (i.e. key layouts with only 'uchr'-format key layout data).
</p><p>Prevent loss of unconfirmed Chinese text input when switching applications.
</p><p>Improve the fix for clearing previous input method key layout overrides when activating.
</p><p>Fixed more problems for key layouts with no 'KCHR' resource (only 'uchr' data): (1) An incorrect internal error caused a crash in Spotlight Preferences and other problems; (2) Can't type non-Mac-script characters in some cases (if the key layout specified by the Script Manager also has no 'KCHR' resource.
</p>
<a name="Window_Manager"></a><h2>Window Manager</h2>
<p><b>Header file (HIToolbox): MacWindows.h</b>
</p>
<a name="Features_and_Enhancements_23"></a><h4>Features and Enhancements</h4>
<p>Since QuickDraw is deprecated in 32-bit and does not exist in 64-bit mode, we are adding new API that uses CGDirectDisplayID instead of GDHandle, HIRect instead of Rect, and so on. The following APIs have been added:
</p>
<dl><dd>HIWindowCreate (replaces CreateNewWindow, CreateCustomWindow)
</dd><dd>HIWindowGetBounds (replaces GetWindowBounds)
</dd><dd>HIWindowSetBounds (replaces SetWindowBounds)
</dd><dd>HIWindowTrackProxyDrag (replaces TrackWindowProxyDrag and TrackWindowProxyFromExistingDrag)
</dd><dd>HIWindowGetIdealUserState (replaces GetWindowIdealUserState)
</dd><dd>HIWindowSetIdealUserState (replaces SetWindowIdealUserState)
</dd><dd>HIWindowIsInStandardState (replaces IsWindowInStandardState)
</dd><dd>HIWindowCopyShape (replaces GetWindowRegion)
</dd><dd>HIWindowConstrain (replaces ConstrainWindowToScreen)
</dd><dd>HIWindowFindAtLocation (replaces FindWindow and friends)
</dd><dd>HIWindowGetGreatestAreaDisplay (replaces GetWindowGreatestAreaDevice)
</dd><dd>HIWindowGetAvailablePositioningBounds (replaces GetAvailableWindowPositioningBounds)
</dd><dd>HIWindowCopyAvailablePositioningShape (replaces GetAvailableWindowPositioningRegion)
</dd><dd>HIWindowCreateCollapsedDockTileContext (replaces CreateQDContextForCollapsedWindowDockTile)
</dd><dd>HIWindowReleaseCollapsedDockTileContext (replaces ReleaseQDContextForCollapsedWindowDockTile)
</dd></dl>
<p>Because the Dock's tile size can now change dynamically, applications that use HIWindowCreateCollapsedDockTileContext should be prepared to redraw their Dock tile as necessary. The kEventWindowUpdateDockTile Carbon event is now sent when the application needs to redraw a collapsed window's Dock tile.
</p><p>The Window Manager now provides more than 32 window attribute bits, and so the attribute bit mask no longer fits in the 32-bit WindowAttributes type. Therefore, we have introduced new APIs to support an arbitrary number of attribute bits:
</p>
<dl><dd>HIWindowTestAttribute
</dd><dd>HIWindowChangeAttributes
</dd><dd>HIWindowIsAttributeAvailable
</dd></dl>
<p>These new APIs use a new set of constants, prefixed with "kHIWindowBit", that are bit numbers, not bit masks. You must not use the older kWindowFooAttribute constants with these new APIs; you must only use the kHIWindowBit constants. Likewise, you must not use the kHIWindowBit constants with the older ChangeWindowAttributes API.
</p><p>These new window attributes are now available:
</p>
<dl><dd>kHIWindowBitTexturedSquareCorners (also as kWindowTexturedSquareCornersAttribute)
</dd><dd>kHIWindowBitUnifiedTitleAndToolbar (also as kWindowUnifiedTitleAndToolbarAttribute)
</dd><dd>kHIWindowBitCanBeVisibleWithoutLogin (also as kWindowCanBeVisibleWithoutLoginAttribute)
</dd><dd>kHIWindowBitDoesNotHide
</dd><dd>kHIWindowBitAutoViewDragTracking
</dd><dd>kHIWindowBitRoundBottomBarCorners
</dd></dl>
<p>kHIWindowBitTexturedSquareCorners indicates that a textured (metal) window has square corners, rather than the default round corners.
</p><p>kHIWindowBitUnifiedTitleAndToolbar is actually supported on Mac OS X 10.4 and later (see Q&amp;A 1423). This attribute specifies that a window uses a unified appearance for its title and toolbar, with no separator drawn between the two areas. Since all windows use the unified appearance on Leopard, it is not necessary to set this attribute on Leopard.
</p><p>kHIWindowBitCanBeVisibleWithoutLogin indicates that a window can be made visible prior to user login. By default, in Leopard and later no windows can be visible before a user logs into the system; this protects the user against certain types of malicious use of insecure applications. However, some software, such as input methods or other accessibility software, may need to deliberately make windows available prior to user login. Such software should add this window attribute to its windows.
</p><p>kHIWindowBitDoesNotHide controls whether a window will hide when its application is hidden (3184642). By default, Utility-class windows have this bit set, and windows of other classes do not.
</p><p>kHIWindowBitAutoViewDragTracking controls whether a window supports automatically sending kEventControlDrag* Carbon events to views within the window. This window attribute is a replacement for the SetAutomaticControlDragTrackingEnabledForWindow API. Setting the attribute is exactly the same as calling the API. The API will be deprecated in a future release of Mac OS X.
</p><p>kHIWindowBitRoundBottomBarCorners applies to windows that do not use the kWindowMetalAttribute. By default, non-metal windows have square bottom corners; setting the RoundBottomBarCorners attributes causes the window to have round corners instead, if the window has a non-zero bottom content border size (see HIWindowSetContentBorderThickness).
</p><p>The HIWindowGetCGWindowID API has been added to allow access to the window server's global window identifier for a WindowRef. This number is not usable with any other Carbon APIs, but may be passed to other APIs that do take window numbers, such as OpenGL.
</p><p>A corresponding API, HIWindowFromCGWindowID, returns the WindowRef that has a specified CGWindowID, if any.
</p><p>Windows that use the Alert, Modal, or AltPlain window classes now support compositing mode.
</p><p>The HIWindowGetThemeBackground  API has been added. In conjunction with the new API HIThemeGetTextColorForThemeBrush and HIThemeSetTextFill it can be used to replace SetThemeTextColorForWindow. 
</p><p>Three constants have been added to identify the HIView part codes that a window frame view should support: kHIWindowTitleBarPart, kHIWindowDragPart, and kHIWindowTitleProxyIconPart.
</p><p>Movable-modal windows now support close and zoom boxes (2884270).
</p><p>Items in the standard window menu that have the kHICommandSelectWindow command ID now also provide a menu item property containing the WindowRef that will be selected when the item is chosen (3976543). The property creator is kHIWindowMenuCreator, and the property tag is kHIWindowMenuWindowTag. Your application can inspect the value of this property to determine which window will be selected when you receive a kEventCommandProcess event with kHICommandSelectWindow, and the command originates from a menu.
</p><p>The Window Manager and the standard window frame view now support application-specified custom toolbar views. A custom toolbar view allows an application to implement its own toolbar appearance and behavior. An application is <b>not</b> allowed to customize the toolbar view of a standard HIToolbarRef; when using the standard HIToolbar API, the toolbox still retains control over the toolbar view. The custom toolbar view API is only meant to allow applications that cannot use the HIToolbar API to provide their own toolbar.
</p><p>A new API, HIWindowSetToolbarView, is provided to allow an application to set a custom toolbar view for a window. After setting a toolbar view, the standard window frame view will automatically show and hide the view when the toolbar button is clicked. A toolbar view must handle several required events, and may optionally respond to several new HICommands in order to implement toolbar customization, multi-window toolbar visibility changes, and toolbar display mode changes. See comments in MacWindows.h just above the prototype for HIWindowSetToolbarView for further documentation.
</p><p>A new API, HIWindowCopyDrawers, returns a list of the drawers attached to a window (3842671).
</p><p>Two new APIs, HIWindowGetBackingLocation and HIWindowSetBackingLocation, are available to control whether a window can be accelerated using the QuartzGL feature of the Leopard CoreGraphics framework.
</p><p>Two new APIs, HIWindowGetSharingType and HIWindowSetSharingType, are available to control whether a window's backing buffer is visible during iChat screen sharing. A window is visible by default, but some applications may wish to make certain windows unavailable to screen sharing for security reasons.
</p><p>Two new APIs, HIWindowSetContentBorderThickness and HIWindowGetContentBorderThickness, allow setting and retrieving the width of a window's bottom content border. The content border is an area at the sides of the window's content area where the window's window structure drawing extends into the content. By default, this width is zero on the left, right, and bottom for windows that do not use kWindowMetalAttribute. The HIWindowSetContentBorderThickness API allows an application to optionally make the bottom content border width non-zero (see Finder in Leopard for an example). The left and right content border widths are currently required to be zero-width and cannot be changed. An application would typically specify a non-zero bottom content border width and also place controls or textual status messages in this area.
</p><p>The kWindowApplicationScaledAttribute constant, and all support for ApplicationScaled mode, has been removed from HIToolbox. This mode was never fully implemented and only was useful for windows that did not use compositing mode. Since 64-bit HIToolbox only supports compositing windows anyways, we have decided that there is little value in finishing the ApplicationScaled mode implementation. For high-resolution compatibility, applications should use compositing mode and FrameworkScaled windows.
</p><p>For ideal interoperability with HIWindowTrackProxyDrag (and thus avoidance of Quickdraw), the BeginWindowProxyDrag API now allows you to pass a NULL outline RgnHandle.
</p><p>A new flag bit, kHIWindowVisibleInAllSpaces, is now allowed for the HIWindowChangeAvailability API. This flag indicates that a window should be visible on all window sets managed by the Spaces feature in Leopard, rather than just the window set on which the window was created.
</p><p>When a window is archived, window availability flags are now included in the archive.
</p><p>TrackWindowProxyFromExistingDrag now accepts a NULL RgnHandle parameter.
</p><p><b>Modal Focus</b>
</p><p>The Window and Control Managers and the standard HIToolbox views now support a new type of user focus called "modal focus". This focusing model is layered on top of the existing user focus window API provided by HIToolbox. The modal focus API is used by UI components that want to temporarily borrow keyboard focus from the user focus window while in a specified mode, and then return focus afterwards. Specifically, it's used by the Menu Manager to borrow keyboard focus while menu tracking is occuring. This allows controls such as edit fields to be embedded in menus, such as the Spotlight-enabled Help menu, and to receive keystrokes while the menu is open. When menu tracking ends, focus is returned to whatever window would normally be the user focus at that point.
</p><p>The modal focus implementation uses a modal focus stack, which is a list of focused windows that override the user focus window. There is currently no API for modifying the modal focus stack. This capability is reserved for system components in Leopard, but may become public in a future release. The topmost window in the focus stack is called the effective focus; this is the window that actually receives keyboard input. The window returned by the GetUserFocusWindow API is now called the modeless focus; this is the window that becomes focused when all focus requests are removed from the modal focus stack. Note that it is possible to change the modeless focus with a call to SetUserFocusWindow without changing the effective focus. In this case, the new modeless focus window does not begin to receive keyboard input until the modal focus stack has been emptied.
</p><p>Several new APIs and Carbon events are provided to manage modal focus:
</p>
<ul><li>The HIApplicationGetFocus API returns either the effective focus or the modeless focus window. Applications can use this to determine if the two windows are different. An application with a custom HIView can also use this to determine if the application should show an insertion point. The insertion point should only be visible if the view is inside the window returned by HIApplicationGetFocus(true).
</li></ul>
<ul><li>The HIViewShowsFocus API indicates whether a view should show focus indicators such as focus rings. It encapsulates checking a variety of different view state, such as whether the view is focused, is active, is enabled, and is in a window that shows focus. Applications with custom HIViews can use this to determine if a view in a window should show the visual appearance of being focused.
</li></ul>
<ul><li>The HIWindowShowsFocus API indicates whether a window's content should show focus indicators such as focus rings. Currently, it returns true if the window is either the modeless or the effective focus window, but it may do more in the future. Applications that cannot use HIViewShowsFocus (perhaps because they have their own private view hierarchy implementation) can use this API to determine if window content should show the visual appearance of being focused.
</li></ul>
<ul><li>The kEventWindowFocusLost and kEventWindowFocusRestored Carbon events are sent when focus is, respectively, borrowed from the effective window and returned to the effective focus window. These are sent to the window gaining or losing focus, and are forwarded by the basic window handler to the focused control in that window, allowing it to invalidate and redraw itself to reflect the new state of the window.
</li></ul>
<p>Applications are not required to do anything to support modal focus, but an application with a custom HIView such as an edit field, which has both insertion point and focus ring indicators, will typically want to be aware of modal focus in order to match the behavior of the system-provided views. In the case of an edit field in the user focus window, when a menu opens, the insertion point in the edit field should stop blinking, but the focus ring around the edit field should remain. A custom view would implement this by listening for the kEventFocusLost and kEventFocusRestored Carbon events, disabling its insertion point when focus is lost and restoring the insertion point when focus is restored, and by using the HIViewShowsFocus API to determine whether to draw the focus ring.
</p>
<a name="User_Interface_Changes_2"></a><h4>User Interface Changes</h4>
<p>The Window Manager now draws all windows using a single consistent visual appearance. The kWindowMetalAttribute and kWindowUnifiedTitleAndToolbarAttribute flags no longer affect the window appearance, except that metal windows automatically have a narrow border on the left, right, and bottom, to preserve compatibility with pre-Leopard window layouts.
</p><p>Windows with a visible toolbar have no visual separation between the window titlebar and the window toolbar. Therefore, a contextual-menu click in the window titlebar is now forwarded to the toolbar view so that the toolbar can show its contextual menu (4479954).
</p><p>Windows that have a proxy icon now additionally respond to a contextual-menu click in the window title text by displaying the window path popup menu (4031690). Previously, only a command-click would cause the path popup menu to be displayed.
</p>
<a name="API_Deprecation_11"></a><h4>API Deprecation</h4>
<p>The WindowDefProcPtr type and all related window definition functionality are deprecated for Leopard. Custom window appearance and behavior should be implemented using a custom window frame HIView, available in Mac OS X 10.2 and later.
</p><p>The following APIs are deprecated for Leopard:
</p>
<dl><dd>NewWindow
</dd><dd>NewCWindow
</dd><dd>GetNewCWindow
</dd><dd>GetNewWindow
</dd><dd>CreateWindowFromResource
</dd><dd>StoreWindowIntoCollection
</dd><dd>CreateWindowFromCollection
</dd><dd>GetWindowOwnerCount
</dd><dd>CloneWindow
</dd><dd>GetWindowRetainCount
</dd><dd>RetainWindow
</dd><dd>ReleaseWindow
</dd><dd>SetWindowClass
</dd><dd>InstallWindowContentPaintProc
</dd><dd>ClipAbove
</dd><dd>PaintOne
</dd><dd>PaintBehind
</dd><dd>CalcVis
</dd><dd>CalcVisBehind
</dd><dd>CheckUpdate
</dd><dd>FrontWindow
</dd><dd>SetWindowPic
</dd><dd>GetWindowPic
</dd><dd>SetWindowProxyFSSpec
</dd><dd>GetWindowProxyFSSpec
</dd><dd>IsWindowPathSelectClick
</dd><dd>SetWTitle
</dd><dd>GetWTitle
</dd><dd>DrawGrowIcon
</dd><dd>GrowWindow
</dd><dd>DragGrayRgn
</dd><dd>DragTheRgn
</dd><dd>GetWVariant
</dd><dd>GetGrayRgn
</dd></dl>
<a name="Notable_Bug_Fixes_10"></a><h4>Notable Bug Fixes</h4>
<p>The standard window frame view (used for document and modal windows) would previously always reset the transparent state of the grow box view whenever the window attributes changed. (The grow box view's default transparency is determined by the window corners; windows with round corners have transparent grow boxes, and windows with square corners have, by default, opaque grow boxes.) This behavior meant that if you wanted to change the attributes of a non-metal window with a transparent grow box, you would need to always make the grow box transparent again after changing the window attributes, because the grow box would always be made opaque by the frame view. The frame view now only resets the grow box transparency when the window's square-corneredness changes (4687777); other attribute changes do not affect the grow box transparency.
</p><p>Copyright © 2005-2007 Apple Inc.
</p>
</body>
</html>
