<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Network Kernel Extensions (legacy): About Network Kernel Extensions</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="About Network Kernel Extensions"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001089-CH225" title="About Network Kernel Extensions"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Kernel-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000532" target="_top">Kernel</a> &gt; <a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_113">Network Kernel Extensions (legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../using/using.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_113" title="About Network Kernel Extensions"></a><h1>About Network Kernel Extensions</h1><div class="importantbox"><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_114" title="Important:"></a><p><strong>Important:</strong>&nbsp;The information provided in this document is relevant for Mac OS 10.1 through 10.3. Specific mention is made for items which apply to newer releases of the OS.</p><p>An important change has long been noted in the <code>&lt;sys/mbuf.h></code> header file since the release of Mac OS X 10.2. Note that the header file is bracketed by the <code>__APPLE_API_UNSTABLE</code> define. The mbuf structure is a key to the processing of packets in an NKE. As part of the formalizing the NKE APIs, it is expected that the mbuf structure will be changed. Details will be provided in the future. Changes to the existing NKE API are not expected be applied to System Updates to Mac OS X 10.3.x, however, bug fixes or features for future systems may require some interim changes.</p><p>For all shipping releases of Mac OS X prior to 10.4, the Network Kernel Extensions (NKE) APIs have not been officially supported. The legacy NKE architecture was implemented as an interim solution. The legacy API was never designed to be officially supported. Other aspects of the OS X networking implementation have received a higher priority, and so the interim solution has remained in effect to OS X 10.3.x.</p><p>The NKE mechanism for Mac OS X version 10.4 and later is described in the document <em><a href="../../NKEConceptual/index.html#//apple_ref/doc/uid/TP40001858" target="_top">Network Kernel Extensions Programming Guide</a></em>.</p><p></p></div><p>Network kernel extensions (NKEs) provide a way to extend and modify the networking infrastructure of Mac OS X while the kernel is running and therefore without requiring the kernel to be recompiled, relinked, or rebooted.</p><p>NKEs allow you to</p><ul class="ul"><li class="li"><p>create protocol stacks that can be loaded and unloaded dynamically and configured automatically.</p></li><li class="li"><p>create modules that can be loaded and unloaded dynamically at specific positions in the network hierarchy. These modules can monitor network traffic, modify network traffic, and receive notification of asynchronous events at the data link and network layers from the driver layer, such as power management events and interface status changes.</p></li></ul><p>An NKE is a specific case of a Mac OS X kernel extension. It is a separately compiled module (produced, for example, by XCode using the Kernel Extension project type).</p><p>An installed and enabled NKE is invoked automatically, depending on its position in the sequence of protocol components, to process an incoming or an outgoing packet. Loading (installing) a kernel extension is handled by the <code>kextload</code>(8) command line utility, which adds the NKE to the running Mac OS X kernel as part of the kernel's address space. Eventually, the system will provide automatic mechanisms for loading extensions. Currently, automatic loading is only possible for IOKit extensions and other extensions that IOKit extensions depend on.</p><p>As a kernel extension, an NKE provides initialization and termination routines that the Kernel Extension Manager invokes when it loads or unloads an NKE. The initialization routine handles any operations needed to complete the incorporation of the NKE into the kernel, such as updating <code>protosw</code> and <code>domain</code> structures. Similarly, the termination routine must remove references to the NKE from these structures in order to unload itself successfully. NKEs must provide a mechanism, such as a reference count, to ensure that the NKE can terminate without leaving dangling pointers.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_1">NKE Implementation</a>
				
			<br/>
			
        
			
			
				<a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_6">PF_NKE Domain</a>
				
			<br/>
			
        
			
			
				<a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_9">Implementing a Preference File for NKE</a>
				
			<br/>
			
        
			
			
				<a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_10">About Protocol Family NKEs</a>
				
			<br/>
			
        
			
			
				<a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_11">About Protocol Handler NKEs</a>
				
			<br/>
			
        
			
			
				<a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_12">About Socket NKEs</a>
				
			<br/>
			
        
			
			
				<a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_13">About Data Link NKEs</a>
				
			<br/>
			
        
			
			
				<a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_19">For more information</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_1" title="NKE Implementation"></a><h2>NKE Implementation</h2><a name="//apple_ref/doc/uid/TP40001089-CH225-BABJJBBF" title="Review of 4.4 BSD Network Architecture"></a><h3>Review of 4.4 BSD Network Architecture</h3><p>Mac OS X is based on the 4.4BSD UNIX operating system. The following structures control the 4.4BSD network architecture:</p><ul class="spaceabove"><li class="li"><p><code>socket</code> structure, which the kernel uses to keep track of sockets. The <code>socket</code> structure is referenced by file descriptors from user mode.</p></li><li class="li"><p><code>domain</code> structure, which describes protocol families.</p></li><li class="li"><p><code>protosw</code> structure, which describes protocol handlers. (A protocol handler is the implementation of a particular protocol in a protocol family.)</p></li><li class="li"><p><code>ifnet</code> structure, which describes a network device and contains pointers to interface device driver routines.</p></li></ul><p>None of these structures is used uniformly throughout the 4.4BSD networking infrastructure. Instead, each structure is used at a specific level, as shown in <span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABFHGDB">Figure 1-1</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_115" title="Figure 1-14.4BSD network architecture"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABFHGDB" title="Figure 1-14.4BSD network architecture"></a><strong>Figure 1-1&nbsp;&nbsp;</strong>4.4BSD network architecture</p><img src = "../art/about-5.gif" alt = "4.4BSD network architecture" width="421" height="186"></div><br/><p>The <code>socket</code> structure is used to manage the socket while the <code>domain</code>, <code>protosw</code>, and <code>ifnet</code> structures are used to manage packet delivery to and from the network device.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_2" title="NKE Types"></a><h3>NKE Types</h3><p>Making the 4.4BSD network architecture dynamically extensible requires several NKE types that are used at specific locations within the kernel.</p><ul class="spaceabove"><li class="li"><p>socket NKEs, which reside between the network layer and protocol handlers and are invoked through a <code>protosw</code> structure. Socket NKEs use a new set of override dispatch vectors that intercept specific socket and socket buffer utility functions.</p></li><li class="li"><p>protocol family NKEs, which are collections of protocols that share a common addressing structure. Internally, a <code>domain</code> structure and a chain of <code>protosw</code> structures describe each protocol. </p></li><li class="li"><p>protocol handler NKEs, which process packets for a particular protocol within the context of a protocol family. A <code>protosw</code> structure describes a protocol handler and provides the mechanism by which the handler is invoked to process incoming and outgoing packets and for invoking various control functions.</p></li><li class="li"><p>data link NKEs, which are inserted below the protocol layer and above the network interface layer. This type of NKE can passively observe traffic as it flows in and out of the system (for example, a sniffer) or can modify the traffic (for example, encrypting or performing address translation). Data link NKEs can provide media support functions (performing demultiplexing, framing, and pre-output functions, such as ARP) and can act as "filters" that are inserted between a protocol stack and a device or above a device.)</p></li></ul><p><span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABEIJHD">Figure 1-2</a></span> summarizes the NKE architecture.</p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_116" title="Figure 1-2NKE architecture"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABEIJHD" title="Figure 1-2NKE architecture"></a><strong>Figure 1-2&nbsp;&nbsp;</strong>NKE architecture</p><img src = "../art/about-7.gif" alt = "NKE architecture" width="421" height="286"></div><br/><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_3" title="Global and Programmatic NKEs"></a><h3>Global and Programmatic NKEs</h3><p>Socket NKEs can operate in one of two modes: programmatic or global.</p><p>A global NKE is an NKE that is automatically enabled for sockets of the type specified for the NKE.</p><p>A programmatic NKE is a socket NKE that is enabled only under program control, using socket options, for a specfic socket.</p><p>Data link `filters' are essentially global in that they can't be accessed by specific sockets.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_4" title="Tracking NKE Usage"></a><h3>Tracking NKE Usage</h3><p>To support the dynamic addition and removal of NKEs in Mac OS X, the kernel keeps track of the use of NKEs by other parts of the system.</p><p>Use of protocol family NKEs is tracked by the <code>dom_refs</code> member of the <code>domain</code> structure, which has been added to support NKEs in Mac OS X. The kernel's <code>socreate</code> function increments <code>dom_refs</code> each time <code>socreate</code> is called to create a socket in an NKE domain. The <code>socreate</code> function is called when user-mode applications call <code>socket</code> or when <code>sonewconn</code> successfully connects to a local listening socket. The <code>dom_refs</code> member is decremented each time <code>soclose</code> is called to close a socket connection.</p><p>Use of protocol handler NKEs is tracked by the <code>pr_refs</code> member of the <code>protosw</code> structure, which has been added to support NKEs in Mac OS X. Like the <code>dom_refs</code> member of the <code>domain</code> structure, the <code>pr_refs</code> member of the <code>protosw</code> structure tracks the use of the protocol between calls to <code>socreate</code> and <code>sonewconn</code> to create a socket and <code>soclose</code> to close a socket.</p><p>The most important aspect of removing an NKE is ensuring that all references to NKE resources are eliminated and that all system resources allocated by the NKE are returned to the system. The NKE must track its use of resources, such as socket structures and protocol control blocks, so that the NKE's termination routine can eliminate references and return system resources.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_5" title="Modifications to 4.4BSD Networking Architecture"></a><h3>Modifications to 4.4BSD Networking Architecture</h3><p>To support NKEs in Mac OS X, the 4.4BSD <code>domain</code> and <code>protosw</code> structures were modified as follows:</p><ul class="spaceabove"><li class="li"><p>The <code>protosw</code> array referenced by the <code>domain</code> structure is now a linked list, thereby removing the array's upper bound. The <code>new dom_maxprotohdr</code> member defines the maximum protocol header size for the domain. The new <code>dom_refs</code> member is a reference count that is incremented when a new socket for this address family is created and is decremented when a socket for this address family is closed.</p></li><li class="li"><p>The <code>protosw</code> structure is no longer an array. The <code>pr_next</code> member has been added to link the structures together. This change has implications for <code>protox</code> usage for <code>AF_INET</code> and <code>AF_ISO</code> input packet processing. The <code>pr_flags</code> member is an unsigned integer instead of a short. NKE hooks have been added to link NKE descriptors together (<code>pr_sfilter</code>).</p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_6" title="PF_NKE Domain"></a><h2>PF_NKE Domain</h2><p>Mac OS X defines a new domain -- the <code>PF_SYSTEM</code> domain-- whose purpose is to provide a way for applications to configure and control NKEs. The <code>PF_SYSTEM </code> domain has two protocols, of which only one is of interest for communications with the NKE: </p><ul class="ul"><li class="li"><p>The <code>SYSPROTO_CONTROL</code> protocol is used for configuring and controlling all NKEs.</p></li></ul><p>Internally, the PF_SYSTEM domain’s initialization function is called when the PF_SYSTEM domain is initially added to the system. The initialization function adds the SYSPROTO_CONTROL protocol to the domain’s protosw list and performs other initialization tasks.</p><p>In the NKE's start method, register a Kernel Controller structure using the ctl_register function. The ctl_register function is defined in &lt;sys/kern_control.h>. The ctl_register call is prototyped as follows.</p><div class="codesample"><table><tr><td scope="row"><pre>int ctl_register(struct kern_ctl_reg *userctl,<span></span></pre></td></tr><tr><td scope="row"><pre>            void *userdata,<span></span></pre></td></tr><tr><td scope="row"><pre>            kern_ctl_ref *ctlref);<span></span></pre></td></tr></table></div><p>The fields of the kern_ctl_reg structure are defined as follows.</p><p><code>ctl_id</code> - unique 4 byte id for the controller. Enter a registered Creator ID. Go to the Apple Developer Creator ID web page to register a unique ID. See <span class="content_text"><a href="http://developer.apple.com/dev/cftype/" target="_top">http://developer.apple.com/dev/cftype/</a></span> for more information.</p><p><code>ctl_unit</code> - the unit number for the controlller. A controller can be registered multiple times with the same ctl_id, but for each instance and different unit number must be used.</p><p><code>ctl_flags</code> - set to <code>CTL_FLAG_PRIVILEGED</code> which requires that the user must have admin privileges to contact the controller.</p><p><code>ctl_sendsize</code> - size of buffer reserved for sending messages.  0 = default value.</p><p><code>ctl_recvsize</code> - size of buffer reserved for receiving messages. 0 = default value.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_7" title="Dispatch Functions"></a><h3>Dispatch Functions</h3><p>ctl_connect - called when the client process calls connect on the socket with the id/unit number of the registered controller.</p><p>clt_disconnect - called when the user client process closes the control socket.</p><p>ctl_write - called when the user client process writes data to the socket.</p><p>ctl_set - called when the user client process setsockopt to set the controller configuration. </p><p>ctl_get - called when the user client process calls getsockopt on the socket.</p><p>The following is a code example of this process.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_117" title="Listing 1-1Dispatch example"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>Dispatch example</p><div class="codesample"><table><tr><td scope="row"><pre>struct kern_ctl_reg     ep_ctl;<span></span></pre></td></tr><tr><td scope="row"><pre>// Initialize controller<span></span></pre></td></tr><tr><td scope="row"><pre>bzero(&amp;ep_ctl, sizeof(ep_ctl));  // sets ctl_unit to 0<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_id = kEPCommID; // should be unique -<span></span></pre></td></tr><tr><td scope="row"><pre>                                   // use a registered Creator ID here<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_flags = CTL_FLAG_PRIVILEGED;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_write = EPHandleWrite;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_get = EPHandleGet;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_set = EPHandleSet;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_connect = EPHandleConnect;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_disconnect = EPHandleDisconnect;<span></span></pre></td></tr><tr><td scope="row"><pre>error = ctl_register(&amp;ep_ctl, &amp;gEPState, &amp;gEPState.ctlHandle);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int EPHandleSet( kern_ctl_ref ctlref, void *userdata, int opt, void *data, size_t len )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int    error = EINVAL;<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleSet opt is %d\n", opt);<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( opt )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEPCommand1:               // program defined symbol<span></span></pre></td></tr><tr><td scope="row"><pre>            error = Do_First_Thing();<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEPCommand2:               // program defined symbol<span></span></pre></td></tr><tr><td scope="row"><pre>            error = Do_Command2();<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return error;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int EPHandleGet( kern_ctl_ref ctlref, void *userdata, int opt, void *data, size_t *len )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int    error = EINVAL;<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleGet opt is %d *****************\n", opt);<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    return error;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int<span></span></pre></td></tr><tr><td scope="row"><pre>EPHandleConnect(kern_ctl_ref ctlref, void *userdata)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleConnect called\n");<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    return (0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void<span></span></pre></td></tr><tr><td scope="row"><pre>EPHandleDisconnect(kern_ctl_ref ctlref, void *userdata)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleDisconnect called\n");<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int EPHandleWrite(kern_ctl_ref ctlref, void *userdata, struct mbuf *m)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleWrite called\n");<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    return (0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_8" title="Connection from the Client Process"></a><h3>Connection from the Client Process</h3><p>After the NKE registers a Kernel Controller structure the application level process opens a PF_SYSTEM socket. The application level process sets up the sockaddr_ctl structure with the required parametrs to communicate with the NKE's Kernel Controller. </p><p>To communicate with the NKE, the client process opens a <code><!--a  -->PF_SYSTEM<!--/a--></code> socket using the socket call.</p><div class="codesample"><table><tr><td scope="row"><pre>fd = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL);<span></span></pre></td></tr></table></div><p>The client process uses the connect call with the file descriptor returned from the socket call to establish a connection with the NKE. In making the connect call, fill in the sockaddr_ctl structure as follows.</p><div class="codesample"><table><tr><td scope="row"><pre>sc_len = sizeof(struct sockaddr_ctl);<span></span></pre></td></tr><tr><td scope="row"><pre>sc_family = AF_SYSTEM;<span></span></pre></td></tr><tr><td scope="row"><pre>ss_sysaddr = AF_SYS_CONTROL;<span></span></pre></td></tr><tr><td scope="row"><pre>sc_id = set to value of ctl_id registered by the NKE in the ctl_reguster call described above.<span></span></pre></td></tr><tr><td scope="row"><pre>sc_unit = set to the unit number registered by the NKE in the ctl_register call described above.<span></span></pre></td></tr></table></div><p>The client process uses the setsockopt call to send commands to the NKE. Note that the option names are user defined. The NKE defines what option names it will respond to, and the client process must pass only supported option names to the NKE in the setsockopt call.</p><p>The client process uses the getsockopt call to get status information from the NKE. Note that the option names are user defined. The NKE defines what option names it will respond to, and the client process must pass only supported option names to the NKE in the setsockopt call.</p><p>The following is a code example for opening a PF_SYSTEM socket to communicate with an NKE</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_118" title="Listing 1-2Opening a PF_SYSTEM socket"></a><p class="codesample"><strong>Listing 1-2&nbsp;&nbsp;</strong>Opening a <code>PF_SYSTEM</code> socket</p><div class="codesample"><table><tr><td scope="row"><pre>      struct sockaddr_ctl       addr;<span></span></pre></td></tr><tr><td scope="row"><pre>      int                       ret = 1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      bzero(&amp;addr, sizeof(addr)); // sets the sc_unit field to 0<span></span></pre></td></tr><tr><td scope="row"><pre>      addr.sc_len = sizeof(addr);<span></span></pre></td></tr><tr><td scope="row"><pre>      addr.sc_family = AF_SYSTEM;<span></span></pre></td></tr><tr><td scope="row"><pre>      addr.ss_sysaddr = AF_SYS_CONTROL;<span></span></pre></td></tr><tr><td scope="row"><pre>      addr.sc_id = kEPCommID;  // should be unique - use a registered Creator ID here<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      fd = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL);<span></span></pre></td></tr><tr><td scope="row"><pre>      if (fd)<span></span></pre></td></tr><tr><td scope="row"><pre>      {<span></span></pre></td></tr><tr><td scope="row"><pre>        result = connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr));<span></span></pre></td></tr><tr><td scope="row"><pre>        if (result)<span></span></pre></td></tr><tr><td scope="row"><pre>           fprintf(stderr, "connect failed %d\n", result);<span></span></pre></td></tr><tr><td scope="row"><pre>      }<span></span></pre></td></tr><tr><td scope="row"><pre>      else<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf(stderr, "failed to open socket\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (!result)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        result = setsockopt( fd, SYSPROTO_CONTROL, kEPCommand1, NULL, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (result)<span></span></pre></td></tr><tr><td scope="row"><pre>          fprintf(stderr, "setsockopt failed on kEPCommand1 call - result was %d\n", result);<span></span></pre></td></tr><tr><td scope="row"><pre>       etc.<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_9" title="Implementing a Preference File for NKE"></a><h2>Implementing a Preference File for NKE</h2><p>The question arises as to how an NKE can open a "preference file" in the start method. Under the existing architecture, the NKE cannot reliably access a Preference File.  When the system starts the NKE, there are no APIs, which the NKE can use to open a file and read preference information. While the NKE could access its info.plist, there is the assumption that the info.plist will not be changed across startups as this information is cached by the system in order to expedite startups. </p><p>The proper way to dynamically configure an NKE is with a startup daemon or other application level process. The daemon finds the NKE using the communication method described above, and passes in configuration information that the NKE may require.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_10" title="About Protocol Family NKEs"></a><h2>About Protocol Family NKEs</h2><p>Adding and removing protocol family NKEs is accomplished by calling <code>net_add_domain</code> and <code>net_del_domain</code>, respectively. These calls are described in <span class="content_text"><a href="../reference/reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHFFGI">“Protocol Family NKE Functions.”</a></span> For detailed information about implementing protocol families, see <code>The Design and Implementation of the 4.4 BSD Operating System</code> by M. K. McKusick. et al. and <code>TCP/IP Illustrated</code> by Richard W. Stevens.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_11" title="About Protocol Handler NKEs"></a><h2>About Protocol Handler NKEs</h2><p>Adding and removing protocol handler NKEs is accomplished by calling <code>net_add_proto</code> and <code>net_del_proto</code>, respectively. These calls are described in <span class="content_text"><a href="../reference/reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACEIEF">“Protocol Handler NKE Functions.”</a></span> For detailed information about implementing protocol families, see <code>The Design and Implementation of the 4.4 BSD Operating System</code> by M. K. McKusick. et al. and <code>TCP/IP Illustrated</code> by Richard W. Stevens.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_12" title="About Socket NKEs"></a><h2>About Socket NKEs</h2><p>Socket NKEs are installed in the kernel by calling <code><!--a-->register_sockfilter<!--/a--></code> typically from the NKE's initialization routine. Each socket NKE provides a descriptor structure that is linked into a global list (<code>nf_list</code>). A second chain runs through the filter descriptor to link it to a <code>protosw</code> for global NKEs. <span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABEHJGD">Figure 1-3</a></span> shows the interconnections for these data structures.</p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_119" title="Figure 1-3Domain structure and protosw interconnections"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABEHJGD" title="Figure 1-3Domain structure and protosw interconnections"></a><strong>Figure 1-3&nbsp;&nbsp;</strong>Domain structure and protosw interconnections</p><img src = "../art/about-10.gif" alt = "Domain structure and protosw interconnections" width="421" height="464"></div><br/><p>When you call <code>socreate</code> to create a socket, any global NKEs associated with the corresponding <code>protosw</code> structure are attached to the socket structure using the <code>so_ext</code> field to link together <code>ketcb</code> structures that are allocated when the socket is created. (See <span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABEHJGD">Figure 1-3</a></span>.) These <code>ketcb</code> structures are initialized to point to the extension descriptor and two dispatch vectors of intercept functions (one for socket operations and one for socket buffer utilities).</p><p>The filter descriptor for a programmatic NKE is linked into the <code>nf_list</code> in the same way as are global NKEs but the file descriptor does not appear in the list associated with a <code>protosw</code>. A program can call <code>setsocketopt</code> using socket option <code>SO_NKE</code>) to insert a programmatic NKE into its NKE chain in the same way that it would call <code>setsocketopt</code> to insert a global NKE.</p><p>Each socket NKE has two dispatch vectors, a <code>sockif</code> structure and a <code>sockutil</code> structure, that contain pointers to the NKE's implementation of these functions. The functions are called when the corresponding <code>socket</code> and <code>sockbuf</code> functions are are called. The dispatch vectors permit the NKE to selectively intercept socket and socket buffer utilities. Here is an example:</p><div class="codesample"><table><tr><td scope="row"><pre>int (*sf_sobind)(struct socket *, struct mbuf *, st kextcb);<span></span></pre></td></tr></table></div><p>The kernel's <code>sobind</code> function calls the NKE's <code>bind</code> entry point with the arguments passed to <code>sobind</code> and the <code>kextcb</code> pointer for the NKE. The <code>sockaddr</code> structure contains the name of the local endpoint being bound.</p><p>Each of the intercept functions can return an integer value. A return value of zero is interpreted to mean that processing at the call site can continue. A non-zero return value is interpreted as an error (as defined in <code>&lt;sys/errno.h></code>) that causes the processing of the packet or opertation to halt. If the return value is <code>EJUSTRETURN</code>, the calling function (for example, <code>sobind</code>) returns at that point with a value of zero. Otherwise, the function returns the non-zero error code. In this way, an NKE can "swallow" a packet or an operation. An NKE may reinject the packet at a later time. (Note that the injection mechanism is not yet defined.)</p><p>A program can insert a socket NKE on an open socket by calling <code>setsockopt</code> as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>setsockopt(s, SOL_SOCKET, SO_NKE, &amp;so_nke, sizeof (struct so_nke);<span></span></pre></td></tr></table></div><p>The <code>so_nke</code> structure is defined as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>struct so_nke {<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned int nke_handle;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned int nke_where;<span></span></pre></td></tr><tr><td scope="row"><pre>    int nke_flags;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The <code>nke_handle</code> specifies the NKE to be linked to the socket (with the <code>so_ext</code> link). It is the programmer's task to locate the appropriate NKE, assure that it is loaded, and retain the returned handle for use in the<code> setsockopt</code> call.</p><p>The <code>nke_where</code> value specifies an NKE assumed to be in this linked list. If <code>nke_where</code> is <code>NULL</code>, the NKE represented by <code>nke_handle</code> is linked at the beginning or end of the list, depending on the value of <code>nke_flags</code>.</p><p>The <code>nke_flags</code> value specifies where, relative to <code>nke_where</code>, the NKE represented by <code>nke_handle</code> will be placed. Possible values are NFF_BEFORE and NFF_AFTER defined in <code>&lt;net/kext_net.h></code>.</p><p>The <code>nke_handle</code> and <code>nke_where</code> values are assigned by Apple Computer from the same name space as the type and creator codes used in Mac OS 8 and Mac OS 9 and using the same registration mechanism.</p><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_13" title="About Data Link NKEs"></a><h2>About Data Link NKEs</h2><p>This section describes the programming interface for creating data link NKEs, which are inserted below the protocol layer and above the network interface layer. Data link NKEs depend on the Data link interface layer (DLIL), shown in <span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABBBEJD">Figure 1-4</a></span>, which provides a fixed point for the insertion of data link NKEs. </p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_120" title="Figure 1-4Data Link Interface Layer"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABBBEJD" title="Figure 1-4Data Link Interface Layer"></a><strong>Figure 1-4&nbsp;&nbsp;</strong>Data Link Interface Layer</p><img src = "../art/about-11.gif" alt = "Data Link Interface Layer" width="421" height="163"></div><br/><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_14" title="DLIL Static Functions"></a><h3>DLIL Static Functions</h3><p>The DLIL defines the following static functions, which are called by protocols and drivers:</p><ul class="spaceabove"><li class="li"><p><code>dlil_attach_protocol</code>, which attaches network protocol stacks to specific interfaces</p></li><li class="li"><p><code>dlil_detach_protocol</code>, which detaches network protocol stacks from the interfaces to which they were previously attached</p></li><li class="li"><p><code>dlil_if_attach</code>, which registers network interfaces with the DLIL</p></li><li class="li"><p><code>dlil_if_detach</code>, which deregisters network interfaces that have been registered with the DLIL</p></li><li class="li"><p><code>dlil_ioctl</code>, which sends ioctl commands to a network driver</p></li><li class="li"><p><code>dlil_input</code>, which sends data to the DLIL from a network driver</p></li><li class="li"><p><code>dlil_output</code>, which sends data to a network driver</p></li><li class="li"><p><code>dlil_event</code>, which processes events from other parts of the network and from IOKit components. (Note that the event mechanisms are still under development.)</p></li></ul><p>In <span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABHGBGF">Figure 1-5</a></span>, the DLIL static functions are shown in relation to the DLIL, the protocol layer, and the network driver layer.</p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_121" title="Figure 1-5DLIL static functions"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABHGBGF" title="Figure 1-5DLIL static functions"></a><strong>Figure 1-5&nbsp;&nbsp;</strong>DLIL static functions</p><img src = "../art/about-12.gif" alt = "DLIL static functions" width="421" height="337"></div><br/><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_15" title="Changes to the ifnet and if_proto Structures"></a><h3>Changes to the ifnet and if_proto Structures</h3><p>To support data link NKEs, the traditional <code>ifnet</code> structure as been extended in Mac OS X: the driver or software that supports the driver must allocate a separate <code>ifnet</code> structure for each logical interface. When an interface is attached (by calling <code>dlil_if_attach</code>)to the DLIL, the DLIL receives a pointer to that interface's <code>ifnet</code> structure.</p><p>Each interface can transmit and receive packets for multiple network protocol families, so for each attached protocol family the DLIL creates an <code>if_proto</code> structure chained off the <code>ifnet</code> structure for that interface.</p><p>The <code>if_proto</code> structure contains function pointers that the DLIL uses to pass incoming packets and event information to the protocol stack, as well as a pointer to the protocol dependent "pre-output" function that performs protocol-family specific operations such as network address translation on outbound packets.</p><p><span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABIJGJC">Figure 1-6</a></span> shows the <code>ifnet</code> and <code>if_proto</code> structures in relation to a generic protocol and a generic interface.</p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_122" title="Figure 1-6Sample ifnet structure in relation to a protocol and a network driver"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABIJGJC" title="Figure 1-6Sample ifnet structure in relation to a protocol and a network driver"></a><strong>Figure 1-6&nbsp;&nbsp;</strong>Sample <code>ifnet</code> structure in relation to a protocol and a network driver</p><img src = "../art/about-13.gif" alt = "Sample ifnet structure in relation to a protocol and a network driver" width="421" height="441"></div><br/><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_16" title="Installing and Removing Data Link NKEs"></a><h3>Installing and Removing Data Link NKEs</h3><p>To support the dynamic insertion of filters into the data and control streams between the network layer and the interface layer and the removal of inserted filters, the DLIL defines the following static functions:</p><ul class="spaceabove"><li class="li"><p><code>dlil_attach_protocol_filter</code>, which inserts an NKE between the DLIL and one of the attached protocols. Such an extension is known as a DLIL protocol filter. This type of NKE provides access to all function calls between the DLIL and the attached protocol for a specific protocol/interface pair.</p></li><li class="li"><p><code>dlil_attach_interface_filter</code>, which inserts an NKE between the DLIL and an attached interface. Such a filter is known as an DLIL interface filter. This type of NKE provides access to all frames flowing to or from an interface. </p></li><li class="li"><p><code>dlil_detach_filter</code>, which removes previously inserted DLIL protocol and interface filters.</p></li></ul><p><span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABFEHBF">Figure 1-7</a></span> shows the relationship of protocol and interface filters to the protocol stack layer, DLIL, and network driver layer. </p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_123" title="Figure 1-7Protocol and interface extensions in relation to the DLIL"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABFEHBF" title="Figure 1-7Protocol and interface extensions in relation to the DLIL"></a><strong>Figure 1-7&nbsp;&nbsp;</strong>Protocol and interface extensions in relation to the DLIL</p><img src = "../art/about-14.gif" alt = "Protocol and interface extensions in relation to the DLIL" width="421" height="469"></div><br/><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_17" title="Sending Data"></a><h3>Sending Data</h3><p><span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABBIBAH">Figure 1-8</a></span> shows the sequence of calls required to send an IP packet over the MACE Ethernet interface (<code>en0</code>).</p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_124" title="Figure 1-8Example of sending an IP packet"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABBIBAH" title="Figure 1-8Example of sending an IP packet"></a><strong>Figure 1-8&nbsp;&nbsp;</strong>Example of sending an IP packet</p><img src = "../art/about-15.gif" alt = "Example of sending an IP packet" width="421" height="401"></div><br/><p>The following steps correspond to the numbers in <span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABBIBAH">Figure 1-8</a></span> and describe the process of sending a packet:</p><ol class="ol"><li class="li"><p>The <code>ip_output</code> routine in the IP protocol stack calls <code>dlil_output</code>, passing the <code>dl_tag</code> value for the stack's attachment to <code>en0</code>.</p></li><li class="li"><p>Using the <code>dl_tag</code> value, the <code>dlil_output</code> function locates the <code>dl_pre_output</code> pointer in the <code>if_proto</code> structure for IP.</p></li><li class="li"><p>The <code>dlil_output</code> function uses the <code>dl_pre_output</code> pointer in the <code>if_proto</code> structure to call IP's interface-specific output module. This module calls its <code>arpresolve</code> routine to resolve the target IP address into a media access control (MAC) address.</p></li><li class="li"><p>When IP's interface-specific output module returns, the <code>dlil_output</code> function uses the <code>if_framer </code>pointer in the <code>ifnet</code> structure to call the appropriate framing function in the DLIL interface module. The framing function prepends interface-specific frame data to the packet.</p></li><li class="li"><p>The <code>dlil_output</code> function calls the function pointed to by the <code>if_output</code> field in the <code>ifnet</code> structure for <code>en0</code> and sends the frame to the MACE Ethernet driver.</p></li></ol><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_18" title="Receiving Data"></a><h3>Receiving Data</h3><p><span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABDBAIH">Figure 1-9</a></span> shows the sequence of calls required to receive an IP packet from the MACE Ethernet interface (<code>en0</code>).</p><br/><div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_125" title="Figure 1-9Example of receiving a packet"></a><p><a name="//apple_ref/doc/uid/TP40001089-CH225-BABDBAIH" title="Figure 1-9Example of receiving a packet"></a><strong>Figure 1-9&nbsp;&nbsp;</strong>Example of receiving a packet</p><img src = "../art/about-16.gif" alt = "Example of receiving a packet" width="421" height="421"></div><br/><p>The following steps correspond to the numbers in <span class="content_text"><a href="about.html#//apple_ref/doc/uid/TP40001089-CH225-BABDBAIH">Figure 1-9</a></span> and describe the process of receiving a packet:</p><ol class="ol"><li class="li"><p>The MACE Ethernet driver or its support code calls <code>dlil_input</code> with pointers to its <code>ifnet</code> structure and <code>mbuf</code> chain.</p></li><li class="li"><p>The <code>dlil_input</code> function uses the <code>if_demux</code> entry in the <code>ifnet</code> structure to call the demultiplexing function for the interface family (Ethernet in this case).</p></li><li class="li"><p>The demultiplexing function identifies the frame and returns an <code>if_proto</code> pointer to <code>dlil_input</code>.</p></li><li class="li"><p>The <code>dlil_input</code> function calls the protocol input module through the <code>dl_input</code> pointer in the <code>if_proto</code> structure.</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_126" title="Note"></a><p><strong>Note:</strong>&nbsp;The Ethernet-specific module for IP receives the frame, removes the 802.2 or SNAP header (if any) and delivers the packet to the protocol's <code>ipintr</code> routine.</p></div><a name="//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_19" title="For more information"></a><h2>For more information</h2><p>The following sources provide additional information that may be of interest to developers of network kernel extensions:</p><ul class="ul"><li class="li"><p><em>The Design and Implementation of the 4.4 BSD Operating System</em> . M. K. McKusick. et al., Addison-Wesley, Reading, 1996.</p></li><li class="li"><p><em>Unix Network Programming, Second Edition, Volume 1</em>. Richard W. Stevens, Prentice Hall, New York, 1998.</p></li><li class="li"><p><em>TCP/IP Illustrated, Volume 1, The Protocols.</em> Richard W. Stevens, Addison-Wesley, Reading, 1994.</p></li><li class="li"><p><em>TCP/IP Illustrated, Volume 2, The Implementation.</em> Richard W. Stevens and Gary R. Wright, Addison-Wesley, Reading, 1995.</p></li><li class="li"><p><em>TCP/IP Illustrated, Volume 3, Other Protocols.</em> Richard W. Stevens, Addison-Wesley, Reading, 1996.</p></li></ul><p>The following websites provide information about the Berkeley Software Distribution (BSD):</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="http://www.FreeBSD.org" target="_blank">http://www.FreeBSD.org</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://www.NetBSD.org" target="_blank">http://www.NetBSD.org</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://www.OpenBSD.org/" target="_blank">http://www.OpenBSD.org/</a></span></p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../using/using.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-10-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/NetworkKernelExtensions/about/about.html%3Fid%3DTP40001089-2.5&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/NetworkKernelExtensions/about/about.html%3Fid%3DTP40001089-2.5&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/NetworkKernelExtensions/about/about.html%3Fid%3DTP40001089-2.5&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>