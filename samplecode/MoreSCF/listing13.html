<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoreSCF - /MoreSCF/MoreSCFTest/MoreSCFTest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Networking/index.html">Networking</a> &gt; <a href="../../samplecode/Networking/idxDarwin-date.html">Darwin</a> &gt; <A HREF="javascript:location.replace('index.html');">MoreSCF</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoreSCF</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoreSCF/MoreSCFTest/MoreSCFTest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MoreCFQ/MoreCFQ.c</option>
<option value="listing2.html">/MoreCFQ/MoreCFQ.h</option>
<option value="listing3.html">/MoreSCF/MoreSCF.c</option>
<option value="listing4.html">/MoreSCF/MoreSCF.h</option>
<option value="listing5.html">/MoreSCF/MoreSCFCCLScanner.c</option>
<option value="listing6.html">/MoreSCF/MoreSCFCCLScanner.h</option>
<option value="listing7.html">/MoreSCF/MoreSCFDigest.c</option>
<option value="listing8.html">/MoreSCF/MoreSCFDigest.h</option>
<option value="listing9.html">/MoreSCF/MoreSCFHelpers.c</option>
<option value="listing10.html">/MoreSCF/MoreSCFHelpers.h</option>
<option value="listing11.html">/MoreSCF/MoreSCFPortScanner.c</option>
<option value="listing12.html">/MoreSCF/MoreSCFPortScanner.h</option>
<option value="listing13.html">/MoreSCF/MoreSCFTest/MoreSCFTest.c</option>
<option value="listing14.html">/MoreSCF/Read Me About MoreSCF.txt</option>
<option value="listing15.html">/Read Me.txt</option></select>
				</p>
				</form>
				<p><strong><a href="MoreSCF.zip">Download Sample</a></strong> (&#147;MoreSCF.zip&#148;, 126.7K)<BR>
<strong><a href="MoreSCF.dmg">Download Sample</a></strong> (&#147;MoreSCF.dmg&#148;, 191.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    MoreSCFTest.c

  Contains:  Test program for all of MoreSCF.

  Written by:  DTS

  Copyright:  Copyright (c) 2007 by Apple Inc., All Rights Reserved.

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Change History (most recent first):

$Log: MoreSCFTest.c,v $
Revision 1.14  2006/11/24 15:01:58         
Make it possible to explicitly test the old port scanning code.  Fix &lt;rdar://problem/3540864&gt;, which was causing original AirPort Extreme cards to not be recognised as AirPort.

Revision 1.13  2006/11/24 12:39:35         
Don't crash if the sort order isn't present.

Revision 1.12  2006/11/23 15:04:24         
Quieten an uninitialised variable warning.

Revision 1.11  2006/03/27 14:42:46         
Eliminate high-bit set characters.

Revision 1.10  2006/03/24 15:44:51         
Updated copyright.

Revision 1.9  2006/03/24 12:38:59         
Eliminate &quot;pascal&quot; keyword.

Revision 1.8  2006/03/24 11:30:25         
Eliminated &quot;MoreSetup.h&quot; to make it easier for folks to copy MIB source into their projects.

Revision 1.7  2004/10/28 12:36:27         
Add TestTrivialCreate to exercise a buggy case discovered by a developer.

Revision 1.6  2003/03/11 23:22:05         
Added DebugCreatePPPoE.

Revision 1.5  2003/02/26 21:02:49         
Serious rewrite. The tool now behaves differently depending on command line parameters. Also, worked around a bug in the Network prefs panel that was causing the set comparison to fail even though MoreSCF is doing the right thing.

Revision 1.4  2003/02/26 12:47:05         
Don't print high-bit set characters because they look ugly when running under Terminal. In the code to compare sets, changed lhs and rhs to new and def (default), so make it easier to understand which is which. Modified TestISP to test the PPPoE code. Added DebugCreateSet.

Revision 1.3  2002/11/09 00:02:39         
Convert nil to NULL. Convert MoreAssertQ to assert.

Revision 1.2  2002/01/22 06:24:13         
Adapt to the new port scanner API. Also added some extra printfs when we get a comparison failure in TestCreateSet to make it easier to track down problems.

Revision 1.1  2002/01/16 22:53:11         
First checked in.


*/

/////////////////////////////////////////////////////////////////

// System interfaces

#include &lt;CoreFoundation/CoreFoundation.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

// MIB Interfaces

#include &quot;MoreCFQ.h&quot;
#include &quot;MoreSCFPortScanner.h&quot;
#include &quot;MoreSCFCCLScanner.h&quot;
#include &quot;MoreSCF.h&quot;
#include &quot;MoreSCFDigest.h&quot;
#include &quot;MoreSCFHelpers.h&quot;

/////////////////////////////////////////////////////////////////
#pragma mark ***** Tests

static Boolean gNoRootTests = false;
  // If this is true, we only runs tests root tests if we're running as root.
  
static Boolean gRunQuiet = false;
  // When this is set to true the test routines print nothing 
  // during successful operation. This prevents a bunch of meaningless 
  // output during the memory leak tests.

static Boolean gCheckLeaks = false;
  // When this is set, tests are run repeatedly to check for leaks.

static Boolean gCheckLeaksDebug = false;
  // When this is set, the leak testing code prints some helpful debugging.

static const char *gProgramName;
  // The last path element of argv[0].  Used when printing error messages.
  
extern void PrintPropertyList(CFPropertyListRef propList);
  // Forward declaration.  Declared external for debugging purposes 
  // in other modules.

static void PrintTestResult(OSStatus errNum, const char *subTestName);
  // Forward declaration of this test engine function.

extern OSStatus MoreSCCreatePortArrayOld(CFArrayRef *portArray);
    // This is an internal function of the MoreSCFPortScanner that I want to 
    // call from the test program but I don't want to generally export.  Thus, 
    // I declare my own private prototype for the routine.

static void TestPortScannerCommon(Boolean useOldCode)
  // A simple test of the port scanner code.  This doesn't do a 
  // lot of automated testing, but you can look at the results 
  // and visually check them.
{
  OSStatus     err;
  CFArrayRef   portArray;
  CFIndex   portCount;
  CFIndex   portIndex;
  long    order;
  CFNumberRef  supportsHold;
  
  portArray = NULL;
  
    if (useOldCode) {
        err = MoreSCCreatePortArrayOld(&amp;portArray);
    } else {
        err = MoreSCCreatePortArray(&amp;portArray);
    }
  if (err == noErr) {
    portCount = CFArrayGetCount(portArray);
    for (portIndex = 0; portIndex &lt; portCount; portIndex++) {
      CFDictionaryRef thisPort;
      
      thisPort = (CFDictionaryRef) CFArrayGetValueAtIndex(portArray, portIndex);
      if (!gRunQuiet) {
        fprintf(stderr, &quot;Port %ld\n&quot;, portIndex);
        fprintf(stderr, &quot;  device   = &quot;);
        CFShow(CFDictionaryGetValue(thisPort, kSCPropNetInterfaceDeviceName));
        fprintf(stderr, &quot;  name     = &quot;);
        CFShow(CFDictionaryGetValue(thisPort, kSCPropUserDefinedName));
        fprintf(stderr, &quot;  hardware = &quot;);
        CFShow(CFDictionaryGetValue(thisPort, kSCPropNetInterfaceHardware));
        fprintf(stderr, &quot;  variant  = &quot;);
        CFShow(CFDictionaryGetValue(thisPort, kMoreSCPropNetInterfaceHardwareVariant));
        fprintf(stderr, &quot;  type     = &quot;);
        CFShow(CFDictionaryGetValue(thisPort, kSCPropNetInterfaceType));
        fprintf(stderr, &quot;  subtype  = &quot;);
        CFShow(CFDictionaryGetValue(thisPort, kSCPropNetInterfaceSubType));
        fprintf(stderr, &quot;  MAC      = &quot;);
        CFShow(CFDictionaryGetValue(thisPort, kSCPropMACAddress));
        
        supportsHold = (CFNumberRef) CFDictionaryGetValue(thisPort, kSCPropNetInterfaceSupportsModemOnHold);
        if (supportsHold != NULL) {
          long hold;
          
          CFNumberGetValue(supportsHold, kCFNumberLongType, &amp;hold);
          fprintf(stderr, &quot;  hold     = %ld\n&quot;, hold);
        }

                // The &quot;SortOrder&quot; property isn't part of the MoreSCF 'API'.  That means a) there's no constant 
                // definition for it, and b) it's not always present (specifically, if we're using the new API, 
                // which returns the ports sorted, I don't bother trying to emulate the value).  However, I do 
                // want to print it if it's present, because it's helpful when debugging the old code.
                
                if ( CFDictionaryContainsKey(thisPort, CFSTR(&quot;SortOrder&quot;)) ) {
                    (void) CFNumberGetValue((CFNumberRef) CFDictionaryGetValue(thisPort, CFSTR(&quot;SortOrder&quot;)), kCFNumberLongType, &amp;order);
                    fprintf(stderr, &quot;  sort     = %ld\n&quot;, order);
                }
      }
    }
  }
  
  CFQRelease(portArray);

  PrintTestResult(err, NULL);
}

static void TestPortScanner(void)
{
    TestPortScannerCommon(false);
}

static void TestPortScannerOld(void)
{
    TestPortScannerCommon(true);
}

static void TestCCLScanner(void)
  // A simple test of the port scanner code.  This doesn't do a 
  // lot of automated testing, but you can look at the results 
  // and visually check them.
{
    OSStatus    err;
    CFArrayRef  cclArray;
    CFIndex     indexOfDefault;
    CFIndex     cclCount;
    CFIndex     cclIndex;
    
    cclArray = NULL;
    
    err = MoreSCCreateCCLArray(&amp;cclArray, &amp;indexOfDefault);
    if ( (err == noErr) &amp;&amp; ! gRunQuiet ) {
        cclCount = CFArrayGetCount(cclArray);
        
        for (cclIndex = 0; cclIndex &lt; cclCount; cclIndex++) {
            if (cclIndex == indexOfDefault) {
                fprintf(stderr, &quot; * &quot;);
            } else {
                fprintf(stderr, &quot;   &quot;);
            }
            CFShow( CFArrayGetValueAtIndex(cclArray, cclIndex) );
        }
    }
    
    CFQRelease(cclArray);
    
  PrintTestResult(err, NULL);
}

static void TestCopySetsDict(void)
  // A test of the MoreSCCopySetsDict routine, which proved key 
  // in tracking down a reference count leak.
{
  OSStatus     err;
  CFDictionaryRef setsDict;

  setsDict = NULL;
  err = MoreSCCopySetsDict(&amp;setsDict);
  CFQRelease(setsDict);

  PrintTestResult(err, NULL);
}

#define kDefaultLocationName &quot;DefaultLocationForMoreSCFTest&quot;

static void TestSetEnumerationAndSwitch(void)
  // A test of set enumeration and switching routines.
{
  OSStatus  err;
  CFIndex    setCount;
  CFIndex      setIndex;
  CFArrayRef  setIDs;
  CFIndex    indexOfCurrentSet;
  
    setCount = 0;           // quieten warning
    
  setIDs = NULL;
  
  // Enumeration
  
  err = MoreSCCopySetIDs(&amp;setIDs, &amp;indexOfCurrentSet);
  if (err == noErr) {
    setCount = CFArrayGetCount(setIDs);
    for (setIndex = 0; setIndex &lt; setCount; setIndex++) {
      CFStringRef userVis;
      
      userVis = NULL;
      err = MoreSCCopyUserVisibleNameOfSet( (CFStringRef) CFArrayGetValueAtIndex(setIDs, setIndex), &amp;userVis);
      if (err == noErr &amp;&amp; !gRunQuiet) {
        fprintf(stderr, &quot;#%ld %c &quot;, setIndex, (setIndex == indexOfCurrentSet) ? '*' : ' ');
        CFShow(userVis);
        CFShow(CFArrayGetValueAtIndex(setIDs, setIndex));
      }
      CFQRelease(userVis);
      
      if (err != noErr) {
        break;
      }
    }
  }
  if (err == noErr) {
    CFStringRef currentSetID;
    
    currentSetID = NULL;
    err = MoreSCCopyCurrentSet(&amp;currentSetID);
    if (err == noErr &amp;&amp; !gRunQuiet) {
      fprintf(stderr, &quot;Current set ID is &quot;);
      CFShow(currentSetID);
    }
    
    CFQRelease(currentSetID);
  }
  
  // Switch
  
  if (err == noErr) {
        if (setCount == 1) {
            fprintf(stderr, &quot;*** TestSetEnumerationAndSwitch requires that you create a default set named '%s' using the Network preferences panel.\n&quot;, kDefaultLocationName);
            err = -1;
        } else {
            ItemCount newSet;
            
            if (indexOfCurrentSet == 0) {
                newSet = 1;
            } else {
                newSet = 0;
            }
            err = MoreSCSetCurrentSet( (CFStringRef) CFArrayGetValueAtIndex(setIDs, newSet));
            if (err == noErr) {
                err = MoreSCSetCurrentSet( (CFStringRef) CFArrayGetValueAtIndex(setIDs, indexOfCurrentSet));
            }
        }
  }

  CFQRelease(setIDs);
  
  PrintTestResult(err, NULL);
}

static void TestDuplicateAndDeleteSet(void)
  // A test of the set duplication and deleting routines.
{
  OSStatus err;
  CFStringRef currentSetID;
  CFStringRef newSetID;
  
  currentSetID = NULL;
  newSetID = NULL;
  err = MoreSCCopyCurrentSet(&amp;currentSetID);
  if (err == noErr) {
    err = MoreSCDuplicateSet(currentSetID, CFSTR(&quot;Frog&quot;), &amp;newSetID);
  }
  if (err == noErr) {
    if (!gRunQuiet) {
      fprintf(stderr, &quot;New set ID is &quot;);
      CFShow(newSetID);
    }
    
    err = MoreSCDeleteSet(newSetID);
  }
  
  CFQRelease(currentSetID);
  CFQRelease(newSetID);

  PrintTestResult(err, NULL);
}

static void TestRenameSet(void)
  // A test of the MoreSCRenameSet routine.
{
  OSStatus err;
  CFStringRef currentSetID;
  CFStringRef originalName;
  CFStringRef newName;
  
  currentSetID = NULL;
  originalName = NULL;
  newName = NULL;
  
  err = MoreSCCopyCurrentSet(&amp;currentSetID);
  if (err == noErr) {
    err = MoreSCCopyUserVisibleNameOfSet(currentSetID, &amp;originalName);
  }
  if (err == noErr) {
    err = MoreSCRenameSet(currentSetID, CFSTR(&quot;Frog&quot;));
  }
  if (err == noErr) {
    err = MoreSCCopyUserVisibleNameOfSet(currentSetID, &amp;newName);
  }
  if (err == noErr) {
    if ( ! CFEqual(newName, CFSTR(&quot;Frog&quot;)) ) {
      fprintf(stderr, &quot;*** newName isn't 'Frog'\n&quot;);
      CFShow(newName);
    }
    err = MoreSCRenameSet(currentSetID, originalName);
  }
  if (err == noErr) {
    CFQRelease(newName);
    newName = NULL;
    
    err = MoreSCCopyUserVisibleNameOfSet(currentSetID, &amp;newName);
  }
  if (err == noErr) {
    if ( ! CFEqual(newName, originalName) ) {
      fprintf(stderr, &quot;*** newName isn't the same as originalName\n&quot;);
      CFShow(newName);
    }
  }
  
  CFQRelease(currentSetID);
  CFQRelease(originalName);
  CFQRelease(newName);

  PrintTestResult(err, NULL);
}

static void TestServiceEnumerate(void)
  // A test of the service enumeration routines.
{
  OSStatus  err;
  ItemCount serviceCount;
  ItemCount serviceIndex;
  CFArrayRef localServiceIDs;
  CFArrayRef resolvedServiceIDs;

  localServiceIDs = NULL;
  resolvedServiceIDs = NULL;
  
  err = MoreSCCopyServiceIDs(NULL, &amp;localServiceIDs, &amp;resolvedServiceIDs);
  if (err == noErr) {
    serviceCount = CFArrayGetCount(localServiceIDs);
    for (serviceIndex = 0; serviceIndex &lt; serviceCount; serviceIndex++) {
      CFStringRef userVisible;
      Boolean     active;
      
      userVisible = NULL;
      err = MoreSCCopyUserVisibleNameOfService(NULL, (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, serviceIndex), &amp;userVisible);
      if (err == noErr) {
        err = MoreSCIsServiceActive(NULL, (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, serviceIndex), &amp;active);
      }
      if (err == noErr &amp;&amp; !gRunQuiet) {
        fprintf(stderr, &quot;#%ld %c &quot;, serviceIndex, (active) ? ' ' : 'X');
        CFShow(userVisible);
        CFShow(CFArrayGetValueAtIndex(localServiceIDs, serviceIndex));
        CFShow(CFArrayGetValueAtIndex(resolvedServiceIDs, serviceIndex));
      }
      
      CFQRelease(userVisible);
      
      if (err != noErr) {
        break;
      }
    }
  }

  CFQRelease(localServiceIDs);
  CFQRelease(resolvedServiceIDs);

  PrintTestResult(err, NULL);
}

static void TestDuplicateAndDeleteService(void)
  // A test of the service duplication and deleting routines.
{
  OSStatus   err;
  CFArrayRef  localServiceIDs;
  CFStringRef newServiceID;
  
  newServiceID = NULL;
  localServiceIDs = NULL;

  // Use NULL for the set ID to indicate that we're operating on
  // the current set.
  //
  // Can't use NULL for a service ID, so we have to come up with 
  // a valid service ID first.  We do this by choosing the first 
  // service ID.
  
  err = MoreSCCopyServiceIDs(NULL, &amp;localServiceIDs, NULL);
  if (err == noErr) {
    assert( CFArrayGetCount(localServiceIDs) &gt; 0 );
    err = MoreSCDuplicateService(NULL, (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, 0), CFSTR(&quot;Frog&quot;), &amp;newServiceID);
  }

  if (err == noErr) {
    if (!gRunQuiet) {
      fprintf(stderr, &quot;New service ID is &quot;);
      CFShow(newServiceID);
    }
    
    err = MoreSCDeleteService(NULL, newServiceID);
  }

  CFQRelease(localServiceIDs);
  CFQRelease(newServiceID);

  PrintTestResult(err, NULL);
}

static void TestRenameService(void)
  // A test of the MoreSCRenameService routine.
{
  OSStatus   err;
  CFArrayRef  localServiceIDs;
  CFStringRef originalName;
  CFStringRef newName;
  CFStringRef serviceZero;
  
    serviceZero = NULL;     // quieten warning
    
  localServiceIDs = NULL;
  originalName = NULL;
  newName = NULL;

  // Use NULL for the set ID to indicate that we're operating on
  // the current set.
  //
  // Can't use NULL for a service ID, so we have to come up with 
  // a valid service ID first.  We do this by choosing the first 
  // service ID.
  
  err = MoreSCCopyServiceIDs(NULL, &amp;localServiceIDs, NULL);
  if (err == noErr) {
    assert( CFArrayGetCount(localServiceIDs) &gt; 0 );
    serviceZero = (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, 0);
    err = MoreSCCopyUserVisibleNameOfService(NULL, serviceZero, &amp;originalName);
  }
  if (err == noErr) {
    err = MoreSCRenameService(NULL, serviceZero, CFSTR(&quot;Frog&quot;));
  }
  if (err == noErr) {
    err = MoreSCCopyUserVisibleNameOfService(NULL, serviceZero, &amp;newName);
  }
  if (err == noErr) {
    if ( ! CFEqual(newName, CFSTR(&quot;Frog&quot;)) ) {
      fprintf(stderr, &quot;*** newName isn't 'Frog'\n&quot;);
      CFShow(newName);
    }
    err = MoreSCRenameService(NULL, serviceZero, originalName);
  }
  if (err == noErr) {
    CFQRelease(newName);
    newName = NULL;
    
    err = MoreSCCopyUserVisibleNameOfService(NULL, serviceZero, &amp;newName);
  }
  if (err == noErr) {
    if ( ! CFEqual(newName, originalName) ) {
      fprintf(stderr, &quot;*** newName isn't the same as originalName\n&quot;);
      CFShow(newName);
    }
  }
  
  CFQRelease(localServiceIDs);
  CFQRelease(originalName);
  CFQRelease(newName);

  PrintTestResult(err, NULL);
}

static void TestEnumerateEntities(void)
  // A test of the MoreSCCopyEntities routine.
{
  OSStatus   err;
  CFArrayRef  localServiceIDs;
  ItemCount  entityCount;
  ItemCount  entityIndex;
  CFArrayRef  protocols;
  CFArrayRef  values;
  
  // Use NULL for the set ID to indicate that we're operating on
  // the current set.
  //
  // Can't use NULL for a service ID, so we have to come up with 
  // a valid service ID first.  We do this by choosing the first 
  // service ID.
  
  localServiceIDs = NULL;
  protocols = NULL;
  values = NULL;
  
  err = MoreSCCopyServiceIDs(NULL, &amp;localServiceIDs, NULL);
  if (err == noErr) {
    assert(CFArrayGetCount(localServiceIDs) &gt; 0);
    err = MoreSCCopyEntities(NULL, (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, 0), &amp;protocols, &amp;values);
  }

  if (err == noErr &amp;&amp; !gRunQuiet) {
    entityCount = CFArrayGetCount(protocols);
    for (entityIndex = 0; entityIndex &lt; entityCount; entityIndex++) {
      fprintf(stderr, &quot;#%ld &quot;, entityIndex);
      CFShow(CFArrayGetValueAtIndex(protocols, entityIndex));
      CFShow(CFArrayGetValueAtIndex(values,    entityIndex));
    }
  }

  CFQRelease(localServiceIDs);
  CFQRelease(protocols);
  CFQRelease(values);
  
  PrintTestResult(err, NULL);
}

static OSStatus WorkaroundNetworkPrefsBug(CFDictionaryRef *entitiesDictPtr)
  // If this is an Ethernet interface and LCPEchoEnabled is false, 
  // set it to true.  This works around what I think is a bug in 
  // the Network preferences panel &lt;rdar://problem/3182846&gt; where the 
  // LCPEchoEnabled flag is mysteriously set to false for PCI Ethernet 
  // interfaces.
{
  OSStatus   err;
  CFStringRef hardwarePath[2];
  CFStringRef lcpPath[2];
  CFStringRef  hardwareStr;
  CFNumberRef lcpValue;
  long    enabled;
  
  hardwarePath[0] = kSCEntNetInterface;
  hardwarePath[1] = kSCPropNetInterfaceHardware;

  lcpPath[0] = kSCEntNetPPP;
  lcpPath[1] = kSCPropNetPPPLCPEchoEnabled;
  
  hardwareStr = NULL;      // just to make debugging easier
  lcpValue = NULL;
  
  err = noErr;
  if (    CFQDictionaryGetValueAtPath(*entitiesDictPtr, (const void **) hardwarePath, 2, (const void **) &amp;hardwareStr) == noErr
     &amp;&amp; CFEqual(hardwareStr, kSCEntNetEthernet)
     &amp;&amp; CFQDictionaryGetValueAtPath(*entitiesDictPtr, (const void **) lcpPath, 2, (const void **) &amp;lcpValue) == noErr
     &amp;&amp; CFNumberGetValue(lcpValue, kCFNumberLongType, &amp;enabled)
     &amp;&amp; (enabled == 0) ) {
    CFMutableDictionaryRef   newDict;
    CFNumberRef       numRef;
    
    if ( ! gRunQuiet ) {
      fprintf(stderr, &quot;Applied workaround\n&quot;);
    }
    
    numRef = NULL;
    newDict = CFDictionaryCreateMutableCopy(NULL, 0, *entitiesDictPtr);
    err = CFQError(newDict);
    if (err == noErr) {
      enabled = true;
      numRef = CFNumberCreate(NULL, kCFNumberLongType, &amp;enabled);
      err = CFQError(numRef);
    }
    if (err == noErr) {
      err = CFQDictionarySetValueAtPath(newDict, (const void **) lcpPath, 2, numRef);
    }
    if (err == noErr) {
      CFQRelease(*entitiesDictPtr);
      *entitiesDictPtr = newDict;
      newDict = NULL;
    }
    
    CFQRelease(newDict);
    CFQRelease(numRef);
  }

  return err;  
}

static OSStatus DeletePrivatePrefs(CFDictionaryRef *entitiesDictPtr)
{
    OSStatus    err;
  CFStringRef privPath[2];
    CFStringRef junkStr;
    
    privPath[0] = kSCEntNetProxies;
    privPath[1] = CFSTR(&quot;AppleProxyConfigurationSelected&quot;);

    err = noErr;
    if ( CFQDictionaryGetValueAtPath(*entitiesDictPtr, (const void **) privPath, 2, (const void **) &amp;junkStr) == noErr ) {
    CFMutableDictionaryRef   newDict;

    newDict = CFDictionaryCreateMutableCopy(NULL, 0, *entitiesDictPtr);
    err = CFQError(newDict);
        
        if (err == noErr) {
            err = CFQDictionaryRemoveValueAtPath(newDict, (const void **) privPath, 2);
        }

    if (err == noErr) {
      CFQRelease(*entitiesDictPtr);
      *entitiesDictPtr = newDict;
      newDict = NULL;
    }

    CFQRelease(newDict);
    }
    
    return err;
}

static OSStatus CompareServices(CFStringRef newSet, CFStringRef newService, 
                CFStringRef defSet, CFStringRef defService)
  // A service comparison routine used by the CompareSets routine.
  // This is godawful code but it's only test code and I don't have time to 
  // make it more elegant at this point.
{
  OSStatus    err;
  CFStringRef newUserVisible;
  CFStringRef defUserVisible;
  Boolean     newActive;
  Boolean     defActive;
  CFStringRef newBSD;
  CFStringRef defBSD;
  CFArrayRef  newProtocols;
  CFArrayRef  defProtocols;
  CFArrayRef  newValues;
  CFArrayRef  defValues;
  CFDictionaryRef newDict;
  CFDictionaryRef defDict;
  
  newUserVisible = NULL;
  defUserVisible = NULL;
  newBSD = NULL;
  defBSD = NULL;
  newProtocols = NULL;
  defProtocols = NULL;
  newValues = NULL;
  defValues = NULL;
  newDict = NULL;
  defDict = NULL;

  #if 0
    fprintf(stderr, &quot;newSet, defSet, newService, defService = \n&quot;);
    CFShow(newSet);
    CFShow(defSet);
    CFShow(newService);
    CFShow(defService);
  #endif
  
  // User visible name
  
  err = MoreSCCopyUserVisibleNameOfService(newSet, newService, &amp;newUserVisible);
  if (err == noErr) {
    err = MoreSCCopyUserVisibleNameOfService(defSet, defService, &amp;defUserVisible);
  }
  if (err == noErr) {
    if ( ! CFEqual(newUserVisible, defUserVisible) ) {
      fprintf(stderr, &quot;*** User visible names don't match\n&quot;);
      CFShow(newUserVisible);
      CFShow(defUserVisible);
      err = -1;
    }
  }
  
  // Active flag
  
  if (err == noErr) {
    err = MoreSCIsServiceActive(newSet, newService, &amp;newActive);
  }
  if (err == noErr) {
    err = MoreSCIsServiceActive(defSet, defService, &amp;defActive);
  }
  if (err == noErr) {
    if ( newActive != defActive ) {
      fprintf(stderr, &quot;*** Active flags don't match\n&quot;);
      err = -1;
    }
  }

  // BSD name
  
  if (err == noErr) {
    err = MoreSCCopyBSDNameOfService(newSet, newService, &amp;newBSD);
  }
  if (err == noErr) {
    err = MoreSCCopyBSDNameOfService(defSet, defService, &amp;defBSD);
  }
  if (err == noErr) {
    if ( ! CFEqual(newBSD, defBSD) ) {
      fprintf(stderr, &quot;*** BSD names don't match\n&quot;);
      CFShow(newBSD);
      CFShow(defBSD);
      err = -1;
    }
  }

  // Entities in service
  
  if (err == noErr) {
    err = MoreSCCopyEntities(newSet, newService, &amp;newProtocols, &amp;newValues);
  }
  if (err == noErr) {
    err = MoreSCCopyEntities(defSet, defService, &amp;defProtocols, &amp;defValues);
  }
  if (err == noErr) {
    err = CFQDictionaryCreateWithArrayOfKeysAndValues(newProtocols, newValues, &amp;newDict);
  }
  if (err == noErr) {
    err = CFQDictionaryCreateWithArrayOfKeysAndValues(defProtocols, defValues, &amp;defDict);
  }
  if (err == noErr) {
    err = WorkaroundNetworkPrefsBug(&amp;defDict);
  }
    if (err == noErr) {
        err = DeletePrivatePrefs(&amp;defDict);
    }
  if (err == noErr) {
    if ( ! CFEqual(newDict, defDict) ) {
      fprintf(stderr, &quot;*** Entities don't match\n&quot;);
      PrintPropertyList(newDict);
      PrintPropertyList(defDict);
      err = -1;
    }
  }

  CFQRelease(newUserVisible);
  CFQRelease(defUserVisible);
  CFQRelease(newBSD);
  CFQRelease(defBSD);
  CFQRelease(newProtocols);
  CFQRelease(defProtocols);
  CFQRelease(newValues);
  CFQRelease(defValues);
  CFQRelease(newDict);
  CFQRelease(defDict);
  
  return err;
}

static OSStatus CompareGlobalEntities(CFStringRef newSet, CFStringRef defSet)
  // A routine to compare global entities, taking care to ignore 
  // certain entities that aren't relevant.  This is used by the 
  // CompareSets routine.
  //
  // This is godawful code but it's only test code and I don't have time to 
  // make it more elegant at this point.
{
  OSStatus    err;
  CFArrayRef    newProtocols;
  CFArrayRef    defProtocols;
  CFArrayRef    newValues;
  CFArrayRef    defValues;
  CFDictionaryRef newDict;
  CFDictionaryRef defDict;
  CFMutableDictionaryRef newMutableDict;
  CFMutableDictionaryRef defMutableDict;
  CFStringRef     serviceOrderPath[2];

  newProtocols = NULL;
  defProtocols = NULL;
  newValues = NULL;
  defValues = NULL;
  newDict = NULL;
  defDict = NULL;
  newMutableDict = NULL;
  defMutableDict = NULL;

  // Create two mutable dictionaries, ones for the new entities and the 
  // other for the def entities.
  
  err = MoreSCCopyEntities(newSet, NULL, &amp;newProtocols, &amp;newValues);
  if (err == noErr) {
    err = MoreSCCopyEntities(defSet, NULL, &amp;defProtocols, &amp;defValues);
  }
  if (err == noErr) {
    err = CFQDictionaryCreateWithArrayOfKeysAndValues(newProtocols, newValues, &amp;newDict);
  } 
  if (err == noErr) {
    err = CFQDictionaryCreateWithArrayOfKeysAndValues(defProtocols, defValues, &amp;defDict);
  }
  if (err == noErr) {
    newMutableDict = CFDictionaryCreateMutableCopy(NULL, 0, newDict);
    if (newMutableDict == NULL) {
      err = coreFoundationUnknownErr;
    }
  }
  if (err == noErr) {
    defMutableDict = CFDictionaryCreateMutableCopy(NULL, 0, defDict);
    if (defMutableDict == NULL) {
      err = coreFoundationUnknownErr;
    }
  }

  // Remove the elementsl at &quot;IPv4/ServiceOrder&quot; because they will never 
  // compare equal because they contain different service IDs.

  serviceOrderPath[0] = kSCEntNetIPv4;
  serviceOrderPath[1] = kSCPropNetServiceOrder;
  if (err == noErr) {
    err = CFQDictionaryRemoveValueAtPath(newMutableDict, (const void **) serviceOrderPath, 2);
  }
  if (err == noErr) {
    err = CFQDictionaryRemoveValueAtPath(defMutableDict, (const void **) serviceOrderPath, 2);
  }
  
  // Now compare the dictionaries.
  
  if (err == noErr) {
    if ( ! CFEqual(newMutableDict, defMutableDict) ) {
      fprintf(stderr, &quot;*** Global entities don't match\n&quot;);
      PrintPropertyList(newMutableDict);
      PrintPropertyList(defMutableDict);
      err = -1;
    }
  }
  
  CFQRelease(newProtocols);
  CFQRelease(defProtocols);
  CFQRelease(newValues);
  CFQRelease(defValues);
  CFQRelease(newDict);
  CFQRelease(defDict);
  CFQRelease(newMutableDict);
  CFQRelease(defMutableDict);
  
  return err;
}

static OSStatus CompareSets(CFStringRef newSet, CFStringRef defSet)
  // A routine to compare two sets to see if they're identical. 
  // TestCreateSet uses this to check that the newly created set 
  // was created correctly.
{
  OSStatus   err;
  CFArrayRef newServices;
  CFArrayRef defServices;
  CFIndex    serviceCount;
  CFIndex    serviceIndex;
  
  // MoreSCCopyUserVisibleNameOfSet not called because 
  // user visible name of sets will be different.
  
  newServices = NULL;
  defServices = NULL;
  
  // Services within the set
  
  err = MoreSCCopyServiceIDs(newSet, &amp;newServices, NULL);
  if (err == noErr) {
    err = MoreSCCopyServiceIDs(defSet, &amp;defServices, NULL);
  }
  if (err == noErr) {
    if ( CFArrayGetCount(newServices) != CFArrayGetCount(defServices) ) {
      fprintf(stderr, &quot;*** Service counts not equal.\n&quot;);
      fprintf(stderr, &quot;%ld\n&quot;, CFArrayGetCount(newServices));
      fprintf(stderr, &quot;%ld\n&quot;, CFArrayGetCount(defServices));
      err = -1;
    }
  }
  if (err == noErr) {
    serviceCount = CFArrayGetCount(newServices);
    
    for (serviceIndex = 0; serviceIndex &lt; serviceCount; serviceIndex++) {
      err = CompareServices(newSet, (CFStringRef) CFArrayGetValueAtIndex(newServices, serviceIndex),
                  defSet, (CFStringRef) CFArrayGetValueAtIndex(defServices, serviceIndex));
      if (err != noErr) {
        break;
      }
    }
  }
  
  // Global entities
  
  if (err == noErr) {
    err = CompareGlobalEntities(newSet, defSet);
  }
  
  CFQRelease(newServices);
  CFQRelease(defServices);

  return err;
}

extern Boolean gMoreSCFCCLScannerBugForBugCompatibility;

static void TestCreateSet(void)
  // A routine to test the set creation and deletion code. 
  // It compares the newly created set against a set called 
  // &quot;DefaultLocationForMoreSCFTest&quot; to ensure that the set 
  // created by MoreSCF matches a set created by the control 
  // panel.
{
  OSStatus     err;
  OSStatus     err2;
  CFStringRef    newSetID;
  CFStringRef    templateSetID;
  
  newSetID = NULL;
  templateSetID = NULL;

  err = MoreSCFindSetByUserVisibleNameAndCopyID(CFSTR(kDefaultLocationName), &amp;templateSetID);
  if (err != noErr || templateSetID == NULL) {
    fprintf(stderr, &quot;*** TestCreateSet requires that you create a default set named '%s' using the Network preferences panel.\n&quot;, kDefaultLocationName);
    err = -1;
  }
    gMoreSCFCCLScannerBugForBugCompatibility = true;
  if (err == noErr) {
    err = MoreSCNewSet(CFSTR(&quot;Frog&quot;), &amp;newSetID);
  }
    gMoreSCFCCLScannerBugForBugCompatibility = false;
  if (err == noErr) {
    if (!gRunQuiet) {
      fprintf(stderr, &quot;New set ID is &quot;);
      CFShow(newSetID);
    }
    
    err = CompareSets(newSetID, templateSetID);

    err2 = MoreSCDeleteSet(newSetID);
    if (err == noErr) {
      err = err2;
    }
  }
  
  CFQRelease(newSetID);
  CFQRelease(templateSetID);

  PrintTestResult(err, NULL);
}

static void TestISP(void)
  // A routine to test the ISP support routines.
{
  OSStatus err;
  CFStringRef setID;
  CFStringRef setID2;
  CFStringRef newSetID;
  
  setID = NULL;
  setID2 = NULL;
  newSetID = NULL;
  
  err = MoreSCFindSetByUserVisibleNameAndCopyID(CFSTR(kDefaultLocationName), &amp;setID);
  if (err == noErr) {
    if (setID == NULL) {
      fprintf(stderr, &quot;*** Couldn't find the set '%s'\n&quot;, kDefaultLocationName);
    } else if (!gRunQuiet) {
      fprintf(stderr, &quot;Set ID for '%s' is\n&quot;, kDefaultLocationName);
      CFShow(setID);
    }
  }
  if (err == noErr) {
    err = MoreSCFindSetByUserVisibleNameAndCopyID(CFSTR(&quot;Who would give a set such a silly name&quot;), &amp;setID2);
    if (setID2 != NULL) {
      fprintf(stderr, &quot;*** Found set that shouldn't exist\n&quot;);
    }
  }
  if (err == noErr) {
    MoreSCPPPDigest ppp;
    
    BlockZero(&amp;ppp, sizeof(ppp));
    ppp.active            = true;
    ppp.authName          = CFSTR(&quot;Quinn&quot;);
    ppp.authPassword      = CFSTR(&quot;eskimo&quot;);
    ppp.commRemoteAddress = CFSTR(&quot;123 4567&quot;);

    err = MoreSCMakeNewDialupSet(NULL, CFSTR(&quot;Frog PPP&quot;), NULL, &amp;ppp, NULL, NULL, &amp;newSetID);
  }
  if (err == noErr) {
    err = MoreSCDeleteSet(newSetID);
  }
  
  CFQRelease(newSetID);
  newSetID = NULL;

  PrintTestResult(err, &quot;dialup&quot;);

    err = noErr;
  
  if (err == noErr) {
    MoreSCPPPDigest ppp;
    
    BlockZero(&amp;ppp, sizeof(ppp));
    ppp.active            = true;
    ppp.authName          = CFSTR(&quot;Quinn&quot;);
    ppp.authPassword      = CFSTR(&quot;eskimo&quot;);

    err = MoreSCMakeNewPPPoESet(NULL, CFSTR(&quot;Frog PPPoE&quot;), &amp;ppp, NULL, NULL, &amp;newSetID);
  }
  if (err == noErr) {
    err = MoreSCDeleteSet(newSetID);
  }
  
  CFQRelease(setID);
  CFQRelease(setID2);
  CFQRelease(newSetID);

  PrintTestResult(err, &quot;PPPoE&quot;);
}

static void TestAppleTalk(void)
  // A routine to test the AppleTalk on/off routines.
{
  OSStatus   err;
  Boolean    originalState;
  Boolean    newState;

  err = MoreSCIsAppleTalkActive(NULL, &amp;originalState);
  if (err == noErr &amp;&amp; !gRunQuiet) {
    fprintf(stderr, &quot;AppleTalk is %s.\n&quot;, originalState ? &quot;active&quot; : &quot;inactive&quot;);
  }
  if (err == noErr) {
    err = MoreSCSetAppleTalkActive(NULL, !originalState);
  }
  if (err == noErr) {
    err = MoreSCIsAppleTalkActive(NULL, &amp;newState);
  }
  if (err == noErr) {
    if (!gRunQuiet) {
      fprintf(stderr, &quot;AppleTalk is now %s.\n&quot;, newState ? &quot;active&quot; : &quot;inactive&quot;);
    }
    if (newState != !originalState) {
      fprintf(stderr, &quot;*** Failed to change state.\n&quot;);
    }
  }
  if (err == noErr) {
    err = MoreSCSetAppleTalkActive(NULL, originalState);
  }
  if (err == noErr) {
    err = MoreSCIsAppleTalkActive(NULL, &amp;newState);
  }
  if (err == noErr) {
    if (!gRunQuiet) {
      fprintf(stderr, &quot;AppleTalk is now %s.\n&quot;, newState ? &quot;active&quot; : &quot;inactive&quot;);
    }
    if (newState != originalState) {
      fprintf(stderr, &quot;*** Failed to restore state.\n&quot;);
    }
  }

  PrintTestResult(err, NULL);
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Ad Hoc Debugging

// This code is for debugging individual modules and hasn't been integrated 
// into a formal test yet.

static void DebugModemScriptSearch(void)
    // Used for debugging the modem script code.
{
    OSStatus   err;
    CFArrayRef  cclArray;
    CFIndex    indexOfDefaultCCL;
    
    cclArray = NULL;
    err = MoreSCCreateCCLArray(&amp;cclArray, &amp;indexOfDefaultCCL);
    if (err == noErr) {
        CFIndex i;
        CFIndex c;
        
        c = CFArrayGetCount(cclArray);
        fprintf(stderr, &quot;CCL Count = %ld\n&quot;, c);
        for (i = 0; i &lt; c; i++) {
            fprintf(stderr, &quot;%3ld %c &quot;, i, i == indexOfDefaultCCL ? '*' : ' ');
            CFShow(CFArrayGetValueAtIndex(cclArray, i));
        }
    }
    
    CFQRelease(cclArray);
    
    if (err == noErr) {
        fprintf(stderr, &quot;Success!\n&quot;);
    } else {
        fprintf(stderr, &quot;*** Failed with error %ld!\n&quot;, err);
    }
}

static void DebugCreateProxiesEntity(void)
    // Used for debugging MoreSCCreateProxiesEntity.
{
    OSStatus       err;
    MoreSCProxiesDigest proxy;
    CFDictionaryRef     entity;
    
    BlockZero(&amp;proxy, sizeof(proxy));
    entity = NULL;
    err = MoreSCCreateProxiesEntity(&amp;proxy, &amp;entity);
    if (err == noErr) {
        PrintPropertyList(entity);
    }
    CFQRelease(entity);
}

static void DebugOpenClose(void)
    // Used for debugging MoreSCOpen/Close.
{
    OSStatus   err;
    int_t     oldUID;
    
    // Simple open/close.

    err = MoreSCOpen(false, false);
    MoreSCClose(&amp;err, false);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 1) failed with error %ld!\n&quot;, err);
    }
    
    // Open and close dirty.
    
    err = MoreSCOpen(false, false);
    MoreSCClose(&amp;err, true);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 2) failed with error %ld!\n&quot;, err);
    }
    
    // Open locked and close not dirty.
    
    err = MoreSCOpen(true, true);
    MoreSCClose(&amp;err, false);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 3) failed with error %ld!\n&quot;, err);
    }
    
    // Open locked and close dirty.
    
    err = MoreSCOpen(true, true);
    MoreSCClose(&amp;err, true);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 4) failed with error %ld!\n&quot;, err);
    }
    
    // Simple recursive open with no privileges needed.
    
    err = MoreSCOpen(false, false);
    if (err == noErr) {
        err = MoreSCOpen(false, false);
        
        MoreSCClose(&amp;err, false);
    }
    MoreSCClose(&amp;err, false);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 5) failed with error %ld!\n&quot;, err);
    }
    
    // Recursive open with no lock but dirty made.
    
    err = MoreSCOpen(false, false);
    if (err == noErr) {
        err = MoreSCOpen(false, false);
        
        MoreSCClose(&amp;err, false);
    }
    MoreSCClose(&amp;err, true);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 6) failed with error %ld!\n&quot;, err);
    }
    
    // Recursive open with lock and no dirty.
    
    err = MoreSCOpen(true, true);
    if (err == noErr) {
        err = MoreSCOpen(false, false);
        
        MoreSCClose(&amp;err, false);
    }
    MoreSCClose(&amp;err, false);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 7) failed with error %ld!\n&quot;, err);
    }

    // Recursive open with lock and dirty.
    
    err = MoreSCOpen(true, true);
    if (err == noErr) {
        err = MoreSCOpen(false, false);
        
        MoreSCClose(&amp;err, false);
    }
    MoreSCClose(&amp;err, true);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 8) failed with error %ld!\n&quot;, err);
    }
    
    // Recursive open with inner no lock and dirty.
    
    err = MoreSCOpen(false, false);
    if (err == noErr) {
        err = MoreSCOpen(false, false);
        
        MoreSCClose(&amp;err, true);
    }
    MoreSCClose(&amp;err, false);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 9) failed with error %ld!\n&quot;, err);
    }
    
    // Recursive open with inner lock and no dirty.
    
    err = MoreSCOpen(false, false);
    if (err == noErr) {
        err = MoreSCOpen(true, true);
        
        MoreSCClose(&amp;err, false);
    }
    MoreSCClose(&amp;err, false);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 10) failed with error %ld!\n&quot;, err);
    }

    // Recursive open with inner lock and dirty.
    
    err = MoreSCOpen(false, false);
    if (err == noErr) {
        err = MoreSCOpen(true, true);
        
        MoreSCClose(&amp;err, true);
    }
    MoreSCClose(&amp;err, false);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 11) failed with error %ld!\n&quot;, err);
    }
    
    // Recursive open with both inner and outer lock and dirty.
    
    err = MoreSCOpen(true, true);
    if (err == noErr) {
        err = MoreSCOpen(true, true);
        
        MoreSCClose(&amp;err, true);
    }
    MoreSCClose(&amp;err, true);
    if (err != noErr) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 12) failed with error %ld!\n&quot;, err);
    }

    // Open/close with error.
    
    err = MoreSCOpen(false, false);
    if (err == noErr) {
        err = -1;
    }
    MoreSCClose(&amp;err, false);
    if (err != -1) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 13) failed with error %ld!\n&quot;, err);
    }

    // Open/close with dirty and error.
    
    err = MoreSCOpen(false, false);
    if (err == noErr) {
        err = -1;
    }
    MoreSCClose(&amp;err, true);
    if (err != -1) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 14) failed with error %ld!\n&quot;, err);
    }
    
    // Open/close with lock, dirty and error.
    
    err = MoreSCOpen(true, true);
    if (err == noErr) {
        err = -1;
    }
    MoreSCClose(&amp;err, true);
    if (err != -1) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 15) failed with error %ld!\n&quot;, err);
    }
    
    // Switch to the nobody user.
    
    oldUID = seteuid(-2);

    // Lock but no dirty, should trigger error on the open.
    
    err = MoreSCOpen(true, true);
    assert(err == kSCStatusAccessError);
    MoreSCClose(&amp;err, false);
    if (err != kSCStatusAccessError) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 16) failed with error %ld!\n&quot;, err);
    }

    // No lock but dirty, should trigger error on the close.
    
    err = MoreSCOpen(false, false);
    assert(err == noErr);
    MoreSCClose(&amp;err, true);
    if (err != kSCStatusAccessError) {
        fprintf(stderr, &quot;*** DebugOpenClose (step 16) failed with error %ld!\n&quot;, err);
    }

    
    (void) seteuid(oldUID);
}

static void DebugCreateSet(void)
{
    OSStatus err;
    
    err = MoreSCNewSet(CFSTR(&quot;Frog&quot;), NULL);

    if (err == noErr) {
        fprintf(stderr, &quot;Success!\n&quot;);
    } else {
        fprintf(stderr, &quot;*** Failed with error %ld!\n&quot;, err);
    }
}

#define kPPPoESetName CFSTR(&quot;MoreSCF DebugCreatePPPoE Set Name&quot;)

static void DebugCreatePPPoE(void)
{
    OSStatus        err;
    CFStringRef     setID;
    
    setID = NULL;

    err = MoreSCFindSetByUserVisibleNameAndCopyID(kPPPoESetName, &amp;setID);
    if (err == noErr &amp;&amp; setID != NULL) {
        err = MoreSCDeleteSet(setID);
        
        CFQRelease(setID);
        setID = NULL;
    }
    if (err == noErr) {
        MoreSCPPPDigest ppp;
        
        BlockZero(&amp;ppp, sizeof(ppp));
        ppp.active            = true;
        ppp.authName          = CFSTR(&quot;Quinn&quot;);
        ppp.authPassword      = CFSTR(&quot;eskimo&quot;);

        err = MoreSCMakeNewPPPoESet(NULL, kPPPoESetName, &amp;ppp, NULL, NULL, &amp;setID);
    }
    if (err == noErr) {
        fprintf(stderr, &quot;PPPoE set ID is &quot;);
        CFShow(setID);
    }
    
    CFQRelease(setID);

    if (err == noErr) {
        fprintf(stderr, &quot;Success!\n&quot;);
    } else {
        fprintf(stderr, &quot;*** Failed with error %ld\n&quot;, err);
    }
}

static void DebugTrivialCreate(void)
{
  OSStatus    err;
  CFStringRef  setID;
    
    setID = NULL;
    
  err = MoreSCSetClient(CFSTR(&quot;MyClient&quot;));
  if (err == noErr) {
    err = MoreSCOpen(false, false);
    }
  if (err == noErr) {
    err = MoreSCNewSet(CFSTR(&quot;My New Set&quot;), &amp;setID);
        MoreSCClose(&amp;err, true);    
    }
    CFQRelease(setID);

  PrintTestResult(err, NULL);
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Test Engine

static void PrintPropertyListCallback(CFTypeRef key, CFTypeRef node, void *context)
  // A callback routine used by PrintPropertyList to print 
  // a property list in a nicely formatted way.
{
  #pragma unused(key)
  int i;
  int depth;
  
  depth = (int)context;
  
  for (i = 0; i &lt; depth; i++) {
    fprintf(stderr, &quot;  &quot;);
  }

  {
    CFStringRef fullDesc;
    CFStringRef typeDesc;
    CFStringRef valueDesc;

    fullDesc = NULL;    
    typeDesc = CFCopyTypeIDDescription(CFGetTypeID(node));
    valueDesc = NULL;
    if ( CFQPropertyListIsLeaf(node) ) {
      if ( CFGetTypeID(node) == CFStringGetTypeID() ) {
        valueDesc = (CFStringRef) CFRetain(node);
      } else if ( CFGetTypeID(node) == CFNumberGetTypeID() ) {
        valueDesc = (CFStringRef) CFRetain(node);
      } else {
        valueDesc = CFCopyDescription(node);
      }
      fullDesc = CFStringCreateWithFormat(NULL, NULL, CFSTR(&quot;%@ : %@ [%d] = %@&quot;), key, typeDesc, CFGetRetainCount(node), valueDesc);
    } else {
      fullDesc = CFStringCreateWithFormat(NULL, NULL, CFSTR(&quot;%@ : %@ [%d]&quot;), key, typeDesc, CFGetRetainCount(node));
    }
    CFShow(fullDesc);
    CFQRelease(fullDesc);
    CFQRelease(valueDesc);
    CFQRelease(typeDesc);
  }

  if ( ! CFQPropertyListIsLeaf(node) ) {
    CFQPropertyListShallowApplyFunction(node, PrintPropertyListCallback, (void *) (depth + 1) );
  }
}

extern void PrintPropertyList(CFPropertyListRef propList)
  // This routine prints a CFPropertyList in a nicely formatted way.
{
  PrintPropertyListCallback(CFSTR(&quot;ROOT&quot;), propList, (void *) 0);
}

static void RefCounter(CFTypeRef node, void *context)
  // A callback routine that adds node's reference count 
  // to a global total.  Used by TotalAllRefCounts.
{
    (*((SInt32 *)context)) += CFGetRetainCount(node);
}

static SInt32 TotalAllRefCounts(SCPreferencesRef prefsRef, CFArrayRef allKeys)
  // Given a connection to the SCF preferences database and an array 
  // of preference keys, this routine calculates the total of all 
  // of the reference counts of all of the nodes in all of the SCF 
  // preferences.  I use this routine to check for reference count leaks 
  // in my use of the SCF preferences database.
{
  CFIndex keyCount;
  CFIndex keyIndex;
  SInt32  result;
  
  result = 0;
  keyCount = CFArrayGetCount(allKeys);
  for (keyIndex = 0; keyIndex &lt; keyCount; keyIndex++) {
    CFPropertyListRef thisPref;
    
    thisPref = SCPreferencesGetValue(prefsRef, (CFStringRef) CFArrayGetValueAtIndex(allKeys, keyIndex));  // C++ requires cast
    CFQPropertyListDeepApplyFunction(thisPref, RefCounter, (void *) &amp;result );
  }
  return result;
}

#if 0

static void PrintAllPreferences(SCPreferencesRef prefsRef, CFArrayRef allKeys)
  // This routine prints all of the preferences in the SCF preferences 
  // database.  I use it during debugging.
{
  CFIndex keyCount;
  CFIndex keyIndex;
  
  keyCount = CFArrayGetCount(allKeys);
  for (keyIndex = 0; keyIndex &lt; keyCount; keyIndex++) {
    CFPropertyListRef thisPref;
    
    thisPref = SCPreferencesGetValue(prefsRef, (CFStringRef) CFArrayGetValueAtIndex(allKeys, keyIndex));  // C++ requires cast
    PrintPropertyList(thisPref);
  }
}

#endif

typedef void (*TestFunc)(void);

static void LeakTest(TestFunc tester)
  // Given a test name and a pointer to a test function, 
  // this routine calls the test function repeatedly to check 
  // for SCF preferences reference count leaks.
{
  OSStatus       err;
  SCPreferencesRef   prefsRef;
  CFArrayRef       allKeys;
  int          i;
  SInt32        startCount;
  SInt32        endCount;
  
    prefsRef = NULL;
    
  // This is kinda cheesy.  We need to use the same SCPreferencesRef 
  // that MoreSCF uses because otherwise we can't see the reference 
  // count changes done by MoreSCF.  Ideally, we wouldn't want to run 
  // within a MoreSCOpen/MoreSCClose pair because then our changes 
  // aren't necessarily being committed to the database.  However, 
  // given the current MoreSCF architecture, where the SCPreferenceRef 
  // is only valid inside the MoreSCOpen/MoreSCClose pair, that's 
  // exactly what we have to do.

  allKeys = NULL;
  
  err = MoreSCOpen(false, false);
  if (err == noErr) {
    prefsRef = MoreSCGetSCPreferencesRef();
  }

  // Now get a copy of the array of all keys in the database.  
  // We make this copy using CFPropertyListCreateDeepCopy so we 
  // know that it's completely independent of the SCF.
  
  if (err == noErr) {
    CFArrayRef allKeysOrig;
    
    allKeysOrig = NULL;

    allKeysOrig = SCPreferencesCopyKeyList(prefsRef);
    if (allKeysOrig == NULL) {
      err = SCError();
    }
    if (err == noErr) {
      allKeys = (CFArrayRef) CFPropertyListCreateDeepCopy(NULL, allKeysOrig, kCFPropertyListMutableContainersAndLeaves);  // C++ requires cast
      if (allKeys == NULL) {
        err = coreFoundationUnknownErr;
      }
    }
    
    CFQRelease(allKeysOrig);
  }

  // Now do the reference counting test.  Call the tester function
  // a few times to allow the refcounts to stabilise.  Then get 
  // a summ of all the nodes in all of the keys in SCF.  Then 
  // run the test a 10 more times and get another count.  If 
  // the counts are different, we're in trouble.
  
  if (err == noErr) {
    for (i = 0; i &lt; 3; i++) {
      tester();
    }
    
    startCount = TotalAllRefCounts(prefsRef, allKeys);
    
    for (i = 0; i &lt; 10; i++) {
      tester();
    }
    
    endCount = TotalAllRefCounts(prefsRef, allKeys);
    
    if (startCount != endCount) {
      CFIndex keyCount;
      CFIndex keyIndex;
      
      fprintf(stderr, &quot;*** Leaked a total of %ld reference counts.\n&quot;, endCount - startCount);

      keyCount = CFArrayGetCount(allKeys);
      for (keyIndex = 0; keyIndex &lt; keyCount; keyIndex++) {
        CFPropertyListRef thisPref;

        // The code conditionalised by gCheckLeaksDebug is helpful when 
                // you're actively trying to track down a leak.
        
        startCount = 0;
        thisPref = SCPreferencesGetValue(prefsRef, (CFStringRef) CFArrayGetValueAtIndex(allKeys, keyIndex));  // C++ requires cast
        CFQPropertyListDeepApplyFunction(thisPref, RefCounter, (void *) &amp;startCount );
        if (gCheckLeaksDebug) {
          fprintf(stderr, &quot;*** BEFORE %ld ***\n&quot;, keyIndex);
          PrintPropertyList(thisPref);
        }

        tester();

        endCount = 0;
        thisPref = SCPreferencesGetValue(prefsRef, (CFStringRef) CFArrayGetValueAtIndex(allKeys, keyIndex));  // C++ requires cast
        CFQPropertyListDeepApplyFunction(thisPref, RefCounter, (void *) &amp;endCount );
        if (gCheckLeaksDebug) {
          fprintf(stderr, &quot;*** AFTER %ld ***\n&quot;, keyIndex);
          PrintPropertyList(thisPref);
        }
        
        if (startCount != endCount) {
          fprintf(stderr, &quot;***   %ld leaked reference counts at key index %ld\n&quot;, endCount - startCount, keyIndex);
          CFShow(CFArrayGetValueAtIndex(allKeys, keyIndex));
        }
      }
    }
  }

  MoreSCClose(&amp;err, false);

  CFQRelease(allKeys);

    if (err != noErr) {
        fprintf(stderr, &quot;*** Failed with error %ld!\n&quot;, err);
    }
}

static void PrintTestResult(OSStatus errNum, const char *subTestName)
{
  if (errNum == noErr) {
    if ( ! gRunQuiet ) {
      if (subTestName == NULL) {
        fprintf(stderr, &quot;Success!\n&quot;);
      } else {
        fprintf(stderr, &quot;Success! (%s)\n&quot;, subTestName);
      }
    }
  } else {
    if (subTestName == NULL) {
      fprintf(stderr, &quot;*** Failed with error %ld\n&quot;, errNum);
    } else {
      fprintf(stderr, &quot;*** Failed (%s) with error %ld\n&quot;, subTestName, errNum);
    }
  }
}

struct TestInfo {
  const char *  testName;
  TestFunc      tester;
  Boolean      needsRoot;
    Boolean         debugOnly;
};
typedef struct TestInfo TestInfo;

static void RunTest(const TestInfo *theTest)
{
  Boolean runTheTest;
  
  runTheTest = true;
  if ( gRunQuiet &amp;&amp; gCheckLeaks ) {
    fprintf(stderr, &quot;LeakTest(%s)\n&quot;, theTest-&gt;testName);
  } else if ( ! gRunQuiet ) {
    fprintf(stderr, &quot;%s\n&quot;, theTest-&gt;testName);
  }
  if ( theTest-&gt;needsRoot ) {
    if (gNoRootTests) {
      fprintf(stderr, &quot;*** Did not run test because it requires root.\n&quot;);
      runTheTest = false;
    } else if ( geteuid() != 0 ) {
        fprintf(stderr, &quot;*** Did not run because the test requires root.\n&quot;);
      runTheTest = false;
      }
  }
  
  if (runTheTest) {
    if ( gCheckLeaks ) {
      LeakTest(theTest-&gt;tester);
    } else {
        theTest-&gt;tester();
    }
  }
  if ( ! gRunQuiet ) {
    fprintf(stderr, &quot;\n&quot;);
  }
}

static const TestInfo kTests[] = {
  { &quot;TestPortScanner&quot;,         TestPortScanner,        false,  false },
  { &quot;TestPortScannerOld&quot;,             TestPortScannerOld,        false,  false },
  { &quot;TestCCLScanner&quot;,         TestCCLScanner,                 false,  false },
  { &quot;TestCopySetsDict&quot;,         TestCopySetsDict,        false,  false },
  { &quot;TestSetEnumerationAndSwitch&quot;,   TestSetEnumerationAndSwitch,  true,   false },
  { &quot;TestDuplicateAndDeleteSet&quot;,     TestDuplicateAndDeleteSet,    true,   false },
  { &quot;TestRenameSet&quot;,           TestRenameSet,          true,   false },
  { &quot;TestServiceEnumerate&quot;,       TestServiceEnumerate,      false,  false },
  { &quot;TestDuplicateAndDeleteService&quot;,  TestDuplicateAndDeleteService,  true,   false },
  { &quot;TestRenameService&quot;,         TestRenameService,        true,   false },
  { &quot;TestEnumerateEntities&quot;,       TestEnumerateEntities,      false,  false },
  { &quot;TestCreateSet&quot;,           TestCreateSet,          true,   false },
  { &quot;TestISP&quot;,             TestISP,            true,   false },
  { &quot;TestAppleTalk&quot;,           TestAppleTalk,          true,   false }, 
  { &quot;DebugModemScriptSearch&quot;,         DebugModemScriptSearch,         false,  true  }, 
  { &quot;DebugCreateProxiesEntity&quot;,       DebugCreateProxiesEntity,       false,  true  }, 
  { &quot;DebugOpenClose&quot;,                 DebugOpenClose,                 true,   true  }, 
  { &quot;DebugCreateSet&quot;,                 DebugCreateSet,                 true,   true  }, 
  { &quot;DebugCreatePPPoE&quot;,               DebugCreatePPPoE,        true,   true  }, 
  { &quot;DebugTrivialCreate&quot;,             DebugTrivialCreate,        true,   true  }, 
  { NULL, NULL }
};

static void RunTestsMatching(const char *testName)
{
  int testIndex;
  
  testIndex = 0;
  while ( kTests[testIndex].testName != NULL ) {
        // Run the test if we're running all tests and the test isn't a debug-only 
        // test, or if the user has explicitly asked for it.
    if ( ((testName == NULL) &amp;&amp; ! kTests[testIndex].debugOnly) || ( (testName != NULL) &amp;&amp; (strcmp(testName, kTests[testIndex].testName) == 0)) ) {
      RunTest(&amp;kTests[testIndex]);
    }
    testIndex += 1;
  }
}

static void PrintUsage(void)
{
    size_t  testIndex;
    static const char * kPrefixen[2] = {
        &quot;Tests names:&quot;,
        &quot;Debug test names: (not run as part of automated test suite)&quot;
    };
    Boolean debugOnly;
    
  fprintf(stderr, &quot;Usage: %s [-u] [-q] [-l] [-L] [ TestName... ] \n&quot;, gProgramName);
  fprintf(stderr, &quot;       -u only run root tests if running as root\n&quot;);
  fprintf(stderr, &quot;       -q quiet mode\n&quot;);
  fprintf(stderr, &quot;       -l run tests repeatedly to check for leaks (implies -q)\n&quot;);
  fprintf(stderr, &quot;       -L leak checks with debugging output (implies -q)\n&quot;);
  fprintf(stderr, &quot;\n&quot;);
    for (debugOnly = 0; debugOnly &lt; 2; debugOnly++) {
        fprintf(stderr, &quot;       %s\n&quot;, kPrefixen[debugOnly]);
        testIndex = 0;
        while ( kTests[testIndex].testName != NULL ) {
            if ( kTests[testIndex].debugOnly == debugOnly ) {
                fprintf(
                    stderr, 
                    &quot;           %s%s\n&quot;, 
                    kTests[testIndex].testName, 
                    kTests[testIndex].needsRoot ? &quot; *&quot; : &quot;&quot;
                );
            }
            testIndex += 1;
        }
    }
  fprintf(stderr, &quot;       * must be run as root\n&quot;);
}


int main(int argc, char *argv[])
{
  int ch;
  int argIndex;
  
  // Set up gProgramName to be the last path element of argv[0].
  
  gProgramName = strrchr(argv[0], '/');
  if (gProgramName == NULL) {
    gProgramName = argv[0];
  } else {
    gProgramName += 1;
  }
  
    fprintf(stderr, &quot;%s\n&quot;, gProgramName);
    
  // Parse arguments.

    do {
        ch = getopt(argc, argv, &quot;uqLl&quot;);
        if (ch != -1) {
            switch (ch) {
                case 'u':
                  gNoRootTests = true;
                    break;
                case 'q':
                  gRunQuiet   = true;
                    break;
                case 'L':
                    gCheckLeaksDebug = true;
                    // fall through
        case 'l':
          gCheckLeaks = true;
                  gRunQuiet   = true;
          break;
                case '?':
                default:
                    PrintUsage();
                    exit(1);
                    break;
            }
        }
    } while (ch != -1);
    
    if (optind == argc) {
      fprintf(stderr, &quot;Running all tests\n&quot;);
      fprintf(stderr, &quot;\n&quot;);
      RunTestsMatching(NULL);
    } else {
      for (argIndex = optind; argIndex &lt; argc; argIndex++) {
        RunTestsMatching(argv[argIndex]);
      }
    }

    return 0;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoreSCF/listing13.html%3Fid%3DDTS10000702-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoreSCF/listing13.html%3Fid%3DDTS10000702-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoreSCF/listing13.html%3Fid%3DDTS10000702-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>