<html><head><title>Mac OS X
 Manual Page For glDrawPixels(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/glDrawPixels" title="Mac OS X
 Manual Page for glDrawPixels(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/glDrawPixels"; name=glDrawPixels(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
GLDRAWPIXELS(3G)                                                                            GLDRAWPIXELS(3G)



<b>NAME</b>
       <b>glDrawPixels</b> - write a block of pixels to the frame buffer


<b>C</b> <b>SPECIFICATION</b>
       void <b>glDrawPixels</b>( GLsizei <u>width</u>,
                          GLsizei <u>height</u>,
                          GLenum <u>format</u>,
                          GLenum <u>type</u>,
                          const GLvoid <u>*pixels</u> )


<b>PARAMETERS</b>
       <u>width</u>, <u>height</u> Specify the dimensions of the pixel rectangle to be written into the frame buffer.

       <u>format</u>        Specifies   the   format   of  the  pixel  data.   Symbolic  constants  <b>GL_COLOR_INDEX</b>,
                     <b>GL_STENCIL_INDEX</b>,  <b>GL_DEPTH_COMPONENT</b>,  <b>GL_RGB</b>,  <b>GL_BGR</b>,  <b>GL_RGBA</b>,   <b>GL_BGRA</b>,   <b>GL_RED</b>,
                     <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_ALPHA</b>, <b>GL_LUMINANCE</b>, and <b>GL_LUMINANCE_ALPHA</b> are accepted.

       <u>type</u>          Specifies  the  data  type  for  <u>pixels</u>.  Symbolic constants <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
                     <b>GL_BITMAP</b>,   <b>GL_UNSIGNED_SHORT</b>,   <b>GL_SHORT</b>,    <b>GL_UNSIGNED_INT</b>,    <b>GL_INT</b>,    <b>GL_FLOAT</b>,
                     <b>GL_UNSIGNED_BYTE_3_3_2</b>,       <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>,      <b>GL_UNSIGNED_SHORT_5_6_5</b>,
                     <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,  <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>,
                     <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,    <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,   <b>GL_UNSIGNED_INT_8_8_8_8</b>,
                     <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>,              <b>GL_UNSIGNED_INT_10_10_10_2</b>,               and
                     <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> are accepted.

       <u>pixels</u>        Specifies a pointer to the pixel data.

<b>DESCRIPTION</b>
       <b>glDrawPixels</b> reads pixel data from memory and writes it into the frame buffer
       relative to the current raster position, provided that the raster position is valid.  Use
       <b>glRasterPos</b>    to    set    the    current    raster    position;    use    <b>glGet</b>    with    argument
       <b>GL_CURRENT_RASTER_POSITION_VALID</b> to determine if the specified raster position is  valid,  and  <b>glGet</b>
       with argument <b>GL_CURRENT_RASTER_POSITION</b> to query the raster position.

       Several  parameters  define  the  encoding  of pixel data in memory and control the processing of the
       pixel data before it is placed in the frame buffer.  These parameters are  set  with  four  commands:
       <b>glPixelStore</b>,  <b>glPixelTransfer</b>,  <b>glPixelMap</b>,  and  <b>glPixelZoom</b>.   This  reference  page describes the
       effects on <b>glDrawPixels</b> of many, but not all, of the parameters specified by these four commands.

       Data is read from <u>pixels</u> as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed
       or unsigned integers, or single-precision floating-point values, depending on <u>type</u>.  When <u>type</u> is one
       of <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, or <b>GL_FLOAT</b>  each
       of  these bytes, shorts, integers, or floating-point values is interpreted as one color or depth com-<font color="#ffffff" class="whiteout">ponent,&nbsp;component,</font>
       ponent,  or  one  index,  depending  on  <u>format</u>.   When  <u>type</u>  is  one   of   <b>GL_UNSIGNED_BYTE_3_3_2</b>,
       <b>GL_UNSIGNED_SHORT_5_6_5</b>,             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,            <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
       <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>, each unsigned value is interpreted as containing
       all  the components for a single pixel, with the color components arranged according to <u>format</u>.  When
       <u>type</u>       is       one       of       <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>,       <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
       <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>,       <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,      <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>,
       <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, each unsigned value is interpreted as  containing  all  color  compo-<font color="#ffffff" class="whiteout">nents,&nbsp;components,</font>
       nents,  specified by <u>format</u>, for a single pixel in a reversed order. Indices are always treated indi-<font color="#ffffff" class="whiteout">vidually.&nbsp;individually.</font>
       vidually.  Color components are treated as groups of one, two, three, or four values, again based  on
       <u>format</u>.  Both  individual  indices  and  groups  of components are referred to as pixels.  If <u>type</u> is
       <b>GL_BITMAP</b>,  the  data  must  be  unsigned  bytes,  and  <u>format</u>  must  be  either  <b>GL_COLOR_INDEX</b>   or
       <b>GL_STENCIL_INDEX</b>.   Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined
       by <b>GL_UNPACK_LSB_FIRST</b> (see <b>glPixelStore</b>).

       <u>width</u> * <u>height</u> pixels are read from memory, starting at location <u>pixels</u>.  By  default,  these  pixels
       are  taken  from  adjacent  memory  locations,  except that after all <u>width</u> pixels are read, the read
       pointer is advanced to the next four-byte boundary.  The four-byte  row  alignment  is  specified  by
       <b>glPixelStore</b>  with argument <b>GL_UNPACK_ALIGNMENT</b>, and it can be set to one, two, four, or eight bytes.
       Other pixel store parameters specify different read pointer advancements, both before the first pixel
       is  read  and  after  all  <u>width</u> pixels are read.  See the <b>glPixelStore</b> reference page for details on
       these options.

       The <u>width</u> * <u>height</u> pixels that are read from memory are each operated on in the same  way,  based  on
       the  values  of several parameters specified by <b>glPixelTransfer</b> and <b>glPixelMap</b>.  The details of these
       operations, as well as the target buffer into which the pixels are drawn, are specific to the  format
       of the pixels, as specified by <u>format</u>.  <u>format</u> can assume one of 13 symbolic values:

       <b>GL_COLOR_INDEX</b>
                 Each  pixel  is  a  single  value, a color index.  It is converted to fixed-point , with an
                 unspecified number of bits to the right of the binary point, regardless of the memory  data
                 type.  Floating-point values convert to true fixed-point values.  Signed and unsigned inte-<font color="#ffffff" class="whiteout">ger&nbsp;integer</font>
                 ger data is converted with all fraction bits set to 0.  Bitmap data convert to either 0  or
                 1.

                 Each  fixed-point  index  is  then  shifted  left  by  <b>GL_INDEX_SHIFT</b>  bits  and  added  to
                 <b>GL_INDEX_OFFSET</b>.  If <b>GL_INDEX_SHIFT</b> is negative, the shift is  to  the  right.   In  either
                 case, zero bits fill otherwise unspecified bit locations in the result.

                 If  the GL is in RGBA mode, the resulting index is converted to an RGBA pixel with the help
                 of    the    <b>GL_PIXEL_MAP_I_TO_R</b>,     <b>GL_PIXEL_MAP_I_TO_G</b>,     <b>GL_PIXEL_MAP_I_TO_B</b>,     and
                 <b>GL_PIXEL_MAP_I_TO_A</b> tables.  If the GL is in color index mode, and if <b>GL_MAP_COLOR</b> is true,
                 the  index  is  replaced  with   the   value   that   it   references   in   lookup   table
                 <b>GL_PIXEL_MAP_I_TO_I</b>.  Whether the lookup replacement of the index is done or not, the inte-<font color="#ffffff" class="whiteout">ger&nbsp;integer</font>
                 ger part of the index is then ANDed with (2^b) -1, where b is the number of bits in a color
                 index buffer.

                 The  GL  then  converts  the resulting indices or RGBA colors to fragments by attaching the
                 current raster position <u>z</u> coordinate and texture coordinates to each pixel, then  assigning
                 x and y window coordinates to the nth fragment such that


                                                    xn = xr + n mod width

                                                      yn = yr + n/width



                 where (xr, yr) is the current raster position.  These pixel fragments are then treated just
                 like the fragments generated by rasterizing points, lines, or polygons.   Texture  mapping,
                 fog,  and  all  the fragment operations are applied before the fragments are written to the
                 frame buffer.

       <b>GL_STENCIL_INDEX</b>
                 Each pixel is a single value, a stencil index.  It is converted to fixed-point  ,  with  an
                 unspecified  number of bits to the right of the binary point, regardless of the memory data
                 type.  Floating-point values convert to true fixed-point values.  Signed and unsigned inte-<font color="#ffffff" class="whiteout">ger&nbsp;integer</font>
                 ger  data is converted with all fraction bits set to 0.  Bitmap data convert to either 0 or
                 1.

                 Each fixed-point  index  is  then  shifted  left  by  <b>GL_INDEX_SHIFT</b>  bits,  and  added  to
                 <b>GL_INDEX_OFFSET</b>.   If  <b>GL_INDEX_SHIFT</b>  is  negative,  the shift is to the right.  In either
                 case, zero bits fill otherwise unspecified bit locations in the result.  If  <b>GL_MAP_STENCIL</b>
                 is  true,  the  index  is  replaced  with  the  value  that  it  references in lookup table
                 <b>GL_PIXEL_MAP_S_TO_S</b>.  Whether the lookup replacement of the index is done or not, the inte-<font color="#ffffff" class="whiteout">ger&nbsp;integer</font>
                 ger  part  of  the  index  is then ANDed with (2^b)-1, where b is the number of bits in the
                 stencil buffer.  The resulting stencil indices are then written to the stencil buffer  such
                 that the nth index is written to location


                                               xn = xr + n mod width

                                                 yn = yr + n/width


              where  (xr  ,  yr) is the current raster position.  Only the pixel ownership test, the scissor
              test, and the stencil writemask affect these write operations.

       <b>GL_DEPTH_COMPONENT</b>
              Each pixel is a single-depth component.  Floating-point  data  is  converted  directly  to  an
              internal floating-point
               with unspecified precision.  Signed integer data is mapped linearly to the internal floating-<font color="#ffffff" class="whiteout">point&nbsp;floatingpoint</font>
              point
               such that the most positive representable integer value maps to 1.0, and  the  most  negative
              representable  value  maps  to  -1.0.   Unsigned integer data is mapped similarly: the largest
              integer value maps to 1.0, and 0 maps to 0.0.  The resulting  floating-point  depth  value  is
              then  multiplied  by  <b>GL_DEPTH_SCALE</b> and added to <b>GL_DEPTH_BIAS</b>.  The result is clamped to the
              range [0,1].

              The GL then converts the resulting depth components to  fragments  by  attaching  the  current
              raster  position  color or color index and texture coordinates to each pixel, then assigning x
              and y window coordinates to the nth fragment such that


                                               xn = xr + n mod width

                                                 yn = yr + n/width


              where (xr , yr) is the current raster position.  These pixel fragments are then  treated  just
              like the fragments generated by rasterizing points, lines, or polygons.  Texture mapping, fog,
              and all the fragment operations are applied before the fragments  are  written  to  the  frame
              buffer.

       <b>GL_RGBA</b>

       <b>GL_BGRA</b>
              Each  pixel  is  a  four-component group: for <b>GL_RGBA</b>, the red component is first, followed by
              green, followed by blue, followed by alpha; for <b>GL_BGRA</b> the order is blue, green, red and then
              alpha.  Floating-point values are converted directly to an internal floating-point
               with unspecified precision.  Signed integer values are mapped linearly to the internal float-<font color="#ffffff" class="whiteout">ing-point&nbsp;floating-point</font>
              ing-point
               such that the most positive representable integer value maps to 1.0, and  the  most  negative
              representable  value  maps  to  -1.0.  (Note that this mapping does not convert 0 precisely to
              0.0.)  Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and 0
              maps  to 0.0.  The resulting floating-point color values are then multiplied by <b>GL_c_SCALE</b> and
              added to <b>GL_c_BIAS</b>, where <u>c</u> is RED, GREEN, BLUE, and ALPHA for  the  respective  color  compo-<font color="#ffffff" class="whiteout">nents.&nbsp;components.</font>
              nents.  The results are clamped to the range [0,1].

              If  <b>GL_MAP_COLOR</b>  is  true,  each  color  component  is  scaled  by  the  size of lookup table
              <b>GL_PIXEL_MAP_c_TO_c</b>, then replaced by the value that it references in that table.  <u>c</u> is R,  G,
              B, or A respectively.

              The  GL  then  converts the resulting RGBA colors to fragments by attaching the current raster
              position <u>z</u> coordinate and texture coordinates to each pixel, then assigning  x  and  y  window
              coordinates to the nth fragment such that


                                               xn = xr + n mod width

                                                 yn = yr + n/width


              where  (xr  , yr) is the current raster position.  These pixel fragments are then treated just
              like the fragments generated by rasterizing points, lines, or polygons.  Texture mapping, fog,
              and  all  the  fragment  operations  are applied before the fragments are written to the frame
              buffer.

       <b>GL_RED</b> Each pixel is a single red component.  This component is converted to the  internal  floating-<font color="#ffffff" class="whiteout">point&nbsp;floatingpoint</font>
              point   in the same way the red component of an RGBA pixel is. It is then converted to an RGBA
              pixel with green and blue set to 0, and alpha set to 1.  After this conversion, the  pixel  is
              treated as if it had been read as an RGBA pixel.

       <b>GL_GREEN</b>
              Each pixel is a single green component.  This component is converted to the internal floating-<font color="#ffffff" class="whiteout">point&nbsp;floatingpoint</font>
              point  in the same way the green component of an RGBA pixel is.  It is then  converted  to  an
              RGBA  pixel  with red and blue set to 0, and alpha set to 1.  After this conversion, the pixel
              is treated as if it had been read as an RGBA pixel.

       <b>GL_BLUE</b>
              Each pixel is a single blue component.  This component is converted to the internal  floating-<font color="#ffffff" class="whiteout">point&nbsp;floatingpoint</font>
              point   in  the  same  way the blue component of an RGBA pixel is.  It is then converted to an
              RGBA pixel with red and green set to 0, and alpha set to 1.  After this conversion, the  pixel
              is treated as if it had been read as an RGBA pixel.

       <b>GL_ALPHA</b>
              Each pixel is a single alpha component.  This component is converted to the internal floating-<font color="#ffffff" class="whiteout">point&nbsp;floatingpoint</font>
              point  in the same way the alpha component of an RGBA pixel is.  It is then  converted  to  an
              RGBA pixel with red, green, and blue set to 0.  After this conversion, the pixel is treated as
              if it had been read as an RGBA pixel.

       <b>GL_RGB</b>

       <b>GL_BGR</b> Each pixel is a three-component group: red first, followed by green,  followed  by  blue;  for
              <b>GL_BGR</b>,  the  first component is blue, followed by green and then red.  Each component is con-<font color="#ffffff" class="whiteout">verted&nbsp;converted</font>
              verted to the internal floating-point  in the same way the red, green, and blue components  of
              an RGBA pixel are.  The color triple is converted to an RGBA pixel with alpha set to 1.  After
              this conversion, the pixel is treated as if it had been read as an RGBA pixel.

       <b>GL_LUMINANCE</b>
              Each pixel is a single luminance component.  This  component  is  converted  to  the  internal
              floating-point   in  the same way the red component of an RGBA pixel is.  It is then converted
              to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set
              to 1.  After this conversion, the pixel is treated as if it had been read as an RGBA pixel.

       <b>GL_LUMINANCE_ALPHA</b>
              Each  pixel  is a two-component group: luminance first, followed by alpha.  The two components
              are converted to the internal floating-point  in the same way the red  component  of  an  RGBA
              pixel  is.  They are then converted to an RGBA pixel with red, green, and blue set to the con-<font color="#ffffff" class="whiteout">verted&nbsp;converted</font>
              verted luminance value, and alpha set to the converted alpha value.   After  this  conversion,
              the pixel is treated as if it had been read as an RGBA pixel.

       The following table summarizes the meaning of the valid constants for the <u>type</u> parameter:



       Type               Corresponding Type _
        <b>GL_UNSIGNED_BYTE</b>  unsigned 8-bit integer
        <b>GL_BYTE</b>           signed 8-bit integer
        <b>GL_BITMAP</b>         single bits in unsigned 8-bit integers
        <b>GL_UNSIGNED_SHORT</b> unsigned 16-bit integer
        <b>GL_SHORT</b>          signed 16-bit integer
        <b>GL_UNSIGNED_INT</b>   unsigned 32-bit integer
        <b>GL_INT</b>            32-bit integer
        <b>GL_FLOAT</b>          single-precision floating-point
        <b>GL_UNSIGNED_BYTE_3_3_2</b>
                          unsigned 8-bit integer
        <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>
                          unsigned 8-bit integer with
                          reversed component ordering
        <b>GL_UNSIGNED_SHORT_5_6_5</b>
                          unsigned 16-bit integer
        <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>
                          unsigned 16-bit integer with
                          reversed component ordering
        <b>GL_UNSIGNED_SHORT_4_4_4_4</b>
                          unsigned 16-bit integer
        <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>
                          unsigned 16-bit integer with
                          reversed component ordering
        <b>GL_UNSIGNED_SHORT_5_5_5_1</b>
                          unsigned 16-bit integer
        <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>
                          unsigned 16-bit integer with
                          reversed component ordering
        <b>GL_UNSIGNED_INT_8_8_8_8</b>
                          unsigned 32-bit integer
        <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>
                          unsigned 32-bit integer with
                          reversed component ordering
        <b>GL_UNSIGNED_INT_10_10_10_2</b>
                          unsigned 32-bit integer
        <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>
                          unsigned 32-bit integer with
                          reversed component ordering



       The rasterization described so far assumes pixel zoom factors of 1.  If
       <b>glPixelZoom</b>  is  used  to change the x and y pixel zoom factors, pixels are converted to fragments as
       follows.  If (xr, yr) is the current raster position, and a given pixel is in the nth column and  mth
       row  of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectan-<font color="#ffffff" class="whiteout">gle&nbsp;rectangle</font>
       gle with corners at

                                             ( xr + zoomx * n, yr + zoomy *m)

                                         ( xr + zoomx * (n+1), yr + zoomy *(m+1))


       where zoomx is the value of <b>GL_ZOOM_X</b> and zoomy is the value of <b>GL_ZOOM_Y</b>.

<b>NOTES</b>
       <b>GL_BGR</b> and <b>GL_BGRA</b> are only valid for <u>format</u> if the GL version is 1.2 or greater.

       <b>GL_UNSIGNED_BYTE_3_3_2</b>,             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>,              <b>GL_UNSIGNED_SHORT_5_6_5</b>,
       <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,         <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,        <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>,
       <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,          <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,           <b>GL_UNSIGNED_INT_8_8_8_8</b>,
       <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>,  <b>GL_UNSIGNED_INT_10_10_10_2</b>, and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> are only
       valid for <u>type</u> if the GL version is 1.2 or greater.

<b>ERRORS</b>
       <b>GL_INVALID_VALUE</b> is generated if either <u>width</u> or <u>height</u> is negative.

       <b>GL_INVALID_ENUM</b> is generated if <u>format</u> or <u>type</u> is not one of the accepted values.

       <b>GL_INVALID_OPERATION</b> is generated if <u>format</u> is <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_ALPHA</b>, <b>GL_RGB</b>,  <b>GL_RGBA</b>,
       <b>GL_BGR</b>, <b>GL_BGRA</b>, <b>GL_LUMINANCE</b>, or <b>GL_LUMINANCE_ALPHA</b>, and the GL is in color index mode.

       <b>GL_INVALID_ENUM</b>  is  generated  if  <u>type</u>  is  <b>GL_BITMAP</b>  and  <u>format</u>  is not either <b>GL_COLOR_INDEX</b> or
       <b>GL_STENCIL_INDEX</b>.

       <b>GL_INVALID_OPERATION</b> is generated if <u>format</u> is <b>GL_STENCIL_INDEX</b> and there is no stencil buffer.

       <b>GL_INVALID_OPERATION</b> is generated if <b>glDrawPixels</b> is executed between the execution  of  <b>glBegin</b>  and
       the corresponding execution of <b>glEnd</b>.

       <b>GL_INVALID_OPERATION</b>     is     generated     if     <u>format</u>     is     one    <b>GL_UNSIGNED_BYTE_3_3_2</b>,
       <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, of <b>GL_UNSIGNED_SHORT_5_6_5_REV</b> and <u>format</u> is not
       <b>GL_RGB</b>.

       <b>GL_INVALID_OPERATION</b>    is    generated    if    <u>format</u>    is   one   of   <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
       <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>,       <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,        <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
       <b>GL_UNSIGNED_INT_8_8_8_8</b>,       <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>,       <b>GL_UNSIGNED_INT_10_10_10_2</b>,      or
       <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <u>format</u> is neither <b>GL_RGBA</b> nor <b>GL_BGRA</b>.

<b>ASSOCIATED</b> <b>GETS</b>
       <b>glGet</b> with argument <b>GL_CURRENT_RASTER_POSITION</b>
       <b>glGet</b> with argument <b>GL_CURRENT_RASTER_POSITION_VALID</b>

<b>SEE</b> <b>ALSO</b>
       <a href="glAlphaFunc.3.html#//apple_ref/doc/man/3/glAlphaFunc"><b>glAlphaFunc</b>(3G)</a>,   <a href="glBlendFunc.3.html#//apple_ref/doc/man/3/glBlendFunc"><b>glBlendFunc</b>(3G)</a>,   <a href="glCopyPixels.3.html#//apple_ref/doc/man/3/glCopyPixels"><b>glCopyPixels</b>(3G)</a>,   <a href="glDepthFunc.3.html#//apple_ref/doc/man/3/glDepthFunc"><b>glDepthFunc</b>(3G)</a>,   <a href="glLogicOp.3.html#//apple_ref/doc/man/3/glLogicOp"><b>glLogicOp</b>(3G)</a>,   <a href="glPixelMap.3.html#//apple_ref/doc/man/3/glPixelMap"><b>glPixelMap</b>(3G)</a>,   <a href="glPixelStore.3.html#//apple_ref/doc/man/3/glPixelStore"><b>glPixelStore</b>(3G)</a>,
       <a href="glPixelTransfer.3.html#//apple_ref/doc/man/3/glPixelTransfer"><b>glPixelTransfer</b>(3G)</a>, <a href="glPixelZoom.3.html#//apple_ref/doc/man/3/glPixelZoom"><b>glPixelZoom</b>(3G)</a>, <a href="glRasterPos.3.html#//apple_ref/doc/man/3/glRasterPos"><b>glRasterPos</b>(3G)</a>, <a href="glReadPixels.3.html#//apple_ref/doc/man/3/glReadPixels"><b>glReadPixels</b>(3G)</a>, <a href="glScissor.3.html#//apple_ref/doc/man/3/glScissor"><b>glScissor</b>(3G)</a>, <a href="glStencilFunc.3.html#//apple_ref/doc/man/3/glStencilFunc"><b>glStencilFunc</b>(3G)</a>




                                                                                            GLDRAWPIXELS(3G)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/glDrawPixels.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/glDrawPixels.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/glDrawPixels.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
