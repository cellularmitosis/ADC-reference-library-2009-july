<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Responding to Events Using TextEdit(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING51></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-50.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-52.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-40.html"><B>Chapter 2 - TextEdit</B></A> / <A HREF="Text-49.html"><B>Using TextEdit</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING51-0></A>
<H2><A NAME=MARKER-9-194></A>Responding to Events Using TextEdit</H2>
 This section disc<A NAME=MARKER-9-51></A>usses some of the TextEdit routines that your application can call in response to event notification. You can use TextEdit routines to<P>
<UL>
<LI>handle idle processing in response to null events (<CODE>TEIdle</CODE>)
<LI>identify the active edit record in response to an activate event (<CODE>TEActivate</CODE> and<CODE> TEDeactivate</CODE>)
<LI>handle mouse-down events (<CODE>TEClick</CODE>)
<LI>update the destination rectangle in response to an update event (<CODE>TEUpdate</CODE>)
<LI>handle key-down events (<CODE>TEKey</CODE>)<P>
</UL>
<A NAME=HEADING51-7></A>
<H3><A NAME=MARKER-2-196></A>Handling a Null Event</H3>
 Your pro<A NAME=MARKER-2-304></A>gram <A NAME=MARKER-9-42></A>needs to call <CODE>TEIdle<A NAME=MARKER-2-82></A></CODE> whenever it receives a null event. If there is more than one edit record associated with an active window, make sure you pass <CODE>TEIdle</CODE> the handle to the currently active edit record. (See <A HREF=#MARKER-9-206>"Activating an Edit Record"</A> in the following section for more information.)<P>
 If you have turned on text buffering through the <A NAME=MARKER-2-6></A><CODE>TEFeatureFlag</CODE> function, you should call <CODE>TEIdle</CODE> before any pause of more than a few ticks--for example, before <CODE>WaitNextEvent</CODE>. A possibility of a long delay before characters appear on the screen exists--especially in non-Roman systems. Blinking the caret alerts the user to this delay.<P>
 To blink the <A NAME=MARKER-2-131></A>caret at a constant frequency, you should call <CODE>TEIdle</CODE> at least once through your main event loop--otherwise, the caret blinks irregularly. No matter how often you call <CODE>TEIdle</CODE>, the time between blinks is never to be less than the minimum interval.<P>
 <A HREF=#MARKER-9-202>Listing 2-4</A> shows a sample application-defined procedure, <CODE>MyDoIdle</CODE>, that calls <CODE>TEIdle</CODE> to handle a null event.<P>
<B>Listing 2-4  <A NAME=MARKER-9-202></A>An idle-processing procedure</B><P>
<PRE>
PROCEDURE MyDoIdle(myWindow: WindowPtr);
VAR
   myData:     MyDocRecHnd;   {handle to a document record}
   myTERec:    TEHandle;      {handle to TextEdit record}
BEGIN
   myData   := MyDocRecHnd(GetWRefCon(myWindow));
   IF myData &lt;&gt; NIL THEN
      BEGIN
         myTERec  := myData^^.editRec;
         IF myTERec &lt;&gt; NIL THEN
            TEIdle(myTERec);
      END;
END;
</PRE>
<DL>
<DT><B>Note</B>
<DD>The value stored in the low-memory global <CODE>CaretTime</CODE> determines the blinking time for the caret. (The user can also set the minimum interval through the General Controls control panel.) You can use the Event Manager's <CODE>GetCaretTime</CODE> function to retrieve this value. For more information, see the chapter "The Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.<EM></EM><A NAME=MARKER-2-322></A><A NAME=MARKER-2-306></A><A NAME=MARKER-2-305></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING51-15></A>
<H3><A NAME=MARKER-9-206></A>Activating an Edit Record</H3>
 When a window becomes active or inactive, the Window Manager updates the frames of the windows on the screen, and then informs the Event Manager that an activate event has occurred. The next time <CODE>WaitNextEvent</CODE> <A NAME=MARKER-2-19></A>is called from your main event loop, the Event Manager notifies your application that an activate event has occurred. (An activate event can have a flag set indicating that a window is to be deactivated.) When your application receives this notification, it needs to call <A NAME=MARKER-2-88></A><CODE>TEActivate</CODE> for an activate event and <A NAME=MARKER-2-89></A><CODE>TEDeactivate</CODE> for a deactivate event. When you call <CODE>TEActivate</CODE>, you pass it the handle to the edit record to be activated; when you call <CODE>TEDeactivate</CODE>, you pass it the handle to the currently active edit record.<P>
 An application can have more than one edit record associated with it. The active edit record is the one where the next editing operation is to take place. The <CODE>TEActivate</CODE> procedure identifies an edit record as the active one by either highlighting the sel<A NAME=MARKER-2-2></A>ection range or displaying a caret at the insertion point. The <CODE>TEDeactivate</CODE> procedure changes an edit record's status from active to inactive and removes the highlighting or the caret. If outline highlighting is on, <CODE>TEDeactivate</CODE> frames the selection range or displays a dimmed caret.<P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>TEActivate</CODE> procedure does not set the selection range; it uses the current values in the <CODE>selStart</CODE> and <CODE>selEnd</CODE> fields of the edit record to highlight the specified text or display a caret at the insertion point. The <CODE>TEDeactivate</CODE> procedure does not affect the current settings of these fields.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Before you can activate an edit record, you need to deactivate the currently active edit record, if there is one. If your application has a routine which it calls to activate and deactivate its own windows, you can include processing in that routine to make an edit record the active one or make the currently active record inactive. Because deactivate events happen before activate events, these events occur in the proper order when the user switches from one window to another.<P>
 If there is more than one edit record associated with a window, you'll probably want to call <A NAME=MARKER-2-606></A><CODE>TEDeactivate</CODE> whenever the mouse button is clicked in an edit record other than the active one. In this case, each <CODE>TEDeactivate</CODE> call not associated with a window deactivate event would be coupled with a call to <CODE>TEActivate</CODE>.<P>
 You can modify the text of an edit record associated with a background window; however, to do so, you need to call <CODE>TEActivate</CODE> for that edit record before you call any other TextEdit routines.<P>
<DL>
<DT><B>Note</B>
<DD>When you use <CODE>TEClick</CODE> <A NAME=MARKER-2-333></A>and <CODE>TESetSelect</CODE> to set the selection range or insertion point, the selection range is not highlighted nor is a blinking caret displayed at the insertion point until the edit record is activated through <CODE>TEActivate</CODE>. However, if you had already turned on outline highlighting (through the <CODE>TEFeatureFlag</CODE> function), the text of the selection range is framed or a gray, unblinking caret is displayed at the insertion point.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING51-23></A>
<H3>Handling Mouse-Down Events</H3>
 When your <A NAME=MARKER-2-463></A>application receives notification of a mouse-down event that it determines TextEdit should handle, it needs to pass the click <A NAME=MARKER-2-127></A>on to the <CODE>TEClick</CODE> procedure. Before calling <CODE>TEClick</CODE>, your application needs to perform the following steps:<P>
<OL>
<LI>Convert the mouse location that is passed in the event record from global to local coordinates, so that it can pass those local coordinates to <CODE>TEClick</CODE>. To perform the conversion, you can use the <CODE>GlobalToLocal</CODE> QuickDraw procedure. (For more information, see <I><A HREF="../QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging</A></I>.)
<LI>Determine if the Shift key was held down at the time of the click to extend the selection. The behavior of <CODE>TEClick</CODE> depends on the user's actions.<P>
<UL>
<LI>If the Shift key was down, <CODE>TEClick</CODE> extends the current selection range.
<LI>If the Shift key was not held down, <CODE>TEClick</CODE> removes highlighting of the current selection range and positions the insertion point as close as possible to the location where the mouse click occurred.
<LI>When the mouse is moved or dragged, <CODE>TEClick</CODE> expands or shortens the selection range a character at a time. The <CODE>TEClick</CODE> procedure keeps control until the user releases the mouse button.
<LI>If the mouse button is clicked twice (a double-click), <CODE>TEClick</CODE> extends the selection to include the entire word where the cursor is positioned.<P>
</UL>
</OL>
<DL>
<DT><B>Note</B>
<DD>As long as the mouse button is held down, <CODE>TEClick</CODE> repeatedly calls the click loop routine pointed to from the <CODE>clikLoop</CODE> field of the edit record.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-216>Listing 2-5</A> shows an application-defined procedure, <CODE>MyDoContentClick</CODE>, that calls <CODE>TEClick</CODE>, passing it a mouse-down event.<P>
<B>Listing 2-5  <A NAME=MARKER-9-216></A>Passing a mouse-down event to TextEdit</B><P>
<PRE>
PROCEDURE MyDoContentClick (myWindow: WindowPtr; event: EventRecord);
VAR
   myData:  MyDocRecHnd;      {handle to a document record}
   myTERec: TEHandle;         {handle to TextEdit record}
   mouse:   Point;
BEGIN
   myData   := MyDocRecHnd(GetWrefCon(myWindow));  {get window's data record}
   IF myData = NIL THEN
      exit(MyDoContentClick);
   myTERec  := myData^^.editRec;                   {get TERec}
   IF myTERec = NIL THEN
      exit(MyDoContentClick);
   SetPort(myWindow);
   mouse := event.where;                     {get the click position}
   GlobalToLocal(mouse);                     {convert to local coordinates}
   IF PtInRect(mouse, myTERec^^.viewRect) THEN 
      BEGIN
         shiftDown := BAnd (event.modifiers, shiftKey) &lt;&gt; 0; 
                           {extend if Shift is down}
         TEClick(mouse, shiftDown, myTERec);
      END;
END; 
</PRE>
 When <CODE>TEClick</CODE> is called, the <CODE>clickTime</CODE> field of the edit record contains the time when <CODE>TEClick</CODE> was last called. When <CODE>TEClick</CODE> returns, it sets the <CODE>clickTime</CODE> field, adjusting the current tick count. The default <A NAME=MARKER-2-346></A>click loop procedure uses this value.<P>
<A NAME=HEADING51-36></A>
<H3>Responding to an Update Event</H3>
 After changing any fields of the edit record that affect the appearance of the text or after any editing or scrolling operation that alters the onscreen appearance of the text, you need to call <CODE>TEUpdate</CODE>.<P>
 Your application needs to call <CODE>TEUpdate</CODE> every time the Event Manager function <CODE>WaitNextEvent</CODE> reports an update event for a text editing window--after you call the Window Manager procedure <CODE>BeginUpdate</CODE>, and before you call the <CODE>EndUpdate</CODE> procedure. You call the following routines when an update event occurs:<P>
<PRE>
BeginUpdate(myWindow); 
EraseRect(myWindow^.portRect); 
TEUpdate(myWindow^.portRect, hTE); 
EndUpdate(myWindow); 
</PRE>
 If you don't include the <CODE>EraseRect</CODE> procedure, the caret may sometimes remain visible when the window is deactivated. For more information about responding to events, see the chapter "Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>. For more informa<A NAME=MARKER-2-345></A>tion about the Window Manager, see the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.<P>
<A NAME=HEADING51-41></A>
<H3>Accepting Text Input Through <A NAME=MARKER-9-219></A>Key-Down Events</H3>
 When the user enters text through the keyboard, your application needs to call the <A NAME=MARKER-2-253></A><CODE>TEKey</CODE> procedure to accept the keyboard input a byte at a time or to delete a character when the user backspaces over it. Call <CODE>TEKey</CODE> every time the Event Manager function <CODE>WaitNextEvent</CODE> <A NAME=MARKER-2-209></A>reports a key-down event that your application determines TextEdit should handle.<P>
 Because <CODE>TEKey</CODE> accepts every character it is passed, your application needs to first filter out Command-key equivalents, special keys, and nonprinting characters as appropriate, such as Enter or Tab, and only pass <CODE>TEKey</CODE> a text, a Return key character, an arrow key character, or a backspace key character.<P>
<DL>
<DT><B>Note</B>
<DD>If you want to display the text as multiple paragraphs, don't filter out Return key characters.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-222>Listing 2-6</A> shows the <CODE>MyHandleKeyDown</CODE> procedure which calls <CODE>TEKey</CODE> to accept text a character at a time. First <CODE>MyHandleKeyDown</CODE> filters out special characters. For example, it treats the Tab key as a special character, and calls an application-defined routine, <CODE>MyDoTab</CODE>, to handle this character appropriately for the document. Then it checks to make sure that inserting the character won't exceed the maximum text length allowed. It does not count the Delete or arrow keys because they are not text characters.<P>
 If the maximum text length is not exceeded, the code passes the character to <CODE>TEKey</CODE>. Otherwise, it calls an application-defined routine, <CODE>MyAlertUser</CODE>, to notify the user that the character is not inserted, and that inserting it would exceed the edit record text limitation. In this example listing, the maximum text length is set to the highest possible value; you can specify a lower limit.<P>
<B>Listing 2-6  <A NAME=MARKER-9-222></A>Inserting text in a document</B><P>
<PRE>
PROCEDURE MyHandleKeyDown(myWindow: WindowPtr; event: EventRecord);
CONST
   kMaxTELength = 32767;
   kTab = $09;
   kDel = $08;
   kRightArrow = $1D;
   kLeftArrow = $1C;
   kDownArrow = $1F;
   kUpArrow = $1E;
VAR
   myData:     MyDocRecHnd;      {handle to a document record}
   myTERec:    TEHandle;         {handle to TextEdit record}
   key:        CHAR;
BEGIN
   myData   := MyDocRecHnd(GetWRefCon(myWindow));  {get window's data record}
   IF myData = NIL THEN
      exit(MyDoContentClick);
   myTERec  := myData^^.editRec;                   {get TERec}
   IF myTERec = NIL THEN
      exit(MyDoContentClick);
   key := CHR(BAnd(event.message, charCodeMask));
   IF key = char(kTab) THEN {handle special characters}
      MyDoTab(event)
   ELSE            
      BEGIN
         IF (key = CHR(kDel)) | (key = CHR(kRightArrow)) | 
         (key = CHR(kLeftArrow)) | (key = CHR(kUpArrow)) | 
         (key = CHR(kDownArrow)) | {don't count deletes or arrow keys}
         (LongInt(myTERec^^.teLength - MyGetTESelLength(myTERec) + 1 &lt;
          kMaxTELength)
         THEN
            BEGIN
               TEKey(key, myTERec); {insert character in document}
               MyAdjustScrollbars(window, FALSE);
            END
         ELSE
            MyAlertUser(eExceedChar); 
      END; 
   END;
</PRE>
 Before testing to ensure that the input character does not exceed the edit record's text limitation, the code subtracts the length of the selection range, which the inserted character is to replace, from the current length of the text. To get the length of the selection range, the code calls an application-defined function, <CODE>MyGetTESelLength</CODE>. <A HREF=#MARKER-9-223>Listing 2-7</A> shows this function. Several other sample application-defined routines in this chapter also call this function.<P>
<B>Listing 2-7  <A NAME=MARKER-9-223></A>Getting the selection range length</B><P>
<PRE>
FUNCTION MyGetTESelLength (myTERec: TEHandle): Integer; 
   Begin
      MyGetTESelLength := myTERec^^.selEnd - myTERec^^.selStart;
   END;
</PRE>
 If the selection range is an insertion point and the key is not an arrow key character or a Backspace key character, <CODE>TEKey</CODE> inserts the character before the insertion point. When the character direction is right-to-left, the character is inserted to the right of the insertion point. When the character direction is left-to-right, the character is inserted to the left of the insertion point.<P>
 When you call <CODE>TEKey</CODE> and the keyboard script is different from the <A NAME=MARKER-2-314></A>font script, TextEdit changes the font script to correspond to the keyboard script. If the font at the insertion point is the same as the keyboard script, then this font is used. If a font was written to the TextEdit style scrap record (in the null scrap) and never used and that font script coincides with the keyboard script, then it is used. Otherwise, TextEdit searches through the fonts in the style table until it locates a font that corresponds to the keyboard. If one does not exist, then it uses the application font.<P>
 When the user <A NAME=MARKER-2-19></A>backspaces over characters of a multistyled edit record, <CODE>TEKey</CODE> deletes the characters but it saves the character attributes associated with the last character deleted in order to apply it to any new characters that the user might enter; the character attributes are saved in the null scrap's style scrap record. As soon as the user clicks in another area of the tex<A NAME=MARKER-2-433></A>t, <CODE>TEKey</CODE> clears the attributes from the null scrap.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-50.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-52.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
