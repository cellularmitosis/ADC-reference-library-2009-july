<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of the PPC Toolbox(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING468></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-467.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-469.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-423.html"><B>Chapter 11 - Program-to-Program Communications Toolbox</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING468-0></A>
<H1>Summary of the PPC Toolbox</H1>
<A NAME=HEADING468-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING468-2></A>
<H3>Constants</H3>
<PRE>
CONST 
   {gestalt selectors}
   gestaltPPCToolboxAttr      = 'ppc ';   {PPC Toolbox attributes}
   gestaltPPCToolboxPresent   = $0000;    {PPC Toolbox is present}
   gestaltPPCSupportsRealTime = $1000;    {real time only in system }
                                          { software version 7.0}
   gestaltPPCSupportsOutGoing = $0002;    {support of outgoing }
                                          { sessions across a network}
   gestaltPPCSupportsIncoming = $0001;    {user enabled program }
                                          { linking in Sharing Setup }
                                          { control panel}
   {service type)
   ppcServiceRealTime         = 1;        {real time only in System 7}
   {look-up type}
   ppcNoLocation              = 0;        {there is no PPCLocName}
   ppcNBPLocation             = 1;        {use AppleTalk NBP}
   ppcNBPTypeLocation         = 2;        {use just the NBP type, fill }
                                          { in the rest with default}
   {port type}
   ppcByCreatorAndType        = 1;        {port type is specified as }
                                          { standard creator and type}
   ppcByString                = 2;        {port type is in Pascal } 
                                          { string format}
   {session request type returned in the PPCInform function}
   ppcLocalOrigin             = 1;        {session initiated on }
                                          { local computer} 
   ppcRemoteOrigin            = 2;        {session initiated on }
                                          { remote computer}
</PRE>
<A NAME=HEADING468-4></A>
<H3>Data Types</H3>
<PRE>
TYPE 
   PPCServiceType          = SignedByte;     {service type}
   PPCLocationKind         = Integer;        {look-up type}
   PPCPortKinds            = Integer;        {port type}
   PPCSessionOrigin        = SignedByte;     {local or remote}
   PPCPortRefNum           = Integer;        {port reference number}
   PPCSessRefNum           = LongInt;        {session reference number}
   LocationNamePtr = ^LocationNameRec;
   LocationNameRec = 
   RECORD
      locationKindSelector: PPCLocationKind; {which variant}
      CASE PPCLocationKind OF                {ppcNoLocation: storage not }
                                             { used by this value}
         ppcNBPLocation:                     {NBP name entity}
                            (nbpEntity: EntityName);
         ppcNBPTypeLocation:(nbpType: Str32);{just the NBP type string }
                                             { for the PPCOpen function}
   END;
   PortInfoPtr = ^PortInfoRec;
   PortInfoRec =
   RECORD
      filler1:             SignedByte;       {space holder}
      authRequired:        Boolean;          {authentication required}
      name:                PPCPortRec;       {port name}
   END;

   PPCPortPtr = ^PPCPortRec;
   PPCPortRec = 
   RECORD
      nameScript:          ScriptCode;       {script identifier}
      name:                Str32;            {port name shown in program }
                                             { linking dialog box}
         portKindSelector: PPCPortKinds;     {general category of }
                                             { application}
         CASE PPCPortKinds OF
            ppcByString:   (portTypeStr: Str32);{32 characters}
            ppcByCreatorAndType:             {4-character creator and type}
                           (portCreator: OSType; portType: OSType);
   END;


      PPCParamBlockPtr = ^PPCParamBlockRec;
      PPCParamBlockRec = 
      RECORD
         CASE Integer OF
         0: (openParam:       PPCOpenPBRec);       {PPCOPen params}
         1: (informParam:     PPCInformPBRec);     {PPCInform params}
         2: (startParam:      PPCStartPBRec);      {PPCStart params}
         3: (acceptParam:     PPCAcceptPBRec);     {PPCAccept params}
         4: (rejectParam:     PPCRejectPBRec);     {PPCReject params}
         5: (writeParam:      PPCWritePBRec);      {PPCWrite params}
         6: (readParam:       PPCReadPBRec);       {PPCRead params}
         7: (endParam:        PPCEndPBRec);        {PPCEnd params}
         8: (closeParam:      PPCClosePBRec);      {PPCClose params}
         9: (listPortsParam:  IPCListPortsPBRec);  {IPCListPorts params}
      END;

      PortInfoArrayPtr = ^PortInfoArray;
      PortInfoArray    = ARRAY[0..0] OF PortInfoRec;

      PPCOpenPBPtr = ^PPCOpenPBRec;
      PPCOpenPBRec = 
      RECORD
         qLink:         Ptr;                 {private}
         csCode:        Integer;             {private}
         intUse:        Integer;             {private}
         intUsePtr:     Ptr;                 {private}
         ioCompletion:  PPCCompProcPtr;      {address of a }
                                             { completion routine}
         ioResult:      OSErr;               {completion of operation}
         reserved:      ARRAY[1..5] OF LongInt;
                                             {private}
         portRefNum:       PPCPortRefNum;    {PPC port identifier}
         filler1:          LongInt;          {space holder}
         serviceType:      PPCServiceType;   {real time only}
         resFlag:          SignedByte;       {reserved field}
         portName:         PPCPortPtr;       {name of port to be opened}
         locationName:     LocationNamePtr;  {location of port to be }
                                             { opened}
         networkVisible:   Boolean;          {port is visible for }
                                             { browsing}
         nbpRegistered:    Boolean;          {location name registered }
                                             { on network}
      END;
      PPCInformPBPtr = ^PPCInformPBRec;
      PPCInformPBRec = 
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion }
                                             { routine}
         ioResult:         OSErr;            {completion of operation} 
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         portRefNum:       PPCPortRefNum;    {port identifier}
         sessRefNum:       PPCSessRefNum;    {session identifier}
         serviceType:      PPCServiceType;   {real time only}
         autoAccept:       Boolean;          {automatic session }
                                             { acceptance}
         portName:         PPCPortPtr;       {name of port that }
                                             { initiated a session}
         locationName:     LocationNamePtr;  {location of port that }
                                             { initiated a session}
         userName:         StringPtr;        {name of user that } 
                                             { initiated a session}
         userData:         LongInt;          {application-defined}
         requestType:      PPCSessionOrigin; {local or remote}
      END;

      PPCStartPBPtr = ^PPCStartPBRec;
      PPCStartPBRec = 
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion }
                                             { routine}
         ioResult:         OSErr;            {completion of operation}
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         portRefNum:       PPCPortRefNum;    {identifier for requested }
                                             { port}
         sessRefNum:       PPCSessRefNum;    {session identifier}
         serviceType:      PPCServiceType;   {real time only}
         resFlag:          SignedByte;       {reserved field}
         portName:         PPCPortPtr;       {name of port to be opened}
         locationName:     LocationNamePtr;  {location of port to be }
                                             { opened}
         rejectInfo:       LongInt;          {rejection of session}
         userData:         LongInt;          {application-specific}
         userRefNum:       LongInt;          {specifies an authenticated }
                                             { user}
      END;

      PPCAcceptPBPtr = ^PPCAcceptPBRec;
      PPCAcceptPBRec = 
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion }
                                             { routine}
         ioResult:         OSErr;            {completion of operation}
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         filler1:          Integer;          {space holder}
         sessRefNum:       PPCSessRefNum;    {session identifier}
      END;

      PPCRejectPBPtr = ^PPCRejectPBRec;
      PPCRejectPBRec = 
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion }
                                             { routine}
         ioResult:         OSErr;            {completion of operation}
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         filler1:          Integer;          {space holder}
         sessRefNum:       PPCSessRefNum;    {session identifier}
         filler2:          Integer;          {space holder}
         filler3:          LongInt;          {space holder}
         filler4:          LongInt;          {space holder}
         rejectInfo:       LongInt;          {rejection of session}
      END;

      PPCWritePBPtr = ^PPCWritePBRec;
      PPCWritePBRec = 
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion }
                                             { routine}
         ioResult:         OSErr;            {completion of operation}
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         filler1:          Integer;          {space holder}
         sessRefNum:       PPCSessRefNum;    {session identifier}
         bufferLength:     Size;             {length of buffer to be }
                                             { written}
         actualLength:     Size;             {actual size of data written}
         bufferPtr:        Ptr;              {location of buffer to be }
                                             { written}
         more:             Boolean;          {additional data to be }
                                             { written}
         filler2:          SignedByte;       {space holder}
         userData:         LongInt;          {application-specific}
         blockCreator:     OSType;           {creator of block to be }
                                             { written}
         blockType:        OSType;           {type of block to be written}
      END;

      PPCReadPBPtr = ^PPCReadPBRec;
      PPCReadPBRec = 
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion } 
                                             { routine}
         ioResult:         OSErr;            {completion of operation}
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         filler1:          Integer;          {space holder}
         sessRefNum:       PPCSessRefNum;    {session identifier}
         bufferLength:     Size;             {length of buffer to be read}
         actualLength:     Size;             {actual size of the data }
                                             { read}
         bufferPtr:        Ptr;              {location of buffer to be }
                                             { read}
         more:             Boolean;          {additional data to be read}
         filler2:          SignedByte;       {space holder}
         userData:         LongInt;          {application-specific}
         blockCreator:     OSType;           {creator of block to be read}
         blockType:        OSType;           {type of block to be read}
      END;
      
      PPCEndPBPtr = ^PPCEndPBRec;
      PPCEndPBRec = 
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion }
                                             { routine}
         ioResult:         OSErr;            {completion of operation}
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         filler1:          Integer;          {space holder}
         sessRefNum:       PPCSessRefNum;    {identifier of session to }
                                             { be terminated}
      END;
      
      PPCClosePBPtr = ^PPCClosePBRec;
      PPCClosePBRec = 
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion } 
                                             { routine}
         ioResult:         OSErr;            {completion of operation}
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         portRefNum:       PPCPortRefNum;    {identifier of port to } 
                                             { be closed}
      END;
      
      IPCListPortsPBPtr = ^IPCListPortsPBRec;
      IPCListPortsPBRec =
      RECORD
         qLink:            Ptr;              {private}
         csCode:           Integer;          {private}
         intUse:           Integer;          {private}
         intUsePtr:        Ptr;              {private}
         ioCompletion:     PPCCompProcPtr;   {address of a completion }
                                             { routine}
         ioResult:         OSErr;            {completion of operation}
         reserved:         ARRAY[1..5] OF LongInt;
                                             {private}
         filler1:          Integer;          {space holder}
         startIndex:       Integer;          {index to the port entry } 
                                             { list}
         requestCount:     Integer;          {number of entries to }
                                             { be returned}
         actualCount:      Integer;          {actual number of port names}
         portName:         PPCPortPtr;       {list of port names} 
         locationName:     LocationNamePtr;  {location of port names}
         bufferPtr:        PortInfoArrayPtr; {pointer to a buffer}
      END;
</PRE>
<A NAME=HEADING468-7></A>
<H3>PPC Toolbox Routines</H3>
<A NAME=HEADING468-8></A>
<H4>Initializing the PPC Toolbox</H4>
<PRE>
FUNCTION PPCInit: OSErr;
</PRE>
<A NAME=HEADING468-10></A>
<H4>Using the Program Linking Dialog Box</H4>
<PRE>
FUNCTION PPCBrowser(prompt: Str255; applListLabel: Str255; 
defaultSpecified: Boolean; 
VAR theLocation: LocationNameRec; 
VAR thePortInfo: PortInfoRec; 
portFilter: PPCFilterProcPtr; 
theLocNBPType: Str32): OSErr;
</PRE>
<A NAME=HEADING468-12></A>
<H4>Obtaining a List of Ports</H4>
<PRE>
FUNCTION IPCListPorts(pb: IPCListPortsPBPtr; async: Boolean): OSErr; 
</PRE>
<A NAME=HEADING468-14></A>
<H4>Opening and Closing a Port</H4>
<PRE>
FUNCTION PPCOpen(pb: PPCOpenPBPtr; async: Boolean): OSErr;
FUNCTION PPCClose(pb: PPCClosePBPtr; async: Boolean): OSErr; 
</PRE>
<A NAME=HEADING468-17></A>
<H4>Starting and Ending a Session</H4>
<PRE>
FUNCTION PPCStart(pb: PPCStartPBPtr; async: Boolean): OSErr;
FUNCTION StartSecureSession(pb: PPCStartPBPtr; VAR userName: Str32; 
useDefault: Boolean; allowGuest: Boolean; 
VAR guestSelected: Boolean; prompt: Str255)
: OSErr;
FUNCTION PPCEnd(pb: PPCEndPBPtr; async: Boolean): OSErr; 
</PRE>
<A NAME=HEADING468-21></A>
<H4>Receiving, Accepting, and Rejecting a Session</H4>
<PRE>
FUNCTION PPCInform(pb: PPCInformPBPtr; async: Boolean): OSErr; 
FUNCTION PPCAccept(pb: PPCAcceptPBPtr; async: Boolean): OSErr;
FUNCTION PPCReject(pb: PPCRejectPBPtr; async: Boolean): OSErr;
</PRE>
<A NAME=HEADING468-25></A>
<H4>Reading and Writing Data</H4>
<PRE>
FUNCTION PPCRead(pb: PPCReadPBPtr; async: Boolean): OSErr;
FUNCTION PPCWrite(pb: PPCWritePBPtr; async: Boolean): OSErr;
</PRE>
<A NAME=HEADING468-28></A>
<H4>Locating a Default User and Invalidating a User</H4>
<PRE>
FUNCTION GetDefaultUser(VAR userRef: LongInt; VAR userName: Str32) 
: OSErr; 
FUNCTION DeleteUserIdentity(userRef: LongInt): OSErr; 
</PRE>
<A NAME=HEADING468-31></A>
<H3>Application-Defined Routines</H3>
<PRE>
PROCEDURE MyCompletionRoutine
(pb: PPCParamBlockPtr);
FUNCTION MyPortFilter(locationName: LocationNameRec; 
thePortInfo: PortInfoRec): Boolean;
</PRE>
<A NAME=HEADING468-35></A>
<H2>C Summary</H2>
<A NAME=HEADING468-36></A>
<H3>Constants</H3>
<PRE>
CONST 
enum {
   /*gestalt selectors*/
   #define gestaltPPCToolboxAttr 'ppc '   /*PPC Toolbox attributes*/
   gestaltPPCToolboxPresent   = $0000,    /*PPC Toolbox is present*/
   gestaltPPCSupportsRealTime = $1000,    /*real time only in system */
                                          /* software version 7.0*/
   gestaltPPCSupportsOutGoing = $0002,    /*support of outgoing */
                                          /* sessions across a network*/
   gestaltPPCSupportsIncoming = $0001     /*user enabled program */
                                          /* linking in Sharing Setup */
                                          /* control panel*/
};
enum {
   /*service type*/
   ppcServiceRealTime         = 1         /*real time only in System 7*/
};
enum {
   /*look-up type*/
   ppcNoLocation              = 0,        /*there is no PPCLocName*/
   ppcNBPLocation             = 1,        /*use AppleTalk NBP*/
   ppcNBPTypeLocation         = 2         /*use just the NBP type, fill */
                                          /* in the rest with default*/
};
enum {
   /*port type*/
   ppcByCreatorAndType        = 1,        /*port type is specified as */
                                          /* standard Mac creator and type*/
   ppcByString                = 2         /*port type is in Pascal */ 
                                          /* string format*/
};
enum {
   /*session request type returned in the PPCInform function*/
   ppcLocalOrigin             = 1,        /*session initiated on */
                                          /* local computer*/ 
   ppcRemoteOrigin            = 2         /*session initiated on */
                                          /* remote computer*/
};
</PRE>
<A NAME=HEADING468-38></A>
<H3>Data Types</H3>
<PRE>
typedef unsigned char PPCServiceType;        /*service type*/
typedef short PPCLocationKind;               /*look-up type*/
typedef short PPCPortKinds;                  /*port type*/
typedef unsigned char PPCSessionOrigin;      /*local or remote*/
typedef short PPCPortRefNum;                 /*port reference number*/
typedef long PPCSessRefNum;                  /*session reference number*/

struct PPCPortRec {
   ScriptCode nameScript;                    /*script identifier*/
   Str32 name;                               /*port name shown in program */
                                             /* linking dialog box*/
   PPCPortKinds portKindSelector;            /*general category of */
                                             /* application*/
   union
      Str32 portTypeStr;                     /*32 characters*/
      struct
         OSType creator;                     /*4-character creator and */
         OSType type;                        /* type*/
         } port;
      } u;
};
typedef struct PPCPortRec PPCPortRec;
typedef PPCPortRec *PPCPortPtr;

struct LocationNameRec {
   PPCLocationKind locationKindSelector;     /*which variant*/
   union {                                
      EntityName  nbpEntity;                 /*NBP name entity*/
      Str32       nbpType;                   /*just the NBP type string */
                                             /* for the PPCOpen function*/
      } u;
};

typedef struct LocationNameRec LocationNameRec;
typedef LocationNameRec *LocationNamePtr;

struct PortInfoRec {
   unsigned char  filler1;                   /*space holder*/
   Boolean        authRequired;              /*authentication required*/
   PPCPortRec     name;                      /*port name*/
};
typedef struct PortInfoRec PortInfoRec;
typedef PortInfoRec *PortInfoPtr;

typedef PortInfoRec *PortInfoArrayPtr;
typedef pascal Boolean (*PPCFilterProcPtr) (LocationNamePtr, PortInfoPtr);
/*procedures you need to write*/
/*ex: void MyCompletionRoutine(PPCParamBlkPtr pb)*/
/*ex: pascal Boolean MyPortFilter(LocationNamePtr, PortInfoPtr)*/
typedef ProcPtr PPCCompProcPtr;

#define PPCHeader \
   Ptr               qLink;                  /*private*/
   unsigned short    csCode;                 /*private*/
   unsigned short    intUse;                 /*private*/
   Ptr               intUsePtr;              /*private*/
   PPCCompProcPtr    ioCompletion;           /*address of a */
                                             /* completion routine*/
   OSErr             ioResult;               /*completion of operation*/
   unsigned long     Reserved[5];            /*private*/

struct PPCOpenPBRec {
   PPCHeader
   PPCPortRefNum  portRefNum;                /*PPC port identifier*/
   long           filler1;                   /*space holder*/
   PPCServiceType serviceType;               /*real time only*/
   unsigned char  resFlag;                   /*reserved field*/
   PPCPortPtr     portName;                  /*name of port to be opened*/
   LocationNamePtr locationName;             /*location of port to be */
                                             /* opened*/
   Boolean        networkVisible;            /*port is visible for */
                                             /* browsing*/
   Boolean        nbpRegistered;             /*location name registered */
                                             /* on network*/
};

typedef struct PPCOpenPBRec PPCOpenPBRec;
typedef PPCOpenPBRec *PPCOpenPBPtr;

struct PPCInformPBRec {
   PPCHeader
   PPCPortRefNum     portRefNum;             /*port identifier*/
   PPCSessRefNum     sessRefNum;             /*session identifier*/
   PPCServiceType    serviceType;            /*real time only*/
   Boolean           autoAccept;             /*automatic session acceptance*/
   PPCPortPtr        portName;               /*name of port that */
                                             /* initiated a session*/
   LocationNamePtr   locationName;           /*location of port that */
                                             /* initiated a session*/
   StringPtr         userName;               /*name of user that */ 
                                             /* initiated a session*/
   unsigned long     userData;               /*application-defined*/
   PPCSessionOrigin  requestType;            /*local or remote*/
};

typdef struct PPCInformPBRec PPCInformPBPtr;

struct PPCStartPBRec {
   PPCHeader
   PPCPortRefNum     portRefNum;          /*identifier for requested */
                                          /* port*/
   PPCSessRefNum     sessRefNum;          /*session identifier*/
   PPCServiceType    serviceType;         /*real time only*/
   unsigned char     resFlag;             /*reserved field*/
   PPCPortPtr        portName;            /*name of port to be opened*/
   LocationNamePtr   locationName;        /*location of port to be opened*/
   unsigned long     rejectInfo;          /*rejection of session*/
   unsigned long     userData;            /*application-specific*/
   unsigned long     userRefNum;          /*specifies an authenticated user*/
};

typedef struct PPCStartPBRec PPCStartPBRec;
typedef PPCStartPBRec *PPCStartPBPtr;

struct PPCAcceptPBRec {
      PPCHeader
      short          filler1;             /*space holder*/
      PPCSessRefNum  sessRefNum;          /*session identifier*/
};

typedef struct PPCAcceptPBRec PPCAcceptPBRec;
typedef PPCAcceptPBRec *PPCAcceptPBPtr;

struct PPCRejectPBRec {
      PPCHeader
      short          filler1;             /*space holder*/
      PPCSessRefNum  sessRefNum;          /*session identifier*/
      short          filler2;             /*space holder*/
      long           filler3;             /*space holder*/
      long           filler4;             /*space holder*/
      unsigned long  rejectInfo;          /*rejection of session*/
};

typedef struct PPCRejectPBRec PPCRejectPBRec;
typedef PPCRejectPBRec *PPCRejectPBPtr;

struct PPCWritePBRec {
   PPCHeader
   short          filler1;                /*space holder*/
   PPCSessRefNum  sessRefNum;             /*session identifier*/
   Size           bufferLength;           /*length of buffer to be written*/
   Size           actualLength;           /*actual size of data written*/
   Ptr            bufferPtr;              /*location of buffer to be */
                                          /* written*/
   Boolean        more;                   /*additional data to be written*/
   unsigned char  filler2;                /*space holder*/
   unsigned long  userData;               /*application-specific*/
   OSType         blockCreator;           /*creator of block to be written*/
   OSType         blockType;              /*type of block to be written*/
};

typedef struct PPCWritePBRec PPCWritePBRec;
typedef PPCWritePBRec *PPCWritePBPtr;

struct PPCReadPBRec {
   PPCHeader
   short          filler1;                /*space holder*/
   PPCSessRefNum  sessRefNum;             /*session identifier*/
   Size           bufferLength;           /*length of buffer to be read*/
   Size           actualLength;           /*actual size of the data read*/
   Ptr            bufferPtr;              /*location of buffer to be read*/
   Boolean        more;                   /*additional data to be read*/
   unsigned char  filler2;                /*space holder*/
   unsigned long  userData;               /*application-specific*/
   OSType         blockCreator;           /*creator of block to be read*/
   OSType         blockType;              /*type of block to be read*/
};

typedef struct PPCReadPBRec PPCReadPBRec;
typdef PPCReadPBRec *PPCReadPBPtr;
struct PPCEndPBRec {
   PPCHeader
   short          filler1;                /*space holder*/
   PPCSessRefNum  sessRefNum;             /*identifier of session to */
                                          /* be terminated*/
};

typedef struct PPCEndPBRec PPCEndPBRec;
typedef PPCEndPBRec *PPCEndPBPtr;

struct PPCClosePBRec {
   PPCHeader
   PPCPortRefNum  portRefNum;             /*identifier of port to */ 
                                          /* be closed*/
};

typedef struct PPCClosePBRec PPCClosePBRec;
typedef PPCClosePBRec *PPCClosePBPtr;

struct IPCListPortsPBRec {
   PPCHeader
   short             filler1;             /*space holder*/
   unsigned short    startIndex;          /*index to the port entry list*/ 
   unsigned short    requestCount;        /*number of entries to */
                                          /* be returned*/
   unsigned short    actualCount;         /*actual number of port names*/
   PPCPortPtr        portName;            /*list of port names*/ 
   LocationNamePtr   locationName;        /*location of port names*/
   PortInfoArrayPtr  bufferPtr;           /*pointer to a buffer*/
};
typedef struct IPCListPortsPBRec IPCListPortsPBRec;
typedef IPCListPortsPBRec *IPCListPortsPBPtr;

union PPCParamBlockRec {
   PPCOpenPBRec      openParam;           /*PPCOpen params*/
   PPCInformPBRec    informParam;         /*PPCInform params*/
   PPCStartPBRec     startParam;          /*PPCStart params*/
   PPCAcceptPBRec    acceptParam;         /*PPCAccept params*/
   PPCRejectPBRec    rejectParam;         /*PPCReject params*/
   PPCWritePBRec     writeParam;          /*PPCWrite params*/
   PPCReadPBRec      readParam;           /*PPCRead params*/
   PPCEndPBRec       endParam;            /*PPCEnd params*/
   PPCClosePBRec     closeParam;          /*PPCClose params*/
   IPCListPortsPBRec listPortsParam;      /*IPCListPorts params*/
};

typdef union PPCParamBlockRec PPCParamBlockRec;
typdef PPCParamBlockRec *PPCParamBlockPtr;
</PRE>
<A NAME=HEADING468-40></A>
<H3>PPC Toolbox Routines</H3>
<A NAME=HEADING468-41></A>
<H4>Initializing the PPC Toolbox</H4>
<PRE>
pascal OSErr PPCInit(void);
</PRE>
<A NAME=HEADING468-43></A>
<H4>Using the Program Linking Dialog Box</H4>
<PRE>
pascal OSErr PPCBrowser(ConstStr255Param prompt, 
ConstStr255Param applListLabel, 
Boolean defaultSpecified, 
LocationNameRec *theLocation, 
PortInfoRec *thePortInfo, 
PPCFilterProcPtr portFilter, 
ConstStr32Param theLocNBPType);
</PRE>
<A NAME=HEADING468-45></A>
<H4>Obtaining a List of Ports</H4>
<PRE>
pascal OSErr IPCListPorts(IPCListPortsPBPtr pb, Boolean async); 
</PRE>
<A NAME=HEADING468-47></A>
<H4>Opening and Closing a Port</H4>
<PRE>
pascal OSErr PPCOpen(PPCOpenPBPtr pb, Boolean async);
pascal OSErr PPCClose(PPCClosePBPtr pb, Boolean async); 
</PRE>
<A NAME=HEADING468-50></A>
<H4>Starting and Ending a Session</H4>
<PRE>
pascal OSErr PPCStart(PPCStartPBPtr pb, Boolean async);
pascal OSErr StartSecureSession
(PPCStartPBPtr pb, Str32 userName, 
Boolean useDefault, Boolean allowGuest, 
Boolean *guestSelected, 
ConstStr255Param prompt);
pascal OSErr PPCEnd(PPCEndPBPtr pb, Boolean async); 
</PRE>
<A NAME=HEADING468-55></A>
<H4>Receiving, Accepting, and Rejecting a Session</H4>
<PRE>
pascal OSErr PPCInform(PPCInformPBPtr pb, Boolean async); 
pascal OSErr PPCAccept(PPCAcceptPBPtr pb, Boolean async);
pascal OSErr PPCReject(PPCRejectPBPtr pb, Boolean async);
</PRE>
<A NAME=HEADING468-59></A>
<H4>Reading and Writing Data</H4>
<PRE>
pascal OSErr PPCRead(PPCReadPBPtr pb, Boolean async);
pascal OSErr PPCWrite(PPCWritePBPtr pb, Boolean async);
</PRE>
<A NAME=HEADING468-62></A>
<H4>Locating a Default User and Invalidating a User</H4>
<PRE>
pascal OSErr GetDefaultUser(unsigned long *userRef, Str32 userName); 
pascal OSErr DeleteUserIdentity
(unsigned long userRef); 
</PRE>
<A NAME=HEADING468-66></A>
<H3>Application-Defined Routines</H3>
<PRE>
void MyCompletionRoutine(PPCParamBlockPtr pb);
pascal Boolean MyPortFilter(LocationNameRec locationName, 
PortInfoRec thePortInfo);
</PRE>
<A NAME=HEADING468-69></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING468-70></A>
<H3>Trap Macros</H3>
<A NAME=HEADING468-71></A>
<H4>Trap Macros Requiring Routine Selectors</H4>
<PRE>
_Pack9
</PRE>
<TABLE BORDER="0" CELLPADDING=3><TD>Selector<TD>Routine<TR>
<TD>$0D00<TD><CODE>PPCBrowser</CODE></TABLE>

<CODE>_PPC
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$0000<TD>PPCInit<TR>
<TD>$0001<TD>PPCOpen<TR>
<TD>$0002<TD>PPCStart<TR>
<TD>$0003<TD>PPCInform<TR>
<TD>$0004<TD>PPCAccept<TR>
<TD>$0005<TD>PPCReject<TR>
<TD>$0006<TD>PPCWrite<TR>
<TD>$0007<TD>PPCRead<TR>
<TD>$0008<TD>PPCEnd<TR>
<TD>$0009<TD>PPCClose<TR>
<TD>$000A<TD>IPCListPorts<TR>
<TD>$000C<TD>DeleteUserIdentity<TR>
<TD>$000D<TD>GetDefaultUser<TR>
<TD>$000E<TD>StartSecureSession</TABLE>
</CODE>

 <P>
<A NAME=HEADING468-75></A>
<H2>Result Codes
<TABLE BORDER="0" CELLPADDING=3><TD>noErr<TD>0<TD>No error<TR>
<TD>paramErr<TD>-50<TD>Illegal parameter<TR>
<TD>memFullErr<TD>-108<TD>Not enough memory to load <CODE>PPCBrowser</CODE> package<TR>
<TD>userCanceledErr<TD>-128<TD>User decided not to conduct a session<TR>
<TD>notInitErr<TD>-900<TD>PPC Toolbox has not been initialized yet<TR>
<TD>nameTypeErr<TD>-902<TD>Invalid or inappropriate <CODE>locationKindSelector</CODE> in location name<TR>
<TD>noPortErr<TD>-903<TD>Unable to open port or bad port reference number<TR>
<TD>noGlobalsErr<TD>-904<TD>System unable to allocate memory, critical error<TR>
<TD>localOnlyErr<TD>-905<TD>Network activity is currently disabled<TR>
<TD>destPortErr<TD>-906<TD>Port does not exist at destination<TR>
<TD>sessTableErr<TD>-907<TD>PPC Toolbox is unable to create a session<TR>
<TD>noSessionErr<TD>-908<TD>Invalid session reference number<TR>
<TD>badReqErr<TD>-909<TD>Bad parameter or invalid state for this operation<TR>
<TD>portNameExistsErr<TD>-910<TD>Another port is already open with this name<TR>
<TD>noUserNameErr<TD>-911<TD>User name unknown on destination machine<TR>
<TD>userRejectErr<TD>-912<TD>Destination rejected the session request<TR>
<TD>noResponseErr<TD>-915<TD>Unable to contact application<TR>
<TD>portClosedErr<TD>-916<TD>The port was closed<TR>
<TD>sessClosedErr<TD>-917<TD>The session has closed<TR>
<TD>badPortNameErr<TD>-919<TD>PPC port record is invalid<TR>
<TD>noDefaultUserErr<TD>-922<TD>User has not specified owner name in Sharing Setup control panel<TR>
<TD>notLoggedInErr<TD>-923<TD>Default user reference number does not yet exist<TR>
<TD>noUserRefErr<TD>-924<TD>Unable to create a new user reference number<TR>
<TD>networkErr<TD>-925<TD>An error has occurred in the network<TR>
<TD>noInformErr<TD>-926<TD><CODE>PPCStart</CODE> failed because target application did not have an inform pending<TR>
<TD>authFailErr<TD>-927<TD>User's password is wrong<TR>
<TD>noUserRecErr<TD>-928<TD>Invalid user reference number<TR>
<TD>badServiceMethodErr<TD>-930<TD>Service method is other than <CODE>ppcServiceRealTime</CODE><TR>
<TD>badLocNameErr<TD>-931<TD>Location name is invalid<TR>
<TD>guestNotAllowedErr<TD>-932<TD>Destination port requires authentication<TR>
<TD>nbpDuplicate<TD>-1027<TD>Location name represents a duplicate on this computer<A NAME=MARKER-2-2></A></TABLE>
</H2>
 <P>
</BLOCKQUOTE><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-467.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-469.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
