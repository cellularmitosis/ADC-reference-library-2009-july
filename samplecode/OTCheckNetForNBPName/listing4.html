<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OTCheckNetForNBPName - /OTCheckNetForNBPName.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; <A HREF="javascript:location.replace('index.html');">OTCheckNetForNBPName</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/index.html" target="_blank">Reference Library > Networking</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OTCheckNetForNBPName</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/OTCheckNetForNBPName.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Carbon.r</option>
<option value="listing2.html">/EnableSelfSendSample.c</option>
<option value="listing3.html">/main.r</option>
<option value="listing4.html">/OTCheckNetForNBPName.c</option>
<option value="listing5.html">/OTCheckNetForNBPName.h</option></select>
				</p>
				</form>
				<p><strong><a href="OTCheckNetForNBPName.zip">Download Sample</a></strong> (&#147;OTCheckNetForNBPName.zip&#148;, 88.7K)<BR>
<strong><a href="OTCheckNetForNBPName.dmg">Download Sample</a></strong> (&#147;OTCheckNetForNBPName.dmg&#148;, 152.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* *   *  File: OTCheckNetForNBPName.c *      Sample code to demonstrate how to check for an AppleTalk NBPName on a *      network. The sample works by first determining the number of zones that *      will be searched. *///#define DEBUG  1//#define TARGET_API_MAC_CARBON  1#include &lt;Types.h&gt;#include &lt;Events.h&gt;#include &lt;Windows.h&gt;#include &lt;Memory.h&gt;#include &lt;Resources.h&gt;#include &lt;Errors.h&gt;#include &lt;OSUtils.h&gt;#include &lt;String.h&gt;#include &lt;Gestalt.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;OpenTransport.h&gt;#include &lt;OpenTptAppleTalk.h&gt;#include &quot;OTCheckNetForNBPName.h&quot;// static globals herestatic ATSvcRef      gOTSvcRef  = nil;static MapperRef    gOTMapper  = nil;static UInt32      gNumZones   = 0;static UInt32      gMatchesFound = 0;static UInt32      gNextLookup  = 0;static UInt32      gNumLookupsCompleted = 0;static OTNameID      gMyNameID  = 0;static TLookupRequest  *gLookupReqPtr = nil;static MyLookupReply  *gLookupReplyPtr = nil;static ZoneBufPtr    gZoneBufPtr  = nil;static NBPEntity    *gNBPEntityPtr;static Boolean      gDone = false;static Boolean      gTriggerAction = false;static Boolean      gNameRegistered = false;static OTNotifyUPP    gNotifier = nil;static UInt8      gNameToSearchFor[33] = &quot;MyName&quot;;static UInt8      gTypeToSearchFor[33] = &quot;MyEntity&quot;;static UInt8      gNameToRegister[33] = &quot;MyName&quot;;static UInt8      gTypeToRegister[33] = &quot;MyEntity&quot;;static UInt8      gNameBuf[100];////  Prototypes here//extern     OSStatus DoNegotiateSelfSendOption(EndpointRef ep, long enableSelfSend);OSStatus   ActivateCheckNetStuff(void);void     CleanupNetStuff(void);void    CleanupLookupStuff(void);UInt32    GetNumZonesToCheckFor(void);UInt32     CountZonesFromUnpackedBuffer(UInt8 *buffer, long len);UInt32     MoveZonesToUnpackedBuffer(UInt8 *packedBuffer, ZoneBufPtr zoneBufPtr, long len);OSStatus   DoOTGetZoneList(void);OSStatus   SetNameMatchString(Str32 *matchString);OSStatus   SetTypeMatchString(Str32 *matchString);OSStatus   SetNameRegisterString(Str32 *registerString);OSStatus   SetTypeRegisterString(Str32 *registerString);UInt32     GetNumberOfActiveLookups(void);UInt32     GetNumberOfEntitiesPerZone(void);UInt32     GetLookupTimeout(void);UInt32     GetEntitySize(Str32 *nameString, Str32 *typeString);OSStatus   InitiateLookupStuff(Str32 *nameString, Str32 *typeString);OSStatus   MakeOTLookupCall(UInt32 indx, UInt32 lindx, Str32 *nameString, Str32 *typeString);OSStatus   OTRegisterMyName (void);void     OTDeleteMyName (void);OSStatus   DoLookupTest(void);short    clen(char *cptr);void    c2p(char *cptr);UInt16     OTMySetNBPEntity(char *buffer, Ptr nbpObject, Ptr nbpType, Ptr nbpZone);pascal void MyNBPHandler(void* contextPtr, OTEventCode event, OTResult result, void* cookie);void    DoEvent(EventRecord *event);OSStatus ActivateCheckNetStuff(void){  OSStatus    err = noErr;    if (gOTSvcRef == nil)  {      // open the appletalk services provider    gOTSvcRef = OTOpenAppleTalkServicesInContext(OTCreateConfiguration(kZIPName), 0, &amp;err, nil);  }  if (err)    fprintf(stdout, &quot;error %d occurred on call to OTOpenAppleTalkServicesInContext\n&quot;, err);  else    fprintf(stdout, &quot;OTOpenAppleTalkServicesInContext worked \n&quot;);  if ((err == noErr) &amp;&amp; (gOTMapper == nil))  {          // open an NBP Mapper service provider    gOTMapper = OTOpenMapperInContext(OTCreateConfiguration(kNBPName), 0, &amp;err, nil);        if (err == noErr)     {      if (gNotifier == nil)      {        gNotifier = NewOTNotifyUPP(MyNBPHandler);        if (gNotifier == nil)        {          err = memFullErr;          fprintf(stdout, &quot;NewOTNotifyUPP failed \n&quot;);        }      }            if (gNotifier)      {          // install notifier for the mapper          // note that since OpenTransport sets the A5 world for a 68K handler,          // we don't need to mess with saving/setting/restoring A5 - yea!!        err = OTInstallNotifier(gOTMapper, gNotifier, nil);      }    }    else    {      fprintf(stdout, &quot;error %d occurred on call to OTOpenMapperInContext\n&quot;, err);    }  }    fflush(stdout);  return err;}/*  Cleanup what we opened in the ActivateCheckNetStuff routine - this routine also frees up the   memory associated with the zone list. It also checks whether an entity has been registered and  deletes it.*/void CleanupNetStuff(void){  if (gZoneBufPtr)  {    OTFreeMem(gZoneBufPtr);    gZoneBufPtr = nil;  }  if (gOTSvcRef)  {    OTCloseProvider(gOTSvcRef);    gOTSvcRef = nil;  }    if (gOTMapper)  {    if (gNameRegistered == true)    {      OTDeleteMyName();      gNameRegistered = false;    }          OTCloseProvider(gOTMapper);    gOTMapper = nil;  }    if (gNotifier)  {    DisposeOTNotifyUPP(gNotifier);    gNotifier = nil;  }}/*  Cleanup what we opened in the InitiateLookup routine */void CleanupLookupStuff(void){  if (gLookupReqPtr)  {    OTFreeMem(gLookupReqPtr);    gLookupReqPtr= nil;  }  if (gLookupReplyPtr)  {    OTFreeMem(gLookupReplyPtr);    gLookupReplyPtr = nil;  }  if (gNBPEntityPtr)  {    OTFreeMem(gNBPEntityPtr);    gNBPEntityPtr = nil;  }}/*  CountZonesFromUnpackedBuffer takes a input the zone name buffer and the valid length of the  buffer contents and returns the number of zone names in the buffer*/UInt32 CountZonesFromUnpackedBuffer(UInt8 *buffer, long len){  long  index = 0L;  short  i = 0;    while (index &lt; len)   {    index += (char)((Ptr)buffer+index)[0]+1L;    i++;  }  return i;}/*  MoveZonesToUnpackedBuffer takes as input the zone name buffer and the valid length of the  buffer contents and moves the zones names into the ZoneBufPtr array elements.  the zoneBufPtr will be an array of Pascal strings*/UInt32 MoveZonesToUnpackedBuffer(UInt8 *packedBuffer, ZoneBufPtr zoneBufPtr, long len){  long  index = 0L;  short  i = 0;    while (index &lt; len)   {    BlockMoveData((Ptr)packedBuffer+index, (Ptr)&amp;zoneBufPtr[i].zoneName, zoneNameSize);    index += (char)((Ptr)packedBuffer+index)[0]+1L;    i++;  }  return i;}/*  GetNumZonesToCheckFor returns the number of zones to start checking for. The smaller the number the more you may have to   search until all of the zones are read*/UInt32  GetNumZonesToCheckFor(void){    // could store this in a resource and obtain the value here.  return kNumZonesToCheckFor;}/*  DoOTGetZoneList repeatedly calls OTAtalkGetZoneList until kOTBufferOverflowErr is no longer  returned, which indicates that the provided buffer was too small for the number of AppleTalk zones present.  Note that the global gZoneBufPtr is allocated here and is not de-allocated until the CleanupNetStuff call.*/OSStatus DoOTGetZoneList(void){  TNetbuf    reply;  OSStatus  err = noErr;  UInt8    *packedzonebuffptr = nil;  UInt32    numZonesToCheckFor;  short    increment = 0;  Boolean    done = false;    numZonesToCheckFor = GetNumZonesToCheckFor();    // set up to loop until we have a buffer big enough to hold all of the returned zones  while (done == false)  {    numZonesToCheckFor += increment;        if (packedzonebuffptr != nil)      OTFreeMem(packedzonebuffptr);          packedzonebuffptr = OTAllocMemInContext(numZonesToCheckFor * zoneNameSize, nil);    if (packedzonebuffptr != nil)    {      reply.buf = packedzonebuffptr;      reply.maxlen = numZonesToCheckFor * zoneNameSize;        // by default, the AtalkServiceProvider is in synchronous mode      err = OTATalkGetZoneList(gOTSvcRef, &amp;reply);      if (err == kOTBufferOverflowErr)      {        fprintf(stdout, &quot;Buffer Overflow error occurred with numZonesToCheckFor = %d\n&quot;, numZonesToCheckFor);          // reset the err to noErr        err = noErr;        increment = numZonesIncrement;      }      else if( err == noErr)      {        done = true;      }      else      {        done = true;        fprintf(stdout, &quot;error %d occurred on call to OTATalkGetZoneList\n&quot;, err);              }            }    else    {      done = true;      fprintf(stdout, &quot;mem error occurred while allocating packedzonebuffptr for %d zones\n&quot;, numZonesToCheckFor);      err = memFullErr;    }  }    if (err == noErr)  {    gNumZones = CountZonesFromUnpackedBuffer(packedzonebuffptr, reply.len);    fprintf(stdout, &quot;There are %d zones detected\n&quot;, gNumZones);      // allocate the memory for the zone list structure      // check first if any zones were found    if (gNumZones == 0)      gZoneBufPtr = (ZoneBufPtr)OTAllocMemInContext(sizeof(ZoneBuffer), nil);    else      gZoneBufPtr = (ZoneBufPtr)OTAllocMemInContext(gNumZones * sizeof(ZoneBuffer), nil);          if (gZoneBufPtr == nil)    {      fprintf(stdout, &quot;mem error occurred while allocating ZoneBuffer array for %d zones\n&quot;, numZonesToCheckFor);      err = memFullErr;    }    else    {      if (gNumZones == 0)      {        gZoneBufPtr-&gt;zoneName[0] = 1;        gZoneBufPtr-&gt;zoneName[1] = '*';        gZoneBufPtr-&gt;zoneName[2] = 0;        gNumZones = 1;      }      else        MoveZonesToUnpackedBuffer(packedzonebuffptr, gZoneBufPtr, reply.len);    }  }      // we're done with the packedzonebuffptr, so lets get rid of it.  if (packedzonebuffptr != nil)    OTFreeMem(packedzonebuffptr);    return err;}/*  SetNameMatchString is where you set the name string that the program will search for among the zones.  replace this code with that where you define the NBP name string to search for*/OSStatus SetNameMatchString(Str32 *matchString){  BlockMoveData((Ptr)gNameToSearchFor, (Ptr)matchString, clen((char*)gNameToSearchFor)+1);  c2p((char*)matchString);  return noErr;}/*  SetTypeMatchString is where you set the type string that the program will search for among the zones.  replace this code with that where you define the NBP type string to search for*/OSStatus SetTypeMatchString(Str32 *matchString){  BlockMoveData((Ptr)gTypeToSearchFor, (Ptr)matchString, clen((char*)gTypeToSearchFor)+1);  c2p((char*)matchString);  return noErr;}/*  SetNameRegisterString is where you set the name string that the program will register with NBP*/OSStatus SetNameRegisterString(Str32 *registerString){  BlockMoveData((Ptr)gNameToRegister, (Ptr)registerString, clen((char*)gNameToRegister)+1);  c2p((char*)registerString);  return noErr;}/*  SetTypeMatchString is where you set the type string that the program will search for among the zones.*/OSStatus SetTypeRegisterString(Str32 *registerString){  BlockMoveData((Ptr)gTypeToRegister, (Ptr)registerString, clen((char*)gTypeToRegister)+1);  c2p((char*)registerString);  return noErr;}/*  GetNumberOfActiveLookups returns the number of simultaneous lookups that are active at one time.  The more you do at  one time, the faster you get the search done.  On the other hand, doing to many lookups at once may flood the  network.  GetNumberOfActiveLookups allows you to define how many lookups are active at the same time.*/UInt32 GetNumberOfActiveLookups(void){  if (gNumZones &lt;= kMaxActiveLookups)  {    // if there are no zones    if (gNumZones == 0)      return 1;    else      return gNumZones;  }  else return kMaxActiveLookups;}/*  GetNumberOfEntitiesPerZone returns the maximum number of matches that I want to look for in a zone.  If multiple matches are  permitted, then you have to face the possibility that the maximum number of matches might exist in the same zone.*/UInt32 GetNumberOfEntitiesPerZone(void){  return 1;}/*  return the lookup timeout value that the program will use*/UInt32 GetLookupTimeout(void){  return kDefaultTimeout;}/*  GetEntitySize returns the entity size to use  Note that we have only allocated a &quot;minimum&quot; size entity array rather than a full   size array, in order to reduce the memory allocation requirement.  Since we do this  we can't treat the entity array as a simple array.  In order to access each element  we have to take the size of each element, multiply that value against the array index  for the element and add the result to the base pointer to get each array element.*/UInt32 GetEntitySize(Str32 *nameString, Str32 *typeString){  UInt8  *c1, *c2;    c1 = (UInt8*)nameString;  c2 = (UInt8*)typeString;      //  return (c1[0] + c2[0] + 16);  return (kNBPEntityBufferSize + 8);}/*  Set up the lookup arrays that we will need for the NBP lookups.  The request, reply and  entity structures cannot go away while the lookup is active since we are making them asynchronously  */OSStatus InitiateLookupStuff(Str32 *nameString, Str32 *typeString){  UInt32    numLookupsActive;  UInt32    entitySize;  UInt32    numEntitiesPerZone;  OSStatus  err;  short    i;    numLookupsActive = GetNumberOfActiveLookups();  #ifdef DEBUG  DebugStr(&quot;\p about to allocate memory&quot;);#endif  gLookupReqPtr = (TLookupRequest*) OTAllocMemInContext(numLookupsActive * sizeof(TLookupRequest), nil);  gLookupReplyPtr = (MyLookupReply*) OTAllocMemInContext(numLookupsActive * sizeof(MyLookupReply), nil);    if ((gLookupReqPtr != nil) &amp;&amp; (gLookupReplyPtr != nil))  {    err = noErr;          // figure out the max number of entities we want to match on in a zone.  If we want to find any      // duplicate of a name, then return 1.  But if we allow more than one entity at all, then plan on      // that maximum number existing in the same zone.    numEntitiesPerZone = GetNumberOfEntitiesPerZone();      // figure out how much memory to allocate for the entity buffer.      // since we know the name and type strings, we can figure their length and add the max zone string      // length instead of allocating the full max entity length string      // make sure to also add space for the address, plus the 4 bytes at the beginning of each response      // which is for the 2 length values - total of 8 bytes.    entitySize = GetEntitySize(nameString, typeString);          // allocate the entityptr array.  Note that we will use the same entity structure for input and       // potential output    gNBPEntityPtr = (NBPEntity*) OTAllocMemInContext(numLookupsActive * entitySize * numEntitiesPerZone, nil);    if (gNBPEntityPtr == nil)      err = memFullErr;  }  else    err = memFullErr;        if (err == noErr)  {    for (i = 0; i &lt; numLookupsActive;)    {      gLookupReplyPtr[i].index = i;      i++;    }          // we initiate all of the lookups in the following loop, however, if there are more lookups than      // we have lookuprequests in the array, then set the gNextLookup indice to numLookupsActive      // so that this will be where we begin other lookups if the entity is not found.    gNextLookup = numLookupsActive;          // set the gOTMapper endpoint to operate asynchronously    OTSetAsynchronous(gOTMapper);        for (i = 0; (gDone == false) &amp;&amp; (i &lt; numLookupsActive);)    {      err = MakeOTLookupCall(i, i, nameString, typeString);      i++;    }  }  return err;  }/*  MakeOTLookupCall is where we make the zone specific Lookup call.  input parameters    indx - index into the gLookupReqPtr, gNBPEntityPtr, and the gLookupReplyPtr arrays    lindx - index into the gZoneBufPtr where we get the zone where we will perform the next lookup    nameString - pascal name string    typeString - pascal type string*/OSStatus MakeOTLookupCall(UInt32 indx, UInt32 lindx, Str32 *nameString, Str32 *typeString){  OSStatus  err;  UInt32    entitySize;  UInt32    numEntitiesPerZone;  char*    entityPtrToUse;      // figure out the max number of entities we want to match on in a zone.  If we want to find any    // duplicate of a name, then return 1.  But if we allow more than one entity at all, then plan on    // that maximum number existing in the same zone.  numEntitiesPerZone = GetNumberOfEntitiesPerZone();      // figure out how much memory to allocate for the entity buffer.    // since we know the name and type strings, we can figure their length and add the max zone string    // length instead of allocating the full max entity length string  entitySize = GetEntitySize(nameString, typeString);    OTMemset(&amp;gLookupReqPtr[indx], 0, sizeof(TLookupRequest));    // set up the lookup request record  gLookupReqPtr[indx].maxcnt = numEntitiesPerZone;  gLookupReqPtr[indx].timeout = GetLookupTimeout();    // figure out where the the pointer is in the array to use.  entityPtrToUse = (char*) ((UInt32) gNBPEntityPtr + indx * entitySize * numEntitiesPerZone);    gLookupReqPtr[indx].name.len = (size_t)OTMySetNBPEntity(entityPtrToUse,                 (char*)nameString, (char*)typeString, (char*)&amp;gZoneBufPtr[lindx].zoneName);  gLookupReqPtr[indx].name.buf = (unsigned char*)entityPtrToUse;    gLookupReqPtr[indx].addr.len = 0;  gLookupReqPtr[indx].addr.buf = nil;  gLookupReqPtr[indx].addr.maxlen = 0;      // set up the lookup reply record  gLookupReplyPtr[indx].lkReply.names.maxlen = numEntitiesPerZone * entitySize;  gLookupReplyPtr[indx].lkReply.names.len = 0;  gLookupReplyPtr[indx].lkReply.names.buf = (unsigned char*)entityPtrToUse;  gLookupReplyPtr[indx].lkReply.rspcount = 0;  gLookupReplyPtr[indx].lindex = lindx;      // make the lookup call  err = OTLookupName(gOTMapper, &amp;gLookupReqPtr[indx], (TLookupReply*)&amp;gLookupReplyPtr[indx]);  if (err != noErr)  {#ifdef DEBUG      // this call can be made at deferred task time, so we can't make a call that      // might allocate memory    DebugStr(&quot;\p Error occurred making OTLookupName call&quot;);#endif  }  return err;}/********************************************************************************* Register my name using Open Transport********************************************************************************/OSStatus OTRegisterMyName (void){  TRegisterRequest regreq;  TRegisterReply  regreply;  OSErr      err;  Str32      nameString;  Str32      typeString;      err = SetNameRegisterString(&amp;nameString);  if (err == noErr)  {    err = SetTypeRegisterString(&amp;typeString);    }    // create the NBP name string and set the len field for the string    // and register in the local zone  regreq.name.len = OTMySetNBPEntity((char*)gNameBuf, (Ptr)&amp;nameString, (Ptr)&amp;typeString, (Ptr)&quot;\p*&quot;);  regreq.name.buf = gNameBuf;      // let the system define the network address for this name  regreq.addr.len = regreq.addr.maxlen = 0;  regreq.addr.buf = NULL;      // set up regreply  regreply.addr.maxlen = 0;  regreply.addr.buf = nil;      OTSetSynchronous(gOTMapper);  err = OTRegisterName(gOTMapper, &amp;regreq, &amp;regreply);  if (err == noErr)  {    gMyNameID = regreply.nameid;    gNameRegistered = true;  }    return err;}/********************************************************************************* Delete my name using Open Transport********************************************************************************/void OTDeleteMyName (void){    OTSetSynchronous(gOTMapper);  OTDeleteNameByID(gOTMapper, gMyNameID);  gNameRegistered = false;  }OSStatus DoLookupTest(void){  EventRecord    theEvent;  OSStatus    err;  Str32      nameString;  Str32      typeString;  long      ticks;  Boolean      watchTrigger = true;    // we start the lookup test here by getting the NBP name and type to look for  err = SetNameMatchString(&amp;nameString);    if (err == noErr)  {    err = SetTypeMatchString(&amp;typeString);  }    // we start the asynch lookup process here.  if (err == noErr)  {    err = InitiateLookupStuff(&amp;nameString, &amp;typeString);  }      // we sit in a WNE (WaitNextEvent) loop for the search to complete.  if (err == noErr)  {    ticks = TickCount() + 300;    printf(&quot;Use Command-Q to quit.\n&quot;);        while (gDone == false)    {      ticks++;      if (!WaitNextEvent(everyEvent, &amp;theEvent, 15, nil))        theEvent.what = nullEvent;              DoEvent(&amp;theEvent);      if (ticks &lt; TickCount())      {        ticks = TickCount() + 300;        fprintf(stdout, &quot;%d/%d &quot;, gMatchesFound, gNumLookupsCompleted);        fflush(stdout);      }            if (watchTrigger == true)      {        if (gTriggerAction == true)        {          fprintf(stdout, &quot;\n Too many matches were found \n&quot;);          fflush(stdout);          watchTrigger = false;        }      }            if (gNumLookupsCompleted &gt;= gNumZones)      {        gDone = true;        fprintf(stdout, &quot;\nThere were %d matches found in %d zones\n\n&quot;, gMatchesFound, gNumLookupsCompleted);        fflush(stdout);      }          }        CleanupLookupStuff();  }  return err;}int main(void){  OSStatus    err;        printf (&quot;Sample Program: OTCheckNetForNBPName!\n\n&quot;);    err = InitOpenTransportInContext(kInitOTForApplicationMask, nil);  if (err != noErr)  {    printf (&quot;InitOpenTransport failed with error %d\n&quot;, err);    return err;  }  else    printf (&quot;InitOpenTransportInContext worked!\n\n&quot;);    err = ActivateCheckNetStuff();  if (err != noErr)  {    fprintf(stdout, &quot;ActivateCheckNetStuff returned error %d.\n&quot;, err);  }  fflush(stdout);    if (err == noErr)  {        fprintf(stdout, &quot;Checking for the number of zones present.\n&quot;);        fflush(stdout);    err = DoOTGetZoneList();    if (err != noErr)    {      fprintf(stdout, &quot;DoOTGetZoneList returned error %d.\n&quot;, err);    }  }          if (err == noErr)        {            fprintf(stdout, &quot;Beginning the lookup test.\n&quot;);            fflush(stdout);            err = DoLookupTest();        }    if ((err == noErr) &amp;&amp; (gNumLookupsCompleted &lt; gNumZones))  {    fprintf(stdout, &quot;\nYou stopped the lookup test before all of the lookups were complete!\n&quot;);    fprintf(stdout, &quot;Am closing the mapper endpoint to clear all outstanding lookups.\n&quot;);      // close the mapper endpoint and reopen it    OTCloseProvider(gOTMapper);    gOTMapper = nil;    fprintf(stdout, &quot;Am reopening the mapper endpoint.\n&quot;);    err = ActivateCheckNetStuff();  }    if (err == noErr)  {        fprintf(stdout, &quot;Am registering a new NBP entity\n&quot;);        fflush(stdout);    err = OTRegisterMyName();    if (err)      fprintf(stdout, &quot;Error occurred registering the name %d\n&quot;, err);    else    {      fprintf(stdout, &quot;\nEntity successfully registered\n&quot;);      // the following code will enable SelfSend mode globally on the machine      // otherwise it is only enabled for this process      OTSetSynchronous(gOTMapper);      err = DoNegotiateSelfSendOption(gOTMapper, 1);      if (err == 1)      {        fprintf(stdout, &quot;self send previously enable\n&quot;);          // reset err        err = noErr;      }      else      {        fprintf(stdout, &quot;Error occurred negotiating self send %d\n&quot;, err);        fprintf(stdout, &quot;Quitting program\n&quot;);      }    }  }  fflush(stdout);      if (err == noErr)  {    fprintf(stdout, &quot;\nPerforming the next lookup for the new entity\n&quot;);        fflush(stdout);      // reset gDone and try the lookup test again    gDone = false;    gNumLookupsCompleted = 0;    err = DoLookupTest();  }    CleanupLookupStuff();    CleanupNetStuff();  CloseOpenTransportInContext(nil);      fprintf(stdout, &quot;\nTest ended\n&quot;);  return 0;}/*****************************************************************************//* Convert a c-string to a pascal-string. */short  clen(char *cptr){  short  i;  for (i = 0; cptr[i]; ++i) {};  return(i);}/*****************************************************************************/void  c2p(char *cptr){  char  len;  BlockMove(cptr, cptr + 1, len = clen(cptr));  *cptr = len;}/*  OTMySetNBPEntity is used to set up an NBP lookup query buffer.  All input strings are assumed to be pascal strings*/UInt16 OTMySetNBPEntity(char *buffer, Ptr nbpObject, Ptr nbpType, Ptr nbpZone){  char*  bufPtr;  UInt16  len;    bufPtr = buffer;  BlockMove((Ptr)&amp;nbpObject[1], bufPtr, nbpObject[0]);  bufPtr += nbpObject[0];    // point buffer to end of current string  len = nbpObject[0];      // collect number of chars moved to buffer    // add the &quot;:&quot; character between the object and type strings  *bufPtr = ':';  bufPtr++;  len++;  BlockMove((Ptr)&amp;nbpType[1], bufPtr, nbpType[0]);  bufPtr += nbpType[0];    // point buffer to end of current string  len += nbpType[0];      // collect number of chars moved to buffer      // add the &quot;@&quot; character between the type and zone strings  *bufPtr = '@';  bufPtr++;  len++;  BlockMove((Ptr)&amp;nbpZone[1], bufPtr, nbpZone[0]);  len += nbpZone[0];      // collect number of chars moved to buffer  return len;  }/********************************************************************************* HandleMapperEvents TMapper (NBP) Event Handling********************************************************************************/pascal void MyNBPHandler(void* contextPtr, OTEventCode event, OTResult result, void* cookie){#pragma unused (contextPtr)  MyLookupReplyPtr  myReplyPtr;  OSStatus      err;  UInt32        indx;  Boolean        dolookup = false;  Str32        nameString;  Str32        typeString;    switch (event)  {    case T_LKUPNAMERESULT:    // intermediate result notification      break;          case T_LKUPNAMECOMPLETE:#ifdef DEBUG      DebugStr(&quot;\p about to set gNumLookupsCompleted&quot;);#endif      gNumLookupsCompleted++;        // in a lookupcomplete event, the cookie is a OTLookupReply ptr.      myReplyPtr = (MyLookupReplyPtr)cookie;            if ((result == kOTBufferOverflowErr) ||        (result == noErr))      {        gMatchesFound += myReplyPtr-&gt;lkReply.rspcount;        dolookup = true;        if (gMatchesFound &gt; GetNumberOfEntitiesPerZone())          gTriggerAction = true;      }            if (result == kOTNoDataErr)        dolookup = true;            if (dolookup == true)      {        if (gNextLookup &lt; gNumZones)        {          indx = myReplyPtr-&gt;index;          if (indx &gt;= kMaxActiveLookups)          {#ifdef DEBUG            DebugStr(&quot;\p about to set gNumLookupsCompleted&quot;);#endif          }          else          {            SetNameMatchString(&amp;nameString);            SetTypeMatchString(&amp;typeString);            err = MakeOTLookupCall(indx, gNextLookup, &amp;nameString, &amp;typeString);              // increment the lookup index in to the zone array for the next              // zone to look into.            gNextLookup++;          }        }      }      else      {#ifdef DEBUG        DebugStr(&quot;\p T_LKUPNAMECOMPLETE: Unexpected error&quot;);#endif      }      break;          case T_REGNAMECOMPLETE:      break;          case T_DELNAMECOMPLETE:      break;          default:#ifdef DEBUG      DebugStr(&quot;\pHandleMapperEvents: Unexpected Event!;g&quot;);#endif      break;  }}void  DoEvent(EventRecord *event){  char  key;  switch(event-&gt;what)   {    case nullEvent:    case mouseDown:    case activateEvt:    case updateEvt:    case kHighLevelEvent:    case osEvt:    case diskEvt:      break;    case autoKey:    case keyDown:      key = event-&gt;message &amp; charCodeMask;      switch (key)      {        case 'q':        case 'Q':          if (event-&gt;modifiers &amp; cmdKey)          gDone = true;          break;      }      break;  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OTCheckNetForNBPName/listing4.html%3Fid%3DDTS10000707-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OTCheckNetForNBPName/listing4.html%3Fid%3DDTS10000707-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OTCheckNetForNBPName/listing4.html%3Fid%3DDTS10000707-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>