<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PT12: C++ Pitfalls in MPW</title><meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="Dec 30, 1991 - Jan 3, 1992"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002666" title="C++ Pitfalls in MPW"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxTools-date.html">Tools</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Java/idxTools-date.html" target="_blank">Reference Library > Tools</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PT12</div>
<div id="pageheadsub">C++ Pitfalls in MPW</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">Class Protection and Inheritance</A><BR><BR><A HREF="#Section3">Type Casting</A><BR><BR><A HREF="#Section4">General Class Issues</A><BR><BR><A HREF="#Section5">Operator Overload Issues</A><BR><BR><A HREF="#Section6">Inlining Issues</A><BR><BR><A HREF="#Section7">Memory Leakage</A><BR><BR><A HREF="#Section8">Tricks to Help You Find Memory Leaks</A><BR><BR><A HREF="#Section9">Virtual Functions</A><BR><BR><A HREF="#Section10">Compiler Issues</A><BR><BR><A HREF="#Section11">Testing/Debugging</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note covers most of the common and serious subtle problems thata MPW C++ user might encounter. For more information consult the current C++literature. This Note will be updated periodically to reflect changes in thelanguage and the compiler. Always read the release notes included with the MPWC++ to find out the latest status for known bugs and restrictions.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Jan 01 1992]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Introduction</h2><p>C++, like any other computer language, has its own subtle problems, traps, andpitfalls. It is impossible to figure out all the possible pitfalls that mayoccur, but this Technote covers the most frequently asked questions about MPWC++ problems.</p><P><A HREF="#top">Back to top</A></p><a name="Section2"></a><h2>Class Protection and Inheritance</h2><h3>Access Control Problems</h3><p>The C++ compiler assumes private access control if any of the access controlkeywords are omitted. For instance, in the following case the member function<code>Run</code> is declared <code>private</code>, and thus is not accessible from theoutside the class:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TClass{    TClass() {/* constructor code *}    void Run();        // private member function// ...</pre>	</TD></TR></TABLE></CENTER><p>This is also true when using inheritance; if no keywords are included, thecompiler assumes that the base class is inherited as a private member:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TFoo : TClass{// ...</pre>	</TD></TR></TABLE></CENTER><p>Always exercise special care when using inheritance, and use the keywords<code>private</code>, <code>protected,</code> or <code>public</code> to avoid unexpectedproblems.</p><h3>Derived Classes</h3><p>Every member function must function properly for the same range of argumentsaccepted by the base class. If not, then the derived class is not a truesubtype of the base and you may encounter subtle and bizarre problems that arehard to find.</p><p>Note that if you inherit the base class as a private class, it is the same asif the class were a private member of the derived class. Thus there are fewcases where one needs to import a base class as a private class.</p><p>Be especially careful to avoid changing the meaning of a base class's publicinterface. Any public member function of the base class should not have itssemantics changed by the derived class. Fortunately the MPW C++ compiler warnsyou if this is done.</p><p>Here's an example:  if a class <code>TBase</code> has an overloaded <code>operator==</code> for comparison that takes a <code>const TBase&amp;</code> as an argument,then any override of this function by a derived class <code>TDerived</code> mustpreserve its semantics. In particular the <code>TDerived</code> class override maynot assume that the argument is of type <code>const TDerived&amp;</code>, as thatchanges the meaning of the member function that is inherited from<code>TBase</code>'s<code> </code>public interface.</p><p>In this case it would be better to overload <code>operator ==</code> to accept anargument of type <code>const TDerived&amp;</code>, and to reexport the inherited<code>operator ==</code>. Thus you need to overload the derived class's operator ifthe comparison overload will make use of a new data structure. Another solutionwould be to use a pointer to a function/member function to define the actualcomparison routine instead of assuming there is a fixed comparison routine.Careful analysis of the use of data structures should help you avoid theseproblems. Bugs related to this particular problem are extremely difficult totrack down, especially when the class inherits from two or more base classes,each of which defines a function with the same name but with differentsemantics.</p><h3>Derived Classes as Variables</h3><p>Any member function that accepts a reference or pointer to a class must beprepared to receive a derived class as an actual argument. Therefore therecipient function must deal with the argument through an interface that isguaranteed to be preserved in derived classes. If this is not the case thefunction call will fail when used with derived classes. If this is notfeasible, then the class documentation should state that it cannot be used as apublic base class.</p><h3>Scoping Issues</h3><p>The scope rules in C++ are in flux. The earlier C++ compilers did not protectthe name space concerning scoping of types declared inside classes. This haschanged in MPW C++ 3.2. You are now able to define <code>typedef</code>s,<code>enum</code>s, and classes/structs with a class scope. However, read therelease notes for your MPW C++ version for possible known bugs and limitationsconcerning this new feature.</p><P><A HREF="#top">Back to top</A></p><a name="Section3"></a><h2>Type Casting</h2><h3>The Problem: Conversion Versus Coercion Type Casting</h3><p>Type casting is occasionally necessary in C and C++, but you should be aware ofthe consequences every time you need to use it. Casts are very uncontrolled anddangerous, and  you should ask yourself if you really need to do one every timeyou catch yourself in the act.</p><p>There are two types of casts in C++. The first one merely changes an objectfrom one type to another. This includes casts between the built-in arithmetictypes and casts involving class objects (not pointers to classes). These are ingeneral fairly safe, since an actual conversion is taking place.</p><p>The other type of cast involves pointers, and these casts are dangerous. Thistype of cast involves so-called type coercion: the bit pattern of one type isinterpreted as another type. This is very unsafe, and could cause the code todie mysteriously and subtly.</p><p>Unfortunately, some C++ constructs can be interpreted as either of the twotypes of casts. A cast from one class pointer to another is interpreted as aconversion cast if the two types are related by type inheritance and ascoercion casts if they are not. The C++ compiler does not warn you if youintend the first cast but wind up with the second. Worse, a cast betweenpointers to member functions may be a conversion on the class part but acoercion on the function prototype part.</p><h3>Casting Cases</h3><p>Some casts are always of the coercion type. For instance, casting a const (anda future volatile) pointer to one without those attributes is always acoercion. Avoid performing such casts. If you make a member function constbecause it does not change the object semantics, then you must cast yourthis pointer to non-const to make changes to the internal object state.However, this technique is not recommended; instead you should overload thefunction or make another design decision.</p><p>There are also casts to and from <code>void*</code>. These are dangerous. Avoidsuch casts, even if the <code>void*</code> is a useful construct. For instance, donot use <code>void*</code> to avoid assigning a type to a variable or parameter.Use it only for manipulation of raw storage.</p><p>Even if casts from a base class pointer to a derived class pointer areconversions, you should avoid these. First, if you accidentally specify typesnot related by inheritance, you will get a silent coercion. Second, this is apoor programming technique and removes vital information used for typechecking. The future template support in C++ should obviate the need for mostsuch casts.</p><p>In general the only normally acceptable cast is the conversion type. Avoid allcasts involving pointers unless absolutely necessary. Note that nonpointercasts can never silently become coercions.</p><P><A HREF="#top">Back to top</A></p><a name="Section4"></a><h2>General Class Issues</h2><h3>Handling Failing Constructors</h3><p>Constructors and destructors do not return any values, so a returned error codeis not possible. There are many ways to provide error handling withconstructors/destructors.</p><p>For instance, the class could have an internal field that signals whether theconstruction of the class succeeded, as well as a special test method orinvariant method that checks whether the state of the newly created class isvalid. Failing to figure out if a class is properly constructed could lead tomany subtle bugs. If possible the class should be constructed to a known stateso that it can be destructed without problems.</p><p>You should also save information about why the construction failed, which couldbe useful for future class operations. The future C++ exception handling schemewill solve this problem. Also one might use the MacApp <code>FailInfo</code>exception handling files in other non-MacApp projects.</p><P><A HREF="#top">Back to top</A></p><a name="Section5"></a><h2>Operator Overload Issues</h2><p>Assignment operators should always start with a test that checks whether theobject (by mistake) wants to assign to itself, as in <code>aFoo = aFoo</code>;,which could cause subtle problems. This is done as in the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>TFoo&amp; TFoo::operator=(const TFoo&amp; aFoo){    if (this == &amp;aFoo) return *this;      //...normal assignment duties...      return *this;</pre>	</TD></TR></TABLE></CENTER><p>Also, always overload all cases of the operator use, for instance both the'<code>x = x + y</code>' and the '<code>x += y</code>' operations.</p><p>If you are overloading certain operators, make sure that you know whether theyhave already been overloaded, and what they return/pass as values. Otherwisethe compiler will complain about mismatch between formal and actual parametertypes. For instance, <code>new</code> is overloaded with <code>PascalObject </code>and<code>HandleObject</code> base classes, and returns a <code>Handle</code> instead of a<code>void*</code>. Note also that if two programmers independently change thebehavior of new, the resulting program might not work as expected.</p><p>Also, you need to inherit publicly from your base classes if you want thebehavior of any new operator overload in the base class.</p><P><A HREF="#top">Back to top</A></p><a name="Section6"></a><h2>Inlining Issues</h2><h3>General</h3><p>The C++ inlining feature is purely a  hint to the compiler indicating thatinline substitution of the function body is to be preferred to the usualfunction implementation. Inline code is usually used for code optimization:instead of calling a function, the whole body is inlined at the point of call,thus saving the cost of a function call.</p><p>Here's a simple example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TClass {public:    long GetField(void) {return this-&gt;fField;};    void SetField(long);private:    long    fField;};inline void TClass::SetField(long theValue){    this-&gt;fField = theValue;</pre>	</TD></TR></TABLE></CENTER><p>Note that there are two different ways inline is indicated: by placing thefunction specifier inline in front of the function (or member function)declarator, or by defining the code directly in the class (by which thestatements are automatically considered to be inlined). See Section 7.2.1 of<i>The Annotated C++ Reference Manual </i>for more information on inlinefunction declarations.</p><p>As inlining is purely an optimization issue, it should be used only when thebenefits in run-time or space outweigh the costs and inconveniences imposed byits use. The major cost of a function call is usually the cost of executing thefunction body, not the cost of making the call. Therefore, inlining should beused mostly for simple functions. Examples of such functions are functions thatset or get a value, increment or decrement a value, or directly call anotherfunction. A function consisting of one or two simple expressions is usually agood inline candidate.</p><h3>Compiler Considerations Concerning Inline Statements</h3><p>The MPW C++ compiler has a set of rules by which it determines if an inlinestatement will be inlined or not. Some of the rules are easily quantified, suchas the fact that recursive functions are never inlined; others vary dependingupon whether or not the inline function return type is void, and upon thecalling context. An inline function invoked in an expression context other thana call statement cannot be inlined if it contains code that cannot be reducedto one or more expressions. For instance, an <code>if-then-else</code> statement isonly acceptable in such a calling context if it can be successfully convertedto a conditional <code>(?:)</code> expression.</p><p>The following rules concern Apple's AT&amp;T CFront port, MPW C++ 3.2 (andshould also cover most cases with MPW C++ 3.1):</p><h3>Recursive Functions</h3><p>Recursive functions are never inlined.</p><h3>Large Functions</h3><p>Any function containing 12 or more assignments will not be inlined. Otherwise,size is less of an issue than complexity. For example,  a function containing 5or more calls will not be inlined, but the compiler may also refuse to inline afunction containing fewer calls if there are other statements adding to thecomplexity. You can override the compiler's decision not to inline somethingbased on size by using the -z17 option, but caution should beexercised.</p><h3>Functions Invoked Before Defined</h3><p>If an inline function is called before it is defined, it cannot be inlined. Forexample:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static int an_inline_function();int an_outline(){    return (an_inline_function());}static inline int an_inline_function(){    return 1;</pre>	</TD></TR></TABLE></CENTER><p>Because the compiler had not seen the inline body of "an_inline" when itencountered the first call, it will generate a call in "an_outline" and anout-of-line copy of "an_inline".</p><h3>Functions Invoked Twice or More Within an Expression</h3><p>Typically, in this case, the compiler will inline the body of the function forthe first usage and then use calls for subsequent uses within the sameexpression.</p><p>An out-of-line copy of "some_inline" will be generated and called for the rightoperand of the addition, in most cases. The compiler may still be able toinline the function in both places if it declares no variables and if either ithas no parameters or the actual parameter expressions are sufficientlysimple.</p><h3>Functions Containing loop, switch, goto, label, break, or continueStatements</h3><p>Value-returning inline functions will not be inlined if they contain any of thestatement types listed above. Even non-value-returning inline functions cannotbe inlined if they contain such statements and are invoked in the middle of anexpression; the only control flow statement that can be inserted into themiddle of an expression is the <code>if-then-else</code> statement.</p><h3>Taking the Address of an Inline Function</h3><p>An out-of-line copy will be generated for any inline function whose address isneeded, either because it is the explicit target of the unary'<code>&amp;</code>' operator or because it is used to initialize a functionpointer. Virtual calls of virtual inline functions fall into this category aswell.</p><h3>Non-Value-Returning Inline Functions Containing a Return Statement</h3><p>These are never inlined.</p><h3>Functions Declaring Static Variables</h3><p>These are never inlined. </p><h3>Functions Containing Statements After a Return</h3><p>An out-of-line copy will be generated for any inline function with one or morestatements after the return statement. This applies primarily tovalue-returning functions, since non-value-returning functions containing anyreturn statement will never be inlined. For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>inline int an_inline(void){    if (condition)        return 0;    do_something();        // will suppress inlining    return something;</pre>	</TD></TR></TABLE></CENTER><h3>Segmentation Issues Concerning Non-Inlined Statements--Which SegmentDo Unexpectedly Outlined Functions Appear In?</h3><p>Inlined code, which is suddenly outlined by the compiler, usually ends up inwhichever segment that is actual for the call that caused the inline code to beoutlined. Typically the outlined code ends up at the end of the object file.</p><p>If you want to control in what segment the code will be placed, bracket all theheader files with  <code>'#pragma segment HeaderFiles'</code>,in combinationwith <code>#pragma push</code> and <code>#pragma pop</code>. This way you are able tocontrol into what segment the inline code will end in if it's suddenlyoutlined. Here's an example of how this is done:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>// push the pragma state information#pragma push// define segment name for suddenly outlined inline-code#pragma segment IfOutlinedItGoesHereclass TFoo{public:    TFoo(){/* ...*/}    long  InlineMeMaybe(long x){/* ...*/}// ...};// pop back the original pragma information</pre>	</TD></TR></TABLE></CENTER><h3>Compiler Directives</h3><h3>Suppression of No Inline Code</h3><p>The MPW C++ compiler has a <code>-z0</code> switch, which forces all inline code tobe non-inline. This switch is useful when trying to track down problems thatare eventually related to inline code generation.</p><h3>Forced Inlining of Large Functions</h3><p>The MPW C++ compiler has a <code>-z17</code> switch that will force inlining offunctions that would normally be rejected because of size considerations.Consider carefully before using this switch as it can lead to large code. Itmay also cause CFront to generate expressions larger than the MPW C compilercan handle.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Warnings:</B><BR>The new MPW 3.2 C++ compiler (available on ETO CD #5 forward)is based on CFront 2.1 (AT&amp;T), and the <code>-w</code> flag in this releasewill now indicate when the compiler chooses not to inline a function declaredinline.</P></TD></TR></TABLE></CENTER><BR><h3>Conclusion</h3><p>Inline-defined functions are just hints to the compiler, and the inline codegeneration rules will vary from implementation to implementation. The rulesdescribed in this document are true for the Apple MPW C++ compiler. Some ofthem are limitations resulting from the fact that MPW C++ generates C code;other inlining problems will also apply to native compilers. One needs torealize that inline statements are not always inlined by C++ compilers, andthat inlining rules are C++ /C compiler implementation dependent.</p><a name="Section7"></a><P><A HREF="#top">Back to top</A></p><h2>Memory Leakage</h2><h3>General</h3><p>Memory  leakage usually occurs when space is dynamically allocated on the heapand, usually because of a programming error, the heap space is neverdeallocated. Unfortunately, with C++ hidden memory leaks can happen, which inthe Macintosh memory system will trigger a heap-stack collision and a bomb.Here's a list of possible memory leaks and memory allocation problems, and waysto avoid them:</p><h3>Nonpaired New/Deletes</h3><P>If you allocate data on the heap with new, it usually should be deleted with asubsequent delete call. This usually happens when the object goes out of scope,but if the data is explicitly allocated in the heap the compiler doesn't knowhow to purge this when the object goes out of scope. This problem comes upespecially when an object creates space for data on the heap as part of itsclass structure, as in the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TFoo{public:    TFoo(char* name);        // forgot to declare a ~TFoo() which would                    // delete the fName structureprivate:    char*    fName;};TFoo::TFoo(char* name){    fName = new char[strlen(name) + 1];    strcpy(fName, name);</pre>	</TD></TR></TABLE></CENTER><P>The <code>fName</code> data structure will be on the heap until delete is called.If you delete the <code>fName</code> string in the destructor then you will avoidthe memory leak.</p><h3>Object Pointers That Are Nested Inside Classes</h3><P>If the class makes use of objects that are referenced via pointers, they needto be deleted; otherwise the data will stay in the heap, as in the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TBar{public:    TBar(char* type);    ~TBar();private:    TFoo*    fFoo;            // from the earlier example    char*    fType;};TBar::TBar(char* type){    fFoo = new TFoo(&quot;Willie&quot;);    fType = new char[strlen(type) + 1];    strcpy(fType, type);}TBar::~TBar(){    delete fType;        // this is OK                // but you also need to delete the fFoo, as in:                // delete fFoo;</pre>	</TD></TR></TABLE></CENTER><p align=center><img src="images/pt_12_001.gif" alt="Figure 1. Nested Objects." width=224 height=59></p><p align=center><b>Figure 1</b>.  Nested Objects</p><h3>Missing Size Arguments to the Delete Function</h3><P>The delete function needs the size of the deleted data structures, especiallyin the case of deletion or arrays of objects. Note that this problem will goaway with MPW C++ compilers (MPW 3.2 C++ and later ones) where the general<code>[]</code> notation keeps track of the sizes of the arrays. For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>main(){    TFoo* fooArray = new TFoo[10];    // create an array of 10 TFoo:s    // do something    // delete the array    delete [] fooArray;        // should be delete [10] fooArray with MPW C++       // 3.1;</pre>	</TD></TR></TABLE></CENTER><h3>Problems With Arrays of Pointers Versus Arrays of Objects</h3><P>There is a subtle but important difference between an array of pointers toobjects, and an array of objects themselves. The use of the delete operator isdifferent in either case, as in the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>main(){    TFoo** fooArray = new TFoo[10];           // array of pointers to objects    for(int i=0;i&lt;10;i++)            // create the objects in the array        fooArray[i] = new TFoo(&quot;Steve&quot;);    // do something    // now clean up the array    delete [10] fooArray;            // this only cleans up the                            // pointers, not the objects                            // themselves    // the following code should be used instead:    for(i=0;i&lt;10;i++)        delete fooArray[i];    delete [] fooArray;    return 0;</pre>	</TD></TR></TABLE></CENTER><P align=center><img src="images/pt_12_002.gif" alt="Figure 2. Objects Left Due to Missing Arguments." width=320 height=140></p><p align=center><b>Figure 2</b>.  Objects Left Due to Missing Arguments</p><p>Memory leaks such as this becomes even more dangerous with object-orienteddatabases and persistence cases, where a leak could address more and more harddisk space on a server.</p><h3>Missing Copy Constructor</h3><P>When operator overloading occurs, dynamically allocated memory for temporarydata storage can suddenly develop a subtle leak that eats memory slowly. Forinstance an implicit call to an undefined copy constructor could be dangerous.These kinds of constructors are called whenever an initialization is done incode, when objects are passed by value on the stack, or when objects arereturned by value. For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TFoo{public:    TFoo(char* name, int age);    // TFoo(const TFoo&amp;);        note, no copy constructor defined!!    ~TFoo();    TFoo Copy(TFoo);            // copy function, will call default                        // copy constructorprivate:    char*    fName;    int    fAge;};TFoo::TFoo(char* name, int age){    fName = new char[strlen(name) + 1];    strcpy(fName,name);    fAge = age;}TFoo::~TFoo(){    delete fName;}TFoo TFoo::Copy(TFoo orig)   // note that this code is the same as the  // code which the compiler would create // for a default copy constructor (i.e.// field-wise copy).{    fAge  = orig.fAge;            // plain pointer copy    fName = orig.fName;    return *this;}main(){    // create two objects    TFoo f1(&quot;James&quot;, 25);    TFoo f2(&quot;Michael&quot;, 29);    TFoo f3 = f2;            // this calls the copy constructor                    // TFoo f3(f2) would also trigger this    // do something    f1.Copy(f2);            // this causes two implicit calls                    // to the default copy constructor      // we have a problem, fName is deleted twice, once     // when f1 is destructed,    // and the second time when d2 is destructed    return 0;}// solution, create a specific copy constructor, as in:TFoo::TFoo(const TFoo&amp; orig){    fAge = orig.fAge;    fName = new char[strlen(orig.fName) + 1];    strcpy(fName, orig.fName);</pre>	</TD></TR></TABLE></CENTER><P>In general, if the class constructor assigns dynamic data, there should be acopy constructor that does the same as well. Note also that call by referencedoes not generate a copy constructor, so use of references is both faster andshould generate fewer unexpected memory leak problems.</p><h3>Missing Overload Assignment Operator (<code>operator=</code>)</h3><P>Every class that dynamically allocate storage for members should also have adefined overload assignment operator. If this operator is not clearly designed,there can be memory leaks due to assignment of dynamic data. For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TFoo{public:    TFoo(char* name, int age);    TFoo(const TFoo&amp;);    // const TFoo&amp; operator=(const TFoo&amp; orig);                    // note missing operator                   // overload                  // operator    ~TFoo();private:    char*    fName;    int    fAge;};TFoo::TFoo(char* name, int age){    fName = new char[strlen(name) + 1];    strcpy(fName,name);    fAge = age;}TFoo::~TFoo(){    delete fName;}TFoo::TFoo(const TFoo&amp; orig){    fAge = orig.fAge;    fName = new char[strlen(orig.fName) + 1];    strcpy(fName, orig.fName);} main(){    // create two objects    TFoo f1(&quot;James&quot;, 25);    TFoo f2(&quot;Michael&quot;, 29);    // do something    f2 = f1;        // this calls the default operator       // = overload, does not take into      // account the dynamic data     // (fName)    return 0;}// The solution is to define an operator=:const TFoo&amp;TFoo::operator=(const TFoo&amp; orig){    // avoid assignment to itself, as in aFoo = aFoo    if(this ==&amp;orig)                // same address?        return *this;    fAge = orig.fAge;    delete fName;                // purge the dynamic memory slot    fName = new char[strlen(orig.fName) + 1];    strcpy(fName,orig.fName);    return *this;</pre>	</TD></TR></TABLE></CENTER><h3>Incorrectly Overloaded Operators</h3><P>In general, try to make overloaded operators return references to objects toavoid overhead associated with calls to copy constructors. So how should youoverload the operators in order to achieve this?</p><P align=center><img src="images/pt_12_003.gif" alt="Figure 3. Correct Overload of Operators." width=320 height=126></p><p align=center><b>Figure 3</b>.  Correct Overload of Operators</p><p>Here's a good solution, we will return a real object instead of a reference inoperator+:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TFoo{public:    TFoo() {}    TFoo(char* name, int age);    TFoo(const TFoo&amp;);    const TFoo&amp; operator=(const TFoo&amp; orig);    ~TFoo();    // here's the example of operator+ overload:    TFoo operator+(const TFoo&amp;);        // return TFoo by value!                            // don't forget to overload +=                            // also!private:    char*    fName;    int    fAge;};TFoo::TFoo(char* name, int age){    fName = new char[strlen(name) + 1];    strcpy(fName,name);    fAge = age;}TFoo::~TFoo(){    delete fName;}TFoo::TFoo(const TFoo&amp; orig){    fAge = orig.fAge;    fName = new char[strlen(orig.fName) + 1];    strcpy(fName, orig.fName);}const TFoo&amp;TFoo::operator=(const TFoo&amp; orig){    // avoid assignment to itself, as in aFoo = aFoo    if(this ==&amp;orig)                // same address?        return *this;    fAge = orig.fAge;    delete fName;                // purge the dynamic memory slot    fName = new char[strlen(orig.fName) + 1];    strcpy(fName,orig.fName);    return *this;}TFooTFoo::operator+(const TFoo&amp; orig){    TFoo temp;                    // create TFoo on the stack    temp.fAge = fAge + orig.fAge;        // add ages, heh!    temp.fName = new char[strlen(fName) + strlen(orig.fName) + 1];    sprintf(temp.fName,&quot;%s%s&quot;, fName, orig.fName);                            // concatenate names, heh!    return temp;}main(){    // create two objects    TFoo f1(&quot;James&quot;, 25);    TFoo f2(&quot;Michael&quot;, 29);    TFoo f3 = f1 + f2;    return 0;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><a name="Section8"></a><h2>Tricks to Help You Find Memory Leaks</h2><p>In general, you need to go through the code carefully and analyze any possiblesubtle memory leaks. Another trick is to override the new and delete operators,and have them print status information to a log file (using for instance the<code>__FILE__</code> and <code>__LINE__</code> macros), and after running the programyou can check to see whether each created data structure on the heap isdeleted or not.</p><p>Here's an example of a possible tracer class, which could be used as the"stamp" for keeping track of class construction and destruction:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include &lt;stream.h&gt;#define TRACEPOINT __FILE__,__LINE__// make use of the ANSI __FILE__ and __LINE__ macrosclass TTracer {public:            TTracer(const char* className, const char* = 0, int = 0);    virtual    ~TTracer();private:    const char*    fLabel;    const char*     fFile;    int        fLine;    static int     fReferenceCount;    // keep track of how many TTracers we   // construct};TTracer::TTracer(const char* label, const char* file, int line) :            fLabel(label), fFile(file), fLine(line){    fReferenceCount++;    cerr     &lt;&lt; &quot;File &quot; &lt;&lt; fFile &lt;&lt;&quot; ; Line &quot; &lt;&lt; fLine        &lt;&lt;&quot;  #+++ constructor event in &quot; &lt;&lt; fLabel        &lt;&lt; &quot; (reference count = &quot; &lt;&lt; fReferenceCount &lt;&lt; &quot;)\n&quot;;}TTracer::~TTracer(){    fReferenceCount--;    cerr     &lt;&lt; &quot;File &quot; &lt;&lt; fFile &lt;&lt;&quot; ; Line &quot; &lt;&lt; fLine        &lt;&lt; &quot;  #--- destructor  event in &quot; &lt;&lt; fLabel        &lt;&lt; &quot; (reference count = &quot; &lt;&lt; fReferenceCount &lt;&lt; &quot;)\n&quot;;}int TTracer::fReferenceCount = 0;        // initialize with 0 valueTTracer gGlobalTracer(&quot;gGlobalTracer&quot;, TRACEPOINT);// this will construct a global/universal tracer// example of use:void InvertPermutation(int* perm, int* inv, int max){    TTracer autoTracer(&quot;InvertPermutation function&quot;, TRACEPOINT);    if(perm &amp;&amp; (new TTracer(&quot;temp&quot;, TRACEPOINT))        // show TTracer in action        &amp;&amp; inv        &amp;&amp; (new TTracer(&quot;temp2&quot;, TRACEPOINT))        // these two are never destructed = memory leak!        &amp;&amp; (max &gt; 0))    {            TTracer otherTracer(&quot;otherTracer&quot;, TRACEPOINT);            for(int i = 0; i &lt; max; i++)            {                TTracer thirdTracer(&quot;iterationTracing...&quot;,TRACEPOINT);                inv[perm[i]] = i;            }    }}// array declarationsint perm [] = {1, 2, 3, 6, 7};int max = 5;main(){    int* inv = new int[max];    InvertPermutation(&amp;perm[0], inv, max);    return 0;</pre>	</TD></TR></TABLE></CENTER><P>The result should look like this (note the output; you can double-click fromMPW to get to the source code line in action):</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>File TTracer.cp ; Line 52  #+++ constructor event  in InvertPermutation function (reference count = 1)File TTracer.cp ; Line 54  #+++ constructor event  in temp (reference count =2)File TTracer.cp ; Line 56  #+++ constructor event  in temp2 (reference count = 3)File TTracer.cp ; Line 59  #+++ constructor event  in otherTracer (reference count = 4)File TTracer.cp ; Line 62  #+++ constructor event  in iterationTracing... (reference count = 5)File TTracer.cp ; Line 62  #--- destructor  event  in iterationTracing... (reference count = 4)File TTracer.cp ; Line 62  #+++ constructor event  in iterationTracing... (reference count = 5)File TTracer.cp ; Line 62  #--- destructor  event  in iterationTracing... (reference count = 4)File TTracer.cp ; Line 62  #+++ constructor event  in iterationTracing... (reference count = 5)File TTracer.cp ; Line 62  #--- destructor  event  in iterationTracing... (reference count = 4)File TTracer.cp ; Line 62  #+++ constructor event  in iterationTracing... (reference count = 5)File TTracer.cp ; Line 62  #--- destructor  event  in iterationTracing... (reference count = 4)File TTracer.cp ; Line 62  #+++ constructor event  in iterationTracing... (reference count = 5)File TTracer.cp ; Line 62  #--- destructor  event  in iterationTracing... (reference count = 4)File TTracer.cp ; Line 59  #--- destructor  event  in otherTracer (reference    count = 3)File TTracer.cp ; Line 52  #--- destructor  event</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><a name="Section9"></a><h2>Virtual Functions</h2><h3>Virtual Base Classes</h3><p>As part of the multiple inheritance semantics, MPW C++ contains a featurecalled <i>virtual base classes</i>. As you can see in figure 4, if both class Band C are subclasses of A, and class D has both B and C as base classes, then Dunfortunately will have two A's subobjects if A is not a virtual base class.</p><p align=center><img src="images/pt_12_004.gif" alt="Figure 4. Virtual Base Classes." width=288 height=209></p><P align=center><b>Figure 4.</b>  Virtual Base Classes</p><p>Try to avoid this confusing situation, because outside programmers might have ahard time trying to understand the new derived class. Also, virtual baseclasses have a problem: once you have a pointer to a virtual base, there is noway to convert it back into a pointer to its enclosing class.</p><p>So, if you have <code>TFoo</code> as a virtual base, and stick this class into anarray or another collection, there's no way to convert it back to the righttype via a cast when you get it out from the generic collection container.*Anyway, you should avoid casting base classes to derived classes if possible.</p><p>Also, see <i>Annotated C++ Reference Manual</i>, Section 10, for moreinformation about virtual base classes.</p><p>*This problem will disappear with future template support.</p><h3>Missing Virtual Functions</h3><p>If you declare a virtual function in a class, you also need to implement thefunction. Otherwise the linker will complain about undefined entry, <code>name:(Error 28) "_ptbl_4TFoo"</code>, for example. This might happen if you define afunction as virtual, but don't create the function until it's part of asubclass.</p><p>The exception to this is pure virtual functions.</p><h3>Virtual Destructor Use</h3><p>Destructors are not implicitly virtual whether the class has other virtualfunctions or not. This means that if you delete such an object via a pointer toone of its bases, the derived class destructors will not be called. This isbad, because it is important to call the right destructor.</p><p>If you wish the right destructor to be called during run-time, declare thedestructor virtual. A good rule is to declare all destructors virtual bydefault, and deviate from this rule only if you don't want to have a vtable(that is, no other virtual functions in the class), or if you want to save somerun-time lookup by providing a simple class.</p><h3>Virtual Functions Are Not Real Functions</h3><p>Virtual functions are references to virtual function resolve to vtable entries.Be aware that they are not similar to normal functions in all cases; forinstance, you can't use them when unloading segments.</p><P>The workaround is to place an empty function stub in the same segment, and usethis function name when calling <code>UnloadSeg</code>.</p><P><A HREF="#top">Back to top</A></p><a name="Section10"></a><h2>Compiler Issues</h2><h3>Declarations</h3><p>The definition of C++ requires that data structures and functions have to bedeclared before they are used.Understanding this should eliminate a lot ofobscure syntax problems. Note that when writing a particular class at thebeginning of the header file  you can use the class before the class isdefined, as in the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TFoo;           // forward declare this classclass TBar{// ...    TFoo* fFooPtr;     // use the class!// ...};Also, if you are using an enum or typedef in the class,it has to be defined before used, as in the following:class TFoo{public://    Constructors/Destructors    TFoo();    const TFoo&amp; TFoo(const TFoo&amp;);    virtual ~TFoo();//    Enums and Typedefs    enum EPriority {kLow, kMedium, kHigh};//    Accessors and mutators    TFoo&amp; SetPriority(EPriority);    EPriority GetPriority();// ...</pre>	</TD></TR></TABLE></CENTER><h3>Exception Handling and Register Optimization</h3><p>The MPW C++/C compiler usually tries to move frequently updated variables toregisters. This is important to know if you are using exception handling,either the MacApp provided calls or something based on setting/restoringregisters after an exception has occurred.</p><p>The following piece of code shows the problem:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>void ProblemCase(void){    int     nCount;    int     nElements;    TFoo*    temp;    TRY    {        for(nCount= 0; nCount &lt; nElements; ++nCount){            temp = new TFoo;            temp-&gt;Initialize();            gApplication-&gt;AddTFoo(temp);        }    }    RECOVER    {        if(temp != NULL) temp-&gt;Free();      // clean up        if(count == 0) ExitApplication()     // exit application    }    ENDTRY</pre>	</TD></TR></TABLE></CENTER><P>In this case the <code>nCount</code> integer  and the <code>temp</code> pointer willmost likely be optimized into a register allocation. If an exception occurswhile the count it updated inside the register, there's no way for theexception handler to roll back the old values, because it assumes the stackbased values are OK. Thus any <code>RECOVER</code> action that assumes that thevalues are OK might not work as expected.</p><p>Unfortunately MPW 3.2 C++ has not implemented the <code>volatile</code> keyword(because it requires a full implementation). However we can emulate thevolatile behavior with a macro. We are interested in making sure the changedvariable is never placed into a register:</p><P>What we need to do is to make sure any possible variable that is subject tochange is wrapped inside the <code>VOLATILE</code> macro before it's used inside<code>TRY/RECOVER </code>, as in:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>// ...    VOLATILE(nCount);    VOLATILE(temp);     TRY    {        for(nCount= 0; nCount &lt; nElements; ++nCount){            temp = new TFoo;</pre>	</TD></TR></TABLE></CENTER><a name="Section11"></a><P><A HREF="#top">Back to top</A></p><h2>Testing/Debugging</h2><h3>General Issues</h3><p>Do empirical testing/debugging sessions; eliminate one module at a time untilyou have pinpointed the problem. Write incremental code, and test the newfeatures before continuing with the code writing.</p><p>Don't change too many variables at once when you  are testing the code. All inall, a controlled test experiment helps you understand how certain partsinteract with each other. If possible, use debugging code that can be turned onand off with a compiler flag.</p><h3>Conclusion</h3><p>Careful consideration of any possible side effects will help a lot when usingany computer language. A good motto for programmers is <i>Prepare for theworst, and plan for the best</i>.</p><a name="References"></a><P><A HREF="#top">Back to top</A></p><h2>References</h2><P>MPW C++ 3.1 Reference</p><P> MPW C++ 3.1 Release Notes</p><P><i>The Annotated C++ Reference Manual,</i> Ellis and Stroustrup,Addison-Wesley</p><P><i>C Traps and Pitfalls,</i> A. Koenig, Addison-Wesley</p>         <a name=Downloads></A>                  <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (96K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pt_12.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pt/pt_12.html%3Fid%3DDTS10002666-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pt/pt_12.html%3Fid%3DDTS10002666-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pt/pt_12.html%3Fid%3DDTS10002666-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>