<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Preparing Code Fragments</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING37></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-36.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-38.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-35.html"><B>Chapter 3 - Programming for the CFM-Based Runtime Architecture </B></A> / <A HREF="RTArch-36.html"><B>Calling the Code Fragment Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING37-0></A>
<H2>Preparing Code Fragments</H2>
 <A NAME=MARKER-2-23></A>If the fragment is an import library that contains a <CODE>'cfrg'0</CODE> resource, you can use the Code Fragment Manager's <CODE>GetSharedLibrary</CODE> function to prepare the fragment. If the fragment is stored in a disk file, you call the <CODE>GetDiskFragment</CODE> function. If the fragment is stored in a resource, you need to place the resource into memory (using normal Resource Manager and Memory Manager routines) and then call the <CODE>GetMemFragment</CODE> function. In general, however, you should avoid storing fragments in resources. Resource-based fragments do not gain the benefits of file-based fragments (such as file mapping directly from the file's data fork), so you should use them only when you have no other choice.<P>
 For complete information about the Code Fragment Manager routines, see <italics>Inside Macintosh: PowerPC System Software<Default \xE8 Font><I></I>. The APIs defined in that book apply for both the PowerPC and CFM-68K implementations. <P>
 In general, the overhead involved in preparing the code fragment and later releasing it is not trivial, so you should avoid closing the connection to a prepared fragment (that is, calling <CODE>CloseConnection</CODE>) until you are finished using it.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>When called to prepare a plug-in, the Code Fragment Manager automatically prepares all the fragments that make up the plug-in's closure. That is, if the plug-in imports symbols from an import library, that library is also prepared; you do not have to explicitly prepare the library.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-24>Listing 3-1</A> shows how to prepare a fragment using <CODE>GetSharedLibrary</CODE>.<P>
<B>Listing 3-1  <A NAME=MARKER-9-24></A>Preparing a fragment using <CODE>GetSharedLibrary</CODE></B><P>
<PRE>
myErr = GetSharedLibrary(myLibName, KPowerPCCFragArch, kPrivateCFragCopy,
                   &amp;myConnID, (Ptr*)&amp;myMainAddr, myErrName);
if (myErr) {
   AlertUser(myErr);
}
</PRE>
 The fragment name is held in <CODE>myLibName</CODE> and it is specified to be a PowerPC fragment. The Code Fragment Manager follows its standard search path to find the library. See <A HREF=RTArch-21.html#MARKER-9-55>"Searching for Import Libraries," beginning on page 1-12</A>, for more information on the search procedure. <P>
 Note that the preparation fails if the preparation of any of the fragments that make up the closure fails. The error term <CODE>myErrName</CODE> then contains the name of the fragment that caused the failure. <P>
 <A NAME=MARKER-2-25></A><A HREF=RTArch-140.html#MARKER-9-27>Listing 3-2</A> show how to prepare a disk-based fragment.<P>
<B>Listing 3-2  <A NAME=MARKER-9-27></A>Preparing a disk-based fragment </B><P>
<PRE>
myErr = GetDiskFragment(&amp;myFSSpec, 0, kCFragGoesToEOF, myToolName, 
               kPrivateCFragCopy, &amp;myConnID, (Ptr*)&amp;myMainAddr, 
               myErrName);
if (myErr) {
   AlertUser(myErr);
}
</PRE>
 <A NAME=MARKER-2-27></A><A HREF=#MARKER-9-28>Listing 3-3</A> shows how to prepare a resource-based fragment.<P>
<B>Listing 3-3  <A NAME=MARKER-9-28></A>Preparing a resource-based fragment</B><P>
<PRE>
Handle         myHandle;
OSErr          myErr;
ConnectionID   myConnID;
Ptr            myMainAddr;
Str255         myErrName;

myHandle = GetResource('tool', 128);
HLock(myHandle);
myErr = GetMemFragment(*myHandle, GetHandleSize(myHandle), 
               myToolName, kPrivateCFragCopy, &amp;myConnID, 
               (Ptr*)&amp;myMainAddr, myErrName);
if (myErr) {
   AlertUser(myErr);
}
</PRE>
 The code in <A HREF=#MARKER-9-28>Listing 3-3</A> places the resource into memory by calling the Resource Manager function <CODE>GetResource</CODE> and locks it by calling the Memory Manager procedure <CODE>HLock</CODE>. Then it calls <CODE>GetMemFragment</CODE> to prepare the fragment. The first parameter passed to <CODE>GetMemFragment</CODE> specifies the memory address of the fragment. Because <CODE>GetResource</CODE> returns a handle to the resource data, <A HREF=#MARKER-9-28>Listing 3-3</A> dereferences the handle to obtain a pointer to the resource data. To avoid dangling pointers, you need to lock the block of memory before calling <CODE>GetMemFragment</CODE>. The constant <CODE>kPrivateCFragCopy</CODE> passed as the fourth parameter requests that the Code Fragment Manager allocate a new copy of the fragment's global data section.<P>
 Like other fragments a resource-based fragment must remain locked in memory and has separate code and data sections. You have access to the connection ID of the resource-based fragment, so you can call Code Fragment Manager routines like <CODE>CloseConnection</CODE> and <CODE>FindSymbol</CODE>. <P>
<DL>
<DT><B>Note</B>
<DD>Some PowerPC executable resources are specially written to model a classic 68K stand-alone code resource. These accelerated resources do not have all the freedom of a true fragment. See <A HREF=RTArch-88.html#MARKER-9-27>"Accelerated and Fat Resources," beginning on page 7-4</A>, for information about how to write and call an accelerated resource.<EM></EM><EM><A NAME=MARKER-2-29></A></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="RTArch-36.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-38.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
