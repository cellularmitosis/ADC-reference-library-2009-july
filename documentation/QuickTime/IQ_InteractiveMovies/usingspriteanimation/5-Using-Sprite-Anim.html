<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Interactive Movies: Using the Sprite Toolbox to Create Sprite Animations</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using the Sprite Toolbox to Create Sprite Animations"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000883-CH209" title="Using the Sprite Toolbox to Create Sprite Animations"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../index.html#//apple_ref/doc/uid/TP30000440-TP30000433" target="_top">QuickTime</a> &gt; <a href="../../WiredMoviesandSprites-date.html#//apple_ref/doc/uid/TP30000440-TP30000433-TP30000594" target="_top">Wired Movies and Sprites</a> &gt; <a href="../preface/QT_Interactive_preface.html#//apple_ref/doc/uid/TP40000883-CH204-DontLinkElementID_69">Interactive Movies</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../authoringwiredmovies/4-Authoring-Wired-Movies.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../flashmediahandler/6-Flash-Media-Handler.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000883-CH209-DontLinkElementID_122" title="Using the Sprite Toolbox to Create Sprite Animations"></a><h1><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCFEAEI" title="Using the Sprite Toolbox to Create Sprite Animations"></a>Using the Sprite Toolbox to Create Sprite Animations</h1><p>This chapter discusses the sprite toolbox and how you can use it to add sprite-based animation to an application. The chapter is aimed at developers who are using the low-level sprite toolbox APIs to create sprite animations in their applications–– <em>not</em> in a QuickTime movie. </p><p>The chapter is divided into these sections: </p><ul class="ul"><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCBICFA">“Overview of Sprite Toolbox”</a></span> provides a brief overview of the sprite toolbox. </p></li><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCJAFEH">“How To Add Sprite-Based Animations to an Application”</a></span> discusses how you can use the sprite toolbox to create sprite worlds and sprite animations. It is divided into a number of topics. </p></li><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCFJGAJ">“Constants and Functions in the Sprite Toolbox”</a></span> describes some of the constants and functions that are useful and available to your application in the sprite toolbox, as well as functions provided by the Movie Toolbox for sprite support. The section is not all-inclusive. For a complete list of functions, refer to the QuickTime API Reference (see bibliography).</p></li></ul><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCBICFA" title="Overview of Sprite Toolbox"></a><h2>Overview of Sprite Toolbox</h2><p>The sprite toolbox is a set of data types and functions you can use to add sprite-based animation to an application. The sprite toolbox handles the following:</p><ul class="ul"><li class="li"><p>invalidating appropriate areas as sprite properties change</p></li><li class="li"><p>the composition of sprites and their background on an offscreen buffer</p></li><li class="li"><p>the transfer of the result to the screen or to an alternate destination. </p></li></ul><p>If you’re authoring an animation outside of a movie, you use the sprite toolbox to create sprite worlds and sprite animations. For more information about the constants and data types available to your application in the sprite toolbox, refer to </p><p>To create a sprite track in a QuickTime movie, you create media samples used by the sprite media handler, which, in turn, makes use of the sprite toolbox. <span class="content_text"><a href="../spritemediahandler/3-Sprite-Media-Handler.html#//apple_ref/doc/uid/TP40000883-CH207-CJBEEIFB">“Chapter 3, Sprite Media Handler,”</a></span> provides information on how to use the sprite media handler. </p><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCJAFEH" title="How To Add Sprite-Based Animations to an Application"></a><h2>How To Add Sprite-Based Animations to an Application</h2><p>The following section discusses how you can use the sprite toolbox to create sprite worlds and sprite animations. It is divided into these topics:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCDAAEH">“Creating and Initializing a Sprite World”</a></span></p></li><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCIGEIH">“Creating and Initializing Sprites”</a></span></p></li><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCIHECF">“Animating Sprites”</a></span></p></li><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCGBAEA">“Disposing of a Sprite Animation”</a></span></p></li><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCIFAJE">“Sprite Hit-Testing”</a></span></p></li><li class="li"><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCHGBJH">“Enhancing Sprite Animation Performance”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCDAAEH" title="Creating and Initializing a Sprite World"></a><h3>Creating and Initializing a Sprite World</h3><p>To create a sprite animation in an application, you first create a sprite world to contain your sprites. To do this, you perform the following steps:</p><ol class="ol"><li class="li"><p>Allocate a sprite layer graphics world that corresponds to the size and bit depth of your destination graphics world.</p></li><li class="li"><p>If you plan to have a background image behind your sprites that is static or that changes infrequently, create a background graphics world that is the same size and depth as the sprite layer graphics world. You do not need to do this if you plan to have a solid background color behind your sprites. Animations that use a solid background color require less memory and perform slightly better than animations that use a background image.</p></li><li class="li"><p>Call <code>LockPixels</code> on the pixel maps of the sprite layer and background graphics worlds. These graphics worlds must remain valid for the lifetime of the sprite world.</p></li><li class="li"><p>Call the <code>NewSpriteWorld</code> function to create the new sprite world.</p></li></ol><p>The sample code function <code>CreateSpriteStuff</code>, shown in <span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCBFFGJ">Listing 5-1</a></span>, calculates the bounds of the destination window and calls <code>NewGWorld</code> to create a new sprite layer graphics world. It then calls <code>LockPixels</code> to lock the pixel map of the sprite layer graphics world.</p><p>Next, <code>CreateSpriteStuff</code> calls <code>NewSpriteWorld</code> to create a new sprite world, passing the destination graphics world (<code>WindowPtr</code>) and the sprite layer graphics world. <code>CreateSpriteStuff</code> passes a background color to <code>NewSpriteWorld</code> instead of specifying a background graphics world. The newly created sprite world is returned in the global variable gSpriteWorld.</p><p>Finally, <code>CreateSpriteStuff</code> calls the sample code function <code>CreateSprites</code> to populate the sprite world with sprites.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-DontLinkElementID_123" title="Listing 5-1Creating a sprite world"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCBFFGJ" title="Listing 5-1Creating a sprite world"></a><strong>Listing 5-1&nbsp;&nbsp;</strong>Creating a sprite world</p><div class="codesample"><table><tr><td scope="row"><pre>// global variables<span></span></pre></td></tr><tr><td scope="row"><pre>GWorldPtr spritePlane = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>SpriteWorld gSpriteWorld = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>Rect gBounceBox;<span></span></pre></td></tr><tr><td scope="row"><pre>RGBColor gBackgroundColor;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void CreateSpriteStuff (Rect *windowBounds, CGrafPtr windowPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect bounds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // calculate the size of the destination<span></span></pre></td></tr><tr><td scope="row"><pre>    bounds = *windowBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    OffsetRect (&amp;bounds, -bounds.left, -bounds.top);<span></span></pre></td></tr><tr><td scope="row"><pre>    gBounceBox = bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    InsetRect (&amp;gBounceBox, 16, 16);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // create a sprite layer graphics world with a bit depth of 16<span></span></pre></td></tr><tr><td scope="row"><pre>    NewGWorld (&amp;spritePlane, 16, &amp;bounds, nil, nil, useTempMem);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (spritePlane == nil)<span></span></pre></td></tr><tr><td scope="row"><pre>        NewGWorld (&amp;spritePlane, 16, &amp;bounds, nil, nil, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (spritePlane)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        LockPixels (spritePlane->portPixMap);<span></span></pre></td></tr><tr><td scope="row"><pre>        gBackgroundColor.red = gBackgroundColor.green =<span></span></pre></td></tr><tr><td scope="row"><pre>            gBackgroundColor.blue = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // create a sprite world<span></span></pre></td></tr><tr><td scope="row"><pre>        err = NewSpriteWorld (&amp;gSpriteWorld, (CGrafPtr)windowPtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                                spritePlane, &amp;gBackgroundColor, nil);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // create sprites<span></span></pre></td></tr><tr><td scope="row"><pre>        CreateSprites ();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCIGEIH" title="Creating and Initializing Sprites"></a><h3>Creating and Initializing Sprites</h3><p>Once you have created a sprite world, you can create sprites within it. To do this, you must first obtain image descriptions and image data for your sprites. This image data may be any image data that has been compressed using QuickTime’s Image Compression Manager.</p><p>You create sprites and add them to your sprite world using the <code>NewSprite</code> function. If you want to create a sprite that is drawn to the background graphics world, you should specify the constant <code>kBackgroundSpriteLayerNum</code> for the <code>layer</code> parameter.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000883-CH209-DontLinkElementID_124" title="Note"></a><p><strong>Note:</strong>&nbsp;The compressed image data must remain locked as long as it is set to be the sprite’s image data. </p></div><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF101" title="Creating Sprites for a Sample Application"></a><h4>Creating Sprites for a Sample Application</h4><p>The sample code function <code>CreateSprites</code>, shown in <span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCCGDFA">Listing 5-2</a></span>, creates the sprites for the sample application shown in <span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCBFFGJ">Listing 5-1</a></span>. </p><p>First, the function initializes some global arrays with position and image information for the sprites. Next, <code>CreateSprites</code> iterates through all the sprite images, preparing each image for display. For each image, <code>CreateSprites</code> calls the sample code function <code>MakePictTransparent</code> function, which strips any surrounding background color from the image. <code>MakePictTransparent</code> does this by using the animation compressor to recompress the PICT images using a key color. Then, <code>CreateSprites</code> calls <code>ExtractCompressData</code>, which extracts the compressed data from the PICT image. This is one technique for creating compressed images; there are other, more optimized ways to store and retrieve sprite images.</p><p>Once the images have been prepared, <code>CreateSprites</code> calls <code>NewSprite</code> to create each sprite in the sprite world. <code>CreateSprites</code> creates each sprite in a different layer. </p><a name="//apple_ref/doc/uid/TP40000883-CH209-DontLinkElementID_125" title="Listing 5-2Creating sprites"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCCGDFA" title="Listing 5-2Creating sprites"></a><strong>Listing 5-2&nbsp;&nbsp;</strong>Creating sprites</p><div class="codesample"><table><tr><td scope="row"><pre>// constants<span></span></pre></td></tr><tr><td scope="row"><pre>#define kNumSprites 4<span></span></pre></td></tr><tr><td scope="row"><pre>#define kNumSpaceShipImages 24<span></span></pre></td></tr><tr><td scope="row"><pre>#define kBackgroundPictID 158<span></span></pre></td></tr><tr><td scope="row"><pre>#define kFirstSpaceShipPictID (kBackgroundPictID + 1)<span></span></pre></td></tr><tr><td scope="row"><pre>#define kSpaceShipWidth 106<span></span></pre></td></tr><tr><td scope="row"><pre>#define kSpaceShipHeight 80<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// global variables<span></span></pre></td></tr><tr><td scope="row"><pre>SpriteWorld gSpriteWorld = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>Sprite gSprites[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>Rect gDestRects[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>Point gDeltas[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>short gCurrentImages[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>Handle gCompressedPictures[kNumSpaceShipImages];<span></span></pre></td></tr><tr><td scope="row"><pre>ImageDescriptionHandle gImageDescriptions[kNumSpaceShipImages];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void CreateSprites (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    long i;<span></span></pre></td></tr><tr><td scope="row"><pre>    Handle compressedData = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    PicHandle picture;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGrafPtr savePort;<span></span></pre></td></tr><tr><td scope="row"><pre>    GDHandle saveGD;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>    RGBColor keyColor;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetRect (&amp;gDestRects[0], 132, 132, 132 + kSpaceShipWidth,<span></span></pre></td></tr><tr><td scope="row"><pre>        132 + kSpaceShipHeight);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetRect (&amp;gDestRects[1], 50, 50, 50 + kSpaceShipWidth,<span></span></pre></td></tr><tr><td scope="row"><pre>        50 + kSpaceShipHeight);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetRect (&amp;gDestRects[2], 100, 100, 100 + kSpaceShipWidth,<span></span></pre></td></tr><tr><td scope="row"><pre>        100 + kSpaceShipHeight);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetRect (&amp;gDestRects[3], 130, 130, 130 + kSpaceShipWidth,<span></span></pre></td></tr><tr><td scope="row"><pre>        130 + kSpaceShipHeight);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    gDeltas[0].h = -3;<span></span></pre></td></tr><tr><td scope="row"><pre>    gDeltas[0].v = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    gDeltas[1].h = -5;<span></span></pre></td></tr><tr><td scope="row"><pre>    gDeltas[1].v = 3;<span></span></pre></td></tr><tr><td scope="row"><pre>    gDeltas[2].h = 4;<span></span></pre></td></tr><tr><td scope="row"><pre>    gDeltas[2].v = -6;<span></span></pre></td></tr><tr><td scope="row"><pre>    gDeltas[3].h = 6;<span></span></pre></td></tr><tr><td scope="row"><pre>    gDeltas[3].v = 4;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    gCurrentImages[0] = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    gCurrentImages[1] = kNumSpaceShipImages / 4;<span></span></pre></td></tr><tr><td scope="row"><pre>    gCurrentImages[2] = kNumSpaceShipImages / 2;<span></span></pre></td></tr><tr><td scope="row"><pre>    gCurrentImages[3] = kNumSpaceShipImages * 4 / 3;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    keyColor.red = keyColor.green = keyColor.blue = 0xFFFF;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // recompress PICT images to make them transparent<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i = 0; i &lt; kNumSpaceShipImages; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        picture = (PicHandle) GetPicture (i + kFirstSpaceShipPictID);<span></span></pre></td></tr><tr><td scope="row"><pre>        DetachResource ((Handle)picture);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        MakePictTransparent (picture, &amp;keyColor);<span></span></pre></td></tr><tr><td scope="row"><pre>        ExtractCompressData (picture, &amp;gCompressedPictures[i],<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;gImageDescriptions[i]);<span></span></pre></td></tr><tr><td scope="row"><pre>        HLock (gCompressedPictures[i]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        KillPicture (picture);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // create the sprites for the sprite world<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i = 0; i &lt; kNumSprites; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        MatrixRecord matrix;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        SetIdentityMatrix (&amp;matrix);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        matrix.matrix[2][0] = ((long)gDestRects[i].left &lt;&lt; 16);<span></span></pre></td></tr><tr><td scope="row"><pre>        matrix.matrix[2][1] = ((long)gDestRects[i].top &lt;&lt; 16);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        err = NewSprite (&amp;(gSprites[i]), gSpriteWorld,<span></span></pre></td></tr><tr><td scope="row"><pre>            gImageDescriptions[i],* gCompressedPictures[i],<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;matrix, true, i);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCIHECF" title="Animating Sprites"></a><h3>Animating Sprites</h3><p>To animate a sprite, you use the <code>SetSpriteProperty</code> function to change one or more of the sprite’s properties, such as its matrix, layer, or image data. In addition to modifying a property, <code>SetSpriteProperty</code> invalidates the appropriate areas of the sprite’s sprite world.</p><p>The <code>SpriteWorldIdle</code> function is responsible for redrawing a sprite world’s invalid regions. Your application should call this function after modifying sprite properties to give the sprite world the opportunity to redraw.</p><p><span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCCJIGI">Listing 5-3</a></span> shows the sample application’s <code>main</code> function. It performs all of the application’s initialization tasks, including initializing the sprite world and its sprites. It displays the window and loops until the user clicks the button in the window. To perform the animation, <code>main</code> calls the sample code function <code>MoveSprites</code> each time through the loop, to modify the properties of the sprites, and then calls <code>SpriteWorldIdle</code> to give the sprite world the opportunity to redraw its invalid areas.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-DontLinkElementID_126" title="Listing 5-3The main function"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCCJIGI" title="Listing 5-3The main function"></a><strong>Listing 5-3&nbsp;&nbsp;</strong>The <code>main</code> function</p><div class="codesample"><table><tr><td scope="row"><pre>// global variables<span></span></pre></td></tr><tr><td scope="row"><pre>SpriteWorld gSpriteWorld = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void main (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    // initialize everything and create a window<span></span></pre></td></tr><tr><td scope="row"><pre>    // create a sprite world and the sprites in it<span></span></pre></td></tr><tr><td scope="row"><pre>    // show the window<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    CreateSpriteStuff(...);<span></span></pre></td></tr><tr><td scope="row"><pre>    while (!Button())<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // animate the sprites<span></span></pre></td></tr><tr><td scope="row"><pre>        MoveSprites ();<span></span></pre></td></tr><tr><td scope="row"><pre>        SpriteWorldIdle (gSpriteWorld, 0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    // dispose of the sprite world and its sprites<span></span></pre></td></tr><tr><td scope="row"><pre>    // shut down everything else<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeEverything();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>MoveSprites</code> function, shown in <span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCBIBCJ">Listing 5-4</a></span>, is responsible for modifying the properties of the sprites. For each sprite, the function calls <code>SetSpriteProperty</code> twice, once to change the sprite’s matrix and once to change the sprite’s image data pointer. </p><a name="//apple_ref/doc/uid/TP40000883-CH209-DontLinkElementID_127" title="Listing 5-4Animating sprites"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCBIBCJ" title="Listing 5-4Animating sprites"></a><strong>Listing 5-4&nbsp;&nbsp;</strong>Animating sprites</p><div class="codesample"><table><tr><td scope="row"><pre>// constants<span></span></pre></td></tr><tr><td scope="row"><pre>#define kNumSprites 4<span></span></pre></td></tr><tr><td scope="row"><pre>#define kNumSpaceShipImages 24<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// global variables<span></span></pre></td></tr><tr><td scope="row"><pre>Rect gBounceBox;<span></span></pre></td></tr><tr><td scope="row"><pre>Sprite gSprites[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>Rect gDestRects[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>Point gDeltas[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>short gCurrentImages[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>Handle gCompressedPictures[kNumSpaceShipImages];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MoveSprites (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    short i;<span></span></pre></td></tr><tr><td scope="row"><pre>    MatrixRecord matrix;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetIdentityMatrix (&amp;matrix);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // for each sprite<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i = 0; i &lt; kNumSprites; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // modify the sprite’s matrix<span></span></pre></td></tr><tr><td scope="row"><pre>        OffsetRect (&amp;gDestRects[i], gDeltas[i].h, gDeltas[i].v);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if ( (gDestRects[i].right >= gBounceBox.right) ||<span></span></pre></td></tr><tr><td scope="row"><pre>            (gDestRects[i].left &lt;= gBounceBox.left) )<span></span></pre></td></tr><tr><td scope="row"><pre>            gDeltas[i].h = -gDeltas[i].h;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if ( (gDestRects[i].bottom >= gBounceBox.bottom) ||<span></span></pre></td></tr><tr><td scope="row"><pre>            (gDestRects[i].top &lt;= gBounceBox.top) )<span></span></pre></td></tr><tr><td scope="row"><pre>            gDeltas[i].v = -gDeltas[i].v;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        matrix.matrix[2][0] = ((long)gDestRects[i].left &lt;&lt; 16);<span></span></pre></td></tr><tr><td scope="row"><pre>        matrix.matrix[2][1] = ((long)gDestRects[i].top &lt;&lt; 16);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        SetSpriteProperty (gSprites[i], kSpritePropertyMatrix, &amp;matrix);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // change the sprite’s image<span></span></pre></td></tr><tr><td scope="row"><pre>        gCurrentImages[i]++;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (gCurrentImages[i] >= (kNumSpaceShipImages * (i+1)))<span></span></pre></td></tr><tr><td scope="row"><pre>            gCurrentImages[i] = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        SetSpriteProperty (gSprites[i], kSpritePropertyImageDataPtr,<span></span></pre></td></tr><tr><td scope="row"><pre>            *gCompressedPictures[gCurrentImages[i] / (i+1)] );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCGBAEA" title="Disposing of a Sprite Animation"></a><h3>Disposing of a Sprite Animation</h3><p>When your application has finished displaying a sprite animation, you should do the following things in the order shown:</p><ol class="ol"><li class="li"><p>Dispose of the sprite world associated with the animation. (You need to do this first.) Disposing of a sprite world automatically destroys the sprites in the sprite world.</p></li><li class="li"><p>Dispose of the sprite image data. </p></li><li class="li"><p>Dispose of graphics worlds associated with the sprite animation.</p></li></ol><p>In the sample application, <code>main</code> calls the sample code function <code>DisposeEverything</code> to dispose of sprite-related structures. This function, shown in <span class="content_text"><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCCCGBC">Listing 5-5</a></span>, iterates through the sprites, disposing of each sprite’s image data. Then, <code>DisposeEverything</code> calls <code>DisposeSpriteWorld</code> to dispose of the sprite world and all of the sprites in it. Finally, the function calls <code>DisposeGWorld</code> to dispose of the graphics world associated with the sprite world.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-DontLinkElementID_128" title="Listing 5-5Disposing of sprites and the sprite world"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCCCGBC" title="Listing 5-5Disposing of sprites and the sprite world"></a><strong>Listing 5-5&nbsp;&nbsp;</strong>Disposing of sprites and the sprite world</p><div class="codesample"><table><tr><td scope="row"><pre>// constants<span></span></pre></td></tr><tr><td scope="row"><pre>#define kNumSprites 4<span></span></pre></td></tr><tr><td scope="row"><pre>#define kNumSpaceShipImages 24<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// global variables<span></span></pre></td></tr><tr><td scope="row"><pre>SpriteWorld gSpriteWorld = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>Sprite gSprites[kNumSprites];<span></span></pre></td></tr><tr><td scope="row"><pre>Handle gCompressedPictures[kNumSpaceShipImages];<span></span></pre></td></tr><tr><td scope="row"><pre>ImageDescriptionHandle gImageDescriptions[kNumSpaceShipImages];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void DisposeEverything (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    short i;<span></span></pre></td></tr><tr><td scope="row"><pre>    // dispose of the sprite world and associated graphics world<span></span></pre></td></tr><tr><td scope="row"><pre>    if (gSpriteWorld)<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeSpriteWorld (gSpriteWorld);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // dispose of each sprite’s image data<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i = 0; i &lt; kNumSprites; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (gCompressedPictures[i])<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeHandle (gCompressedPictures[i]);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (gImageDescriptions[i])<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeHandle ((Handle)gImageDescriptions[i]);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeGWorld (spritePlane);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCIFAJE" title="Sprite Hit-Testing"></a><h3>Sprite Hit-Testing</h3><p>The sprite toolbox provides two functions for performing hit-testing operations with sprites, <code>SpriteWorldHitTest</code> and <code>SpriteHitTest</code>.</p><p>The <code>SpriteWorldHitTest</code> function determines whether any sprites exist at a specified location in a sprite world’s display coordinate system. This function retrieves the frontmost sprite at the specified location.</p><p>The <code>SpriteHitTest</code> function determines whether a particular sprite exists at a specified location in the sprite’s display coordinate system. This function is useful for hit-testing a subset of the sprites in a sprite world and for detecting multiple sprites at a single location.</p><p>For either hit-test function, there are two flags, <code>spriteHitTestBounds</code> and <code>spriteHitTestImage</code>, that control the hit-test operation. For example, you set the <code>spriteHitTestBounds</code> flag to check if there has been a hit anywhere within the sprite’s bounding box, and you set the <code>spriteHitTestImage </code>flag to check if there has been a hit anywhere within the sprite image.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF102" title="Hit-Testing Flags"></a><h4>Hit-Testing Flags</h4><p>The following hit-testing flags are used with both the sprite toolbox and the movie sprite track hit-testing routines: </p><ul class="spaceabove"><li class="li"><p><code>spriteHitTestInvisibleSprites</code>, which you set if you want invisible sprites to be hit-tested along with visible ones.</p></li><li class="li"><p><code>spriteHitTestLocInDisplayCoordinates</code>, which you set if the hit-testing point is in display coordinates instead of local sprite track coordinates.</p></li><li class="li"><p><code>spriteHitTestIsClick</code>, which you set if you want the hit-testing operation to pass a click on to the codec currently rendering the sprites image. For example, this can be used to make the Ripple Codec ripple.</p></li></ul><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCHGBJH" title="Enhancing Sprite Animation Performance"></a><h3>Enhancing Sprite Animation Performance</h3><p>To achieve the best performance for your sprite animation, you should observe the following guidelines when creating a sprite world:</p><ul class="spaceabove"><li class="li"><p>When you create a graphics world to be used for your sprite world, you achieve the best performance if the graphics world’s dimensions are a multiple of 16 pixels.</p></li><li class="li"><p>Your sprite layer graphics world and background graphics world should both be the same size and depth as the destination of your sprite animation.</p></li><li class="li"><p>Use translation-only matrices for creating sprite worlds and sprites.</p></li><li class="li"><p>Do not set a clipping region for your sprite world.</p></li><li class="li"><p>Call the <code>SpriteWorldIdle</code> function frequently.</p></li><li class="li"><p>Avoid clipping sprites with the sprite world boundary.</p></li><li class="li"><p>Use the Animation compressor to create sprites with transparent areas.</p></li></ul><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCFJGAJ" title="Constants and Functions in the Sprite Toolbox"></a><h2>Constants and Functions in the Sprite Toolbox</h2><p>This section describes some of the constants and functions that are useful and available to your application in the sprite toolbox. It also describes functions provided by the Movie Toolbox for sprite support. The section is not all-inclusive. For a complete list of functions, refer to the <em>QuickTime API Referenc</em>e (see bibliography). </p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF103" title="Constants"></a><h3>Constants</h3><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF104" title="Background Sprites"></a><h4>Background Sprites</h4><p>You assign the following constant to a sprite’s <code>kSpritePropertyLayer</code> property to designate the sprite as a background sprite.</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    kBackgroundSpriteLayerNum   = 32767<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF105" title="Flags for Sprite Hit-Testing"></a><h4>Flags for Sprite Hit-Testing</h4><p>You can pass the following flags to control sprite hit-testing.</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    spriteHitTestBounds                 = 1L &lt;&lt; 0,<span></span></pre></td></tr><tr><td scope="row"><pre>    spriteHitTestImage                  = 1L &lt;&lt; 1<span></span></pre></td></tr><tr><td scope="row"><pre>    spriteHitTestInvisibleSprites       = 1L &lt;&lt; 2,<span></span></pre></td></tr><tr><td scope="row"><pre>    spriteHitTestIsClick                = 1L &lt;&lt; 3,<span></span></pre></td></tr><tr><td scope="row"><pre>    spriteHitTestLocInDisplayCoordinates  = 1L &lt;&lt; 4<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><dl class="termdef">	<dt><code>spriteHitTestBounds</code></dt><dd><p>The specified location must be within the sprite’s bounding box.</p></dd><dt><code>spriteHitTestImage</code><a name="//apple_ref/doc/uid/TP40000883-CH209-DontLinkElementID_276"></a></dt><dd><p>If both this flag and <code>spriteHitTestBounds</code> are set, the specified location must be within the shape of the sprite’s image.</p></dd><dt><code>spriteHitTestInvisibleSprites</code></dt><dd><p>This flag enables invisible sprites to be hit-tested. </p></dd><dt><code>spriteHitTestIsClick</code></dt><dd><p>This flag is for codecs that want mouse events, such as the ripple codec.</p></dd><dt><code>spriteHitTestLocInDisplayCoordinates</code></dt><dd><p>You set this flag if you want to pass a display coordinate point to <code>SpriteHitTest</code>, such as returned by the Mac OS Toolbox routine <code>getMouse</code>. </p></dd></dl><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF106" title="Sprite Properties"></a><h3>Sprite Properties</h3><p>The following constants represent the different properties of a sprite. When you call <code><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCJGEFG">SetSpriteProperty</a></code> to set a sprite property, you pass one of these constants to specify the property you wish to modify.</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyMatrix                   = 1,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyImageDescription         = 2,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyImageDataPtr             = 3,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyVisible                  = 4,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyLayer                    = 5,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyGraphicsMode             = 6,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyImageIndex               = 100<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><dl class="termdef">	<dt><code>kSpritePropertyMatrix</code></dt><dd><p>A matrix of type <code>MatrixRecord</code> that defines the sprite’s display coordinate system.</p></dd><dt><code>kSpritePropertyImageDescription</code></dt><dd><p>An image description handle that describes the sprite’s image data. This must be valid as long as the sprite uses it. The caller owns the storage. The sprite toolbox does not copy this data. </p></dd><dt><code>kSpritePropertyImageDataPtr</code></dt><dd><p>A pointer to the sprite’s image data. This must be valid as long as the sprite uses it. The caller owns the storage. The sprite toolbox does not copy this data. </p></dd><dt><code>kSpritePropertyVisible</code></dt><dd><p>A Boolean value that indicates whether the sprite is visible.</p></dd><dt><code>kSpritePropertyLayer</code></dt><dd><p>A <code>short</code> integer value that defines the sprite’s layer. You set this property to <code>kBackgroundSpriteLayerNum</code> to designate the sprite as a background sprite.</p></dd><dt><code>kSpritePropertyGraphicsMode</code></dt><dd><p>A <code>ModifierTrackGraphicsModeRecord</code> value that specifies the graphics mode to be used when drawing the sprite.</p></dd><dt><code>kSpritePropertyImageIndex</code></dt><dd><p>In a sprite track, the index of the sprite’s image in the pool of shared images.</p></dd></dl><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF107" title="Flags for SpriteWorldIdle"></a><h3>Flags for SpriteWorldIdle</h3><p>You can pass the following flags as input to <code><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCFCEFE">SpriteWorldIdle</a></code> to control drawing of the sprite world.</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    kOnlyDrawToSpriteWorld  = 1L &lt;&lt; 0,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpriteWorldPreFlight   = 1L &lt;&lt; 1<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><dl class="termdef">	<dt><code>kOnlyDrawToSpriteWorld</code></dt><dd><p>You set this flag to indicate that drawing should take place in the sprite world only; drawing to the final destination should be suppressed.</p></dd><dt><code>kSpriteWorldPreFlight</code></dt><dd><p>You can set this flag to determine whether the sprite world has any invalid areas that need to be drawn. If so, the <code>SpriteWorldIdle</code> function returns the <code>kSpriteWorldNeedsToDraw</code> flag in the <code>flagsOut</code> parameter.</p></dd></dl><p></p><p>The following flags may be returned in the <code>flagsOut</code> parameter of <code><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCFCEFE">SpriteWorldIdle</a></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpriteWorldDidDraw         = 1L &lt;&lt; 0,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpriteWorldNeedsToDraw     = 1L &lt;&lt; 1<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><dl class="termdef">	<dt><code>kSpriteWorldDidDraw</code></dt><dd><p>If set, this flag indicates that <code>SpriteWorldIdle</code> updated the sprite world.</p></dd><dt><code>kSpriteWorldNeedsToDraw</code></dt><dd><p>If set, this flag indicates that the sprite world has invalid areas that need to be drawn.</p></dd></dl><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF108" title="Sprite and Sprite World Identifiers"></a><h3>Sprite and Sprite World Identifiers</h3><p>The sprite world and sprite data structures are private data structures. You identify a sprite world or a sprite data structure to the sprite toolbox by means of a data type that is supplied by the sprite toolbox. The following data types are currently defined:</p><dl class="termdef">	<dt><code>Sprite</code></dt><dd><p>Specifies the sprite for an operation. Your application obtains a sprite identifier when you create a new sprite by calling <code><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCGGFGE">NewSprite</a></code>.</p></dd><dt><code>SpriteWorld</code></dt><dd><p>Specifies the sprite world for an operation. Your application obtains a sprite world identifier when you create a sprite world by calling NewSpriteWorld .</p></dd></dl><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF109" title="Useful Sprite Toolbox Functions"></a><h3>Useful Sprite Toolbox Functions</h3><p>This section describes the functions provided by the Movie Toolbox for sprite support. It also describes some of the functions that you can use to create and manipulate sprites and sprite worlds.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF110" title="NewSpriteWorld"></a><h4>NewSpriteWorld</h4><p>You call the <code>NewSpriteWorld</code> function to create a new sprite world with associated destination and sprite layer graphics worlds, and either a background color or a background graphics world. Once created, you can manipulate the sprite world and add sprites to it using other sprite toolbox functions. The sprite world created by this function has an identity matrix. The sprite world does not have a clip shape.</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr NewSpriteWorld (SpriteWorld *newSpriteWorld,                             GWorldPtrdestination,                             GWorldPtr spriteLayer,<span></span></pre></td></tr><tr><td scope="row"><pre>                            RGBColor *backgroundColor,<span></span></pre></td></tr><tr><td scope="row"><pre>                            GWorldPtr background);<span></span></pre></td></tr></table></div><p>The <code>newSpriteWorld</code>, <code>destination</code>, and <code>spriteLayer</code> parameters are all required. You should specify a background color, a background graphics world, or both. You should not pass <code>nil</code> for both parameters. If you specify both a background graphics world and a background color, the sprite world is filled with the background color before the background sprites are drawn. If no background color is specified, black is the default. If you specify a background graphics world, it should have the same dimensions and depth as the graphics world specified by <code>spriteLayer</code>. If you draw to the graphics worlds associated with a sprite world using standard QuickDraw and QuickTime functions, your drawing is erased by the sprite world’s background color.</p><p>Before calling <code>NewSpriteWorld</code>, you should call <code>LockPixels</code> on the pixel maps of the sprite layer and background graphics worlds. These graphics worlds must remain valid and locked for the lifetime of the sprite world. The sprite world does not own the graphics worlds that are associated with it; it is the caller’s responsibility to dispose of the graphics worlds when they are no longer needed.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF111" title="DisposeSpriteWorld"></a><h4>DisposeSpriteWorld</h4><p>You call the <code>DisposeSpriteWorld</code> function to dispose of a sprite world created by the <code>NewSpriteWorld</code> function. This function also disposes of all of the sprites associated with the sprite world. This function does not dispose of the graphics worlds associated with the sprite world. It is safe to pass <code>nil</code> to this function.</p><div class="codesample"><table><tr><td scope="row"><pre>pascal void DisposeSpriteWorld  (SpriteWorld theSpriteWorld);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF112" title="SetSpriteWorldClip"></a><h4>SetSpriteWorldClip</h4><p>You call the <code>SetSpriteWorldClip</code> function to change the clip shape of a sprite world. You may pass a value of <code>nil</code> for the <code>clipRgn</code> parameter to indicate that there is no longer a clip shape for the sprite world. This means that the whole area is drawn. </p><p>The clip shape should be specified in the sprite world’s source space, the coordinate system of the sprite layer’s graphics world before the sprite world’s matrix is applied to it. The specified region is owned by the caller and is not copied by this function.</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr SetSpriteWorldClip (SpriteWorld theSpriteWorld, RgnHandle                                 clipRgn);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF113" title="SetSpriteWorldMatrix"></a><h4>SetSpriteWorldMatrix</h4><p>You call the <code>SetSpriteWorldMatrix</code> function function to change the matrix of a sprite world. You may pass a value of <code>nil</code> for the <code>matrix</code> parameter to set the sprite world’s matrix to an identity matrix. Transformations, including translation, scaling, rotation, skewing, and perspective, are all supported in QuickTime. </p><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCFCEFE" title="SpriteWorldIdle"></a><h4>SpriteWorldIdle</h4><p>You call the <code>SpriteWorldIdle</code> function function to allow a sprite world the opportunity to redraw its invalid areas. This is the only function that causes drawing to occur; you should call it as often as is necessary.</p><p>The <code>flagsIn</code> parameter contains flags that describe allowable actions during the idle period. For the default behavior, you should set the value of this parameter to 0. The <code>flagsOut</code> parameter is optional; if you do not need the information returned by this parameter, set the value of this parameter to <code>nil</code>.</p><p>Typically, you would make changes in perspective for a number of sprites and then call <code>SpriteWorldIdle</code> to redraw the changed sprites. </p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF114" title="InvalidateSpriteWorld"></a><h4>InvalidateSpriteWorld</h4><p>Typically, your application calls the <code>InvalidateSpriteWorld</code> function function when the sprite world’s destination window receives an update event. Invalidating an area of the sprite world will cause the area to be redrawn the next time that <code>SpriteWorldIdle</code> is called.</p><p>The invalid rectangle pointed to by the <code>invalidArea</code> parameter should be specified in the sprite world’s source space, the coordinate system of the sprite layer’s graphics world before the sprite world’s matrix is applied to it. To invalidate the entire sprite world, pass <code>nil</code> for this parameter.</p><p>When you modify sprite properties, invalidation takes place automatically; you do not need to call <code>InvalidateSpriteWorld</code>.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF115" title="SpriteWorldHitTest"></a><h4>SpriteWorldHitTest</h4><p>You call the <code>SpriteWorldHitTest</code> function to determine whether any sprites exist at a specified location in a sprite world’s display coordinate system. If you are drawing the sprite world in a window, you should call <code>GlobalToLocal</code> to convert the location to your window’s local coordinate system before passing it to <code>SpriteWorldHitTest</code>.</p><p>You use the <code>spriteHitTestBounds</code> and <code>spriteHitTestImage</code> flags in the <code>flags</code> parameter to control the hit-test operation. Set the <code>spriteHitTestBounds</code> flag to check if there has been a hit anywhere within the sprite’s bounding box. Set the <code>spriteHitTestImage</code> flag to check if there has been a hit anywhere within the sprite image. </p><p>A hit-testing operation does not occur unless you pass one of the flags, either <code>SpriteHitTestBound</code> or <code>SpriteHitTestImage</code>. You can add other flags as needed. </p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF116" title="DisposeAllSprites"></a><h4>DisposeAllSprites</h4><p>The <code>DisposeAllSprites</code> function disposes all sprites associated with a sprite world.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCGGFGE" title="NewSprite"></a><h4>NewSprite</h4><p>You call the <code>NewSprite</code> function to create a new sprite associated with a sprite world. Once you have created the sprite, you can manipulate it using <code><a href="5-Using-Sprite-Anim.html#//apple_ref/doc/uid/TP40000883-CH209-BBCJGEFG">SetSpriteProperty</a></code>.</p><p>The <code>newSprite</code>, <code>itsSpriteWorld</code>, <code>visible</code>, and <code>layer</code> parameters are required. Sprites with lower layer values appear in front of sprites with higher layer values. If you want to create a sprite that is drawn to the background graphics world, you should specify the constant <code>kBackgroundSpriteLayerNum</code> for the <code>layer</code> parameter.</p><p>You can defer assigning image data to the sprite by passing <code>nil</code> for both the <code>idh</code> and <code>imageDataPtr</code> parameters. If you choose to defer assigning image data, you must call <code>SetSpriteProperty</code> to assign the image description handle and image data to the sprite before the next call to <code>SpriteWorldIdle</code>. The caller owns the image description handle and the image data pointer; it is the caller’s responsibility to dispose of them after it disposes of a sprite.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF117" title="DisposeSprite"></a><h4>DisposeSprite</h4><p>You call the <code>DisposeSprite</code> function to dispose of a sprite created by the <code>NewSprite</code> function. The image description handle and image data pointer associated with the sprite are not disposed by this function.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF118" title="InvalidateSprite"></a><h4>InvalidateSprite</h4><p>The <code>InvalidateSprite</code> function invalidates the portion of a sprite’s sprite world that is occupied by the sprite.</p><div class="codesample"><table><tr><td scope="row"><pre>pascal void InvalidateSprite  (Sprite theSprite);<span></span></pre></td></tr></table></div><p>In most cases, you don’t need to call this function. When you call the <code>SetSpriteProperty</code> function to modify a sprite’s properties, <code>SetSpriteProperty</code> takes care of invalidating the appropriate regions of the sprite world. However, you might call this function if you change a sprite’s image data, but retain the same image data pointer.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF119" title="SpriteHitTest"></a><h4>SpriteHitTest</h4><p>The <code>SpriteHitTest</code> function determines whether a location in a sprite’s display coordinate system intersects the sprite. You call this function to determine whether a sprite exists at a specified location in the sprite’s display coordinate system. This function is useful for hit-testing a subset of the sprites in a sprite world and for detecting multiple hits for a single location.</p><p>You should apply the sprite world’s matrix to the location before passing it to <code>SpriteHitTest</code>. To convert a location to local coordinates, you should use the <code>GlobalToLocal</code> function to convert the location to your window’s local coordinate system and then apply the inverse of the sprite world’s matrix to the location.</p><p>You use the <code>spriteHitTestBounds</code> and <code>spriteHitTestImage</code> flags in the <code>flags</code> parameter to control the hit-test operation. Set the <code>spriteHitTestBounds</code> flag to check if there has been a hit anywhere within the sprite’s bounding box. Set the <code>spriteHitTestImage</code> flag to check if there has been a hit anywhere within the sprite image. </p><a name="//apple_ref/doc/uid/TP40000883-CH209-TPXREF120" title="GetSpriteProperty"></a><h4>GetSpriteProperty</h4><p>The <code>GetSpriteProperty</code> function retrieves the value of the specified sprite property. You call this function to retrieve a value of a sprite property. You set the <code>propertyType</code> parameter to the property you want to retrieve. The following table lists the sprite properties and the data types of the corresponding property values.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sprite Property</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Data Type</p></th></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyMatrix<!--/a--></code></p></td><td ><p>MatrixRecord</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyImageDescription<!--/a--></code></p></td><td ><p>ImageDescriptionHandle</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyImageDataPtr<!--/a--></code></p></td><td ><p>Ptr</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyVisible<!--/a--></code></p></td><td ><p>Boolean</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyLayer<!--/a--></code></p></td><td ><p>short</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyGraphicsMode<!--/a--></code></p></td><td ><p>ModifierTrackGraphicsModeRecord</p></td></tr></table></div><p>In the case of the <code>kSpritePropertyImageDescription</code> and <code>kSpritePropertyImageDataPtr</code> properties, this function does not return a copy of the data; rather, the pointers returned are references to the sprite’s data.</p><a name="//apple_ref/doc/uid/TP40000883-CH209-BBCJGEFG" title="SetSpriteProperty"></a><h4>SetSpriteProperty</h4><p>The <code>SetSpriteProperty</code> function sets the specified property of a sprite. You animate a sprite by modifying its properties. You call this function to modify a property of a sprite. This function invalidates the sprite’s sprite world as needed.</p><p>You set the <code>propertyType</code> parameter to the property you want to modify. Depending on the property type, you set the <code>propertyValue</code> parameter to either a pointer to the property value or the property value itself, cast as a <code>void*</code>. </p><p>The following table lists the sprite properties and the data types of the corresponding property values.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sprite Property</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Data Type</p></th></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyMatrix<!--/a--></code></p></td><td ><p>MatrixRecord *</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyImageDescription<!--/a--></code></p></td><td ><p>ImageDescriptionHandle</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyImageDataPtr<!--/a--></code></p></td><td ><p>Ptr</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyVisible<!--/a--></code></p></td><td ><p>Boolean</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyLayer<!--/a--></code></p></td><td ><p>short</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kSpritePropertyGraphicsMode<!--/a--></code></p></td><td ><p>ModifierTrackGraphicsModeRecord *</p></td></tr></table></div><p></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../authoringwiredmovies/4-Authoring-Wired-Movies.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../flashmediahandler/6-Flash-Media-Handler.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2002 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2002-10-01<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/IQ_InteractiveMovies/usingspriteanimation/5-Using-Sprite-Anim.html%3Fid%3DTP40000883-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/IQ_InteractiveMovies/usingspriteanimation/5-Using-Sprite-Anim.html%3Fid%3DTP40000883-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/IQ_InteractiveMovies/usingspriteanimation/5-Using-Sprite-Anim.html%3Fid%3DTP40000883-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>