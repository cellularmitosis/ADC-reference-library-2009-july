<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Optimization TN Demos - /CBuffFileStream/CBuffFileStream.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">Optimization TN Demos</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Optimization TN Demos</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CBuffFileStream/CBuffFileStream.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CBuffFileStream/CBuffFileStream.c</option>
<option value="listing2.html">/CBuffFileStream/CBuffFileStream.h</option>
<option value="listing3.html">/CBuffFileStream/CreateRandExpNumbers.c</option>
<option value="listing4.html">/CBuffFileStream/CreateRandExpNumbers.h</option>
<option value="listing5.html">/CBuffFileStream/CTestJig.c</option>
<option value="listing6.html">/CBuffFileStream/CTestJig.h</option>
<option value="listing7.html">/CBuffFileStream/FilePermUtils.c</option>
<option value="listing8.html">/CBuffFileStream/FilePermUtils.h</option>
<option value="listing9.html">/CBuffFileStream/HelloWorld.c</option>
<option value="listing10.html">/CBuffFileStream/RandomTestJig.c</option>
<option value="listing11.html">/CBuffFileStream/RandomTestJig.h</option></select>
				</p>
				</form>
				<p><strong><a href="Optimization_TN_Demos.zip">Download Sample</a></strong> (&#147;Optimization_TN_Demos.zip&#148;, 123.9K)<BR>
<strong><a href="Optimization_TN_Demos.dmg">Download Sample</a></strong> (&#147;Optimization_TN_Demos.dmg&#148;, 213.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    CBuffFileStream.c  Contains:  Buffer handling.  Written by:  Tim Carroll  Copyright:  Copyright (c) 1999 Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.*/#include &lt;Errors.h&gt;#include &lt;Files.h&gt;#include &quot;FilePermUtils.h&quot;#include &quot;CBuffFileStream.h&quot;// flush out the buffer we have.// will write if it is a writing buffer// otherwise just empty itstatic OSErr  BFSFlushOutBuffer(CBuffFileStreamData *fdata);// Check to see if we are changing from read buffering to write// buffering or vice-versa. If so, flush the buffer.static OSErr  BFSFlushOnModeSwap(CBuffFileStreamData *fdata,int nowMode);// Trash the buffer. Nasty? Yes. Calling this make you lose data if you// were in the middle of a buffered write. Don't call it if you don't know// why you would.static void    BFSTrashBuffer(CBuffFileStreamData *fdata,int nowMode);// Fill the buffer from the current location in the file. This is used when// the read buffer runs drystatic OSErr  BFSReadInBuffer(CBuffFileStreamData *fdata);#define DOINGDEBUGCHECKING  0#define  STOPEACHONENTRY    0#define BYPASSBUFFER    0// ---------------------------------------------------------------------------//    * BFSOpenFIle(CBuffFileStreamData **newdata, FSSpec *inFileInfo, long inPrivileges)// ---------------------------------------------------------------------------//  Open a file from an FSSpec////  This opens a file given the specified permissions (fsRdWrPerm, etc.)//  and creates a file stream buffer record.OSErr  BFSOpenFile(CBuffFileStreamData **newdata, FSSpec *inFileInfo, long inPrivileges){  CBuffFileStreamData   *makeBlock;  OSErr          fileErr;#if STOPEACHONENTRY  Debugger();#endif  if (0 == *newdata)    return paramErr;#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) *newdata &amp; 1))    return paramErr;#endif  makeBlock = (CBuffFileStreamData *) NewPtrClear(sizeof(CBuffFileStreamData));  if (0 == makeBlock)    return MemError();  fileErr = FSpOpenDF(inFileInfo,inPrivileges,&amp;(makeBlock-&gt;mFileRefNum));  if (noErr != fileErr)  {    (void) DisposePtr((Ptr) makeBlock);    *newdata = 0;    return fileErr;  }  fileErr = GetPermission(makeBlock-&gt;mFileRefNum,&amp;(makeBlock-&gt;mFilePerms));  if (noErr != fileErr)  {    (void) FSClose(makeBlock-&gt;mFileRefNum);    (void) DisposePtr((Ptr) makeBlock);    *newdata = 0;    return fileErr;  }  *newdata = makeBlock;  return noErr;}// ---------------------------------------------------------------------------//    * BFSCloseFile(CBuffFileStreamData *fdata)// ---------------------------------------------------------------------------//  Close an opened file////  This closes an already opened buffered file.//  It also deletes the storage associated with the file stream buffer record.OSErr  BFSCloseFile(CBuffFileStreamData *fdata){  OSErr      fileErr;  OSErr      file2Err;#if STOPEACHONENTRY  Debugger();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1))    return paramErr;#endif  if (0 == fdata)    return paramErr;  fileErr = BFSFlushOutBuffer(fdata);  file2Err = FSClose(fdata-&gt;mFileRefNum);  if (noErr == fileErr)    fileErr = file2Err;  return fileErr;}// ---------------------------------------------------------------------------//    * BFSSetMarker// ---------------------------------------------------------------------------//  Place the Read/Write Marker at an offset from a specified position////  fromWhere can be fsAtMark (useless) or fsFromStart, fsFromLEOF, fsFromMarkOSErr  BFSSetMarker(CBuffFileStreamData *fdata, long inOffset, long fromWhere){  OSErr      fileErr;#if STOPEACHONENTRY  Debugger();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1))    return paramErr;#endif  if (0 == fdata)    return paramErr;  if (fromWhere &lt; fsAtMark || fromWhere &gt; fsFromMark)    return paramErr;#if BYPASSBUFFER  fileErr = SetFPos(fdata-&gt;mFileRefNum,fromWhere,inOffset);  #else// Flush cache out  fileErr = BFSFlushOutBuffer(fdata);  if (noErr != fileErr)    return fileErr;// Now seek  fileErr = SetFPos(fdata-&gt;mFileRefNum,fromWhere,inOffset);// update where our window starts  fdata-&gt;mWindowLocation = BFSGetMarker(fdata);#endif  return fileErr;}long  BFSGetMarker(CBuffFileStreamData *fdata){#if DOINGDEBUGCHECKING  OSErr      fileErr;#endif#if STOPEACHONENTRY  Debugger();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1))    return -1;#endif  if (0 == fdata)    return -1;#if BYPASSBUFFER  {    Int32      returnMarker;    fileErr = GetFPos(fdata-&gt;mFileRefNum,&amp;returnMarker);    if (noErr != fileErr)      return -1;    return returnMarker;  }#else#if DOINGDEBUGCHECKING  {    long      returnMarker;    fileErr = GetFPos(fdata-&gt;mFileRefNum,&amp;returnMarker);    if (noErr != fileErr)      return -1;    if (returnMarker != fdata-&gt;mWindowLocation)      DebugStr(&quot;\pmarker matching now working.&quot;);  }#endif// rejigger marker  return fdata-&gt;mWindowLocation + fdata-&gt;mBufferCurPos;#endif}// ---------------------------------------------------------------------------//    * BFSSetLength// ---------------------------------------------------------------------------//  Set the length, in bytes, of the data fork a buffered fileOSErr  BFSSetLength(CBuffFileStreamData *fdata, long inLength){#if STOPEACHONENTRY  Debugger();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1))    return -1;#endif  if (0 == fdata)    return -1;#if BYPASSBUFFER  return SetEOF(fdata-&gt;mFileRefNum,inLength);#else  {    OSErr        fileErr;    fileErr = BFSFlushOutBuffer(fdata);    if (noErr != fileErr)      return fileErr;  // If we get an error, continue so we keep an accurate marker    fileErr = SetEOF(fdata-&gt;mFileRefNum,inLength);    fdata-&gt;mWindowLocation = BFSGetMarker(fdata);    return fileErr;  }#endif}// ---------------------------------------------------------------------------//    * BFSGetLength// ---------------------------------------------------------------------------//  Return the length, in bytes, of the data fork of a buffered filelong  BFSGetLength(CBuffFileStreamData *fdata){  OSErr        fileErr;#if STOPEACHONENTRY  Debugger();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1))    return -1;#endif  if (0 == fdata)    return -1;#if BYPASSBUFFER  {    Int32        returnLength;  // Find file system length    fileErr = GetEOF(fdata-&gt;mFileRefNum,&amp;returnLength);    if (noErr != fileErr)      return -1;    return returnLength;  }#else  {    long        returnLength;    long        markerPos;  // Find file system length    fileErr = GetEOF(fdata-&gt;mFileRefNum,&amp;returnLength);    if (noErr != fileErr)      return -1;  // adjust length in case buffer passes current end of file    markerPos = BFSGetMarker(fdata);    if (-1 != markerPos &amp;&amp; markerPos &gt; returnLength)      returnLength = markerPos;    return returnLength;  }#endif}// ---------------------------------------------------------------------------//    * BFSWrite// ---------------------------------------------------------------------------//  Write data from a buffer to a buffered file stream////  Returns an error code and passes back the number of bytes actually//  written, which may be less than the number requested if an error occurred.//  If no error is returned, the full amount was written.OSErr  BFSWrite(CBuffFileStreamData *fdata, long *writeAmt, const void *inBuffer){#if STOPEACHONENTRY  Debugger();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1) || 0 != ((unsigned long) writeAmt &amp; 0x1))    return paramErr;#endif  if (0 == fdata || 0 == writeAmt || *writeAmt &lt; 0)    return paramErr;#if BYPASSBUFFER  return FSWrite(fdata-&gt;mfRefNum,writeAmt,inBuffer);#else  {    const void  *subBuffer = inBuffer;    long    remainByteCount = *writeAmt;    OSErr    modeErr;    long    freeBytes;  //  // Road map: here's what we are doing  //  // 1st: Check to see if we have write permissions  // 2nd: Is our data less the remaining section of the buffer plus an empty buffer?  //     Yes: 3rd: put as much data as you can in the current buffer  //          4th: flush the buffer if full  //          5th: put the rest of the data in the buffer  //      No: 3rd: Is there data already in the buffer?  //              Yes: 4th: put as much data as you can in the current buffer  //                   5th: flush the buffer  //               No: 6th: bypass the buffer to write the rest  //  // We only allow writing to the end of the buffer.  // This is okay since any seeks flush the buffer and begin with a fresh one.  // We keep mBufferCurPos in sync with mBufferLength though to make some  // operations easier.  // check for write permissions    if (fsRdPerm == fdata-&gt;mFilePerms ||        fsRdWrShPerm == fdata-&gt;mFilePerms)    {      return opWrErr;    // no write permissions    }  // Check to see if we changed modes from read to write    modeErr = BFSFlushOnModeSwap(fdata,eBuffFileStreamIamWriting);    if (noErr != modeErr)      return modeErr;    freeBytes = eBuffFileStreamBufferMaxSize - fdata-&gt;mBufferLength;  // Can we write by using the available space plus another buffer?    if (remainByteCount &lt; (freeBytes + eBuffFileStreamBufferMaxSize))    {      long        addBytes = freeBytes;    // Take the lesser number of the available space or the bytes we have      if (remainByteCount &lt; addBytes)        addBytes = remainByteCount;    // Move in the data      BlockMoveData(subBuffer,&amp;(fdata-&gt;mFileWindow[fdata-&gt;mBufferLength]),addBytes);    // Adjust the buffer pointer, source pointer, and bytes left to write      fdata-&gt;mBufferLength += addBytes;      fdata-&gt;mBufferCurPos += addBytes;      subBuffer = (const void *) ((char *) subBuffer + addBytes);      remainByteCount -= addBytes;    // Now flush the buffer if it is full      if (eBuffFileStreamBufferMaxSize == fdata-&gt;mBufferLength)      {        OSErr flushErr = BFSFlushOutBuffer(fdata);        if (flushErr != noErr)          return flushErr;      }    // Now, do we have more data to write? If so, put it in the buffer      if (remainByteCount &gt; 0)      {      // Move in the data        BlockMoveData(subBuffer,fdata-&gt;mFileWindow,remainByteCount);      // Adjust the buffer pointer        fdata-&gt;mBufferLength = remainByteCount;        fdata-&gt;mBufferCurPos = remainByteCount;      }    }    else    {    // We have so much data we are going to at least partially bypass the buffer.    // First, if we have a partial buffer, we should put as much of our data as    // possible into the buffer before we write the rest as a bypass.    // If we don't have a partial buffer, then we would be turning one write    // into two, and we don't want that, so skip this step and write it all    // as a bypass.      if (fdata-&gt;mBufferLength &gt; 0)      {        OSErr flushErr;      // Take as much data as we can        BlockMoveData(subBuffer,&amp;(fdata-&gt;mFileWindow[fdata-&gt;mBufferLength]),freeBytes);      // Adjust the buffer pointer, source pointer, and bytes left to write        fdata-&gt;mBufferLength = eBuffFileStreamBufferMaxSize;        fdata-&gt;mBufferCurPos = eBuffFileStreamBufferMaxSize;        subBuffer = (const void *) ((char *) subBuffer + freeBytes);        remainByteCount -= freeBytes;      // Now flush this full buffer        flushErr = BFSFlushOutBuffer(fdata);        if (flushErr != noErr)          return flushErr;      }    // Now we are going to write the rest as a bypass      {        long      writeCount = remainByteCount;        OSErr      bypassErr = FSWrite(fdata-&gt;mFileRefNum,&amp;writeCount,subBuffer);        if (bypassErr)          return bypassErr;      }    }  // We've written all we have, and we have a empty buffer (because it was  // empty, or we flushed it), we are ready for further writes  }  *writeAmt = 0;  return noErr;#endif  // !BYPASSBUFFER}// ---------------------------------------------------------------------------//    * BFSRead// ---------------------------------------------------------------------------//  Read data from a buffered data stream to a buffer////  Returns an error code and passes back the number of bytes actually//  read, which may be less than the number requested if an error occurred.//  If no error is returned, the full amount was read.OSErr  BFSRead(CBuffFileStreamData *fdata, long *readAmt, void *outBuffer){#if STOPEACHONENTRY  Debugger();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1) || 0 != ((unsigned long) readAmt &amp; 0x1))    return paramErr;#endif  if (0 == fdata || 0 == readAmt || *readAmt &lt; 0)    return paramErr;#if BYPASSBUFFER  return FSRead(fdata-&gt;mfRefNum,writeAmt,inBuffer);#else  {    void  *subBuffer       = outBuffer;    long  remainByteCount   = *readAmt;    long  gotBytes       = fdata-&gt;mBufferLength - fdata-&gt;mBufferCurPos;  //  // Road map: here's what we are doing  //  // 1st: Is our request less than the remaining data in the buffer plus another buffer?  //     Yes: 2nd: get as much data as you can/need from the current buffer  //          3rd: need more?  //          Yes: 4th: refill buffer  //               5th: read the rest of the data from the buffer (or eof)  //      No: 2nd: Is there data already in the buffer?  //          3rd: get what you can from the buffer  //          4th: bypass to read the rest  //  // Check to see if we changed modes from write to read    OSErr modeErr = BFSFlushOnModeSwap(fdata,eBuffFileStreamIamReading);    if (noErr != modeErr)    {      *readAmt = 0;      return modeErr;    }  // See if we could possibly satisfy the request from the current buffer contents  // and another less than full buffer?    if (*readAmt &lt; (gotBytes + eBuffFileStreamBufferMaxSize))    {    // Yes, so we want to use up what we have, read a whole buffer and    // use part of this. However, this is written as a while loop to handle    // operations at the end of a file.      while (remainByteCount &gt; 0)      {        long      addBytes;      // Is the buffer empty and we still need more?        if (remainByteCount &gt; 0 &amp;&amp; fdata-&gt;mBufferCurPos == fdata-&gt;mBufferLength)        {        // Yes, refill it          OSErr      fillErr = BFSReadInBuffer(fdata);          if (noErr != fillErr)          {          //  Probably an eof, we ran out of data.            if (fillErr == eofErr)              *readAmt -= remainByteCount;            else              *readAmt = 0;            return fillErr;          }        }        addBytes = fdata-&gt;mBufferLength - fdata-&gt;mBufferCurPos;      // Take the lesser number of the available data or the bytes we want        if (remainByteCount &lt; addBytes)          addBytes = remainByteCount;      // Move in the data        BlockMoveData(&amp;(fdata-&gt;mFileWindow[fdata-&gt;mBufferCurPos]),subBuffer,addBytes);      // Adjust location in buffer, destination pointer, and bytes left to read        fdata-&gt;mBufferCurPos += addBytes;        subBuffer = (void *) ((char *) subBuffer + addBytes);        remainByteCount -= addBytes;      // Is the buffer empty and we still need more?        if (remainByteCount &gt; 0 &amp;&amp; fdata-&gt;mBufferCurPos == fdata-&gt;mBufferLength)        {        // Yes, refill it          OSErr    fillErr = BFSReadInBuffer(fdata);          if (fillErr)          {          //  Probably an eof, we ran out of data.            if (fillErr == eofErr)              *readAmt -= remainByteCount;            else              *readAmt = 0;            return fillErr;          }        }      }    }    else    {    // Fast-track big read, use data available in the buffer, then switch    // to big dedicated reads.      long      readAttempt;      OSErr      bypassErr;      if (gotBytes &gt; 0)    // use the data already in the buffer      {      // Move in the data        BlockMoveData(&amp;(fdata-&gt;mFileWindow[fdata-&gt;mBufferCurPos]),subBuffer,gotBytes);      // Adjust location in buffer, destination pointer, and bytes left to read        fdata-&gt;mBufferCurPos += gotBytes;        subBuffer = (void *) ((char *) subBuffer + gotBytes);        remainByteCount -= gotBytes;      }      readAttempt = remainByteCount;      bypassErr = FSRead(fdata-&gt;mFileRefNum,&amp;readAttempt,subBuffer);      if (bypassErr)      {        if (bypassErr == eofErr)        {          remainByteCount -= readAttempt;          *readAmt -= remainByteCount;          return bypassErr;        }        *readAmt = 0;        return bypassErr;      }      remainByteCount -= readAttempt;    }    *readAmt -= remainByteCount;    return noErr;  }#endif}// ---------------------------------------------------------------------------//    * BFSGetFilePermissions// ---------------------------------------------------------------------------//  Find the permissions acquired when opening a buffered data file.////  This is useful if you specified fsCurPerm on open and want to know what//  permissions you got.long  BFSGetFilePermissions(CBuffFileStreamData *fdata){#if STOPEACHONENTRY  SysBreak();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1))    return paramErr;#endif  if (0 == fdata)    return paramErr;  return fdata-&gt;mFilePerms;}// ---------------------------------------------------------------------------//    * BFSFlushFile// ---------------------------------------------------------------------------//  Find the permissions acquired when opening a buffered data file.////  This is useful if you specified fsCurPerm on open and want to know what//  permissions you got.OSErr  BFSFlushFile(CBuffFileStreamData *fdata){#if STOPEACHONENTRY  SysBreak();#endif#if DOINGDEBUGCHECKING  if (0 != ((unsigned long) fdata &amp; 0x1))    return paramErr;#endif  if (0 == fdata)    return paramErr;#if BYPASSBUFFER  return noErr;#else  {    OSErr      flushErr;    flushErr = BFSFlushOutBuffer(fdata);  // You should do a MacOS flush file here.  // I'm not going to.    return flushErr;  }#endif}// flush out the buffer we have.// will write if it is a writing buffer// otherwise just empty it// This is not an externally accessible function so it does NOT// check its parameters.OSErr  BFSFlushOutBuffer(CBuffFileStreamData *fdata){#if BYPASSBUFFER  return noErr;#else  OSErr      returnValue = noErr;  if (eBuffFileStreamIamWriting == fdata-&gt;mBufferMode)  {    long      writeAmount = fdata-&gt;mBufferLength;  // write the data and update the file position    returnValue = FSWrite(fdata-&gt;mFileRefNum,&amp;writeAmount,fdata-&gt;mFileWindow);  // update kept file position    fdata-&gt;mWindowLocation += fdata-&gt;mBufferCurPos;    fdata-&gt;mBufferLength = 0;    fdata-&gt;mBufferCurPos = 0;  }  else  {  // update kept file position    fdata-&gt;mWindowLocation += fdata-&gt;mBufferCurPos;    SetFPos(fdata-&gt;mFileRefNum,fsFromStart,fdata-&gt;mWindowLocation);    fdata-&gt;mBufferLength = 0;    fdata-&gt;mBufferCurPos = 0;  }  return returnValue;#endif}// Check to see if we are changing from read buffering to write// buffering or vice-versa. If so, flush the buffer.// This is not an externally accessible function so it does NOT// check its parameters.OSErr  BFSFlushOnModeSwap(CBuffFileStreamData *fdata,int nowMode){#if BYPASSBUFFER  return noErr;#else  OSErr    flushErr = noErr;  if ((fdata-&gt;mBufferLength &gt; 0) &amp;&amp; (fdata-&gt;mBufferMode != nowMode))  {    flushErr = BFSFlushOutBuffer(fdata);    fdata-&gt;mBufferLength = 0;    // flush FOR SURE (sorry)    fdata-&gt;mBufferCurPos = 0;  }// set buffer mode  fdata-&gt;mBufferMode = nowMode;  return flushErr;#endif}// Trash the buffer. Nasty? Yes. Calling this make you lose data if you// were in the middle of a buffered write. Don't call it if you don't know// why you would.// This is not an externally accessible function so it does NOT// check its parameters.void    BFSTrashBuffer(CBuffFileStreamData *fdata,int nowMode){#if BYPASSBUFFER#else// delete the data in the buffer  fdata-&gt;mBufferLength = 0;  fdata-&gt;mBufferCurPos = 0;// set the buffer mode  fdata-&gt;mBufferMode = nowMode;#endif}// Fill the buffer from the current location in the file. This is used when// the read buffer runs dry// This is not an externally accessible function so it does NOT// check its parameters.OSErr  BFSReadInBuffer(CBuffFileStreamData *fdata){  OSErr      returnValue = noErr;  long      readAmount = eBuffFileStreamBufferMaxSize;#if BYPASSBUFFER  return noErr;#else#if DOINGDEBUGCHECKING  if (eBuffFileStreamIamReading != fdata-&gt;mBufferMode)  {    DebugStr(&quot;\pTried to fill the buffer in write mode!&quot;);  }#endif  fdata-&gt;mWindowLocation += fdata-&gt;mBufferCurPos;    // jump down the file some  returnValue = FSRead(fdata-&gt;mFileRefNum,&amp;readAmount,fdata-&gt;mFileWindow);  if (eofErr == returnValue &amp;&amp; 0 != readAmount)    returnValue = noErr;      // ignore under reads unless we run dry  fdata-&gt;mBufferLength = readAmount;  fdata-&gt;mBufferCurPos = 0;  return returnValue;#endif}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Optimization_TN_Demos/listing1.html%3Fid%3DDTS10000733-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Optimization_TN_Demos/listing1.html%3Fid%3DDTS10000733-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Optimization_TN_Demos/listing1.html%3Fid%3DDTS10000733-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>