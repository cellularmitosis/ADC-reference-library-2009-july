<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Data Programming Guide: Using Managed Objects</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using Managed Objects"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001803" title="Using Managed Objects"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Core Data Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdFetching.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdMemory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40001803-CJBDBHCB" title="Using Managed Objects"></a><hr /><H1>Using Managed Objects</H1><p>This document describes issues related to using and manipulating managed objects in your application. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001803-SW11" title="Mac OS X v10.4"></a><p><strong>Mac OS X v10.4:</strong>&nbsp;This article describes usage patterns for Mac OS X v10.5; if you are using Mac OS X v10.4, see <span class="content_text"><a href="cdZ104UsingMOs.html#//apple_ref/doc/uid/TP40006654-SW1">“Mac OS X v10.4: Using Managed Objects.”</a></span></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-212651">Accessing and Modifying Properties</a>
				
			<br/>
			
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-SW5">Saving Changes</a>
				
			<br/>
			
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-SW1">Managed Object IDs and URIs</a>
				
			<br/>
			
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-213600">Copying and Copy and Paste</a>
				
			<br/>
			
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-SW2">Drag and Drop</a>
				
			<br/>
			
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-213664">Validation</a>
				
			<br/>
			
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-207821-TPXREF148">Undo Management</a>
				
			<br/>
			
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-SW8">Faults</a>
				
			<br/>
			
        
			
			
				<a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-208900">Ensuring Data Is Up-to-Date</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001803-212651" title="Accessing and Modifying Properties"></a><h2>Accessing and Modifying Properties</h2><p>Core Data automatically generates efficient public and primitive get and set accessor methods for modeled properties (attributes <em>and</em> relationships) of managed object classes (see <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW1">“Managed Object Accessor Methods”</a></span>). When you access or modify properties of a managed object, you should use these methods directly.</p><p>Most relationships are inherently bidirectional. Any changes made to the relationships between objects should maintain the integrity of the object graph. Provided that you have correctly modeled a relationship in both directions and set the inverses, modifying one end of a relationship automatically updates the other end—see <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW3">“Manipulating Relationships and Object Graph Integrity.”</a></span></p><a name="//apple_ref/doc/uid/TP40001803-SW4" title="Attributes and to-one relationships"></a><h3>Attributes and to-one relationships</h3><p>You access attributes and and to-one relationships of a managed object using standard accessor methods or using the Objective-C 2.0 dot syntax (see <span class="content_text"><a href="../../ObjectiveC/Articles/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_top">Declared Properties</a></span>) as illustrated in the following code fragment:</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *firstName = [anEmployee firstName];<span></span></pre></td></tr><tr><td scope="row"><pre>Employee *manager = anEmployee.manager;<span></span></pre></td></tr></table></div><p>Similarly, you can use either standard accessor methods or the dot syntax to modify attributes; for example:</p><div class="codesample"><table><tr><td scope="row"><pre>newEmployee.firstName = @"Stig";<span></span></pre></td></tr><tr><td scope="row"><pre>[newEmployee setManager:manager];<span></span></pre></td></tr></table></div><p>In the cases of both getters and setters, the dot syntax is exactly equivalent to standard method invocation. For example, the following two statements use identical codepaths:</p><div class="codesample"><table><tr><td scope="row"><pre>[[aDepartment manager] setSalary:[NSNumber numberWithInteger:100000]];<span></span></pre></td></tr><tr><td scope="row"><pre>aDepartment.manager.salary = [NSNumber numberWithInteger:100000];<span></span></pre></td></tr></table></div><p>You can also use key-value coding (KVC) to get or set the value of a simple attribute as illustrated in the following code fragment. Using KVC, though, is considerably less efficient than using accessor methods, so you should only use KVC when necessary (for example when you are choosing the key or keypath dynamically).</p><div class="codesample"><table><tr><td scope="row"><pre>[newEmployee setValue:@"Stig" forKey:@"firstName"];<span></span></pre></td></tr><tr><td scope="row"><pre>[aDepartment setValue:[NSNumber numberWithInteger:100000] forKeyPath:@"manager.salary"];<span></span></pre></td></tr></table></div><p>You must change attribute values in a KVC-compliant fashion. For example, the following typically represents a programming error:</p><div class="codesample"><table><tr><td scope="row"><pre>NSMutableString *mString = [NSMutableString stringWithString:@"Laurie"];<span></span></pre></td></tr><tr><td scope="row"><pre>[newEmployee setFirstName:mString];<span></span></pre></td></tr><tr><td scope="row"><pre>[mString setString:@"Laura"];<span></span></pre></td></tr></table></div><p>For mutable values, you should either transfer ownership of the value to Core Data, or implement custom accessor methods to always perform a copy. The previous example may not represent an error if the class representing the Employee entity declared the <code>firstName</code> property <code>(copy)</code> (or implemented a custom <code>setFirstName:</code> method that copied the new value). It is important to note, of course, that after the invocation of <code>setString:</code> (in the third code line) the value of <code>firstName</code> would still be “Laurie” and not “Laura”.</p><p>There should typically be no reason to invoke the primitive accessor methods except within custom accessor methods (see <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW1">“Managed Object Accessor Methods”</a></span>).</p><a name="//apple_ref/doc/uid/TP40001803-SW3" title="To-many relationships"></a><h3>To-many relationships</h3><p>To access a to-many relationship (whether the destination of a one-to-many relationship or a many-to-many relationship), you use the standard get accessor or dot syntax. A to-many relationship is represented by a set, as illustrated in the following code fragment:</p><div class="codesample"><table><tr><td scope="row"><pre>NSSet *managersPeers = [managersManager directReports];<span></span></pre></td></tr><tr><td scope="row"><pre>NSSet *departmentsEmployees = aDepartment.employees;<span></span></pre></td></tr></table></div><p>When you access the destination of a relationship, you may initially get a fault object (see <span class="content_text"><a href="cdFaultingUniquing.html#//apple_ref/doc/uid/TP30001202-CJBDBHCB">“Faulting and Uniquing”</a></span>)—the fault fires automatically if you make any changes to it. On Mac OS X v10.5 and later you check whether the relationship is a fault or not using <code>NSManagedObject</code>’s <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/hasFaultForRelationshipNamed:" target="_top">hasFaultForRelationshipNamed:</a></code> method.</p><p>You can in principle manipulate an entire to-many relationship in the same way you do a to-one relationship, using either a custom accessor method or (more likely) key-value coding, as in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>NSSet *newEmployees = [NSSet setWithObjects:employee1, employee2, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>[aDepartment setEmployees:setOfEmployees];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSSet *newDirectReports = [NSSet setWithObjects:employee3, employee4, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>manager.directReports = newDirectReports;<span></span></pre></td></tr></table></div><p>Typically, however, you do not want to set an entire relationship, instead you want to add or remove a single element at a time. To do this, you should use <code><a href="../../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/mutableSetValueForKey:" target="_top">mutableSetValueForKey:</a></code> or one of the automatically-generated relationship mutator methods (see <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW9">“Dynamically-Generated Accessor Methods”</a></span>):</p><div class="codesample"><table><tr><td scope="row"><pre>NSMutableSet *employees = [aDepartment mutableSetValueForKey:@"employees"];<span></span></pre></td></tr><tr><td scope="row"><pre>[employees addObject:newEmployee];<span></span></pre></td></tr><tr><td scope="row"><pre>[employees removeObject:firedEmployee];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// or<span></span></pre></td></tr><tr><td scope="row"><pre>[aDepartment addEmployeesObject:newEmployee];<span></span></pre></td></tr><tr><td scope="row"><pre>[aDepartment removeEmployeesObject:firedEmployee];<span></span></pre></td></tr></table></div><p>It is important to understand the difference between the values returned by the dot accessor and by <code>mutableSetValueForKey:</code>. <code>mutableSetValueForKey:</code> returns a mutable proxy object. If you mutate its contents, it will emit the appropriate key-value observing (KVO) change notifications for the relationship. The dot accessor simply returns a set. If you manipulate the set as shown in this code fragment:</p><div class="codesample"><table><tr><td scope="row"><pre>[aDepartment.employees addObject:newEmployee]; // do not do this!<span></span></pre></td></tr></table></div><p>then KVO change notifications are <em>not</em> emitted and the inverse relationship is not updated correctly.</p><p>Recall that the dot simply invokes the accessor method, so for the same reasons:</p><div class="codesample"><table><tr><td scope="row"><pre>[[aDepartment employees] addObject:newEmployee]; // do not do this, either!<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001803-SW5" title="Saving Changes"></a><h2>Saving Changes</h2><p>Simply modifying a managed object does not cause the changes to be saved to a store. The managed object context acts as a scratchpad. You can make changes to the objects, and undo and redo changes as you wish. If you make changes to managed objects associated with a given context, those changes remain local to that context until you commit the changes by sending the context a <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/save:" target="_top">save:</a></code> message. At that point—provided that there are no validation errors—the changes are committed to the persistent store.</p><p>See also <span class="content_text"><a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-208900">“Ensuring Data Is Up-to-Date.”</a></span></p><a name="//apple_ref/doc/uid/TP40001803-SW1" title="Managed Object IDs and URIs"></a><h2>Managed Object IDs and URIs</h2><p>An <code>NSManagedObjectID</code> object is a universal identifier for a managed object, and provides basis for uniquing in the Core Data Framework. A managed object ID uniquely identifies the same managed object both between managed object contexts in a single application, and in multiple applications (as in distributed systems). Like the primary key in the database, an identifier contains the information needed to exactly describe an object in a persistent store, although the detailed information is not exposed. The framework completely encapsulates the “external” information and presents a clean object oriented interface.</p><div class="codesample"><table><tr><td scope="row"><pre>NSManagedObjectID *moID = [managedObject objectID];<span></span></pre></td></tr></table></div><p>It is important to note that there are two forms of an object ID. When a managed object is first created, Core Data assigns it a temporary ID; only if it is saved to a persistent store does Core Data assign a managed object a permanent ID. You can readily discover whether an ID is temporary:</p><div class="codesample"><table><tr><td scope="row"><pre>BOOL isTemporary = [[managedObject objectID] isTemporaryID];<span></span></pre></td></tr></table></div><p>You can also transform an object ID into a URI representation:</p><div class="codesample"><table><tr><td scope="row"><pre>NSURL *moURI = [[managedObject objectID] URIRepresentation];<span></span></pre></td></tr></table></div><p>Given a managed object ID or a URI, you can retrieve the corresponding managed object using <code><a href="../../../Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/Reference/NSPersistentStoreCoordinator.html#//apple_ref/occ/instm/NSPersistentStoreCoordinator/managedObjectIDForURIRepresentation:" target="_top">managedObjectIDForURIRepresentation:</a></code> or <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/objectWithID:" target="_top">objectWithID:</a></code>.</p><p>An advantage of the URI representation is that you can archive it—although note that in many cases you should not archive a temporary ID since this is obviously subject to change. You could, for example, store archived URIs in your application’s user defaults to save the last selected group of objects in a table view. You can also use URIs to support copy and paste operations (see <span class="content_text"><a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-213600">“Copying and Copy and Paste”</a></span>) and drag and drop operations (see <span class="content_text"><a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-SW2">“Drag and Drop”</a></span>).</p><p>You can use object IDs to define “weak” relationships across persistent stores (where no hard join is possible). For example, for a weak to-many relationship you store as archived URIs the IDs of the objects at the destination of the relationship, and maintain the relationship as a transient attribute derived from the object IDs. </p><p>You can sometimes benefit from creating your own unique ID (UUID) property which can be defined and set for newly inserted objects. This allows you to efficiently locate specific objects using predicates (though before a save operation new objects can be found only in their original context).</p><a name="//apple_ref/doc/uid/TP40001803-213600" title="Copying and Copy and Paste"></a><h2>Copying and Copy and Paste</h2><p>It is difficult to solve the problem of copying, or supporting copy and paste, in a generic way for managed objects. You need to determine on a case-by-case basis what properties of a managed object you actually want to copy.</p><a name="//apple_ref/doc/uid/TP40001803-SW6" title="Copying Attributes"></a><h3>Copying Attributes</h3><p>If you just want to copy a managed object’s attributes, then in many cases the best strategy may be in the copy operation to create a dictionary (property list) representation of a managed object, then in the paste operation to create a new managed object and populate it using the dictionary. For an example, see <em><a href="../../NSPersistentDocumentTutorial/index.html#//apple_ref/doc/uid/TP40001799" target="_top">NSPersistentDocument Core Data Tutorial</a></em>—see also <span class="content_text"><a href="../../ModelObjects/Articles/moCopying.html#//apple_ref/doc/uid/TP40002137" target="_top">Copying</a></span> in <em><a href="../../ModelObjects/index.html#//apple_ref/doc/uid/TP40001931" target="_top">Model Object Implementation Guide</a></em>. You can use the managed object’s ID (described in <span class="content_text"><a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-SW1">“Managed Object IDs and URIs”</a></span>) to support copy and paste. Note, however, that the technique needs to be adapted to allow for copying of new objects.</p><p>A new, unsaved, managed object has a temporary ID. If a user performs a copy operation and then a save operation, the managed object’s ID changes and the ID recorded in the copy will be invalid in a subsequent paste operation. To get around this, you use a "lazy write" (as described in <span class="content_text"><a href="../../CopyandPaste/Articles/pbImplementing.html#//apple_ref/doc/uid/TP40004255" target="_top">Implementing Copy and Paste</a></span>). In the copy operation, you declare your custom type but if the managed object’s ID is temporary you do not write the data—but you do keep a reference to the original managed object. In the <code><a href="../../../Reference/ApplicationKit/Classes/NSPasteboard_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/pasteboard:provideDataForType:" target="_top">pasteboard:provideDataForType:</a></code> method you then write the current ID for the object.</p><p>As a further complication, it is possible that the ID is still temporary during the paste operation, yet you must still allow for the possibility of future paste operations after an intervening save operation. You must therefore re-declare the type on the pasteboard to set up lazy pasting again, otherwise the pasteboard will retain the temporary ID. You cannot invoke <code><a href="../../../Reference/ApplicationKit/Classes/NSPasteboard_Class/Reference/Reference.html#//apple_ref/occ/instm/NSPasteboard/addTypes:owner:" target="_top">addTypes:owner:</a></code> during <code>pasteboard:provideDataForType:</code>, so you must use a delayed perform—for example:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSString *)type<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([type isEqualToString:MyMOIDType]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // assume cachedManagedObject is object originally copied<span></span></pre></td></tr><tr><td scope="row"><pre>        NSManagedObjectID *moID = [cachedManagedObject objectID];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSURL *moURI = [moID URIRepresentation];<span></span></pre></td></tr><tr><td scope="row"><pre>        [sender setString:[moURI absoluteString] forType:MyMOIDType];<span></span></pre></td></tr><tr><td scope="row"><pre>        if ([moID isTemporaryID]) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self performSelector:@selector(clearMOIDInPasteboard:)<span></span></pre></td></tr><tr><td scope="row"><pre>                    withObject:sender afterDelay:0];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // implementation continues...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)clearMOIDInPasteboard:(NSPasteboard *)pb<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [pb addTypes:[NSArray arrayWithObject:MyMOIDType] owner:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001803-SW7" title="Copying Relationships"></a><h3>Copying Relationships</h3><p>If you want to copy relationships you also need to consider the objects related to those first tier of related objects—if you are not careful, it is possible that you will copy the whole object graph (which may not be what you want!). If you want to copy a to-one relationship, you need to decide whether the copy of the destination should be a new object or a reference. If it is a reference, what should happen to the inverse relationship to the original object—should making a copy redefine relationships between other objects? You need to make similar decisions for to-many relationships.</p><a name="//apple_ref/doc/uid/TP40001803-SW2" title="Drag and Drop"></a><h2>Drag and Drop</h2><p>You can perform drag and drop operations with managed objects—such as, for example, transferring an object from one relationship to another—using a URI representation, as described in <span class="content_text"><a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-SW1">“Managed Object IDs and URIs.”</a></span></p><div class="codesample"><table><tr><td scope="row"><pre>NSURL *moURI = [[managedObject objectID] URIRepresentation];<span></span></pre></td></tr></table></div><p>You can put the URI on a dragging pasteboard, from which you can later retrieve it and recreate a reference to the original managed object using the persistent store coordinator, as illustrated in the following code sample.</p><div class="codesample"><table><tr><td scope="row"><pre>NSURL *moURL = // get it from the pasteboard ...<span></span></pre></td></tr><tr><td scope="row"><pre>NSManagedObjectID *moID = [[managedObjectContext persistentStoreCoordinator]<span></span></pre></td></tr><tr><td scope="row"><pre>    managedObjectIDForURIRepresentation:moURL];<span></span></pre></td></tr><tr><td scope="row"><pre>// assume moID non-nil...<span></span></pre></td></tr><tr><td scope="row"><pre>NSManagedObject *mo = [managedObjectContext objectWithID:moID];<span></span></pre></td></tr></table></div><p>Note that this assumes that drag and drop is "within a single persistence stack"—that is, that if there is more than one managed object context involved that they use a shared persistent store coordinator—or that the object(s) being dragged and dropped are in a store referenced by the persistent store coordinators.</p><p>If you want to copy-and-paste via drag-and-drop then you must put a suitable representation of the managed object onto the pasteboard, get the representation during the drop method, and initialize a new managed object using the representation (see <span class="content_text"><a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-213600">“Copying and Copy and Paste”</a></span>).</p><a name="//apple_ref/doc/uid/TP40001803-213664" title="Validation"></a><h2>Validation</h2><p>The Core Data framework provides a clean infrastructure for supporting validation, both through logic encapsulated in the object model and through custom code. In the managed object model, you can specify constraints on values that a property may have (for example, an Employee's salary cannot be negative, or that every employee must belong to a Department). There are two forms of custom validation methods—those that follow standard key-value coding conventions (see <span class="content_text"><a href="../../KeyValueCoding/Concepts/Validation.html#//apple_ref/doc/uid/20002173" target="_top">Key-Value Validation</a></span>) to validate a value for a single attribute, and a special set (<code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/validateForInsert:" target="_top">validateForInsert:</a></code>, <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/validateForUpdate:" target="_top">validateForUpdate:</a></code>, and <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/validateForDelete:" target="_top">validateForDelete:</a></code>) for validating the whole object at different stages of its life-cycle (insertion, update, and deletion). The latter may be particularly useful for validating combinations of values—for example, to ensure that an employee can be entered into a stock purchase plan only if their period of service exceeds a given length and their pay grade is at or above a certain level.</p><p>Model-based constraints are checked and validation methods are invoked automatically before changes are committed to the external store to prevent invalid data being saved. You can also invoke them programmatically whenever necessary. You validate individual values using <code>validateValue:forKey:error:</code>. The managed object compares the new value with the constraints specified in the model, and invokes any custom validation method (of the form <code>validate&lt;Key>:error:</code>) you have implemented. Even if you implement custom validation methods, you should typically not call custom validation methods directly. This ensures that any constraints defined in the managed object model are applied.</p><p>For more about implementing validation methods, see <span class="content_text"><a href="../../ModelObjects/Articles/moValidation.html#//apple_ref/doc/uid/TP40002185" target="_top">Model Object Validation</a></span>.</p><a name="//apple_ref/doc/uid/TP40001652-207821" title="Undo Management"></a><a name="//apple_ref/doc/uid/TP40001803-207821-TPXREF148" title="Undo Management"></a><h2>Undo Management</h2><p>The Core Data framework provides automatic support for undo and redo. Undo management even extends to transient properties (properties that are not saved to persistent store, but are specified in the managed object model).</p><p>Managed objects are associated with a managed object context. Each managed object context maintains an undo manager. The context uses key-value observing to keep track of modifications to its registered objects. You can make whatever changes you want to a managed object’s properties using normal accessor methods, key-value coding, or through any custom key-value-observing compliant methods you define for custom classes, and the context registers appropriate events with its undo manager.</p><p>To undo an operation, you simply send the context an <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/undo" target="_top">undo</a></code> message and to redo it send the context a <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/redo" target="_top">redo</a></code> message. You can also roll back all changes made since the last save operation using <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/rollback" target="_top">rollback</a></code> (this also clears the undo stack) and reset a context to its base state using <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/reset" target="_top">reset</a></code>.</p><p>You also can use other standard undo manager functionality, such grouping undo events. Core Data, though, queues up the undo registrations and adds them in a batch (this allows the framework to coalesce changes, negate contradictory changes, and perform various other operations that work better with hindsight than immediacy). If you use methods other than <code><a href="../../../Reference/Foundation/Classes/NSUndoManager_Class/Reference/Reference.html#//apple_ref/occ/instm/NSUndoManager/beginUndoGrouping" target="_top">beginUndoGrouping</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSUndoManager_Class/Reference/Reference.html#//apple_ref/occ/instm/NSUndoManager/endUndoGrouping" target="_top">endUndoGrouping</a></code>, to ensure that any queued operations are properly flushed you must first therefore send the managed object context a <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/processPendingChanges" target="_top">processPendingChanges</a></code> message.</p><p>For example, in some situations you want to alter—or, specifically, disable—undo behavior. This may be useful if you want to create a default set of objects when a new document is created (but want to ensure that the document is not shown as being dirty when it is displayed), or if you need to merge new state from another thread or process. In general, to perform operations without undo registration, you send an undo manager a <code><a href="../../../Reference/Foundation/Classes/NSUndoManager_Class/Reference/Reference.html#//apple_ref/occ/instm/NSUndoManager/disableUndoRegistration" target="_top">disableUndoRegistration</a></code> message, make the changes, and then send the undo manager an <code><a href="../../../Reference/Foundation/Classes/NSUndoManager_Class/Reference/Reference.html#//apple_ref/occ/instm/NSUndoManager/enableUndoRegistration" target="_top">enableUndoRegistration</a></code> message. Before each, you send the context a <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/processPendingChanges" target="_top">processPendingChanges</a></code> message, as illustrated in the following code fragment:</p><div class="codesample"><table><tr><td scope="row"><pre>NSManagedObjectContext *moc = ...;<span></span></pre></td></tr><tr><td scope="row"><pre>[moc processPendingChanges];  // flush operations for which you want undos<span></span></pre></td></tr><tr><td scope="row"><pre>[[moc undoManager] disableUndoRegistration];<span></span></pre></td></tr><tr><td scope="row"><pre>// make changes for which undo operations are not to be recorded<span></span></pre></td></tr><tr><td scope="row"><pre>[moc processPendingChanges];  // flush operations for which you do not want undos<span></span></pre></td></tr><tr><td scope="row"><pre>[[moc undoManager] enableUndoRegistration];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001803-SW8" title="Faults"></a><h2>Faults</h2><p>Managed objects typically represent data held in a persistent store. In some situations a managed object may be a “fault”—an object whose property values have not yet been loaded from the external store. When you access persistent property values, a fault “fires” and its persistent data is retrieved automatically from the store. In some circumstances you may explicitly turn a managed object into a fault (typically to ensure that its values are up to date, using <code>NSManagedObjectContext</code>'s <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/refreshObject:mergeChanges:" target="_top">refreshObject:mergeChanges:</a></code>). More commonly you encounter faults when traversing relationships.</p><p>When you fetch a managed object, Core Data does not automatically fetch data for other objects to which it has relationships (see <span class="content_text"><a href="cdFaultingUniquing.html#//apple_ref/doc/uid/TP30001202-185436">“Faulting”</a></span>). Initially, an object's relationships are represented by faults (unless the destination object has already been fetched—see <span class="content_text"><a href="cdFaultingUniquing.html#//apple_ref/doc/uid/TP30001202-185502">“Uniquing”</a></span>). If, however, you access the relationship's destination object or objects, their data are retrieved automatically for you. For example, suppose you fetch a single Employee object from a persistent store when an application first launches, then (assuming these exist in the persistent store) its <code>manager</code> and <code>department</code> relationships are represented by faults. You can nevertheless ask for the employee’s manager’s last name as shown in the following code example:</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *managersName =<span></span></pre></td></tr><tr><td scope="row"><pre>        [[anEmployee valueForKey:@"manager"] valueForKey:@"lastName];<span></span></pre></td></tr></table></div><p>or more easily using key paths:</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *managersName =<span></span></pre></td></tr><tr><td scope="row"><pre>        [anEmployee valueForKeyPath:@"manager.lastName"];<span></span></pre></td></tr></table></div><p>In this case, the data for destination Employee object (the manager) is retrieved for you automatically.</p><p>There is a subtle but important point here. Notice that, in order to traverse a relationship—in this example to find an employee’s manager—you do not have to explicitly <em>fetch</em> the related objects (that is, you do not create and execute a fetch request). You simply use key-value coding (or if you have implemented them, accessor methods) to retrieve the destination object (or objects) and they are created for you automatically by Core Data. For example, you could ask for an employee’s manager’s manager’s department’s name like this:</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *departmentName = [anEmployee valueForKeyPath:@"manager.manager.department.name"];<span></span></pre></td></tr></table></div><p>(This assumes, of course, that the employee is at least two levels deep in the management hierarchy.) You can also use collection operator methods. You could find the salary overhead of an employee's department like this: </p><div class="codesample"><table><tr><td scope="row"><pre>NSNumber *salaryOverhead = [anEmployee valueForKeyPath:@"department.employees.@sum.salary"];<span></span></pre></td></tr></table></div><p>In many cases, your initial fetch retrieves a starting node in the object graph and thereafter you do not execute fetch requests, you simply follow relationships.</p><a name="//apple_ref/doc/uid/TP40001803-208900" title="Ensuring Data Is Up-to-Date"></a><h2>Ensuring Data Is Up-to-Date</h2><p>If two applications are using the same data store, or a single application has multiple persistence stacks, it is possible for managed objects in one managed object context or persistent object store to get out of sync with the contents of the repository. If this occurs, you need to “refresh” the data in the managed objects, and in particular the persistent object store (the snapshots) to ensure that the data values are current.</p><a name="//apple_ref/doc/uid/TP40001803-SW9" title="Refreshing an object"></a><h3>Refreshing an object</h3><p>Managed objects that have been realized (their property values have been populated from the persistent store) as well as pending updated, inserted, or deleted objects, are never changed by a fetch operation without developer intervention. For example, consider a scenario in which you fetch some objects and modify them in one editing context; meanwhile in another editing context you edit the same data and commit the changes. If in the first editing context you then execute a new fetch which returns the same objects, you do not see the newly-committed data values—you see the existing objects in their current in-memory state.</p><p>To refresh a managed object's property values, you use the managed object context method <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/refreshObject:mergeChanges:" target="_top">refreshObject:mergeChanges:</a></code>. If the <code>mergeChanges</code> flag is <code>YES</code>, the method merges the object's property values with those of the object available in the persistent store coordinator; if the flag is <code>NO</code>, the method simply turns an object back into a fault without merging (which also causes other related managed objects to be released, so you can use this method to trim the portion of your object graph you want to hold in memory).</p><p>Note that an object's staleness interval is the time that has to pass until the store re-fetches the snapshot. This therefore only affects firing faults—moreover it is only relevant for SQLite stores (the other stores never re-fetch because the entire data set is kept in memory).</p><a name="//apple_ref/doc/uid/TP40001803-SW10" title="Merging changes with transient properties"></a><h3>Merging changes with transient properties</h3><p>If you use <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/refreshObject:mergeChanges:" target="_top">refreshObject:mergeChanges:</a></code> with the <code>mergeChanges</code> flag <code>YES</code>, then any transient properties are restored to their pre-refresh value after <code>awakeFromFetch</code> is invoked. This means that, if you have a transient property with a value that depends on a property that is refreshed, the transient value may become out of sync.</p><p>Consider an application in which you have a Person entity with attributes <code>firstName</code> and <code>lastName</code>, and a <em>cached</em> transient derived property, <code>fullName</code> (in practice it might be unlikely that a <code>fullName</code> attribute would be cached, but the example is easy to understand). Suppose also that <code>fullName</code> is calculated and cached in a custom <code>awakeFromFetch</code> method.</p><p>A Person, currently named "Sarit Smith" in the persistent store, is edited in two managed object contexts:</p><ul class="spaceabove"><li class="li"><p>In context one, the corresponding instance's <code>firstName</code> is changed to "Fiona" (which causes the cached <code>fullName</code> to be updated to "Fiona Smith") and the context saved. </p><p>In the persistent store, the person is now “Fiona Smith”.</p></li><li class="li"><p>In context two, corresponding instance's <code>lastName</code> is changed to "Jones", which causes the cached <code>fullName</code> to be updated to "Sarit Jones". </p><p>The object is then refreshed with the <code>mergeChanges</code> flag <code>YES</code>. The refresh fetches “Fiona Smith” from the store.</p><ul class="nested"><li class="nested li"><p><code>firstName</code> was <em>not</em> changed prior to the refresh; the refresh causes it to be updated to the new value from the persistent store, so it is now "Fiona".</p></li><li class="nested li"><p><code>lastName</code> <em>was</em> changed prior to the refresh; so, after the refresh, it is set back to its modified value—"Jones".</p></li><li class="nested li"><p>The <em>transient</em> value, <code>fullName</code>, was also changed prior to the refresh. After the refresh, its value is restored to "Sarit Jones" (to be correct, it should be "Fiona Jones").</p></li></ul></li></ul><p>The example shows that, because pre-refresh values are applied <em>after</em> <code>awakeFromFetch</code>, you cannot use <code>awakeFromFetch</code> to ensure that a transient value is properly updated following a refresh (or if you do, the value will subsequently be overwritten). In these circumstances, the best solution is to use an additional instance variable to note that a refresh has occurred and that the transient value should be recalculated. For example, in the Person class you could declare an instance variable <code>fullNameIsValid</code> of type <code>BOOL</code> and implement the <code>didTurnIntoFault</code> method to set the value to <code>NO</code>. You then implement a custom accessor for the <code>fullName</code> attribute that checks the value of <code>fullNameIsValid</code>—if it is <code>NO</code>, then the value is recalculated. </p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdFetching.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdMemory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdUsingMOs.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdUsingMOs.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdUsingMOs.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
