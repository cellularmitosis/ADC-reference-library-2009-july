<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"        "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd"><HTML><!-- Template 03-24-01 --><!--Includes revisions to code listings--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1004: On QuickTime Component Manager 3.0 &amp; PowerPC Native Components</title>    <meta name="keywords" content="Mac OS 8 QuickTime Component Manager 3 ComponentResource 'thng'">    <meta name="Description" content="Technical Note TN1004: This Technical Note contains informationabout the version of the Component      Manager that shippedwith QuickTime 1.6 and the changes necessary to support nativePowerPC components.      Included in this TechNote is a descriptionof the fields of ComponentResource, the version 3 routinesof the Component      Manager, and a list of the MPW rezComponent Manager Interfaces."><meta name="categories" content="QuickTime"><meta name="week-posted" content="Sep 25, 1995 - Oct 6, 1995"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002847" title="On QuickTime Component Manager 3.0 & PowerPC Native Components"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxQuickTimeComponentCreation-date.html" target="_blank">QuickTime > QuickTime Component Creation</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1004</div>
<div id="pageheadsub">On QuickTime Component Manager 3.0 &amp; PowerPC Native Components</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">         <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <BR>                            <BR>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc --><p id="menutext"><A HREF = "#RTFToC1">About Component Manager 3.0</a><br><br><A HREF = "#RTFToC2">Code for the Glue Function</a><br><br><A HREF = "#RTFToC3">Component Manager Interfaces</a><br><br><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                 <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            <!-- begin_intro_text --><p id="introtext">This Note contains information about the version of the Component Manager that shipped with QuickTime 1.6 and the changes necessary to support native PowerPC components.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>&nbsp;[Oct 1 1995]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>                   <!-- begin_content --><a name="RTFToC1"></a><h2>About Component Manager 3.0</h2><P>The Component Manager in QuickTime 1.6.x and for the Power Macintosh (PowerPC) release has some new features. It has added the ability to automatically resolve conflicts between different versions of the same component. It will ensure that only the most recent version of a given component is actually registered. The Component Manager now supports Icon Suites for a component, so a component's icon no longer has to be just black and white. In addition, the Component Manager can support code written in the native format of the PowerPC.</p><P>The result returned for the Gestalt selector <code>gestaltComponentMgr</code> will be 3, indicating version number 3 of the Component Manager. This is the version being discussed in this Note. To insure that you have the features discussed here, check that version 3 is installed.</p><P>For support of the Power Macintosh, the Component Manager has been extended to allow use of native PowerPC components. When the Component Manager loads a native component on the Power Macintosh, it uses the Code Fragment Manager and calls <code>GetMemFragment</code> and then later <code>CloseConnection</code> when it unloads your code resource (specified in a <code>ComponentPlatformInfo</code>). This is how the Component Manager supports a native code fragment.</p><P>A component can support multiple platforms such as the 68K and PowerPC. Existing 68K code is always supported on the Power Macintosh through emulation. But you can also have native PowerPC code for your component to support better performance. The Component Manager will allow you to create a component that contains both code formats, so that you can support all platforms with a single component. The Component Manager also was extended in a way that allows for native PowerPC only components (without any 68K code support).</p><h3>Extended ComponentResource</h3><P>The <code>ComponentResource</code> data structure (the <code>'thng</code>' resource) has been extended. These extensions define additional information about the component. The complete data structure is shown below. The first portion is the same as the existing <code>ComponentResource</code>, with the new fields added at the end. The Component Manager determines if it is present by examining the size of the <code>'thng'</code> resource.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct ExtComponentResource {<br>    ComponentDescription cd; /* Registration parameters */<br>    ResourceSpec component; /* resource where Component code is found */<br>    ResourceSpec componentName; /* name string resource */<br>    ResourceSpec componentInfo; /* info string resource */<br>    ResourceSpec componentIcon; /* icon resource */<br><br>    // new data for Component Manager version 3<br>    long componentVersion; /* version of Component */<br>    long componentRegisterFlags; /* flags for registration */<br>    short componentIconFamily; /* resource id of Icon Family */<br>    long count; /* elements in platformArray */<br>    ComponentPlatformInfo platformArray[1];<br>};</pre>	</TD></TR></TABLE></CENTER><h4>componentVersion </h4><P>The <code>componentVersion</code> field contains the version number of the component. This should be identical to the value returned by <code>GetComponentVersion</code>. For convenience, if this value is set to 0, the component is called to get the version. This is useful during development. The version number stored in the <code>ComponentResourceExtension</code> is used by the Component Manager to avoid having to load and call the component to retrieve the component's version during startup.</p><h4>componentRegisterFlags </h4><P>The <code>componentRegisterFlags</code> allow you to define additional register information. These flags are discussed below. </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* Component Resource Extension flags */componentDoAutoVersion              = (1&lt;&lt;0)componentWantsUnregister                = (1&lt;&lt;1)componentAutoVersionIncludeFlags            = (1&lt;&lt;2)componentHasMultiplePlatforms           = (1&lt;&lt;3)</pre>	</TD></TR></TABLE></CENTER><P>The <code>componentDoAutoVersion</code> flag tells the Component Manager that you want your component registered only if there is no later version available. If there is an older version of the component installed, it will be unregistered. If an older version of the same component attempts to register after you, it will be immediately unregistered. Further, if a newer version of the same component registers after you, you will automatically be unregistered. Using the automatic version control feature  of the Component Manager allows you to make sure that only the most recent version of your software is running on a given   machine, regardless of how many versions may be installed.</p><P>The <code>componentWantsUnregister</code> flag indicates that your component wants to be called when it is unregistered. This is useful if your component allocates global memory at register time, for example. The prototype of the unregister  message is identical to the register message. If your component has never been opened, its unregister message is not be called.  The routine selector for unregister is given below.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>kComponentUnregisterSelect             = -7</pre>	</TD></TR></TABLE></CENTER><P>The <code>componentAutoVersionIncludeFlags</code> flag tells the Component Manager to use the component flags as criteria for its component search. If a component wants automatic version control, the Component Manager has to search for similar components. Normally, the Component Manager searches only for another component using the type, subType, and manufacturer fields of a <code>ComponentDescription</code> record. This flag tells the Component Manager to include the <code>componentFlags</code> in its search.</p><P>The <code>componentHasMultiplePlatforms</code> flag indicates that your component contains multiple versions of the code for different platforms. If you plan on supporting the PowerPC native code format, then you need to use the <code>ComponentPlatformInfo</code> within the component resource structure. Then set this bit in the <code>componentRegisterFlags</code> field. If this bit is not set then the code is assumed to be 68K format. Without this flag being set, the Component Manager will ignore any <code>ComponentPlatformInfo</code>.</p><h4>componentIconFamily </h4><P>Finally, the <code>componentIconFamily</code> field allows you to provide the resource ID of a System 7 Icon Suite. If this field is 0, it indicates that there is no icon suite.</p><h4>count</h4><P>This is the number of elements contained in the <code>ComponentPlatformInfo</code> array.</p><h4>platformArray</h4><P>This is an array of elements that describe the code to be used for different platforms. If the platform is for 68K, then the information within this element is a copy from the <code>componentFlags</code> of the <code>ComponentDescription</code> and ResourceSpec of the original <code>ComponentResource</code> structure. This insures backwards compatibility with older Component Managers. If the component contains native code support for the PowerPC, then an element of the array will contain the information about its <code>componentFlags</code>, resource type, and resource ID.</p><P>The <code>platformType</code> field is a value that represents which platform the component code is to support. The Gestalt result for selector gestaltSysArchitecture will be matched with the value in <code>platformType</code> of the <code>ComponentResource</code>. If a match is found, then that code is used to support the given platform.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    gestalt68k = 1, /* Motorola MC68K architecture  */    gestaltPowerPC = 2, /* IBM PowerPC architecture     */struct ResourceSpec {    OSType      resType;    /* 4-byte code */    short       resID;};typedef struct ResourceSpec ResourceSpec;struct ComponentPlatformInfo{    long componentFlags; /* flags of Component */    ResourceSpec component; /* resource where Component code is found */    short platformType; /* gestaltSysArchitecture result */};</pre>	</TD></TR></TABLE></CENTER><h3>Component Manager version 3 routines</h3><h4>GetComponentIconSuite</h4><P><code>GetComponentIconSuite</code> returns an Icon Suite for the given component. This call works only under System7 or later. If called on System 6, it returns an error. If the component doesn't have an Icon Suite but does have a Component Icon (as returned by <code>GetComponentInfo</code>), <code>GetComponentIconSuite</code> creates an Icon Suite  containing just the black-and-white Component Icon. In this way, you can use <code>GetComponentIconSuite</code> whether  or not a component has an Icon Suite.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr GetComponentIconSuite(Component aComponent, Handle *iconSuite)aComponent - Component ID, retrieved with FindNextComponent.iconSuite - Pointer to the Icon Suite you will receive.</pre>	</TD></TR></TABLE></CENTER><h4>RegisterComponent</h4><h4>RegisterComponentResource</h4><h4>RegisterComponentResourceFile</h4><P>The only change made to these routines was to modify the use of the global parameter. The upper byte now contains the platform ID to be used by the component being registered. This change is necessary because these calls do not have access to the ComponentResource which contains the <code>ComponentPlatformInfo</code>. If the upper byte of the global parameter is zero, then the platform is assumed to be the platform68k.</p><h3>Creating a PowerPC ComponentResource</h3><P>The basics step for running on a Power Macintosh with a native component are:</p><ul><li>Create component code fragment with native PowerPC code</li><li>Main entry point to code is a mixed mode routine descriptor</li><li>Package component code fragment as a resource</li><li>If you supply an interface for the component to be called directly, then for PowerPC code to call your component you must provide custom glue to make the call.</li><li>Create the extended <code>'thng'</code> resource using the ComponentPlatformInfo</li></ul><P>Each of these steps are discussed in more detail as follows:</p><h4>Creating the component code fragment</h4><P>The first step in creating a native PowerPC component is to port your code.  For complete details on porting to PowerPC, see Inside Macintosh: PowerPC System Software. Especially important for the following discussion is an understanding of the Mixed Mode and Code Fragment Managers.</p><P>Like other code ported for PowerPC, anytime your code uses a callback function (<code>ProcPtr</code>), it must be converted to a <code>UniversalProcPtr</code>. But unlike callbacks defined by the system, callbacks to your component have their own function prototypes. With the exception of some callbacks defined for QuickTime components, there are no system supplied function prototypes or UniversalProcPtrs, so you must create these yourself.</p><P>If, in response to a request code, your component dispatches to internal functions using <code>CallComponentFunction</code> or <code>CallComponentFunctionWithStorage</code>, then this is a place where you must use a <code>UniversalProcPtr</code>.</p><P>Suppose your component currently responds to an open request as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>       switch (params-&gt;what)        {            case kComponentOpenSelect:      /* Open request */            {                result = CallComponentFunctionWithStorage(storage, params, MyOpen);                break;            }</pre>	</TD></TR></TABLE></CENTER><P><code>MyOpen</code> is an internal function callback, so you must create a <code>RoutineDescriptor</code>/<code>UniversalProcPtr</code> for it. <code>MyOpen</code> is declared as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResult MyOpen (Handle storage, ComponentInstance self);</pre>	</TD></TR></TABLE></CENTER><P>The first step is to create a <code>ProcInfo</code> value for this function:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    uppMyOpenProcInfo = kPascalStackBased        | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))        | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))        | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(ComponentInstance)))};</pre>	</TD></TR></TABLE></CENTER><P>Next you must update your source to build a <code>UniversalProcPtr</code> and use it.  You could use <code>NewRoutineDescriptor</code> for this purpose, but the disadvantage is that creates a heap object which your component must dispose of properly.</p><P>An alternate approach is to declare a global <code>RoutineDescriptor</code> (global variables are not a problem for a native PowerPC component, since a code fragment automatically has global variables):</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#ifdef powercRoutineDescriptor MyOpenRD = BUILD_ROUTINE_DESCRIPTOR(uppMyOpenProcInfo, MyOpen);#endif</pre>	</TD></TR></TABLE></CENTER><P>If you want your code to be compilable for both 68K and PowerPC, using the Universal Interfaces, then to avoid a lot of conditional compilation, the following macros may be useful:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#ifdef powerc#define CallComponentFunctionWithStorageUniv(storage, params, funcName) \    CallComponentFunctionWithStorage(storage, params, &amp;funcName##RD)#define CallComponentFunctionUniv(params, funcName) \    CallComponentFunction(params, &amp;funcName##RD)#define INSTANTIATE_ROUTINE_DESCRIPTOR(funcName) RoutineDescriptor funcName##RD = \    BUILD_ROUTINE_DESCRIPTOR (upp##funcName##ProcInfo, funcName)#else#define CallComponentFunctionWithStorageUniv(storage, params, funcName) \    CallComponentFunctionWithStorage(storage, params,(ComponentFunctionUPP)funcName)#define CallComponentFunctionUniv(params, funcName) \    CallComponentFunction(params, (ComponentFunctionUPP)funcName)#endif</pre>	</TD></TR></TABLE></CENTER><P>These macros, exactly analogous to <code>CallComponentFunction</code> and <code>CallComponentFunctionWithStorage</code>, generate the appropriate code when compiled for 68K and PowerPC. Note that the PowerPC macro expansion depends on the global RoutineDescriptor name being FuncNameRD, i.e., the name of the function with RD appended. The INSTANTIATE_ROUTINE_DESCRIPTOR macro can be used for that purpose:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#ifdef powercINSTANTIATE_ROUTINE_DESCRIPTOR(MyOpen);#endif</pre>	</TD></TR></TABLE></CENTER><P>This is identical to the declaration of MyOpenRD earlier, but simplifies the editing.</p><P>With all the conditional stuff out of the way, then the original code can simply be updated by replacing <code>CallComponentFunctionWithStorage</code> with <code>CallComponentFunctionWithStorageUniv</code>:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>       switch (params-&gt;what)        {            case kComponentOpenSelect:      // Open request            {                result = CallComponentFunctionWithStorageUniv(storage, params, MyOpen);                break;            }</pre>	</TD></TR></TABLE></CENTER><P>Repeat the above steps for all internal component dispatches you make.</p><h4>Setting the main entry point</h4><P>Lastly, you must set up the entry point into your component correctly. Unlike a 68K code resource, a PowerPC code fragment (which your component will be) has a well defined entry point. The Component Manager, rather than just jumping to the start of the code resource, will call the main entry point, as defined when linking, instead.</p><P>But the Component Manager is 68K code, which means your main entry point must be a RoutineDescriptor.  You can set that up as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResult main    (ComponentParameters    *params,                                     Handle                 storage);#ifdef powercenum {    uppMainProcInfo = kPascalStackBased        | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))        | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(ComponentParameters *)))        | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Handle)))};RoutineDescriptor MainRD = BUILD_ROUTINE_DESCRIPTOR(uppMainProcInfo, main);#endif</pre>	</TD></TR></TABLE></CENTER><P>When you link the component, you must then specify MainRD as the entry point.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Your development environment may issue a warning because your main entry point is in a data section, not a code section. You may ignore the warning.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If your code is dependent on C or C++ runtime initializations, then your main entry point would be __start or __cplusstart, respectively, rather than main.  Modify the previous example accordingly.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Some components rely on a "fast dispatching" mechanism for calling component functions. This mechanism is dependent on the 68K architecture and is unsupported for native components, although it will work for emulated components running on the Power Macintosh.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>In all these modifications for PowerPC, the most difficult thing to get right is the <code>ProcInfo</code> value.  It's very easy to make a "cut and paste" error, or get a type wrong (short instead of short *). If your component is crashing the first thing to check (and check and check and check!) are the <code>ProcInfo</code> values.</P></TD></TR></TABLE></CENTER><BR><h3>Packaging the PowerPC component into a resource</h3><P>PowerPC development tools create your PowerPC code in a code fragment in the data fork of the file. Your component code must be a resource (the resource type and id are specified in the <code>'thng'</code> resource described below). You can use the MPW Rez "read" command to read from the data fork into a resource.  For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   read 'mycp' (130) mycomponent.pef;</pre>	</TD></TR></TABLE></CENTER><P>reads the code fragment from the file mycomponent.pef and creates the resource <code>'mycp'</code>(130).</p><h4>Providing an interface to the component</h4><P>If you wish your component to be called directly, you must also supply an interface so callers know how to call it.  For standard functions, such as Open, Close, Version, etc., this is not a problem as the Component Manager supplies functions to do this for you. Nor is this a problem if you are writing QuickTime components, since QuickTime supplies  standard interfaces and libraries for calling components.</p><P>But one of the advantages of the Component Manager is it lets you define your own routines with their own parameter lists, and for these routines you must supply an interface. Typically, for 68K this involved providing callers an interface file with function prototypes for your calls and inline 68K assembly to actually make the call.</p><P>Obviously, the inline 68K code is a problem for a native PowerPC caller, so you must provide glue to accomplish the same thing. The following discussion also applies to calling a 68K component from PowerPC code. The interface  is the same, either way.</p><P>To take the example for Inside Macintosh: More Macintosh Toolbox, page 6-30, you might have a call like:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResult DrawerSetup (ComponentInstance myInstance, Rect *r) =    ComponentCallNow (kDrawerSetUpSelect, 4);</pre>	</TD></TR></TABLE></CENTER><P><code>ComponentCallNow</code> is a macro that expands to inline 68K code that pushes additional parameters and then executes an A-trap to call the Component Manager.</p><P>The first thing when using the new Universal Headers is that the definition of <code>ComponentCallNow</code> has changed slightly. The above declaration would change to:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResult DrawerSetup (ComponentInstance myInstance, Rect *r)    ComponentCallNow (kDrawerSetUpSelect, 4);</pre>	</TD></TR></TABLE></CENTER><P>The only difference in this declaration is that the `=' character is missing. This is necessary to allow the code to compile for both 68K and PowerPC.</p><P>For 68K code, <code>ComponentCallNow</code> continues to expand to inline 68K code, but for PowerPC, the <code>ComponentCallNow</code> macro expands to nothing, which means the above declaration reduces to:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResult DrawerSetup (ComponentInstance myInstance, Rect *r) ;</pre>	</TD></TR></TABLE></CENTER><P>You must now supply glue for <code>DrawerSetup</code> that does the same thing on PowerPC as the 68K inlines would do.  </p><P>The strategy here is to mimic what 68K code calling your component would do. Namely, push a bunch of parameters on the stack, then call the component.  You do that by building a struct that looks like the parameters as they would appear on the 68K stack. Each call will require a different struct because each call can have different parameters.</p><P>Use the struct below (<code>DrawerSetupGluePB</code>) as a template. The first three fields, <code>componentFlags</code>, <code>componentParamSize</code>, and <code>componentWhat</code> are required, as is the last field, which is the  component instance.</p><P><code>componentFlags</code> is unused and should be zero.</p><P><code>componentParamSize</code> is the size, in bytes, of the parameters to the call, not counting the component instance. This is the same number that is passed as the second parameter in a <code>ComponentCallNow</code> macro call, and should be the same as the size of the params struct, discussed below.</p><P><code>componentWhat</code> is the selector for your component call. It's the same as the first parameter to a <code>ComponentCallNow</code> macro call.</p><P>The params field is a separate struct that exactly mirrors your parameters.   This must be customized for your call. A separate struct is used here because it simplifies the sizeof calculation for the <code>componentParamSize</code> field. Parameters in this struct are specified in reverse order from the parameter list.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Remember that the struct mirrors 68K stack alignment, not 68K struct alignment. This means that byte parameters, e.g., char or Boolean, get passed as two bytes, not one. The struct must mirror that fact, so you must declare byte fields to be a byte field followed by a pad byte field and take it into account in your parameter size calculations. </P></TD></TR></TABLE></CENTER><BR><P>Once you have the struct, initialize it as shown in the example, and call the component via <code>CallUniversalProc</code> with the <code>CallComponentUPP</code>.  <code>CallComponentUPP</code> is declared for you and is part of the InterfaceLib. You don't need to do anything special to use it.</P><P><code>uppCallComponentProcInfo</code> should have been in the interfaces, because the call is always the same, but it's not, so it's defined below.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    uppCallComponentProcInfo = kPascalStackBased            | RESULT_SIZE(kFourByteCode)            | STACK_ROUTINE_PARAMETER(1, kFourByteCode)};</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><A NAME="RTFToC2"></A><h2>Code for the Glue Function</h2><P>Once you have the structure defined, create an instantiation of it, and initialize it. Finally, call the component using <code>CallUniversalProc</code> as shown in the following example.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal  ComponentResult  DrawerSetup (ComponentInstance myInstance, Rect *r){#define kDrawerSetupParamSize    (sizeof (DrawerSetupParams))#ifdef powerc#pragma options align=mac68k#endif    struct DrawerSetupParams {        Rect    *theRect; /* Your parameters go here!!  In reverse                          order from parameter list. */    };    typedef struct DrawerSetupParams DrawerSetupParams;    struct DrawerSetupGluePB {        unsigned char componentFlags; /* Flags - set to zero */        unsigned char componentParamSize; /* Size of the params struct */        short componentWhat; /* The component request selector */        DrawerSetupParams params; /* The parameters, see above */        ComponentInstance instance; /* This component instance */    };    typedef struct DrawerSetupGluePB DrawerSetupGluePB;#ifdef powerc#pragma options align=reset#endif    DrawerSetupGluePB myDrawerSetupGluePB;    myDrawerSetupGluePB.componentFlags = 0;    myDrawerSetupGluePB.componentParamSize = kDrawerSetupParamSize;    myDrawerSetupGluePB.componentWhat = kDrawerSetUpSelect;    myDrawerSetupGluePB.params.theRect = r;    myDrawerSetupGluePB.instance = myInstance;    return CallUniversalProc(CallComponentUPP,        uppCallComponentProcInfo,  &amp;myDrawerSetupGluePB);}</pre>	</TD></TR></TABLE></CENTER><p>Repeat the above steps for all the public functions for your component. To allow for future updating, the best way to make this glue available to your clients is to build the glue into a Code Fragment Manager shared library that is built into your component. Provide your client with an XCOFF file to link against. That way, if the glue changes, the client applications will not have to be relinked.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Be sure you choose a unique name for the glue library to avoid possible name conflicts.</p></TD></TR></TABLE></CENTER><BR> <h3>Creating the extended 'thng' ComponentResource</h3><p>Here is how to create the <code>'thng'</code> ComponentResource for a component that supports both platform68k and platformPowerPC. This is the source for MPW Rez using the latest version of Types.r that supports the <code>UseExtendedThingResource</code> template. Before using the new Types.r you need to define the UseExtendedThingResource conditional with the value 1.</p><p>A  component defined with this resource will work for all previous versions of the Component Manager. By keeping the original portions of the ComponentResource setup for the platform68k information, it allows your component to work on all 68K Macintosh computers. Adding the new information about your code fragment for the Power Macintosh allows the Component Manager for that machine to use your native code.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>resource 'thng' (128, purgeable) {    kComponentType,    kComponentSubType,    kComponentCreator,    cmpWantsRegisterMessage,    kAnyComponentFlagsMask,    k68KCodeType, k68KCodeID,    'STR ', kComponentNameStringID,    'STR ', kComponentInfoStringID,    'ICON', kComponentIconID,#if UseExtendedThingResource        0x00010001,                     /* version 1.1 */    componentHasMultiplePlatforms,    kComponentIconFamilyID,    {cmpWantsRegisterMessage, k68KCodeType, k68KCodeID, platform68k,    cmpWantsRegisterMessage, kPowerPCCodeType, kPowerPCCodeID,    platformPowerPC    };#endif};</pre>	</TD></TR></TABLE></CENTER><P>If you have a component that only supports the 68K Macintosh, then you do not need to use the extended ComponentResource structure. However, if you wish to utilize Icon Families and automatic version registration, then use the extended <code>ComponentResource</code> without the <code>ComponentPlatformInfo</code> and do not set the <code>componentHasMultiplePlatforms</code> flag of the <code>componentRegisterFlags</code>. You may also include the <code>ComponentPlatformInfo</code> if you wish to and just have a single element that describes your 68K component code.</p><P>If you have a "fat" component, with both 68K and PowerPC code, set the component flags as you would for the 68K only case and duplicate that information in the <code>ComponentPlatformInfo</code> portion of the extended resource.  That will allow your component to work correctly for versions of the Component Manager that are not aware of the extended 'thng' resource.</p><P>If you have a component that only supports the PowerPC in native mode, then you must use the extended <code>ComponentResource</code>. In this case, some care must be taken so that the component will not be registered on 68K machines. Set the <code>ResourceSpec</code> field in the non-extended part of the 'thng' resource to zero. In addition, set the component flags in the non-extended part  of the resource to <code>cmpWantsRegisterMessage</code>, regardless of whether or not you handle the register message. This will cause the 68K Component Manager to attempt to register your component, it will fail, because there is no 68K code resource and your component will not be registered.</p><P>For the PowerPC case, you need to include a single ComponentPlatformInfo element that describes your PowerPC native component code for PowerPC implementations of your component to be registered. Set the component flags in the extended portion of the resource as you would normally. </p><P><A HREF="#top">Back to top</A></P><a name="RTFToC3"></A><h2>Component Manager Interfaces</h2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* MPW Rez interfaces */#define cmpWantsRegisterMessage (1&lt;&lt;31) /* bits for component flags */#define componentDoAutoVersion (1&lt;&lt;0) /* bits for registration flags */#define componentWantsUnregister (1&lt;&lt;1)#define componentAutoVersionIncludeFlags (1&lt;&lt;2)#define componentHasMultiplePlatforms (1&lt;&lt;3)type 'thng' {    literal longint; /* Type */    literal longint; /* Subtype */    literal longint; /* Manufacturer */    unsigned hex longint; /* component flags */    unsigned hex longint        kAnyComponentFlagsMask = 0; /* component flags Mask */    literal longint; /* Code Type */    integer; /* Code ID */    literal longint; /* Name Type */    integer; /* Name ID */    literal longint; /* Info Type */    integer; /* Info ID */    literal longint; /* Icon Type */    integer; /* Icon ID */#if UseExtendedThingResource    unsigned hex longint; /* version of Component */    longint; /* flags for registration */    integer; /* resource id of Icon Family */    longint = $$CountOf(ComponentPlatformInfo);    wide array ComponentPlatformInfo {        unsigned hex longint; /* component  flags */        literal longint; /* Code Type */        integer; /* Code ID */        integer platform68k = 1,            platformPowerPC = 2; /* platform type */        };#endif};/* MPW C interfaces */enum {#define gestaltComponentMgr 'cpnt' /* Component Mgr version */#define gestaltQuickTimeFeatures 'qtrs' /* QuickTime features */    gestaltPPCQuickTimeLibPresent = 0,        /* PowerPC QuickTime glue library is present */#define gestaltSysArchitecture 'sysa' /* Native System Architecture */    gestalt68k = 1, /* Motorola MC68K architecture */    gestaltPowerPC = 2, /* IBM PowerPC architecture */    /* componentRegisterFlags flags for ComponentResourceExtension */    componentDoAutoVersion = (1&lt;&lt;0),    componentWantsUnregister = (1&lt;&lt;1),    componentAutoVersionIncludeFlags = (1&lt;&lt;2),    componentHasMultiplePlatforms = (1&lt;&lt;3)};struct ComponentPlatformInfo{    long componentFlags; /* flags of Component */    ResourceSpec component; /* resource where Component code is found */    short platformType; /* gestaltSysArchitecture result */};typedef struct ComponentPlatformInfo ComponentPlatformInfo;struct ExtComponentResource {    ComponentDescription cd; /* Registration parameters */    ResourceSpec component; /* resource where Component code is found */    ResourceSpec componentName; /* name string resource */    ResourceSpec componentInfo; /* info string resource */    ResourceSpec componentIcon; /* icon resource */    // new data for Component Manager version 3    long componentVersion; /* version of Component */    long componentRegisterFlags; /* flags for registration */    short componentIconFamily; /* resource id of Icon Family */    long count; /* elements in platformArray */    ComponentPlatformInfo platformArray[1];};typedef struct ExtComponentResource ExtComponentResource;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><A NAME="References"></a><H2>References</h2><P><a href="http://developer.apple.com/documentation/mac/MoreToolbox/MoreToolbox-333.html#HEADING333-0"><cite>Inside Macintosh: More Macintosh Toolbox (Component Manager)</cite></A></p><p><a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-17.html#HEADING17-0"><cite>Inside Macintosh: PowerPC System Software (Mixed Mode Manager and Code Fragment Manager)</cite></A>. </p><P><A HREF="#top">Back to top</A></P>                           <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (76K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1004.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1004.html%3Fid%3DDTS10002847-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1004.html%3Fid%3DDTS10002847-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1004.html%3Fid%3DDTS10002847-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>