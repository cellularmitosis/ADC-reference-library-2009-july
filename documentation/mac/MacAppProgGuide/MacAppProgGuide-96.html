<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--The Mouse (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING96></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-95.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-97.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-94.html"><B>Chapter 15 - Working With the Mouse</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING96-0></A>
<H1><A NAME=MARKER-9-20></A><A NAME=MARKER-2-21></A>Recipes--The Mouse</H1>
 The recipes and sample code in this section demonstrate how to implement a recordable drawing command, respond to a drawing Apple event, drag with the mouse, and implement autoscrolling in a tracker command. <A HREF=#MARKER-9-23>Figure 15-1</A> shows the classes and methods used to create commands that track the mouse.<P>
<B>Figure 15-1  <A NAME=MARKER-2-22></A><A NAME=MARKER-9-23></A>Classes and methods used to track the mouse</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-077.gif"><P>
<A NAME=HEADING96-4></A>
<H2><A NAME=MARKER-2-24></A><A NAME=MARKER-9-25></A>Recipe--Implementing a Recordable Drawing Command</H2>
 MacApp's IconEdit sample application supports drawing an icon at any level of magnification. A user can click the mouse button to turn an individual pixel on or off, or click and drag to modify a series of pixels. Drawing is performed by a command that tracks the mouse and modifies pixels. Drawing is recordable because, on completion, the command sends an Apple event that describes the drawing that took place. (The recipe following this one describes how to respond to a drawing Apple event.)<P>
 To implement a recordable, undoable drawing command, you perform these steps:<P>
<OL>
<LI>Define a command constant for a drawing command.
<LI>Add a Buzzwords menu entry to supply menu text for undoing the command.
<LI>Define a subclass of <CODE>TTracker</CODE> to track the mouse and perform drawing.<P>
<UL>
<LI>Provide constructor, destructor, and initialization methods.
<LI>Override the <CODE>DoIt</CODE>, <CODE>UndoIt</CODE>, and <CODE>RedoIt</CODE> methods.
<LI>Override the <CODE>TrackConstrain</CODE> method.
<LI>Override the <CODE>TrackFeedback</CODE> method.
<LI>Override the <CODE>TrackMouse</CODE> method.<P>
</UL>
<LI>Define a class to send an Apple event describing the drawing operation.
<LI>Override the <CODE>DoMouseCommand</CODE> method in the view class to create and post a drawing command.<P>
</OL>
 The sample code shown in this recipe is from the IconEdit application.<P>
<A NAME=HEADING96-18></A>
<H3>Define a Command Constant for a Drawing Command</H3>
 The IconEdit application defines a command number for the icon-drawing command in both its resource definition file and its implementation file. In the resource file, <CODE>IconEdit.r</CODE>, the command is defined as<P>
<PRE>
#define cDrawCommand1003
</PRE>
 In the implementation file, <CODE>IconEdit.cp</CODE>, the command is defined as<P>
<PRE>
const CommandNumber cDrawCommand =1003; // For drawing in icon view.
</PRE>
 As an alternative, IconEdit could place the <CODE>#define</CODE> definition in a header file (such as <CODE>IconEdit.r.h</CODE>), then include it into both the resource definition file (<CODE>IconEdit.r</CODE>) and the C++ code file (<CODE>IconEdit.cp</CODE>). Because the constant is defined in only one place, there is less chance for error. However, the type checking provided by the const CommandNumber definition is lost.<P>
<A NAME=HEADING96-24></A>
<H3>Add a Buzzwords Menu Entry</H3>
 When a command (such as Cut) appears in a menu, MacApp uses the text from the menu item for the Undo menu command (Undo Cut). Because the drawing command does not appear in any menu, you must inform MacApp of the text to display for Undo. You supply this information in a special <CODE>'CMNU'</CODE> resource called the <I>Buzzwords menu</I> (described beginning on <A HREF=MacAppProgGuide-86.html#MARKER-9-40>page 305</A>).<P>
 The IconEdit application uses the following line in its Buzzwords menu in the file <CODE>IconEdit.r</CODE>:<P>
<PRE>
/* [2] */&quot;Drawing&quot;, noIcon, noKey, noMark, plain, cDrawCommand;
</PRE>
 This line tells MacApp to display the text "Undo Drawing" when Undo is enabled for a command object with the command number cDrawCommand.<P>
<A NAME=HEADING96-29></A>
<H3>Define a Subclass of TTracker to Track the Mouse and Perform Drawing</H3>
 The IconEdit application defines the class <CODE>TIconDrawCommand</CODE> to perform user icon drawing.<P>
<PRE>
class TIconDrawCommand : public TTracker
{
   MA_DECLARE_CLASS;

  protected:
   TIconDocument*fIconDocument;// The document affected by this command.
   TIconEditView*fIconEditView;// The view in which this command draws.
   TIconBitMap*fIconBitMap;// The icon in which drawing takes place.
   TIconBitMap*fIconBitMapModel;// Place of storage for points to be drawn
                           // by Apple event.
   TIconBitMap*fOriginalIcon;// A copy of the original icon.
   Boolean     fTurnBitsOn;// A flag for turning bits on or off.
   CRGBColor   fColor;     // Drawing color (property of fIconDocument).
   
  public:
   TIconDrawCommand();     // Constructor.
   virtual ~TIconDrawCommand();// Destructor.

   virtual void IIconDrawCommand(TIconEditView* itsIconEditView, 
                           TIconDocument* itsIconDocument, 
                           VPoint&amp;     theMouse);

   // Each of these methods sets the icon bitmap, using the fIconBitMap and
   // fOriginalIcon fields to switch between the do, undo, and redo icons.
   virtual void DoIt();    // Override.
   virtual void RedoIt();  // Override.
   virtual void UndoIt();  // Override.
   virtual void TrackConstrain(TrackPhaseaTrackPhase, 
                           const VPoint&amp;anchorPoint, 
                           const VPoint&amp;previousPoint,
                           VPoint&amp;     nextPoint, 
                           Boolean     mouseDidMove);// Override.

   virtual void TrackFeedback(TrackPhaseaTrackPhase,
                           const VPoint&amp;anchorPoint, 
                           const VPoint&amp;previousPoint, 
                           const VPoint&amp;nextPoint, 
                           Boolean     mouseDidMove, 
                           Boolean     turnItOn);  // Override.

   virtual TTracker* TrackMouse(TrackPhaseaTrackPhase, 
                           VPoint&amp;     anchorPoint, 
                           VPoint&amp;     previousPoint, 
                           VPoint&amp;     nextPoint, 
                           Boolean     mouseDidMove);// Override.
}; // TIconDrawCommand
</PRE>
 Each of the methods of the TIconDrawCommand class is discussed in the sections that follow.<P>
<A NAME=HEADING96-34></A>
<H4>Constructor</H4>
 The constructor method for TIconDrawCommand is called automatically when a drawing command is instantiated with the <CODE>new</CODE> operator. It sets the object's fields to default or safe values:<P>
<PRE>
TIconDrawCommand::TIconDrawCommand() 
{
   fIconDocument = NULL;
   fIconEditView = NULL;
   fIconBitMap = NULL;        
   fOriginalIcon = NULL;
   fTurnBitsOn = TRUE;
   fIconBitMapModel = NULL;
}
</PRE>
<DL>
<DT><B>Note</B>
<DD>The default is to turn bits on when drawing, but in fact, fTurnBitsOn is reset when drawing begins, based on whether the bit under the mouse is on or off.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING96-38></A>
<H4>Destructor</H4>
 The destructor method for TIconDrawCommand is called automatically when an object of this type is deleted. It frees whichever icon bitmap is not in use: if the command is done, it frees the original bitmap; if the command is undone, it frees the modified bitmap (so in effect, no drawing took place). It always frees the bitmap model, which is used to store points to be drawn by an Apple event (if any drawing actually takes place):<P>
<PRE>
TIconDrawCommand::~TIconDrawCommand()
{
   // If the command is done, dispose of original icon.
   // Otherwise, dispose of icon that was drawn.
   if (fCommandDone)
      fOriginalIcon = (TIconBitMap*)FreeIfObject(fOriginalIcon);
   else
      fIconBitMap = (TIconBitMap*)FreeIfObject(fIconBitMap);

   // Free the bitmap model.
   fIconBitMapModel = (TIconBitMap*)FreeIfObject(fIconBitMapModel);
}
</PRE>
<A NAME=HEADING96-41></A>
<H4>Initialization Method</H4>
 The following is the initialization method for the TIconDrawCommand class:<P>
<PRE>
void TIconDrawCommand::IIconDrawCommand(TIconEditView*itsIconEditView,
                                 TIconDocument*itsIconDocument,
                                 VPoint&amp;     theMouse)
{
   this-&gt;ITracker(cDrawCommand,// Initialize the command . . .
               itsIconDocument,// Its context.
               kCanUndo,      // Command is undoable.
               kCausesChange, // Command changes its document.
               itsIconDocument,// Associate it with a notifying object.
               itsIconEditView,// Associate it with a view.
                              // Associate it with a scroller from
                              // any superview.
               itsIconEditView-&gt;GetScroller(TRUE),
               theMouse);     // Initial point.
   fConstrainsMouse = TRUE;   // Want TrackConstrain called.

   fIconEditView = itsIconEditView;// Set two convenience fields.
   fIconDocument = itsIconDocument;
                              // Get reference to icon being drawn.
   fIconBitMap = fIconDocument-&gt;ReturnBitMap();
   fIconBitMapModel = new TIconBitMap;// Create a model for the bits being set.
   fIconBitMapModel-&gt;IIconBitMap();
   fIconBitMapModel-&gt;Clear();
   
   fColor = fIconDocument-&gt;GetIconColor();// Store the drawing color.
}
</PRE>
 The IIconDrawCommand method first calls the initialization method of its parent class, <CODE>TTracker</CODE>. It then sets fConstrainsMouse to <CODE>TRUE</CODE> so that the TrackConstrain method will be called. It also sets two convenience fields that refer to document and view objects. Finally, its sets the fIconBitMap field to the current bitmap (the current icon bitmap before any drawing takes place) and creates an empty bitmap to store a record of each bit that is modified (to use when sending an Apple event to describe whatever drawing takes place).<P>
 Note that the <CODE>fOriginalIcon</CODE> field is initialized to a copy of the <CODE>fIconBitMap</CODE> field the first time the <CODE>TrackMouse</CODE> method is called (shown below).<P>
<A NAME=HEADING96-46></A>
<H4>TrackConstrain</H4>
 Drawing commands typically constrain the mouse to deal with border areas or to snap drawing to a grid. Views in the IconEdit application have a border area in which drawing is not allowed, so the <CODE>TrackConstrain</CODE> method constrains drawing to the content area of the window, adjusted for the border area:<P>
<PRE>
void TIconDrawCommand::TrackConstrain(TrackPhase/*aTrackPhase*/,
                              const VPoint&amp;/*anchorPoint*/ ,
                              const VPoint&amp;/*previousPoint*/,
                              VPoint&amp;     nextPoint,
                              Boolean     /*mouseDidMove*/)
{
   // This is on several lines so that Max can be &quot;inlined&quot;.
   VCoordinate h = Min(nextPoint.h, fIconEditView-&gt;fSize.h - kBorder - 1);
   VCoordinate v = Min(nextPoint.v, fIconEditView-&gt;fSize.v - kBorder - 1);
   h = Max(h, (long) kBorder);
   v = Max(v, (long) kBorder);
   nextPoint = VPoint(h, v);
}
</PRE>
 Note that the <CODE>TrackConstrain</CODE> method does not use most of its parameters, so they are commented out to avoid compiler warnings.<P>
<A NAME=HEADING96-50></A>
<H4>TrackFeedback</H4>
 The default feedback provided by the <A NAME=MARKER-2-26></A><CODE>TrackFeedback</CODE> method of the <CODE>TTracker</CODE> command is a gray rectangle that expands and contracts as the user drags with the mouse. Because the TIconDrawCommand class turns the icon bits on or off in the <CODE>TrackMouse</CODE> method (shown below) as drawing takes place, no other feedback is needed. To disable the default feedback, the TIconDrawCommand class overrides the <CODE>TrackFeedback</CODE> method with an empty implementation.<P>
<PRE>
void TIconDrawCommand::TrackFeedback(
      TrackPhase  /*aTrackPhase*/,const VPoint&amp;/*anchorPoint*/,
      const VPoint&amp;/*previousPoint*/,const VPoint&amp;/*nextPoint*/,
      Boolean     /*mouseDidMove*/,Boolean   /*turnItOn*/)
{
   // Overridden to avoid default feedback.
}
</PRE>
 Since this method does nothing, all parameters are commented out.<P>
<A NAME=HEADING96-54></A>
<H4>TrackMouse</H4>
 For the TIconDrawCommand class, the TrackMouse method tracks the mouse, turns bits on or off, and, when drawing is complete, sends an Apple event describing the operation.<P>
<PRE>
TTracker* TIconDrawCommand::TrackMouse(TrackPhaseaTrackPhase,
                              VPoint&amp;  /*anchorPoint*/,
                              VPoint&amp;  previousPoint,
                              VPoint&amp;  nextPoint,
                              Boolean  mouseDidMove)
{
   VPointfromBit;
   VPointtoBit;
   VPointiconBit;
   short lineLength;
   float deltaH;
   float deltaV;
   float h;
   float v; 
   
   // Convert nextPoint and previousPoint to bit locations in the icon.
   fIconEditView-&gt;PointToBit(fIconEditView-&gt;ViewToQDPt(nextPoint), toBit);
   fIconEditView-&gt;PointToBit(fIconEditView-&gt;ViewToQDPt(previousPoint), fromBit);
   
   if (aTrackPhase == trackBegin) // First time through.
   {
      // Determine whether to turn bits on or off.
      fTurnBitsOn =!fIconBitMap-&gt;GetBit(toBit);
      // Make a copy of the original bitmap for undo.
      fOriginalIcon = fIconBitMap-&gt;Copy();
   }
   // If mouse moved since last time . . .
   if (mouseDidMove)
   {
      // The following sets bits in the icon from the bit at previousPoint to the bit
      // at nextPoint.  It is based on a simple line-drawing algorithm. The line
      // length calculations are on two lines so Max can be inlined.

      lineLength = (short) Max(labs(toBit.h - fromBit.h), labs(toBit.v - fromBit.v));
      lineLength = (short) Max(1,lineLength);
      
      deltaH = (toBit.h - fromBit.h) / lineLength;
      deltaV = (toBit.v - fromBit.v) / lineLength;

      h = fromBit.h + 0.5;
      v = fromBit.v + 0.5;
      
      for (short i = 0; i &lt; lineLength; i++)
      {
         iconBit.h = h;
         iconBit.v = v;

         // Set the bit in the bitmap and draw it in the icon view.
         fIconBitMap-&gt;SetBit(iconBit, fTurnBitsOn);
         fIconEditView-&gt;DrawBit(iconBit, fTurnBitsOn, fColor);
         
         // Store the change by setting a bit in the model. The model will be
         // used to generate a Draw Points event for recordability.
         fIconBitMapModel-&gt;SetBit(iconBit, TRUE);

         h = h + deltaH;
         v = v + deltaV;
      }
   }
   // If finished tracking.
   if (aTrackPhase == trackEnd)
   {
      // Send a recordable Apple event. (NOTE: It would be more robust to
      // post a recordable, undoable command to do the drawing.) 
      TDrawPointsAppleEvent *aDrawEvent = new TDrawPointsAppleEvent;
      aDrawEvent-&gt;IDrawPointsAppleEvent(fIconDocument,fIconBitMapModel,fTurnBitsOn);
      aDrawEvent-&gt;Send();
   }
   // Return same command object.
   return this;
}  // TIconDrawCommand::TrackMouse
</PRE>
 The TrackMouse method is called repeatedly until the user releases the mouse button. It makes use of the <CODE>aTrackPhase</CODE> parameter to determine what state the mouse is currently in: <CODE>trackBegin</CODE> indicates tracking has just begun (TrackMouse is called for the first time),  <CODE>trackContinue</CODE> indicates tracking is continuing,  and <CODE>trackEnd</CODE> indicates the user has released the mouse (TrackMouse won't be called again).<P>
 The <CODE>TrackMouse</CODE> method first converts the <CODE>nextPoint</CODE> and <CODE>previousPoint</CODE> mouse location parameters to bit locations in the icon. Then, if the track phase is <CODE>trackBegin</CODE>, it performs two operations. It sets fTurnBitsOn based on whether the first bit was on or off--all bits will be turned on or off based on the first changed bit. And it creates a copy of the original icon bitmap in case drawing is undone.<P>
 If the mouse has moved, <CODE>TrackMouse</CODE> determines which bits have been affected. For each modified bit, it does the following:<P>
<UL>
<LI>It sets the bit in the icon bitmap.
<LI>It causes the bit to be redrawn.
<LI>It sets the bit in the <CODE>fIconBitMapModel</CODE> field, which stores a record of each modified bit.<P>
</UL>
 If the track phase is <CODE>trackEnd</CODE>, <CODE>TrackMouse</CODE> creates and initializes a <CODE>TDrawPointsAppleEvent</CODE> object and calls its <CODE>Send</CODE> method to send an Apple event describing the drawing that occurred. The <CODE>TDrawPointsAppleEvent</CODE> class is described in the next section.<P>
 Finally, each time <CODE>TrackMouse</CODE> is executed it must return a command object to be called as tracking continues. The <CODE>TrackMouse</CODE> method could create a new command object each time, but it is more efficient to return the same command object, which is done by the line<P>
  return this;<P>
<A NAME=HEADING96-66></A>
<H3>Define a Class to Send an Apple Event Describing the Drawing Operation</H3>
 The IconEdit application defines the <CODE>TDrawPointsAppleEvent</CODE> class, a subclass of <CODE>TAppleEvent</CODE>, to send an Apple event that turns points in a bitmap on or off. The command's initialization method, <CODE>IDrawPointsAppleEvent</CODE>, does the following:<P>
<UL>
<LI>It creates an Apple event.
<LI>It extracts the points from the passed icon bitmap and stores them in a dynamic array point list.
<LI>It writes the point list to the Apple event's parameter list.
<LI>If the drawing operation turns bits off, it adds a Boolean parameter indicating that the points should be erased.<P>
</UL>
 The recipe following this one shows how to handle the Draw Points event by posting an undoable drawing command.<P>
<A NAME=HEADING96-73></A>
<H3>Override DoMouseCommand to Create and Post a Drawing Command</H3>
 With the previous steps completed, the framework is in place to supply an undoable, recordable command for drawing with the mouse. The <CODE>TIconEditView</CODE> class overrides the <CODE>DoMouseCommand</CODE> method:<P>
<PRE>
void TIconEditView::DoMouseCommand(VPoint&amp;theMouse,
                           TToolboxEvent*/*event*/ ,
                           CPoint      /*hysteresis*/)
{
   VPoint         iconBit;
   TIconDrawCommand*anIconDrawCommand;

   // If the mouse location is within the icon, create and post
   // a command for icon drawing. Otherwise, ignore it (don't
   // call Inherited).
   if (this-&gt;PointToBit(theMouse, iconBit))
   {
      anIconDrawCommand = new TIconDrawCommand;
      anIconDrawCommand-&gt;IIconDrawCommand(this, fIconDocument,
                                 theMouse);
      this-&gt;PostCommand(anIconDrawCommand);
   }
}
</PRE>
 If the mouse location is within the view's icon, this method creates a drawing command and posts it to the MacApp command queue. Otherwise, it does nothing.<A NAME=MARKER-2-27></A><P>
<A NAME=HEADING96-77></A>
<H2><A NAME=MARKER-2-28></A>Recipe--Supporting Drawing Specified by an Apple Event</H2>
 The previous recipe implements a drawing command that sends an Apple event to describe the drawing that takes place in an icon view (turning individual bits in the icon on or off). This recipe describes how an application can respond to that Draw Points event.<P>
 To support drawing specified by a Draw Points event, you perform these steps:<P>
<OL>
<LI>Define a command constant for a command that performs drawing based on the information in a Draw Points event.
<LI>Add a Buzzwords menu entry to supply menu text for undoing the command.
<LI>Describe the Draw Points event in the <CODE>'aete'</CODE> resource.
<LI>Map the Draw Points event to a command number in an <CODE>'aedt'</CODE> resource.
<LI>Define a command class to work with the Draw Points event.
<LI>Override the <CODE>DoScriptCommand</CODE> method in the document class to create a draw points command when the Draw Points event is received.<P>
</OL>
 The sample code shown in this recipe is from the IconEdit application.<P>
<A NAME=HEADING96-87></A>
<H3>Define a Command Constant for a Draw Points Command</H3>
 The IconEdit application defines a command number for a draw points command in both its resource definition file and its implementation file. In the resource file, <CODE>IconEdit.r</CODE>, the command is defined as<P>
<PRE>
#define cDrawPointsCommand1004
</PRE>
 In the implementation file, <CODE>IconEdit.cp</CODE>, the command is defined as<P>
<PRE>
const CommandNumber cDrawPointsCommand = 1004;
</PRE>
<A NAME=HEADING96-92></A>
<H3>Add a Buzzwords Menu Entry</H3>
 The IconEdit application uses the following line in its Buzzwords menu in the file <CODE>IconEdit.r</CODE>:<P>
<PRE>
/* [3] */&quot;Drawing&quot;, noIcon, noKey, noMark, plain, cDrawPointsCommand;
</PRE>
 This line tells MacApp to display the text "Undo Drawing" when Undo is enabled for a command object with the command number cDrawPointsCommand.<P>
<A NAME=HEADING96-96></A>
<H3>Describe the Draw Points Event in the 'aete' Resource</H3>
 The Apple event terminology extension (<CODE>'aete'</CODE>) resource is described in <A HREF=MacAppProgGuide-48.html#MARKER-9-19>Chapter 6, "Scripting."</A> MacApp provides an <CODE>'aete'</CODE> resource that defines terminology for the four required Apple events, as well as for all of the events in the Core suite supported by MacApp.<P>
 The IconEdit application extends MacApp's <CODE>'aete'</CODE> resource to add information describing the Draw Points event. IconEdit's <CODE>'aete'</CODE> resource, shown on the following pages, is defined in the file <CODE>IconEdit.r</CODE>.<P>
<PRE>
resource kAETerminologyExtension (0,
#if qNames
   &quot;English Terminology&quot;,
#endif
   purgeable)
{
   // Some text omitted.

   //==========================
   // IconEdit Suite
   //==========================

      // [4]
   &quot;IconEdit Suite&quot;,
      &quot;Events that are specific to the IconEdit application&quot;,
      'ICED',
      1,
      1,
      {  // array Events: 4 elements
         // [1]
         &quot;invert&quot;,

         // Some text omitted.

         // [4]
         &quot;draw_points&quot;,
         &quot;draw or erase a list of points in the specified view.&quot;,
         'ICED', 'DrPt', noReply, &quot;&quot;, replyOptional,
         singleItem, notEnumerated, notTightBindingFunction,
         Reserved8,
         verbEvent,
         Reserved3,
         typeObjectSpecifier,
         &quot;the document containing the bitmap to draw in&quot;,
         directParamRequired,
         singleItem, notEnumerated, doesntChangeState,
         Reserved12,
         {  // array OtherParams: 2 elements
            // [1]
            &quot;points&quot;, 'kPtL', cAEList,
            &quot;list of points to draw or erase&quot;,
            required,
            listOfItems, notEnumerated,
            Reserved9,
            prepositionParam, notFeminine, notMasculine, singular,
            // [2]
            &quot;do_erase&quot;, 'kErs', typeBoolean,
            &quot;optional parameter to erase points (default is draw)&quot;,
            optional, singleItem, notEnumerated,
            Reserved9,
            prepositionParam, notFeminine, notMasculine, singular
         }
         // Some text omitted.
      }
}
</PRE>
 The IconEdit application adds four events for the "IconEdit suite" of Apple events. The Draw Points Apple event definition explains that the Apple event draws or erases a list of points in the specified view. The definition further states that the Apple event<P>
<UL>
<LI>must specify a document
<LI>must specify a list of points
<LI>may optionally specify a Boolean value indicating that the points should be erased (the default is to draw points)<P>
</UL>
 For more information about the format of an <CODE>'aete'</CODE> resource, see the "Apple Event Terminology Resources" chapter of <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.<P>
<A NAME=HEADING96-105></A>
<H3>Map the Draw Points Event to a Command Number</H3>
 The IconEdit application uses the following <CODE>'aedt'</CODE> resource to map the Apple events it defines to MacApp command numbers:<P>
<PRE>
resource 'aedt' (kAEIconEditDispatchTable, 
#if qNames
   &quot;IconEdit Events&quot;,
#endif
   purgeable) {
   {  // array: 4 elements
      // [1]
      'ICED', 'INVT', cInvert,
      // [2]
      'ICED', 'ZmIn', cZoomIn,
      // [3]
      'ICED', 'ZmOt', cZoomOut,
      // [4]
      'ICED', 'DrPt', cDrawPointsCommand
   }
};
</PRE>
 This table tells the Apple Event Manager that when the application receives an Apple event with class ID 'ICED' and descriptor 'DrPt', it should be mapped to the command number cDrawPointsCommand.<P>
<A NAME=HEADING96-109></A>
<H3>Define a Command Class to Work With the Draw Points Event</H3>
 The IconEdit application defines the <CODE>TDrawPointsCommand</CODE> class to extract information from a Draw Points event and perform the specified drawing.<P>
 The <CODE>TDrawPointsCommand</CODE> class is defined as follows:<P>
<PRE>
class TDrawPointsCommand : public TCommand
{
   MA_DECLARE_CLASS;

  protected:
   TIconBitMap*fSavedBitMap;// Used in undoing and redoing.
   TIconDocument*fIconDocument; // Document affected by the command.
   Boolean     fErasePoints;// If TRUE, erase, not draw.
   TDynamicArray*fPointList;// List of points to set or clear.

  public:
   TDrawPointsCommand();   // Constructor.
   virtual ~TDrawPointsCommand();// Destructor.
   virtual void IDrawPointsCommand(TIconDocument *itsIconDocument,
                           TAppleEvent *theAppleEvent);
   virtual void DoIt();    // Override.
   virtual void RedoIt();  // Override.
   virtual void UndoIt();  // Override.
};
</PRE>
<A NAME=HEADING96-113></A>
<H4>Constructor and Destructor</H4>
 The constructor method sets fields to safe or default values:<P>
<PRE>
TDrawPointsCommand::TDrawPointsCommand()
{
   fSavedBitMap = NULL;
   fIconDocument = NULL;
   fErasePoints = FALSE; // By default, turn bits on.
}
</PRE>
 The destructor method frees any storage that needs freeing:<P>
<PRE>
TDrawPointsCommand::~TDrawPointsCommand()
{
   if (fCommandDone)
      fSavedBitMap = (TIconBitMap *)FreeIfObject(fSavedBitMap);
   fPointList = (TDynamicArray *)FreeIfObject(fPointList);
}
</PRE>
<A NAME=HEADING96-118></A>
<H4>Initialization Method</H4>
 The initialization method for the TDrawPointsCommand class initializes the command and extracts drawing information from the Draw Points event:<P>
<PRE>
void TDrawPointsCommand::IDrawPointsCommand(
                           TIconDocument*itsIconDocument,
                           TAppleEvent*theAppleEvent)
{
   fIconDocument = itsIconDocument;
   
   // Initialize the parent command class.
   this-&gt;ICommand(cDrawPointsCommand,
               itsIconDocument, 
               kCanUndo, 
               kCausesChange, 
               itsIconDocument);
   
   // Create an array and read the list of points from the Apple event.
   fPointList = new TDynamicArray;
   fPointList-&gt;IDynamicArray(1, sizeof(CPoint));
   theAppleEvent-&gt;ReadPtrList(keyPointList, typeQDPoint, fPointList);
         
   // Look for the optional erasePoints parameter. 
   if (theAppleEvent-&gt;HasParameter(keyErasePoints))
      fErasePoints = theAppleEvent-&gt;ReadBoolean(keyErasePoints);
}
</PRE>
<A NAME=HEADING96-121></A>
<H4>DoIt Method</H4>
 The TDrawPointsCommand<CODE>::DoIt</CODE> method creates a copy of the document's current bitmap, sets or erases the bits specified by the point list, and causes a redraw to occur. It also frees the point list, since it won't be needed anymore:<P>
<PRE>
void TDrawPointsCommand::DoIt()
{
   // Get the current bitmap from the document and make a copy.
   TIconBitMap*targetBitMap = fIconDocument-&gt;ReturnBitMap();
   fSavedBitMap = targetBitMap-&gt;Copy();
   
   // Draw the points listed in the point list.
   CArrayIteratoriter(fPointList);
   CPoint   aPoint;
   VPoint   iconBit;
   
   for (ArrayIndex i = iter.FirstIndex(); iter.More();
         i = iter.NextIndex())
   {
      fPointList-&gt;GetElementsAt(i, (Point *)aPoint, 1);
      iconBit.h = aPoint.h;
      iconBit.v = aPoint.v;
      // Set the bit in the document's bitmap.
      targetBitMap-&gt;SetBit(iconBit, !fErasePoints);
   }
   // Setting the icon will cause a redraw.
   fIconDocument-&gt;SetIcon(targetBitMap);
   // Free the point list--it won't be used again.
   fPointList = (TDynamicArray *)FreeIfObject(fPointList);
}
</PRE>
<A NAME=HEADING96-124></A>
<H4>UndoIt and RedoIt Methods</H4>
 The <CODE>UndoIt</CODE> method switches the current and saved bitmaps:<P>
<PRE>
void TDrawPointsCommand::UndoIt()
{
   // Switch the document's current bitmap with the saved bitmap.
   TIconBitMap *tempBitMap = fIconDocument-&gt;ReturnBitMap()-&gt;Copy();
   fIconDocument-&gt;SetIcon(fSavedBitMap);
   fSavedBitMap = tempBitMap;
}
</PRE>
 The <CODE>RedoIt</CODE> method is identical to the <CODE>UndoIt</CODE> method.<P>
<A NAME=HEADING96-128></A>
<H3>Override DoScriptCommand to Create a Draw Points Command</H3>
 The Apple event sent by IconEdit's <CODE>TIconDrawCommand</CODE> specifies the document as the target object. The <CODE>TIconDocument</CODE> class overrides the <CODE>DoScriptCommand</CODE> method so that when it receives an Apple event with the command number <CODE>cDrawPointsCommand</CODE>, it creates a <CODE>TDrawPointsCommand</CODE> object and posts it to the MacApp command queue: <P>
<PRE>
void TIconDocument::DoScriptCommand(CommandNumberaCommand,
                           TAppleEvent*message,
                           TAppleEvent*reply)
{
   switch (aCommand)
   {
      // Some cases not shown.
         
      case cDrawPointsCommand:
         {
            TDrawPointsCommand *drawPointsCommand = 
                                 new TDrawPointsCommand;
            drawPointsCommand-&gt;IDrawPointsCommand(this, message);
            drawPointsCommand-&gt;Process();
         }
         break;
      
      default:
         Inherited::DoScriptCommand(aCommand, message, reply);
         break;
   }
}
</PRE>
 As mentioned in a previous section, the IDrawPointsCommand method is responsible for extracting the drawing information from the Draw Points event.<P>
 When the TDrawPointsCommand object is retrieved from the command queue, its <CODE>DoIt</CODE> method sets or erases the specified points. Because the command is undoable, the user can reverse the drawing.<A NAME=MARKER-2-29></A><P>
 Note that the <A NAME=MARKER-2-30></A>DoScriptCommand method calls drawPointsCommand-&gt;Process(), rather than posting the command to the command queue. This ensures proper error handling for the Apple event, should an error occur while processing the command.<P>
<A NAME=HEADING96-134></A>
<H2><A NAME=MARKER-2-31></A>Dragging With the Mouse--A General Outline</H2>
 To drag objects in a view with the mouse (not for a drag-and-drop operation), you follow these general guidelines:<P>
<OL>
<LI>In your view class, do the following:<P>
<UL>
<LI>Add a Boolean variable <CODE>fDragging</CODE> to record whether dragging is currently in effect. Initialize this variable to <CODE>FALSE</CODE> in the <CODE>I<I>YourView</I></CODE> method. (Be careful not to use a variable name that will conflict with any of MacApp's drag-and-drop fields and methods.)
<LI>In the <CODE>DoMouseCommand</CODE> method, create and initialize a dragger command object.<P>
</UL>
<LI>As an alternative first step, in your view class you can<P>
<UL>
<LI>Define a pointer reference <CODE>fTracker</CODE> to a dragger object. Set it to <CODE>NULL</CODE> in your constructor method. If desired, create a dragger object in the <CODE>I<I>YourView</I></CODE> method and make <CODE>fTracker</CODE> point to it.
<LI>At an appropriate time, create a dragger object and make <CODE>fTracker</CODE> point to it (if you didn't already do so in the <CODE>I<I>YourView</I></CODE> method).
<LI>In the <CODE>Draw</CODE> and <CODE>DoHighlightSelection</CODE> methods, check <CODE>fTracker</CODE>. If it isn't <CODE>NULL</CODE>, defer to it for drawing or highlighting.<P>
</UL>
<LI>Define a command constant for a dragging command and add a Buzzwords menu entry to supply text for undoing the dragging command.
<LI>Define a dragger command that is a subclass of <CODE>TTracker</CODE>.
<LI>In your dragger class, add a field or fields to record how far the objects have been dragged.
<LI>Override the <CODE>TrackFeedback</CODE> method in your dragger class to show dragging. This is often done by drawing a frame rectangle that encloses the dragged objects. The <CODE>TrackFeedback</CODE> method examines the previous and current point locations to determine how far to move the rectangle.
<LI>To constrain dragging to a grid, override the <CODE>TrackConstrain</CODE> method to align the dragging rectangle on a grid point.
<LI>Override the <CODE>TrackMouse</CODE> method to handle two cases.<P>
If this is the first move, do the following:<P>
<UL>
<LI>Turn off selection highlighting for individual shapes.
<LI>Set the view's <CODE>fDragging</CODE> field to <CODE>TRUE</CODE>.
<LI>Update the window to force redrawing.
<LI>Focus the view.<P>
If dragging has just finished, do the following:
<LI>Set the field or fields that record how far the objects were dragged.
<LI>Set the view's <CODE>fDragging</CODE> field to <CODE>FALSE</CODE>.<P>
</UL>
<LI>Override the <CODE>DoIt</CODE>, <CODE>UndoIt</CODE>, and <CODE>RedoIt</CODE> methods. Each of these methods uses the field or fields that record how far the objects were dragged. How the objects are actually moved depends on your implementation. A <CODE>DoIt</CODE>, <CODE>UndoIt</CODE>, or <CODE>RedoIt</CODE> method may notify the document or view class that holds the objects of the required movement or it might notify the objects themselves.<A NAME=MARKER-2-32></A><P>
</OL>
<A NAME=HEADING96-158></A>
<H2><A NAME=MARKER-2-33></A><A NAME=MARKER-9-34></A>Recipe--Implementing Autoscrolling</H2>
 <I>Autoscrolling</I> refers to the process by which a view scrolls automatically when a user drags the cursor to a boundary of the view. Autoscrolling may be appropriate, for example, during drawing or dragging in a view. To implement autoscrolling in your application, just associate a scroller with the tracker command object you use to track the mouse.<P>
 When a tracker command object is initialized, one of the parameters specifies the scroller affected by the command. For example, in the Calc sample application, the command class that handles cell selection in the spreadsheet is a subclass of <CODE>TTracker</CODE>. When a <CODE>TCellSelectCommand</CODE> object is initialized, it makes the following call from the <CODE>ICellSelectCommand</CODE> method:<P>
<PRE>
this-&gt;ITracker(cNoCommand, // Command number.
         itsView,          // Its context.
         kCantUndo,        // Can't undo selection.
         kDoesNotCauseChange, // Doesn't cause changes.
         NULL,             // No object to notify.
         itsView,          // Associate it with a view.
         itsView-&gt;GetScroller(kAnySuperView),
                           // Associate with a scroller.
         itsMouse);        // Current mouse position.
</PRE>
 The <CODE>GetScroller</CODE> method retrieves a reference to a scroller object from any view in the view hierarchy. The <CODE>ITracker</CODE> method associates that scroller with the tracker command object. That is all that's required to make autoscrolling work as a user drags to select cells.<P>
<DL>
<DT><B>Note</B>
<DD>The default <CODE>AutoScroll</CODE> method of the <CODE>TScroller</CODE> class calculates a proportional amount to scroll by. You can override that method to control autoscrolling more precisely.<EM></EM><A NAME=MARKER-2-35></A><A NAME=MARKER-2-36></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-95.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-97.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
