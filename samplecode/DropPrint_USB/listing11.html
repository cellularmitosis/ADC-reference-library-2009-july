<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DropPrint USB - /ListInDialog.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">DropPrint USB</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxUSB-date.html" target="_blank">Hardware & Drivers > USB</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DropPrint USB</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/ListInDialog.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/DropShell.c</option>
<option value="listing2.html">/DropShell.h</option>
<option value="listing3.html">/dropshell.r</option>
<option value="listing4.html">/DSAppleEvents.c</option>
<option value="listing5.html">/DSAppleEvents.h</option>
<option value="listing6.html">/DSGlobals.h</option>
<option value="listing7.html">/DSUserProcs.c</option>
<option value="listing8.html">/DSUserProcs.h</option>
<option value="listing9.html">/DSUtils.c</option>
<option value="listing10.html">/DSUtils.h</option>
<option value="listing11.html">/ListInDialog.c</option>
<option value="listing12.html">/ListInDialog.h</option>
<option value="listing13.html">/ListInDialog.r</option>
<option value="listing14.html">/Prefix.h</option>
<option value="listing15.html">/SafeNameRegistry.c</option>
<option value="listing16.html">/SafeNameRegistry.h</option>
<option value="listing17.html">/TestPrinterClass.c</option>
<option value="listing18.html">/TestPrinterClass.h</option></select>
				</p>
				</form>
				<p><strong><a href="DropPrint_USB.zip">Download Sample</a></strong> (&#147;DropPrint_USB.zip&#148;, 72.5K)<BR>
<strong><a href="DropPrint_USB.dmg">Download Sample</a></strong> (&#147;DropPrint_USB.dmg&#148;, 133.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*ListInDialogA snippet that shows how to (uuuhhhhh) put a list in a dialog.I thought we had this one, but I guess not. It's easy, just create the listright after you create the dialog, then call LUpdate and LClick in a dialog filter to respond to user events.Please see the snippet DialogBits for a more comprehensive treatment ofeverything you can do in a dialog (well, almost).This is a 680x0 version, built with the Universal Headers.C.K. HaunApril '94Are you sure we don't already have a snippet like this????Oh, I rememeber, that was on the //gs*/#include &lt;Dialogs.h&gt;#include &lt;Controls.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Windows.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Menus.h&gt;#include &lt;Fonts.h&gt;#include &lt;resources.h&gt;#include &lt;Sound.h&gt;#include &lt;Traps.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Memory.h&gt;#include &lt;Scrap.h&gt;#include &lt;TextEdit.h&gt; #include &lt;Lists.h&gt;#include &lt;Events.h&gt;#include &lt;string.h&gt;#include &quot;TestPrinterClass.h&quot;#include &quot;SafeNameRegistry.h&quot;enum  {    kSampleDialog = 512};enum  {    kModelListItem = 3,    kNameListItem,    kStatTextItem1,    kBlocksizePopupItem,    kRepeatPopupItem,  kAlignPopupItem    };enum {  appleID = 128,  fileID,  editID,  blockID};enum {  mApple = 0,  mFile,  mEdit,  mBlocksize,  MENU_COUNT};#include &quot;ListInDialog.h&quot;ListHandle  gPrinterList, gModelList;          /* making the list handle a global */MenuHandle  menus[MENU_COUNT];Boolean    done;void SetupMenus( void ){  short        i;  MenuHandle      *pMenu;  menus[mApple] = GetMenu(appleID);  AppendResMenu( menus[mApple], (ResType) 'DRVR');  InsertMenu( menus[mApple], 0 );  for (pMenu = &amp;menus[1], i = 1; i &lt; MENU_COUNT; i++ ) {    *pMenu = GetMenu( i + appleID );    InsertMenu(*pMenu++, 0);  }  DrawMenuBar();}ListHandleMakeDialogList( DialogPtr dlg, int item ){  // this &quot;rect&quot; defines the data bounds of the list. In this case, a  // one column list  Rect tempRect;  short tempItem;  Handle tempHandle;  Rect  listRect2  =  {  0, 0, 0, 1 };  Cell  cp      =  {  0, 0  };  // setting it up in the Dialog manager's records,     GetDialogItem( dlg, item, &amp;tempItem, &amp;tempHandle, &amp;tempRect);        /* inset the rect by 16, which is the width of the scroll bar that will be attached */    /* to this list */    tempRect.right -= 16;        /* set the current port to this dialog */    SetPort(dlg);        /* create the list */        return LNew(&amp;tempRect,  // in the tempRect bounds        &amp;listRect2,        // with a sinngle column        cp,            // default cell size (a cell of 0,0 says that)        0,            // no special LDEF, use the standard one        dlg,          // put it in this port        false,          // do NOT draw initially        false,          // does NOT have a grow box space        false,          // does NOT scroll horizontally        true);          // DOES have a verticle scroll bar}/* Here is the filter that handles any List activity */pascal Boolean theListFilter(DialogPtr theDialog, EventRecord *theEvent, short *itemHit){        Rect tempR;    Boolean returnValue = false;  // defaults to me not saying I handled anything    Boolean theBoolean;    WindowPtr oldP;  // get the current port, set the port to this dialog    GetPort(&amp;oldP);    SetPort(theDialog);        // was this an update event for this dialog?    if ((theEvent-&gt;what == updateEvt) &amp;&amp; (theEvent-&gt;message == (UInt32)theDialog)) {                FrameOk( theDialog );        // Update the list.        LUpdate(theDialog-&gt;visRgn, gModelList);    LUpdate(theDialog-&gt;visRgn, gPrinterList);                // get the list rectangle        // push it outwards one pixel and frame the list        tempR = (*gModelList)-&gt;rView;        InsetRect(&amp;tempR, -1, -1);        FrameRect(&amp;tempR);                tempR = (*gPrinterList)-&gt;rView;        InsetRect(&amp;tempR, -1, -1);        FrameRect(&amp;tempR);        // NOTE: Do !NOT! return 'true' if you did SOME drawing in response to a dialog update        // event in your filter!        // ONLY if you did EVERYTHING should you return 'true', or else you can cause other updating        // not to occur, which would be Bad            } else {        // see if this was a mouseDown event        if (theEvent-&gt;what == mouseDown) {            Point theP;      // we set the port to the dialog on entry to the filter, so a GetMouse will work            GetMouse(&amp;theP);                        // get the list rectangle            tempR = (*gModelList)-&gt;rView;                        // add the scroll bar back in for hit testing (remember we took it out earlier)            tempR.right += 16;                        // See if they clicked in our list!            if (PtInRect(theP, &amp;tempR))            {                theBoolean = LClick(theP, 0, gModelList);                // if they double-clicked the list, return 1, as if the OK button had been pressed                if (theBoolean)                    *itemHit = ok;                else                    *itemHit = kModelListItem;                                // tell the Dialog Manager that we handled this click, it can stop searching for a click-owner                returnValue = true;            }      if ( returnValue != true )      {              // get the list rectangle              tempR = (*gPrinterList)-&gt;rView;                            // add the scroll bar back in for hit testing (remember we took it out earlier)              tempR.right += 16;                            // See if they clicked in our list!              if (PtInRect(theP, &amp;tempR))              {                  theBoolean = LClick(theP, 0, gPrinterList);                  // if they double-clicked the list, return 1, as if the OK button had been pressed                  if (theBoolean)                      *itemHit = ok;                  else                      *itemHit = kNameListItem;                                    // tell the Dialog Manager that we handled this click, it can stop searching for a click-owner                  returnValue = true;              }          }          if ( returnValue == true )          {            HiliteOk( theDialog );          }        }    }       // reset the original port        SetPort(oldP);        return(returnValue);}/*  Sys7CDEFPopupPrivateDataHdl theMenuData = (Sys7CDEFPopupPrivateDataHdl) (**(ControlHandle)fHItem).contrlData;  return (**theMenuData).mHandle;*/voidHiliteOk( DialogPtr dlg ){  //  //  enable/disable the okay button if we have an item selected in each list  //  Cell  cp;  Boolean enableOk;  Rect  tempRect;  short  tempItem;  Handle  tempHandle;  cp.h = 0;  cp.v = 0;  enableOk = LGetSelect( true, &amp;cp, gModelList);  if ( enableOk )  {    cp.h = 0;    cp.v = 0;    enableOk = LGetSelect( true, &amp;cp, gPrinterList);  }    GetDialogItem( dlg, ok, &amp;tempItem, &amp;tempHandle, &amp;tempRect);    HiliteControl( (ControlHandle) tempHandle, enableOk? 0: 255 );}voidFrameOk( DialogPtr dlg ){  //  //  outline the default ok button  //  Cell  cp;  Boolean enableOk;  Rect  tempRect;  short  tempItem;  Handle  tempHandle;  RGBColor  gray = { 0x3FFF, 0x3FFF, 0x3FFF },        black = { 0, 0, 0 };  cp.h = 0;  cp.v = 0;  enableOk = LGetSelect( true, &amp;cp, gModelList);  if ( enableOk )  {    cp.h = 0;    cp.v = 0;    enableOk = LGetSelect( true, &amp;cp, gPrinterList);  }    GetDialogItem( dlg, ok, &amp;tempItem, &amp;tempHandle, &amp;tempRect);    if ( !enableOk )      RGBForeColor( &amp;gray );  InsetRect( &amp;tempRect, -3, -3 );  PenSize( 3, 3 );  FrameRoundRect( &amp;tempRect, 16, 16 );    if ( !enableOk )      RGBForeColor( &amp;black );    PenNormal();}voidGetNameFromCell (StringPtr theString, Cell cell, ListHandle hList){  short length;    /*  The maximum length of the string is the size of a Str255, minus the  length byte\xC9  */  length = sizeof(Str255) - 1;  LGetCell((StringPtr)(theString + 1), &amp;length, cell, hList);    /*  Set the length byte.  */  *theString = (unsigned char) length;}intGetDialogPopupValue( DialogPtr dlg, int item ){  Rect  tempRect;  short  tempItem;  Handle  tempHandle;  GetDialogItem( dlg, item, &amp;tempItem, &amp;tempHandle, &amp;tempRect);  return GetControlValue( (ControlHandle) tempHandle);}voidSetDialogPopupValue( DialogPtr dlg, int item, int value ){  Rect  tempRect;  short  tempItem;  Handle  tempHandle;  GetDialogItem( dlg, item, &amp;tempItem, &amp;tempHandle, &amp;tempRect);  SetControlValue( (ControlHandle) tempHandle, value );}intChoosePrinter( char *name, long *blocksize, int *repeats)//ChoosePrinter( char *name, long *blocksize, int *repeats, int *align ){    char    model[255];    short    length;    Cell    cp =  {   0, 0 };     // cell to initialize with    DialogPtr  myDialog = nil; // the dialog we're using    short    hitItem = 0;  // hitItem for ModalDialog call    static ModalFilterUPP modalFilterUPP;        modalFilterUPP = NewModalFilterProc(theListFilter);    /* get our dialog. It is created HIDDEN, and shown after I set the */    /* user item that will hold the list */    myDialog = GetNewDialog(kSampleDialog, nil, (WindowPtr)-1);        // list all the known printer models    gModelList = MakeDialogList( myDialog, kModelListItem );    gPrinterList = MakeDialogList( myDialog, kNameListItem );       SetUpList( gModelList, &quot;&quot;);     // list all the known printer of the first model  SetDialogPopupValue( myDialog, kBlocksizePopupItem, 6 );  //  512 byte default blocksize  SetDialogPopupValue( myDialog, kRepeatPopupItem, 1 );    //  only send file down once      cp.h = 0;    cp.v = 0;    length = sizeof(model);    LGetCell( model, &amp;length, cp, gModelList);    if ( length &gt; 0 )    {      LSetSelect( true, cp, gModelList);    // select the first model    model[ length ] = 0;  // null terminate c-string       SetUpList( gPrinterList, model );      length = sizeof(model);      cp.h = 0;      cp.v = 0;      LGetCell( model, &amp;length, cp, gPrinterList);      if ( length &gt; 0 )      {        LSetSelect( true, cp, gPrinterList);  // select the first printer name       }    }    // turn drawing on after the list has been filled    LSetDrawingMode(true, gModelList);    LSetDrawingMode(true, gPrinterList);    HiliteOk( myDialog );  // enable/disable ok button    // show the dialog    ShowWindow((WindowPtr)myDialog);        /* draw it once */    DrawDialog(myDialog);        // loop until ModalDialog is done    do {        // we have to use a ModalDialog filter, since ModalDialog doesn't        // automatically handle lists        ModalDialog(modalFilterUPP, &amp;hitItem);                // switch off what item was hit        switch (hitItem) {        case kModelListItem:            //          //  rebuild the list of specific printers         //      cp.h = 0;      cp.v = 0;      if ( LGetSelect( true, &amp;cp, gModelList) )      {        length = sizeof(model);          LGetCell( model, &amp;length, cp, gModelList);          model[ length ] = 0;        // create a new list of printer names        LDispose( gPrinterList );           gPrinterList = MakeDialogList( myDialog, kNameListItem );          SetUpList( gPrinterList, model );          cp.h = 0;          cp.v = 0;          LGetCell( model, &amp;length, cp, gPrinterList);          if ( length &gt; 0 )          {            LSetSelect( true, cp, gPrinterList);  // select the first printer name           }          LSetDrawingMode(true, gPrinterList);          LUpdate( myDialog-&gt;visRgn, gPrinterList );        }        break;        default:          break;                    }        // wait for an OK or Cancel    }  while (hitItem != ok &amp;&amp; hitItem != cancel);        if ( hitItem == ok )    {      //      //  save a reference to the requested printer      //    cp.h = 0;    cp.v = 0;    if ( LGetSelect( true, &amp;cp, gModelList) )    {      length = sizeof(model);        LGetCell( model, &amp;length, cp, gPrinterList);        model[ length ] = 0;      strcpy( name, &quot;Devices:device-tree:PRINTER:&quot; );      strcat( name, model );      cp.h = 0;      cp.v = 0;      if ( LGetSelect( true, &amp;cp, gPrinterList) &gt; 0 )      {        length = sizeof(model);          LGetCell( model, &amp;length, cp, gPrinterList);          model[ length ] = 0;        strcat( name, &quot;:&quot; );        strcat( name, model );      }    }    //    //  get the current blocksize    //    *blocksize = 1L&lt;&lt; (GetDialogPopupValue( myDialog, kBlocksizePopupItem ) - 1);    //    //  get the number of times to send the file    //    switch( GetDialogPopupValue( myDialog, kRepeatPopupItem ) )    {    case 2:  *repeats =  2; break;    case 3:  *repeats =  5; break;    case 4:  *repeats = 10; break;    case 5:  *repeats = 20; break;    case 6:  *repeats = 30; break;    case 7:  *repeats = 50; break;    case 8:  *repeats =100; break;    default:    case 1:  *repeats =  1; break;    }     switch( GetDialogPopupValue( myDialog, kAlignPopupItem ) )    {    case 1:      case 2:    case 3:    case 4:    case 5:    case 6:    default:    break;    }   }   // don't do anything in this sample   LDispose( gModelList );   LDispose( gPrinterList  );    DisposeDialog(myDialog);    return hitItem;}/*-----------------------------------------------------------------------------*  SearchForUSBPrinters    Desc:    Searches thru a printer model entry in the name registry        looking for a model's printers. When one is found a call is         issued to the clients callback routine for further processing  In:      - A pstring full path in the name registry of a printer model        - A callback routine which gets called when a printer is found        - A ptr to user data          Out:    None    History:    17 Apr 98  oja    modified to use list manager instead of Chooser  24 Feb 98  gp    Created   *-----------------------------------------------------------------------------*/void  SetUpList( ListHandle theList, char *modelPath ){  RegEntryID    theModelEntry;    // the model node supported by the driver  RegEntryID    aPrinterEntry;    // a printer node in the name registry  RegEntryIterationOp iterOp;      // name registry iterator op code  RegEntryIter  printerIterator;  // used to iterate child nodes of printer model  Boolean      donePrinters  = false;  // NameRegistry param tell when we're done  OSStatus    err       = noErr;  // error from name registry calls  char      path[256];    short       listCount = 0;    Cell      cp;  // name registry only deals with c strings  strcpy( path, &quot;Devices:device-tree:PRINTER&quot; );  if ( modelPath[0] != 0 )  {    strcat( path, &quot;:&quot; );    strcat( path, modelPath );  }    // look up the node for the printer model requested  err = SafeRegistryEntryIDInit(&amp;theModelEntry);  if( err == noErr )     err = SafeRegistryCStrEntryLookup( nil, path, &amp;theModelEntry );  if( err == noErr )   {    // create an iterator to look at the child nodes for our printer model entry    iterOp = kRegIterChildren;    err = SafeRegistryEntryIterateCreate( &amp;printerIterator );    err = SafeRegistryEntryIterateSet(&amp;printerIterator, &amp;theModelEntry);        if( err == noErr )    {      // look for a model's connected printers      do      {        Str255          nodeName;      // the name of the printer        RegPropertyValueSize  nameSize;  // size of name buffer        err = SafeRegistryEntryIterate( &amp;printerIterator, iterOp, &amp;aPrinterEntry, &amp;donePrinters );        // grab name of printer in name registyr        nameSize = sizeof( nodeName );        if( !donePrinters &amp;&amp; err == noErr )          err = SafeRegistryPropertyGet( &amp;aPrinterEntry, &quot;name&quot;, &amp;nodeName, &amp;nameSize );        if( !donePrinters &amp;&amp; err == noErr )        {          // add the printer to the list          listCount = LAddRow(1, listCount + 1, theList);          cp.h = 0;          cp.v = listCount;          LAddToCell(&amp;nodeName, nameSize-1, cp, theList);        }        iterOp = kRegIterContinue;      } while( !donePrinters &amp;&amp; err == noErr );      // end while for printers    }    SafeRegistryEntryIterateDispose(&amp;printerIterator);  }  SafeRegistryEntryIDDispose( &amp;theModelEntry );}// eof</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DropPrint_USB/listing11.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DropPrint_USB/listing11.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DropPrint_USB/listing11.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>