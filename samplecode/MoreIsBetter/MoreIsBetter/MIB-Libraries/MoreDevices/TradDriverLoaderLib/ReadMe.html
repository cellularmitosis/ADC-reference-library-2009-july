<HTML>
<HEAD>
   <TITLE>Read Me</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H1>Read Me About TradDriverLoaderLib</H1>

<P>1.0b7</P>

<P>The TradDriverLoaderLib provides a bunch of routines helpful for
installing traditional Mac OS device drivers (<CODE>'DRVR'</CODE>s).
While there have been many samples of how to do this in the past,
this sample has a number of advantages:</P>

<UL>
   <LI>It works. Some of the other samples out there don't, at least
   not in all possible cases.</LI>
   
   <LI>It mimicks the API of the PCI "DriverLoaderLib" as much as
   possible, which makes the TradDriverLoaderLib easier to use in an
   environment supporting both PCI native drivers
   (<CODE>'ndrv'</CODE>) and traditional Mac OS drivers
   (<CODE>'DRVR'</CODE>). The PCI "DriverLoaderLib" is documented in
   <A HREF="http://developer.apple.com/macos/opentransport/docs/dev/Designing_PCI_Cards_Drivers.pdf">Designing
   PCI Cards and Drivers for Power Macintosh Computers</A>.</LI>
   
   <LI>It has both C and Pascal interfaces.</LI>
   
   <LI>I have revised all DTS sample <CODE>'DRVR'</CODE>s to use this
   library where appropriate.</LI>
   
   <LI>You can build it into both 68K and PPC clients.</LI>
</UL>

<P>TradDriverLoaderLib has been used by many developers (and quite a
few system software projects) in the 4 years since it was first
distributed.</P>

<H2>Packing List</H2>

<P>The distribution contains the following files:</P>

<UL>
   <LI>ReadMe.html -- This document.</LI>
   
   <LI>TradDriverLoaderLib.c -- C source for the library.</LI>
   
   <LI>TradDriverLoaderLib.h -- C interface to the library.</LI>
   
   <LI>TradDriverLoaderLib.p -- Pascal interface to the library.</LI>
   
   <LI>TestTradDriverLoaderLib -- A folder containing Pascal source
   to an application used to test TradDriverLoaderLib. This folder
   also contains a subfolder, TestDriver, which contains the source
   to an extremely simple <CODE>'DRVR'</CODE> that's used by the test
   application.</LI>
</UL>

<P>TradDriverLoaderLib also depends on the following MoreIsBetter
libraries:</P>

<UL>
   <LI>MoreInterfaceLib.h -- A header file that exports versions of
   system routines that are not exported by InterfaceLib.</LI>
   
   <LI>MoreInterfaceLib.c -- C glue that implements certain system
   routines that should be included in InterfaceLib but are not. You
   must add this glue to any PPC client of TradDriverLoaderLib. 68K
   clients should not include this glue.</LI>
</UL>

<H2>Using the Sample</H2>

<H4>Running the Test Program</H4>

<P>The distribution includes a copy of both the 68K and PPC builds of
the test application (TestTradDriverLoader-68K and
TestTradDriverLoader-PPC). To run the test application, just double
click it in the Finder which, amongst other things, installs and
removes 494 copies of the test driver!</P>

<H4>Using the API from C</H4>

<P>Installing and opening a <CODE>'DRVR'</CODE> using
TradDriverLoaderLib is very simple. You need to take the following
steps:</P>

<OL>
   <LI>Add "TradDriverLoaderLib.c" to your project.</LI>
   
   <LI>If you are building a PPC client, add "MoreInterfaceLib.c" to
   your project.</LI>
   
   <LI>Include "TradDriverLoaderLib.h" in your source.</LI>
   
   <LI>When you want to install a driver, execute the following:</LI>
</OL>

<P><TABLE BORDER=0>
   <TR>
      <TD BGCOLOR="#EEEEEE">
         <PRE>err = TradInstallDriverFromResource(0, "\p.MyDriverName",
              48,
              TradHighestUnitNumber() + 1,
              &amp;gDriverRefNum);
if (err == noErr || err == dupFNErr) {
    err = TradOpenInstalledDriver(gDriverRefNum, fsRdWrPerm);
}</PRE>
      </TD>
   </TR>
</TABLE>
</P>

<H4>Using the API from Pascal</H4>

<P>Installing and opening a <CODE>'DRVR'</CODE> using
TradDriverLoaderLib is very simple. You need to take the following
steps:</P>

<OL>
   <LI>Add "TradDriverLoaderLib.c" to your project.</LI>
   
   <LI>If you are building a PPC client, add "MoreInterfaceLib.c" to
   your project.</LI>
   
   <LI>Use "TradDriverLoaderLib.p" in your source.</LI>
   
   <LI>When you want to install a driver, execute the following:</LI>
</OL>

<P><TABLE BORDER=0>
   <TR>
      <TD BGCOLOR="#EEEEEE">
         <PRE>driverName := '.MyDriverName';
err := TradInstallDriverFromResource(0, @driverName,
              48,
              TradHighestUnitNumber + 1,
              gDriverRefNum);
if (err = noErr) or (err = dupFNErr) then begin
    err := TradOpenInstalledDriver(gDriverRefNum, fsRdWrPerm);
end; (* if *)</PRE>
      </TD>
   </TR>
</TABLE>
</P>

<H2>Building the Sample</H2>

<P>The sample was built using the standard MoreIsBetter build
environment (CodeWarrior Pro 2 compiler with Universal Interfaces
3.2). You should be able to build the project in CodeWarrior Pro 4
without difficulty. To build the test application, open the
"TestTradDriverLoader.mcp" project and choose a target (either 68K or
PPC), and choose Make from the Project menu. This will build either
TestTradDriverLoader-68K or TestTradDriverLoader-PPC.</P>

<H2>Advanced Topics</H2>

<H3>API Reference</H3>

<P>All of the routines in the API are described in detail in the
comments in the "TradDriverLoaderLib.h" file. I suggest you look
there for more in-depth information about the services provided by
the library.</P>

<H3>Internal Implementation Details</H3>

<P>The most important routine in TradDriverLoaderLib is
<CODE>TradInstallDriverFromPtr</CODE>. Both
<CODE>TradInstallDriverFromHandle</CODE> and
<CODE>TradInstallDriverFromResource</CODE> call through to this
routine. This routine takes a pointer to an <CODE>'DRVR'</CODE> that
has been loaded in the system heap and creates a Device Control Entry
(DCE) in the system's unit table for that driver. The driver uses an
interesting variant of <CODE>DriverInstall</CODE> (namely
<CODE>DriverInstallReserveMem</CODE>) to ensure that the driver's DCE
is loaded as low in the system heap as possible.</P>

<P>When you call <CODE>TradInstallDriverFromHandle</CODE>, it creates
an appropriately sized pointer block in the system heap and copies
the <CODE>'DRVR'</CODE> you supply into that block. It then calls
<CODE>TradInstallDriverFromPtr</CODE> on that block. This ensures
that the driver code is loaded as low in the system heap as
possible.</P>

<P><CODE>TradInstallDriverFromResource</CODE> simply calls through to
<CODE>TradInstallDriverFromHandle</CODE>.</P>

<P>The source code contains many comments on the specific details of
installing a driver in the unit table.</P>

<H3>Sharing Driver Code Between Multiple Instances</H3>

<P>Because <CODE>TradInstallDriverFromPtr</CODE> takes a pointer to
the driver and just jams it into the <CODE>dCtlDriver</CODE> field of
the DCE without interpretation, you can use this routine to share
code between device drivers. This is useful for things like serial
drivers, which traditionally install two different drivers with
different names. You can create one big chunk of code that has
multiple driver headers in it, and then install that code into two
different DCEs using <CODE>TradInstallDriverFromPtr</CODE>.</P>

<P>Obviously, this is not for the faint of heart (&endash;:</P>

<H3><CODE>dRAMBased</CODE> and <CODE>dNeedLock</CODE></H3>

<P>The <CODE>dctlFlags</CODE> field of the DCE has a bit known as
<CODE>dRAMBased</CODE>. Most people interpret this bit as:</P>

<BLOCKQUOTE>1 ==&gt; device driver is in RAM
   
   <P>0 ==&gt; driver is in ROM</P></BLOCKQUOTE>

<P><STRONG>This interpretation is wrong!</STRONG> The name
<CODE>dRAMBased</CODE> is a historical artifact of the time when the
system had ROM based drivers for hardware and RAM based driver for
desk accessories.</P>

<P>The correct interpretation of this bit is:</P>

<BLOCKQUOTE>1 ==&gt; the <CODE>dCtlDriver</CODE> field of the DCE is
   a handle
   
   <P>0 ==&gt; the <CODE>dCtlDriver</CODE> field of the DCE is a
   pointer</P></BLOCKQUOTE>

<P>So you don't have to set this bit to load your driver into RAM. In
additon, pointer-based driver are also more efficient because the
Device Manager does not have to dereference the handle each time.</P>

<P><CODE>dNeedLock</CODE> controls whether the Device Manager locks
the DCE for your driver. If you set <CODE>dNeedLock</CODE>, the
Device Manager will lock your driver's DCE whenever your driver is
active.</P>

<P><STRONG>Devices that operate at interrupt time (either accepting
asynchronous requests or completing requests) must never have
<CODE>dRAMBased</CODE> set and must always have
<CODE>dNeedLock</CODE> set.</STRONG> Failing to do this will result
in the Device Manager calling Memory Manager routines at interrupt
time, with unpredictable and possibly catastrophic results.</P>

<P>TradDriverLoaderLib implements this recomendation and always loads
drivers into RAM, making sure that <CODE>dRAMBased</CODE> is clear
and <CODE>dNeedLock</CODE> is set.</P>

<H3>Setting <CODE>dNeedLock</CODE></H3>

<P>This sample always sets <CODE>dNeedLock</CODE>. This is necessary
to prevent the Device Manager from locking and unlocking the DCE
while the driver operates. Instead the Device Manager notices that
<CODE>dNeedLock</CODE> is set and locks the DCE once when the driver
is opened. This is good for much the same reasons :</P>

<OL>
   <LI>It saves a few CPU cycles.</LI>
   
   <LI>It avoids the Device Manager calling the Memory Manager
   <CODE>HLock</CODE> and <CODE>HUnlock</CODE> routines at interrupt
   time. <STRONG>Devices that operate at interrupt time (either
   accepting asynchronous requests or completing requests) must
   always have <CODE>dNeedLock</CODE> set.</STRONG></LI>
</OL>

<H2>Caveats</H2>

<P>There are no known caveats at this time.</P>

<H2>Credits and Version History</H2>

<P>Thanks for Fran&ccedil;ois Grieu for his invaluable contribution
to this effort.</P>

<P>If you find any problems with this sample, please mail
&lt;DTS@apple.com&gt; and I'll try to fix them up.</P>

<P>1.0b1 (Jan 1997) was distributed to a couple of developers.</P>

<P>1.0b2 (Feb 1997) is the first official release version.</P>

<P>1.0b3 (Feb 1997) incorporates changes from the original DTS
reviewers. In addition, TradDriverLoaderLib now calls
<CODE>CloseDriver</CODE> instead of <CODE>FSClose</CODE>.</P>

<P>1.0b4 (Mar 1997) incorporates changes and suggestions from
Fran&ccedil;ois Grieu. Tidied up the description of
<CODE>dNeedLock</CODE> and <CODE>dRAMBased</CODE> in the
documentation, and made <CODE>TradGetDriverInformation</CODE> more
paranoid about bogus drivers.</P>

<P>1.0b5 (Jul 1997) can now build PPC native
<CODE>TradDriverLoaderLib</CODE> using snazzy MixedMode glue for
<CODE>DriverInstallReserveMem</CODE> (which is not in InterfaceLib).
Also increased <CODE>kMaximumNumberOfUnitTableEntries</CODE> to 1024
to reflect the new limit used by the PCI DriverLoaderLib included
with Mac OS 8. Cosmetic documentation and code changes.</P>

<P>1.0b6 (Feb 1999) Integrated the library into MoreIsBetter.
<CODE>TradRemoveDriver</CODE> and <CODE>TradRenameDriver</CODE> now
check that the driver is a <CODE>'DRVR'</CODE> (as opposed to an
<CODE>'ndrv'</CODE>) and refuse to remove it otherwise. Recast the
documention in HTML. Minor stylistic changes.</P>

<P>1.0b7 (Dec 2000) Fixed a bug where
<CODE>TradInstallDriverFromHandle</CODE> was failing to test
<CODE>MemError</CODE> in one case. Converted test program to C
because the latest MIB development environment (CWPro6) does not
currently support Pascal.</P>

<P>Share and Enjoy.</P>

<P>Apple Developer Technical Support<BR>
Networking, Communications, Hardware</P>

<P>26 Dec 2000</P>
</BODY>
</HTML>
