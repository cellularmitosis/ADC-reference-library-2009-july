<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shell Scripting Primer: An Extreme Example: The Monte Carlo (Bourne) Method for Pi</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="An Extreme Example: The Monte Carlo (Bourne) Method for Pi"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004268-TP40003515" title="An Extreme Example: The Monte Carlo (Bourne) Method for Pi"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP40003594" target="_top">Open Source</a> &gt; <a href="../../../Scripting-date.html#//apple_ref/doc/uid/TP30000440-TP40003594-TP30000569" target="_top">Scripting &amp; Automation</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004268-TP40003516-SW1">Shell Scripting Primer</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ForMoreInformation/ForMoreInformation.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../revision_history/revision_history.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW4" title="An Extreme Example: The Monte Carlo (Bourne) Method for Pi"></a><h1>An Extreme Example: The Monte Carlo (Bourne) Method for Pi</h1><p>The Monte Carlo method for calculating Pi is a common example program used in computer science curricula. Most CS professors do not force their students to write it using a shell script, however, and doing so poses a number of challenges.</p><p>The Monte Carlo method is fairly straightforward. You take a unit circle and place it inside a 2x2 square and randomly throw darts at it. For any dart that hits within the circle, you add one to the "inside" counter and the "total" counter. For any dart that hits outside the circle, you just add one to the "total" counter. When you divide the number of hits inside the circle by the number of total throws, you get a number that (given an infinite number of sufficiently random throws) will converge towards ∏/4 (one fourth of pi).</p><p>A common simplification of the Monte Carlo method (which is used in this example) is to reduce the square to a single unit in size, and to reduce the unit circle to only a quarter circle. Thus, the circle meets two corners of the square and has its center at the third corner..</p><p>The computer version of this problem, instead of throwing darts, uses a random number generator to generate a random point within a certain set of bounds. In this case, the code uses integers from 0-65,535 for both the x and y coordinates of the point. It then calculates the distance from the point (0,0) to (x,y) using the pythagorean theorem (the hypotenuse of a right triangle with edges of lengths x and y). If this distance is greater than the unit circle (65,535, in this case), the point falls outside the "circle". Otherwise, it falls inside the "circle".</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AnExtremeExample.html#//apple_ref/doc/uid/TP40004268-TP40003515-SW5">Obtaining Random Numbers</a>
				
			<br/>
			
        
			
			
				<a href="AnExtremeExample.html#//apple_ref/doc/uid/TP40004268-TP40003515-SW1">Finding The Ordinal Rank of a Character</a>
				
			<br/>
			
        
			
			
				<a href="AnExtremeExample.html#//apple_ref/doc/uid/TP40004268-TP40003515-SW8">Complete Code Sample</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW5" title="Obtaining Random Numbers"></a><h2>Obtaining Random Numbers</h2><p>To obtain <a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_113"></a>random numbers, this code example uses the <a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_114"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/dd.1.html#//apple_ref/doc/man/1/dd" target="_top">dd</a></code> command to read one byte at a time from <a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_115"></a><code>/dev/random</code>. Then, it must calculate the numeric equivalent of these numbers. That process is described in <span class="content_text"><a href="AnExtremeExample.html#//apple_ref/doc/uid/TP40004268-TP40003515-SW1">“Finding The Ordinal Rank of a Character.”</a></span></p><p>The following example shows how to read a byte using <code>dd</code>:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Read four random bytes.<span></span></pre></td></tr><tr><td scope="row"><pre>RAWVAL1="$(dd if=/dev/random bs=1 count=1 2> /dev/null)"<span></span></pre></td></tr><tr><td scope="row"><pre>RAWVAL2="$(dd if=/dev/random bs=1 count=1 2> /dev/null)"<span></span></pre></td></tr><tr><td scope="row"><pre>RAWVAL3="$(dd if=/dev/random bs=1 count=1 2> /dev/null)"<span></span></pre></td></tr><tr><td scope="row"><pre>RAWVAL4="$(dd if=/dev/random bs=1 count=1 2> /dev/null)"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Calculate the ordinality of the bytes.<span></span></pre></td></tr><tr><td scope="row"><pre>XVAL0=$(ord "$RAWVAL1") # more on this function later<span></span></pre></td></tr><tr><td scope="row"><pre>XVAL1=$(ord "$RAWVAL2") # more on this function later<span></span></pre></td></tr><tr><td scope="row"><pre>YVAL0=$(ord "$RAWVAL3") # more on this function later<span></span></pre></td></tr><tr><td scope="row"><pre>YVAL1=$(ord "$RAWVAL4") # more on this function later<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># We basically want to get an unsigned 16-bit number out of<span></span></pre></td></tr><tr><td scope="row"><pre># two raw bytes.  Earlier, we got the ord() of each byte.<span></span></pre></td></tr><tr><td scope="row"><pre># Now, we figure out what that unsigned value would be by<span></span></pre></td></tr><tr><td scope="row"><pre># multiplying the high order byte by 256 and adding the<span></span></pre></td></tr><tr><td scope="row"><pre># low order byte.  We don't really care which byte is which,<span></span></pre></td></tr><tr><td scope="row"><pre># since they're just random numbers.<span></span></pre></td></tr><tr><td scope="row"><pre>XVAL=$(( ($XVAL0 * 256) + $XVAL1 ))   # use expr for older shells.<span></span></pre></td></tr><tr><td scope="row"><pre>YVAL=$(( ($YVAL0 * 256) + $YVAL1 ))   # use expr for older shells.<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW1" title="Finding The Ordinal Rank of a Character"></a><h2>Finding The Ordinal Rank of a Character</h2><p><a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_116"></a>There are many ways to calculate the ordinal rank of a character. This example presents three of those: inline Perl, inline AWK, and a more purist (read "slow") version using only <code>sed</code> and <code>tr</code>.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW6" title="Finding Ordinal Rank Using Perl"></a><h3>Finding Ordinal Rank Using Perl</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_117"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_118"></a>The easiest way to find the ordinal rank of a character in a shell script is by using inline Perl code. In the following example, the raw character is echoed to the <code>perl</code> interpreter's standard input. (See the <code><a href="../../../../Darwin/Reference/ManPages/man1/perl.1.html#//apple_ref/doc/man/1/perl" target="_top">perl</a></code> manual page for more information about Perl.)</p><p>The short Perl script sets the record separator to undefined, then reads data until EOF, finally printing the ordinal value of the character that it retrieves using the <code>ord</code> function..</p>
<div class="codesample"><table><tr><td scope="row"><pre>YVAL1=$(echo $RAWVAL4 | perl -e '$/ = undef; my $val = &lt;STDIN>; print ord($val);')<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_119"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW2" title="Finding Ordinal Rank Using AWK"></a><h3>Finding Ordinal Rank Using AWK</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_120"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_121"></a>The second method for obtaining the ordinal rank of a character is slightly more complicated, but still relatively fast. Performance is only slightly slower than the Perl example.</p>
<div class="codesample"><table><tr><td scope="row"><pre>            YVAL0=$(echo $RAWVAL3 | awk '{<span></span></pre></td></tr><tr><td scope="row"><pre>                RS="\n"; ch=$0;<span></span></pre></td></tr><tr><td scope="row"><pre>                # print "CH IS ";<span></span></pre></td></tr><tr><td scope="row"><pre>                # print ch;<span></span></pre></td></tr><tr><td scope="row"><pre>                if (!length(ch)) { # must be the record separator.<span></span></pre></td></tr><tr><td scope="row"><pre>                        ch="\n"<span></span></pre></td></tr><tr><td scope="row"><pre>                };<span></span></pre></td></tr><tr><td scope="row"><pre>                s="";<span></span></pre></td></tr><tr><td scope="row"><pre>                for (i=1; i&lt;256; i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>                        l=sprintf("%c", i);<span></span></pre></td></tr><tr><td scope="row"><pre>                        ns = (s l); s = ns;<span></span></pre></td></tr><tr><td scope="row"><pre>                };<span></span></pre></td></tr><tr><td scope="row"><pre>                pos = index(s, ch); printf("%d", pos)<span></span></pre></td></tr><tr><td scope="row"><pre>            }')<span></span></pre></td></tr></table></div><p>In this example, the raw character is echoed to an AWK script. (See the <code><a href="../../../../Darwin/Reference/ManPages/man1/awk.1.html#//apple_ref/doc/man/1/awk" target="_top">awk</a></code> manual page and <span class="content_text"><a href="../Howawk-ward/Howawk-ward.html#//apple_ref/doc/uid/TP40004268-TP40003518-SW10">“How AWK-ward”</a></span> for more information about AWK.) That script iterates through the numbers 1-255, concatenating the character (<code>l</code>) whose ASCII value is that number (<code>i</code>) onto a string (<code>ns</code>). It then asks for the location of that character in the string. If no value is found, index will return zero (0), which is convenient, as <code>NULL</code> (character 0) is excluded from the string.</p><p>The surprising thing is that this code, while seemingly far more complicated than the Perl equivalent, performs almost as well (less than half a second slower per 100 iterations).<a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_122"></a></p><a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW7" title="Finding Ordinal Rank Using tr And sed"></a><h3>Finding Ordinal Rank Using tr And sed</h3><p>This example was written less out of a desire to actually use such a method and more out of a desire to prove that such code is possible. It is, by far, the most roundabout way to calculate the ordinal rank of a character that you are likely to ever encounter. It behaves much like the <code><a href="../../../../Darwin/Reference/ManPages/man1/awk.1.html#//apple_ref/doc/man/1/awk" target="_top">awk</a></code> program described in <span class="content_text"><a href="AnExtremeExample.html#//apple_ref/doc/uid/TP40004268-TP40003515-SW2">“Finding Ordinal Rank Using AWK,”</a></span> but without using any other programming languages other than Bourne shell scripts.</p><p>The first part of this example is a small code snippet to convert an integer into its octal equivalent. This will be important later.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW3" title="Listing B-1An Integer to Octal Conversion Function"></a><p class="codesample"><strong>Listing B-1&nbsp;&nbsp;</strong>An Integer to Octal Conversion Function</p><div class="codesample"><table><tr><td scope="row"><pre># Convert an int to an octal value.<span></span></pre></td></tr><tr><td scope="row"><pre>inttooct()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        echo $(echo "obase=8; $1" | bc)<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This code is relatively straightforward. It tells the basic calculator, <a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_123"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/bc.1.html#//apple_ref/doc/man/1/bc" target="_top">bc</a></code>, to print the specified number, converting the output to base 8 (octal).</p><p>The next part of this example is the code to initialize a string containing a list of all of the possible ASCII characters except <code>NULL</code> (character 0) in order. This function is called only once at program initialization; the shell version of this code is very slow as it is, and calling this function each time you try to find the ordinal rank of a character would make this code completely unusable.</p>
<div class="codesample"><table><tr><td scope="row"><pre># Initializer for the scary shell ord function.<span></span></pre></td></tr><tr><td scope="row"><pre>ord_init()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    I=1<span></span></pre></td></tr><tr><td scope="row"><pre>    ORDSTRING=""<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ $I -lt 256 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>        # local HEX=$(inttohex $I);<span></span></pre></td></tr><tr><td scope="row"><pre>        local OCT=$(inttooct $I);<span></span></pre></td></tr><tr><td scope="row"><pre>        # The following should work with GNU sed, but<span></span></pre></td></tr><tr><td scope="row"><pre>        # Mac OS X's sed doesn't support \x.<span></span></pre></td></tr><tr><td scope="row"><pre>        # local CH=$(echo ' ' | sed "s/ /\\x$HEX/")<span></span></pre></td></tr><tr><td scope="row"><pre>        # How about this?<span></span></pre></td></tr><tr><td scope="row"><pre>        # local CH=$(perl -e  "\$/=undef; \$x = ' '; \$x =~ s/ /\x$HEX/g; print \$x;")<span></span></pre></td></tr><tr><td scope="row"><pre>        # Yes, that works, but it's cheating.  Here's a better one.<span></span></pre></td></tr><tr><td scope="row"><pre>        local CH=$(echo ' ' | tr ' ' "\\$OCT");<span></span></pre></td></tr><tr><td scope="row"><pre>        ORDSTRING=$ORDSTRING$CH<span></span></pre></td></tr><tr><td scope="row"><pre>        I=$(($I + 1)) # or I=$(expr $I '+' 1)<span></span></pre></td></tr><tr><td scope="row"><pre>        # echo "ORDSTRING: $ORDSTRING"<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>This version shows three possible ways to generate a raw character from the numeric equivalent. The first way works in Perl and works with GNU <code>sed</code>, but does not work with the <code><a href="../../../../Darwin/Reference/ManPages/man1/sed.1.html#//apple_ref/doc/man/1/sed" target="_top">sed</a></code> implementation in Mac OS X. The second way uses the <code><a href="../../../../Darwin/Reference/ManPages/man1/perl.1.html#//apple_ref/doc/man/1/perl" target="_top">perl</a></code> interpreter. While this way works, the intent was to avoid using other scripting languages if possible.</p><p>The third way is an interesting trick. A string containing a single space is passed to <a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_124"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/tr.1.html#//apple_ref/doc/man/1/tr" target="_top">tr</a></code>. The <code>tr</code> command, in its normal use, substitutes all instances of a particular character with another one. It also recognizes character codes in the form of a backslash followed by three octal digits. Thus, in this case, its arguments tell it to replace every instance of a space in the input (which consists of a single space) with the character equivalent of the octal number <code>$OCT</code>. This octal number, in turn, was calculated from the loop index (<code>I</code>) using the octal conversion function shown in <span class="content_text"><a href="AnExtremeExample.html#//apple_ref/doc/uid/TP40004268-TP40003515-SW3">Listing B-1</a></span>.</p><p>When this function returns, the global variable <code>$ORDSTRING</code> contains every ASCII character beginning with character 1 and ending with character 255.</p><p>The final piece of this code is a subroutine to locate a character within a string and to return its index. Again, this can be done easily with inline Perl code, but the goal of this code is to do it without using any other programming language.</p><div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_17" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_125"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_126"></a>Beginning in Mac OS X v10.5, the <code>sed</code> command requires that its input strings contain only valid character sequences in the character set specified by your locale settings. The default character set is UTF-8.</p><p>The raw streams of bytes used in this function are not guaranteed to be a valid UTF-8 text sequence. As a result, with the default locale settings, this function produces errors whenever it encounters most characters with values greater than 127 (high ASCII characters).</p><p>To disable these <code>sed</code> constraints, your script <em>must</em> override the standard locale. To do this, add the following line near the top of the script:</p><p><div class="codesample"><table><tr><td scope="row"><pre>export LANG="C"<span></span></pre></td></tr></table></div>This sets the locale to “C”, a locale in which no multibyte character sequences exist and each character is treated as a raw byte for comparison purposes (sorting is in raw numeric order, and so on).</p><p>See the <a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_127"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/locale.1.html#//apple_ref/doc/man/1/locale" target="_top">locale</a></code> manual page for more information about locales.</p><p></p><div class="clear"></div></div>
<div class="codesample"><table><tr><td scope="row"><pre>ord()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    local CH="$1"<span></span></pre></td></tr><tr><td scope="row"><pre>    local STRING=""<span></span></pre></td></tr><tr><td scope="row"><pre>    local OCCOPY=$ORDSTRING<span></span></pre></td></tr><tr><td scope="row"><pre>    local COUNT=0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Some shells can't handle NULL characters,<span></span></pre></td></tr><tr><td scope="row"><pre>    # so this code gets an empty argument.<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "x$CH" = "x" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>        echo 0<span></span></pre></td></tr><tr><td scope="row"><pre>        return<span></span></pre></td></tr><tr><td scope="row"><pre>    fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Delete the first character from a copy of ORDSTRING if that<span></span></pre></td></tr><tr><td scope="row"><pre>    # character doesn't match the one we're looking for.  Loop<span></span></pre></td></tr><tr><td scope="row"><pre>    # until we don't have any more leading characters to delete.<span></span></pre></td></tr><tr><td scope="row"><pre>    # The count will be the ASCII character code for the letter.<span></span></pre></td></tr><tr><td scope="row"><pre>    CONT=1;<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ $CONT = 1 ]; do<span></span></pre></td></tr><tr><td scope="row"><pre>        # Copy the string so we know if we've stopped finding<span></span></pre></td></tr><tr><td scope="row"><pre>        # nonmatching characters.<span></span></pre></td></tr><tr><td scope="row"><pre>        OCTEMP="$OCCOPY"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # echo "CH WAS $CH"<span></span></pre></td></tr><tr><td scope="row"><pre>        # echo "ORDSTRING: $ORDSTRING"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # Delete a character if possible.<span></span></pre></td></tr><tr><td scope="row"><pre>        OCCOPY=$(echo "$OCCOPY" | sed "s/^[^$CH]//");<a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_128"></a><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # On error, we're done.<span></span></pre></td></tr><tr><td scope="row"><pre>        if [ $? != 0 ] ; then CONT=0 ; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # If the string didn't change, we're done.<span></span></pre></td></tr><tr><td scope="row"><pre>        if [ "x$OCTEMP" = "x$OCCOPY" ] ; then CONT=0 ; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # Increment the counter so we know where we are.<span></span></pre></td></tr><tr><td scope="row"><pre>        COUNT=$((COUNT + 1)) # or COUNT=$(expr $COUNT '+' 1)<span></span></pre></td></tr><tr><td scope="row"><pre>        # echo "COUNT: $COUNT"<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    COUNT=$(($COUNT + 1)) # or COUNT=$(expr $COUNT '+' 1)<span></span></pre></td></tr><tr><td scope="row"><pre>    # If we ran out of characters, it's a null (character 0).<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "x$OCTEMP" = "x" ] ; then COUNT=0; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "ORD IS $COUNT";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Return the ord of the character in question....<span></span></pre></td></tr><tr><td scope="row"><pre>    echo $COUNT<span></span></pre></td></tr><tr><td scope="row"><pre>    # exit 0<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Basically, this code repeatedly deletes the first character from a copy of the string generated by the  <code>ord_init</code> function unless that character matches the pattern. As soon as it fails to delete a character, the number of characters deleted (before finding the matching character) is equal to one less than the ASCII value of the input character. If the code runs out of characters, the input character must have been the one character omitted from the ASCII lookup string: <code>NULL</code> (character 0).<a name="//apple_ref/doc/uid/TP40004268-TP40003515-DontLinkElementID_129"></a></p><a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW8" title="Complete Code Sample"></a><h2>Complete Code Sample</h2><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003515-SW9" title="Note"></a><p><strong>Note:</strong>&nbsp;This complete code listing is also available in the companion files zip archive, which may be found in the table of contents when viewing this chapter in HTML form on the ADC Reference Library website.</p></div>
<div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ITERATIONS=1000<span></span></pre></td></tr><tr><td scope="row"><pre>SCALE=6<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Prevent sed from caring about high ASCII characters not<span></span></pre></td></tr><tr><td scope="row"><pre># being valid UTF-8 sequences<span></span></pre></td></tr><tr><td scope="row"><pre>export LANG="C"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Set FAST to "slow", "medium", or "fast".  This controls<span></span></pre></td></tr><tr><td scope="row"><pre># which ord() function to use.<span></span></pre></td></tr><tr><td scope="row"><pre>#<span></span></pre></td></tr><tr><td scope="row"><pre># slow-use a combination of Perl, AWK, and shell methods<span></span></pre></td></tr><tr><td scope="row"><pre># medium-use only Perl and AWK methods.<span></span></pre></td></tr><tr><td scope="row"><pre># fast-use only Perl<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># FAST="slow"<span></span></pre></td></tr><tr><td scope="row"><pre># FAST="medium"<span></span></pre></td></tr><tr><td scope="row"><pre>FAST="fast"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># 100 iterations - FAST<span></span></pre></td></tr><tr><td scope="row"><pre># real    0m9.850s<span></span></pre></td></tr><tr><td scope="row"><pre># user    0m2.162s<span></span></pre></td></tr><tr><td scope="row"><pre># sys     0m8.388s<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># 100 iterations - MEDIUM<span></span></pre></td></tr><tr><td scope="row"><pre># real    0m10.362s<span></span></pre></td></tr><tr><td scope="row"><pre># user    0m2.375s<span></span></pre></td></tr><tr><td scope="row"><pre># sys     0m8.726s<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># 100 iterations - SLOW<span></span></pre></td></tr><tr><td scope="row"><pre># real    2m25.556s<span></span></pre></td></tr><tr><td scope="row"><pre># user    0m32.545s<span></span></pre></td></tr><tr><td scope="row"><pre># sys     2m12.802s<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Calculate the distance from point 0,0 to point X,Y.<span></span></pre></td></tr><tr><td scope="row"><pre># In other words, calculate the hypotenuse of a right<span></span></pre></td></tr><tr><td scope="row"><pre># triangle whose legs are of length X and Y.<span></span></pre></td></tr><tr><td scope="row"><pre>distance()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    local X=$1<span></span></pre></td></tr><tr><td scope="row"><pre>    local Y=$2<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    DISTANCE=$(echo "sqrt(($X ^ 2) + ($Y ^ 2))" | bc)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    echo $DISTANCE<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Convert an int to a hex value.  (Not used.)<span></span></pre></td></tr><tr><td scope="row"><pre>inttohex()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    echo $(echo "obase=16; $1" | bc)<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Convert an int to an octal value.<span></span></pre></td></tr><tr><td scope="row"><pre>inttooct()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    echo $(echo "obase=8; $1" | bc)<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Initializer for the scary shell ord function.<span></span></pre></td></tr><tr><td scope="row"><pre>ord_init()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    I=1<span></span></pre></td></tr><tr><td scope="row"><pre>    ORDSTRING=""<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ $I -lt 256 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>    # local HEX=$(inttohex $I);<span></span></pre></td></tr><tr><td scope="row"><pre>    local OCT=$(inttooct $I);<span></span></pre></td></tr><tr><td scope="row"><pre>    # The following should work with GNU sed, but<span></span></pre></td></tr><tr><td scope="row"><pre>    # Mac OS X's sed doesn't support \x.<span></span></pre></td></tr><tr><td scope="row"><pre>    # local CH=$(echo ' ' | sed "s/ /\\x$HEX/")<span></span></pre></td></tr><tr><td scope="row"><pre>    # How about this?<span></span></pre></td></tr><tr><td scope="row"><pre>    # local CH=$(perl -e  "\$/=undef; \$x = ' '; \$x =~ s/ /\x$HEX/g; print \$x;")<span></span></pre></td></tr><tr><td scope="row"><pre>    # Yes, that works, but it's cheating.  Here's a better one.<span></span></pre></td></tr><tr><td scope="row"><pre>    local CH=$(echo ' ' | tr ' ' "\\$OCT");<span></span></pre></td></tr><tr><td scope="row"><pre>    ORDSTRING=$ORDSTRING$CH<span></span></pre></td></tr><tr><td scope="row"><pre>    I=$(($I + 1)) # or I=$(expr $I '+' 1)<span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "ORDSTRING: $ORDSTRING"<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># This is a scary little lovely piece of shell script.<span></span></pre></td></tr><tr><td scope="row"><pre># It finds the ord of a character using only the shell,<span></span></pre></td></tr><tr><td scope="row"><pre># tr, and sed.  The variable ORDSTRING must be initialized<span></span></pre></td></tr><tr><td scope="row"><pre># prior to first use with a call to ord_init.  This string<span></span></pre></td></tr><tr><td scope="row"><pre># is not modified.<span></span></pre></td></tr><tr><td scope="row"><pre>ord()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    local CH="$1"<span></span></pre></td></tr><tr><td scope="row"><pre>    local STRING=""<span></span></pre></td></tr><tr><td scope="row"><pre>    local OCCOPY=$ORDSTRING<span></span></pre></td></tr><tr><td scope="row"><pre>    local COUNT=0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Some shells can't handle NULL characters,<span></span></pre></td></tr><tr><td scope="row"><pre>    # so this code gets an empty argument.<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "x$CH" = "x" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>        echo 0<span></span></pre></td></tr><tr><td scope="row"><pre>        return<span></span></pre></td></tr><tr><td scope="row"><pre>    fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Delete the first character from a copy of ORDSTRING if that<span></span></pre></td></tr><tr><td scope="row"><pre>    # character doesn't match the one we're looking for.  Loop<span></span></pre></td></tr><tr><td scope="row"><pre>    # until we don't have any more leading characters to delete.<span></span></pre></td></tr><tr><td scope="row"><pre>    # The count will be the ASCII character code for the letter.<span></span></pre></td></tr><tr><td scope="row"><pre>    CONT=1;<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ $CONT = 1 ]; do<span></span></pre></td></tr><tr><td scope="row"><pre>    # Copy the string so we know if we've stopped finding<span></span></pre></td></tr><tr><td scope="row"><pre>    # nonmatching characters.<span></span></pre></td></tr><tr><td scope="row"><pre>    OCTEMP="$OCCOPY"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "CH WAS $CH"<span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "ORDSTRING: $ORDSTRING"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Delete a character if possible.<span></span></pre></td></tr><tr><td scope="row"><pre>    OCCOPY=$(echo "$OCCOPY" | sed "s/^[^$CH]//");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # On error, we're done.<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ $? != 0 ] ; then CONT=0 ; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # If the string didn't change, we're done.<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "x$OCTEMP" = "x$OCCOPY" ] ; then CONT=0 ; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Increment the counter so we know where we are.<span></span></pre></td></tr><tr><td scope="row"><pre>    COUNT=$((COUNT + 1)) # or COUNT=$(expr $COUNT '+' 1)<span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "COUNT: $COUNT"<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    COUNT=$(($COUNT + 1)) # or COUNT=$(expr $COUNT '+' 1)<span></span></pre></td></tr><tr><td scope="row"><pre>    # If we ran out of characters, it's a null (character 0).<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "x$OCTEMP" = "x" ] ; then COUNT=0; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "ORD IS $COUNT";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Return the ord of the character in question....<span></span></pre></td></tr><tr><td scope="row"><pre>    echo $COUNT<span></span></pre></td></tr><tr><td scope="row"><pre>    # exit 0<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># If we're using the shell ord function, we need to<span></span></pre></td></tr><tr><td scope="row"><pre># initialize it on launch.  We also do a quick sanity<span></span></pre></td></tr><tr><td scope="row"><pre># check just to make sure it is working.<span></span></pre></td></tr><tr><td scope="row"><pre>if [ "x$FAST" = "xslow" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Initializing Bourne ord function."<span></span></pre></td></tr><tr><td scope="row"><pre>    ord_init<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Test our ord function<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Testing ord function"<span></span></pre></td></tr><tr><td scope="row"><pre>    ORDOFA=$(ord "a")<span></span></pre></td></tr><tr><td scope="row"><pre>    # That better be 97.<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "$ORDOFA" != "97" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "Shell ord function broken.  Try fast mode."<span></span></pre></td></tr><tr><td scope="row"><pre>    fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    echo "ord_init done"<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>COUNT=0<span></span></pre></td></tr><tr><td scope="row"><pre>IN=0<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># For the Monte Carlo method, we check to see if a random point between<span></span></pre></td></tr><tr><td scope="row"><pre># 0,0 and 1,1 lies within a unit circle distance from 0,0.  This allows<span></span></pre></td></tr><tr><td scope="row"><pre># us to approximate pi.<span></span></pre></td></tr><tr><td scope="row"><pre>while [ $COUNT -lt $ITERATIONS ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>    # Read four random bytes.<span></span></pre></td></tr><tr><td scope="row"><pre>    RAWVAL1="$(dd if=/dev/random bs=1 count=1 2> /dev/null)"<span></span></pre></td></tr><tr><td scope="row"><pre>    RAWVAL2="$(dd if=/dev/random bs=1 count=1 2> /dev/null)"<span></span></pre></td></tr><tr><td scope="row"><pre>    RAWVAL3="$(dd if=/dev/random bs=1 count=1 2> /dev/null)"<span></span></pre></td></tr><tr><td scope="row"><pre>    RAWVAL4="$(dd if=/dev/random bs=1 count=1 2> /dev/null)"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # ord "$RAWVAL4";<span></span></pre></td></tr><tr><td scope="row"><pre>    # exit 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # The easy method for doing an ord() of a character: use Perl.<span></span></pre></td></tr><tr><td scope="row"><pre>    XVAL0=$(echo $RAWVAL1 | perl -e '$/ = undef; my $val = &lt;STDIN>; print ord($val);')<span></span></pre></td></tr><tr><td scope="row"><pre>    XVAL1=$(echo $RAWVAL2 | perl -e '$/ = undef; my $val = &lt;STDIN>; print ord($val);')<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # The not-so-easy way using AWK (but still almost as fast as Perl)<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "x$FAST" != "xfast" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>        # Run this for FAST = medium or slow.<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "AWK ord"<span></span></pre></td></tr><tr><td scope="row"><pre>        # Fun little AWK program for calculating ord of a letter.<span></span></pre></td></tr><tr><td scope="row"><pre>        YVAL0=$(echo $RAWVAL3 | awk '{<span></span></pre></td></tr><tr><td scope="row"><pre>        RS="\n"; ch=$0;<span></span></pre></td></tr><tr><td scope="row"><pre>        # print "CH IS ";<span></span></pre></td></tr><tr><td scope="row"><pre>        # print ch;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!length(ch)) { # must be the record separator.<span></span></pre></td></tr><tr><td scope="row"><pre>            ch="\n"<span></span></pre></td></tr><tr><td scope="row"><pre>        };<span></span></pre></td></tr><tr><td scope="row"><pre>        s="";<span></span></pre></td></tr><tr><td scope="row"><pre>        for (i=1; i&lt;256; i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>            l=sprintf("%c", i);<span></span></pre></td></tr><tr><td scope="row"><pre>            ns = (s l); s = ns;<span></span></pre></td></tr><tr><td scope="row"><pre>        };<span></span></pre></td></tr><tr><td scope="row"><pre>        pos = index(s, ch); printf("%d", pos)<span></span></pre></td></tr><tr><td scope="row"><pre>        }')<span></span></pre></td></tr><tr><td scope="row"><pre>        # Fun little shell script for calculating ord of a letter.<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        YVAL0=$(echo $RAWVAL3 | perl -e '$/ = undef; my $val = &lt;STDIN>; print ord($val);')<span></span></pre></td></tr><tr><td scope="row"><pre>    fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # The evil way---slightly faster than looking it up by hand....<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "x$FAST" = "xslow" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>        # Run this ONLY for FAST = slow.  This is REALLY slow!<span></span></pre></td></tr><tr><td scope="row"><pre>        YVAL1=$(ord "$RAWVAL4")<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        YVAL1=$(echo $RAWVAL4 | perl -e '$/ = undef; my $val = &lt;STDIN>; print ord($val);')<span></span></pre></td></tr><tr><td scope="row"><pre>    fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "YV3: $VAL3"<span></span></pre></td></tr><tr><td scope="row"><pre>    # YVAL1="0"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # We basically want to get an unsigned 16-bit number out of<span></span></pre></td></tr><tr><td scope="row"><pre>    # two raw bytes.  Earlier, we got the ord() of each byte.<span></span></pre></td></tr><tr><td scope="row"><pre>    # Now, we figure out what that unsigned value would be by<span></span></pre></td></tr><tr><td scope="row"><pre>    # multiplying the high order byte by 256 and adding the<span></span></pre></td></tr><tr><td scope="row"><pre>    # low order byte.  We don't really care which byte is which,<span></span></pre></td></tr><tr><td scope="row"><pre>    # since they're just random numbers.<span></span></pre></td></tr><tr><td scope="row"><pre>    XVAL=$(( ($XVAL0 * 256) + $XVAL1 ))   # use expr for older shells.<span></span></pre></td></tr><tr><td scope="row"><pre>    YVAL=$(( ($YVAL0 * 256) + $YVAL1 ))   # use expr for older shells.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # This doesn't work well, since we can't seed AWK's PRNG<span></span></pre></td></tr><tr><td scope="row"><pre>    # in any useful way.<span></span></pre></td></tr><tr><td scope="row"><pre>    # YVAL=$(awk '{printf("%d", rand() * 65535)}')<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Calculate the difference.<span></span></pre></td></tr><tr><td scope="row"><pre>    DISTANCE=$(distance $XVAL $YVAL)<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "X: $XVAL, Y: $YVAL, DISTANCE: $DISTANCE"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if [ $DISTANCE -le 65535 ] ; then # use expr for older shells<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "In circle.";<span></span></pre></td></tr><tr><td scope="row"><pre>        IN=$(($IN + 1))<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "Outside circle.";<span></span></pre></td></tr><tr><td scope="row"><pre>    fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    COUNT=$(($COUNT + 1))                # use expr for older shells.<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Calculate PI.<span></span></pre></td></tr><tr><td scope="row"><pre>PI=$(echo "scale=$SCALE; ($IN / $ITERATIONS) * 4" | bc)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Print the results.<span></span></pre></td></tr><tr><td scope="row"><pre>echo "IN: $IN, ITERATIONS: $ITERATIONS"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "PI is about $PI"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div>	

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ForMoreInformation/ForMoreInformation.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../revision_history/revision_history.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-04-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/OpenSource/Conceptual/ShellScripting/AnExtremeExample/AnExtremeExample.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/OpenSource/Conceptual/ShellScripting/AnExtremeExample/AnExtremeExample.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/OpenSource/Conceptual/ShellScripting/AnExtremeExample/AnExtremeExample.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>