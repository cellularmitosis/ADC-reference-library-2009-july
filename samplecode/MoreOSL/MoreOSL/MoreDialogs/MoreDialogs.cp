/*	File:		MoreDialogs.cp	Contains:		Written by:	Pete Gontier	Copyright:	Copyright (c) 1998 Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):         <6>     20/3/00    Quinn   Make SetDialogItemString work regardless of whether the dialog                                    is using embedding or not.         <5>      1/3/00    Quinn   SystemClick is no longer part of, or necessary in, Carbon.         <4>     1/22/99    PCG     TARGET_CARBON         <3>      1/7/99    PCG     add ToggleDialogCheckBox and MoreAppendDialogItemList         <2>    11/11/98    PCG     fix header         <1>    11/10/98    PCG     first big re-org at behest of Quinn	Old Change History (most recent first):         <2>     7/24/98    PCG	    eliminate dependency on 'qd'         <1>     6/16/98    PCG     initial checkin*/#include <ControlDefinitions.h>#include "MoreToolbox.h"#include "MoreAppearance.h"#include "MoreDialogs.h"#include <Sound.h>pascal void SaferShortenDITL (DialogPtr dialog, DialogItemIndex index){	while (index--) ShortenDITL (dialog, 1);}pascal DialogPtr MoreGetNewDialog (short dlogResID){	return GetNewDialog (dlogResID, nil, kFirstWindowOfClass);}pascal void SetDialogItemString (DialogPtr dialog, DialogItemIndex index, ConstStringPtr str){	OSStatus   junk;	SInt16     iType; 	Rect 	   iRect; 	Handle     iHandle;	ControlRef control;	if (MoreAssert (dialog && index)) {		if (str == nil) {			str = "\p";		}				// If the dialog item is using a control rather than the pre-Appearance		// sharing of a TEHandle, we must set the text using SetControlData.		// If you donÕt do this, it mostly works, but weird things happen with		// the text highlighting in edit text items.				if (HaveAppearance() && (GetDialogItemAsControl(dialog, index, &control) == noErr) && (control != nil)) {						junk = SetControlData(control, kControlEditTextPart,								kControlEditTextTextTag,								str[0], (void *) &str[1]);			MoreAssertQ(junk == noErr);		} else {			GetDialogItem(dialog, index, &iType, &iHandle, &iRect);			SetDialogItemText(iHandle, str);		}	}}pascal void GetDialogItemString (DialogPtr dialog, DialogItemIndex index, Str255 str){	if (MoreAssert (dialog && index && str))	{		short iType; Rect iRect; Handle iHandle;		GetDialogItem (dialog,index,&iType,&iHandle,&iRect);		GetDialogItemText (iHandle, str);	}}pascal void SelectAllDialogItemText (DialogPtr dialog, DialogItemIndex index){	SelectDialogItemText (dialog,index,0,32767);}pascal void MoveableModalDialog (ModalFilterUPP mfp, short *itemHit){	//	//	I just made this logic up.	//	In a perfect world, I would steal the implementation	//	of the real ModalDialog and tweak it a little bit.	//	Consider it a to-do item.	//	EventRecord		event;	DialogRef		pop, dummy;	WindowRef		whichWindow;	short			partCode;	Boolean			handledIt = false;	pop = GetDialogFromWindow (FrontWindow( ));	*itemHit = kDialogItemIndexNone;	do	{		WaitNextEvent (everyEvent & ~highLevelEventMask, &event, GetCaretTime( ), nil);		switch (event.what)		{			case mouseDown:				partCode = FindWindow (event.where, &whichWindow);				if (whichWindow != GetDialogWindow (pop))				{					#if TARGET_API_MAC_CARBON						SysBeep(10);					#else						if (partCode == inSysWindow)							SystemClick (&event,whichWindow);						else							SysBeep(10);					#endif										break;				}				if (inDrag == partCode)				{					Rect dragBounds;					dragBounds = (**GetMainDevice ( )).gdRect;					InsetRect (&dragBounds, 4, 4);					DragWindow (GetDialogWindow (pop), event.where, &dragBounds);					break;				}				// fall thru			default:				if (mfp)					handledIt = CallModalFilterProc (mfp,pop,&event,itemHit);				if (!handledIt && IsDialogEvent(&event))					DialogSelect(&event,&dummy,itemHit);				break;		}	}	while (*itemHit == kDialogItemIndexNone);}pascal Boolean ToggleDialogCheckBox (DialogRef dialog, DialogItemIndex itemIndex){	if (!MoreAssert (itemIndex > 0 && itemIndex <= CountDITL (dialog)))		return false;	short iType; Handle iHandle; Rect iRect;	::GetDialogItem (dialog, itemIndex, &iType, &iHandle, &iRect);	if (!MoreAssert ((iType & ~(kItemDisableBit | kControlDialogItem)) == chkCtrl))		return false;	Boolean result = !::GetControlValue (ControlRef (iHandle));	::SetControlValue (ControlRef (iHandle), result);	return result;}pascal OSErr MoreAppendDialogItemList (DialogPtr dialog, DialogItemIndex ditlID, DITLMethod method){	//	//	Under Mac OS 8.5 and 8.5.1, AppendDialogItemList returns garbage when called	//	from 68K code (through the address in the trap table). We attempt to detect	//	the context in which this is a problem and work around it by doing our own	//	feeble but not grossly incorrect error checking. One thing to be aware of	//	is that this function does not allow you to append 0-item dialog item lists	//	on systems which have the bug. If you have a better idea for how to do a	//	modicum of error checking without a significant increase in complexity,	//	let us know.	//	#if !TARGET_CPU_68K		return AppendDialogItemList (dialog,ditlID,method);	#else		Boolean appendDialogItemListReturnsGarbage = (GetSystemVersion ( ) & 0xFFFFFFF0) == 0x00000850;		if (!appendDialogItemListReturnsGarbage)			return AppendDialogItemList (dialog,ditlID,method);		DialogItemIndex		itemCountBefore		= CountDITL (dialog);		OSErr				err					= AppendDialogItemList (dialog,ditlID,method);		if (err)		{			DialogItemIndex itemCountAfter = CountDITL (dialog);			err = (itemCountBefore < itemCountAfter) ? noErr : paramErr;		}		return err;	#endif}