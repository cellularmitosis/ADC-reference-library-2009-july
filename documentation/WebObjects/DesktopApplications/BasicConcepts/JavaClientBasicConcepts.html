<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>WebObjects Java Client Programming Guide (Legacy): Java Client Concepts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Java Client Concepts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001017-CH299" title="Java Client Concepts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../LegacyTechnologies/Tools-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000463" target="_top">Tools</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30001017-CH297-TP1">WebObjects Java Client Programming Guide (Legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../PuttingItAllTogether/PuttingItAllTogether.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../BasicTutorial/BasicTutorial.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP30001017-CH299-TP9" title="Java Client Concepts"></a><h1>Java Client Concepts</h1><p>This chapter introduces you to the fundamental concepts of Java Client. It defines the Enterprise Object technology and explains how it maps your database schema into Java objects. It covers Java Client architecture and includes information on the different framework layers and the functionality they provide. <span class="content_text"><a href="../BasicTutorial/BasicTutorial.html#//apple_ref/doc/uid/TP30001017-CH300-TP9">“Building a Simple Application”</a></span> links the concepts presented here to practical use in a sample application.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF7">Enterprise Objects</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF10">Java Client Architecture</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF11">Business Logic</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF114">Foundation Framework</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF13">Access Layer</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF20">Control Layer</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF26">Distribution Layer</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF30">Client Interface Layer</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF29">Application Layer</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-CJBGJCJD">Generation Layer</a>
				
			<br/>
			
        
			
			
				<a href="JavaClientBasicConcepts.html#//apple_ref/doc/uid/TP30001017-CH299-TPXREF34">Model-View-Controller Paradigm</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF7" title="Enterprise Objects"></a><h2>Enterprise Objects</h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_280"></a><p>To understand the Java Client architecture, you must first understand enterprise objects. Like all WebObjects applications, Java Client applications gain much of their usefulness by interacting with a persistent data store, usually a database. In WebObjects, databases are represented as collections of objects called enterprise objects that contain your application’s business logic. </p><p>The Enterprise Object technology maps your data to these enterprise objects, and you work with the objects rather than directly with the data store. The Enterprise Object technology handles all communication with the database, which frees you from writing SQL and other database-specific code.</p><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_281"></a>The Enterprise Object technology is composed of specialized layers:</p><ul class="ul"><li class="li"><p><code>com.webobjects.eoaccess.EOAdaptor</code> subclasses use JDBC or <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_282"></a>JNDI to read and write from data stores.</p></li><li class="li"><p><code>com.webobjects.eoaccess</code> manages interaction with a database; it is responsible for object-relational mapping.</p></li><li class="li"><p><code>com.webobjects.eocontrol</code> manages a graph of enterprise objects; tracks insertions into, deletions from, and changes within the object graph.</p></li><li class="li"><p><code>com.webobjects.eointerface</code> mediates between the control layer and an application’s user interface; maps data to user interface elements.</p></li><li class="li"><p><code>com.webobjects.eodistribution</code> and <code>com.webobjects.eodistribution.client</code> distribute enterprise objects across the network to the client; they provide much of the functionality of the EOAccess layer on the client.</p></li><li class="li"><p><code>com.webobjects.eoapplication</code> and <code>com.webobjects.eoapplication.client</code> form a general user-interface utility layer specific to both types of Java Client applications.</p></li><li class="li"><p><code>com.webobjects.eogeneration</code> and <code>com.webobjects.eogeneration.rules</code> dynamically generate the user interface for Direct to Java Client applications.</p></li></ul><p>These layers are described in more detail later in this chapter.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF8" title="What Is an Enterprise Object? "></a><h3>What Is an Enterprise Object? </h3><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_283"></a><p>An enterprise object is like any other object in that it couples data with the methods for operating on that data. However, an enterprise object class has certain characteristics that distinguish it from other classes:</p><ul class="spaceabove"><li class="li"><p>It has properties that map to stored data; an enterprise object instance typically corresponds to a single row or record in a database.</p></li><li class="li"><p>It knows how to interact with other parts of the Enterprise Object technology to give and receive values for its properties.</p></li></ul><p>An enterprise object is made up of its class definition (such as <code>com.webobjects.eocontrol.EOGenericRecord</code>) and the data values from the database row or record with which the object is instantiated. An enterprise object has a corresponding model that defines the mapping between the class’s object model and the database schema. However, an enterprise object doesn’t explicitly “know” about its model. Rather, it accesses its model through a <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_284"></a><code>com.webobjects.eocontrol.EOClassDescription</code> object.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF9" title="Enterprise Object Models"></a><h3>Enterprise Object Models</h3><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_285"></a><p>One of the fundamental features of the Enterprise Object technology is that it maps the data in data stores (usually relational databases) to objects. The industry term for this is <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_286"></a>object-relational mapping. The correspondence between an enterprise object class and stored data is established and maintained by a model. A model defines the mapping between enterprise object classes and a data store in <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_287"></a>entity-relationship terms.</p><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_288"></a>In addition to storing a mapping between the data store schema and enterprise objects, a model file stores information needed to connect to the data store. This connection information includes the name of an adaptor to load so that enterprise objects can communicate with the data store. <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_289"></a>WebObjects provides a JDBC adaptor that allows you to connect to any <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_290"></a>JDBC Type 2 compliant or Type 4 compliant database. It also provides a JNDI adaptor, and you can write your own adaptors to connect to other types of data stores.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF10" title="Java Client Architecture"></a><h2>Java Client Architecture</h2><p>A Java Client application is essentially an Enterprise Objects application distributed across an application server and one or more client applications or applets. </p><p>The design of Java Client breaks up some of the layers of the Enterprise Object technology and distributes them across the client and the application server. <span class="content_text">Figure 2-1</span> illustrates this architecture.</p><br/><div><a name="//apple_ref/doc/uid/TP30001017-CH299-CJBFICFC" title="Figure 2-1Java Client architecture"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Java Client architecture</p><img src = "../Art/javaclientarchitecture.gif" alt = "Java Client architecture" width="293" height="579"></div><br/><p>The packages <code>com.webobjects.foundation</code>, <code>com.webobjects.eocontrol</code>, and <code>com.webobjects.eodistribution.client</code> are provided on the client to allow real, full-fledged, first-class enterprise objects to exist on the client side. Other technologies similar to Java Client usually implement client stubs on the client side, instead of creating real objects.</p><p>The client stub design requires a round trip to the server anytime the user does anything with the business logic on the client. In the Java Client architecture, the business logic (represented in real objects) can be queried and otherwise manipulated without making a round trip to the server. Only when the user explicitly executes a database action, such as saving or fetching, is a round trip to the server made. This is made possible because the distribution layer uses a <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_291"></a>by-copy distribution mechanism, which is described in more detail in <span class="content_text"><a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30001017-CH297-TPXREF117">“Java Client and Other Multitier Systems.”</a></span></p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF11" title="Business Logic "></a><h2>Business Logic </h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_292"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_293"></a><p>The Enterprise Object architecture abstracts business logic from data stores and from specific data-access mechanisms. This abstraction lets you build reusable business objects that are independent of any data store or of the mechanisms for accessing data. If you build well-behaving business objects, you can easily change the data store your model accesses.</p><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_294"></a>To achieve the goal of reusability, the Enterprise Object technology requires that your business logic contains no data store schema information. Business objects should not be identifiable as relating to any specific data store except by the data they contain. That is, your business objects shouldn’t have any knowledge of database primary and foreign keys, JDBC code, or data store connection dictionary information. This allows you to use identical business logic classes on the client and on the server.</p><p>In Java Client applications, you must take extra control of your business logic and business objects. Unlike with HTML-based WebObjects applications, Java Client applications pass Java business logic classes (business objects) across the network. Clearly, you want to control which business logic and data each business object contains.</p><p>For instance, the client should hardly ever need to know credit card information, user passwords, algorithms specific to your business, or other sensitive business logic. <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_295"></a>Java Client defines these parameters for business logic partitioning:</p><ul class="ul"><li class="li"><p>Each business object can be represented by a different class on the client and on the server. </p></li><li class="li"><p>These different classes usually contain different sets of class properties.</p></li><li class="li"><p>The goal in business logic partitioning is to pass as little data to the client as possible.</p></li><li class="li"><p>Since some computations require additional data, it makes sense to let certain algorithms execute on the application server, which lives closer to the data store, and to control if this data is sent to the client. </p></li></ul><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_296"></a>The most important aspect of business logic partitioning is finding the partitioning scheme that minimizes the amount of data transferred from client to server. This and other business logic partitioning issues are discussed in more programmatic terms in <span class="content_text"><a href="../DistributionLayer/DistributionLayer.html#//apple_ref/doc/uid/TP30001017-CH302-TPXREF31">“Business Logic Partitioning.”</a></span></p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF114" title="Foundation Framework"></a><h2>Foundation Framework</h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_297"></a><p>The Foundation framework (<code>com.webobjects.foundation</code>) provides a set of robust and mature core classes, including utility, collection, key-value coding, time and date, notification, and debug logging classes.</p><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_298"></a>Although you may choose to use the standard Java classes such as <code>java.util.Vector</code> and <code>java.util.HashTable</code>, Foundation provides a rich set of classes that you may find more flexible and robust than the standard Java foundation classes.</p><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_299"></a>For historical reasons, the inner workings of WebObjects rely almost totally on Foundation for collections and other low-level functionality. In your custom classes, you are free to use the JDK foundation classes or the WebObjects Foundation classes. However, you’ll find that your custom classes will be better integrated with WebObjects if written with Foundation classes.</p><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_300"></a>Listed here are classes that you may find especially useful in Foundation. Consult the Foundation API reference for complete details.</p><ul class="ul"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_301"></a>NSKeyValueCoding</strong> provides arbitrary access to data in objects; a better-performing alternative to standard Java set and get methods.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_302"></a>NSLog</strong> is the WebObjects debug logging system; it allows you to easily control debug logging for everything from SQL generation to user interface generation.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_303"></a>NSBundle</strong> provides file system and archiving services (server-side only).</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_304"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_305"></a>NSDictionary and NSArray</strong> are common data structures used in object-relational mapping.</p></li></ul><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF13" title="Access Layer"></a><h2>Access Layer</h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_306"></a><p>The EOAccess layer (<code>com.webobjects.eoaccess</code>) is directly responsible for communicating with the data store and for registering enterprise objects with the EOControl layer. It exists only on the server and provides these functions:</p><ul class="ul"><li class="li"><p>generates SQL to fetch data from and commit data to data stores</p></li><li class="li"><p>manages the communication chain between the data store and the control layer</p></li><li class="li"><p>manages model files, which define the object-relational mapping between data stores and Java objects</p></li><li class="li"><p>provides classes that represent various database elements, such as tables, relationships, stored procedures, and joins</p></li><li class="li"><p>maps raw data to business objects</p></li></ul><p>EOAccess provides an elegant way to interact programmatically with data stores in an abstract manner. It is designed to work with all different types of data stores and different data store vendors, so many of its objects are portable to different data access environments. Although EOAccess is an essential element of any WebObjects application, you rarely need to use it programmatically.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF14" title="Essential EOAccess Classes"></a><h3>Essential EOAccess Classes</h3><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_307"></a><p>The following sections introduce important EOAccess classes. For complete details, see the EOAccess API reference.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF15" title="EOAdaptor"></a><h4>EOAdaptor</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_308"></a><p>EOAdaptor defines a server-independent interface for working with relational database systems. This class is subclassed to communicate with specific data sources. Server-specific subclasses encapsulate the behavior of a specific data source.</p><p>EOAdaptor isolates your application from any particular data source. By switching the EOAdaptor your application uses, you can change data sources without changing any source code in your application.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF17" title="EODatabaseContext"></a><h4>EODatabaseContext</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_309"></a><p>EODatabaseContext class has many responsibilities, including fetching, faulting, saving, and managing transactions and channels.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF18" title="EOModel"></a><h4>EOModel</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_310"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_311"></a><p>EOModels establish and maintain the correspondence between an enterprise object and stored data in entity-relationship terms. EOModels also store database connection information, including the adaptor’s name.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF19" title="EOUtilities"></a><h4>EOUtilities</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_312"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_313"></a><p>EOUtilities provides a collection of static convenience methods that make working with enterprise objects easier. The methods allow you to query editing contexts for information on the entities, objects, and relationships they manage. Convenience methods are provided that allow you to more easily work with raw SQL, if necessary.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_139" title="Note"></a><p><strong>Note:</strong>&nbsp;EOUtilities is not available on the client because it exists in the <code>com.webobjects.eoaccess</code>, package which is not provided on the client. Furthermore, you should be careful when using EOUtilities in server-side business logic classes as some of its methods reduce the reusability of those classes.</p></div><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF20" title="Control Layer"></a><h2>Control Layer</h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_314"></a><p>The EOControl layer (<code>com.webobjects.eocontrol</code>) exists in identical form on both the client side and the server side of Java Client applications. This layer manages the object graph (a collection of enterprise objects), implements faulting (on-demand fetching), and tracks editing changes. The object store and data source used by the client control layer communicate changes to the object graph across the channel to the server.</p><p>The control layer in Java Client applications maintains an object graph on the client and on the server, but the set of objects in each object graph may differ depending on how you partition your business logic. An object that exists in both client and server object graphs is synchronized with the help of the distribution layer.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF21" title="Essential EOControl Classes"></a><h3>Essential EOControl Classes</h3><p>The EOControl layer is very abstract, which allows it flexibility. Its abstract nature allows EOControl objects to live independent of any persistence scheme, database, or data source. The client and server parts of a Java Client application have the exact same EOControl layer; it is the layer that plugs into EOControl that differs for the client and the server. On the server side, EOControl objects talk to the database using EOAccess; on the client side, EOControl objects talk to the server using EODistribution. The EOControl classes you will encounter in development are introduced here.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF22" title="EOEnterpriseObject"></a><h4>EOEnterpriseObject</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_315"></a><p>An EOEnterpriseObject is a flexible representation of your business logic. EOEnterpriseObjects are conceptually abstract—they are ignorant of specific data stores and data-access mechanisms. All EOEnterpriseObjects conform to these behaviors:</p><ul class="spaceabove"><li class="li"><p><strong>Key-value coding<a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_316"></a></strong> is a mechanism that allows arbitrary access to data in objects without requiring instance variables. The following are examples of key-value coding accessors:  <code>student.valueForKey("name")</code><code>student.takeValueForKey("name", "Ernest")</code>. </p></li><li class="li"><p><strong>Validation<a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_317"></a></strong> of data is done before saving, deleting, updating, and performing other operations.</p></li><li class="li"><p><strong>Relationship manipulation<a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_318"></a></strong> provides methods to facilitate the management of objects in a relationship.</p></li><li class="li"><p><strong>Faulting<a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_319"></a></strong> provides placeholders for data, rather than fetching all data at once.</p></li></ul><p>These behaviors provide convenience and flexibility for your business objects, while enhancing performance and offering important business functionality.</p><p>EOEnterpriseObject is an interface, so you never instantiate it. Rather, WebObjects provides two classes that implement EOEnterpriseObject:</p><ul class="spaceabove"><li class="li"><p><strong>EOCustomObject<a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_320"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_321"></a></strong> inherits from <code>java.lang.Object</code>, implements <code>com.webobjects.eocontrol.EOEnterpriseObject</code>.</p></li><li class="li"><p><strong>EOGenericRecord<a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_322"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_323"></a></strong> inherits from EOCustomObject.</p></li></ul><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF23" title="EOEditingContext"></a><h4>EOEditingContext</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_324"></a><p>An EOEditingContext manages the graph of enterprise objects in your application. The EOEditingContext is responsible for ensuring that all parts of your application stay in sync with one another and with your data store—it is the WebObjects change-tracking mechanism. When an enterprise object changes, the EOEditingContext sends a notification so that other parts of the application, such as the user interface, can update themselves accordingly. </p><p>The EOEditingContext also manages undo and revert and is the object through which you save changes to the database. EOEditingContext is designed to abstract these database operations from your business objects, which keeps any database-specific information from living inside your business logic.</p><p>An EOEditingContext is always associated with an instance of a parent object store. In Java Client applications, the client and server have separate editing contexts. The client-side editing context is associated with a client-side object store, <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_325"></a><code>com.webobjects.eodistribution.client.EODistributedObjectStore</code>; the server-side editing context is associated with a server-side object store, <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_326"></a><code>com.webobjects.eoaccess.EODatabaseContext</code>.</p><p>You can think of an EOEditingContext object as an abstract database transaction object. In WebObjects, a request to fetch data from a data store is usually done from the control layer, and fetches done from the control layer almost always happen from within an EOEditingContext. Once data is fetched into objects, an EOEditingContext manages the graph of fetched objects, tracks changes to those objects, and is the object through which you invoke data store commits. </p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF24" title="EOFetchSpecification"></a><h4>EOFetchSpecification</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_327"></a><p>Because database fetches are resource-intensive operations (expensive), you rarely ask for all the data at once. Rather, you provide criteria for the data to be fetched with an EOFetchSpecification. An EOFetchSpecification describes the objects to be retrieved using an <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_328"></a>EOQualifier (an object that restricts the selection of database rows based on a specified criterion).</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF25" title="EOGlobalID"></a><h4>EOGlobalID</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_329"></a><p>To maintain database independence, EOControl provides an internal mechanism to identify objects. Other systems use database primary and foreign keys to identify objects, but these keys don’t represent data (they represent locations in the data store) and so shouldn’t be part of your business logic. The algorithm used to generate EOGlobalIDs is designed to guarantee completely unique identifiers. </p><p>A subclass of EOGlobalID, <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_330"></a>EOTemporaryGlobalID, identifies objects before they are committed to the data store.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF36" title="EOObjectStoreCoordinator"></a><h4>EOObjectStoreCoordinator</h4><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_331"></a><p>A single Java Client application can access data from different data stores. In this case, each EOModel is usually associated with a different data store, and this added complexity requires an object to manage it. Each EOModel in an application has a corresponding EODatabaseContext object. The EOObjectStoreCoordinator sits between the client’s editing contexts and the EODatabaseContext objects and isolates the editing contexts from the application’s data sources<a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_332"></a>.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF26" title="Distribution Layer"></a><h2>Distribution Layer</h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_333"></a><p>The distribution layer (<code>com.webobjects.eodistribution</code> and <code>com.webobjects.eodistribution.client</code>) synchronizes the states of the object graphs on the client and on the application server. This layer exists in part on both the client and the server and moves business objects between the two. The distribution layer on the server fetches objects and saves changes from the database and communicates these actions to the distribution layer on the client.</p><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_334"></a>The server-side distribution layer contains the <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_335"></a>EODistributionContext class. It encodes data to send to the client and decodes data it receives from the client over the distribution channel. (You can implement your own encoding and decoding schemes to improve security.) It also synchronizes the server and client object graphs by tracking the state of the server-side object graph and communicating any changes to the client. EODistributionContext also validates remote invocations originating from client objects to allow only authorized invocations.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF28" title="Essential EODistribution Classes "></a><h3>Essential EODistribution Classes </h3><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_336"></a><p>Listed here are the classes you are most likely to deal with programmatically. For complete details, see the EODistribution API reference. </p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_337"></a>EODistributionChannel, <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_338"></a>EOHTTPChannel.</strong> The distribution layer provides classes for communication between the application server and client applications. EOHTTPChannel is a subclass of EODistributionChannel and implements an HTTP channel to communicate with clients. You can subclass EODistributionChannel to use a different transport protocol such as <a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_339"></a>CORBA.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_340"></a>EODistributedObjectStore.</strong> This class mediates between the distribution layer’s channel (an EODistributionChannel object) and the client’s editing contexts. It sends messages to its child editing contexts from the server and sends messages to the server from its editing contexts.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_341"></a>EODistributedDataSource.</strong> Using an EOEditingContext, objects of this class fetch, insert, and delete objects from the object store. This class implements all the functionality of EODataSource, but it exists solely on the client side.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_342"></a>EODistributionContext.</strong> This object exists on the server and is responsible for communicating with its client-side counterpart EODistributionChannel. These two objects mediate object transfer over the network and handle remote method invocation. </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_343"></a>WOJavaClientComponent. </strong>This object sits on the server side and forwards requests from the client’s EODistributionChannel to the server’s EODistributionContext. It also plays a critical role in application initialization.</p></li></ul><p>See <span class="content_text"><a href="../DistributionLayer/DistributionLayer.html#//apple_ref/doc/uid/TP30001017-CH302-TP1">“The Distribution Layer”</a></span> for more information on the distribution layer and to better understand how these objects work together.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF30" title="Client Interface Layer"></a><h2>Client Interface Layer</h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_344"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_345"></a><p>The EOInterface layer (<code>com.webobjects.eointerface</code>) displays to the user the properties of the enterprise objects maintained in the client control layer. Changes to the object graph are automatically synchronized with the user interface, and user-entered data is automatically reflected in the object graph. The primary mechanisms behind this synchronization are associations and display groups.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF32" title="Display Groups"></a><h3>Display Groups</h3><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_346"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_347"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_348"></a><p>A display group (<code>com.webobjects.eointerface.EODisplayGroup</code>) coordinates the flow of data between the user interface and the database. Display groups decide what data to allow associations to display. They fetch data from either database contexts or other display groups through <code>com.webobjects.eocontrol.EODataSource</code> objects.</p><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF99" title="Associations"></a><h3>Associations</h3><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_349"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_350"></a><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_351"></a><p>As mentioned earlier, associations keep the user interface synchronized with enterprise object values. Associations in Java Client derive from EOAssociation, an object that maintains a two-way binding between the properties of a display object and the properties of one or more enterprise objects contained in EODisplayGroups.</p><p>EOAssociation defines the different parameters of the display object it controls using <strong>aspects</strong>. These parameters include the values displayed and whether the display object is enabled or editable. Each aspect of a display object can be bound to an EODisplayGroup object with a key denoting the property of its associated enterprise object. </p><p>For instance, EOTableAssociation (<code>com.webobjects.eointerface.EOTableAssociation</code>) defines these aspects:</p><ul class="spaceabove"><li class="li"><p><code>source</code>—the object from which the table’s data is fetched, usually a display group.</p></li><li class="li"><p><code>bold</code>—sets a flag to make the text in the table bold.</p></li><li class="li"><p><code>italic</code>—sets a flag to make the text in the table italics.</p></li><li class="li"><p><code>textColor</code>—defines the color of the text in the table.</p></li><li class="li"><p><code>enabled</code>—a flag that controls editability, usually associated with an attribute in a display group.</p></li></ul><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_352"></a>The EOInterface framework includes associations for different types of user interface objects, such as table columns, text fields, and checkboxes. Each association has multiple aspects. Associations are defined in the EOInterface framework. See the EOInterface API reference for complete details.</p><p>Typically, you create and configure associations in Interface Builder when you build user interfaces by hand. Associations are created and configured automatically if you use the dynamic user interface generation of the Direct to Java Client approach. See the EOInterface API reference for information on configuring associations programmatically.</p><p><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_353"></a>There are many different kinds of associations. These are some of the more common ones:</p><ul class="spaceabove"><li class="li"><p><strong>EOActionAssociation.</strong> Sits between an action widget (such as a button) and a display group. Reacts to a mouse click or a keypress and invokes a particular business method, based on the bound aspect.</p></li><li class="li"><p><strong>EOMasterDetailAssociation.</strong> These associations bind one display group (the detail display group) to a relationship in another display group (the master display group) so that the detail display group contains the destination objects for the object selected in the master display group. Takes a relationship key rather than an entity name and displays a subset of data in the master display group.</p></li><li class="li"><p><strong>EOTableAssociation.</strong> Maps all the objects in a display group to a user interface table view. This association takes no direct keys, but uses an EOTableColumnAssociation, which take keys.</p></li><li class="li"><p><strong>EOTextFieldAssociation.</strong> Takes a value key that determines the property to be displayed in or taken from the text field.</p></li><li class="li"><p><strong>EOValueAssociation.</strong> Associates a single property of the value display group’s selected object with a widget.</p></li></ul><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF29" title="Application Layer"></a><h2>Application Layer</h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_354"></a><p>The EOApplication layer, defined in <code>com.webobjects.eoapplication</code> and in <code>com.webobjects.eoapplication.client</code> , isolates the developer from the idiosyncrasies of each client-side execution environment (Web Start, desktop applications, or applets). It provides the classes that are used to manage application-level data and resources, including transient and persistent defaults, localization information, menu operations like save and quit, documents, user interface controls, and so on.</p><p>JFC/Swing does not provide a full suite of application logic utility classes, so the Java Client application layer steps in and provides other basic services as well, such as application startup and shutdown. </p><a name="//apple_ref/doc/uid/TP30001017-CH299-CJBGJCJD" title="Generation Layer"></a><h2>Generation Layer</h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_355"></a><p>The EOGeneration layer, defined in <code>com.webobjects.eogeneration</code> and <code>com.webobjects.eogeneration.rules</code>, dynamically generates user interfaces in Java Client applications that use the rule system. It is not used in nondirect Java Client applications. This layer analyzes your application’s business model (defined in an EOModel) and, using a sophisticated set of rules, generates a user interface. The user interface description is then sent to the client where it is executed. You can alter the rules in a number of ways for customization purposes.</p><p>The generation layer consists of predefined controller classes that are dynamically mapped to Swing user interface objects and Enterprise Objects at runtime. The generation layer uses the WebObjects rule system as part of this dynamic user interface generation. The rule system and the generation layer are the elements that make a Direct to Java Client application different from a nondirect Java Client application. They are illustrated in <span class="content_text">Figure 2-2</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF37" title="Figure 2-2The complete stack of WebObjects layers in Direct to Java Client"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>The complete stack of WebObjects layers in Direct to Java Client</p><img src = "../Art/applicationarchitecture.gif" alt = "The complete stack of WebObjects layers in Direct to Java Client" width="244" height="421"></div><br/><a name="//apple_ref/doc/uid/TP30001017-CH299-TPXREF34" title="Model-View-Controller Paradigm "></a><h2>Model-View-Controller Paradigm </h2><a name="//apple_ref/doc/uid/TP30001017-CH299-DontLinkElementID_356"></a><p>A common and useful paradigm for object-oriented applications, particularly business applications, is Model-View-Controller (MVC). Derived from Smalltalk-80, MVC proposes three types of objects in an application, separated by abstract boundaries and communicating with each other across those boundaries.</p><p>Model objects represent special knowledge and expertise, such as a company’s data and business logic. Model objects are not directly displayed. They often are reusable, distributed, persistent, and portable to a variety of platforms.</p><p>View objects represent things visible in the user interface such as windows, table views, and buttons. A View object is “ignorant” of the data it displays, as it relies exclusively on the Controller object for data. View objects tend to be very reusable and so provide consistency between applications.</p><p>The Controller object acts as a mediator between Model objects and View objects. Usually there is one Controller per application or per window. Controller objects communicate data back and forth between the Model objects and the View objects. A Controller’s function is usually very specific to an application, so it is generally not reusable like View and Model objects are.</p><p>Because of the Controller’s central mediating role, Model objects need not know about the state and events of the user interface, and View objects need not know about the programmatic interfaces of Model objects.</p><p>Within the MVC paradigm, enterprise objects are Model objects. By definition, Model objects represent data and business logic. The Enterprise Object technology extends the MVC paradigm so enterprise objects are independent of their persistent storage mechanism. Enterprise objects do not need to know about the database that holds their data, and the database doesn’t need to know about the enterprise object formed from its data.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../PuttingItAllTogether/PuttingItAllTogether.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../BasicTutorial/BasicTutorial.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-08-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/WebObjects/DesktopApplications/BasicConcepts/JavaClientBasicConcepts.html%3Fid%3DTP30001017-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/WebObjects/DesktopApplications/BasicConcepts/JavaClientBasicConcepts.html%3Fid%3DTP30001017-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/WebObjects/DesktopApplications/BasicConcepts/JavaClientBasicConcepts.html%3Fid%3DTP30001017-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>