<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SGDataProcSample - /Minimung.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxCompressionDecompression-date.html">Compression & Decompression</a> &gt; <A HREF="javascript:location.replace('index.html');">SGDataProcSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SGDataProcSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Minimung.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Minimung.c</option>
<option value="listing2.html">/Minimung.r</option>
<option value="listing3.html">/Munggrab.c</option>
<option value="listing4.html">/Munggrab.r</option>
<option value="listing5.html">/SonOfMungGrab.c</option>
<option value="listing6.html">/SonOfMunggrab.r</option>
<option value="listing7.html">/SonOfMunggrabPrefix.r</option></select>
				</p>
				</form>
				<p><strong><a href="SGDataProcSample.zip">Download Sample</a></strong> (&#147;SGDataProcSample.zip&#148;, 89.3K)<BR>
<strong><a href="SGDataProcSample.dmg">Download Sample</a></strong> (&#147;SGDataProcSample.dmg&#148;, 159.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    Minimung.c    Description: Minimung shows how to run the Sequence Grabber in record mode and use         a DataProc to get at the captured data. This technique provides optimal         performance, far better than using preview mode with SG bottlenecks.         This code will help a lot when capturing from DV and should allow         30fps playthrough using DV capture on a G3.  Author:    km, era  Copyright:   &copy; Copyright 2000 - 2001 Apple Computer, Inc. All rights reserved.    Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          Change History (most recent first):  &lt;3&gt; 3/28/02 DV source rect bug fix in DataProc                    &lt;2&gt; 4/04/00 carbonized                     &lt;1&gt; 1/13/00 initial release*/// NOTE:// this sample uses carbon accessesors and will not// build if you have not specified a carbon target// build for carbon#define TARGET_API_MAC_CARBON 1#if __APPLE_CC__  #include &lt;Carbon/Carbon.h&gt;  #include &lt;QuicKTime/QuickTime.h&gt;#else  #include &lt;ConditionalMacros.h&gt;  #include &lt;QuickTimeComponents.h&gt;  #include &lt;TextUtils.h&gt;  #include &lt;stdio.h&gt;#endif#define BailErr(x) {err = x; if(err != noErr) goto bail;}// datatypedef struct {  GWorldPtr     pGWorld;  Rect      boundsRect;  WindowRef      pWindow;  ImageSequence   decomSeq;  // unique identifier for our decompression sequence  ImageSequence   drawSeq;  // unique identifier for our draw sequence} tMungDataRecord, *MungDataPtr;// global data pointerstatic MungDataPtr gpMungData = NULL;OSErr InitializeMungData(Rect inBounds,const WindowRef inWindow);OSErr InitializeMungData(Rect inBounds,const WindowRef inWindow){    OSErr err = noErr;        // allocate memory for the data    gpMungData = (MungDataPtr)NewPtrClear(sizeof(tMungDataRecord));    if (gpMungData ==NULL) {err = MemError(); goto bail;}        // create the GWorld    err = QTNewGWorld(&amp;(gpMungData-&gt;pGWorld),  // returned GWorld              k32ARGBPixelFormat,    // pixel format              &amp;inBounds,        // bounding rectangle              0,            // color table              NULL,            // graphic device handle              0);            // flags    BailErr(err);       // lock the pixmap and make sure it's locked because    // we can't decompress into an unlocked PixMap    if(!LockPixels(GetPortPixMap(gpMungData-&gt;pGWorld)))      BailErr(-1);        gpMungData-&gt;boundsRect = inBounds;    gpMungData-&gt;pWindow = inWindow;bail:    return err;}void DisposeMungData(void);void DisposeMungData(void){    // end the decompression sequences    // clean up the bits    if (gpMungData) {        if (gpMungData-&gt;decomSeq) CDSequenceEnd(gpMungData-&gt;decomSeq);        if (gpMungData-&gt;drawSeq) CDSequenceEnd(gpMungData-&gt;drawSeq);        if (gpMungData-&gt;pGWorld) {      DisposeGWorld(gpMungData-&gt;pGWorld);          gpMungData-&gt;pGWorld = NULL;        }        DisposePtr((Ptr)gpMungData);        gpMungData = NULL;    }}/* ---------------------------------------------------------------------- *//* sequence grabber data procedure - this is where the work is done/* ---------------------------------------------------------------------- *//* mySGDataProc - the sequence grabber calls the data function whenever   any of the grabber's channels write digitized data to the destination movie file.      NOTE: We really mean any, if you have an audio and video channel then the DataProc will        be called for either channel whenever data has been captured. Be sure to check which        channel is being passed in. In this example we never create an audio channel so we know        we're always dealing with video.      This data function decompresses captured video data into an offscreen GWorld,   then transfers the frame to an onscreen window.      For more information refer to Inside Macintosh: QuickTime Components, page 5-120   c - the channel component that is writing the digitized data.   p - a pointer to the digitized data.   len - the number of bytes of digitized data.   offset - a pointer to a field that may specify where you are to write the digitized data,         and that is to receive a value indicating where you wrote the data.   chRefCon - per channel reference constant specified using SGSetChannelRefCon.   time  - the starting time of the data, in the channel's time scale.   writeType - the type of write operation being performed.       seqGrabWriteAppend - Append new data.       seqGrabWriteReserve - Do not write data. Instead, reserve space for the amount of data                   specified in the len parameter.       seqGrabWriteFill - Write data into the location specified by offset. Used to fill the space                  previously reserved with seqGrabWriteReserve. The Sequence Grabber may                  call the DataProc several times to fill a single reserved location.   refCon - the reference constant you specified when you assigned your data function to the sequence grabber.*/pascal OSErr mySGDataProc(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon);pascal OSErr mySGDataProc(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon){#pragma unused(offset,chRefCon,time,writeType)        CodecFlags     ignore;    MungDataPtr   theMungData = (MungDataPtr)refCon;      ComponentResult err = noErr;        if (!theMungData) goto bail;       if(theMungData-&gt;pGWorld) {        if (theMungData-&gt;decomSeq == 0) {            Rect           sourceRect = { 0, 0 };      MatrixRecord       scaleMatrix;            ImageDescriptionHandle imageDesc = (ImageDescriptionHandle)NewHandle(0);                        /* Set up getting grabbed data into the GWorld */                        // retrieve a channel's current sample description, the channel returns a sample description that is            // appropriate to the type of data being captured            err = SGGetChannelSampleDescription(c,(Handle)imageDesc);            BailErr(err);                        /***** IMPORTANT NOTE *****                   Previous versions of this sample code made an incorrect decompression       request.  Intending to draw the DV frame at quarter-size into a quarter-size       offscreen GWorld, it made the call           err = DecompressSequenceBegin(..., &amp;rect, nil, ...);       passing a quarter-size rectangle as the source rectangle.  The correct       interpretation of this request is to draw the top-left corner of the DV       frame cropped at normal size.  Unfortunately, a DV-specific bug in QuickTime       5 caused it to misinterpret this request and scale the frame to fit.       This bug will be fixed in QuickTime 6.  If your code behaves as intended       because of the bug, you should fix your code to pass a matrix scaling the       frame to fit the offscreen gworld:        RectMatrix( &amp; scaleMatrix, &amp;dvFrameRect, &amp;gworldBounds );         err = DecompressSequenceBegin(..., nil, &amp;scaleMatrix, ...);             This approach will work in all versions of QuickTime.                   **************************/                        // make a scaling matrix for the sequence      sourceRect.right = (**imageDesc).width;      sourceRect.bottom = (**imageDesc).height;      RectMatrix(&amp;scaleMatrix, &amp;sourceRect, &amp;theMungData-&gt;boundsRect);                        // begin the process of decompressing a sequence of frames            // this is a set-up call and is only called once for the sequence - the ICM will interrogate different codecs            // and construct a suitable decompression chain, as this is a time consuming process we don't want to do this            // once per frame (eg. by using DecompressImage)            // for more information see Ice Floe #8 http://developer.apple.com/quicktime/icefloe/dispatch008.html            // the destination is specified as the GWorld            err = DecompressSequenceBegin(&amp;theMungData-&gt;decomSeq,  // pointer to field to receive unique ID for sequence                            imageDesc,        // handle to image description structure                            theMungData-&gt;pGWorld,    // port for the DESTINATION image                            NULL,            // graphics device handle, if port is set, set to NULL                            NULL,            // source rectangle defining the portion of the image to decompress                                          &amp;scaleMatrix,        // transformation matrix                                          srcCopy,          // transfer mode specifier                                          NULL,            // clipping region in dest. coordinate system to use as a mask                                          0,            // flags                                          codecNormalQuality,    // accuracy in decompression                                          bestSpeedCodec);      // compressor identifier or special identifiers ie. bestSpeedCodec            BailErr(err);                        DisposeHandle((Handle)imageDesc);            imageDesc = NULL;                        /* Set up getting grabbed data into the Window */                        // returns an image description for the GWorlds PixMap            // on entry the imageDesc is NULL, on return it is correctly filled out            // you are responsible for disposing it            err = MakeImageDescriptionForPixMap(GetPortPixMap(theMungData-&gt;pGWorld), &amp;imageDesc);            BailErr(err);                        // begin the process of decompressing a sequence of frames - see above notes on this call            // destination is specified as the Window            err = DecompressSequenceBegin(&amp;theMungData-&gt;drawSeq,                            imageDesc,                            GetWindowPort(theMungData-&gt;pWindow),                            NULL,                            &amp;theMungData-&gt;boundsRect,                            NULL,                            srcCopy,                            NULL,                            0,                            codecNormalQuality,                            bestSpeedCodec);            BailErr(err);                        if (imageDesc)              DisposeHandle((Handle)imageDesc);        }                // decompress a frame into the GWorld - can queue a frame for async decompression when passed in a completion proc        // once the image is in the GWorld it can be manipulated at will        err = DecompressSequenceFrameS(theMungData-&gt;decomSeq,  // sequence ID returned by DecompressSequenceBegin                        p,            // pointer to compressed image data                        len,          // size of the buffer                        0,            // in flags                        &amp;ignore,        // out flags                        NULL);          // async completion proc        BailErr(err);                // ******  IMAGE IS NOW IN THE GWORLD ****** //    // decompress one of a sequence of frames        // this draws the image back to the window from the GWorld and could be used as a &quot;preview&quot;        err = DecompressSequenceFrame(theMungData-&gt;drawSeq,                    // sequence ID returned by DecompressSequenceBegin                        GetPixBaseAddr(GetGWorldPixMap(theMungData-&gt;pGWorld)),  // pointer to compressed image data                        0,                            // in flags                        &amp;ignore,                          // out flags                        NULL);                          // async completion proc  }        bail:  return err;}int main(void){    SeqGrabComponent  seqGrab = NULL;    SGChannel      sgchanVideo = NULL;    Rect        theRect = {0, 0, 240, 320};    WindowRef      pWindow = NULL;       OSErr        err = noErr;    // initialize for Carbon &amp; QuickTime.  InitCursor();    EnterMovies();  // create a new window        CreateNewWindow(kDocumentWindowClass, kWindowNoAttributes, &amp;theRect, &amp;pWindow);    if (pWindow == NULL ) goto bail;  SetWTitle(pWindow, &quot;\pMiniMung&quot;);  MoveWindow(pWindow,50,50,true);  ShowWindow(pWindow);        // initialize the data structure we use with the    // sequence grabber data proc    err = InitializeMungData(theRect, pWindow);    BailErr(err);        // open the sequence grabber component and initialize it    seqGrab = OpenDefaultComponent(SeqGrabComponentType, 0);    err = SGInitialize(seqGrab);    BailErr(err);      // specify the destination data reference for a record operation  // tell it we're not making a movie  // if the flag seqGrabDontMakeMovie is used, the sequence grabber still calls  // your data function, but does not write any data to the movie file  // writeType will always be set to seqGrabWriteAppend    err = SGSetDataRef(seqGrab, 0, 0, seqGrabDontMakeMovie);    BailErr(err);         // it wants a port, even if its not drawing to it    err = SGSetGWorld(seqGrab, GetWindowPort(pWindow), GetMainDevice());    BailErr(err);        // create a new sequence grabber video channel    err = SGNewChannel(seqGrab, VideoMediaType, &amp;sgchanVideo);    BailErr(err);        // set the bounds for the channel    err = SGSetChannelBounds(sgchanVideo, &amp;theRect);    BailErr(err);        // set the usage for our new video channel to avoid playthrough    // note: we do not set seqGrabPlayDuringRecord because if you set this flag    // the data from the channel may be played during the record operation,    // if the destination buffer is onscreen. However, playing the    // data may affect the quality of the recorded sequence by causing frames     // to be dropped...something we definitely want to avoid    err = SGSetChannelUsage(sgchanVideo, seqGrabRecord);    BailErr(err);        // specify a data function for use by the sequence grabber    // whenever any channel assigned to the sequence grabber writes data,    // this data function is called and may then write the data to another destination    err = SGSetDataProc(seqGrab,NewSGDataUPP(mySGDataProc),(long)gpMungData);    BailErr(err);        // i'm ready for my closeup!    err = SGStartRecord(seqGrab);    BailErr(err);        while(!Button() &amp;&amp; !err)      // give the sequence grabber time to do it's thing      err = SGIdle(seqGrab);          FlushEvents(mDownMask, 0);    bail:  if (err) {    char  errMsg[32];    KeyMap  theKeys;    #define ISESCKEYDOWN() ((theKeys[1] &amp; 0x00002000) == 0x00002000)        // if there is an error, display the result    sprintf(errMsg, &quot;ESC to quit Err: %d&quot;, err);    c2pstrcpy((unsigned char *)&amp;errMsg, errMsg);    SetWTitle(pWindow, (unsigned char *)errMsg);        do {      GetKeys(theKeys);    } while  (!ISESCKEYDOWN());  }    HideWindow(pWindow);      if(seqGrab) {      // stop and close the grabber       SGStop(seqGrab);      CloseComponent(seqGrab);    }        DisposeMungData();        if(pWindow)      DisposeWindow(pWindow);    return 0;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SGDataProcSample/listing1.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SGDataProcSample/listing1.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SGDataProcSample/listing1.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>