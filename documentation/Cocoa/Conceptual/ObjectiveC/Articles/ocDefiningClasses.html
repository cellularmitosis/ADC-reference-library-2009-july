<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>The Objective-C 2.0 Programming Language: Defining a Class</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Defining a Class"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001163-CH12" title="Defining a Class"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ObjectiveCLanguage-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000856" target="_top">Objective-C Language</a> &gt; <a href="../Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163-CH1-SW2">The Objective-C 2.0 Programming Language</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocObjectsClasses.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocAllocInit.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001163-CH12-SW1" title="Defining a Class"></a><h1>Defining a Class</h1><p><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_49"></a>Much of object-oriented programming consists of writing the code for new objects—defining new classes. In Objective-C, classes are defined in two parts:</p><ul class="ul"><li class="li"><p>An <strong>interface</strong><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_50"></a> that declares the methods and instance variables of the class and names its superclass</p></li><li class="li"><p>An <strong>implementation</strong><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_51"></a> that actually defines the class (contains the code that implements its methods)</p></li></ul><p>These are typically split between two files, sometimes however a class definition may span several files through the use of a feature called a “category.” Categories can compartmentalize a class definition or extend an existing one. Categories are described in <span class="content_text"><a href="ocCategories.html#//apple_ref/doc/uid/TP30001163-CH20-SW1">“Categories and Extensions.”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-SW2">Source Files</a>
				
			<br/>
			
        
			
			
				<a href="ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-TPXREF122">Class Interface</a>
				
			<br/>
			
        
			
			
				<a href="ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-TPXREF126">Class Implementation</a>
				
			<br/>
			
        
			
			
				<a href="ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-BAJHDGAC">Messages to self and super</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001163-CH12-SW2" title="Source Files"></a><h2>Source Files</h2><p>Although the compiler doesn’t require it, the interface and implementation are usually separated into two different files. The interface file must be made available to anyone who uses the class.</p><p>A single file can declare or implement more than one class. Nevertheless, it’s customary to have a separate interface file for each class, if not also a separate implementation file. Keeping class interfaces separate better reflects their status as independent entities.</p><p>Interface and implementation files typically are named after the class. The name of the implementation file<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_52"></a> has the <code>.m</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_53"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_54"></a> extension, indicating that it contains Objective-C source code. The interface file can be assigned any other extension. Because it’s included in other source files, the name of the interface file usually has the <code>.h</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_55"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_56"></a> extension typical of header files. For example, the Rectangle class would be declared in <code>Rectangle.h</code> and defined in <code>Rectangle.m</code>. </p><p>Separating an object’s interface from its implementation fits well with the design of object-oriented programs. An object is a self-contained entity that can be viewed from the outside almost as a “black box.” Once you’ve determined how an object interacts with other elements in your program—that is, once you’ve declared its interface—you can freely alter its implementation without affecting any other part of the application.</p><a name="//apple_ref/doc/uid/TP30001163-CH12-87537" title="Class Interface"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF122" title="Class Interface"></a><h2>Class Interface</h2><p><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_57"></a>The declaration of a class interface begins with the compiler directive <code>@interface</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_58"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_59"></a> and ends with the directive<code> @end</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_60"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_61"></a>. (All Objective-C directives to the compiler begin with “@”.)</p><div class="codesample"><table><tr><td scope="row"><pre>@interface ClassName : ItsSuperclass<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    instance variable declarations<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>method declarations<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The first line of the declaration presents the new class name and links it to its superclass. The superclass defines the position of the new class in the inheritance hierarchy, as discussed under <span class="content_text"><a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-86370">“Inheritance.”</a></span> If the colon and superclass name are omitted, the new class is declared as a root class<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_62"></a>, a rival to the <code>NSObject</code> class.</p><p>Following the first part of the class declaration, braces enclose declarations of <strong>instance variables</strong><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_63"></a>, the data structures that are part of each instance of the class. Here’s a partial list of instance variables that might be declared in the Rectangle class:</p><div class="codesample"><table><tr><td scope="row"><pre>float width;<span></span></pre></td></tr><tr><td scope="row"><pre>float height;<span></span></pre></td></tr><tr><td scope="row"><pre>BOOL filled;<span></span></pre></td></tr><tr><td scope="row"><pre>NSColor *fillColor;<span></span></pre></td></tr></table></div><p>Methods<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_64"></a> for the class are declared next, after the braces enclosing instance variables and before the end of the class declaration. The names of methods that can be used by class objects, <strong>class methods</strong><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_65"></a>, are preceded by a plus sign<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_66"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_67"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>+ alloc;<span></span></pre></td></tr></table></div><p>The methods that instances of a class can use, <strong>instance methods</strong><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_68"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_69"></a>, are marked with a minus sign<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_70"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_71"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)display;<span></span></pre></td></tr></table></div><p>Although it’s not a common practice, you can define a class method and an instance method with the same name. A method can also have the same name as an instance variable. This is more common, especially if the method returns the value in the variable. For example, Circle has a <code>radius</code> method that could match a <code>radius</code> instance variable.</p><p>Method return types<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_72"></a> are declared using the standard C syntax for casting one type to another:</p><div class="codesample"><table><tr><td scope="row"><pre>- (float)radius;<span></span></pre></td></tr></table></div><p>Argument types<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_73"></a> are declared in the same way:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setRadius:(float)aRadius;<span></span></pre></td></tr></table></div><p>If a return or argument type isn’t explicitly declared, it’s assumed to be the default type for methods and messages—an <code>id</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_74"></a>. The <code>alloc</code> method illustrated earlier returns <code>id</code>.</p><p>When there’s more than one argument, the arguments are declared within the method name after the colons. Arguments break the name apart in the declaration, just as in a message. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setWidth:(float)width height:(float)height;<span></span></pre></td></tr></table></div><p>Methods that take a variable<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_75"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_76"></a> number of arguments declare them using a comma and ellipsis points, just as a function would:</p><div class="codesample"><table><tr><td scope="row"><pre>- makeGroup:group, ...;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH12-87788" title="Importing the Interface"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF123" title="Importing the Interface"></a><h3>Importing the Interface</h3><p>The interface file<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_77"></a> must be included in any source module that depends on the class interface—that includes any module that creates an instance of the class, sends a message to invoke a method declared for the class, or mentions an instance variable declared in the class. The interface is usually included with the <code>#import</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_78"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_79"></a> directive:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "Rectangle.h"<span></span></pre></td></tr></table></div><p>This directive is identical to <code>#include</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_80"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_81"></a>, except that it makes sure that the same file is never included more than once. It’s therefore preferred and is used in place of <code>#include</code> in code examples throughout Objective-C–based documentation.</p><p>To reflect the fact that a class definition builds on the definitions of inherited classes, an interface file<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_82"></a> begins by importing the interface for its superclass<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_83"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "ItsSuperclass.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface ClassName : ItsSuperclass<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    instance variable declarations<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>method declarations<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>This convention means that every interface file includes, indirectly, the interface files for all inherited classes. When a source module imports a class interface, it gets interfaces for the entire inheritance hierarchy that the class is built upon.</p><p>Note that if there is a <em>precomp</em>—a precompiled header<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_84"></a>—that supports the superclass, you may prefer to import the precomp instead.</p><a name="//apple_ref/doc/uid/TP30001163-CH12-87895" title="Referring to Other Classes"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF124" title="Referring to Other Classes"></a><h3>Referring to Other Classes</h3><p>An interface file declares a class and, by importing its superclass, implicitly contains declarations for all inherited classes, from <code>NSObject</code> on down through its superclass. If the interface mentions classes not in this hierarchy, it must import them explicitly or declare them with the <code>@class</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_85"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_86"></a> directive:</p><div class="codesample"><table><tr><td scope="row"><pre>@class Rectangle, Circle;<span></span></pre></td></tr></table></div><p>This directive simply informs the compiler that “Rectangle” and “Circle” are class names. It doesn’t import their interface files.</p><p>An interface file mentions class names when it statically types instance variables, return values, and arguments. For example, this declaration</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setPrimaryColor:(NSColor *)aColor;<span></span></pre></td></tr></table></div><p>mentions the <code>NSColor</code> class.</p><p>Since declarations like this simply use the class name as a type and don’t depend on any details of the class interface (its methods and instance variables), the <code>@class</code> directive gives the compiler sufficient forewarning of what to expect. However, where the interface to a class is actually used (instances created, messages sent), the class interface must be imported. Typically, an interface file uses <code>@class</code> to declare classes, and the corresponding implementation file imports their interfaces (since it will need to create instances of those classes or send them messages).</p><p>The <code>@class</code> directive minimizes the amount of code seen by the compiler and linker, and is therefore the simplest way to give a forward declaration of a class name. Being simple, it avoids potential problems that may come with importing files that import still other files. For example, if one class declares a statically typed<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_87"></a> instance variable of another class, and their two interface files import each other, neither class may compile correctly.</p><a name="//apple_ref/doc/uid/TP30001163-CH12-87976" title="The Role of the Interface"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF125" title="The Role of the Interface"></a><h3>The Role of the Interface</h3><p>The purpose of the interface file is to declare the new class to other source modules (and to other programmers). It contains all the information they need to work with the class (programmers might also appreciate a little documentation).</p><ul class="spaceabove"><li class="li"><p>The interface file tells users how the class is connected into the inheritance hierarchy and what other classes—inherited or simply referred to somewhere in the class—are needed.</p></li><li class="li"><p>The interface file also lets the compiler know what instance variables an object contains, and tells programmers what variables subclasses inherit. Although instance variables are most naturally viewed as a matter of the implementation of a class rather than its interface, they must nevertheless be declared in the interface file. This is because the compiler must be aware of the structure of an object where it’s used, not just where it’s defined. As a programmer, however, you can generally ignore the instance variables of the classes you use, except when defining a subclass.</p></li><li class="li"><p>Finally, through its list of method declarations, the interface file lets other modules know what messages can be sent to the class object and instances of the class. Every method that can be used outside the class definition is declared in the interface file; methods that are internal to the class implementation can be omitted.<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_88"></a></p></li></ul><a name="//apple_ref/doc/uid/TP30001163-CH12-88010" title="Class Implementation"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF126" title="Class Implementation"></a><h2>Class Implementation</h2><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_89"></a><p><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_90"></a>The definition of a class is structured very much like its declaration. It begins with the <code>@implementation</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_91"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_92"></a> directive and ends with the <code>@end</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_93"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_94"></a> directive:</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation ClassName : ItsSuperclass<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    instance variable declarations<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>method definitions<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>However, every implementation file<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_95"></a> must import its own interface. For example, <code>Rectangle.m</code> imports <code>Rectangle.h</code>. Because the implementation doesn’t need to repeat any of the declarations it imports, it can safely omit:</p><ul class="ul"><li class="li"><p>The name of the superclass</p></li><li class="li"><p>The declarations of instance variables</p></li></ul><p>This simplifies the implementation<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_96"></a> and makes it mainly devoted to method definitions:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "ClassName.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation ClassName<span></span></pre></td></tr><tr><td scope="row"><pre>method definitions<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Methods<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_97"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_98"></a> for a class are defined, like C functions, within a pair of braces. Before the braces, they’re declared in the same manner as in the interface file, but without the semicolon. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)alloc<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isfilled<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setFilled:(BOOL)flag<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Methods that take a variable number of arguments handle them just as a function would:</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;stdarg.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- getGroup:group, ...<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    va_list ap;<span></span></pre></td></tr><tr><td scope="row"><pre>    va_start(ap, group);<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH12-88281" title="Referring to Instance Variables"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-BAJHEIFE" title="Referring to Instance Variables"></a><h3>Referring to Instance Variables</h3><p>By default, the definition of an instance method<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_99"></a> has all the instance variables<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_100"></a> of the object within its scope. It can refer to them simply by name. Although the compiler creates the equivalent of C structures to store instance variables, the exact nature of the structure is hidden. You don’t need either of the structure operators (<code>.</code> or <code>-></code>) to refer to an object’s data. For example, the following method definition refers to the receiver’s <code>filled</code> instance variable:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setFilled:(BOOL)flag<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    filled = flag;<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Neither the receiving object nor its <code>filled</code> instance variable is declared as an argument to this method, yet the instance variable falls within its scope. This simplification of method syntax is a significant shorthand in the writing of Objective-C code.</p><p>When the instance variable belongs to an object that’s not the receiver, the object’s type must be made explicit to the compiler through static typing<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_101"></a>. In referring to the instance variable of a statically typed object, the structure pointer operator (<code>-></code>) is used.</p><p>Suppose, for example, that the Sibling class declares a statically typed object, <code>twin</code>, as an instance variable:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Sibling : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Sibling *twin;<span></span></pre></td></tr><tr><td scope="row"><pre>    int gender;<span></span></pre></td></tr><tr><td scope="row"><pre>    struct features *appearance;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As long as the instance variables of the statically typed object are within the scope of the class (as they are here because <code>twin</code> is typed to the same class), a Sibling method can set them directly:</p><div class="codesample"><table><tr><td scope="row"><pre>- makeIdenticalTwin<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( !twin ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        twin = [[Sibling alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>        twin->gender = gender;<span></span></pre></td></tr><tr><td scope="row"><pre>        twin->appearance = appearance;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return twin;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH12-88468" title="The Scope of Instance Variables"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF127" title="The Scope of Instance Variables"></a><h3>The Scope of Instance Variables</h3><p><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_102"></a>Although they’re declared in the class interface, instance variables are more a matter of the way a class is implemented than of the way it’s used. An object’s interface lies in its methods, not in its internal data structures.</p><p>Often there’s a one-to-one correspondence between a method and an instance variable, as in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)isFilled<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return filled;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>But this need not be the case. Some methods might return information not stored in instance variables, and some instance variables might store information that an object is unwilling to reveal.</p><p>As a class is revised from time to time, the choice of instance variables may change, even though the methods it declares remain the same. As long as messages are the vehicle for interacting with instances of the class, these changes won’t really affect its interface.</p><p>To enforce the ability of an object to hide its data, the compiler limits the scope of instance variables—that is, limits their visibility within the program. But to provide flexibility, it also lets you explicitly set the scope at three different levels. Each level is marked by a compiler directive:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Directive</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p><code>@private</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_103"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_104"></a></p></td><td ><p>The instance variable<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_105"></a> is accessible only within the class that declares it.</p></td></tr><tr><td  scope="row"><p><code>@protected</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_106"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_107"></a></p></td><td ><p>The instance variable is accessible within the class that declares it and within classes that inherit it.</p></td></tr><tr><td  scope="row"><p><code>@public</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_108"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_109"></a></p></td><td ><p>The instance variable is accessible everywhere.</p></td></tr><tr><td  scope="row"><p><code>@package</code></p></td><td ><p>On 64-bit, an <code>@package</code> instance variable acts like <code>@public</code> inside the image that implements the class, but <code>@private</code> outside.</p><p>This is analogous to <code>private_extern</code> for variables and functions. Any code outside the class implementation’s image that tries to use the instance variable will get a link error. This is most useful for instance variables in framework classes, where <code>@private</code> may be too restrictive but <code>@protected</code> or <code>@public</code> too permissive.
</p></td></tr></table></div><p>This is illustrated in <span class="content_text">Figure 2-1</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH12-88582" title="Figure 2-1The scope of instance variables"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-CJBFHAIC" title="Figure 2-1The scope of instance variables"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>The scope of instance variables</p><img src = "../Art/scopeinstvariables.gif" alt = "" width="356" height="303"></div><br/><p>A directive applies to all the instance variables listed after it, up to the next directive or the end of the list. In the following example, the <code>age</code> and <code>evaluation</code> instance variables are private, <code>name</code>, <code>job</code>, and <code>wage</code> are protected, and <code>boss</code> is public.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Worker : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    char *name;<span></span></pre></td></tr><tr><td scope="row"><pre>@private<span></span></pre></td></tr><tr><td scope="row"><pre>    int age;<span></span></pre></td></tr><tr><td scope="row"><pre>    char *evaluation;<span></span></pre></td></tr><tr><td scope="row"><pre>@protected<span></span></pre></td></tr><tr><td scope="row"><pre>    id job;<span></span></pre></td></tr><tr><td scope="row"><pre>    float wage;<span></span></pre></td></tr><tr><td scope="row"><pre>@public<span></span></pre></td></tr><tr><td scope="row"><pre>    id boss;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>By default, all unmarked instance variables (like <code>name</code> above) are <code>@protected</code>.</p><p>All instance variables that a class declares, no matter how they’re marked, are within the scope of the class definition. For example, a class that declares a <code>job</code> instance variable, such as the Worker class shown above, can refer to it in a method definition:</p><div class="codesample"><table><tr><td scope="row"><pre>- promoteTo:newPosition<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id old = job;<span></span></pre></td></tr><tr><td scope="row"><pre>    job = newPosition;<span></span></pre></td></tr><tr><td scope="row"><pre>    return old;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Obviously, if a class couldn’t access its own instance variables, the instance variables would be of no use whatsoever.</p><p>Normally, a class also has access to the instance variables<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_110"></a> it inherits. The ability to refer to an instance variable is usually inherited along with the variable. It makes sense for classes to have their entire data structures within their scope, especially if you think of a class definition as merely an elaboration of the classes it inherits from. The <code>promoteTo:</code> method illustrated earlier could just as well have been defined in any class that inherits the <code>job</code> instance variable from the Worker class.</p><p>However, there are reasons why you might want to restrict inheriting classes from directly accessing an instance variable:</p><ul class="spaceabove"><li class="li"><p>Once a subclass accesses an inherited instance variable, the class that declares the variable is tied to that part of its implementation. In later versions, it can’t eliminate the variable or alter the role it plays without inadvertently breaking the subclass.</p></li><li class="li"><p>Moreover, if a subclass accesses an inherited instance variable and alters its value, it may inadvertently introduce bugs in the class that declares the variable, especially if the variable is involved in class-internal dependencies.</p></li></ul><p>To limit an instance variable’s scope to just the class that declares it, you must mark it <code>@private</code>. Instance variables marked <code>@private</code> are only available to subclasses by calling public accessor methods, if they exist.</p><p>At the other extreme, marking a variable <code>@public</code> makes it generally available, even outside of class definitions that inherit or declare the variable. Normally, to get information stored in an instance variable, other objects must send a message requesting it. However, a public instance variable can be accessed anywhere as if it were a field in a C structure. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>Worker *ceo = [[Worker alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>ceo->boss = nil;<span></span></pre></td></tr></table></div><p>Note that the object must be statically typed.</p><p>Marking instance variables <code>@public</code> defeats the ability of an object to hide its data. It runs counter to a fundamental principle of object-oriented programming—the encapsulation of data within objects where it’s protected from view and inadvertent error. Public instance variables should therefore be avoided except in extraordinary cases.<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_111"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_112"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_113"></a> </p><a name="//apple_ref/doc/uid/TP30001163-CH12-89660" title="Messages to self and super"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-BAJHDGAC" title="Messages to self and super"></a><h2>Messages to self and super</h2><p>Objective-C provides two terms that can be used within a method definition to refer to the object that performs the method—<code>self</code> and <code>super</code>.</p><p>Suppose, for example, that you define a <code>reposition</code> method that needs to change the coordinates of whatever object it acts on. It can invoke the <code>setOrigin::</code> method to make the change. All it needs to do is send a <code>setOrigin::</code> message to the same object that the <code>reposition</code> message itself was sent to. When you’re writing the reposition code, you can refer to that object as either <code>self</code> or <code>super</code>. The <code>reposition</code> method could read either:</p><div class="codesample"><table><tr><td scope="row"><pre>- reposition<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setOrigin:someX :someY];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>or:</p><div class="codesample"><table><tr><td scope="row"><pre>- reposition<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    [super setOrigin:someX :someY];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here, <code>self</code> and <code>super</code> both refer to the object receiving a <code>reposition</code> message, whatever object that may happen to be. The two terms are quite different, however. <code>self</code> is one of the hidden arguments that the messaging routine passes to every method; it’s a local variable that can be used freely within a method implementation, just as the names of instance variables can be. <code>super</code> is a term that substitutes for <code>self</code> only as the receiver in a message expression. As receivers, the two terms differ principally in how they affect the messaging process:</p><ul class="ul"><li class="li"><p><code>self</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_114"></a> searches for the method implementation in the usual manner, starting in the dispatch table of the receiving object’s class. In the example above, it would begin with the class of the object receiving the reposition message.</p></li><li class="li"><p><code>super</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_115"></a> starts the search for the method implementation in a very different place. It begins in the superclass of the class that defines the method where <code>super</code> appears. In the example above, it would begin with the superclass of the class where reposition is defined.</p></li></ul><p>Wherever <code>super</code> receives a message, the compiler substitutes another messaging routine for the <code>objc_msgSend</code> function. The substitute routine looks directly to the superclass of the defining class—that is, to the superclass of the class sending the message to <code>super</code>—rather than to the class of the object receiving the message.</p><a name="//apple_ref/doc/uid/TP30001163-CH12-89868" title="An Example"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF135" title="An Example"></a><h3>An Example</h3><p>The difference between <code>self</code> and <code>super</code> becomes clear in a hierarchy of three classes. Suppose, for example, that we create an object belonging to a class called Low. Low’s superclass is Mid; Mid’s superclass is High. All three classes define a method called <code>negotiate</code>, which they use for a variety of purposes. In addition, Mid defines an ambitious method called <code>makeLastingPeace</code>, which also has need of the <code>negotiate</code> method. This is illustrated in <span class="content_text">Figure 2-2</span>:</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH12-89905" title="Figure 2-2High, Mid, Low"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-CJBEEDHJ" title="Figure 2-2High, Mid, Low"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>High, Mid, Low</p><img src = "../Art/highmidlow.gif" alt = "" width="198" height="431"></div><br/><p>We now send a message to our Low object to perform the <code>makeLastingPeace</code> method, and <code>makeLastingPeace</code>, in turn, sends a <code>negotiate</code> message to the same Low object. If source code calls this object <code>self</code>,</p><div class="codesample"><table><tr><td scope="row"><pre>- makeLastingPeace<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self negotiate];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>the messaging routine finds the version of <code>negotiate</code> defined in Low, <code>self</code>’s class. However, if Mid’s source code calls this object <code>super</code>,</p><div class="codesample"><table><tr><td scope="row"><pre>- makeLastingPeace<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super negotiate];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>the messaging routine will find the version of <code>negotiate</code> defined in High. It ignores the receiving object’s class (Low) and skips to the superclass of Mid, since Mid is where <code>makeLastingPeace</code> is defined. Neither message finds Mid’s version of <code>negotiate</code>.</p><p>As this example illustrates, <code>super</code> provides a way to bypass a method that overrides another method. Here it enabled <code>makeLastingPeace</code> to avoid the Mid version of <code>negotiate</code> that redefined the original High version.</p><p>Not being able to reach Mid’s version of <code>negotiate</code> may seem like a flaw, but, under the circumstances, it’s right to avoid it:</p><ul class="spaceabove"><li class="li"><p> The author of the Low class intentionally overrode Mid’s version of <code>negotiate</code> so that instances of the Low class (and its subclasses) would invoke the redefined version of the method instead. The designer of Low didn’t want Low objects to perform the inherited method.</p></li><li class="li"><p> In sending the message to <code>super</code>, the author of Mid’s <code>makeLastingPeace</code> method intentionally skipped over Mid’s version of <code>negotiate</code> (and over any versions that might be defined in classes like Low that inherit from Mid) to perform the version defined in the High class. Mid’s designer wanted to use the High version of <code>negotiate</code> and no other.</p></li></ul><p>Mid’s version of <code>negotiate</code> could still be used, but it would take a direct message to a Mid instance to do it.</p><a name="//apple_ref/doc/uid/TP30001163-CH12-90109" title="Using super"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF136" title="Using super"></a><h3>Using super</h3><p>Messages to <code>super</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_116"></a> allow method implementations to be distributed over more than one class. You can override an existing method to modify or add to it, and still incorporate the original method in the modification:</p><div class="codesample"><table><tr><td scope="row"><pre>- negotiate<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    return [super negotiate];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For some tasks, each class in the inheritance hierarchy can implement a method that does part of the job and passes the message on to <code>super</code> for the rest. The <code>init</code> method, which initializes a newly allocated instance, is designed to work like this. Each <code>init</code> method has responsibility for initializing<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_117"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_118"></a> the instance variables defined in its class. But before doing so, it sends an <code>init</code> message to <code>super</code> to have the classes it inherits from initialize their instance variables. Each version of <code>init</code> follows this procedure, so classes initialize their instance variables in the order of inheritance:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)init<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super init]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Initializer methods have some additional constraints, and are described in more detail in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW1">“Allocating and Initializing Objects.”</a></span></p><p>It’s also possible to concentrate core functionality in one method defined in a superclass, and have subclasses incorporate the method through messages to <code>super</code>. For example, every class method that creates an instance must allocate storage for the new object and initialize its <code>isa</code> variable to the class structure. This is typically left to the <code>alloc</code> and <code>allocWithZone:</code> methods defined in the <code>NSObject</code> class. If another class overrides these methods (a rare case), it can still get the basic functionality by sending a message to <code>super</code>.</p><a name="//apple_ref/doc/uid/TP30001163-CH12-90247" title="Redefining self"></a><a name="//apple_ref/doc/uid/TP30001163-CH12-TPXREF137" title="Redefining self"></a><h3>Redefining self</h3><p><code>super</code> is simply a flag to the compiler telling it where to begin searching for the method to perform; it’s used only as the receiver of a message. But <code>self</code><a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_119"></a> is a variable name that can be used in any number of ways, even assigned a new value.</p><p>There’s a tendency to do just that in definitions of class methods. Class methods are often concerned not with the class object, but with instances of the class. For example, many class methods combine allocation and initialization of an instance, often setting up instance variable values at the same time. In such a method, it might be tempting to send messages to the newly allocated instance and to call the instance <code>self</code>, just as in an instance method. But that would be an error. <code>self</code> and <code>super</code> both refer to the receiving object—the object that gets a message telling it to perform the method. Inside an instance method, <code>self</code> refers to the instance; but inside a class method<a name="//apple_ref/doc/uid/TP30001163-CH12-DontLinkElementID_120"></a>, <code>self</code> refers to the class object. This is an example of what not to do:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (Rectangle *)rectangleOfColor:(NSColor *) color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self = [[Rectangle alloc] init]; // BAD<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setColor:color];<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>To avoid confusion, it’s usually better to use a variable other than <code>self</code> to refer to an instance inside a class method:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)rectangleOfColor:(NSColor *)color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id newInstance = [[Rectangle alloc] init]; // GOOD<span></span></pre></td></tr><tr><td scope="row"><pre>    [newInstance setColor:color];<span></span></pre></td></tr><tr><td scope="row"><pre>    return [newInstance autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In fact, rather than sending the <code>alloc</code> message to the class in a class method, it’s often better to send <code>alloc</code> to <code>self</code>. This way, if the class is subclassed, and the <code>rectangleOfColor:</code> message is received by a subclass, the instance returned will be the same type as the subclass (for example, the <code>array</code> method of <code>NSArray</code> is inherited by <code>NSMutableArray</code>).</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)rectangleOfColor:(NSColor *)color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id newInstance = [[self alloc] init]; // EXCELLENT<span></span></pre></td></tr><tr><td scope="row"><pre>    [newInstance setColor:color];<span></span></pre></td></tr><tr><td scope="row"><pre>    return [newInstance autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>See <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW1">“Allocating and Initializing Objects”</a></span> for more information about object allocation.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocObjectsClasses.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocAllocInit.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocDefiningClasses.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocDefiningClasses.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocDefiningClasses.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>