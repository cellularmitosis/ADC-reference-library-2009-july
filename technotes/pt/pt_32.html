<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PT32: Performance Tuning with Development Tools</title>                                       <meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="Apr 27, 1992 - May 1, 1992"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002686" title="Performance Tuning with Development Tools"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxTools-date.html">Tools</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/DeveloperTools/idxCompilersDebuggers-date.html" target="_blank">Tools > Compiling & Debugging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PT32</div>
<div id="pageheadsub">Performance Tuning with Development Tools</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">Hardware Issues</A><BR><BR><A HREF="#Section3">System Issues</A><BR><BR><A HREF="#Section4">System 7 Virtual Memory</A><BR><BR><A HREF="#Section5">Compiler Issues</A><BR><BR><A HREF="#Section6">C / C++ Compiler Issues</A><BR><BR><A HREF="#Section7">Pascal Compiler Issues</A><BR><BR><A HREF="#Section8">Linker Issues</A><BR><BR><A HREF="#Section9">C++ Code Issues</A><BR><BR><A HREF="#Section10">MacApp Code Issues</A><BR><BR><A HREF="#Section11">MPW Issues</A><BR><BR><A HREF="#Section12">Testing</A><BR><BR><A HREF="#Section13">Conclusion</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note is a collection of useful ideas and suggestions to help youdecrease the time required to compile and link under MPW. Some of the issuesare even relevant to any development tools running under the Macintoshenvironment. The Technote will also clarify what performance tunings work, andwhich are marginal or may not work at all.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[May 01 1992]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A> <h2>Introduction</h2><p>This Technical Note contains information that will help you improve bothcompilation and linking times, and also point out about performance tricks thatare marginal, or may not work at all. Most likely this information will beupdated and modified as we gain more knowledge of how to speed up compilationsand link stages. This Note is biased towards the <code>MPW</code> environment.However, there are many ideas that can be used with any other Macintoshdevelopment platforms. The issues are ordered from hardware- or system-relatedissues to specific MPW and MPW tool issues, and these are not listed in anyparticular order of efficiency.</p><p>Many of these ideas are benchmarked and the results are marked with a specialnote at the end of the paragraph . The equipment/environment consisted of:</p><ul type="disc">	<li>Macintosh 900 Quadra, 160Mb internal hard disk, 20Mb physical RAM memory, no VM  (unless stated)</li>	<li>System 7.0.1 + TuneUp</li>	<li>MPW 3.2 4Mb application heap, 256k file cache</li>	<li>No extensions loaded, no network</li>	<li>MacApp 3.0 Calc application source, C++ (when applicable) </li></ul><a name="Section2"></a><P><A HREF="#top">Back to top</A></p><h2>Hardware Issues </h2><b>Accelerator Cards</b><p>We at DTS have had mixed input about using CPU accelerator cards. In generalthey speed up number-crunching. However, they don't help with file I/Obottleneck situations. Also they can cause compatibility problems with thetools, so we strongly recommend taking out the card for testing if youencounter weird problems during compilation or linking.</p><p>Before you buy a card, contact the appropriate accelerator card tech supportgroup, and ask about the compatibility of their card with various Macintoshdevelopment systems. Try to borrow a card for a quick test to figure out ifbuying the card is justified or not and if it works with the particulardevelopment tools needed. Remember that accelerator cards based on NuBus(TM)can easily congest the NuBus bus (which has a 10 MB/sec limit on datatransfers). Any possible savings in CPU execution could be lost in the NuBustransfers.</p><b>SCSI I/O Cards and Hard Disk Access Times</b><p>File I/O is one of the known bottlenecks that affect MPW performance (however,it's not the only bottleneck). Faster NuBus SCSI cards (like SCSI-2 cards)should certainly improve the file I/O; how much depends on the file I/O accessfigures. Also, shop around for hard disks with fast access times.</p><a name="Section3"></a> <P><A HREF="#top">Back to top</A></p><h2>System Issues</h2><b>Background Processes</b><p>Every background process, including the Finder, takes CPU cycles that could beused for compilation and linking. Try to limit the background tasks on yourcompiling system. If possible turn off any unnecessary inits and drivers.</p><b>External Sources of Interrupts</b><p>You should be aware that the development machine connected to a network willreceive outside interrupts as part of the network protocol handling (as inAppleTalk), and this will also consume needed CPU cycles. For example, System 7Personal FileShare requires a lot of attention from the system itself. This isalso true of any other background communication protocol handling. The bestpossible case is a standalone development system. However, for practicalreasons (like accessing common volumes) a developer can seldom afford toconfigure a standalone environment. If possible, minimize the network access onthe development system.</P><P>If a server is connected to the system and is not used, the Finder stillattempts to keep its desktop in synch with the server. This consumes CPUcycles. If the server and the network are busy then the machine is stuckwaiting. If possible, always remove servers from the desktop when they are nolonger needed.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    [[Delta]] System in network + inits+ =          404s, no-network System =          379s, savings       6.25%.          + mail services,          4 servers on desktop,          1 application in memory</pre>	</TD></TR></TABLE></CENTER><b>File Cache</b><p>We suggest that you experiment with your particular system configuration, thereis no magic value which we could recommend. There's however a differencebetween System 6.0.x and 7.x. Large cache sizes in System 6 will not improvethe performance due to a bug, which is fixed in System 7. If your developmenttool is mostly in memory during the execution, many of the resources and datafiles may be cached in memory between the execution stages. Following is a testwhere we changed the cache size between 32k and 4096k while compiling the samesources. As shown we didn't directly find an optimal value, so the 96k value isa good approximation.</p><P align=center><img src="images/pt_32_001.gif" alt="Figure 1. cache size vs. compilation time." width=384 height=189></P><P align=center><b>Figure 1</b>.  cache size vs. compilation time</p><a name="Section4"></a> <P><A HREF="#top">Back to top</A></p><h2>System 7 Virtual Memory</h2><p>The use of virtual memory is recommended when you would like to have manydevelopment tools running at the same time. However, VM is much slower thanreal memory; it  constantly needs to read/write to the much slower hard disk.One exception is the IIci with its built-in video. IIci has a non-contiguousmemory map, and uses the MMU to map the logical addresses. The algorithms usedby the ROM are slower than the ones used by VM. However the access gates slowerif a page fault occurs.</p><p>Note also that 32-bit mode runs faster than 24-bit mode.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    [[Delta]] VM on+ =  481s, VM off =  400s, savings   16.8%.</pre>	</TD></TR></TABLE></CENTER> <P><A HREF="#top">Back to top</A></p> <a name="Section5"></a><h2>Compiler Issues</h2><b>Compiler Flags</b><p>Eliminate any compiler flags that are not necessary for the code compilation.For example, optimization flags take more CPU cycles, and in many cases thecode produced without optimization is OK for a quick syntax or functionalitytest. Read the manuals carefully; they should indicate which flags are defaultones. Note also that the MacApp has its own <code>Startup</code> file where manycompiler flags are defined.</p><p>The <code>-sym on/full</code> flag will trigger <code>.SYM</code> file informationgeneration, and this takes time. If possible avoid symbolics generation untilyou really need to debug.</p><b>Selected #include File Handling</b><p>A larger percent of a typical compile is spent reading the header files, soreading them only once for each source file compilation is a win. We aretalking about cases where various source files each want to include the sameheader file. The MPW C compiler has a special pragma called #pragma once, whichwill make sure that each source file with this statement at the top of the filewill be read in only once. However this will not work with other languages -like C++ - so the following guidelines are useful:</p><p>In your individual source files, bracket your C++ include files so that theyare not read more than once during a compilation of a source file:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/ / Utilities.cp#ifndef _UTILITIES_#include &quot;Utilities.h&quot;#endif _UTILITIES_</pre>	</TD></TR></TABLE></CENTER><p>Of course, you also need to put bracketing into your local include files sothat things don't go haywire if you do include the same file twice (note thatwe recommend using only one underline, because ANSI C has reserved the use oftwo underlines):</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>// Utilities.h#ifndef _UTILITIES_#define _UTILITIES_// definitions#endif _UTILITIES_</pre>	</TD></TR></TABLE></CENTER><p>One trick is to define a global <code>IncludeFiles.h</code> file, which containsall files needed for the other header files, and include it on demand insidethe other header files, using the <code>#ifndef </code>trick. A <code>#pragmaonce</code> statement placed first in a C header file provides the samefunctionality. However, we can't guarantee that the <code>#pragma once</code>statements in C++ code end up in the right places with the generated Ccode, so don't use this with C++.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    [[Delta]] No #include labels = 183s,          include labels = 174s, savings 6.45%.</pre>	</TD></TR></TABLE></CENTER> <P><A HREF="#top">Back to top</A></p> <a name="Section6"></a><h2>C / C++ Compiler Issues</h2><b>Load/Dump</b><p><code>load/dump</code> is described in the MPW C++ Release Notes. It provides thebiggest single performance improvement possible when using MPW C++. Use the<code>-load</code> and <code>-dump</code> flags instead of the MPW C <code>#pragmaload/dump</code> statements, because they work differently. <code>#pragma load</code>and<code> #pragma dump</code> placed directly in C++ may have Cfront generate codethat appears before the pragma and thus could cause the <code>load/dump</code> towork incorrectly.</P><P>MPW C also has this feature, implemented using #pragma load and #pragma dump -compile time savings are similar to those found in C++.  For more informationon how to use this feature, please refer to the MPW C 3.0 release notes, pages40-41.</p><h3>Tradeoffs Between Compiling Small and Large Files</h3><p>Each time CPlus is triggered, MPW will load in resources needed for thecompiler. This also happens when CPlus triggers the C compiler. In the case ofa compilation of 10 files, the C++ and C resources are loaded 10 times in arow.</p><p>There are cases where a huge file compilation is faster than compiling a numberof smaller files. The overall trick is to create dependencies (Makefiles) whereas few files as possible are recompiled when something changes.</p> <P><A HREF="#top">Back to top</A></p> <a name="Section7"></a><h2>Pascal Compiler Issues</h2><h3>Limit Symbol Table Generation</h3><p>The <code>-p</code> switch on the Pascal compiler is useful to determine where thecompiler is spending its time. For example, with MacApp the compiler shouldspend a lot of time inside the MacApp units and in the <code>PInterfaces</code>files when discarding predigested symbol resources on the interface files andreanalyzing the source.</p><p>The goal is to configure a standard set of interface files so that we canuse the precompiled symbol information. Changing the order of includes or<code>USES</code> statements could cause these resources to be rebuilt, takingextra time.</p><p>Here is a possible strategy to help you analyze the information from thecompiler and define strategies that will minimize the need for resources andmake the compilation faster:</p><ol type="1" start="1">	<li>ALL units should use <code>Types</code>, <code>QuickDraw</code>, <code>Packages</code>, <code>SANE</code>, and <code>Printing </code>(if needed).</li><LI>When additional units are required, <i>always </i> use units from the newer,smaller groupings: <code>Events</code>, <code>Controls</code>, <code>Desk</code>,<code>Windows</code>, <code>TextEdit</code>, <code>Dialogs</code>, <code>Fonts</code>,<code>Lists</code>, <code>Menus</code>, <code>Resources</code>,  <code>Scrap</code>, and<code>ToolUtils</code>  {instead of <code>ToolIntf</code>} <code>OSUtils</code>,<code>Files</code>, <code>Devices</code>, <code>DeskBus</code>, <code>DiskInit</code>,<code>Disks</code>, <code>Errors</code>, <code>Memory</code>, <code>OSEvents</code>,<code>Retrace</code>, <code>SegLoad</code>, <code>Serial</code>, <code>ShutDown</code>,<code>Slots</code>, <code>Sound</code>, <code>Start</code> and     <code>Timer</code> {instead of<code>OSIntf</code>} and <code>Script</code>, <code>Palettes</code>, <code>Picker</code>,<code>Perf</code>, <code>DisAsmLookup</code>, <code>AppleTalk.</code></li><li>Note that if you mix references to newer and older files it will take longer tocompile.</li><LI>Always use units in the same order. The Apple units set compile flags that<i>must</i> be identical the next time a unit is used or the compiler will notuse the symbolic resources.</li><LI>The MacApp units also set compile flags, so they should appear after the<code>MPW:Interfaces:PInterfaces</code> units and always in the same order.</li><LI>Keep your own units in a consistent order in each USES statement,especially if you use compiler variables in your source.</li><LI>Adjust your build scripts to build units in the same order  they arelisted in your USES statements.</li><LI>As you clean up the units, compile them in a full build with the <code>-p</code>compiler option to verify the results of your work. The output willindicate when the compiler uses the resources.</li></ol><p>If you clean up your files in the order in which the units are built, you willbegin to accumulate savings as you go along. However, don't expect to see atremendous difference until nearly all your USES statements have been cleanedup. When an uncleaned unit is compiled, the consistency of the symbol resourcesis spoiled and the compiler starts parsing resources again. Moreover, itleaves<i> </i> the units in this inconsistent state, so the next build mustbegin by rebuilding the resources in a consistent manner.</p><p>Once the cleanup is complete, your application should build at its optimumrate. If you are already pretty clean in your USES statements, you should begetting near optimal performance.</P><p>If you haven't already done so, consider switching to the 3.0/C-style separateinterfaces instead of using <code>OSIntf</code> or <code>ToolIntf</code>. Unless youuse almost all the files included by these old-style units, you should use thefiles as separate units, and get only what you need.</p><p>In all cases use <code>Types.p</code> instead of <code>MemTypes.p</code> and<code>Packages.p</code> instead of <code>PackIntf.p.</code></p><P>Try not to rely blindly on the auto-inclusion feature of the new interfaces. Ifyou let <code>Packages</code> include <code>Types</code> in one file and then use<code>Types</code> before using <code>Packages</code> in the next file, you'll get"symbol table churning": compile-time variables will be different and thesymbol table resources will have to be rebuilt each time.</p><p>Structure your <code>Make</code> file so that the units that come first in yourUSES clause get compiled before later units and the main program. The symboltable resources for a unit are always rebuilt when the unit is compiled. So ifyou change a unit and the main program, and your <code>Make</code> file builds themain program first, the symbol table resources for the unit will get built whenthe program is compiled, and again when the unit is compiled.</p><p>Use the <code>-p</code> option every now and then to see how things are going.Maybe you have compile-time variables that are causing symbol table churning,or maybe the resource fork of a file has become corrupt. Maybe you don't haveenough memory to create the symbol table resource (MacApp needs more than a 4MB partition, and use <code>-mf</code> with all tools if possible). Most of thepossible inefficiencies in reading or writing symbol table resources can bedisplayed only by use of the <code>-p</code> option</p><P>If you use MacApp and switch between versions often(<code>Debug</code>/<code>noDebug</code> and so on), you can put the directive <code>{$K$$Shell(ObjApp)} </code>before the first unit in your USES clauses. This willcreate the symbol table resources in files in the same directory as theprogram's object files. So as you switch from <code>:.Debug Files:</code> to<code>:.Non-Debug Files:</code> the right set of symbol table resources willalready be built.</p><h3>Precheck the Pascal Syntax</h3><p>You might precompile the code using Pasmat before the Pascal compiler is used,which could be helpful for quickly finding syntax errors in the code withoutthe penalty of running the full compiler. You might define a command key thatperforms the operation, as in the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    AddMenu MyMenu 'Pasmat {Active}.[[section]]/[[pi]]'        '[[partialdiff]]        (    Pasmat &lt;&quot;{Active}.[[section]]&quot; &gt;&quot;{TemporaryFile}&quot;        &gt;= &quot;{ErrorsFile}&quot; [[partialdiff]]        &amp;&amp; Catenate &quot;{TemporaryFile}&quot;        &gt; &quot;{Active}.[[section]]&quot; ;[[partialdiff]]            Delete -y &quot;{TemporaryFile}&quot; [[partialdiff]]        ) || Alert &lt;&quot;{ErrorsFile}&quot;'</pre>	</TD></TR></TABLE></CENTER><p>You might also use the <code>-c </code>flag with the Pascal compiler for syntaxchecking only.</p> <P><A HREF="#top">Back to top</A></p><a name="Section8"></a><h2>Linker Issues</h2><h3>Limit Symbol Table Generation</h3><p>In general it takes a lot of time for the linker to build the final .SYM file.Try to avoid building symbol files unless needed (like when stuck with aproblem in the source code). In many cases the <code>-msg full</code> (or<code>-Names</code> flag in MacApp) compiler flag for MacsBug name generation mightbe OK for a test of where the application crashes.</p><p>You might also create a limited set of SYMBOLIC (.SYM) information. Here's anexample from MacApp 3.0 of how this could be achieved (in the case of generalC++ code, just specify'<code>-sym on'</code> in the C++ compiler for thosefiles that you need for debugging). This technique will also save both RAM anddisk space.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>############################################################ L I B R A R Y   D E P E N D E N C I E S###########################################################&quot;{ObjApp}{LibName}&quot;[[florin]][[florin]] [[partialdiff]]   {LibObjs}   IF {MacAppLibrary} || {LibName} !~ /MacApp.lib/ # Special trick to keep   MacApp libraries from building   {MAEcho} {EchoOptions} &quot;Libbing:       {LibName}&quot;   SET XToolStartTime 'DATE -n'#  {MALib} [[partialdiff]]#  {LibOptions} [[partialdiff]]#  {OtherLibOptions} [[partialdiff]]#  {LibObjs} [[partialdiff]]#  -o &quot;{ObjApp}{LibName}&quot;   execute &quot;Skinny Lib&quot;      &lt;+++++++++ new script fileFile:  Skinny Lib   -----------------------------directory &quot;{malibraries}.nodebug names sym nosys7:&quot;delete -i macapp.liblib -mf -w -sym off -o macapp.nosym [[partialdiff]]   Geometry.cp.o PascalString.cp.o Toolbox.cp.o UAppleEvents.cp.o   UAssociation.cp.o [[partialdiff]]   UBusyCursor.cp.o UClipboardMgr.cp.o UCPlusTool.cp.o UDebug.a.o   UDebug.cp.o [[partialdiff]]   UDeskScrapView.cp.o UEditionDocument.cp.o UErrorMgr.cp.o   UFailure.a.o UFloatWindow.cp.o [[partialdiff]]   UGeometry.cp.o UGrabberTracker.cp.o UKeySelectionBehavior.cp.o   UMacAppGlobals.cp.o [[partialdiff]]   UMacAppUtilities.cp.o UMemory.a.o UMenuMgr.cp.o UMenuView.cp.o   UPascalTool.p.o [[partialdiff]]   UPatch.cp.o USection.cp.o USectionMgr.cp.o UStream.cp.o   USynchScroller.cp.o [[partialdiff]]   UProjFileHandler.cp.o UScroller.cp.o UTabTEView.a.o   UTabTEView.cp.o [[partialdiff]]   UTearOffMenuView.cp.o UTECommands.cp.o UTEView.cp.o   UTranscriptView.cp.o [[partialdiff]]   UDependencies.cp.o UDesignator.cp.o UTabBehaviors.cp.o#lib -mf -w -sym off,NoLabels,NoLines,NoVars -o        macapp.justTypes[[partialdiff]] lib -mf -w -sym off -omacapp.justTypes[[partialdiff]]   UCommand.cp.o UCommandHandler.cp.o MacAppTypes.cp.o UAdorners.cp.o   UBehavior.cp.o [[partialdiff]]   UDrawingEnvironment.cp.o UEvent.cp.o UFile.cp.o UFileHandler.cp.o    UMemory.cp.o [[partialdiff]]   UIterator.cp.o UPopup.cp.o UViewBehavior.cp.o UViewServer.cp.olib -mf -w -sym on -o macapp.lib macapp.nosymmacapp.justTypes[[partialdiff]]   UApplication.cp.o UControl.cp.o UDialog.cp.o UDialogBehavior.cp.o   UDocument.cp.o [[partialdiff]]   UEventHandler.cp.o UFailure.cp.o UFileBasedDocument.cp.o   UGridView.cp.o [[partialdiff]]   UList.cp.o UObject.cp.o UPascalObject.a.o UPascalObject.cp.o   UPrintHandler.cp.o [[partialdiff]]   UPrinting.cp.o UView.cp.o UWindow.cp.o</pre>	</TD></TR></TABLE></CENTER><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    [[Delta]] .SYM generated = 379 s, no .SYM</pre>	</TD></TR></TABLE></CENTER><h3>Use Libraries If Possible</h3><p>The linker will perform much faster if you link together library files (createdby the Lib tool)  than if you separately compile .o files. Consult the latestMPW documentation which describes various ways of using the Lib tool withprojects.</P><h3>CODE Resources</h3><p>If you have code resources that do not make any intersegment calls (such asstandalone code and <code>XCMD</code> style code resources), you can use the<code>Rez</code> tool to add these resources directly to the binary instead ofusing the link tool. This should save some time; how much depends on the actualproject.</p><h3>Global Data</h3><p>The link tool will build a complete image of the globals to be initialized. Ifthe global area is large, this might take a long time. Try to avoid extensiveand unneeded use of global data.</p><a name="Section9"></a> <P><A HREF="#top">Back to top</A></p><h2>C++ Code Issues</h2><h3>Smaller Files Compile Faster</h3><p>Split huge source and header files into smaller modules and create dependenciesin the Makefile that will trigger compilations only when a particular file haschanged. A known caveat with C++ is the <code>vtable</code> consistency. Sometimesthe vtables have to be created from scratch in order to synchronize the<code>vtable</code> information. If the compilation and linking phase has generateda binary, but when you are running the application it has problems, try torecompile most or maybe all sources for a quick test in order to see if theproblem has to do with vtables.</p><h3>Don't Include All Class Headers</h3><p>If possible place include statements with C++ classes internally used in the.cp file instead of in the header (.h) file. When developers are using aparticular header file, they don't need to include class headers that are notneeded, and this saves some time. In general try to avoid unnecessaryinclusions of classes.</p><h3>C++ Dump/Load</h3><p>One problem with compiling object-oriented programs has to do with the parsingof header files. Generally, 80% of the compile time is spent parsing headerfiles. However, most header files remain unchanged for long periods of timeduring the programming phase. So the header files are reread and reparsed, timeafter time.</p><p>C++ dump/load solves this problem by dumping the header file information to asingle file. During compilation of class methods, the compiler loads from thisdump file each time it needs the header file information. You can get even morespeed by placing all the dump and object files on a RAM disk.</p><p>To use dump/load you need to decide which header files are static and notsubject to change. For MacApp, the obvious choice is the MacApp class headerfiles. For other complex frameworks, consider only the most stable header filesfor the dump file. If you alter header files often, the compiler has to createa new dump file, and the dumping process takes a long time.</p><p>For more general C++ dump/load guidelines, please consult the MPW C++ ReleaseNotes.</p> <P><A HREF="#top">Back to top</A></p> <a name="Section10"></a><h2>MacApp Code Issues</h2><h3>Using Dump/Load With MacApp</h3><p><code>MABuild</code> has a flag called -<code>CPlusLoad</code>. When this is present, theC++ compiler dumps the MacApp header file information to a folder called<code>Load Files</code> inside the MPW folder. This happens during the firstcompile only. A dump file can take 1 to 2 MB of space, so check your disk spacebefore doing the dump. Also remember that if you have many release versions ofthe same header files that are dumped, you need to delete the earlier dumpfiles; otherwise you will encounter mysterious bugs.</p><p>Dump/load requires lots of heap space for the tools, so now is the time tostart using the <code>-mf</code> option with <code>CPlus</code>, <code>Link</code>, and<code>Lib</code>. Or increase the MPW application heap size--depending on the sizeof your sources, up to 4 MB or more. If the CFront tools don't have enoughmemory for the memory-consuming part of the parsing, error messages such as<i>"free store exhausted"</i> will be displayed.</p><p>MacApp has a special startup file in the MacApp folder where you can specifydefault settings. One of the variables defined in this file is<code>MABuildDefaults</code>:</p><p>Uncomment this line and restart MPW, or select and execute the command. Thenext time you build your MacApp application, <code>MABuild</code> willautomatically use the MacApp header files to create a dump file inside the'<code>MPW:Load Files</code>' folder. Note that this is now the default case withMacApp 3.0.</p><p>You can go one step further and specify that additional header files should bedumped. To do this, edit the <code>MacApp:Tools</code> file called <code>'Build Rulesand Dependencies.'</code> Here's an excerpt from that file:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre># Load/Dump files must be kept current for C++ too{CPlusLoadFiles}    [[florin]]    {MacAppCPlusIntf}    {MAEcho} {EchoOptions} &quot;C++ Load/Dump: UMacApp.h.dump&quot;    IF 'EXISTS {CPlusLoad}' != &quot;        Delete {CPlusLoad}        END    {MACPlus} [[partialdiff]]        {CPlusOptions} [[partialdiff]]        {OtherCPlusOptions} [[partialdiff]]        -i &quot;{SrcApp}&quot; [[partialdiff]]        -i &quot;{MACIncludes}&quot; [[partialdiff]]        &quot;{MACIncludes}UMacApp.h&quot; [[partialdiff]]        -mf [[partialdiff]]        # Any other files you want to include in the dump            could go here [[partialdiff]]</pre>	</TD></TR></TABLE></CENTER><p>If you're sure that you will repeatedly include certain additional header filesin the MacApp dump file, you can add them to this file. Any building blockheaders (<code>U~.h </code>files) that are likely to be stable are goodcandidates.</p><p>You can also define build rules for dump/load files in the MAMake file for eachMacApp project. This way you can have different dump/load definitions forvarious permutations of source code and header code combinations. Writing yourown MAMake dump rules gives you better control over what is to be dumped.Instead of generically dumping all MacApp header files, you can dump only thoseMacApp and application header files actually used-- you don't have to dump allthe MacApp header files as MacApp's default C++ dump does. This saves time anddisk space.</p><p>This works well for handling header files that are part of your own project aslong as you don't frequently change the header files, which triggers a costlydump operation. Here are some guidelines:</p><ul type="disc">	<li>You must create a header file dependency rule for the dump file if you want dependencies operating on the header file changes.</li>	<li> Use <code>{SrcApp}</code> prefixes for the application source code file names, and <code>{ObjApp}</code> prefixes for the application object code file names.</li>	<li>You will be overriding most of the basic building rules, so if you want the MPW shell to show what it is doing, add an <code>Echo</code> statement as in the original rules.</li></ul><p>The C++ Release Notes discuss in great detail how to build the dump file headerfile. Once again, the trick is to move all static header files to one singlefile, and call it "<code>MyAppDump.h</code>" or something similar. In all the otherheader files, include the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    #ifndef __MYAPPDUMP__    #include &quot;MyAppDump.h&quot;</pre>	</TD></TR></TABLE></CENTER><p>Do the same <code>ifndef</code> trick with the included header files in the dumpheader file, so that the compiler won't need to include the file many times.Build a rule for dumping the <code>MyAppDump.h </code>file, or do it by compilingthe header from the MPW command line.</p><p>Sometimes a header file is static; then suddenly you are tearing your objectframework apart in a frenzy, making incremental changes. A good way to supportthis would be to use multiple dump files, where sometimes you dump and loadfrom many files, but other times you load from only one dump file, allowing thecompiler to parse the header file that is subject to change. (This would befaster when header files are changing, because the dump phase takes a longtime.)</p><P>Alas, it's not likely that there will ever be support for multiple dump filesin MPW C++ because dump files contain structures that are hard to merge. Youcan achieve a similar functionality using flags inside the header files. Youcould instruct <code>MABuild</code> to dump your own header files in addition tothe basic header files. This is done with a programmer-defined MABuildoption:</p><p>This <code>qOwnDump</code> flag controls use of dump files within the header filesvia a simple <code>#ifdef qOwnDump</code> directive (see sample code in theSnippets collection(Developer CD, ETO CD, AppleLink, ftp.apple.com). Byusing this directive, you can exclude your header files from the dump phasewhile incrementally changing header files; when again working with methodimplementations, so that headers are static, you can again dump your headerfiles.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    [[Delta]] No dump files =  818 s, dump file+ =  660s, savings   19.3%.</pre>	</TD></TR></TABLE></CENTER> <P><A HREF="#top">Back to top</A></p><a name="Section11"></a><h2>MPW Issues</h2><h3>More RAM Memory</h3><p>More memory means more application heap space, and this means less segmentloading in cases where segments are purged out of memory in memory-tightsituations. If the MPW memory partition is big enough most tools could stay inthe MPW heap, and this improves the performance, but not much! Note that youdon't need to go overboard with the application heap space. The peak parts ofmemory use could be handled with the <code>-mf</code> <code>MultiFinder</code>temporary memory flag which is implemented with our compilers, linker, and<code>Lib</code> tools. For instance a 4Mb MPW partition is suitable for MacAppprogramming if the <code>-mf</code> flag is defined for the compilers linker andLib.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    [[Delta]] 4Mb heap =   379 s, 12Mb heap =  379 s, difference 0%.+</pre>	</TD></TR></TABLE></CENTER><h3>RAM Disks</h3><p>To avoid file I/O bottlenecks you might think about using a RAM disk. Thefollowing order is based on the list of the most important folders/files, andif you have more RAM disk space you could include more from this list until youhave most of the development environment and the sources on the RAM disk (themost extreme case). In some cases, like the first three examples, all you needto do is to redefine the exported value in an MPW startup file (the last one!),as in:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Set CPlusScratch &quot;RAMDisk:&quot;</pre>	</TD></TR></TABLE></CENTER><p>In other cases you need to copy the files/folders to the RAM disk, and add thepaths to the new folder in such a way that the MPW environment will look intothe particular folder first , as in:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Set Commands &quot;RAMDisk:Tools:,{Commands}&quot;</pre>	</TD></TR></TABLE></CENTER><p>Here's the recommended list:</p><p><code>{MATemporaries}         </code>temporary folder for files that MacApp MaBuildcreates</p><P><code>{CPlusScratch}</code>        temporary folder for files that MPW C++ creates</p><P><code>{MALoadFiles}</code>        MacApp dump/load files folder</p><P><code>MPW:Tools</code>            tools (like compilers) for faster load into memory</p><P><code>MPW:Scripts</code>            scripts, for faster load into memory</p><P><code>{Libraries}</code>            general MacOS libraries, for faster load</p><P><code>{CLibraries} or</code></p><P><code>{PLibraries}    </code>    general C/Pascal libraries for faster load</p><P><code>{MALibraries}</code>        MacApp libraries (.lib, .rsrc files)</p><P>. . . your own project files . . .</p><p>Any other possible additions are MPW and MacApp header files and the actual MPWshell itself, including any other development tools. However, these take a lotof space, so we are talking about a huge RAM disk. If you have a +50 MB RAMdisk, you might even place the whole MPW and MacApp folders on the RAM disk,which is the quickest way to get the benefits of such a large RAM disk.However, you then need a RAM disk utility which will save and restore thecontents if the system is shut down.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    [[Delta]] No RAM disk = 379 s, 4Mb RAM disk+ = 342 s, savings 9.8%.</pre>	</TD></TR></TABLE></CENTER> <P><A HREF="#top">Back to top</A></p> <a name="Section12"></a><h2>Testing</h2><p>The following MPW script is useful for testing purposes:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Echo -n &gt; &quot;{MPW}Dump&quot;                    # specify output                                  file/windowOpen &quot;{MPW}Dump&quot;for cases in 1 2 3 4 5                    # define how many tests    Echo &quot;Test Number &quot;{cases}    set StartTime 'Date -n'    set exit 0    MaBuild -debug -sym Calc  [[Sigma]][[Sigma]]        &quot;{MPW}Dump&quot;    # place whatever jobhere    delete -y *Debug~                    # clean up afterwards    set exit 1    set TimeNow 'Date -n'    set Elapsed 'Evaluate {TimeNow}-{StartTime}'    set Elapsed &quot;'Date -c {Elapsed} -t'&quot;    If &quot;{Elapsed}&quot; =~ /12:([0-9]+:[0-9]+)reg.1 [AP]M/       Set Elapsed &quot;0:{reg.1}&quot;    Else If &quot;{Elapsed}&quot; =~ /0*([0-9]+:[0-9]+:[0-9]+)reg.1 [AP]M/       Set Elapsed &quot;{reg.1}&quot;    End    Echo &quot;[[partialdiff]]t[[lozenge]] Build time: {Elapsed}&quot;</pre>	</TD></TR></TABLE></CENTER><a name="Section13"></a> <P><A HREF="#top">Back to top</A></p><h2>Conclusion</h2><p>The four most valuable performance improvements are:</p><ol type="1" start="1">	<li>RAM disk use (the more you could place on the RAM disk, the better performance)</li>	<li>Don't compile and link with the <code>-sym on</code> option unless needed</li>	<li>Use libraries</li>	<li>Avoid compiling/linking, use tools which will postpone unneeded compilation and linking</li></ol><P>Use common sense and consider whether a particular scheme will require moreresources and/or memory. Carefully follow Apple announcements about new toolsand development environments that might fix bugs that have caused slowerperformance, or brand-new tools that address performance issues.</p><a name="References"></a> <P><A HREF="#top">Back to top</A></p><h2>References</h2><P>   MPW Documentation</p><p>NuBus(TM) is a trademark of Texas Instruments.</p><h3>Acknowledgements</h3><P>Thanks to the following contributors (listed in a twisted order, where the sortalgorithm is an NP-complete problem): Jack Robson, Keith Rollin, LarryRosenstein, Bryan Stearns, Blue Meanies, Chris Knepper, Rich Norling, KarlGoiser, Pete Richardson, Greg Robbins, Jim Reekes, programmers on MacApp.Tech$,Jeff Sandvik.</p>         <a name=Downloads></A>                  <P><A HREF="#top">Back to top</A></p> <h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pt_32.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pt/pt_32.html%3Fid%3DDTS10002686-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pt/pt_32.html%3Fid%3DDTS10002686-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pt/pt_32.html%3Fid%3DDTS10002686-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>