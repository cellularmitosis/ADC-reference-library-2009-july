<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="Stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN2059: Using collection classes safely with multithreaded applications</title><meta name="keywords" content="threads, thread-safety, synchronization, collection, array, dictionary, set"><meta name="Description" content="Technical Note TN2059: This technote describes some problemsthat can occur when using mutable collection classes (arrays,dictionaries, and sets) in multithreaded applications, anddescribes an approach  to solving these problems, includingseveral implementations."><meta name="categories" content="Cocoa and Processes"><meta name="week-posted" content="Sep 9, 2002 - Sep 13, 2002"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003088" title="Using collection classes safely with multithreaded applications"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxProcessManagement-date.html">Process Management</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN2059</div>
<div id="pageheadsub">Using collection classes safely with multithreaded applications</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"> <A HREF="#Section1">Problems with shared data in threaded applications</A><BR><BR><A HREF="#Section2">Problems with collection classes in threaded applications</A><BR><BR><A HREF="#Section3">Example 1: A Faulty Application</A><BR><BR><A HREF="#Section4">Safeguarding shared objects</A><BR><BR><A HREF="#Section5">Example 2: A corrected application</A><BR><BR><A HREF="#Section6">Example 3: A category to simplify safety</A><BR><BR><A HREF="#Section7">Example 4: A subclass of NSMutableDictionary</A><BR><BR><A HREF="#Summary">Summary</A><BR><BR><A HREF="#References">References</A><BR>               <BR><A HREF="#Downloads">Downloadables</A></P> <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This technote describes some problems that can occur when using mutable collection classes (arrays, dictionaries, and sets) in multithreaded Cocoa applications, and describes some approaches to solving these problems, including several implementations.</p><p id="introtext">Multithreaded Core Foundation applications may involve the same concerns, since Cocoa and Core Foundation classes are "toll-free bridged." This note does not address Core Foundation collections explicitly, but most of the principles discussed here apply to Core Foundation as well. For more information on Core Foundation, see <a href="http://developer.apple.com/documentation/CoreFoundation/Overview/CFOverview/">Overview of Core Foundation</a> in the <a href="#References">References</a> section.</p><p id="introtext">This note doesn't cover general issues in threading. For an introduction to those, see the Reference section for a list of readings.</p>	     <!-- end_intro_text --><!-- begin_date --><h3 align=center>[Sep 10 2002]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content -->          <P><A NAME=Section1></A></P>                  <H2>Problems with shared data in threaded applications</H2>         <p>Whenever two threads share data, they must synchronize access to that data to avoid bugs that can arise when they both work with the data at the same time.</p><p>In most cases, a thread synchronizes by using a lock to prevent other threads from entering the same code at the same time. For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>NSLock *statisticsLock; // assume this object existsint statistics;    ...[statisticsLock lock];    // make sure no two threads...statistics += 1;    // ...update 'statistics' at the same time[statisticsLock unlock];    // release the lock</pre>	</TD></TR></TABLE></CENTER>                                                    <p>The use of <code>statisticsLock</code> above ensures that only one thread executes the "+=" operation at a time. Without this, two threads might try to update the same location at the same time, losing one thread's contribution to the statistics.</p>                  <P><A HREF="#top">Back to top</A></P>         <BR><BR>                  <P><A NAME=Section2></A></P>                  <H2>Problems with collection classes in threaded applications</H2>         <p>When your code works with a mutable dictionary or array, locking the object only during the time the code works with its contents may not prevent all bugs.</p><p>To see why, consider this code (all the code shown here uses dictionaries, but the same concerns apply to arrays and sets):</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    NSLock *dictionaryLock; // assume this object exists    NSDictionary *aDictionary; // assume this object exists    NSString *theName;        ...    [dictionaryLock lock];    theName = [aDictionary objectForKey: @"name"];    [dictionaryLock unlock];    NSLog (@"the name is '%@'", theName);</pre>	</TD></TR></TABLE></CENTER><p>This code protects access to the mutable dictionary; however, even if all other parts of the program use the same lock to avoid concurrent use of the dictionary, the code above can fail. Here's how:</p><p>When a mutable collection removes an object, it sends the object a <code>release</code> message. Keeping this in mind, consider the following sequence:</p><ol type="1" start="1">	<li><code>aDictionary</code> contains the name <code>@"Pat"</code> for the key <code>@"name"</code>, with a retain count of 1</li>	<li>thread "A" executes the code above: it locks, sends <code>objectForKey</code>:, and unlocks &mdash; the variable <code>theName</code> now has a value of <code>@"Pat"</code>, with a retain count of 1</li>	<li>thread "B" now locks the lock and updates the dictionary with:<BR><BR><center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>[aDictionary setObject: @"Sandy"  forKey: @"name"];</pre>	</TD></TR></TABLE></center><p>The dictionary sends <code>release</code> to the old value for this key, the string @"Pat". Since the retain count was 1 to start, this release drops the count to zero, and the string <code>@"Pat"</code> gets deallocated.</p></li>	<li>thread "A" now tries to use its variable <code>theName</code> in the <code>NSLog(...)</code> invocation, but the variable refers to the string <code>@"Pat"</code> which has been deallocated, leading to a crash or other random results.</li></ol><p>The above sequence typifies the subtlety of using collection classes in threaded applications, but is not the only concern you need to keep in mind. Let's briefly consider a second example.</p><p>Suppose your code adds an object to a dictionary. Since the dictionary retains its values, the code releases the object after adding it. The code looks like this:</p><center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>NSString *theName; // assume this exists    ...[aDictionaryLock lock];[aDictionary setObject: theName  forKey: KEY];[theName release]; // since dictionary retains it, we don't need to[aDictionaryLock unlock];NSLog (@"the name is '%@'", theName);</pre>	</TD></TR></TABLE></center>	<p>The risk here resembles the risk in the previous code: Once the code unlocks, another thread may change the dictionary, releasing the value. Again, <code>theName</code> refers to a value that can get deallocated in the short period between unlocking and trying to use it in the <code>NSLog(...)</code>.</p><p>The same concerns apply to objects stored in arrays and sets, not just dictionaries: If thread B removes from an array or set an object to which thread A holds a pointer, that object may not remain valid during the scope in which thread A plans to use it.</p><p>To sum up:</p><ul type="disc">	<li>When multiple threads share a collection object, they need to synchronize access to that collection.</li>	<li>Collection objects send release to objects as they remove (or replace) them.</li>	<li>After one thread adds an object to a collection, or gets it from a collection, a second thread may cause that object to become invalid.</li>	<li>Thus, when multiple threads share a collection object, they also share all values contained in the object, even when one thread holds a reference to the value.</li></ul><P><A HREF="#top">Back to top</A></P><BR><BR><a name="Section3"></a><h2>Example 1: A faulty application</h2><p>The following source code illustrates the risks of sharing collections across threads. Even though it uses a lock to prevent simultaneous access to a mutable dictionary, it still crashes consistently.</p>                  <center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#import &lt;Foundation/Foundation.h&gt;static NSMutableDictionary    *aDictionary = nil;static NSLock                *aDictionaryLock = nil;@implementation NSMutableDictionary (Churning)#define KEY        @"key"- (void) churnContents;{    unsigned long    i;    for (i = 0; ; i++)    {        NSAutoreleasePool    *pool;        pool = [[NSAutoreleasePool alloc] init];        [aDictionaryLock lock];        [self setObject: [NSString stringWithFormat: @"%d", i]  forKey: KEY];        [aDictionaryLock unlock];        [pool release];    }}@end#define COUNT    10000static void doGets (void){    long    i;    for (i = 0; i &lt; COUNT; i++)    {        NSObject    *anObject;        //    Get the dictionary's value, and then try to message the value.        [aDictionaryLock lock];        anObject = [aDictionary objectForKey: KEY];        [aDictionaryLock unlock];        [anObject description];    }}static void doSets (void){    long    i;    for (i = 0; i &lt; COUNT; i++)    {        NSObject    *anObject;        anObject = [[NSObject alloc] init];        [aDictionaryLock lock];        [aDictionary setObject: anObject  forKey: KEY];        [anObject release];        [aDictionaryLock unlock];        [anObject description];    }}int main (){    SEL        threadSelector;    [[NSAutoreleasePool alloc] init];    threadSelector = @selector(churnContents);    aDictionary = [NSMutableDictionary dictionary];    aDictionaryLock = [[NSLock alloc] init];    //    Start the dictionary "churning", repeatedly replacing the    //    sole value with a new one under the same key.    [NSThread detachNewThreadSelector: threadSelector                toTarget: aDictionary                withObject: nil];#if 1 // because this crashes, you can turn it off to show that doSets() also crashes    doGets();#endif    doSets();    return 0;}</pre></td></tr><TR>	<td align="left"><P><B>Listing 1</B>. main1.m (available in the <a href="#Downloads">Downloads</a> section)</P>	</TD></TR></TABLE></CENTER>	<p>Bugs in multithreaded applications may appear only sporadically. So that you don't have to run it repeatedly to see the problem, this application spawns a thread that sends the <code>churnContents</code> message to a mutable dictionary. This method repeatedly replaces one value in the dictionary with a sequence of objects.</p><p>It includes two functions <code>doGets()</code> and <code>doSets()</code>, either of which will crash the application &mdash; you can comment out the call to the first function to see the other one crash. The <code>doGets()</code> function repeatedly gets a value from the dictionary and sends it a description message, eventually causing a crash.</p><p>The <code>doSets()</code> function puts a value into a dictionary, releases the value on the assumption that the dictionary will retain it, and similarly risks a crash by sending <code>description</code> to the object. (The choice of <code>description</code> has no significance; any method would do the same thing.)</p><P><A HREF="#top">Back to top</A></P><BR><BR>         <P><A NAME=Section4></A></P><H2>Safeguarding shared objects</H2>         <p>How can code safely work with objects it gets from a collection or stores in a collection? One approach is to send the object a <code>retain</code> message and later &mdash; when you're done using it &mdash; send it a balancing <code>release</code> message. The net effect of these two actions leaves the object unchanged, but during the interval between retaining and releasing your code lays claim to the object, preventing it from getting deallocated by other threads.</p><p>The problem with this approach is that you have to remember to send the <code>release</code> message, or else the object may never get deallocated, and "leak." Instead of waiting until you're done and sending <code>release</code>, you can immediately send it an <code>autorelease</code> message, which guarantees that the object will get released when the current autorelease pool gets deallocated.</p><p>Think of retain-and-release as asking someone to lend you a dollar and you promising to pay them back. Think of retain-and-<b>autorelease</b> as asking someone to lend you a dollar and them promising to make you pay it back. The latter approach is more conservative, in that it ensures your books stay balanced. (Keep in mind that autoreleasing takes more time and space than releasing, though.)</p><p>To make the code above safe, you need to add one line, noted in <b>boldface</b> below, to the code given before Example 1:</p><center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>NSLock *dictionaryLock; // assume this object existsNSDictionary *aDictionary; // assume this object existsNSString *theName;    ...[dictionaryLock lock];theName = [aDictionary objectForKey: @"name"];<b>[[theName retain] autorelease]; // keep object around for now</b>[dictionaryLock unlock];NSLog (@"the name is '%@'", theName);</pre>	</TD></TR></TABLE></center><p>The combined <code>retain</code> and <code>autorelease</code> may look like it has no effect, but the <code>retain</code> takes effect immediately, while the <code>autorelease</code> undoes the <code>retain</code> later. In the end, the two messages cancel out, but the <code>retain</code> keeps the object from getting deallocated while your code is using it.</p><P><A HREF="#top">Back to top</A></P><BR><BR><a name="Section5"></a><h2>Example 2: A corrected application</h2>                  <center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#import &lt;Foundation/Foundation.h&gt;static NSMutableDictionary    *aDictionary = nil;static NSLock                *aDictionaryLock = nil;@implementation NSMutableDictionary (Churning)#define KEY        @"key"- (void) churnContents;{    unsigned long    i;    for (i = 0; ; i++)    {        NSAutoreleasePool    *pool;        pool = [[NSAutoreleasePool alloc] init];        [aDictionaryLock lock];        [self setObject: [NSString stringWithFormat: @"%d", i]  forKey: KEY];        [aDictionaryLock unlock];        [pool release];    }}@end#define COUNT    10000static void doGets (void){    long    i;    for (i = 0; i &lt; COUNT; i++)    {        NSObject    *anObject;        //    Get the dictionary's value, and then try to message the value.        [aDictionaryLock lock];        anObject = [aDictionary objectForKey: KEY];        [[anObject retain] autorelease];        [aDictionaryLock unlock];        [anObject description];    }}static void doSets (void){    long    i;    for (i = 0; i &lt; COUNT; i++)    {        NSObject    *anObject;        anObject = [[NSObject alloc] init];        [aDictionaryLock lock];        [aDictionary setObject: anObject  forKey: KEY];        [anObject autorelease];        [aDictionaryLock unlock];        [anObject description];    }}int main (){    SEL        threadSelector;    [[NSAutoreleasePool alloc] init];    threadSelector = @selector(churnContents);    aDictionary = [NSMutableDictionary dictionary];    aDictionaryLock = [[NSLock alloc] init];    //    Start the dictionary "churning", repeatedly replacing the    //    sole value with a new one under the same key.    [NSThread detachNewThreadSelector: threadSelector                toTarget: aDictionary                withObject: nil];    doGets();    doSets();    return 0;}</pre></td></tr><TR>	<td align="left"><P><B>Listing 2</B>. main2.m (available in the <a href="#Downloads">Downloads</a> section) The above source code changes only a couple of lines from the previous example, but no longer crashes.</P>	</TD></TR></TABLE></CENTER><p>In this version the <code>doGets()</code> and <code>doSets()</code> functions add or change code to protect themselves. The <code>doGets()</code> function temporarily retains the object it gets from the dictionary, then balances that retention with an autorelease. The "sets" function changes its <code>release</code> to an <code>autorelease</code>.</p><p>Notice that the thread that "churns" the dictionary has the same code as before. It doesn't retrieve an object from the dictionary, and it doesn't use the value it stores in the dictionary.</p><p>Why not put the burden on this thread to safeguard the data? Why not have it retain-and-autorelease the object it's about to remove? The answer lies in the fact that each thread has its own autorelease pool. If the "churning" thread sends retain-then-autorelease to the object, that autorelease will take effect when the churning thread frees <b>its</b> autorelease pool &mdash; that might happen while another thread is still using it.</p><p>To sum up:</p><ul type="disc">	<li>Retain-and-release works to temporarily prevent an object from getting deallocated, but you must make sure that <code>release</code> gets sent.</li>	<li>Retain-and-<b>auto</b>release works better, because the autorelease pool remembers to send the <code>release</code> for you.</li>	<li>The thread that wants to protect the object must do the autorelease; other threads might wind up releasing the object at the wrong time.</li></ul><P><A HREF="#top">Back to top</A></P><BR><BR><a name="Section6"></a><h2>Example 3: A category to simplify safety</h2><p>The above example works, but each piece of code that uses the dictionary has to perform the same steps to use it safely. To make it easy for developers to write safe code, you can encapsulate the functionality for them. One way to do this is to add a category to <code>NSMutableDictionary</code>, adding methods that do most of the work for you.</p><p>The three methods are:</p><center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>- (id) threadSafeObjectForKey: (id) aKey  usingLock: (NSLock *) aLock;- (void) threadSafeRemoveObjectForKey: (id) aKey  usingLock: (NSLock *) aLock;- (void) threadSafeSetObject: (id) anObject            forKey: (id) aKey  usingLock: (NSLock *) aLock;</pre>	</TD></TR></TABLE></center>	<p>For example, if your old code was:</p><center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    [aDictionaryLock lock];    anObject = [aDictionary objectForKey: KEY];    [[anObject retain] autorelease];    [aDictionaryLock unlock];</pre>	</TD></TR></TABLE></center>        <p>After adding the category, you can change this to one statement:</p><center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>anObject = [aDictionary threadSafeObjectForKey: KEY        usingLock: aDictionaryLock];</pre>	</TD></TR></TABLE></center>       <p>The following source code includes the interface declaration and the implementation for this category, along with the revised application code. (You'll usually put a category's interface in its own .h file and implementation in its own .m file. This example puts everything in a single file for conciseness.)</p>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#import &lt;Foundation/Foundation.h&gt;////////////////////////////////////////////////////////////////////    NSMutableDictionary CATEGORY FOR THREAD-SAFETY////////////////////////////////////////////////////////////////@interface NSMutableDictionary (ThreadSafety)- (id) threadSafeObjectForKey: (id) aKey    usingLock: (NSLock *) aLock;- (void) threadSafeRemoveObjectForKey: (id) aKey    usingLock: (NSLock *) aLock;- (void) threadSafeSetObject: (id) anObject    forKey: (id) aKey    usingLock: (NSLock *) aLock;@end@implementation NSMutableDictionary (ThreadSafety)- (id) threadSafeObjectForKey: (id) aKey    usingLock: (NSLock *) aLock;{    id    result;    [aLock lock];    result = [self objectForKey: aKey];    [[result retain] autorelease];    [aLock unlock];    return result;}- (void) threadSafeRemoveObjectForKey: (id) aKey    usingLock: (NSLock *) aLock;{    [aLock lock];    [self removeObjectForKey: aKey];    [aLock unlock];}- (void) threadSafeSetObject: (id) anObject    forKey: (id) aKey    usingLock: (NSLock *) aLock;{    [aLock lock];    [[anObject retain] autorelease];    [self setObject: anObject  forKey: aKey];    [aLock unlock];}@end////////////////////////////////////////////////////////////////////    TEST PROGRAM////////////////////////////////////////////////////////////////static NSMutableDictionary    *aDictionary = nil;static NSLock                *aDictionaryLock = nil;@implementation NSMutableDictionary (Churning)#define KEY        @"key"- (void) churnContents;{    unsigned long    i;    for (i = 0; ; i++)    {        NSAutoreleasePool    *pool;        pool = [[NSAutoreleasePool alloc] init];        [self threadSafeSetObject: [NSString stringWithFormat: @"%d", i]            forKey: KEY  usingLock: aDictionaryLock];        [pool release];    }}@end#define COUNT    10000static void doGets (void){    long    i;    for (i = 0; i &lt; COUNT; i++)        //    Get the dictionary's value, and then try to message the value.        [[aDictionary threadSafeObjectForKey: KEY        usingLock: aDictionaryLock] description];}static void doSets (void){    long    i;    for (i = 0; i &lt; COUNT; i++)    {        NSObject    *anObject;        anObject = [[NSObject alloc] init];        [aDictionary threadSafeSetObject: anObject            forKey: KEY            usingLock: aDictionaryLock];        [anObject release];        [anObject description];    }}int main (){    SEL        threadSelector;    [[NSAutoreleasePool alloc] init];    threadSelector = @selector(churnContents);    aDictionary = [NSMutableDictionary dictionary];    aDictionaryLock = [[NSLock alloc] init];    //    Start the dictionary "churning", repeatedly replacing the    //    sole value with a new one under the same key.    [NSThread detachNewThreadSelector: threadSelector                toTarget: aDictionary                withObject: nil];    doGets();    doSets();    return 0;}</pre>	</TD></TR><TR>	<td align="left"><P><B>Listing 3</B>. main3.m (available in the <a href="#Downloads">Downloads</a> section)</P>	</TD></TR></TABLE></CENTER><P>These methods require you to specify the lock that controls the dictionary. You'd usually choose to use one <code>NSLock</code> instance for each dictionary.</p><p>A variation on the above approach is to have the category supply simpler methods, such as <code>threadSafeObjectForKey</code>:, which supply the lock themselves. This technique has problems because either it uses a single lock for all dictionaries or it has a data structure mapping each dictionary to its respective lock. The data structure will need its own lock, so either way a single lock can become a bottleneck for all threads.</p><p>To easily associate each dictionary with a lock, you can subclass the dictionary class. The next example describes in detail how to do this.</p><P><A HREF="#top">Back to top</A></P><BR><BR><a name="Section7"></a><h2>Example 4: A subclass of NSMutableDictionary</h2><p>Instead of adding methods like <code>threadSafeObjectForKey</code>: in a category, and requiring all developers working on an application to use that method, another technique is to create a subclass of <code>NSMutableDictionary</code>, overriding methods like <code>objectForKey:</code> and replacing them with thread-safe implementations.</p><p><code>NSMutableDictionary</code> is part of the <code>NSDictionary</code> class cluster. Subclassing within a class cluster is somewhat complicated, and you shouldn't do it without good reason. For an introduction to both class clusters and ways to subclass them, see the primer on <a href="http://developer.apple.com/documentation/Cocoa/TasksAndConcepts/ProgrammingTopics/Foundation/Concepts/ClassClusters.html">Class Clusters.</a></p><p>The implementation below uses the "composite object" technique described in the class cluster documentation. It defines an object which includes both a real mutable dictionary and a lock. It also implements each of the "primitive" methods in <code>NSMutableDictionary</code>.</p>                                                    <center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#import &lt;Foundation/Foundation.h&gt;////////////////////////////////////////////////////////////////////    NSMutableDictionary SUBCLASS////////////////////////////////////////////////////////////////@interface ThreadSafeMutableDictionary : NSMutableDictionary{    NSMutableDictionary    *realDictionary;    NSLock                *lock;}@end@implementation ThreadSafeMutableDictionary : NSMutableDictionary//  Primitive methods in NSDictionary- (unsigned) count;{    //  I believe we don't need to lock for this.    return [realDictionary count];}- (NSEnumerator *) keyEnumerator;{    NSEnumerator    *result;    //    It's not clear whether we need to lock for this operation,    //    but let's be careful.    [lock lock];    result = [realDictionary keyEnumerator];    [lock unlock];    return result;}- (id) objectForKey: (id) aKey;{    id    result;    [lock lock];    result = [realDictionary objectForKey: aKey];    //    Before unlocking, make sure this object doesn't get    //  deallocated until the autorelease pool is released.    [[result retain] autorelease];    [lock unlock];    return result;}//  Primitive methods in NSMutableDictionary- (void) removeObjectForKey: (id) aKey;{    //    While this method itself may not run into trouble, respect the    //  lock so we don't trip up other threads.    [lock lock];    [realDictionary removeObjectForKey: aKey];    [lock unlock];}- (void) setObject: (id) anObject forKey: (id) aKey;{    //    Putting the object into the dictionary puts it at risk for being    //  released by another thread, so protect it.    [[anObject retain] autorelease];    //    Respect the lock, because setting the object may release    // its predecessor.    [lock lock];    [realDictionary setObject: anObject  forKey: aKey];    [lock unlock];}//    This isn't labeled as primitive, but let's optimize it.- (id) initWithCapacity: (unsigned) numItems;{    self = [self init];    if (self != nil)        realDictionary = [[NSMutableDictionary alloc] initWithCapacity: numItems];    return self;}//    Overrides from NSObject- (id) init;{    self = [super init];    if (self != nil)        lock = [[NSLock alloc] init];    return self;}- (void) dealloc;{    [realDictionary release];    [lock release];    [super dealloc];}@end////////////////////////////////////////////////////////////////////    TEST PROGRAM////////////////////////////////////////////////////////////////static NSMutableDictionary    *aDictionary = nil;@implementation NSMutableDictionary (Churning)#define KEY        @"key"- (void) churnContents;{    unsigned long    i;    for (i = 0; ; i++)    {        NSAutoreleasePool    *pool;        pool = [[NSAutoreleasePool alloc] init];        [self setObject: [NSString stringWithFormat: @"%d", i]  forKey: KEY];        [pool release];    }}@end#define COUNT    10000static void doGets (void){    long    i;    for (i = 0; i &lt; COUNT; i++)        //    Get the dictionary's value, and then try to message the value.        [[aDictionary objectForKey: KEY] description];}static void doSets (void){    long    i;    for (i = 0; i &lt; COUNT; i++)    {        NSObject    *anObject;        anObject = [[NSObject alloc] init];        [aDictionary setObject: anObject  forKey: KEY];        [anObject release];        [anObject description];    }}int main (){    SEL        threadSelector;    [[NSAutoreleasePool alloc] init];    threadSelector = @selector(churnContents);    aDictionary = [ThreadSafeMutableDictionary dictionary];    //    Start the dictionary "churning", repeatedly replacing the    //    sole value with a new one under the same key.    [NSThread detachNewThreadSelector: threadSelector                toTarget: aDictionary                withObject: nil];    doGets();    doSets();    return 0;}</pre>	</TD></TR><TR>	<td align="left"><P><B>Listing 4</B>. main4.m (available in the <a href="#Downloads">Downloads</a> section)</P>	</TD></TR></TABLE></CENTER><p>	A subclass like this entails several concerns:</p><ul type="disc">	<li>the time to perform locking may hurt performance</li>	<li>on top of that, any subclass may not be as fast as Apple's "concrete" implementation, which is typically highly optimized</li>	<li>each object is implemented with two underlying objects, using more memory</li>	<li>you need to make sure that the dictionary is instantiated from the subclass &mdash; notice that in this final version, the dictionary gets created with this code: </li></ul><center><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    aDictionary = [ThreadSafeMutableDictionary dictionary];</pre>	</TD></TR></TABLE></center><p>To sum up:</p><ul type="disc">	<li>Categories provide a simple way to encapsulate new functionality on existing classes.</li>	<li>Subclassing provides another way to add functionality, but by overriding methods instead of adding them.</li>	<li>Subclassing within a class cluster requires special attention.</li></ul><P><A HREF="#top">Back to top</A></P><BR><BR><a name="Summary"></a><h2>Summary</h2><p>We've looked at four ways to fix thread-safety problems with <code>NSMutableDictionary</code> instances (similar approaches would work for <code>NSMutableArray</code> and <code>NSMutableSet</code>). Each of them had their own advantages and disadvantages. Keep the disadvantages in mind, and use these classes only when operating in a multi-threaded environment. To review, the advantages and disadvantages are:</p><p><a href="#Section3">Example 1</a> uses a lock to mediate access to the mutable dictionary<BR>	<b>Advantage</b>: Clear, simple code<BR>	<b>Disadvantage</b>: Like... duh? It crashes!</p><p><a href="#Section5">Example 2</a> uses <code>retain</code> and <code>autorelease</code> to protect the object<BR>	<b>Advantage</b>: Doesn't crash<BR>	<b>Disadvantages</b>: Client code must follow certain rules to be safe<BR>		autoreleasing may cost extra time and, temporarily, extra space</p><p><a href="#Section6">Example 3</a> adds safe methods, encapsulated in a category<BR>	<b>Advantages</b>: Doesn't crash; client code is simpler<BR>	<b>Disadvantages</b>: Client code must use new methods and supply a lock object<BR>              autoreleasing may cost extra time and, temporarily, extra space</p><p><a href="#Section7">Example 4</a> makes <code>NSMutableDictionary</code> methods safe with a subclass<BR>	<b>Advantages</b>: Doesn't crash; client code needs no changes<BR>	<b>Disadvantages</b>: Dictionary must get instantiated from new class<BR>              performance may not match Apple's implementation<BR>              autoreleasing may cost extra time and, temporarily, extra space</p><P><A HREF="#top">Back to top</A></P><BR><BR>         <P><A NAME=References></A></P>                  <H2>References</H2>                  <p><a href="http://developer.apple.com/documentation/Cocoa/TasksAndConcepts/ProgrammingTopics/Multithreading/index.html">Overview of Programming Topic: Multithreading</a></p><p><a href="http://developer.apple.com/documentation/Cocoa/TasksAndConcepts/ProgrammingTopics/Multithreading/Concepts/safety.html">Thread Safety</a></p>	     <p><a href="http://developer.apple.com/documentation/Cocoa/TasksAndConcepts/ProgrammingTopics/Multithreading/Tasks/foundation.html">Using Foundation from Multiple Threads</a></P><p><a href="http://developer.apple.com/documentation/CoreFoundation/Overview/CFOverview/">Overview of Core Foundation</a></p>                  <P><A HREF="#top">Back to top</A></P>         <BR><BR>                                   <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left><P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left"><P>Acrobat version of this Note (80K)</P>               </TD>               <td width=60 align=left><P><A HREF="pdf/tn2059.pdf">Download</A></P>               </TD>            </TR>            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/redbook.gif" width=20 height=20 align=bottom alt="Redbook gif"></P>               </TD>               <td align="left">                  <P>Binhexed Sample Code (8K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="downloads/tn2059.hqx">Download</A></P>               </TD>            </TR>         </TABLE>         <BR>                           <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn2002/tn2059.html%3Fid%3DDTS10003088-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn2002/tn2059.html%3Fid%3DDTS10003088-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn2002/tn2059.html%3Fid%3DDTS10003088-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>