/*	File:		TGraphicCollection.h	Contains:	See TGraphicCollection.cp for description and the list of changes.	Written by: Timothy Carroll		Copyright:	Copyright © 1996-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/2/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#ifndef _TGRAPHICCOLLECTION_#define _TGRAPHICCOLLECTION_#pragma once#include "TGraphic.h"#if PRAGMA_STRUCT_ALIGN#pragma options align=power#endifclass TGraphicCollection{	public:	/*****************************************************************************Static Creator and Reference CountingThese are the routines that handle the actual creation of the objects, alongwith reference counting and so on.  You don't dispose of an object directly,you just dispose of your reference.  It will automatically be chucked outwhen all references are deleted.A TGraphicCollection is defined by a resource of type 'SptA' or sprite array.*****************************************************************************/	static	TGraphicCollection 	*NewCollection (SInt16 resID);	void	AddReference (void);	void	DisposeReference (void);			/*****************************************************************************Locking and Unlocking	You are never required to lock a collection, but you can choose to lock themdown high in memory to ensure that they don't move around when other, criticalmemory allocations are being done.*****************************************************************************/	OSStatus	LockCollection (void);	OSStatus	UnlockCollection (void);		/*****************************************************************************Creating and destroying the collectionThe actual work to load by CreateCollection.  DisposeCollection releases anyreferences to the list of TGraphics and disposes any additional memory wemay have allocated.*****************************************************************************/	OSStatus	CreateCollection (void);	OSStatus	DestroyCollection (void);		/*****************************************************************************Accessor FunctionsWe actually do allow a client to obtain a TGraphic directly.  An immediatelink is not made when this is done.  Clients should assume the TGraphic willbe available through the current scope, and if you need it longer than that,you should explicitly create a reference to it.*****************************************************************************/	SInt16			GetResID(void) {return fResID;}	Rect			GetBounds (UInt32 index);	TGraphic		*GetTGraphic (UInt32 index); // returns a naked TGraphic.  Use sparingly.		/*****************************************************************************Utility FunctionsThese just call through to the equivalent TGraphic classes.*****************************************************************************/	void			CopyImage (UInt32 index, SInt32 top, SInt32 left, Boolean useBackground);								   	Boolean			HitTest (UInt32 index, SInt32 v, SInt32 h);	protected:		/*****************************************************************************Constructor/Destructor	The contructor and destructor are only called internally by the class.  Clientsshould ask for an object via its resource ID, using the static routine above.*****************************************************************************/	TGraphicCollection (SInt16 resID);	~TGraphicCollection (void);	/*****************************************************************************Data Structures	The actual data used to hold the TGraphicCollection.  The structs could useeither 68K or PowerPC alignment (they come out the same).*****************************************************************************/	Handle			fGraphics;		   // 4 bytes	SInt16			fResID; 		   // 2 bytes	UInt16			fReferenceCount;   // 2 bytes, # of owners of this collection;	UInt32			fNumberOfGraphics; // 4 bytes};#if PRAGMA_STRUCT_ALIGN#pragma options align=reset#endif#endif /* _TGRAPHICCOLLECTION_ */