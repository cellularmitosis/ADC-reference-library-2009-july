<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>GCC Porting Guide: Porting from GCC 3.3 to GCC 4.0</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Porting from GCC 3.3 to GCC 4.0"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../documentation/Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../documentation/Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../documentation/Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../documentation/Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../documentation/Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../documentation/Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002071" title="Porting from GCC 3.3 to GCC 4.0"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../documentation/index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../documentation/DeveloperTools/index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../../documentation/DeveloperTools/CompilersDebuggers-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30001025" target="_top">Compiling &amp; Debugging</a> &gt; <a href="../index.html" target="_top">GCC Porting Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="PortingGuidelines.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../documentation/Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002071-BBCBGHCJ" title="Porting from GCC 3.3 to GCC 4.0"></a><hr /><H1>Porting from GCC 3.3 to GCC 4.0</H1><p>In Mac OS X 10.4, GCC 4.0 is the default compiler for all new projects. If you are creating new projects on the platform, you should naturally be using GCC 4.0 to compile those projects. However, if you are building existing projects using the GCC 3.3 compiler (the default compiler in Mac OS X 10.3), there are also many reasons to upgrade to GCC 4.0, including the following:</p><ul class="ul"><li class="li"><p>Better compile times</p></li><li class="li"><p>Better C++ language conformance</p></li><li class="li"><p>Smaller C++ binaries</p></li><li class="li"><p>Faster C++ compiles</p></li><li class="li"><p>Better optimization machinery</p></li><li class="li"><p>Better error checking and diagnosis</p></li><li class="li"><p>GCC 3.3 is not supported in Intel-based Macs</p></li></ul><p>Before you upgrade though, you should understand the changes that have gone into GCC 4.0 and how they might affect your code. In particular, code that compiled cleanly using GCC 3.3 may now generate warnings and errors when compiled using GCC 4.0. This is not intended to discourage you from updating to GCC 4.0, however. Upgrading may help you find subtle bugs in your code and bring your code into better conformance with existing standards. </p><p>This document provides information and guidance on how to migrate your code to GCC 4.0. For additional information, particularly regarding changes in C++ support, see the following GCC release notes: </p><ul class="ul"><li class="li"><p><span class="content_text"><a href="http://gcc.gnu.org/gcc-3.4/changes.html" target="_blank">http://gcc.gnu.org/gcc-3.4/changes.html</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://gcc.gnu.org/gcc-4.0/changes.html" target="_blank">http://gcc.gnu.org/gcc-4.0/changes.html</a></span></p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;Apple's release of GCC 4.0 occurred before the Free Software Foundation (FSF) declared the official release. Apple's GCC 4.0 Release Note contains an excellent summary of the changes in Apple's version of the compiler.</p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-100947">Justifying the Migration</a>
				
			<br/>
			
        
			
			
				<a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-97010">Making the Switch to GCC 4.0</a>
				
			<br/>
			
        
			
			
				<a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-104480">Step 1: Switch Your Project to Build Using GCC 4.0</a>
				
			<br/>
			
        
			
			
				<a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-103275">Step 2: Compile Your Code in GCC 4.0</a>
				
			<br/>
			
        
			
			
				<a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-103216">Step 3: Address Link Errors</a>
				
			<br/>
			
        
			
			
				<a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-103140">Step 4: Validate Your Code</a>
				
			<br/>
			
        
			
			
				<a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-103027">Step 5: Attack Warnings</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002071-100947" title="Justifying the Migration"></a><h2>Justifying the Migration</h2><p>GCC 4.0 represents a significant improvement over GCC 3.3. Upgrading is highly recommended for the majority of developers. Not only is the performance of the new compiler better, but it provides stricter conformance to existing standards, thus ensuring that your code is more correct. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_15" title="Important:"></a><p><strong>Important:</strong>&nbsp;GCC 4.0 uses the dynamic library implementations of libgcc and libstdc++ that were introduced in Mac OS X v10.3.9. If you migrate to GCC 4.0, the binaries you create can run only in Mac OS X 10.3.9 and later. For more information on the impacts these dynamic libraries may have on your code, see <em><a href="../../../../documentation/DeveloperTools/Conceptual/CppRuntimeEnv/index.html#//apple_ref/doc/uid/TP40001666" target="_top">C++ Runtime Environment Programming Guide</a></em>. </p><p></p></div><a name="//apple_ref/doc/uid/TP40002071-110088" title="Performance"></a><h3>Performance</h3><p>GCC 4.0 offers better compile times, especially for C++ code. Compile times for C++ programs have improved by as much as 30%. Compile times for C and Objective-C programs have improved by as much as 5%. </p><a name="//apple_ref/doc/uid/TP40002071-101151" title="Code Optimization"></a><h3>Code Optimization</h3><p>For optimizing code, GCC 4.0 now uses a model called <strong>static single assignment</strong> or SSA. SSA makes your program faster and more efficient by permitting better and more optimizations. The SSA optimizer does a much better job of finding places where functions can be inlined. In future revisions of GCC, it will be possible to have even better optimizations as developers extend the SSA optimizations.</p><a name="//apple_ref/doc/uid/TP40002071-101284" title="Better Warnings"></a><h3>Better Warnings</h3><p>Warnings often identify potential bugs in your code. GCC 4.0 performs many more checks (regardless of whether optimizations are enabled and disabled) and reports more warnings because of these checks. Identifying potential problems can help you fix your code in a way that improves overall stability. For example, GCC 4.0 will now warn about potentially ambiguous implicit casts, which could lead to manipulations on an unknown or unexpected object.</p><p>GCC 4.0 also promotes some warnings to full-fledged errors. For example, GCC 4.0 now reports an error if you try to use a return value from an Objective-C method whose return type is <code>void</code>, as shown in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Foo : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int _i;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void) i;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Foo<span></span></pre></td></tr><tr><td scope="row"><pre>- (void) i<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return _i;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(int argc, char **argv)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Foo *f=[[Foo alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    int value = [f i];  // this is a hard error in GCC 4.0.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Another place where GCC 4.0 now reports an error is when you have a statement in C++ where one array value is assigned to another array value, as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>main(int argc, char **argv)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int ARRAY_SIZE = 5;<span></span></pre></td></tr><tr><td scope="row"><pre>    int a[ARRAY_SIZE], b[ARRAY_SIZE];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    b[0] = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    a = b; // ERROR with GCC 4.0; Warning with GCC 3.3.<span></span></pre></td></tr><tr><td scope="row"><pre>    memcpy(a,b,sizeof(a)); // This is the correct way to copy an array in GCC 4.0.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the preceding code is compiled, GCC reports an error similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>/tmp/foo.C:9: error: incompatible types in assignment<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-101487" title="Better C++ Conformance"></a><h3>Better C++ Conformance</h3><p>GCC 4.0 now provides closer conformance to the C and C++ language standards, which are supported by most major compiler vendors. Better language conformance means your code is now more correct. It also means that it is more portable to other platforms. If your code deviates from the standards, the compiler issues warnings to let you know. If you are developing your code for use on multiple platforms, this feature alone should justify the upgrade. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_16" title="Note"></a><p><strong>Note:</strong>&nbsp;To detect potential incompatibilities between C++ code generated with GCC 3.3 and GCC 4.0, you can pass the <code>-Wabi</code> flag to GCC. When this flag is in effect, GCC issues a warning when it generates code that is probably not compatible with the vendor-neutral C++ ABI. For more information, see the <code>gcc</code> man page. </p></div><a name="//apple_ref/doc/uid/TP40002071-101549" title="Compiler Stability"></a><h3>Compiler Stability</h3><p>GCC 4.0 contains numerous bug fixes. If you are a C++ developer using GCC 3.3, you are likely to notice many new fixes in GCC 4.0, thanks in part to improved C++ support and a new C++ parser. If you have ever encountered crashes while parsing complex C++ code, you should definitely upgrade to GCC 4.0. </p><a name="//apple_ref/doc/uid/TP40002071-101521" title="Compiler Support"></a><h3>Compiler Support</h3><p>GCC 4.0 is now the default compiler for Mac OS X v10.4. This means that current development efforts are focused on making GCC 4.0 a better compiler. Even if you do not need the new features or performance offered by the compiler, upgrading means that you will be using the most up-to-date compiler that incorporates all of the latest bug fixes. </p><p>Of course, it is important to note that Apple still supports GCC 3.3 and ships the GCC 3.3 compiler alongside GCC 4.0. However, work on the GCC 3.3 code base will be limited to critical bug fixes.</p><a name="//apple_ref/doc/uid/TP40002071-97010" title="Making the Switch to GCC 4.0"></a><h2>Making the Switch to GCC 4.0</h2><p>The process for migrating to GCC 4.0 is relatively straightforward and can be summarized by the following steps: </p><ol class="ol"><li class="li"><p>Switch your project to build with GCC 4.0.</p></li><li class="li"><p>Compile your project and address any errors.</p></li><li class="li"><p>Address link errors.</p></li><li class="li"><p>Validate your code to ensure it works as before. </p></li><li class="li"><p>Eliminate warnings aggressively.</p></li></ol><p>The sections that follow provide detailed information regarding each of these steps.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_17" title="Important:"></a><p><strong>Important:</strong>&nbsp;Within the following sections, pay particular attention to warnings or important notes like this one. These notes call out misleading symptoms and error messages that might divert your attention from the real problem.</p><p></p></div><a name="//apple_ref/doc/uid/TP40002071-104480" title="Step 1: Switch Your Project to Build Using GCC 4.0"></a><h2>Step 1: Switch Your Project to Build Using GCC 4.0</h2><p>The first thing you have to do to use GCC 4.0 is configure your project. Even if your projects use the default system compiler (now GCC 4.0), you may need to modify the options you pass to the compiler. The basic steps for upgrading to GCC 4.0 are as follows:</p><ul class="ul"><li class="li"><p>Modify your Xcode targets or makefiles.</p></li><li class="li"><p>Check your compiler and linker flags.</p></li><li class="li"><p>Check your preprocessor usage.</p></li></ul><p>The following sections provide detailed information about each of these steps.</p><a name="//apple_ref/doc/uid/TP40002071-104493" title="Modifying Xcode Targets"></a><h3>Modifying Xcode Targets</h3><p>If you are building your project with Xcode, switching to GCC 4.0 involves modifying the settings for each target in your project. How you modify the settings depends on the type of your target. </p><a name="//apple_ref/doc/uid/TP40002071-104505" title="Table 1Changing Xcode targets to use GCC 4.0"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1&nbsp;&nbsp;</strong>Changing Xcode targets to use GCC 4.0</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Target type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Modifications</p></th></tr><tr><td  scope="row"><p>Native</p></td><td ><p>The icon for native targets looks like a box. For native targets, open the Inspector window for the target. Select the Build Rules tab. If the compiler shown in the System C Rule is not the desired compiler, add a new build rule by clicking the + button. Configure your new build rule to process “C source files” using GCC 4.0 (or the “GCC System Version (4.0)” of the compiler).</p></td></tr><tr><td  scope="row"><p>Classic (Jambase)</p></td><td ><p>The icon for classic targets looks like a set of concentric circles (bullseye). For classic targets, double-click the target in the project window to open it in an editor. Choose Settings > Simple View > GCC Compiler Settings. Select the GCC 4.0 compiler from the Compiler version popup menu.</p></td></tr></table></div><div class="warningbox"><img src="../../../../documentation/Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_18" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;Some developers try to hard-wire their compiler choice in Xcode by assigning values to the CC and CPLUSPLUS settings in the Xcode target expert view. When this happens, the compiler might complain about some options, such as headermaps, that are being used. The problem is that Xcode thinks it's using GCC 4.0 but is in fact still passing GCC 3.3 options to the compiler. To fix this problem, delete the values in CC and CPLUSPLUS. For classic (Jambase) targets, look for suspicious entries referring to the compiler version in the target settings. For native targets, look in the Build tab for these settings.</p><p></p><div class="clear"></div></div><p>In some cases, you may want to see which compiler is being used to compile your code and verify the options that are being passed to it. To get this information in Xcode, open the Build Results dialog and show the “build log” pane. (This section is located between the list of errors and the source code pane and is not always visible.) You can also use this pane to view linker error and warning messages. For more information on using this build log, see <em><a href="../../../../documentation/DeveloperTools/Conceptual/XcodeUserGuide20/Contents/Resources/en.lproj/index.html#//apple_ref/doc/uid/TP40001440" target="_top">Xcode 2.0 User Guide</a></em>. </p><a name="//apple_ref/doc/uid/TP40002071-104553" title="Modifying Makefiles"></a><h3>Modifying Makefiles</h3><p>If your project is built using Makefiles or custom build scripts, look for references to <code>/usr/bin/gcc-3.3</code> and change them to <code>/usr/bin/gcc</code> or <code>/usr/bin/gcc-4.0</code>. By default, invoking <code>/usr/bin/gcc</code> launches the default system compiler, which in Mac OS X v10.4 is GCC 4.0. </p><a name="//apple_ref/doc/uid/TP40002071-104284" title="Changing Compiler and Linker Flags"></a><a name="//apple_ref/doc/uid/TP40002071-104284-BBCHBFHE" title="Changing Compiler and Linker Flags"></a><h3>Changing Compiler and Linker Flags</h3><p>Some projects may use flags that are supported in GCC 3.3 but were removed in GCC 4.0. You can locate these changes by explicitly checking your compiler options in each Xcode project, or you can simply build your project and wait for error messages regarding illegal options. Once you identify the incorrect flag, go to the settings for the offending target and remove the option. <span class="content_text">Table 2</span> lists some other compiler flags that you should think about changing.</p><a name="//apple_ref/doc/uid/TP40002071-104300-BBCCEJEH" title="Table 2Problematic compiler options in GCC 4.0"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP40002071-104300" title="Table 2Problematic compiler options in GCC 4.0"></a><strong>Table 2&nbsp;&nbsp;</strong>Problematic compiler options in GCC 4.0</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Flag</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>-Werror</code></p></td><td ><p>This flag is still supported in GCC 4.0, but because it turns warnings into hard errors, you might want to disable it anyway. GCC 4.0 already generates significantly more warnings than before, so this flag is not as necessary while you are trying to get your code up and running on GCC 4.0. To disable it, disable the "Treat warnings as errors" build setting for your target. </p></td></tr><tr><td  scope="row"><p><code>-Wno-precomp</code></p></td><td ><p>This flag has not been needed since GCC 3.1. </p></td></tr><tr><td  scope="row"><p><code>-fcoalesce</code>,  <code>-fweak-coalesced</code>,  <code>-fcoalesce-templates</code></p></td><td ><p>There is no need to use these flags because the behavior specified by those flags is now the default. Those flags can safely be removed from any projects that use them.</p></td></tr><tr><td  scope="row"><p><code>-fno-coalesce</code>,  <code>-fno-weak-coalesced</code>,  <code>-fno-coalesce-templates</code></p></td><td ><p>These flags can be safely removed. The projects that used these flags in earlier compiler versions usually did so as workarounds for compiler bugs that no longer exist. In the very rare cases where there is a real need to disable C++ "vague linkage", use the <code>-fno-weak</code> flag.</p></td></tr><tr><td  scope="row"><p><code>--param max-inline-insns</code>, <code>--param min-inline-insns</code></p></td><td ><p>These flags are no longer used. The values used by the rest of the inlining parameters have changed their meaning between GCC 3.3 and GCC 4.0. Parameters used for GCC 3.3 will cause slower compile times and larger binaries in GCC 4.0. You may want to remove all inlining flags, analyze which portions of your code are slow, and then set the inlining parameters so that the slow functions are inlined.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-104397" title="Check Your Preprocessor Usage"></a><h3>Check Your Preprocessor Usage</h3><p>Do a quick check for bad preprocessor usage. If you have conditional code based on which compiler you're using (as in GCC vs. CodeWarrior), don't forget to update any conditional code looking at the <code>__GNUC__</code> variable for the compiler version, as shown in the following code listing:</p><div class="codesample"><table><tr><td scope="row"><pre>if (__GNUC__ == 3) // old<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (__GNUC__ == 3) || (__GNUC__ == 4) // new<span></span></pre></td></tr></table></div><p>Searching for <code>__GNUC__</code> in your project should locate all of the relevant code.</p><p>If you are migrating a project from CodeWarrior, do not wrap any Mac OS X-specific code using the <code>__MWERKS__</code> macro. Instead, use the following:</p><ul class="spaceabove"><li class="li"><p>Use <code>#ifdef __GNUC__</code> to wrap any GCC-specific code.</p></li><li class="li"><p>Use <code>#ifdef __APPLE_CC__</code> to wrap any Mac OS X-specific code.</p></li></ul><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_6" title="Use Framework Include Files"></a><h3>Use Framework Include Files</h3><p>If you are migrating a Carbon application from CodeWarrior to Mac OS X, you should remove any references to universal header files and replace them with the appropriate framework header files for Carbon. Framework includes are the standard way to include system header files. For example, to include the header files for the Carbon framework, you would use the following <code>#include</code> statement:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;Carbon/Carbon.h><span></span></pre></td></tr></table></div><p>If you encounter a large number of errors when including the Carbon framework in this manner, you can use the flat Carbon header files instead. The intent of the flat Carbon headers is to help ease the conversion away from universal headers. To include the flat Carbon headers, add <code>/Developer/Headers/FlatCarbon/</code> to the include path of your project. </p><a name="//apple_ref/doc/uid/TP40002071-103275" title="Step 2: Compile Your Code in GCC 4.0"></a><h2>Step 2: Compile Your Code in GCC 4.0</h2><p>Once you start compiling your code, the most common causes of problems are likely to be the following: </p><ul class="ul"><li class="li"><p>Invalid compiler and linker flags</p></li><li class="li"><p>Changes to C++ template code</p></li><li class="li"><p>Restrictions on what can be on the left hand side of assignment statements (lvalues)</p></li><li class="li"><p>Problems finding header files</p></li><li class="li"><p>Conflicting declarations (static vs. extern)</p></li><li class="li"><p>Changes to kernel extension ("kext") source code</p></li><li class="li"><p>Warnings about incorrect code</p></li></ul><p>For more information about invalid compiler and linker flags, see <span class="content_text"><a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-104284">“Changing Compiler and Linker Flags.”</a></span> The remaining problems are explained in the sections that follow. Each section explains the class of the problem and discusses issues you may notice when running the resulting binary.</p><a name="//apple_ref/doc/uid/TP40002071-103336" title="Changes for C++ Templates"></a><h3>Changes for C++ Templates</h3><p>The most common problem C++ programmers are likely to encounter revolve around changes to support C++ standards compliance. GCC 3.4 (which was shipped by the FSF but not by Apple) started to warn developers about incorrect C++ usage patterns. In GCC 4.0, those warnings are now errors. </p><p>One of the more common errors you’re likely to encounter is name lookup problems of the form “x isn’t defined in this scope.” You can find out more about this problem by searching for “name lookup” in the GCC 4.0 documentation. Four of the most common name lookup errors are as follows:</p><a name="//apple_ref/doc/uid/TP40002071-106112" title="Table 3Common name lookup errors in GCC 4.0"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3&nbsp;&nbsp;</strong>Common name lookup errors in GCC 4.0</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Error</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Dependent names in a template class</p></td><td ><p>Names in function templates are either dependent or non-dependent. Dependent names depend lexically on a template parameter and are looked up when the template is instantiated. Non-dependent names are looked up when the template is parsed, which occurs before it is instantiated.</p></td></tr><tr><td  scope="row"><p>Unqualified names in a template</p></td><td ><p>Names that are specific to a template parameter class must be qualified, either by explicitly saying that they are from the template (<code>Foo&lt;T>::mArray</code>) or by using a <code>this</code> pointer to indicate they come from the template instance. If you explicitly state that they are from the template, the name is looked up at instantiation time; otherwise, if you use a <code>this</code> pointer, the name is looked up at template definition time.</p></td></tr><tr><td  scope="row"><p>Unqualified names in a template superclass</p></td><td ><p>Names defined in a template superclass of the current template must be qualified as being from the superclass. Alternatively, you can also qualify those names by preceding them with <code>this-></code>. </p></td></tr><tr><td  scope="row"><p>Unqualified names in an inherited template class</p></td><td ><p>If a template class inherits from another template class, members of the inherited template class must be qualified. For an example, see <span class="content_text">Listing 1</span>. </p></td></tr></table></div><p><span class="content_text">Listing 1</span> shows an example of an unqualified name belonging to an inherited template class. </p><a name="//apple_ref/doc/uid/TP40002071-106184-BBCECBJJ" title="Listing 1Unqualified names in an inherited template"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40002071-106184" title="Listing 1Unqualified names in an inherited template"></a><strong>Listing 1&nbsp;&nbsp;</strong>Unqualified names in an inherited template</p><div class="codesample"><table><tr><td scope="row"><pre>template &lt;typename T> struct Base<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int local_var;<span></span></pre></td></tr><tr><td scope="row"><pre>    void f();<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>template &lt;typename T> struct Derived : public Base&lt;T><span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    void g()<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        local_var++;    // ERROR: Name not found.<span></span></pre></td></tr><tr><td scope="row"><pre>        f();          // ERROR: Name not found.<span></span></pre></td></tr><tr><td scope="row"><pre>        this->local_var++;    // OK<span></span></pre></td></tr><tr><td scope="row"><pre>        this->f();    // OK<span></span></pre></td></tr><tr><td scope="row"><pre>        Derived::f(); // OK<span></span></pre></td></tr><tr><td scope="row"><pre>        Base&lt;T>::f(); // OK<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-103443" title="Changes to lvalue Assignments"></a><h3>Changes to lvalue Assignments</h3><p>The GCC compiler was previously extended to permit non-trivial expressions on the left hand side of an assignment (the <strong>lvalue</strong> of the assignment). This feature was removed from GCC 4.0 to better match the C and C++ standards and because it was not always clear what the programmer intended in those situations. </p><p>Currently, Apple's version of GCC 4.0 compiler only warns about some cases that the FSF's GCC 4.0 compiler would consider an error. Those cases that remain will be eliminated in a future version of Apple’s compiler. What follows are some examples of code that may now generate errors or warnings. </p><p>In the following case, GCC 4.0 no longer permits the following conditional lvalue assignments. </p><div class="codesample"><table><tr><td scope="row"><pre>(condition ?  lvalue1 : lvalue2) = expr; // Warning: target of assignment not really an lvalue (will be a hard error in future)<span></span></pre></td></tr></table></div><p>To avoid this problem, rewrite the expression so that the left-hand side contains only a variable.</p><p>Another case that generates an error involves taking the address of an lvalue variable, as shown here.</p><div class="codesample"><table><tr><td scope="row"><pre>&amp;foo = 1; //  ERROR: invalid lvalue in assignment<span></span></pre></td></tr></table></div><p>Instead of this expression, create a temporary variable for the address of <code>foo</code>, and assign a value to that. </p><p>In the last case, the problem is caused by dereferencing first and then casting to the target type. Instead, cast the pointer to an appropriate pointer type and then dereference the value. </p><div class="codesample"><table><tr><td scope="row"><pre>(u_int32_t)*(vcp->vc_outtok) = sp->sv_caps; // Warning: target of assignment not really an lvalue (hard error in future)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>*(u_int32_t*)(vcp->vc_outtok) = sp->sv_caps; // OK<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-103516" title="Searching for Framework Headers"></a><h3>Searching for Framework Headers</h3><p>Several issues in framework and header searching changed between GCC 3.3 and GCC 4.0. </p><p>In GCC 3.3, the compiler would incorrectly search all framework paths when searching for a header in a framework. This is incorrect behavior because there are cases where headers could be retrieved from different installed versions of the framework. For example, some headers might be retrieved from a copy of the framework you are working on while others are retrieved from an officially installed version of the framework. </p><p>GCC 4.0 now uses a “first match wins” model for frameworks. With this model, the first time you include a framework header, the compiler makes a note of the location of that framework. Subsequent attempts to retrieve headers from the same framework automatically go to the same location. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_19" title="Important:"></a><p><strong>Important:</strong>&nbsp;If the compiler reports that it cannot find a header that you know to exist in the framework, it could be due to this mismatched framework header problem. To fix this problem, reorder the framework paths so that the complete version of the framework is searched first.</p><p></p></div><p>In GCC 3.3, the <code>-I</code> and <code>-F</code> flags were treated interchangeably. This is incorrect behavior. In GCC 4.0, you must use the <code>-F</code> flag to get the proper search semantics for your framework directory. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_20" title="Important:"></a><p><strong>Important:</strong>&nbsp;If the compiler reports that framework headers cannot be found, you should also check to make sure you are including the framework using the <code>-F</code> flag. </p><p></p></div><div class="codesample"><table><tr><td scope="row"><pre>gcc -I/System/Library/MyFrameworks foo.m // worked in gcc-3.3, doesn't work in gcc-4.0.<span></span></pre></td></tr><tr><td scope="row"><pre>gcc -F/System/Library/MyFrameworks foo.m // OK<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-103574" title="Conflicting Declarations"></a><h3>Conflicting Declarations</h3><p>The following sections list some of the conflicting declarations you may encounter:</p><a name="//apple_ref/doc/uid/TP40002071-104627" title="Static versus Extern"></a><h4>Static versus Extern</h4><p>GCC 4.0 now warns you if your project defines the same variable as <code>extern</code> and <code>static</code>. In the past, the compiler used to respect whichever declaration it encountered last. </p><p>This problem occurs when you create a local static variable in one file and then declare a variable with the same name as <code>extern</code> in a different file. Don’t do this. Instead, change the name of the static variable so that it doesn't match the global variable name.</p><div class="codesample"><table><tr><td scope="row"><pre>// foo.h:<span></span></pre></td></tr><tr><td scope="row"><pre>extern int _defaultWidth;  // used by lots of compilation units<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// foo.c:<span></span></pre></td></tr><tr><td scope="row"><pre>static int _defaultWidth; // local copy -- ERROR: static declaration of '_defaultWidth' follows non-static declaration<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-104688" title="Forward Declaration of Static Functions"></a><h4>Forward Declaration of Static Functions</h4><p>GCC 4.0 does not allow you to place a forward definition of a static function inside the body of another function. To correct this situation, move the forward declaration outside of the function (to the file namespace level).</p><div class="codesample"><table><tr><td scope="row"><pre>int foo(int i) {<span></span></pre></td></tr><tr><td scope="row"><pre>  static int bar(int j);  // ERROR: invalid storage class for function 'bar<span></span></pre></td></tr><tr><td scope="row"><pre>  bar(i+5);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static int bar(int j);  // OK<span></span></pre></td></tr><tr><td scope="row"><pre>int foo(int i) {<span></span></pre></td></tr><tr><td scope="row"><pre>  bar(i+5);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-104760" title="C++ new"></a><h4>C++ new</h4><p>GCC 4.0 now enforces the rule that when allocating an object array, the class name in the new statement cannot be surrounded by parenthesis. </p><div class="codesample"><table><tr><td scope="row"><pre>map = new (IOMemoryMap*)[WindowCount]; // ERROR: array bound forbidden after parenthesized type-id<span></span></pre></td></tr><tr><td scope="row"><pre>// note: try removing the parentheses around the type-id<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>map = new IOMemoryMap *[WindowCount];  // OK<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-107125" title="Implicit Arguments to C++ Member Functions"></a><h4>Implicit Arguments to C++ Member Functions</h4><p>The same implicit arguments (default parameters) cannot be specified in both the declaration and definition of a member function. A member function definition declared outside the class can give additional default arguments, but not the same ones as shown in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>class A<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>    int foo(int i, int j = 99);<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int A::foo(int i, int j = 99) // ERROR: default argument given for parameter 1 of 'int A::foo(int)'<span></span></pre></td></tr><tr><td scope="row"><pre>    // ERROR: after previous specification in 'int A::foo(int)'<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int A::foo(int i=10, int j) {  // OK, but visible only in this compilation unit<span></span></pre></td></tr><tr><td scope="row"><pre> ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int A::foo(int i, int j) {  // OK<span></span></pre></td></tr><tr><td scope="row"><pre> ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_7" title="Conflicting Declarations in Namespaces"></a><h4>Conflicting Declarations in Namespaces</h4><p>When declaring a namespace, do not include the name of the namespace in the declaration:</p><div class="codesample"><table><tr><td scope="row"><pre>namespace mynames<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    void mynames::func();    // ERROR! Explicit qualification in declaration<span></span></pre></td></tr><tr><td scope="row"><pre>    void func();            // OK.<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-103817" title="Kernel Extensions"></a><h3>Kernel Extensions</h3><p>GCC 4.0 can compile kernel extensions (kexts) that should work with current and previous versions of Mac OS X (subject to all the conditions that GCC 3.3-compiled kexts followed). Regardless, you must make a few changes to your kext to get it to compile. </p><p>Kernel extensions cannot have statically initialized <code>auto</code> (function-local) variables that call C++ constructors. This is because he kernel does not provide locking routines around the initialization of <code>auto</code> variables. (Such locking routines could trigger nasty side effects in the kernel.) Although your code should compile fine, it will fail to load because the symbols for the missing locking code (<code>___cxa_guard_abort</code>, <code>___cxa_guard_acquire</code>, and <code>___cxa_guard_release</code>) are undefined. To correct the problem, you must move the local variables to the top level:</p><div class="codesample"><table><tr><td scope="row"><pre>static A* globalArrayOfA = new A[10];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int A::foo(int i)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    static A* arrayOfA = new A[10];<span></span></pre></td></tr><tr><td scope="row"><pre>    return arrayOfA[i].value();  // KEXT LOAD ERROR: __cxa_guard_abort undefined<span></span></pre></td></tr><tr><td scope="row"><pre>    return globalArrayOfA[i].value();  // OK<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Many kexts try to cast member function pointers to make them appear as if they are simply function pointers. This is done so that the member function can be registered as an interrupt handler. GCC 4.0 disallows such casts. Instead, you must use the <code>OSMemberCastFunction</code> macro to perform the cast correctly. This macro is available in Mac OS X v10.4 and should work identically with GCC 3.3 or GCC 4.0, and with the same behavior as the original code when compiled with GCC 3.3.</p><div class="codesample"><table><tr><td scope="row"><pre>int A::bar(int i)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    handler = (IOInterruptAction) &amp;A::interruptHandler; // ERROR: converting from `int (A::*)(int)' to `int (*)(int)' in a kext.  Use OSMemberFunctionCast() instead.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (*handler)(5);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int B::bar(int i)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    handler = OSMemberFunctionCast(IOInterruptAction, this, &amp;B::interruptHandler); // OK<span></span></pre></td></tr><tr><td scope="row"><pre>    return (*handler)(5);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-104894" title="Warnings About Incorrect Code"></a><h3>Warnings About Incorrect Code</h3><p>The following sections explain some of the other types of warnings and errors you may encounter during compilation.</p><a name="//apple_ref/doc/uid/TP40002071-104908" title="Declaring Abstract Virtual Functions"></a><h4>Declaring Abstract Virtual Functions</h4><p>Don't use NULL to define a virtual function as unimplemented. Instead, use the value 0, as shown in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>class C<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual int PrepareCFBundle() = NULL; // ERROR: invalid initializer for virtual method<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual int PrepareCFBundle() = 0; // OK<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-104943" title="Labels"></a><h4>Labels</h4><p>The ISO C specification says that labels must be followed by a statement. Thus, you cannot have a label at the end of a block:</p><div class="codesample"><table><tr><td scope="row"><pre>foo: }<span></span></pre></td></tr></table></div><p>To fix this problem, simply add a semicolon after the label to create an empty statement: </p><div class="codesample"><table><tr><td scope="row"><pre>foo: ; }<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-105081" title="Static Data in Inline Functions"></a><h4>Static Data in Inline Functions</h4><p>GCC 4.0 reports an error if you define a static array inside an inline function. The compiler cannot determine if it should use a single array or duplicate the array as it inlines the function. To fix this, move the array out of the function.</p><a name="//apple_ref/doc/uid/TP40002071-105012" title="The offsetof Function"></a><h4>The offsetof Function</h4><p>GCC 4.0 now requires that arguments to <code>offsetof</code> must be constant: </p><div class="codesample"><table><tr><td scope="row"><pre>bufferSizeNeeded = offsetof(ATSUGlyphInfoArray, glyphs[numGlyphs]); // ERROR:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Instead, do this.<span></span></pre></td></tr><tr><td scope="row"><pre>bufferSizeNeeded = (char*)&amp;(((ATSUGlyphInfoArray*)0)->glyphs[numGlyphs]) - (char*)0;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-113345" title="Bitfields and the typeof Operator"></a><h4>Bitfields and the typeof Operator</h4><p>Because of a change to the C compiler, attempting to get the type of a bitfield value generates an error in GCC 4.0. GCC 3.3 used to allow this operation for C code and it is still supported in C++ code in GCC 4.0.</p><div class="codesample"><table><tr><td scope="row"><pre>// The following macro won't work in GCC 4.0 because the type of<span></span></pre></td></tr><tr><td scope="row"><pre>// value is considered to be a bitfield that can't be used in typeof.<span></span></pre></td></tr><tr><td scope="row"><pre>// In GCC 3.3, it would have been treated as an int.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define STRUCT_VALUE(x) ((x->isSet ? x->value : (typeof(x->value))0))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>struct a<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int isSet: 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    int value:15;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int foo(struct a *instance)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return STRUCT_VALUE(instance);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In some situations, you can correct this problem in your C code. Specifically, if the bitfield value is a 2-bit integer, cast the value being used in the <code>typeof</code> statement to <code>int</code>. This should allow the code to compile. </p><a name="//apple_ref/doc/uid/TP40002071-113460" title="Initializing Class Instance Variables"></a><h4>Initializing Class Instance Variables</h4><p>With GCC 4.0 and C++, static class instance variables can be initialized inside the class declaration only if the type is an integer or <code>enum</code> and only if the assigned value is a constant. If you need to initialize other types or if you need to initialize the value using an expression, you cannot do it from the class declaration. Instead, you must perform the assignment from the code in your class definition file.</p><a name="//apple_ref/doc/uid/TP40002071-113476" title="Assigning Arrays"></a><h4>Assigning Arrays</h4><p>You cannot assign one array variable to another and expect the compiler to copy the array members for you. When copying arrays, you must use <code>bcopy</code> to explicitly copy the bytes of the array. GCC 3.3 issued a warning for this type of behavior, but in GCC 4.0, this now results in a hard error. </p><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_8" title="Sequence Points"></a><h4>Sequence Points</h4><p>You cannot modify variables as part of passing them to a function, as shown in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>void myFunc()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int i = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    myOtherFunc(i, i++);    // Warning! Operation on 'i' may be undefined.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Instead, simply modify the variable outside of the function parameter list, as shown here:</p><div class="codesample"><table><tr><td scope="row"><pre>void myFunc()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int i = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    myOtherFunc(i, i);<span></span></pre></td></tr><tr><td scope="row"><pre>    i++;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-107899" title="Defining System Macros Which Change Header File Processing"></a><h4>Defining System Macros Which Change Header File Processing</h4><p>Some open source programs have failed to build because of supposedly missing files. The problem is caused by the project defining an implementation-reserved name, such as <code>__FreeBSD__</code>, either in a source code file or in a compiler argument. Implementation-reserved names begin with two underscore characters or one underscore followed by a capital letter. These names often control which header files are used by the compiler. Defining the <code>__FreeBSD__</code> name, and not setting a value, can cause the BSD-derived header files to assume you are running on an earlier version of BSD than you actually are. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_21" title="Important:"></a><p><strong>Important:</strong>&nbsp;The definition of implementation-reserved macros in your project should always be viewed suspiciously because they can alter the way in which the system parses header files. One of the symptoms of defining the <code>__FreeBSD__</code> name is that the compiler reports that the header file <code>machine/ansi.h</code> cannot be found. </p><p></p></div><p>In the case of the <code>__FreeBSD__</code> name, the header files assume you’re running on a version of BSD prior to version 5. Versions of BSD prior to version 5 included the <code>machine/ansi.h</code> header file. Mac OS X is derived from BSD version 5, which does not include the header file. Thus, the compiler reports an error when it cannot find the file. </p><a name="//apple_ref/doc/uid/TP40002071-105962" title="General Correctness"></a><h4>General Correctness</h4><p>GCC 4.0 now generates errors in many cases where its predecessor (GCC 3.3) did not. Most of these errors should be obvious once you examine the code. Examples of these errors include the following:</p><ul class="spaceabove"><li class="li"><p>Accessing a private instance variable in C++ and Objective C</p></li><li class="li"><p>An empty return value in a function that is expected to return a value</p></li><li class="li"><p>Returning a value from a function whose return type is <code>void</code></p></li><li class="li"><p>Doing anything with the return value from a function whose return type is <code>void</code></p></li><li class="li"><p>Arbitrary casts. The compiler does not allow you to implicitly cast a <code>void</code> pointer to some other type. Instead, you must provide an explicit cast.</p></li></ul><a name="//apple_ref/doc/uid/TP40002071-113729" title="Thread Safety and Static Local Variable Initialization"></a><h3>Thread Safety and Static Local Variable Initialization</h3><p>To maximize thread safety, GCC 4.0 automatically adds locks around any code that initializes local static variables in C++. If you do not need this protection and want to reduce your code size slightly, you can disable the locking behavior by passing the <code>-fno-threadsafe-statics</code> option to the compiler. </p><a name="//apple_ref/doc/uid/TP40002071-103216" title="Step 3: Address Link Errors"></a><h2>Step 3: Address Link Errors</h2><p>Once you sort through and solve any major compilation errors, you can begin to examine any linking issues. C++ developers in particular may discover that they have missing or multiply-defined symbols. </p><a name="//apple_ref/doc/uid/TP40002071-108399" title="Examine System Library Usage"></a><h3>Examine System Library Usage</h3><p>The first step to resolving link issues is to examine your system library usage. In Mac OS X v10.3.9 and later, both <code>libgcc</code> (the C support library) and <code>libstdc++</code> (the Standard C++ library) are implemented as dynamic libraries. These libraries are linked into your program automatically by the GCC 4.0 compiler (rather than <code>ld</code>). If you encounter multiply defined symbols from these libraries, you may be including the static versions of these libraries on your link line. </p><p>Check to see if your project links against the <code>libgcc.a</code>, <code>libstdc++.a</code>, or <code>libcc_dynamic.a</code> static libraries. If it does, you should remove those libraries from your link commands. </p><p>If you compile your C++ application outside of Xcode, initiate the link phase using <code>g++</code>, and not <code>ld</code>, to ensure the inclusion of the correct libraries. </p><a name="//apple_ref/doc/uid/TP40002071-108693" title="Check Any Linked C++ Libraries"></a><h3>Check Any Linked C++ Libraries</h3><p>Once you have resolved any link issues with the system libraries, look at the other libraries on your link line. If you link to any libraries that contain a C++ interface and were created using GCC 3.3, you must remove them from your link line. </p><p>The C++ application binary interface (ABI) changed between GCC 3.3 and GCC 4.0. Any application or library linking against a library that exports C++ functions must be built with the same compiler. Such problems are usually obvious when you check the list of undefined symbols. If the linker complains that any symbols starting with <code>_ZTI</code> are undefined, you are probably compiling a program using a mix of GCC 3.3 and GCC 4.0 binaries. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_22" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>_ZTI</code> prefix indicates the mangled type info for a specific C++ class. </p></div><p>In your own libraries, you can use the <code>-Wabi</code> flag to tell the GCC compiler to issue warnings when it generates code that is not compatible with the vendor-neutral C++ ABI. For more information about this flag, see the <code>gcc</code> man page. </p><a name="//apple_ref/doc/uid/TP40002071-108857" title="Check Your C++ Library Exports"></a><a name="//apple_ref/doc/uid/TP40002071-108857-BBCIIJFH" title="Check Your C++ Library Exports"></a><h3>Check Your C++ Library Exports</h3><p>If you are building a C++ library and limit the symbols exported from your library, you should verify that your library exports the symbols you expect.</p><p>By default, GCC 4.0 marks most symbols as private to prevent them from being exported. This is a change from the GCC 3.3 behavior but has significant advantages, particularly for C++ developers. Setting the default symbol visibility to private reduces the size of the exported symbol tables. If your code makes extensive use of templates, this size reduction could be huge. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_23" title="Important:"></a><p><strong>Important:</strong>&nbsp;If your project is a dynamic library and uses an export list, prepare to change the list to make sure the same symbols are exported from your library. Use the <code>nm</code> tool to check the list of symbols exported from both your GCC 3.3 binary and GCC 4.0 binary. If you export C++ interfaces, remember to export class info (<code>_ZTI*</code> symbols) for your exported classes. </p><p></p></div><p>If you don't want the space improvements triggered by making most symbols private, you can tell GCC 4.0 to export most symbols in the GCC 3.3 manner. To do so from Xcode, turn off the "symbols private by default" setting for your target. To do so from the GCC command line option, specify the <code>-fvisibility=default</code> option on the command line.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_24" title="Important:"></a><p><strong>Important:</strong>&nbsp;In GCC 4.0 and Xcode, projects are built with all symbols marked <code>private extern</code> by default. To export symbols, you either need to turn off the global setting for hiding symbols or mark only those symbols that you want to be exported. Otherwise, if you use <code>nmedit</code> to strip unwanted symbols, the tool strips all <code>private extern</code> symbols, which may not be what you intended. </p><p></p></div><p>For more information regarding C++ symbol visibility and runtime behavior, see <em><a href="../../../../documentation/DeveloperTools/Conceptual/CppRuntimeEnv/index.html#//apple_ref/doc/uid/TP40001666" target="_top">C++ Runtime Environment Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP40002071-103140" title="Step 4: Validate Your Code"></a><h2>Step 4: Validate Your Code</h2><p>When you reach the stage where your application builds successfully, you should start testing to make sure everything still works as intended. Run the code through your test suites to verify that the compiler did not change any of your application’s behavior. Changing compilers can introduce new problems, so testing is an important step in verifying that the change went smoothly. </p><p>In addition to running your test suites, you should also check the size of your resulting binary file. With GCC 4.0, the compiler can do optimizations in places that it could not previously. Using the same compiler settings, you might find the resulting binary is quite different than ones previously built using GCC 3.3. New functions may be inlined, which could significantly increase the size of your binary. (For more information on this effect, see <span class="content_text"><a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-103191">“Optimization Changes for Inline Functions.”</a></span>)</p><p>If you are building a dynamic shared library, verify that the list of symbols exported by your library has not changed. For more information on fixing export problems, see <span class="content_text"><a href="PortingToGCC.html#//apple_ref/doc/uid/TP40002071-108857">“Check Your C++ Library Exports.”</a></span> </p><a name="//apple_ref/doc/uid/TP40002071-103163" title="Known Code Changes"></a><h3>Known Code Changes</h3><p>The code optimizer in GCC 4.0 is very different from the ones in previous versions of GCC. If you discover incorrect behavior in your recompiled code, or if you encounter crashes, check for the following known issues:</p><ul class="spaceabove"><li class="li"><p>The optimizer in GCC 4.0 may change the order of computations for some mathematical operations (such as addition or multiplication). </p></li><li class="li"><p>Casting a member-function pointer to a regular function pointer now works differently in GCC 4.0. Prior to GCC 4.0, such casts were resolved at runtime, which meant that the address of the function was based on the actual type of the object at the call site. For example, suppose you request the address of <code>A::MyFunction</code> from another method of <code>A</code>. If the actual type of the object at runtime is <code>B</code> (a subclass of <code>A</code>) and <code>B</code> defines its own version of <code>MyFunction</code>, you would actually get the address of <code>B::MyFunction</code>. In GCC 4.0, the address of these functions is now calculated at compile time. So now, if you ask for <code>&amp;A::MyFunction</code>, you will always get the address of <code>A::MyFunction</code>. </p></li></ul><p>For arithmetic operations, the C and C++ standards state that subexpression evaluation order is undefined; the compiler is free to evaluate the arguments in addition or multiplication expressions in any order it wants. There are exceptions to this rule, however. These exceptions include the following types of subexpressions, which are all evaluated from left to right:</p><ul class="spaceabove"><li class="li"><p>&amp;&amp; operators</p></li><li class="li"><p>|| operators</p></li><li class="li"><p>?: operators</p></li><li class="li"><p>, (comma) operators</p></li></ul><p>If one of these subexpressions has side effects, you might notice different behavior in GCC 4.0, depending on how the optimizer has reordered the code. You can use the <code>-Wsequence-point</code> flag to find any code that may have undefined semantics. </p><a name="//apple_ref/doc/uid/TP40002071-103191" title="Optimization Changes for Inline Functions"></a><a name="//apple_ref/doc/uid/TP40002071-103191-BBCHDGBF" title="Optimization Changes for Inline Functions"></a><h3>Optimization Changes for Inline Functions</h3><p>The inlining algorithms in GCC 4.0 are much better at deciding when to inline functions rather than call them. The side effects of this optimization, however, are larger binaries and faster code. In many cases, you should not see any significant differences unless you have been overriding the default parameters that control inlining in your project. If you currently use the inlining parameters <code>-finline-limit=xxxx</code> or <code>--param</code>, do not continue to use the currently assigned values for those parameters. Instead, profile your code again and see what parameters offer the best balance between code size and speed for your application. </p><p>Internal testing has shown that projects using the <code>-finline-limit</code> option under GCC 3.3 would see code size increases of up to 30% and compile time increases of up to 50% under GCC 4.0. For <code>-finline-limit</code>, the default value is usually <code>600</code>. If you use the <code>-Os</code> flag to optimize for size, the default value drops to <code>10</code>. If you manually assign a limit of <code>200</code> or more to the <code>-finline-limit</code> flag, you are liable to see larger binaries than you did using the same settings under GCC 3.3.</p><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_9" title="Forcibly Inlining Functions"></a><h3>Forcibly Inlining Functions</h3><p>If you want to force a routine to be inlined all the time, do not assume the compiler will do it for you. Tell the compiler you explicitly want the routine inlined by adding the <code>always_inline</code> attribute to it, as shown in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>void MyInlineFunction(int c) __attribute__((always_inline))<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002071-DontLinkElementID_10" title="Data Type Size Differences"></a><h3>Data Type Size Differences</h3><p>For many basic data types, such as <code>bool</code> and  <code>int</code> compilers are at liberty to define the size of those types as they see fit. If you have code that expects these types to be a specific size, your code may not behave as expected. The transition to Macs that use Intel processors and differences between 32-bit and 64-bit binaries make it very important that you do not assume the size of some data types.</p><p>For string data, you should also not make assumptions about the size of character data types such as <code>wchar_t</code>. On Mac OS X, this type is typically 2 bytes wide, but on most UNIX operating systems it is 4 bytes. If you really need two-byte character data, manipulate your strings using CFString objects and examine the resulting characters using the <code>UniChar</code> data type. If your program retrieves strings from external sources, you can convert them using the <code>CFStringCreateFromExternalRepresentation</code> function. (You can also use the <code>iconv</code> function on UNIX; see <code>man 3 iconv</code> for details.)  </p><a name="//apple_ref/doc/uid/TP40002071-103027" title="Step 5: Attack Warnings"></a><h2>Step 5: Attack Warnings</h2><p>GCC 4.0 is much better about warning you of potentially incorrect code. Therefore, it is important that you vigorously pursue and eliminate warnings in your code. The newly reported warnings have already uncovered several potential bugs lurking in Mac OS X sources, and you are strongly advised to eliminate them from your own sources as well. </p><p>Once your code builds successfully under GCC 4.0, you should start examining the warnings produced by the compiler. Some warnings may reflect stylistic differences but they may also identify places where the compiler cannot infer enough information from the code to know what was originally intended. You should examine each of them to determine whether the warning is innocuous or identifies a potential bug. Removing the potential problems not only eliminates the warnings but should also add stability to your code. </p><p>The following sections describe some of the more common warnings you can expect to see in projects compiled with GCC 4.0.</p><a name="//apple_ref/doc/uid/TP40002071-103045" title="Objective-C and Selectors"></a><h3>Objective-C and Selectors</h3><p>When a message is sent to a receiver of type <code>id</code>, the compiler looks at <em>all</em> matching selectors and warns about inconsistencies in argument types. GCC 4.0 is better at this than GCC 3.3 was and may reveal inconsistencies that were previously hidden. Although currently disabled, you can enable these warnings using the <code>-Wstrict-selector-match</code> flag. In the future, the compiler will warn about these inconsistencies by default. </p><p>Here are 3 examples of this warning that occurred in the Sketch example application:</p><div class="codesample"><table><tr><td scope="row"><pre> NSNotification.h:40: warning: using `-(void)postNotificationName:(NSString  *)aName object:(id)anObject' NSDistributedNotificationCenter.h:59:  warning: also  found `-(void)postNotificationName:(NSString *)aName object:(NSString  *)anObject' <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> NSNotification.h:37: warning: using `-(void)addObserver:(id)observer  selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject'  NSDistributedNotificationCenter.h:57: warning: also found  `-(void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString  *)aName  object:(NSString *)anObject' <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSView.h:115: warning: using `-(NSWindow *)window'<span></span></pre></td></tr><tr><td scope="row"><pre>NSAlert.h:125: warning: also found `-(id)window'<span></span></pre></td></tr></table></div><p>To fix these, use explicit casts or change the method definitions so that calls and definitions match. </p><a name="//apple_ref/doc/uid/TP40002071-103082" title="Objective-C Instance Variables"></a><h3>Objective-C Instance Variables</h3><p>In Objective C, instance variables are labeled as <code>@protected</code> by default. GCC 4.0 now explicitly warns about this, and future versions of the compiler will treat this as an error. To correct this problem, you should explicitly identify the scope of instance variables in your Objective-C interfaces.</p><a name="//apple_ref/doc/uid/TP40002071-103096" title="Things You Should Not Do"></a><h3>Things You Should Not Do</h3><p>There are cases where combinations of particularly ugly or strange casts can generate the following warning:</p><div class="codesample"><table><tr><td scope="row"><pre>Pictures.c: In function 'StdOpcode':<span></span></pre></td></tr><tr><td scope="row"><pre>Pictures.c:1132: warning: function called through a non-compatible type<span></span></pre></td></tr><tr><td scope="row"><pre>Pictures.c:1132: note: if this code is reached, the program will abort<span></span></pre></td></tr></table></div><p>In these cases, the compiler really does insert an abort instruction rather than try to generate what it thinks is an incorrect function call. If you see this warning, you should absolutely fix it by removing or changing the cast so that the compiler can call the correct function. </p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="PortingGuidelines.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../documentation/Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-10-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/releasenotes/DeveloperTools/GCC40PortingReleaseNotes/Articles/PortingToGCC.html%3Fid%3DTP40002069-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/releasenotes/DeveloperTools/GCC40PortingReleaseNotes/Articles/PortingToGCC.html%3Fid%3DTP40002069-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/releasenotes/DeveloperTools/GCC40PortingReleaseNotes/Articles/PortingToGCC.html%3Fid%3DTP40002069-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
