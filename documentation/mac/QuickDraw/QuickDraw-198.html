<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About Color QuickDraw (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING198></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-197.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-199.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-197.html"><B>Chapter 4 - Color QuickDraw</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING198-0></A>
<H1>About Color QuickDraw</H1>
 <B>Color QuickDraw</B> is a collection of system software routines that your application can use to display hundreds, thousands, even millions of colors on capable screens. Color QuickDraw is available on all newer models of Macintosh computers; only those older computers based on the Motorola 68000 processor provide no support for Color QuickDraw.<P>
 Color QuickDraw performs its operations in a graphics port called a <I>color graphics port</I>, which is based on a data structure of type <CODE>CGrafPort</CODE>. As with basic graphics ports (which are based on a data structure of type <CODE>GrafPort</CODE>), each color graphics port has its own local coordinate system. All fields in a <CODE>CGrafPort</CODE> record are expressed in these coordinates, and all calculations and actions that Color QuickDraw performs use its local coordinate system.<P>
 As described in the chapter "QuickDraw Drawing," you can draw into a basic graphics port using eight predefined colors. With a color graphics port, however, you can define your own colors with which to draw. With Color QuickDraw, your application works in an abstract color space defined by three axes of red, green, and blue (RGB). Although the range of colors actually available to your application depends on the user's computer system, Color QuickDraw provides a consistent way for your application to deal with color, regardless of the characteristics of your user's screen and software configuration.<P>
<A NAME=HEADING198-4></A>
<H2>RGB Colors</H2>
 <A NAME=MARKER-2-545></A><A NAME=MARKER-2-22></A>When using Color QuickDraw, you specify colors as RGB colors. An RGB color is defined by its red, green, and blue components. For example, when each of the red, green, and blue components of a color is at maximum intensity ($FFFF), the result is the color white. When each of the components has zero intensity ($0000), the result is the color black.<P>
 You specify a color to Color QuickDraw by creating an <CODE>RGBColor</CODE> record in which you use three 16-bit unsigned integers to assign intensity values for the three additive primary colors. The <CODE>RGBColor</CODE> data type is defined as follows.<P>
<PRE>
TYPE RGBColor\xF0= 
RECORD
   red:\xF0    Integer;    {red\xF0component}
   green:   Integer;    {green\xF0component}
   blue:    Integer;    {blue\xF0component}
END;
</PRE>
 When you specify an RGB color in an <CODE>RGBColor</CODE> record and then draw with that color, Color QuickDraw translates that color to the various indexed or direct devices that your user may be using. <P>
 <A NAME=MARKER-2-23></A>For example, your application can use Color QuickDraw to display images containing up to 256 different colors on indexed devices. An <B>indexed device</B> is a graphics device--that is, a plug-in video card, a video interface built into a Macintosh computer, or an offscreen graphics world--that supports up to 256 colors in a color lookup table. Indexed devices support pixels of 1-bit, 2-bit, 4-bit, or 8-bit depths. On indexed devices, each pixel is represented in memory by an index to the graphics device's color lookup table (also known as the <I>CLUT</I>), where the currently available colors are stored. Such images, although limited in hue, take up relatively small amounts of memory. Color QuickDraw, working with the Color Manager, automatically matches the color your application specifies to the closest available color in the CLUT. <P>
 Your application can use the Palette Manager, described in the chapter "Palette Manager" in <I>Inside Macintosh: Advanced Color Imaging,</I> to exercise greater control of the colors in the CLUT. Note, however, that some Macintosh computers--such as black-and-white and grayscale PowerBook computers--have a fixed CLUT, which your application cannot change.<A NAME=MARKER-2-24></A><P>
 <A NAME=MARKER-2-25></A>On direct devices, your application can use Color QuickDraw to display images containing thousands or millions of different colors. A <B>direct device</B> is a graphics device that supports up to 16 million colors having a direct correlation between a value placed in the graphics device and the color displayed onscreen. On attached direct devices, each pixel is represented in memory by the most significant bits of the actual red, green, and blue component values specified in an <CODE>RGBColor</CODE> record by your application. <A NAME=MARKER-2-590></A><P>
 Other output devices may render colors that differ from RGB colors; for example, many color printers work with CMYK (cyan, magenta, yellow, and black) colors. See <I><A HREF="../ACI/ACI-2.html">Advanced Color Imaging on the Mac OS</A></I> for information about color matching between screens, which use RGB colors, and devices--like printers--that use CMYK or other colors.<A NAME=MARKER-9-173></A><A NAME=MARKER-2-43></A><P>
<A NAME=HEADING198-13></A>
<H2>The Color Drawing Environment: Color Graphics Ports</H2>
 <A NAME=MARKER-2-29></A>A color graphics port defines a complete drawing environment that determines where and how color graphics operations take place. As with basic graphics ports, you can open many color graphics ports at once. Each color graphics port has its own local coordinate system, drawing pattern, background pattern, pen size and location, foreground color, background color, and pixel map. Using the <CODE>SetPort</CODE> procedure (described in the chapter "Basic QuickDraw"), or the <CODE>SetGWorld</CODE> procedure (described in the chapter "Offscreen Graphics Worlds"), you can instantly switch from one color or basic graphics port to another.<P>
 When you use Window Manager and Dialog Manager routines and resources to create color windows, dialog boxes, and alert boxes, these managers automatically create color graphics ports for you. As described in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>, for example, a color graphics port is automatically created when you use the Window Manager function <CODE>GetNewCWindow</CODE> or <CODE>NewCWindow</CODE>. Color graphics ports are automatically created when your application provides the color-aware resources <CODE>'dctb'</CODE> and <CODE>'actb'</CODE> and then uses the Dialog Manager routines <CODE>GetNewDialog</CODE> and <CODE>Alert</CODE>.<A NAME=MARKER-2-30></A><P>
 A color graphics port is defined by a <CODE>CGrafPort</CODE> record, which is diagrammed in <BR><A HREF=#MARKER-9-31>Figure 4-1</A>. Some aspects of its contents are discussed after the figure; see <A HREF=QuickDraw-203.html#MARKER-9-189>page 4-39</A> for a complete description of the fields. Your application generally should not directly set any fields of a <CODE>CGrafPort</CODE> record; instead you should use the QuickDraw routines described in this book to manipulate them.<P>
<B>Figure 4-1  <A NAME=MARKER-9-31></A>The color graphics port</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-01.jpg"><BR>
 <A NAME=MARKER-2-32></A><A HREF=QuickDraw-213.html#MARKER-9-6>Table 4-3 on page 4-55</A> shows initial values for a <CODE>CGrafPort</CODE> record. A <CODE>CGrafPort</CODE> record is the same size as a <CODE>GrafPort</CODE> record (described in the chapter "Basic QuickDraw"), and most of the fields are identical for these two records. The important differences between these two data types are listed here:<P>
<UL>
<LI>In a <CODE>GrafPort</CODE> record, the <CODE>portBits</CODE> field contains a complete 14-byte <CODE>BitMap</CODE> record. In a <CODE>CGrafPort</CODE> record, this field is partly replaced by the 4-byte <CODE>portPixMap</CODE> field; this field contains a handle to a <CODE>PixMap</CODE> record. 
<LI>In what would be the <CODE>rowBytes</CODE> field of the <CODE>BitMap</CODE> record stored in the <CODE>portBits</CODE> field of a <CODE>GrafPort</CODE> record, a <CODE>CGrafPort</CODE> record has a 2-byte <CODE>portVersion</CODE> field in which the 2 high bits are always set. QuickDraw uses these bits to distinguish <CODE>CGrafPort</CODE> records from <CODE>GrafPort</CODE> records, in which the 2 high bits of the <CODE>rowBytes</CODE> field are always clear.
<LI>Following the <CODE>portVersion</CODE> field in the <CODE>CGrafPort</CODE> record is the <CODE>grafVars</CODE> field, which contains a handle to a <CODE>GrafVars</CODE> record; this handle is not included in a <CODE>GrafPort</CODE> record. The <CODE>GrafVars</CODE> record contains color information used by Color QuickDraw and the Palette Manager.
<LI>In a <CODE>GrafPort</CODE> record, the <CODE>bkPat</CODE>, <CODE>pnPat</CODE>, and <CODE>fillPat</CODE> fields hold 8-byte bit patterns. In a <CODE>CGrafPort</CODE> record, these fields are partly replaced by three 4-byte handles to pixel patterns. The resulting 12 bytes of additional space are taken up by the <CODE>rgbFgColor</CODE> and <CODE>rgbBkColor</CODE> fields, which contain 6-byte <CODE>RGBColor</CODE> records specifying the optimal foreground and background colors for the color graphics port. Note that the closest matching available colors, which Color QuickDraw actually uses for the foreground and background, are stored in the <CODE>fgColor</CODE> and <CODE>bkColor</CODE> fields of the <CODE>CGrafPort</CODE> record.
<LI>In a <CODE>GrafPort</CODE> record, you can supply the <CODE>grafProcs</CODE> field with a pointer to a <CODE>QDProcs</CODE> record that your application can store into if you want to customize QuickDraw drawing routines or use QuickDraw in other advanced, highly specialized ways. If you supply custom QuickDraw drawing routines in a <CODE>CGrafPort</CODE> record, you must provide this field with a pointer to a data structure of type <CODE>CQDProcs</CODE>.<P>
</UL>
 Working with a <CODE>CGrafPort</CODE> record is much like using a <CODE>GrafPort</CODE> record. The routines <CODE>SetPort</CODE>, <CODE>GetPort</CODE>, <CODE>PortSize</CODE>, <CODE>SetOrigin</CODE>, <CODE>SetPortBits</CODE>, and <CODE>MovePortTo</CODE> operate on either port type, and the global variable <CODE>ThePort</CODE> points to the current graphics port no matter which type it is. (Remember that drawing always takes place in the current graphics port.) These routines are described in the chapter "Basic QuickDraw."<P>
 If you find it necessary, you can use type coercion to convert between <CODE>GrafPtr</CODE> and <CODE>CGrafPtr</CODE> records. For example:<P>
<PRE>
VAR myPort: CGrafPtr;
SetPort (GrafPtr(myPort));
</PRE>
<DL>
<DT><B>Note</B>
<DD>You can use all QuickDraw drawing commands when drawing into a graphics port created with a <CODE>CGrafPort</CODE> record, and you can use all Color QuickDraw drawing commands (such as <CODE>FillCRect</CODE>) when drawing into a graphics port created with a <CODE>GrafPort</CODE> record. However, Color QuickDraw drawing commands used with a <CODE>GrafPort</CODE> record don't take advantage of Color QuickDraw's color features.<EM></EM><A NAME=MARKER-2-263></A><A NAME=MARKER-2-264></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 While the <CODE>CGrafPort</CODE> record contains information for a color window, there can be many windows on a screen, and even more than one screen. The <CODE>GDevice</CODE> record, described in the chapter "Graphics Devices," is the data structure that holds state information about a graphics device--such as the size of its boundary rectangle and whether the device is indexed or direct. Like the graphics port, the <CODE>GDevice</CODE> record is created automatically for you: QuickDraw uses information supplied by the Slot Manager to create a <CODE>GDevice</CODE> record for each graphics device found during startup. Many applications can let Color QuickDraw manage multiple screens of differing pixel depths. If your application needs more control over graphics device management--if your application needs certain screen depths to function effectively, for example--you can use the routines described in the chapter "Graphics Devices."<P>
<A NAME=HEADING198-30></A>
<H3><A NAME=MARKER-9-35></A>Pixel Maps</H3>
 The <CODE>portPixMap</CODE> field of a <CODE>CGrafPort</CODE> record contains a handle to a <B>pixel map,</B> a data structure of type <CODE>PixMap</CODE>. Just as basic QuickDraw does all of its drawing in a bitmap, Color QuickDraw draws in a pixel map. <A NAME=MARKER-2-36></A><P>
 <A NAME=MARKER-2-266></A><A NAME=MARKER-2-265></A><A NAME=MARKER-2-39></A>The representation of a color image in memory is a<B> pixel image,</B> analogous to the bit image used by basic QuickDraw. A <CODE>PixMap</CODE> record includes a pointer to a pixel image, its dimensions, storage format, depth, resolution, and color usage. The pixel map is diagrammed in <A HREF=#MARKER-9-40>Figure 4-2</A>. Some aspects of its contents are discussed after the figure; see <A HREF=QuickDraw-202.html#MARKER-9-165>page 4-37</A> for a complete description of its fields.<P>
<B>Figure 4-2  <A NAME=MARKER-9-40></A>The pixel map</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-02.jpg"><BR>
 The <CODE>baseAddr</CODE> field of a <CODE>PixMap</CODE> record contains a pointer to the beginning of the onscreen pixel image for a pixel map. The pixel image that appears on a screen is normally stored on a graphics card rather than in main memory. (There can be several pixel maps pointing to the same pixel image, each imposing its own coordinate system on it.) <P>
 As with a bitmap, the pixel map's boundary rectangle is initially set to the size of the main screen. However, you should never use a pixel map's boundary rectangle to determine the size of the screen; instead use the value of the <CODE>gdRect</CODE> field of the <CODE>GDevice</CODE> record for the screen, as described in the chapter "Graphics Devices" in this book.<P>
 <A NAME=MARKER-2-316></A><A NAME=MARKER-2-42></A>The number of bits per pixel in the pixel image is called the <B>pixel depth.</B> Pixels on indexed devices can be 1, 2, 4, or 8 bits deep. (A pixel image that is 1 bit deep is equivalent to a bit image.) Pixels on direct devices can be 16 or 32 bits deep. (Even if your application creates a basic graphics port on a direct device, pixels are never less than one of these two depths.) When a user uses the Monitors control panel to set a 16-bit or 32-bit direct device to use 2, 4, 16, or 256 colors as a grayscale or color device, the direct device creates a CLUT and operates like an indexed device.<P>
 <A NAME=MARKER-2-43></A>When your application specifies an RGB color for some pixel in a pixel image, Color QuickDraw translates that color into a value appropriate for display on the user's screen; Color QuickDraw stores this value in the pixel. The<B> pixel value</B> is a number used by system software and a graphics device to represent a color. The translation from the color you specify in an <CODE>RGBColor</CODE> record to a pixel value is performed at the time you draw the color. The process differs for indexed and direct devices, as described here.<P>
<UL>
<LI>When drawing on indexed devices, Color QuickDraw calls the Color Manager to supply the index to the color that most closely matches the requested color in the current device's CLUT. This index becomes the pixel value for that color. 
<LI>When drawing on direct devices, Color QuickDraw truncates the least significant bits from the <CODE>red</CODE>, <CODE>green</CODE>, and <CODE>blue</CODE> fields of the <CODE>RGBColor</CODE> record. This becomes the pixel value that Color QuickDraw sends to the graphics device.<A NAME=MARKER-2-44></A><P>
</UL>
 This process is described in greater detail in <A HREF=#MARKER-9-55>"Color QuickDraw's Translation of RGB Colors to Pixel Values" beginning on page 4-10</A>.<P>
 The <CODE>hRes</CODE> and <CODE>vRes</CODE> fields of the <CODE>PixMap</CODE> record describe the horizontal and vertical resolution of the image in pixels per inch, abbreviated as dpi (dots per inch). The values for these fields are of type <CODE>Fixed</CODE>; by default, the value for each is $00480000 (for 72 dpi), but Color QuickDraw supports <CODE>PixMap</CODE> records of other resolutions. For example, <CODE>PixMap</CODE> records for scanners and frame grabbers can have dpi resolutions of 150, 200, 300, or greater.<A NAME=MARKER-2-549></A><P>
 The <CODE>pixelType</CODE> field of the <CODE>PixMap</CODE> record specifies the format--indexed or direct--used to hold the pixels in the image. For indexed devices the value is 0; for direct devices it is 16 (which can be represented by the constant <CODE>RGBDirect</CODE>).<P>
 The <CODE>pixelSize</CODE> field specifies the pixel depth. Indexed devices can be 1, 2, 4, or 8 bits deep; direct devices can be 16 or 32 bits deep.<P>
 The <CODE>cmpCount</CODE> and <CODE>cmpSize</CODE> fields describe how the pixel values are organized. For pixels on indexed devices, the color component count (stored in the <CODE>cmpCount</CODE> field) is 1--for the index into the graphics device's CLUT, where the colors are stored. For pixels on direct devices, the color component count is 3--for the red, green, and blue components of each pixel.<P>
 The <CODE>cmpSize</CODE> field specifies how large each color component is. For indexed devices it is the same value as that in the <CODE>pixelSize</CODE> field: 1, 2, 4, or 8 bits. For direct pixels, each of the three color components can be either 5 bits for a 16-bit pixel (1 of these 16 bits is unused), or 8 bits for a 32-bit pixel (8 of these 32 bits are unused).<P>
 The <CODE>planeBytes</CODE> field specifies an offset in bytes from one plane to another. Since Color QuickDraw doesn't support multiple-plane images, the value of this field is always 0.<P>
 <A NAME=MARKER-2-2></A>Finally, the <CODE>pmTable</CODE> field contains a handle to the <CODE>ColorTable</CODE> record. <B>Color tables</B> define the colors available for pixel images on indexed devices. (The Color Manager stores a color table for the currently available colors in the graphics device's CLUT; you can use the Palette Manager to assign different color tables to your different windows.) You can create color tables using either <CODE>ColorTable</CODE> records (described on <A HREF=QuickDraw-206.html#MARKER-9-264>page 4-47</A>) or color table (<CODE>'clut'</CODE>) resources (described on <A HREF=QuickDraw-267.html#MARKER-9-618>page 4-94</A>). Pixel images on direct devices don't need a color table because the colors are stored right in the pixel values; in such cases the <CODE>pmTable</CODE> field points to a dummy color table.<A NAME=MARKER-2-47></A><A NAME=MARKER-2-48></A><A NAME=MARKER-2-49></A><A NAME=MARKER-2-50></A><P>
<DL>
<DT><B>Note</B>
<DD>The pixel map for a window's color graphics port always consists of the pixel depth, color table, and boundary rectangle of the main screen, even if the window is created on or moved to an entirely different screen.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING198-50></A>
<H3>Pixel Patterns</H3>
 <A NAME=MARKER-2-51></A>Color QuickDraw supplements the black-and-white patterns of basic QuickDraw with pixel patterns, which can use colors at any pixel depth and can be of any width and height that's a power of 2. A <B>pixel pattern</B> defines a repeating design (such as stripes of different colors) or a color otherwise unavailable on indexed devices. For example, if your application draws to an indexed device that supports 4 bits per pixel, your application has 16 colors available if it simply sets the foreground color and draws. However, if your application uses the <CODE>MakeRGBPat</CODE> procedure to create patterns that use these 16 colors in various combinations, and then draws using that pattern, your application can effectively have as many as 125 approximated colors at its disposal. For example, you can specify a purple color to <CODE>MakeRGBPat</CODE>, which creates a pattern that mixes blue and red pixels.<A NAME=MARKER-2-317></A><P>
 As with bit patterns (described in the chapter "QuickDraw Drawing"), your application can use pixel patterns to draw lines and shapes on the screen. In a color graphics port, the graphics pen has a pixel pattern specified in the <CODE>pnPixPat</CODE> field of the <CODE>CGrafPort</CODE> record. This pixel pattern acts like the ink in the pen; the pixels in the pattern interact with the pixels in the pixel map according to the pattern mode of the graphics pen. When you use the <CODE>FrameRect</CODE>, <CODE>FrameRoundRect</CODE>, <CODE>FrameArc</CODE>, <CODE>FramePoly</CODE>, <CODE>FrameRgn</CODE>, <CODE>PaintRect</CODE>, <CODE>PaintRoundRect</CODE>, <CODE>PaintArc</CODE>, <CODE>PaintPoly</CODE>, and <CODE>PaintRgn</CODE> procedures (described in the chapter "QuickDraw Drawing") to draw shapes, these procedures draw the shape with the pattern specified in the <CODE>pnPixPat</CODE> field. Initially, every <BR>graphics pen is assigned an all-black pattern, but you can use the <CODE>PenPixPat</CODE> <BR>procedure to assign a different pixel pattern to the graphics pen.<P>
 You can use the <CODE>FillCRect</CODE>, <CODE>FillCRoundRect</CODE>, <CODE>FillCArc</CODE>, <CODE>FillCPoly</CODE>, and <CODE>FillCRgn</CODE> procedures (described later in this chapter) to draw shapes with a pixel pattern other than the one specified in the <CODE>pnPixPat</CODE> field. When your application uses one of these procedures, the procedure stores the pattern your application specifies in the <CODE>fillPixPat</CODE> field of the <CODE>CGrafPort</CODE> record and then calls a low-level drawing routine that gets the pattern from that field.<P>
 Each graphics port also has a background pattern that's used when an area is erased (for example, by the <CODE>EraseRect</CODE>, <CODE>EraseRoundRect</CODE>, <CODE>EraseArc</CODE>, <CODE>ErasePoly</CODE>, and <CODE>EraseRgn</CODE> procedures, described in the chapter "QuickDraw Drawing") and when pixels are scrolled out of an area by the <CODE>ScrollRect</CODE> procedure, described in the chapter "Basic QuickDraw." Every color graphics port stores a background pixel pattern in the <CODE>bkPixPat</CODE> field of its <CODE>CGrafPort</CODE> record. Initially, every graphics port is assigned an all-white background pattern, but you can use the <CODE>BackPixPat</CODE> procedure to assign a different pixel pattern.<P>
 You can create your own pixel patterns in your program code, but it's usually simpler and more convenient to store them in resources of type <CODE>'ppat'</CODE>.<P>
 Each pixel map has its own color table; therefore, pixel patterns can consist of any number of colors, and they don't usually require the graphics port's foreground and background colors to have particular values. <A NAME=MARKER-2-53></A><P>
<DL>
<DT><B>Note</B>
<DD>Color QuickDraw also supports bit patterns. When used in a <CODE>CGrafPort</CODE> record, such patterns are limited to 8-by-8 bit dimensions and are always drawn using the values in the <CODE>fgColor</CODE> and <CODE>bkColor</CODE> fields of the <CODE>CGrafPort</CODE> record.<EM></EM><A NAME=MARKER-2-313></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING198-58></A>
<H3><A NAME=MARKER-9-55></A>Color QuickDraw's Translation of RGB Colors to Pixel Values</H3>
 <A NAME=MARKER-2-554></A><A NAME=MARKER-2-267></A>When using Color QuickDraw, your application refers to a color only through the three 16-bit fields of a 48-bit <CODE>RGBColor</CODE> record; you use these fields to specify the red, green, and blue components of your desired color. When your application draws into a pixel map, Color QuickDraw and the Color Manager translate your <CODE>RGBColor</CODE> records into pixel values; these pixel values are sent to your users' graphics devices, which display the pixels accordingly. <P>
 Your application never needs to handle pixel values. However, to clarify the relation between your application's 48-bit <CODE>RGBColor</CODE> records and the pixels that are actually displayed, this section presents some examples of how Color QuickDraw derives pixel values from your <CODE>RGBColor</CODE> records.<P>
 <A NAME=MARKER-2-271></A><A NAME=MARKER-2-59></A>Indexed devices were introduced to support--with minimal memory requirements--the color capabilities of the Macintosh II computer. The pixel value for any color on an indexed device is represented by a single byte. Each byte contains an index number that specifies one of 256 colors available on the device's CLUT. This index number is the pixel value for the pixel. (Some indexed devices support 1-bit, 2-bit, or 4-bit pixel values, resulting in tables containing 2, 4, or 16 colors, respectively, as shown in <A HREF="ColorPlate1.html">Plate 1</A> in the front of this book.)<P>
 To obtain an 8-bit pixel value from the 48-bit <CODE>RGBColor</CODE> record specified by your application, Color QuickDraw calls on the Color Manager to determine the closest RGB color stored in the CLUT on the current device. The index number to that color is then stored in the 8-bit pixel. <P>
 For example, the <CODE>RGBColor</CODE> record for a medium green pixel is represented on the left side of <A HREF=#MARKER-9-60>Figure 4-3</A>. An application might create such a record and pass it to the <CODE>RGBForeColor</CODE> procedure, which sets the foreground color for drawing. In system software's standard 8-bit color lookup table (which is defined in a <CODE>'clut'</CODE> resource with the resource ID of 8), the closest color to that medium green is stored as table entry 161. When the next pixel is drawn, this index number is stored in the pixel image as the pixel value.<P>
<B>Figure 4-3  <A NAME=MARKER-9-60></A><A NAME=MARKER-21-61></A>Translating a 48-bit <CODE>RGBColor</CODE> record to an 8-bit pixel value on an indexed device</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-10.jpg"><BR>
 The application might later use the <CODE>GetCPixel</CODE> procedure to determine the color of a particular pixel. As shown in <A HREF=#MARKER-9-64>Figure 4-4</A>, the Color Manager uses the index number stored as the pixel value to find the 48-bit <CODE>RGBColor</CODE> record stored in the CLUT for that pixel's color--which, as with the medium green in this example, is not necessarily the exact color first specified by the application. The difference, however, is imperceptible.<A NAME=MARKER-2-62></A><A NAME=MARKER-2-37></A><P>
<B>Figure 4-4  <A NAME=MARKER-9-64></A><A NAME=MARKER-21-65></A>Translating an 8-bit pixel value on an indexed device to a 48-bit <CODE>RGBColor</CODE> record</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-11.jpg"><BR>
 <A NAME=MARKER-2-66></A><A NAME=MARKER-2-268></A>Direct devices support 32-bit and 16-bit pixel values. Direct devices do not use tables to store and look up colors, nor do their pixel values consist of index numbers. For each pixel on a direct device, Color QuickDraw instead derives the pixel value by concatenating the values of the <CODE>red</CODE>, <CODE>green</CODE>, and <CODE>blue</CODE> fields of an <CODE>RGBColor</CODE> record. <P>
 As shown in <A HREF=#MARKER-9-68>Figure 4-5</A>, Color QuickDraw converts a 48-bit <CODE>RGBColor</CODE> record into a 32-bit pixel value by storing the most significant 8 bits of each 16-bit field of the <CODE>RGBColor</CODE> record into the lower 3 bytes of the pixel value, leaving 8 unused bits in the high byte of the pixel value.<P>
<B>Figure 4-5  <A NAME=MARKER-9-68></A><A NAME=MARKER-21-69></A>Translating a 48-bit <CODE>RGBColor</CODE> record to a 32-bit pixel value on a direct device</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-06.jpg"><BR>
 Color QuickDraw converts a 48-bit <CODE>RGBColor</CODE> record into a 16-bit pixel value by storing the most significant 5 bits of each 16-bit field of the <CODE>RGBColor</CODE> record into the lower 15 bits of the pixel value, leaving an unused high bit, as shown in <A HREF=#MARKER-9-70>Figure 4-6</A>.<P>
<B>Figure 4-6  <A NAME=MARKER-9-70></A><A NAME=MARKER-21-71></A>Translating a 48-bit <CODE>RGBColor</CODE> record to a 16-bit pixel value on a direct device</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-07.jpg"><BR>
 <A HREF=#MARKER-9-72>Figure 4-7</A> shows how Color QuickDraw expands a 32-bit pixel value to a 48-bit <CODE>RGBColor</CODE> record by dropping the unused high byte of the pixel value and doubling each of its 8-bit components. Note that the resulting 48-bit value differs in the least significant 8 bits of each component from the original <CODE>RGBColor</CODE> record in <A HREF=#MARKER-9-68>Figure 4-5</A>.<P>
<B>Figure 4-7  <A NAME=MARKER-9-72></A><A NAME=MARKER-21-73></A>Translating a 32-bit pixel value to a 48-bit <CODE>RGBColor</CODE> record</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-08.jpg"><BR>
 <A HREF=#MARKER-9-77>Figure 4-8</A> shows how Color QuickDraw expands a 16-bit pixel value to a 48-bit <CODE>RGBColor</CODE> record by dropping the unused high bit of the pixel value and inserting three copies of each 5-bit component and a copy of the most significant bit into each 16-bit field of the <CODE>RGBColor</CODE> record. Note that the result differs (in the least significant 11 bits of each component) from the original 48-bit value in <A HREF=#MARKER-9-68>Figure 4-5</A>. The difference, however, is imperceptible.<A NAME=MARKER-2-273></A><A NAME=MARKER-2-75></A><A NAME=MARKER-2-76></A><P>
<B>Figure 4-8  <A NAME=MARKER-9-77></A><A NAME=MARKER-21-78></A>Translating a 16-bit pixel value to a 48-bit <CODE>RGBColor</CODE> record</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-09.jpg"><BR>
<A NAME=HEADING198-82></A>
<H3><A NAME=MARKER-21-79></A>Colors on Grayscale Screens</H3>
 <A NAME=MARKER-2-269></A>When Color QuickDraw displays a color on a grayscale screen, it computes the <B>luminance,</B> or intensity of light, of the desired color and uses that value to determine the appropriate gray value to draw. A grayscale graphics device can be a color graphics device that the user sets to grayscale by using the Monitors control panel; for such a graphics device, Color QuickDraw places an evenly spaced set of grays, forming a linear ramp from white to black, in the graphics device's CLUT. (When a user uses the Monitors control panel to set a 16-bit or 32-bit direct device to use 2, 4, 16, or 256 colors as a grayscale or color device, the direct device creates a CLUT and operates like an indexed device.)<A NAME=MARKER-2-81></A><P>
 By using the <CODE>GetCTable</CODE> function, described on <A HREF=QuickDraw-252.html#MARKER-9-544>page 4-83</A>, your application can obtain the default color tables for various graphics devices, including grayscale devices.<A NAME=MARKER-2-318></A><A NAME=MARKER-2-83></A><P>

</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-197.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-199.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
