<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Code Size Performance Guidelines: Improving Locality of Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Improving Locality of Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001862" title="Improving Locality of Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000430" target="_top">Performance</a> &gt; <a href="../../../Tools-date.html#//apple_ref/doc/uid/TP30000440-TP30000430-TP30000463" target="_top">Tools</a> &gt; <a href="../index.html" target="_top">Code Size Performance Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="CompilerOptions.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="SharedPages.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20001862-CJBJFIDD" title="Improving Locality of Reference"></a><hr /><H1>Improving Locality of Reference</H1>

<p>An important improvement you can make to your application’s performance is to reduce the number of virtual memory pages used by the application at any given time. This set of pages is referred to as the <strong>working set</strong><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_19"></a> and consists of application code and runtime data. Reducing the amount of in-memory data is a function of your algorithms, but reducing the amount of in-memory code can be achieved by a process called <strong>scatter loading</strong><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_20"></a>. This technique is also referred to as improving the locality of reference of your code.</p>
<p>Normally, compiled code for methods and functions is organized by source file in the resulting binary. Scatter loading changes this organization and instead groups related methods and functions together, independent of the original locations of those methods and functions. This process allows the kernel to keep an active application’s most frequently referenced executable pages in the smallest memory space possible. Not only does this reduce the footprint of the application, it reduces the likelihood of those pages being paged out.</p>
<div class="importantbox"><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_5" title="Important:"></a><p><strong>Important:</strong>&nbsp;

You should generally wait until very late in the development cycle to scatter load your application. Code tends to get moved around during development, which can invalidate prior profiling results.</p><p></p></div>

<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-106785-TPXREF102">Profiling Code With gprof</a>
				
			<br/>
			
        
			
			
				<a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-138832">Profiling With the Monitor Functions</a>
				
			<br/>
			
        
			
			
				<a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-111363">Organizing Code at Compile Time</a>
				
			<br/>
			
        
			
			
				<a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-111686-TPXREF124">Reordering the __text Section</a>
				
			<br/>
			
        
			
			
				<a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-110250-TPXREF108">Reordering Other Sections</a>
				
			<br/>
			
        
			
			
				<a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-104673-BCIGJDHD">Reordering Assembly Language Code</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001862-106785" title="Profiling Code With gprof"></a><a name="//apple_ref/doc/uid/20001862-106785-TPXREF102" title="Profiling Code With gprof"></a><h2>Profiling Code With gprof</h2>
<p><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_21"></a><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_22"></a>Given profiling data collected at runtime, <code>gprof</code> produces an execution profile of a program. The effect of called routines is incorporated in the profile of each caller. The profile data is taken from the call graph profile file (<code>gmon.out</code> by default), which is created by a program compiled and linked with the <code>-pg</code> option. The symbol table in the executable is correlated with the call graph profile file. If more than one profile file is specified, the <code>gprof</code> output shows the sum of the profile information in the given profile files.<a name="//apple_ref/doc/uid/20001862-DontLinkElementID_23"></a></p>
<p>The <code>gprof</code> tool is useful for many purposes, including the following:</p>
<ul class="ul"><li class="li"><p>cases where the Sampler application doesn’t work well, such as command-line tools or applications that quit after a short period of time</p></li>
<li class="li"><p>cases where you want a call graph that includes all the code that might be called in a given program, rather than a periodic sampling of calls</p></li>
<li class="li"><p>cases where you want to change the link order of your code to optimize the code locality</p></li></ul>
<a name="//apple_ref/doc/uid/20001862-106854" title="Generating Profiling Data"></a><h3>Generating Profiling Data</h3>
<p>Before you can profile your application, you must set up your project to generate profiling information. To generate profiling information for your Xcode project, you must modify your target or build-style settings to include the “Generate profiling code” option. (See the Xcode Help for information on enabling target and build-style settings.)</p>
<p>The profiling code inside your program generates a file called <code>gmon.out</code> with the profiling information. (Usually, this file is placed in the current working directory.) To analyze the data in this file, copy it to the directory containing your executable prior to calling <code>gprof</code>, or just specify the path to <code>gmon.out</code> when you run <code>gprof</code>.</p>
<p>In addition to profiling your own code, you can find out how much time is spent in Carbon and Cocoa frameworks by linking against profile versions of those frameworks. To do this, add the <code>DYLD_IMAGE_SUFFIX</code> setting to your target or build style and set its value to <code>_profile</code>. The dynamic linker combines this suffix with the framework name to link against the profile version of the framework. To determine which frameworks support profiling, look at the frameworks themselves. For example, the Carbon library comes with both profile and debug versions. </p><div class="notebox"><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_6" title="Note"></a><p><strong>Note:</strong>&nbsp;Profile and debug versions of libraries are installed as part of the developer tools package and may not be available on user systems. Make sure your shipping executable does not link against one of these libraries.</p></div>
<a name="//apple_ref/doc/uid/20001862-117091" title="Generating Order Files"></a><a name="//apple_ref/doc/uid/20001862-117091-BCIBJEBH" title="Generating Order Files"></a><h3>Generating Order Files</h3>
<p>An order file contains an ordered sequence of lines, each line consisting of a source file name and a symbol name, separated by a colon with no other white space. Each line represents a block to be placed in a section of the executable. If you modify the file by hand, you must follow this format exactly so the linker can process the file. If the object file <em>name</em>:<em>symbol</em> name pair is not exactly the name seen by the linker, it tries its best to match up the names with the objects being linked.</p>
<p>The lines in an order file for procedure reordering consist of an object filename and procedure name (function, method, or other symbol). The sequence in which procedures are listed in the order file represents the sequence in which they are linked into the <code>__text</code> section of the executable.</p>
<p>To create an order file from the profiling data generated by using a program, run <code>gprof</code> using the <code>-S</code> option (see the man page for <code>gprof (1)</code>). For example,</p>
<div class="codesample"><table><tr><td scope="row"><pre>gprof -S MyApp.profile/MyApp gmon.out<span></span></pre></td></tr></table></div>
<p>The <code>-S</code> option produces four mutually exclusive order files:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p><code>gmon.order</code></p></td>
<td ><p>Ordering based on a “closest is best” analysis of the profiling call graph. Calls that call each other frequently are placed close together.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>callf.order</code></p></td>
<td ><p>Routines sorted by the number of calls made to each routine, largest numbers first.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>callo.order</code></p></td>
<td ><p>Routines sorted by the order in which they are called.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>time.order</code></p></td>
<td ><p>Routines sorted by the amount of CPU time spent, largest times first.</p></td>
</tr>

</table></div>
<p>You should try using each of these files to see which provides the largest performance improvement, if any. See <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-103710">“Using pagestuff to Examine Pages on Disk”</a></span> for a discussion of how to measure the results of the ordering.</p>
<p>These order files contain only those procedures used during profiling. The linker keeps track of missing procedures and links them in their default order after those listed in the order file. Static names for library functions are generated in the order file only if the project directory contains a file generated by the linker’s <code>-whatsloaded</code> option; see <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-103584">“Creating a Default Order File”</a></span> for details. </p>
<p>The <code>gprof -S</code> option doesn’t work with executables that have already been linked using an order file.</p>
<a name="//apple_ref/doc/uid/20001862-112550" title="Fixing Up Your Order Files"></a><h3>Fixing Up Your Order Files</h3>
<p>After you generate your order files, you should look through them and make sure they are correct. There are a number of cases where you need to edit your order files manually, including the following:</p>
<ul class="spaceabove"><li class="li"><p>Your executable contained assembly-language files.</p></li>
<li class="li"><p>You profiled a stripped executable.</p></li>
<li class="li"><p>Your executable contained files compiled without the <code>-g</code> option.</p></li>
<li class="li"><p>Your project defines internal labels (typically for <code>goto</code> statements).</p></li>
<li class="li"><p>You want to preserve the order of routines in a particular object file.</p></li></ul>
<p>If the definition of a symbol is located in an assembly file, a stripped executable file, or a file compiled without the <code>-g</code> option, <code>gprof</code> omits the source file name from the symbol’s entry in the order file. If your project uses such files, you must edit the order file manually and add the appropriate source filenames. Alternatively, you can delete the symbol references altogether to force the corresponding routines to be linked in default order.</p>
<p>If your code contains internal labels, you must remove those labels from the order files; otherwise, the function that defines the label will be split apart during the linking phase. You can prevent the inclusion of internal labels in assembly files altogether by prefixing them with the string <code>L_</code>. The assembler interprets symbols with this prefix as local to a particular function and strips them to prevent access by other tools such as <code>gprof</code>.</p>
<p>To preserve the order of routines in a particular object file, use the special symbol <code>.section_all</code>. For example, if the object file <code>foo.o</code> comes from assembly source and you want to link all of the routines without reordering them, delete any existing references to <code>foo.o</code> and insert the following line in the order file:</p>
<div class="codesample"><table><tr><td scope="row"><pre>foo.o:.section_all<span></span></pre></td></tr></table></div>
<p>This option is useful for object files compiled from assembly source, or for which you don’t have the source.</p>
<a name="//apple_ref/doc/uid/20001862-109955" title="Linking with an Order File"></a><a name="//apple_ref/doc/uid/20001862-109955-BCIFEIIB" title="Linking with an Order File"></a><h3>Linking with an Order File</h3>
<p>Once you’ve generated an order file, you can link the program using the <code>-sectorder</code> and <code>-e
start</code> options:</p>
<p><code>cc -o</code> <em>outputFile</em> <em>inputFile.o</em> <code>…
-sectorder __TEXT __text</code> <em>orderFile</em> <code>-e
start</code></p>
<p>To use an order file with a Xcode project, modify the “Other Linker Flags” option in the Deployment build style of your project. Add the text <code>-sectorder __TEXT __text</code> <em>orderFile</em> to this setting to specify your order file.</p>
<p>If any <em>inputFile</em> is a library rather than an object file, you may need to edit the order file before linking to replace all references to the object file with references to the appropriate library file. Again, the linker does its best to match names in the order file with the sources it is editing.</p>
<p>With these options, the linker constructs the executable file <em>outputFile</em> so that the contents of the <code>__TEXT</code> segment’s <code>__text</code> section are constructed from blocks of the input files’ <code>__text</code> sections. The linker arranges the routines in the input files in the order listed in <em>orderFile</em>.</p>
<p>As the linker processes the order file, it places the procedures whose object-file and symbol-name pairs aren’t listed in the order file into the <code>__text</code> section of <em>outputFile</em>. It links these symbols in the default order. Object-file and symbol-name pairs listed more than once always generate a warning, and the first occurrence of the pair is used.</p>
<p>By default, the linker prints a summary of the number of symbol names in the linked objects that are not in the order file, the number of symbol names in the order file that are not in the linked objects, and the number of symbol names it tried to match that were ambiguous. To request a detailed listing of these symbols, use the <code>-sectorder_detail</code> option.</p>
<p>The linker’s <code>-e start</code> option preserves the executable’s entry point. The symbol <code>start</code> (note the lack of a leading “<code>_</code>”) is defined in the C runtime shared library <code>/usr/bin/crt1.o</code>; it represents the first text address in your program when you link normally. When you reorder your procedures, you have to use this option to fix the entry point. Another way to do this is to make the line <code>/usr/lib/crt1.o:start</code> or <code>/usr/lib/crt1.o:section_all</code> the first line of your order file.</p>
<a name="//apple_ref/doc/uid/20001862-110125" title="Limitations of gprof Order Files"></a><a name="//apple_ref/doc/uid/20001862-110125-TPXREF149" title="Limitations of gprof Order Files"></a><h3>Limitations of gprof Order Files</h3>
<p>The <code>.order</code> files generated by <code>gprof</code> contain only those functions that were called or sampled when the executable was run. For library functions to appear correctly in the order file, a <code>whatsloaded</code> file produced by the linker should exist in the working directory.</p>
<p>The <code>-S</code> option does not work with executables that have already been linked with an order file.</p>
<p>Production of the <code>gmon.order</code> file can take a long time—it can be suppressed with the <code>-x</code> parameter.</p>
<p>Filenames will be missing for the following items: </p>
<ul class="spaceabove"><li class="li"><p>files compiled without the <code>-g</code> parameter</p></li>
<li class="li"><p>routines generated from assembly-language source</p></li>
<li class="li"><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_24"></a><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_25"></a><p>executables that have had their debugging symbols removed (as with the <code>strip</code> tool)</p></li></ul>
<a name="//apple_ref/doc/uid/20001862-138832" title="Profiling With the Monitor Functions"></a><h2>Profiling With the Monitor Functions</h2>
<p>The file <code>/usr/include/monitor.h</code> declares a set of functions that you can use to programmatically profile specific sections of your code. You can use these functions to gather statistics only for certain sections of your code, or for all of your code. You can then use the <code>gprof</code> tool to build call graph and other performance analysis data from the resulting file. <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-138857-BCIGGIII">Listing 1</a></span> shows how to use the monitor functions.</p>
<a name="//apple_ref/doc/uid/20001862-138857-BCIGGIII" title="Listing 1Using monitor functions"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001862-138857" title="Listing 1Using monitor functions"></a><strong>Listing 1&nbsp;&nbsp;</strong>Using monitor functions</p>
<div class="codesample"><table><tr><td scope="row"><pre>#include &lt;monitor.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* To start profiling: */<span></span></pre></td></tr><tr><td scope="row"><pre>    moninit();<span></span></pre></td></tr><tr><td scope="row"><pre>    moncontrol(1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* To stop, and dump to a file */<span></span></pre></td></tr><tr><td scope="row"><pre>    moncontrol(0);<span></span></pre></td></tr><tr><td scope="row"><pre>    monoutput("/tmp/myprofiledata.out");<span></span></pre></td></tr><tr><td scope="row"><pre>    monreset();<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/20001862-111363" title="Organizing Code at Compile Time"></a><h2>Organizing Code at Compile Time</h2>
<p>The GCC compiler lets you specify attributes on any function or variable you declare. The <code>section</code> attribute lets you tell GCC which segment and section you want a particular piece of code to be placed. </p>
<div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_7" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;
Do not use <code>section</code> attributes unless you understand the structure of Mach-O executables<a name="//apple_ref/doc/uid/20001862-DontLinkElementID_26"></a> and know the rules for placing functions and data in the corresponding segments. Placing a function or global variable in an inappropriate section may break your program.</p><p></p><div class="clear"></div></div>
<p>The <code>section</code> attribute takes several parameters that control where the resulting code is placed. At a minimum, you must specify a segment and section name for the code you want to place. Other options are also available and are described in the GCC documentation.</p>
<p>The following listing shows how you use the <code>section</code> attribute for a function. In this example, the <code>section</code> attribute is added to a forward declaration of the function. The attribute tells the compiler to place the function in a specific <code>__text</code> section of the executable. </p>
<div class="codesample"><table><tr><td scope="row"><pre>void MyFunction (int a) __attribute__((section("__TEXT,__text.10")));<span></span></pre></td></tr></table></div>
<p>The following listing shows some examples of how you can organize your global variables using the <code>section</code> attribute. </p>
<div class="codesample"><table><tr><td scope="row"><pre>extern const int x __attribute__((section("__TEXT,__my_const")));<span></span></pre></td></tr><tr><td scope="row"><pre>const int x=2;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern char foo_string[] __attribute__((section("__DATA,__my_data")));<span></span></pre></td></tr><tr><td scope="row"><pre>char foo_string[] = "My text string\n";<span></span></pre></td></tr></table></div>
<p>For detailed information on specifying <code>section</code> attributes, see the documentation for the GCC compiler in <code>/Developer/Documentation/DeveloperTools/gcc3</code>. </p>
<a name="//apple_ref/doc/uid/20001862-111686" title="Reordering the __text Section"></a><a name="//apple_ref/doc/uid/20001862-111686-TPXREF124" title="Reordering the __text Section"></a><h2>Reordering the __text Section</h2><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_27"></a><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_28"></a>
<p>As described in <span class="content_text"><a href="MachOOverview.html#//apple_ref/doc/uid/20001860-BAJGJEJC">“Overview of the Mach-O Executable Format,”</a></span> the <code>__TEXT</code> segment holds the actual code and read-only portions of your program. The compiler tools, by convention, place procedures from your <a name="//apple_ref/doc/uid/20001862-DontLinkElementID_29"></a>Mach-O object files (with extension <code>.o</code>) in the <code>__text</code> section of the <code>__TEXT</code> segment.</p>
<p>As your program runs, pages from the <code>__text</code> section are loaded into memory on demand, as routines on these pages are used. Code is linked into the <code>__text</code> section in the order in which it appears in a given source file, and source files are linked in the order in which they are listed on the linker command line (or in the order specifiable in <a name="//apple_ref/doc/uid/20001862-DontLinkElementID_30"></a>Xcode). Thus, code from the first object file is linked from start to finish, followed by code from the second file and third file and so on. </p>
<p>Loading code in the source file declaration order is rarely optimal. For example, suppose that certain methods or functions in your code are invoked repeatedly, while others are seldom used. Reordering the procedures to place frequently used code at the beginning of the <code>__text</code> section minimizes the average number of pages your application uses and thereby reduces paging activity.</p>
<p>As another example, suppose that all the objects defined by your code are initialized at the same time. Because the initialization routine for each class is defined in a separate source file, the initialization code is ordinarily distributed across the <code>__text</code> section. By contiguously reordering initialization code for all classes, you reduce the number of pages that need to be read in, enhancing initialization performance. The application requires just the small number of pages containing initialization code, rather than a larger number of pages, each containing a small piece of initialization code.</p>
<a name="//apple_ref/doc/uid/20001862-102991" title="Reordering Procedures"></a><a name="//apple_ref/doc/uid/20001862-102991-BCIHIDGE" title="Reordering Procedures"></a><h3>Reordering Procedures</h3><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_31"></a>
<p>Depending on the size and complexity of your application, you should pursue a strategy for ordering code that best improves the performance of your executable. Like most performance tuning, the more time you spend measuring and retuning your procedure order, the more memory you save. You can easily obtain a good first-cut ordering by running your application and sorting the routines by call frequency. The steps for this strategy are listed below and explained in more detail in the sections that follow:</p>
<ol class="ol"><li class="li"><p>Build a profile version of your application. This step generates an executable containing symbols used in the profiling and reordering procedures.</p></li>
<li class="li"><p>Run and use the application to create a set of profile data. Perform a series of functional tests, or have someone use the program for a test period.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_8" title="Important:"></a><p><strong>Important:</strong>&nbsp;

For best results, focus on the most typical usage pattern. Avoid using all the features of the application or the profile data might become diluted. For example, focus on launch time and the time to activate and deactivate your main window. Do not bring up ancillary windows.</p><p></p></div></li>
<li class="li"><p>Create order files. Order files list procedures in optimized order. The linker uses order files to reorder procedures in the executable.</p></li>
<li class="li"><p>Run the linker using the order files. This creates an executable with procedures linked into the <code>__text</code> section as specified in the order file.</p></li></ol>
<p>For information on profiling your code and generating and linking an order file, see <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-106785">“Profiling Code With gprof.”</a></span></p>
<a name="//apple_ref/doc/uid/20001862-103571" title="Procedure Reordering for Large Programs"></a><a name="//apple_ref/doc/uid/20001862-103571-TPXREF127" title="Procedure Reordering for Large Programs"></a><h3>Procedure Reordering for Large Programs</h3>
<p>For many programs, the ordering generated by the steps just described brings a substantial improvement over unordered procedures. For a simple application with few features, such an ordering represents most of the gains to be had by procedure reordering. However, larger applications and other large programs can benefit greatly from additional analysis. While order files based on call frequency or the call graph are a good start, you can use your knowledge of the structure of your application to further reduce the virtual-memory working set.</p>
<a name="//apple_ref/doc/uid/20001862-103584" title="Creating a Default Order File"></a><a name="//apple_ref/doc/uid/20001862-103584-BCIEFDCH" title="Creating a Default Order File"></a><h4>Creating a Default Order File</h4><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_32"></a>
<p>If you want to reorder an application’s procedures using techniques other than those described above, you may want to skip the profiling steps and just start with a <a name="//apple_ref/doc/uid/20001862-DontLinkElementID_33"></a>default order file that lists all the routines of your application. Once you have a list of the routines in suitable form, you can then rearrange the entries by hand or by using a sorting technique of your choice. You can then use the resulting order file with the linker’s <code>-sectorder</code> option as described in <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-109955">“Linking with an Order File.”</a></span> </p>
<p>To create a default order file, first run the linker with the <code>-whatsloaded</code> option:</p>
<p><code>cc -o</code> <em>outputFile inputFile.o</em> <code>-whatsloaded ></code> <em>loadedFile</em></p>
<p>This creates a file, <em>loadedFile</em>, that lists the object files loaded in the executable, including any in frameworks or other libraries. The <code>-whatsloaded</code> option can also be used to make sure that order files generated by <code>gprof
-S</code> include names for procedures in static libraries.</p>
<p>Using the file <em>loadedFile</em>, you can run <code>nm</code> with the <code>-onjls</code> options and the <code>__TEXT __text</code> argument:</p>
<p><code>nm -onjls __TEXT __text `cat</code> <em>loadedFile</em><code>`
></code> <em>orderFile</em></p>
<p>The content of the file <em>orderFile</em> is the symbol table for the text section. Procedures are listed in the symbol table in their default link order. You can rearrange entries in this file to change the order in which you want procedures to be linked, then run the linker as described in <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-109955">“Linking with an Order File.”</a></span></p>
<a name="//apple_ref/doc/uid/20001862-103710" title="Using pagestuff to Examine Pages on Disk"></a><a name="//apple_ref/doc/uid/20001862-103710-BCIFCBDI" title="Using pagestuff to Examine Pages on Disk"></a><h4>Using pagestuff to Examine Pages on Disk</h4><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_34"></a><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_35"></a>
<p>The <code>pagestuff</code> tool helps you measure the effectiveness of your procedure ordering by telling you which pages of the executable file are likely to be loaded in memory at a given time. This section briefly describes how to use this tool. See the <code>pagestuff</code> man page for more information.</p>
<p>The <code>pagestuff</code> tool prints out the symbols on a particular page of executable code. The following is the syntax for the command:</p>
<p><code>pagestuff</code> <em>filename</em> [<em>pageNumber</em> |<code> -a</code>] </p>
<p>The output of <code>pagestuff</code> is a list of procedures contained in <em>filename</em> on page <em>pageNumber</em>. To view all the pages of the file, use the <code>-a</code> option in place of the page number. This output allows you to determine if each page associated with the file in memory is optimized. If it isn’t, you can rearrange entries in the order file and link the executable again to maximize performance gains. For example, move two related procedures together so they are linked on the same page. Perfecting the ordering may require several cycles of linking and tuning.</p>
<a name="//apple_ref/doc/uid/20001862-103785" title="Grouping Routines According to Usage"></a><a name="//apple_ref/doc/uid/20001862-103785-BCIFAHAC" title="Grouping Routines According to Usage"></a><h4>Grouping Routines According to Usage</h4><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_36"></a><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_37"></a>
<p>Why generate profile data for individual operations of your application? The strategy is based on the assumption that a large application has three general groups of routines:</p>
<ul class="spaceabove"><li class="li"><p><strong>Hot routines</strong> run during the most common usage of the application. These are often primitive routines that provide a foundation for the application’s features (for example, routines for accessing a document’s data structures) or routines that implement the core features of an application, such as routines that implement typing in a word processor. These routines should be clustered together in the same set of pages.</p></li>
<li class="li"><p><strong>Warm routines</strong> implement specific features of the application. Warm routines are usually associated with particular features that user performs only occasionally (such as launching, printing, or importing graphics). Because these routines are used reasonably often, cluster them in the same small set of pages so they will load quickly. However, because there are long periods when users aren’t accessing this functionality, these routines should not be located in the hot category.</p></li>
<li class="li"><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_38"></a><p><strong>Cold routines</strong> are rarely used in the application. Cold routines implement obscure features or cover boundary or error cases. Group these routines together to avoid wasting space on a hot or warm page. </p></li></ul>
<p>At any given time, you should expect most of the hot pages to be resident, and you should expect the warm pages to be resident for the features that the user is currently using. Only very rarely should a cold page be resident.</p>
<p>To achieve this ideal ordering, gather a number of profile data sets. First, gather the hot routines. As described above, compile the application for profiling, launch it, and use the program. Using <code>gprof
-S</code>, generate a frequency sorted order file called <code>hot.order</code> from the profile data.</p>
<p>After creating a hot order file, create order files for features that users occasionally use, such as routines that only run when the application is launched. Printing, opening documents, importing images and using various non-document windows and tools are other examples of features that users use occasionally but not continually, and are good candidates for having their own order files. Naming these order files after the feature being profiled (for example, <code>feature.order</code>) is recommended.</p>
<p>Finally, to generate a list of all routines, build a “default” order file <code>default.order</code> (as described in <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-102991">“Reordering Procedures”</a></span>).</p>
<p>Once you have these order files, you can combine them using the code shown in <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-110927-BCIGIGCD">Listing 2</a></span>. You can use this listing to build a command-line utility that removes duplicate lines in the order files while retaining the ordering of the original data.</p>
<a name="//apple_ref/doc/uid/20001862-110927-BCIGIGCD" title="Listing 2Code for Unique.c"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001862-110927" title="Listing 2Code for Unique.c"></a><strong>Listing 2&nbsp;&nbsp;</strong>Code for Unique.c</p>
<div class="codesample"><table><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//  unique<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//  A command for combining files while removing<span></span></pre></td></tr><tr><td scope="row"><pre>//  duplicate lines of text. The order of other lines of text<span></span></pre></td></tr><tr><td scope="row"><pre>//  in the input files is preserved.<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//  Build using this command line:<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//  cc -ObjC -O -o unique -framework Foundation Unique.c<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//  Note that "unique" differs from the BSD command "uniq" in that<span></span></pre></td></tr><tr><td scope="row"><pre>//  "uniq" combines duplicate adjacent lines, while "unique" does not<span></span></pre></td></tr><tr><td scope="row"><pre>//  require duplicate lines to be adjacent. "unique" is also spelled<span></span></pre></td></tr><tr><td scope="row"><pre>//  correctly.<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/NSSet.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/NSData.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define kBufferSize 8*1024<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void ProcessFile(FILE *fp)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    char buf[ kBufferSize ];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    static id theSet = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if( theSet == nil )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        theSet = [[NSMutableSet alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while( fgets(buf, kBufferSize, fp) )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        id dataForString;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        dataForString = [[NSData alloc] initWithBytes:buf length:strlen(buf)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if( ! [theSet containsObject:dataForString] )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [theSet addObject:dataForString];<span></span></pre></td></tr><tr><td scope="row"><pre>            fputs(buf, stdout);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [dataForString release];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main( int argc, char *argv[] )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int     i;<span></span></pre></td></tr><tr><td scope="row"><pre>    FILE *  theFile;<span></span></pre></td></tr><tr><td scope="row"><pre>    int     status = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if( argc > 1 )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        for( i = 1; i &lt; argc; i++ )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if( theFile = fopen( argv[i], "r" ) )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                ProcessFile( theFile );<span></span></pre></td></tr><tr><td scope="row"><pre>                fclose( theFile );<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            else<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                fprintf( stderr, "Could not open ‘%s’\n", argv[i] );<span></span></pre></td></tr><tr><td scope="row"><pre>                status = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ProcessFile( stdin );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	
<p> Once built, you would use the program to generate your final order file with syntax similar to the following:<a name="//apple_ref/doc/uid/20001862-DontLinkElementID_39"></a></p>
<div class="codesample"><table><tr><td scope="row"><pre>unique hot.order feature1.order ... featureN.order default.order > final.order<span></span></pre></td></tr></table></div>
<p>Of course, the real test of the ordering is the amount by which paging I/O is reduced. Run your application, use different features, and examine how well your ordering file is performing under different conditions. You can use the <code>top</code> tool (among others) to measure paging performance.</p>
<a name="//apple_ref/doc/uid/20001862-109188" title="Finding That One Last Hot Routine"></a><a name="//apple_ref/doc/uid/20001862-109188-TPXREF128" title="Finding That One Last Hot Routine"></a><h4>Finding That One Last Hot Routine</h4>
<p>After reordering you will usually have a region of pages with cold routines that you expect to be rarely used, often at the end of your text ordering. However, one or two hot routines might slip through the cracks and land in this cold section. This is a costly mistake, because using one of these hot routines now requires an entire page to be resident, a page that is otherwise filled with cold routines that are not likely to be used.</p>
<p>Check that the cold pages of your executable are not being paged in unexpectedly. Look for pages that are resident with high-page offsets in the cold region of your application’s text segment. If there is an unwanted page, you need to find out what routine on that page is being called. One way to do this is to profile during the particular operation that is touching that page, and use the <code>grep</code> tool to search the profiler output for routines that reside on that page. Alternatively, a quick way to identify the location where a page is being touched is to run the application under the <code>gdb</code> debugger and use the Mach call <code>vm_protect</code> to disallow all access to that page:</p>
<div class="codesample"><table><tr><td scope="row"><pre>(gdb) p vm_protect(task_self(), startpage_addr, vm_page_size, FALSE, 0);<span></span></pre></td></tr></table></div>
<p>After clearing the page protections, any access to that page causes a memory fault, which breaks the program in the debugger. At this point you can simply look at the function call stack (using the <code>bt</code> command) to learn why the routine was being called.</p>
<a name="//apple_ref/doc/uid/20001862-110250" title="Reordering Other Sections"></a><a name="//apple_ref/doc/uid/20001862-110250-TPXREF108" title="Reordering Other Sections"></a><h2>Reordering Other Sections</h2><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_40"></a>
<p>You can use the <code>-sectorder</code> option of the linker to organize blocks in most sections of the executable. Sections that might occasionally benefit from reordering are literal sections, such as the <code>__TEXT</code> segment’s <code>__cstring</code> section, and the <code>__DATA</code> segment’s <code>__data</code> section.</p>
<a name="//apple_ref/doc/uid/20001862-104418" title="Reordering Literal Sections"></a><a name="//apple_ref/doc/uid/20001862-104418-TPXREF109" title="Reordering Literal Sections"></a><h3>Reordering Literal Sections</h3>
<p>The lines in the order file for literal sections can most easily be produced with the <code>ld</code> and <code>otool</code> tools. For literal sections, <code>otool</code> creates a specific type of order file for each type of literal section:<a name="//apple_ref/doc/uid/20001862-DontLinkElementID_41"></a></p>
<ul class="spaceabove"><li class="li"><p>For C string literal sections, the order-file format is one literal C string per line (with ANSI C escape sequences allowed in the C string). For example, a line might look like</p>
<div class="codesample"><table><tr><td scope="row"><pre>Hello world\n<span></span></pre></td></tr></table></div></li>
<li class="li"><p>For 4-byte literal sections, the order-file format is one 32-bit hex number with a leading 0x per line with the rest of the line treated as a comment. For example, a line might look like</p>
<div class="codesample"><table><tr><td scope="row"><pre>0x3f8ccccd (1.10000002384185790000e+00)<span></span></pre></td></tr></table></div></li>
<li class="li"><p>For 8-byte literal sections, the order file line consists of two 32-bit hexadecimal numbers per line separated by white space each with a leading 0x, with the rest of the line treated as a comment. For example, a line might look like:</p><div class="codesample"><table><tr><td scope="row"><pre>0x3ff00000 0x00000000 (1.00000000000000000000e+00)<span></span></pre></td></tr></table></div></li>
<li class="li"><p>For literal pointer sections, the format of the lines in the order file represents the pointers, one per line. A literal pointer is represented by the segment name, the section name of the literal pointer, and then the literal itself. These are separated by colons with no extra white space. For example, a line might look like:</p>
<div class="codesample"><table><tr><td scope="row"><pre>__OBJC:__selector_strs:new<span></span></pre></td></tr></table></div></li>
<li class="li"><p>For all the literal sections, each line in the order file is simply entered into the literal section and appears in the output file in the order of the order file. No check is made to see if the literal is in the loaded objects.</p></li></ul>
<p>To reorder a literal section, first create a “whatsloaded” file using the <code>ld</code> <code>-whatsloaded</code> option as described in section <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-103584">“Creating a Default Order File.”</a></span> Then, run <code>otool</code> with the appropriate options, segment and section names, and filenames. The output of <code>otool</code> is a default order file for the specified section. For example, the following command line produces an order file listing the default load order for the <code>__TEXT</code> segment’s <code>__cstring</code> section in the file <code>cstring_order</code>:</p>
<div class="codesample"><table><tr><td scope="row"><pre>otool -X -v -s __TEXT __cstring `cat whatsloaded` > cstring_order<span></span></pre></td></tr></table></div>
<p>Once you’ve created the file <code>cstring_order</code>, you can edit the file and rearrange its entries to optimize locality of reference. For example, you can place literal strings used most frequently by your program (such as labels that appear in your user interface) at the beginning of the file. To produce the desired load order in the executable, use the following command:</p>
<div class="codesample"><table><tr><td scope="row"><pre>cc -o hello hello.o -sectorder __TEXT __cstring  cstring_order<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/20001862-104599" title="Reordering Data Sections"></a><a name="//apple_ref/doc/uid/20001862-104599-TPXREF129" title="Reordering Data Sections"></a><h3>Reordering Data Sections</h3>
<p>There are currently no tools to measure code references to data symbols. However, you might know a program’s data-referencing patterns and might be able to get some savings by separating data for seldom-used features from other data. One way to approach<a name="//apple_ref/doc/uid/20001862-DontLinkElementID_42"></a> <code>__data</code> section reordering is to sort the data by size so small data items end up on as few pages as possible. For example, if a larger data item is placed across two pages with two small items sharing each of these pages, the larger item must be paged in to access the smaller items. Reordering the data by size can minimize this sort of inefficiency. Because this data would normally need to be written to the virtual-memory backing store, this could be a major savings in some programs.</p>
<p>To reorder the <code>__data</code> section, first create an order file listing source files and symbols in the order in which you want them linked (order file entries are described at the beginning of <span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-117091">“Generating Order Files”</a></span>). Then, link the program using the <code>-sectorder</code> command-line option:</p>
<p><code>cc -o</code> <em>outputFile</em> <em>inputFile.o</em> <code>…
-sectorder __DATA __data</code> <em>orderFile</em> <code>-e
start</code></p>
<p>To use an order file with a Xcode project, modify the “Other Linker Flags” option in the Deployment build style of your project. Add the text <code>-sectorder __DATA __data</code> <em>orderFile</em> to this setting to specify your order file.</p>
<a name="//apple_ref/doc/uid/20001862-104673" title="Reordering Assembly Language Code"></a><a name="//apple_ref/doc/uid/20001862-104673-BCIGJDHD" title="Reordering Assembly Language Code"></a><h2>Reordering Assembly Language Code</h2>
<p>Some additional guidelines to keep in mind when reordering routines coded in assembly language:</p>
<ul class="ul"><li class="li"><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_43"></a><p>temporary labels in assembly code</p><p>Within hand-coded assembly code, be careful of branches to temporary labels that branch over a non temporary label. For example, if you use a label that starts with “L” or a <em>d</em> label (where <em>d</em> is a digit), as in this example</p>
<div class="codesample"><table><tr><td scope="row"><pre>foo: b 1f<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>bar: ...<span></span></pre></td></tr><tr><td scope="row"><pre>1:   ...<span></span></pre></td></tr></table></div><p>The resulting program won’t link or execute correctly, because only the symbols <code>foo</code> and <code>bar</code> make it into the object file’s symbol table. References to the temporary label <code>1</code> are compiled as offsets; as a result, no relocation entry is generated for the instruction <code>b
1f</code>. If the linker does not place the block associated with the symbol <code>bar</code> directly after that associated with <code>foo</code>, the branch to <code>1f</code> will not go to the correct place. Because there is no relocation entry, the linker doesn’t know to fix up the branch. The source-code change to fix this problem is to change the label <code>1</code> to a non temporary label (<code>bar1</code> for example). You can avoid problems with object files containing hand-coded assembly code by linking them whole, without reordering. </p></li>
<li class="li"><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_44"></a><p>the pseudo-symbol <code>.section_start</code></p><p>If the specified section in any input file has a non-zero size and there is no symbol with the value of the beginning of its section, the linker uses the pseudo <a name="//apple_ref/doc/uid/20001862-DontLinkElementID_45"></a>symbol <code>.section_start</code><a name="//apple_ref/doc/uid/20001862-DontLinkElementID_46"></a> as the symbol name it associates with the first block in the section. The purpose of this symbol is to deal with literal constants whose symbols do not persist into the object file. Because literal strings and floating-point constants are in literal sections, this not a problem for Apple compilers. You might see this symbol used by assembly-language programs or non-Apple compilers. However, you should not reorder such code and you should instead link the file whole, without reordering (see<span class="content_text"><a href="ImprovingLocality.html#//apple_ref/doc/uid/20001862-109955">“Linking with an Order File”</a></span>).</p></li></ul>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="CompilerOptions.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="SharedPages.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-06-28<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Conceptual/CodeFootprint/Articles/ImprovingLocality.html%3Fid%3D10000149i-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Conceptual/CodeFootprint/Articles/ImprovingLocality.html%3Fid%3D10000149i-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Conceptual/CodeFootprint/Articles/ImprovingLocality.html%3Fid%3D10000149i-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
