<html><head><title>Mac OS X Developer Tools
 Manual Page For Tcl_GetServiceMode(3tcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3tcl/Tcl_GetServiceMode" title="Mac OS X Developer Tools
 Manual Page for Tcl_GetServiceMode(3tcl)"><a name="//apple_ref/doc/man/3/Tcl_GetServiceMode" title="Mac OS X Developer Tools
 Manual Page for Tcl_GetServiceMode(3tcl)"><!-- headerDoc=man; indexgroup=Section 3tcl; uid="//apple_ref/doc/man/3tcl/Tcl_GetServiceMode"; name=Tcl_GetServiceMode(3tcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac&nbsp;OS&nbsp;X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>

<p style='text-align:justify;'>This manual page is associated with the Mac&nbsp;OS&nbsp;X
developer tools.  The software or headers described may not be present on your
Mac&nbsp;OS&nbsp;X installation until you install the developer tools
package.  This package is available on your Mac&nbsp;OS&nbsp;X installation DVD,
and the latest versions can be downloaded from
<a href="http://developer.apple.com/tools/download/">developer.apple.com</a>.</p>

<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Notifier(3)                                Tcl Library Procedures                                <a href="Notifier.3tcl.html#//apple_ref/doc/man/3/Notifier">Notifier(3)</a>



____________________________________________________________________________________________________________

<b>NAME</b>
       Tcl_CreateEventSource,   Tcl_DeleteEventSource,   Tcl_SetMaxBlockTime,   Tcl_QueueEvent,  Tcl_Thread-<font color="#ffffff" class="whiteout">QueueEvent,&nbsp;Tcl_ThreadQueueEvent,</font>
       QueueEvent, Tcl_ThreadAlert,  Tcl_GetCurrentThread,  Tcl_DeleteEvents,  Tcl_InitNotifier,  Tcl_Final-<font color="#ffffff" class="whiteout">izeNotifier,&nbsp;Tcl_FinalizeNotifier,</font>
       izeNotifier,  Tcl_WaitForEvent,  Tcl_AlertNotifier,  Tcl_SetTimer,  Tcl_ServiceAll, Tcl_ServiceEvent,
       Tcl_GetServiceMode, Tcl_SetServiceMode - the event queue and notifier interfaces

<b>SYNOPSIS</b>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       void
       <b>Tcl_CreateEventSource</b>(<u>setupProc,</u> <u>checkProc,</u> <u>clientData</u>)

       void
       <b>Tcl_DeleteEventSource</b>(<u>setupProc,</u> <u>checkProc,</u> <u>clientData</u>)

       void
       <b>Tcl_SetMaxBlockTime</b>(<u>timePtr</u>)

       void
       <b>Tcl_QueueEvent</b>(<u>evPtr,</u> <u>position</u>)

       void                                                                                                  |
       <b>Tcl_ThreadQueueEvent</b>(<u>threadId,</u> <u>evPtr,</u> <u>position</u>)                                                       |

       void                                                                                                  |
       <b>Tcl_ThreadAlert</b>(<u>threadId,</u> <u>clientData</u>)                                                                 |

       Tcl_ThreadId                                                                                          |
       <b>Tcl_GetCurrentThread</b>()                                                                                |

       void                                                                                                  |
       <b>Tcl_DeleteEvents</b>(<u>deleteProc,</u> <u>clientData</u>)                                                              |

       ClientData                                                                                            |
       <b>Tcl_InitNotifier</b>()                                                                                    |

       void                                                                                                  |
       <b>Tcl_FinalizeNotifier</b>(<u>clientData</u>)                                                                      |

       int                                                                                                   |
       <b>Tcl_WaitForEvent</b>(<u>timePtr</u>)                                                                             |

       void                                                                                                  |
       <b>Tcl_AlertNotifier</b>(<u>clientData</u>)                                                                         |

       void                                                                                                  |
       <b>Tcl_SetTimer</b>(<u>timePtr</u>)                                                                                 |

       int                                                                                                   |
       <b>Tcl_ServiceAll</b>()                                                                                      |

       int                                                                                                   |
       <b>Tcl_ServiceEvent</b>(<u>flags</u>)                                                                               |

       int                                                                                                   |
       <b>Tcl_GetServiceMode</b>()                                                                                  |

       int                                                                                                   |
       <b>Tcl_SetServiceMode</b>(<u>mode</u>)                                                                              |


<b>ARGUMENTS</b>
       Tcl_EventSetupProc    <u>*setupProc</u>     (in)      Procedure to invoke  to  prepare  for  event  wait  in
                                                      <b>Tcl_DoOneEvent</b>.

       Tcl_EventCheckProc    <u>*checkProc</u>     (in)      Procedure  for  <b>Tcl_DoOneEvent</b> to invoke after waiting
                                                      for events.  Checks to see if any events have occurred
                                                      and, if so, queues them.

       ClientData            <u>clientData</u>     (in)      Arbitrary  one-word value to pass to <u>setupProc</u>, <u>check</u>-<font color="#ffffff" class="whiteout">Proc,&nbsp;checkProc,</font>
                                                      <u>Proc</u>, or <u>deleteProc</u>.

       Tcl_Time              <u>*timePtr</u>       (in)      Indicates the maximum amount of time to  wait  for  an
                                                      event.   This is specified as an interval (how long to
                                                      wait), not an absolute time (when to wakeup).  If  the
                                                      pointer  passed  to <b>Tcl_WaitForEvent</b> is NULL, it means
                                                      there is no maximum wait time:  wait forever if neces-<font color="#ffffff" class="whiteout">sary.&nbsp;necessary.</font>
                                                      sary.

       Tcl_Event             <u>*evPtr</u>         (in)      An  event  to add to the event queue.  The storage for
                                                      the event must have been allocated by the caller using
                                                      <b>Tcl_Alloc</b> or <b>ckalloc</b>.

       Tcl_QueuePosition     <u>position</u>       (in)      Where   to   add   the   new   event   in  the  queue:
                                                      <b>TCL_QUEUE_TAIL</b>, <b>TCL_QUEUE_HEAD</b>, or <b>TCL_QUEUE_MARK</b>.

       Tcl_ThreadId          <u>threadId</u>       (in)      A unique identifier for a thread.

       Tcl_EventDeleteProc   <u>*deleteProc</u>    (in)      Procedure to invoke for each queued event in <b>Tcl_Dele</b>-<font color="#ffffff" class="whiteout">teEvents.&nbsp;Tcl_DeleteEvents.</font>
                                                      <b>teEvents</b>.

       int                   <u>flags</u>          (in)      What  types of events to service.  These flags are the
                                                      same as those passed to <b>Tcl_DoOneEvent</b>.                |

       int                   <u>mode</u>           (in)                                                             ||
                                                      Indicates   whether   events  should  be  serviced  by |
                                                      <b>Tcl_ServiceAll</b>.  Must be one  of  <b>TCL_SERVICE_NONE</b>  or |
                                                      <b>TCL_SERVICE_ALL</b>.
____________________________________________________________________________________________________________


<b>INTRODUCTION</b>
       The  interfaces  described  here  are used to customize the Tcl event loop.  The two most common cus-<font color="#ffffff" class="whiteout">tomizations&nbsp;customizations</font>
       tomizations are to add new sources of events and to merge Tcl's event  loop  with  some  other  event
       loop,  such  as  one  provided  by  an  application in which Tcl is embedded.  Each of these tasks is
       described in a separate section below.

       The procedures in this manual entry are the building blocks out of which the Tcl  event  notifier  is
       constructed.   The  event  notifier  is  the lowest layer in the Tcl event mechanism.  It consists of
       three things:

       [1]    Event sources: these represent the ways in which events can be generated.  For example,  there
              is  a  timer  event  source that implements the <b>Tcl_CreateTimerHandler</b> procedure and the <b>after</b>
              command, and there is a file event source that implements the <b>Tcl_CreateFileHandler</b>  procedure
              on  Unix  systems.   An event source must work with the notifier to detect events at the right
              times, record them on the event queue, and eventually notify higher-level software  that  they
              have  occurred.   The  procedures  <b>Tcl_CreateEventSource</b>,  <b>Tcl_DeleteEventSource</b>, and <b>Tcl_Set</b>-<font color="#ffffff" class="whiteout">MaxBlockTime,&nbsp;Tcl_SetMaxBlockTime,</font>
              <b>MaxBlockTime</b>, <b>Tcl_QueueEvent</b>, and <b>Tcl_DeleteEvents</b> are used primarily by event sources.

       [2]    The event queue: for non-threaded applications, there is a single queue for the whole applica-<font color="#ffffff" class="whiteout">tion,&nbsp;application,</font>
              tion,  containing  events  that  have been detected but not yet serviced.  Event sources place
              events onto the queue so that they may be processed in order at appropriate times  during  the
              event  loop.  The event queue guarantees a fair discipline of event handling, so that no event
              source can starve the others.  It also allows events to be saved for  servicing  at  a  future
              time.   Threaded  applications work in a similar manner, except that there is a separate event |
              queue for each thread containing a Tcl interpreter.   <b>Tcl_QueueEvent</b>  is  used  (primarily  by |
              event  sources) to add events to the event queue and <b>Tcl_DeleteEvents</b> is used to remove events |
              from the queue without processing them.  In a threaded  application,  <b>Tcl_QueueEvent</b>  adds  an |
              event  to  the  current thread's queue, and <b>Tcl_ThreadQueueEvent</b> adds an event to a queue in a |
              specific thread.                                                                               |

       [3]                                                                                                   ||
              The  event  loop:  in  order  to detect and process events, the application enters a loop that |
              waits for events to occur, places them on the event queue,  and  then  processes  them.   Most |
              applications  will  do  this  by calling the procedure <b>Tcl_DoOneEvent</b>, which is described in a |
              separate manual entry.                                                                         |

       Most Tcl applications need not worry about any of the internals of the Tcl  notifier.   However,  the |
       notifier  now has enough flexibility to be retargeted either for a new platform or to use an external |
       event loop (such as the Motif event loop, when Tcl is embedded in a Motif application).   The  proce- |
       dures <b>Tcl_WaitForEvent</b> and <b>Tcl_SetTimer</b> are normally implemented by Tcl, but may be replaced with new |
       versions to retarget the notifier  (the  <b>Tcl_InitNotifier</b>,  <b>Tcl_AlertNotifier</b>,  <b>Tcl_FinalizeNotifier</b>, |
       <b>Tcl_Sleep</b>, <b>Tcl_CreateFileHandler</b>, and <b>Tcl_DeleteFileHandler</b> must also be replaced; see CREATING A NEW |
       NOTIFIER below for details).  The procedures  <b>Tcl_ServiceAll</b>,  <b>Tcl_ServiceEvent</b>,  <b>Tcl_GetServiceMode</b>, |
       and  <b>Tcl_SetServiceMode</b>  are provided to help connect Tcl's event loop to an external event loop such |
       as Motif's.                                                                                           |

<b>NOTIFIER</b> <b>BASICS</b>                                                                                              |
       The easiest way to understand how the notifier works is to consider what happens when  <b>Tcl_DoOneEvent</b>
       is  called.  <b>Tcl_DoOneEvent</b> is passed a <u>flags</u> argument that indicates what sort of events it is OK to
       process and also whether or not to block if no events are ready.  <b>Tcl_DoOneEvent</b> does  the  following
       things:

       [1]    Check  the  event queue to see if it contains any events that can be serviced.  If so, service
              the first possible event, remove it from the queue, and  return.   It  does  this  by  calling |
              <b>Tcl_ServiceEvent</b> and passing in the <u>flags</u> argument.

       [2]    Prepare  to  block for an event.  To do this, <b>Tcl_DoOneEvent</b> invokes a <u>setup</u> <u>procedure</u> in each
              event source.  The event source will perform event-source specific initialization and possibly |
              call <b>Tcl_SetMaxBlockTime</b> to limit how long <b>Tcl_WaitForEvent</b> will block if no new events occur.

       [3]    Call <b>Tcl_WaitForEvent</b>.  This procedure is implemented differently on different platforms;   it
              waits  for  an event to occur, based on the information provided by the event sources.  It may
              cause the application to block if <u>timePtr</u> specifies  an  interval  other  than  0.   <b>Tcl_Wait</b>-<font color="#ffffff" class="whiteout">ForEvent&nbsp;Tcl_WaitForEvent</font>
              <b>ForEvent</b> returns when something has happened, such as a file becoming readable or the interval
              given by <u>timePtr</u> expiring.  If there are no events for <b>Tcl_WaitForEvent</b> to wait for,  so  that
              it would block forever, then it returns immediately and <b>Tcl_DoOneEvent</b> returns 0.

       [4]    Call  a  <u>check</u>  <u>procedure</u>  in  each  event source.  The check procedure determines whether any
              events of interest to this source occurred.  If so, the events are added to the event queue.

       [5]    Check the event queue to see if it contains any events that can be serviced.  If  so,  service
              the first possible event, remove it from the queue, and return.

       [6]    See if there are idle callbacks pending. If so, invoke all of them and return.

       [7]    Either  return 0 to indicate that no events were ready, or go back to step [2] if blocking was
              requested by the caller.


<b>CREATING</b> <b>A</b> <b>NEW</b> <b>EVENT</b> <b>SOURCE</b>
       An event source consists of three procedures invoked by the notifier, plus  additional  C  procedures
       that  are  invoked  by higher-level code to arrange for event-driven callbacks.  The three procedures
       called by the notifier consist of the setup and check procedures described above, plus an  additional
       procedure that is invoked when an event is removed from the event queue for servicing.

       The procedure <b>Tcl_CreateEventSource</b> creates a new event source.  Its arguments specify the setup pro-<font color="#ffffff" class="whiteout">cedure&nbsp;procedure</font>
       cedure and check procedure for the event source.  <u>SetupProc</u> should match the following prototype:
              typedef void Tcl_EventSetupProc(
                ClientData <u>clientData</u>,
                int <u>flags</u>);
       The <u>clientData</u> argument will be the same as the <u>clientData</u> argument to <b>Tcl_CreateEventSource</b>;  it  is
       typically  used to point to private information managed by the event source.  The <u>flags</u> argument will
       be the same as the  <u>flags</u>  argument  passed  to  <b>Tcl_DoOneEvent</b>  except  that  it  will  never  be  0
       (<b>Tcl_DoOneEvent</b> replaces 0 with <b>TCL_ALL_EVENTS</b>).  <u>Flags</u> indicates what kinds of events should be con-<font color="#ffffff" class="whiteout">sidered;&nbsp;considered;</font>
       sidered; if the bit corresponding to this event source isn't set,  the  event  source  should  return
       immediately   without   doing   anything.   For  example,  the  file  event  source  checks  for  the
       <b>TCL_FILE_EVENTS</b> bit.

       <u>SetupProc</u>'s job is to make sure that the application wakes up when events of the desired type  occur.
       This  is  typically  done  in  a platform-dependent fashion.  For example, under Unix an event source
       might call <b>Tcl_CreateFileHandler</b>; under Windows it might request notification with a  Windows  event.
       For  timer-driven  event  sources such as timer events or any polled event, the event source can call
       <b>Tcl_SetMaxBlockTime</b> to force the application to wake up after a specified time even if no events have
       occurred.   If  no  event source calls <b>Tcl_SetMaxBlockTime</b> then <b>Tcl_WaitForEvent</b> will wait as long as |
       necessary for an event to occur; otherwise, it will only wait as long as the shortest interval passed |
       to  <b>Tcl_SetMaxBlockTime</b>  by  one  of the event sources.  If an event source knows that it already has |
       events ready to report, it can request a zero maximum block time.  For example, the  setup  procedure |
       for  the  X  event  source  looks  to see if there are events already queued.  If there are, it calls |
       <b>Tcl_SetMaxBlockTime</b> with a 0 block time so that <b>Tcl_WaitForEvent</b> does not block if there  is  no  new |
       data  on  the  X  connection.   The  <u>timePtr</u>  argument to <b>Tcl_WaitForEvent</b> points to a structure that
       describes a time interval in seconds and microseconds:
              typedef struct Tcl_Time {
                long <u>sec</u>;
                long <u>usec</u>;
              } Tcl_Time;
       The <u>usec</u> field should be less than 1000000.

       Information provided to <b>Tcl_SetMaxBlockTime</b> is only used for the next call to <b>Tcl_WaitForEvent</b>; it is |
       discarded  after  <b>Tcl_WaitForEvent</b>  returns.   The  next time an event wait is done each of the event
       sources' setup procedures will be called again, and they can specify new information for  that  event
       wait.

       If the application uses an external event loop rather than <b>Tcl_DoOneEvent</b>, the event sources may need |
       to call <b>Tcl_SetMaxBlockTime</b> at other times.  For example, if a new event handler is  registered  that |
       needs to poll for events, the event source may call <b>Tcl_SetMaxBlockTime</b> to set the block time to zero |
       to force the external event loop to call Tcl.  In this case, <b>Tcl_SetMaxBlockTime</b> invokes <b>Tcl_SetTimer</b> |
       with the shortest interval seen since the last call to <b>Tcl_DoOneEvent</b> or <b>Tcl_ServiceAll</b>.              |

       In addition to the generic procedure <b>Tcl_SetMaxBlockTime</b>, other platform-specific procedures may also |
       be available for <u>setupProc</u>, if there is additional information needed  by  <b>Tcl_WaitForEvent</b>  on  that |
       platform.   For  example, on Unix systems the <b>Tcl_CreateFileHandler</b> interface can be used to wait for |
       file events.

       The second procedure provided by each event source is its check procedure, indicated by the <u>checkProc</u>
       argument to <b>Tcl_CreateEventSource</b>.  <u>CheckProc</u> must match the following prototype:
              typedef void Tcl_EventCheckProc(
                ClientData <u>clientData</u>,
                int <u>flags</u>);
       The  arguments  to  this  procedure  are  the  same  as those for <u>setupProc</u>.  <b>CheckProc</b> is invoked by
       <b>Tcl_DoOneEvent</b> after it has waited for events.  Presumably at least one event source is now  prepared
       to queue an event.  <b>Tcl_DoOneEvent</b> calls each of the event sources in turn, so they all have a chance
       to queue any events that are ready.  The check procedure does two things.  First, it must see if  any
       events have triggered.  Different event sources do this in different ways.

       If  an  event  source's  check procedure detects an interesting event, it must add the event to Tcl's
       event queue.  To do this, the event source calls <b>Tcl_QueueEvent</b>.  The <u>evPtr</u> argument is a pointer  to
       a dynamically allocated structure containing the event (see below for more information on memory man-<font color="#ffffff" class="whiteout">agement&nbsp;management</font>
       agement issues).  Each event source can define its own event structure with whatever  information  is
       relevant  to  that  event source.  However, the first element of the structure must be a structure of
       type <b>Tcl_Event</b>, and the address of this structure is used when communicating between the event source
       and the rest of the notifier.  A <b>Tcl_Event</b> has the following definition:
              typedef struct {
                  Tcl_EventProc *<u>proc</u>;
                  struct Tcl_Event *<u>nextPtr</u>;
              } Tcl_Event;
       The event source must fill in the <u>proc</u> field of the event before calling <b>Tcl_QueueEvent</b>.  The <u>nextPtr</u>
       is used to link together the events in the queue and should not be modified by the event source.

       An event may be added to the queue at any of three positions, depending on the <u>position</u>  argument  to
       <b>Tcl_QueueEvent</b>:

       <b>TCL_QUEUE_TAIL</b>          Add the event at the back of the queue, so that all other pending events will
                               be serviced first.  This is almost always the right place for new events.

       <b>TCL_QUEUE_HEAD</b>          Add the event at the front of the queue, so that it will be  serviced  before
                               all other queued events.

       <b>TCL_QUEUE_MARK</b>          Add the event at the front of the queue, unless there are other events at the
                               front whose position is <b>TCL_QUEUE_MARK</b>;  if so, add the new event just  after
                               all other <b>TCL_QUEUE_MARK</b> events.  This value of <u>position</u> is used to insert an
                               ordered sequence of events at the front of the queue, such  as  a  series  of
                               Enter and Leave events synthesized during a grab or ungrab operation in Tk.

       When  it is time to handle an event from the queue (steps 1 and 4 above) <b>Tcl_ServiceEvent</b> will invoke |
       the <u>proc</u> specified in the first queued <b>Tcl_Event</b> structure.  <u>Proc</u> must match the following prototype:
              typedef int Tcl_EventProc(
                Tcl_Event *<u>evPtr</u>,
                int <u>flags</u>);
       The first argument to <u>proc</u> is a pointer to the event, which will be the same as the first argument to
       the <b>Tcl_QueueEvent</b> call that added the event to the queue.  The second argument to <u>proc</u> is the  <u>flags</u>
       argument  for the current call to <b>Tcl_ServiceEvent</b>;  this is used by the event source to return imme- |
       diately if its events are not relevant.

       It is up to <u>proc</u> to handle the event, typically by invoking one or more Tcl commands or C-level call-<font color="#ffffff" class="whiteout">backs.&nbsp;callbacks.</font>
       backs.  Once the event source has finished handling the event it returns 1 to indicate that the event
       can be removed from the queue.  If for some reason the event source decides that the event cannot  be
       handled  at  this  time, it may return 0 to indicate that the event should be deferred for processing |
       later;  in this case <b>Tcl_ServiceEvent</b> will go on to the next event in the queue and attempt  to  ser-<font color="#ffffff" class="whiteout">vice&nbsp;service</font>
       vice  it.   There  are  several reasons why an event source might defer an event.  One possibility is
       that events of this type are excluded by the <u>flags</u> argument.  For example, the file event source will
       always  return  0 if the <b>TCL_FILE_EVENTS</b> bit isn't set in <u>flags</u>.  Another example of deferring events
       happens in Tk if <b>Tk_RestrictEvents</b> has been invoked to defer certain kinds of window events.

       When <u>proc</u> returns 1, <b>Tcl_ServiceEvent</b> will remove the event from the event queue and free  its  stor- |
       age.   Note  that  the storage for an event must be allocated by the event source (using <b>Tcl_Alloc</b> or |
       the Tcl macro <b>ckalloc</b>) before calling <b>Tcl_QueueEvent</b>, but it will be freed by  <b>Tcl_ServiceEvent</b>,  not |
       by the event source.                                                                                  |

       Threaded  applications work in a similar manner, except that there is a separate event queue for each |
       thread containing a Tcl interpreter.  Calling <b>Tcl_QueueEvent</b> in a multithreaded application  adds  an |
       event  to  the  current  thread's  queue.  To add an event to another thread's queue, use <b>Tcl_Thread-</b> |
       <b>QueueEvent</b>.  <b>Tcl_ThreadQueueEvent</b> accepts as an argument  a  Tcl_ThreadId  argument,  which  uniquely |
       identifies a thread in a Tcl application.  To obtain the Tcl_ThreadID for the current thread, use the |
       <b>Tcl_GetCurrentThread</b> procedure.  (A thread would then need to pass this identifier to  other  threads |
       for  those threads to be able to add events to its queue.)  After adding an event to another thread's |
       queue, you then typically need to call <b>Tcl_ThreadAlert</b> to "wake up" that thread's notifier  to  alert |
       it to the new event.                                                                                  |

       <b>Tcl_DeleteEvents</b> can be used to explicitly remove one or more events from the event queue.  <b>Tcl_Dele-</b> |
       <b>teEvents</b> calls <u>proc</u> for each event in the queue, deleting those for with  the  procedure  returns  1. |
       Events for which the procedure returns 0 are left in the queue.  <u>Proc</u> should match the following pro- |
       totype:                                                                                               |
              typedef int Tcl_EventDeleteProc(                                                               |
                Tcl_Event *<u>evPtr</u>,                                                                            |
                ClientData <u>clientData</u>);                                                                      |
       The <u>clientData</u> argument will be the same as the <u>clientData</u> argument to <b>Tcl_DeleteEvents</b>; it is  typi- |
       cally  used to point to private information managed by the event source.  The <u>evPtr</u> will point to the |
       next event in the queue.                                                                              |

       <b>Tcl_DeleteEventSource</b> deletes an event source.  The <u>setupProc</u>, <u>checkProc</u>,  and  <u>clientData</u>  arguments |
       must  exactly  match  those provided to the <b>Tcl_CreateEventSource</b> for the event source to be deleted. |
       If no such source exists, <b>Tcl_DeleteEventSource</b> has no effect.


<b>CREATING</b> <b>A</b> <b>NEW</b> <b>NOTIFIER</b>
       The notifier consists of all the procedures described in this manual entry, plus  <b>Tcl_DoOneEvent</b>  and
       <b>Tcl_Sleep</b>, which are available on all platforms, and <b>Tcl_CreateFileHandler</b> and <b>Tcl_DeleteFileHandler</b>, |
       which are Unix-specific.  Most of these procedures are generic, in that they are  the  same  for  all |
       notifiers.  However, eight of the procedures are notifier-dependent: <b>Tcl_InitNotifier</b>, <b>Tcl_AlertNoti-</b> |
       <b>fier</b>, <b>Tcl_FinalizeNotifier</b>,  <b>Tcl_SetTimer</b>,  <b>Tcl_Sleep</b>,  <b>Tcl_WaitForEvent</b>,  <b>Tcl_CreateFileHandler</b>  and |
       <b>Tcl_DeleteFileHandler</b>.   To  support  a new platform or to integrate Tcl with an application-specific |
       event loop, you must write new versions of these procedures.                                          |

       <b>Tcl_InitNotifier</b> initializes the notifier state and returns a handle  to  the  notifier  state.   Tcl |
       calls this procedure when initializing a Tcl interpreter.  Similarly, <b>Tcl_FinalizeNotifier</b> shuts down |
       the notifier, and is called by <b>Tcl_Finalize</b> when shutting down a Tcl interpreter.                     |

       <b>Tcl_WaitForEvent</b> is the lowest-level procedure in the notifier; it is responsible for waiting for  an |
       ``interesting''  event  to  occur or for a given time to elapse.  Before <b>Tcl_WaitForEvent</b> is invoked, |
       each of the event sources' setup procedure will have been invoked.  The <u>timePtr</u> argument to <b>Tcl_Wait-</b> |
       <b>ForEvent</b>  gives the maximum time to block for an event, based on calls to <b>Tcl_SetMaxBlockTime</b> made by |
       setup procedures and on other information (such as the <b>TCL_DONT_WAIT</b> bit in <u>flags</u>).                   |

       Ideally, <b>Tcl_WaitForEvent</b> should only wait for an event to occur; it should not actually process  the |
       event  in  any way.  Later on, the event sources will process the raw events and create Tcl_Events on |
       the event queue in their <u>checkProc</u> procedures.  However, on some platforms  (such  as  Windows)  this |
       isn't  possible;  events  may be processed in <b>Tcl_WaitForEvent</b>, including queuing Tcl_Events and more |
       (for example, callbacks for native widgets may be invoked).  The return value  from  <b>Tcl_WaitForEvent</b> |
       must  be  either  0,  1, or -1.  On platforms such as Windows where events get processed in <b>Tcl_Wait-</b> |
       <b>ForEvent</b>, a return value of 1 means that there may be more events still  pending  that  haven't  been |
       processed.   This  is  a  sign to the caller that it must call <b>Tcl_WaitForEvent</b> again if it wants all |
       pending events to be processed. A 0 return value means that calling <b>Tcl_WaitForEvent</b> again  will  not |
       have  any effect: either this is a platform where <b>Tcl_WaitForEvent</b> only waits without doing any event |
       processing, or <b>Tcl_WaitForEvent</b> knows for sure that there are no additional events to  process  (e.g. |
       it returned because the time elapsed).  Finally, a return value of -1 means that the event loop is no |
       longer operational and the application should probably unwind and terminate.  Under Windows this hap- |
       pens  when  a  WM_QUIT  message  is  received; under Unix it happens when <b>Tcl_WaitForEvent</b> would have |
       waited forever because there were no active event sources and the timeout was infinite.               |

       <b>Tcl_AlertNotifier</b> is used in multithreaded applications to allow any thread to "wake up" the notifier |
       to  alert it to new events on its queue.  <b>Tcl_AlertNotifier</b> requires as an argument the notifier han- |
       dle returned by <b>Tcl_InitNotifier</b>.                                                                     |

       If the notifier will be used with an external event loop, then it must also support the  <b>Tcl_SetTimer</b> |
       interface.   <b>Tcl_SetTimer</b>  is  invoked  by <b>Tcl_SetMaxBlockTime</b> whenever the maximum blocking time has |
       been reduced.  <b>Tcl_SetTimer</b> should arrange for the external event loop to invoke <b>Tcl_ServiceAll</b> after |
       the  specified  interval even if no events have occurred.  This interface is needed because <b>Tcl_Wait-</b> |
       <b>ForEvent</b> isn't invoked when there is an external event loop.  If the notifier will only be used  from |
       <b>Tcl_DoOneEvent</b>, then <b>Tcl_SetTimer</b> need not do anything.                                               |

       On  Unix  systems, the file event source also needs support from the notifier.  The file event source |
       consists of the <b>Tcl_CreateFileHandler</b> and <b>Tcl_DeleteFileHandler</b> procedures, which  are  described  in |
       the <b>Tcl_CreateFileHandler</b> manual page.                                                                |

       The <b>Tcl_Sleep</b> and <b>Tcl_DoOneEvent</b> interfaces are described in their respective manual pages.           |

       The easiest way to create a new notifier is to look at the code for an existing notifier, such as the |
       files <b>unix/tclUnixNotfy.c</b> or <b>win/tclWinNotify.c</b> in the Tcl source distribution.                       |


<b>EXTERNAL</b> <b>EVENT</b> <b>LOOPS</b>                                                                                         |
       The notifier interfaces are designed so that Tcl can be embedded into applications  that  have  their |
       own  private  event  loops.  In this case, the application does not call <b>Tcl_DoOneEvent</b> except in the |
       case of recursive event loops such as calls to the Tcl commands <b>update</b> or <b>vwait</b>.  Most of the time is |
       spent  in the external event loop of the application.  In this case the notifier must arrange for the |
       external event loop to call back into Tcl when something happens on the various  Tcl  event  sources. |
       These callbacks should arrange for appropriate Tcl events to be placed on the Tcl event queue.        |

       Because  the  external  event  loop is not calling <b>Tcl_DoOneEvent</b> on a regular basis, it is up to the |
       notifier to arrange for <b>Tcl_ServiceEvent</b> to be called whenever events are pending on  the  Tcl  event |
       queue.   The  easiest way to do this is to invoke <b>Tcl_ServiceAll</b> at the end of each callback from the |
       external event loop.  This will ensure that all of the event sources are polled,  any  queued  events |
       are  serviced,  and  any pending idle handlers are processed before returning control to the applica- |
       tion.  In addition, event sources that need to poll for events can call <b>Tcl_SetMaxBlockTime</b> to  force |
       the external event loop to call Tcl even if no events are available on the system event queue.        |

       As  a  side  effect  of  processing  events  detected in the main external event loop, Tcl may invoke |
       <b>Tcl_DoOneEvent</b> to start a recursive event loop in commands like <b>vwait</b>.   <b>Tcl_DoOneEvent</b>  will  invoke |
       the  external  event  loop,  which  will result in callbacks as described in the preceding paragraph, |
       which will result in calls to <b>Tcl_ServiceAll</b>.  However, in these cases it is undesirable  to  service |
       events  in  <b>Tcl_ServiceAll</b>.   Servicing  events there is unnecessary because control will immediately |
       return to the external event loop and hence to <b>Tcl_DoOneEvent</b>, which can service the  events  itself. |
       Furthermore,  <b>Tcl_DoOneEvent</b>  is supposed to service only a single event, whereas <b>Tcl_ServiceAll</b> nor- |
       mally services all pending events.  To handle this situation, <b>Tcl_DoOneEvent</b> sets a flag for <b>Tcl_Ser-</b> |
       <b>viceAll</b> that causes it to return without servicing any events.  This flag is called the <u>service</u> <u>mode</u>; |
       <b>Tcl_DoOneEvent</b> restores it to its previous value before it returns.                                   |

       In some cases, however, it may be necessary for <b>Tcl_ServiceAll</b> to service events  even  when  it  has |
       been  invoked  from  <b>Tcl_DoOneEvent</b>.   This  happens  when  there is yet another recursive event loop |
       invoked via an event handler called by <b>Tcl_DoOneEvent</b> (such as one that is part of a native  widget). |
       In  this  case, <b>Tcl_DoOneEvent</b> may not have a chance to service events so <b>Tcl_ServiceAll</b> must service |
       them all.  Any recursive event loop that calls an external event loop rather than <b>Tcl_DoOneEvent</b> must |
       reset  the service mode so that all events get processed in <b>Tcl_ServiceAll</b>.  This is done by invoking |
       the <b>Tcl_SetServiceMode</b> procedure.  If <b>Tcl_SetServiceMode</b> is passed <b>TCL_SERVICE_NONE</b>,  then  calls  to |
       <b>Tcl_ServiceAll</b>  will  return  immediately  without  processing  any events.  If <b>Tcl_SetServiceMode</b> is |
       passed <b>TCL_SERVICE_ALL</b>, then  calls  to  <b>Tcl_ServiceAll</b>  will  behave  normally.   <b>Tcl_SetServiceMode</b> |
       returns  the  previous  value  of  the service mode, which should be restored when the recursive loop |
       exits.  <b>Tcl_GetServiceMode</b> returns the current value of the service mode.

<b>SEE</b> <b>ALSO</b>
       <b>Tcl_CreateFileHandler</b>, <b>Tcl_DeleteFileHandler</b>, <b>Tcl_Sleep</b>, <b>Tcl_DoOneEvent</b>, <a href="Thread.3tcl.html#//apple_ref/doc/man/3/Thread"><b>Thread(3)</b></a><b></b>

<b>KEYWORDS</b>
       event, notifier, event queue, event sources, file events, timer, idle, service mode, threads



Tcl                                                  8.1                                         <a href="Notifier.3tcl.html#//apple_ref/doc/man/3/Notifier">Notifier(3)</a>
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_GetServiceMode.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_GetServiceMode.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_GetServiceMode.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
