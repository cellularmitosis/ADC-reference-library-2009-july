<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Device File Access Guide for Storage Devices: Working With Device Files for Storage Devices</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Working With Device Files for Storage Devices"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000385" title="Working With Device Files for Storage Devices"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/MassStorageDevices-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30001039" target="_top">Storage</a> &gt; <a href="../WWStorage_Intro/WWStorage_Intro.html#//apple_ref/doc/uid/TP40002651-DontLinkElementID_6">Device File Access Guide for Storage Devices</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WWStorage_Intro/WWStorage_Intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WWStorage_RevHistory/WWStorage_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000385-SW1" title="Working With Device Files for Storage Devices"></a><h1>Working With Device Files for Storage Devices</h1><p>This chapter describes how to develop an application that uses I/O Kit and POSIX functions to locate a CD-ROM storage device on Mac OS X and open it for reading.</p><p>The code snippets in this chapter are based on the sample application <em><a href="../../../../../samplecode/CDROMSample/index.html#//apple_ref/doc/uid/DTS10000423" target="_top">CDROMSample</a></em>, available in its entirety at <span class="content_text"><a href="../../../../../samplecode/HardwareDrivers/idxMassStorageDevices-date.html#//apple_ref/doc/uid/TP30000925-TP40003576-TP30001039" target="_top">Sample Code > Hardware &amp; Drivers > Storage</a></span>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_7" title="Note"></a><p><strong>Note:</strong>&nbsp;If you choose to develop a Cocoa application that accesses a storage device, be aware that Objective-C does not provide interfaces for I/O Kit or POSIX functions. However, because the I/O Kit and POSIX APIs are C APIs, you can call them from a Cocoa application.</p></div><p>Although the sample code in this chapter has been compiled and tested to some degree, Apple does not recommend that you directly incorporate this code into a commercial application. For example, only limited error handling is shown—you should develop your own techniques for detecting and handling errors.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_8" title="Important:"></a><p><strong>Important:</strong>&nbsp;The sample code in this chapter requires Mac OS X v10.1 or later to build, but the resulting application will run in Mac OS X v10.0 or later.</p><p></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-DontLinkElementID_3">Storage Device Access in an Intel-Based Macintosh</a>
				
			<br/>
			
        
			
			
				<a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-DontLinkElementID_4">Accessing a CD-ROM Storage Device</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_3" title="Storage Device Access in an Intel-Based Macintosh"></a><h2>Storage Device Access in an Intel-Based Macintosh</h2><p>This section briefly outlines some of the issues related to developing a universal binary version of a Mac OS X application that uses device files to access a storage device. Before you read this section, be sure to read <em><a href="../../../../MacOSX/Conceptual/universal_binary/index.html#//apple_ref/doc/uid/TP40002217" target="_top">Universal Binary Programming Guidelines, Second Edition</a></em>.  That document covers architectural differences and byte-ordering formats and provides comprehensive guidelines for code modification and building universal binaries. The guidelines in that document apply to all types of applications, including those that access hardware.</p><p>Before you build your application as a universal binary, make sure that:</p><ul class="ul"><li class="li"><p>You port your project to GCC 4 (Xcode uses GCC 4 to target Intel-based Macintosh computers)</p></li><li class="li"><p>You install the Mac OS X v10.4 universal SDK</p></li><li class="li"><p>You develop your project in Xcode 2.1 or later</p></li></ul><p>An application that reads from and writes to storage media frequently handles data structures that contain multibyte integer data. It's vital that these data structures remain in the correct endian format on the disk so the disk can be used with both PowerPC-based and Intel-based Macintosh computers. Depending on the native endian format of the computer in which the application is running, therefore, the application may need to byte swap the data structures it handles.</p><p>If you've determined that byte-swapping is required in your application, you can implement it in one of two ways:</p><ul class="ul"><li class="li"><p>Perform the appropriate byte swap on the data after it's read into a buffer and perform the opposite byte swap on the data that's ready to be written out to disk. This scheme allows your application to access the buffers without having to worry about the endian format of the data in them.</p></li><li class="li"><p>Do not byte swap the data in the buffers, but perform the appropriate byte swap each time your application accesses the buffers. This preserves the data's correct endian format while it resides in the buffers, which means your application does not have to byte swap the data while reading it in or writing it out.</p></li></ul><p>To avoid confusion, it's best to choose only one of these two schemes and be consistent in its implementation throughout your application. Whichever you choose, however, be sure to use the conditional byte-swapping macros defined in <code>libkern/OSByteOrder.h</code> (even though this header file is in the Kernel framework, its macros are available to applications). When you use these macros, the compiler optimizes your code so the routines are executed only if they are necessary for the architecture in which your application is running.</p><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_4" title="Accessing a CD-ROM Storage Device"></a><h2>Accessing a CD-ROM Storage Device</h2><p>To communicate with a storage device (such as a CD-ROM device) from your Mac OS X application, you use I/O Kit functions to find the device and obtain a path to its device file. You can then use POSIX functions to perform such operations as opening and closing the device and reading from it.</p><p>The sample code in this chapter demonstrates how to find all ejectable CD media, obtain the path to the device file for a CD-ROM drive, and use POSIX functions to open the device, read a sector of the media and close the device. Your application can read data using POSIX functions because, depending on the permissions, the file system may allow multiple users to open a file for reading. However, you should not assume you can use this mechanism to write data, because the file system itself may have opened all writable mounted storage devices with restrictive write access.</p><p><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_10"></a>The sample code shown in this chapter is from an Xcode “CoreFoundation Tool” project. The project builds a tool that has no user interface and sends its output to the console. You can view the output either by running the tool within Xcode or by running the Console utility, which you can find at <code>/Applications/Utilities/Console</code>, before launching the tool.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_9" title="Note"></a><p><strong>Note:</strong>&nbsp;By convention, application functions in this chapter, such as <code><!--a-->MyOpenDrive<!--/a--></code> in <span class="content_text"><a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-SW2">Listing 1-5</a></span>, start with <code>My</code> to distinguish them from I/O Kit functions and other Mac OS X functions.</p></div><p>If you are using a version of Mac OS X prior to v10.1, this tool must be run with root privileges, because the <code>/dev/rdisk*</code> nodes are owned by root in those versions. In Mac OS X v10.1 and later, the <code>/dev/*disk*</code> nodes for removable media are owned by the currently logged-in user (nodes for nonremovable media are still owned by root). If necessary, you can use the <code><a href="../../../../Darwin/Reference/ManPages/man8/sudo.8.html#//apple_ref/doc/man/8/sudo" target="_top">sudo(8)</a></code> command to launch the tool with root privileges, as shown below (you will be asked to supply your <code>admin</code> password):</p><p><code>sudo open /YourDirectoryPath/CDROMSample.app</code></p><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_5" title="Including Header Files and Setting Up a Main Function"></a><h3>Including Header Files and Setting Up a Main Function</h3><p><span class="content_text">Listing 1-1</span> shows the header files you’ll need to include in your main file for the sample code in this chapter. (Some of these headers include others; a shorter list is possible.) Except for <code>CoreFoundation.h</code><code></code>, these headers are generally part of <code>IOKit.framework</code><code></code> or <code>System.framework</code><code></code>.</p><a name="//apple_ref/doc/uid/TP30000385-SW3" title="Listing 1-1Header files to include for the storage device sample code"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>Header files to include for the storage device sample code</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;unistd.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;fcntl.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/ioctl.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;errno.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;paths.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/param.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/IOKitLib.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/IOBSD.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/storage/IOCDMedia.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/storage/IOMedia.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/storage/IOCDTypes.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/storage/IOMediaBSDClient.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;CoreFoundation/CoreFoundation.h><span></span></pre></td></tr></table></div><p><span class="content_text">Listing 1-2</span> shows a <code><!--a-->main<!--/a--></code> function for finding a CD-ROM device with the I/O Kit and accessing it with POSIX functions. The <code><!--a-->main<!--/a--></code> function accomplishes its work by calling the following functions, which are shown in other sections:</p><ul class="spaceabove"><li class="li"><p><code>MyFindEjectableCDMedia</code> (<span class="content_text"><a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-SW8">“Finding All Ejectable CD Media”</a></span>)</p></li><li class="li"><p><code>MyGetDeviceFilePath</code> (<span class="content_text"><a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-SW9">“Getting the Path to the Device File for the CD-ROM Device”</a></span>)</p></li><li class="li"><p><code>MyOpenDrive</code> (<span class="content_text"><a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-SW10">“Opening the Device”</a></span>)</p></li><li class="li"><p><code>MyReadSector</code> (<span class="content_text"><a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-SW11">“Reading a Sector From the Device”</a></span>)</p></li><li class="li"><p><code>MyCloseDrive</code> (<span class="content_text"><a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-SW12">“Closing the Device”</a></span>)</p></li></ul><p>The type <code>kern_return_t</code> is defined in <code>std_types.h</code>.</p><p>The constant <code>KERN_SUCCESS</code> is defined in <code>kern_return.h</code>.</p><a name="//apple_ref/doc/uid/TP30000385-SW5" title="Listing 1-2Finding a CD-ROM device and reading a sector"></a><p class="codesample"><strong>Listing 1-2&nbsp;&nbsp;</strong>Finding a CD-ROM device and reading a sector</p><div class="codesample"><table><tr><td scope="row"><pre>int main( void )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_iterator_t mediaIterator;<span></span></pre></td></tr><tr><td scope="row"><pre>    char deviceFilePath[ MAXPATHLEN ];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = MyFindEjectableCDMedia( &amp;mediaIterator );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( kernResult != KERN_SUCCESS )<span></span></pre></td></tr><tr><td scope="row"><pre>        return 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = MyGetDeviceFilePath( mediaIterator, deviceFilePath,<span></span></pre></td></tr><tr><td scope="row"><pre>                    sizeof( deviceFilePath ) );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( kernResult != KERN_SUCCESS )<span></span></pre></td></tr><tr><td scope="row"><pre>        return 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Now open the device we found, read a sector, and close the device.<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( deviceFilePath[ 0 ] != '\0' )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        int fileDescriptor;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        fileDescriptor = MyOpenDrive( deviceFilePath );<span></span></pre></td></tr><tr><td scope="row"><pre>        if (fileDescriptor != -1 )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( MyReadSector( fileDescriptor ) )<span></span></pre></td></tr><tr><td scope="row"><pre>                printf( "Sector read successfully.\n" );<span></span></pre></td></tr><tr><td scope="row"><pre>            else<span></span></pre></td></tr><tr><td scope="row"><pre>                printf( "Could not read sector.\n" );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            MyCloseDrive( fileDescriptor );<span></span></pre></td></tr><tr><td scope="row"><pre>            printf( "Device closed.\n" );<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        printf( "No ejectable CD media found.\n" );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Release the iterator.<span></span></pre></td></tr><tr><td scope="row"><pre>    IOObjectRelease( mediaIterator );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>main</code> function releases the iterator returned by the <code>MyFindEjectableCDMedia</code> function, which also releases the iterator’s objects. </p><a name="//apple_ref/doc/uid/TP30000385-SW8" title="Finding All Ejectable CD Media"></a><h3>Finding All Ejectable CD Media</h3><p><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_11"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_12"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_13"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_14"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_15"></a>The <code>MyFindEjectableCDMedia</code> function, shown in <span class="content_text"><a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-SW6">Listing 1-3</a></span>, establishes a connection to the I/O Kit by calling the <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOMasterPort" target="_top">IOMasterPort</a></code> function, which returns a Mach port. It then creates a matching dictionary by calling <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceMatching" target="_top">IOServiceMatching</a></code>, passing the constant <code><a href="../../../../Darwin/Reference/IOKit/IOCDMedia_h/index.html#//apple_ref/c/macro/kIOCDMediaClass" target="_top">kIOCDMediaClass</a></code> (defined in <code>IOCDMedia.h</code>). This sets up a dictionary that matches all devices with a provider class of IOCDMediaClass; all CD media devices in the I/O Registry are instances of this class or a subclass.</p><p>A matching dictionary is a dictionary of key-value pairs that describe the properties of an I/O Kit device or other service. Each IOMedia object in the I/O Registry has a property with key <code><a href="../../../../Darwin/Reference/IOKit/IOMedia_h/index.html#//apple_ref/c/macro/kIOMediaEjectableKey" target="_top">kIOMediaEjectableKey</a></code> and a value that is <code>true</code> if the media is indeed ejectable. In this sample, we are interested only in ejectable media, so the <code><!--a-->MyFindEjectableCDMedia<!--/a--></code> function refines the matching dictionary by calling <code><a href="../../../../CoreFoundation/Reference/CFMutableDictionaryRef/Reference/reference.html#//apple_ref/c/func/CFDictionarySetValue" target="_top">CFDictionarySetValue</a></code> to add the key <code>kIOMediaEjectableKey</code> and value <code><a href="../../../../CoreFoundation/Reference/CFBooleanRef/Reference/reference.html#//apple_ref/c/data/kCFBooleanTrue" target="_top">kCFBooleanTrue</a></code>.</p><p>The constants <code>kIOMediaEjectableKey</code> and <code>kIOCDMediaClass</code> are defined in <code>IOMedia.h</code> in <code>Kernel.framework</code>. The constant <code>kCFBooleanTrue</code> is a Core Foundation constant. If you need more information on the process of using matching dictionaries to find devices in the I/O Registry, see <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>.</p><p>Next<a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_16"></a>, <code>MyFindEjectableCDMedia</code> passes the dictionary to the I/O Kit function <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceGetMatchingServices" target="_top">IOServiceGetMatchingServices</a></code> to<a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_17"></a> obtain an iterator object that identifies all CD-ROM devices with ejectable media in the I/O Registry. If successful, <code>MyFindEjectableCDMedia</code> uses its pointer parameter to return the iterator object. The calling function is responsible for releasing this object.</p><p>Finally, <code>MyFindEjectableCDMedia</code> returns a result value that indicates whether it found any ejectable CD media. The constant <code>KERN_SUCCESS</code> is defined in <code>kern_return.h</code>.<a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_18"></a></p><a name="//apple_ref/doc/uid/TP30000385-SW6" title="Listing 1-3Finding all ejectable CD media"></a><p class="codesample"><strong>Listing 1-3&nbsp;&nbsp;</strong>Finding all ejectable CD media</p><div class="codesample"><table><tr><td scope="row"><pre>kern_return_t MyFindEjectableCDMedia( io_iterator_t *mediaIterator )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_port_t         masterPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t       kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMutableDictionaryRef   classesToMatch;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = IOMasterPort( MACH_PORT_NULL, &amp;masterPort );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( kernResult != KERN_SUCCESS )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf( "IOMasterPort returned %d\n", kernResult );<span></span></pre></td></tr><tr><td scope="row"><pre>        return kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // CD media are instances of class kIOCDMediaClass.<span></span></pre></td></tr><tr><td scope="row"><pre>    classesToMatch = IOServiceMatching( kIOCDMediaClass );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( classesToMatch == NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>        printf( "IOServiceMatching returned a NULL dictionary.\n" );<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Each IOMedia object has a property with key kIOMediaEjectableKey<span></span></pre></td></tr><tr><td scope="row"><pre>        // which is true if the media is indeed ejectable. So add this<span></span></pre></td></tr><tr><td scope="row"><pre>        // property to the CFDictionary for matching.<span></span></pre></td></tr><tr><td scope="row"><pre>        CFDictionarySetValue( classesToMatch,<span></span></pre></td></tr><tr><td scope="row"><pre>                        CFSTR( kIOMediaEjectableKey ), kCFBooleanTrue );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = IOServiceGetMatchingServices( masterPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                                classesToMatch, mediaIterator );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( (kernResult != KERN_SUCCESS) || (*mediaIterator == NULL) )<span></span></pre></td></tr><tr><td scope="row"><pre>        printf( "No ejectable CD media found.\n kernResult = %d\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                    kernResult );<span></span></pre></td></tr><tr><td scope="row"><pre>    return kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000385-SW9" title="Getting the Path to the Device File for the CD-ROM Device"></a><h3>Getting the Path to the Device File for the CD-ROM Device</h3><p><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_19"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_20"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_21"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_22"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_23"></a><span class="content_text"><a href="StorageDevFiles.html#//apple_ref/doc/uid/TP30000385-SW7">Listing 1-4</a></span> shows the <code><!--a-->MyGetDeviceFilePath<!--/a--></code> function. The parameters to this function specify an iterator over ejectable CD media devices, a pointer to storage for the device file path, and the maximum size of the path. The function returns, in the <code>deviceFilePath</code> parameter, the path to the device file, including filename, for the first such device it finds in the iterator.</p><p>The <code>MyGetDeviceFilePath</code> function examines the first object in the passed iterator. Although many computers have just one CD-ROM device, the iterator could actually contain objects for multiple devices; however, this function looks at only the first.</p><p>The <code><!--a-->MyGetDeviceFilePath<!--/a--></code> function performs the following steps:</p><ol class="ol"><li class="li"><p>It calls the I/O Kit function <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IORegistryEntryCreateCFProperty" target="_top">IORegistryEntryCreateCFProperty</a></code>, passing the key <code>kIOBSDNameKey</code> (defined in <code>IOBSD.h</code>), to obtain a <code><a href="../../../../CoreFoundation/Reference/CFTypeRef/Reference/reference.html#//apple_ref/c/tdef/CFTypeRef" target="_top">CFTypeRef</a></code> to the device file name.</p></li><li class="li"><p>If the call to <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IORegistryEntryCreateCFProperty" target="_top">IORegistryEntryCreateCFProperty</a></code> is successful, <code><!--a-->MyGetDeviceFilePath<!--/a--></code> constructs a device path to the device. To do this, the function:</p><ul class="ul"><li class="li"><p>Copies the string ‘<code>/dev/</code>’ (defined by the constant <code>_PATH_DEV</code> in the header <code>paths.h</code>) to the storage location specified by the <code>deviceFilePath</code> parameter</p></li><li class="li"><p>Concatenates the string <code>‘r’</code> to the end of the device path to ensure that the code accesses the raw device</p></li><li class="li"><p>Calls the <code><a href="../../../../CoreFoundation/Reference/CFStringRef/Reference/reference.html#//apple_ref/c/func/CFStringGetCString" target="_top">CFStringGetCString</a></code> function to encode the Core Foundation representation of the device name as a C string</p></li></ul></li><li class="li"><p>If <code><!--a-->MyGetDeviceFilePath<!--/a--></code> is able to create the device-file name successfully, it prints the string and releases the <code>CFTypeRef</code>. The full device file name will be something like <code>/dev/rdisk0</code>.</p></li></ol><p><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_24"></a>The <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOIteratorNext" target="_top">IOIteratorNext</a></code> function retains each media object it returns, so the <code>MyGetDeviceFilePath</code> function releases the iterator objects it examines. The calling function is responsible for releasing the iterator itself, which also releases the iterator’s objects.</p><p>Finally, <code>MyGetDeviceFilePath</code> returns a result value that indicates whether the function successfully obtained a device path for a CD-ROM device.</p><a name="//apple_ref/doc/uid/TP30000385-SW7" title="Listing 1-4Getting the device file path for the first ejectable CD media in a passed iterator"></a><p class="codesample"><strong>Listing 1-4&nbsp;&nbsp;</strong>Getting the device file path for the first ejectable CD media in a passed iterator</p><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_25"></a><div class="codesample"><table><tr><td scope="row"><pre>kern_return_t MyGetDeviceFilePath( io_iterator_t mediaIterator,<span></span></pre></td></tr><tr><td scope="row"><pre>                        char *deviceFilePath, CFIndex maxPathSize )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    io_object_t nextMedia;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t kernResult = KERN_FAILURE;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    *deviceFilePath = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre>    nextMedia = IOIteratorNext( mediaIterator );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( nextMedia )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CFTypeRef   deviceFilePathAsCFString;<span></span></pre></td></tr><tr><td scope="row"><pre>        deviceFilePathAsCFString = IORegistryEntryCreateCFProperty(<span></span></pre></td></tr><tr><td scope="row"><pre>                                nextMedia, CFSTR( kIOBSDNameKey ),<span></span></pre></td></tr><tr><td scope="row"><pre>                                kCFAllocatorDefault, 0 );<span></span></pre></td></tr><tr><td scope="row"><pre>       *deviceFilePath = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( deviceFilePathAsCFString )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            size_t devPathLength;<span></span></pre></td></tr><tr><td scope="row"><pre>            strcpy( deviceFilePath, _PATH_DEV );<span></span></pre></td></tr><tr><td scope="row"><pre>            // Add "r" before the BSD node name from the I/O Registry<span></span></pre></td></tr><tr><td scope="row"><pre>            // to specify the raw disk node. The raw disk node receives<span></span></pre></td></tr><tr><td scope="row"><pre>            // I/O requests directly and does not go through the<span></span></pre></td></tr><tr><td scope="row"><pre>            // buffer cache.<span></span></pre></td></tr><tr><td scope="row"><pre>            strcat( deviceFilePath, "r");<span></span></pre></td></tr><tr><td scope="row"><pre>            devPathLength = strlen( deviceFilePath );<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( CFStringGetCString( deviceFilePathAsCFString,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     deviceFilePath + devPathLength,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     maxPathSize - devPathLength,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     kCFStringEncodingASCII ) )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                printf( "BSD path: %s\n", deviceFilePath );<span></span></pre></td></tr><tr><td scope="row"><pre>                kernResult = KERN_SUCCESS;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRelease( deviceFilePathAsCFString );<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    IOObjectRelease( nextMedia );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000385-SW10" title="Opening the Device"></a><h3>Opening the Device</h3><p><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_26"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_27"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_28"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_29"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_30"></a>To open<a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_31"></a> a CD media device, the <code><!--a-->MyOpenDrive<!--/a--></code> function, shown in <span class="content_text">Listing 1-5</span>, calls the <code><!--a-->open<!--/a--></code> function, passing a device-file path and the constant <code>O_RDONLY</code>, which indicates the device should be opened for reading only. The <code><!--a-->open<!--/a--></code> function and <code>O_RDONLY</code> are both defined in <code>fcntl.h</code>, which is part of <code>System.framework</code>. You can get more information about the <code><!--a-->open<!--/a--></code> function by typing <code>man 2 open</code> in a Terminal window.</p><p>The <code>MyOpenDrive</code> function returns the value it gets from the <code>open</code> function; on error, it also prints an error message.</p><a name="//apple_ref/doc/uid/TP30000385-SW2" title="Listing 1-5Opening a device specified by its device file path"></a><p class="codesample"><strong>Listing 1-5&nbsp;&nbsp;</strong>Opening a device specified by its device file path</p><div class="codesample"><table><tr><td scope="row"><pre>int MyOpenDrive( const char *deviceFilePath )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int fileDescriptor;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fileDescriptor = open( deviceFilePath, O_RDONLY );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( fileDescriptor == -1 )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf( "Error opening device %s: \n", deviceFilePath );<span></span></pre></td></tr><tr><td scope="row"><pre>        perror( NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return fileDescriptor;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000385-SW11" title="Reading a Sector From the Device"></a><h3>Reading a Sector From the Device</h3><p><span class="content_text">Listing 1-6</span> shows a function, <code><!--a-->MyReadSector<!--/a--></code>, that reads a sector of the media. The caller of this function passes the file descriptor for a device file. The device is assumed to be open. <code><!--a-->MyReadSector<!--/a--></code> first uses the <code><!--a-->DKIOCGETBLOCKSIZE<!--/a--></code> ioctl to get the preferred block size for the media. Then, it allocates a buffer of the preferred block size and attempts to read a sector, using the <code><!--a-->read<!--/a--></code> function defined in the <code>unistd.h</code>. </p><a name="//apple_ref/doc/uid/TP30000385-SW13" title="Listing 1-6Reading a sector of the media, given the file descriptor"></a><p class="codesample"><strong>Listing 1-6&nbsp;&nbsp;</strong>Reading a sector of the media, given the file descriptor</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean MyReadSector( int fileDescriptor )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    char *buffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    size_t numBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>    u_int32_t blockSize;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( ioctl( fileDescriptor, DKIOCGETBLOCKSIZE, &amp;blockSize ) == -1)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        perror( "Error getting preferred block size." );<span></span></pre></td></tr><tr><td scope="row"><pre>        // Set a reasonable block size instead.<span></span></pre></td></tr><tr><td scope="row"><pre>        // kCDSectorSizeCDDA is defined in IOCDTypes.h as 2352.<span></span></pre></td></tr><tr><td scope="row"><pre>        blockSize = kCDSectorSizeCDDA;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    buffer = malloc( blockSize );<span></span></pre></td></tr><tr><td scope="row"><pre>    numBytes = read( fileDescriptor, buffer, blockSize );<span></span></pre></td></tr><tr><td scope="row"><pre>    free( buffer );<span></span></pre></td></tr><tr><td scope="row"><pre>    return numBytes == blockSize ? true : false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000385-SW12" title="Closing the Device"></a><h3>Closing the Device</h3><p><span class="content_text">Listing 1-7</span> shows the <code><!--a-->MyCloseDrive<!--/a--></code> function. To close<a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_32"></a> the CD-ROM device, <code><!--a-->MyCloseDrive<!--/a--></code> calls the <code><!--a-->close<!--/a--></code> function (defined in <code>unistd.h</code>), passing the file descriptor for the device file. The file descriptor was obtained by the <code>MyOpenDrive</code> function.<a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_33"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_34"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_35"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_36"></a><a name="//apple_ref/doc/uid/TP30000385-DontLinkElementID_37"></a></p><a name="//apple_ref/doc/uid/TP30000385-SW14" title="Listing 1-7Closing a device, given its file descriptor"></a><p class="codesample"><strong>Listing 1-7&nbsp;&nbsp;</strong>Closing a device, given its file descriptor</p><div class="codesample"><table><tr><td scope="row"><pre>void MyCloseDrive( int fileDescriptor )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    close( fileDescriptor );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WWStorage_Intro/WWStorage_Intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WWStorage_RevHistory/WWStorage_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-03-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WorkingWStorage/WWStorage_StorageDevs/StorageDevFiles.html%3Fid%3DTP40000968-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WorkingWStorage/WWStorage_StorageDevs/StorageDevFiles.html%3Fid%3DTP40000968-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WorkingWStorage/WWStorage_StorageDevs/StorageDevFiles.html%3Fid%3DTP40000968-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>