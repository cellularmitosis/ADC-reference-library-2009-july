<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Inverse Tables</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING103></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="ACI-102.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-104.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="ACI-2.html"><B>Advanced Color Imaging on the Mac OS</B></A> / <BR><DD><A HREF="ACI-99.html"><B>Chapter 7 - Color Manager</B></A> / <A HREF="ACI-100.html"><B>About the Color Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING103-0></A>
<H2><A NAME=MARKER-9-31></A>Inverse Tables</H2>
 <A NAME=MARKER-2-32></A>The Color Manager constructs inverse tables to remap the information in a device's color lookup table so that, when Color QuickDraw supplies a color, the Color Manager can quickly return the index to the closest color available in the CLUT.<P>
<DL>
<DT><B>Note</B>
<DD>The material in this section is provided for developers who are planning to create their own color-mapping methods; few programs need to use inverse tables directly, and even fewer need to create their own.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When an application sets the foreground color with the <CODE>RGBForeColor</CODE> function, and then draws using that color (with a <CODE>LineTo</CODE> function, for example), Color QuickDraw must determine how to deal with the 48 bits of that <CODE>RGBColor</CODE> data structure. If the line is drawn into a picture, Color QuickDraw can store all 48 bits of color information along with the line-drawing codes. But when it is drawn into a pixel map, some color information must be discarded, because even the deepest pixel map can store only 24 bits of color information per pixel.<P>
 Drawing into direct pixel maps, in which each pixel value directly specifies the red, green, and blue components of a color, is straightforward: Color QuickDraw truncates low-order bits from each 16-bit color component of the <CODE>RGBColor</CODE> data structure. Direct pixel maps can be either 16 or 32 bits deep, with each pixel value containing 15 or 24 bits of color information (5 or 8 bits per component, with the other bits unused).<A NAME=MARKER-2-33></A><P>
 <A NAME=MARKER-2-34></A>Indexed pixel maps don't contain <CODE>RGBColor</CODE> data structures; they contain indexes to a color table where the <CODE>RGBColor</CODE> data structures are stored. The color table of a <CODE>GDevice</CODE> data structure reflects the current CLUT values for that device. When an application requests a color for an indexed device, Color QuickDraw calls on the Color Manager to determine which color currently in the <CODE>GDevice</CODE> data structure's color table (and hence the device's CLUT) comes closest to the requested color. The Color Manager function <CODE>Color2Index</CODE> returns the index for a given color, and Color QuickDraw stores that index in the pixel map. Indexed pixel maps can be 1, 2, 4, or 8 bits deep. (A 1-bit pixel map is effectively the same as a bitmap.) The most common device CLUT has 256 entries, each of which can be addressed by a pixel map that is 8 bits deep. <A NAME=MARKER-2-36></A><P>
 Determining the best color choice out of 256 candidates can take a lot of processing time. To speed up processing, the Color Manager builds an inverse table for every indexed device that the Slot Manager finds at startup. The Color Manager stores a handle to the inverse table in the <CODE>gdITable</CODE> field of the <CODE>GDevice</CODE> data structure. An inverse table organizes the information in a device's CLUT so that, given an <CODE>RGBColor</CODE> data structure, the index to the best color can be found quickly. Its format is the inverse of a color table: instead of a collection of <CODE>RGBColor</CODE> data structures that can be looked up by an index, the inverse table contains a collection of color table indexes that can be looked up by an RGB color value.<P>
 The format of an inverse table can be illustrated compactly with a hypothetical color world in which red, green, and blue components are only 1 bit deep each. Shown in <A HREF=#MARKER-9-37>Figure 7-1</A>, the eight possible RGB color values of such a world are the indexes into a table whose entries consist of indexes to the best colors in the CLUT for that RGB color value.<P>
<B>Figure 7-1  <A NAME=MARKER-9-37></A>Sample inverse table</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-01.jpg">
 In the Color QuickDraw world, inverse tables may use 3, 4, or 5 bits for each color component. The number of bits used is called the <I>resolution</I> of the inverse table. The size of the table depends on its resolution; the table must be large enough to accommodate every color combination at a given resolution. For example, the number of combinations in a table of resolution 3 is 512, so an inverse table of resolution 3 has 512 entries, of one byte each. (Here's how to calculate the 512: there are 3 bits each for red, green, and blue, totaling 9 bits, the permutations of which are 29 or 512.) Tables of resolution 4 and 5 occupy approximately 4 KB and 32 KB, respectively. <P>
 The format of an inverse table follows.<P>
<PRE>
struct ITab {
   long        iTabSeed;   /* copy of color table seed */
   short       iTabRes;    /* resolution of table: 3, 4, or 5 */
   unsigned chariTTable[1]; /* byte-length color */
                           /*  table index values */
};
typedef struct ITab ITab;
</PRE>
<DL>
<DT><B>WARNING</B>
<DD>Because the format of inverse tables is subject to change in the future, or may not be present on certain devices, applications should not assume the structure of the inverse table's data.<IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The first entry of the <CODE>iTabTable</CODE> array, at location 0 (red, green, and blue values of 0000, 0000, 0000 in a table of resolution 4) contains the index to black or the nearest color to it in the CLUT. Similarly, the last entry in a table of resolution 4, at location 4095 (1111, 1111, 1111), contains the CLUT index to white. <P>
 Since the largest CLUT has only 256 entries, many inverse table entries contain duplicates of other entries. For example, in an inverse table of resolution 4, the first several entries may all point to the index for black, the last few entries may all point to the index for white, and even various entries in the middle may point to white or black, as illustrated in <A HREF=#MARKER-9-38>Figure 7-2</A>.<P>
<B>Figure 7-2  <A NAME=MARKER-9-38></A>An inverse table of resolution 4</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-02.jpg">
<DL>
<DT><B>Note</B>
<DD>Finding indexes by means of inverse tables is the Color Manager's default method for color mapping. Applications with special color processing requirements may need to override the code for inverse table mapping with custom functions that have special mapping rules.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING103-19></A>
<H3>Inverse Tables in Action</H3>
 When Color QuickDraw supplies a color, the Color Manager truncates the red, green, and blue values to the size of the table resolution, and concatenates the results to form an index into the table. At that location, the Color Manager, when it built the inverse table, stored the index to the best-mapping color in the CLUT. <P>
 <A HREF=#MARKER-9-1>Table 7-1</A> shows two indexes into two inverse tables, one of resolution 4, the other of resolution 5, when the <A NAME=MARKER-10-17></A><CODE>Color2Index</CODE> function is given a color of 0x123456789ABC: <A NAME=MARKER-9-40></A>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><B>Table 7-1 Sample inverse table indexes</B><A NAME=MARKER-9-1></A></CAPTION>
<TH>Table resolution<TH><CODE>RGBColor</CODE> data structure<TH>Inverse table index<TH>Table size<TR>
<TD>4-bit<TD>red=0x1234, green=0x5678,<BR>blue=0x9ABC<TD>0x0159<TD>2<EM>12</EM> = 4 KB<TR>
<TD>5-bit<TD>red=0x1234, green=0x5678,blue=0x9ABC<TD>0x0953<TD>2<EM>15</EM> = 32 KB</TABLE>
<P>
 The Color Manager derived the 4-bit index by taking the top 4 bits of each color component. The 5-bit index is more subtle. <A HREF=#MARKER-9-41>Figure 7-3</A> illustrates the steps of truncation and concatenation that result in the value 0x0953.<P>
<B>Figure 7-3  Creating an inverse table index<A NAME=MARKER-9-41></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-03.jpg">
 The Color Manager truncates the high-order 8 bits of each color component to the high-order 5 bits, and then concatenates those 15 bits. The resulting value, 0x0953 in hexadecimal, is the index into the inverse table.<P>
<A NAME=HEADING103-26></A>
<H3>Hidden Colors</H3>
 Colors that are close in the red, green, and blue color space can become hidden when they differ only in low-order bits that weren't used to construct the inverse table index. For example, even if the CLUT were loaded with 256 levels of gray, a 4-bit inverse table can only discriminate among 16 of the levels. (In the 4096 permutations there are only 16 places where the red, green, and blue values are equal.) <P>
 To solve this problem, inverse tables carry additional information about how to find colors that differ only in the less significant bits. (The information is kept private to the Color Manager.) As a result, when the <CODE>Color2Index</CODE> function is called, it can find the best color to the full 48-bit resolution available in a <CODE>ColorSpec</CODE> data structure. Since examining the extra information takes time, certain parts of Color QuickDraw, notably the arithmetic transfer modes, don't use this information and hence won't find the hidden colors.<P>
<A NAME=HEADING103-29></A>
<H3><A NAME=MARKER-9-43></A>Building Inverse Tables</H3>
 The Color Manager builds an inverse table for each graphics device at startup. The data in inverse tables remains valid as long as the CLUT from which it was built remains unchanged. <P>
 The Color Manager rebuilds a table whenever Color QuickDraw, the Color Picker Manager, or the Palette Manager requests colors from a graphics device whose CLUT has changed. To determine whether an inverse table has been changed, the Color Manager compares the <CODE>ctSeed</CODE> field of the current <CODE>GDevice</CODE> data structure's color table against the <CODE>iTabSeed</CODE> field of that graphics device's inverse table. Each function that modifies the <CODE>ColorTable</CODE> data structure (with the exception of the <CODE>RestoreEntries</CODE> function) increments the value in its <CODE>ctSeed</CODE> field. If <CODE>ctSeed</CODE> and <CODE>iTabSeed</CODE> don't match, the Color Manager invalidates the inverse table and rebuilds it.<P>
<DL>
<DT><B>Note</B>
<DD>Under normal circumstances, your application does not know when the Color Manager has invalidated an inverse table. The method of invalidation is the same as the one that Color QuickDraw uses to invalidate expanded patterns and cursors.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 If your application modifies a color table entry directly (which is not recommended), it should call the <A NAME=MARKER-2-44></A><CODE>CTabChanged</CODE> function, described in the chapter "Color QuickDraw" in <a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><I>Inside Macintosh: Imaging With QuickDraw</I>.</a> For the <CODE>ColorTable</CODE> record you specify in the <CODE>ctab</CODE> parameter, the <CODE>CTabChanged</CODE> procedure calls the Color Manager function <CODE>GetCTSeed</CODE> to get a new seed (that is, a new, unique identifier in the <CODE>ctSeed</CODE> field of the <CODE>ColorTable</CODE> record) and notifies Color QuickDraw of the change.<P>
 The Color Manager builds or rebuilds an inverse table in the following manner:<P>
<OL>
<LI>It builds a table of all possible RGB color values taken 3, 4, or 5 bits at a time.
<LI>For each position in the table, it attempts to find the closest match.
<LI>It adds information to get a better resolution.<P>
</OL>
 The Color Manager builds an inverse table with the <A NAME=MARKER-2-45></A><CODE>MakeITable</CODE> function, which supports only 3-bit, 4-bit, and 5-bit resolution. (Five bits is the maximum resolution, because the indexes into a 6-bit table would have to be 18 bits long, more than a full word.) In most cases, when your application sets colors in a graphics port using the <CODE>RGBForeColor</CODE> and <CODE>RGBBackColor</CODE> functions or uses <CODE>CopyBits</CODE> to transfer pixel maps, inverse tables of 4 bits, the default, are sufficient. If you use arithmetic transfer modes with color tables that have closely spaced colors, the screen appearance may be improved by specifying inverse tables at 5-bit resolution, which may uncover some hidden colors. <A NAME=MARKER-2-46></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="ACI-102.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-104.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="ACI-3.html">&copy; Apple Computer, Inc.</A><br>13 NOV 1996<P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML> 
