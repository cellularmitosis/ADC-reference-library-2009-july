<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>SCSI Architecture Model Device Interface Guide: Accessing SCSI Parallel Devices</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Accessing SCSI Parallel Devices"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000386" title="Accessing SCSI Parallel Devices"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/SCSI-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000567" target="_top">SCSI</a> &gt; <a href="../WWS_Intro/WWS_Intro.html#//apple_ref/doc/uid/TP30000743-BAJDAJDJ">SCSI Architecture Model Device Interface Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WWS_Intro/WWS_Intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WWS_SAMDevInt/WWS_SAM_DevInt.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000386-SW1" title="Accessing SCSI Parallel Devices"></a><h1><a name="//apple_ref/doc/uid/TP30000386-BAJDAJDJ" title="Accessing SCSI Parallel Devices"></a>Accessing SCSI Parallel Devices</h1><p>In versions of Mac OS X prior to v10.2, if you wanted to access a SCSI Parallel device that was not accessible with the SCSI Architecture Model family’s device interfaces, you used the SCSI family’s device interfaces. Beginning with Mac OS X v10.2, however, Apple introduced the SCSI Parallel family to support SCSI controllers. The new family is designed to allow the SCSI Architecture Model family to support SCSI devices attached to those controllers, which means you can use the SCSI Architecture Model family’s device interfaces to access all SCSI devices that do not declare a peripheral device type of $00, $05, $07, or $0E.</p><p>As third-party developers release new SCSI controller drivers that use the SCSI Parallel family and as users install these new drivers, the SCSI Parallel family will replace the SCSI family. During the transition, however, the APIs of both families are available. This means that you can use the API of both families to look up your device and then use the API that successfully found your device to communicate with it. You might need to use both APIs in a single application if the following is true:</p><ul class="ul"><li class="li"><p>Your application must remain compatible with Mac OS X v10.2.x or earlier.</p></li><li class="li"><p>You need to access a SCSI Parallel device you could not previously access using the SCSI Architecture Model family’s device interfaces.</p></li></ul><p>If these statements describe your situation, you can use both APIs to find and communicate with your device. This way, your application will be able to find all the devices it’s interested in regardless of the SCSI controller drivers the user has installed. More importantly, your application will still work when the SCSI family is replaced and all SCSI controllers are supported by the SCSI Parallel family. (Note, however, that the APIs of the deprecated SCSI family will not work in an Intel-based Macintosh.)</p><p>If, on the other hand, compatibility with Mac OS X v10.2.x or earlier is not required or your application already uses the device interfaces of the SCSI Architecture Model family to access your device, you should not use the SCSI family API in your application. Instead, see <span class="content_text"><a href="../WWS_SAMDevInt/WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIIFCJB">“Accessing SCSI Architecture Model Devices”</a></span> for information on how to use the SCSI Architecture Model family device interfaces.</p><p>This chapter describes how to use the deprecated SCSI family API to find and access a SCSI Parallel device that you cannot access using the SCSI Architecture Model family API. To illustrate this, it uses the <em><a href="../../../../../samplecode/SCSIOldAndNew/index.html#//apple_ref/doc/uid/DTS10000448" target="_top">SCSIOldAndNew</a></em> sample project, which employs the API of both families to find and access a SCSI Parallel device. Because the SCSI Architecture Model family’s device interfaces are thoroughly covered in <span class="content_text"><a href="../WWS_SAMDevInt/WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIIFCJB">“Accessing SCSI Architecture Model Devices,”</a></span> this chapter focuses on the SCSI family’s application-level support for SCSI devices. Although the <em>SCSIOldAndNew</em> sample project demonstrates how to use the APIs of both families to find and access a SCSI Parallel device, this chapter does not describe the project’s use of the SCSI Architecture Model API. If you are unfamiliar with the SCSI Architecture Model family and you plan to use the APIs of both families in your application, be sure to read <span class="content_text"><a href="../WWS_SAMDevInt/WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIIFCJB">“Accessing SCSI Architecture Model Devices”</a></span> in addition to reading this chapter.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000386-DontLinkElementID_5" title="Important:"></a><p><strong>Important:</strong>&nbsp;The sample code in this chapter is written to work with Mac OS X v10.2 or later and may not work with earlier versions.</p><p></p></div><p>Although the sample code outlined in this chapter has been compiled and tested to some degree, Apple does not recommend that you directly incorporate this code into a commercial application. Its function is to illustrate the techniques you need to access a SCSI Parallel device; it does not attempt to exercise all features of the APIs or to demonstrate exhaustive error handling or an ideal user interface.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000386-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;The APIs of the deprecated SCSI family (including the IOSCSIDeviceInterface and CDBCommandInterface) will not work in an Intel-based Macintosh. If you are ready to develop a universal binary version of your device-access application, you must use the device interface APIs provided by the SCSI Architecture Model family. See <span class="content_text"><a href="../WWS_SAMDevInt/WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-SW2">“SCSI Device Access in an Intel-Based Macintosh”</a></span> for more information.</p><p></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-BABIAHJE">SCSI Family Support for SCSI Parallel Devices</a>
				
			<br/>
			
        
			
			
				<a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CHDGJHHG">Working With SCSI Family Device Interfaces</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000386-BABIAHJE" title="SCSI Family Support for SCSI Parallel Devices"></a><h2>SCSI Family Support for SCSI Parallel Devices</h2><p>The SCSI (Small Computer System Interface) Parallel Interface is an industry standard parallel data bus that provides a consistent method of connecting computers and peripheral devices. SCSI Parallel devices use SCSI Parallel technology to communicate with a computer.</p><p>On computers that do not have new SCSI Parallel family–supported SCSI controller drivers installed, the SCSI family provides application-level access to SCSI Parallel devices with two device interfaces: </p><ul class="ul"><li class="li"><p>The IOSCSIDeviceInterface, which provides functions that access the device</p></li><li class="li"><p>The IOCDBCommandInterface, which provides functions that create and execute CDB (command descriptor block) commands</p></li></ul><p>The IOSCSIDeviceInterface is defined in <code>IOSCSILib.h</code> and the IOCDBCommandInterface is defined in <code>IOCDBLib.h</code>, both in the I/O Kit framework. This section provides a brief description of CDB performance and an outline of how to gain access to a SCSI Parallel device.</p><a name="//apple_ref/doc/uid/TP30000386-CHDHCGHF" title="Performance and Threading With CDB Commands"></a><h3>Performance and Threading With CDB Commands</h3><p>A command descriptor block is defined as a structure up to 16 bytes in length that is used to communicate a command from an application client to a device server. To improve performance, Mac OS X queues CDB commands to help keep a SCSI Parallel device busy. When you use asynchronous commands, you can create more than one CDB command instance and execute subsequent commands as soon as you have queued the first command (by executing it). In fact, for best performance, you should try to use at least two commands whenever possible.</p><p>When a command completes, you can reuse the CDB command instance to execute another command. In reusing commands, keep the following in mind:</p><ul class="spaceabove"><li class="li"><p>No data in a CDB command is changed by executing the command, so that when you reuse the command, you must reset any values that need to be different for the next command.</p></li><li class="li"><p>When you use the <code><!--a-->setAndExecuteCommand<!--/a--></code> function to set up and execute a CDB command, it sets every CDB option, so you don’t need to worry about clearing previous data.</p></li><li class="li"><p>Once you have executed a command, it is not safe to change its value until its completion routine is called.</p></li></ul><p>You should create and communicate with a CDB command only from code in a single thread. However, you can have multiple threads that each create, execute, and reuse multiple commands. CDB commands are executed in the order sent, but if you use multiple threads to execute multiple commands, your code is responsible for ensuring any required ordering of commands.</p><p>When using multiple commands, don’t call <code><!--a-->close<!--/a--></code> on the device until all the commands have completed. If you close a device with one or more outstanding asynchronous commands, some queued commands may be cancelled with a completion status of failed.</p><a name="//apple_ref/doc/uid/TP30000386-TPXREF110" title="The SCSI Device Interface"></a><h3>The SCSI Device Interface</h3><p>The I/O Kit’s SCSI family provides a SCSI device interface that applications can use to access SCSI Parallel devices on Mac OS X. For the full definition of the SCSI device interface, see <code>IOSCSILib.h</code>.</p><p>You may need to access SCSI Parallel devices for a number of reasons, such as:</p><ul class="spaceabove"><li class="li"><p>Your utility application needs to list all the currently available SCSI Parallel devices, query them, and possibly perform operations on them (you can find devices and obtain cached device information from the I/O Registry without creating a device interface, but to query or control the device you do need a device interface).</p></li><li class="li"><p>Your application needs to drive a SCSI scanner.</p></li></ul><p><span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-BABJJIJJ">Figure 1-1</a></span> shows an application that uses a device interface to act as a driver for a SCSI Parallel scanner. The application calls functions of the device interface, which communicates with a SCSI device nub (based on the IOSCSIDevice class) in the kernel.</p><br/><div><a name="//apple_ref/doc/uid/TP30000386-BABJJIJJ" title="Figure 1-1An application communicating with a SCSI device through a device interface"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>An application communicating with a SCSI device through a device interface</p><img src = "../art/acchardware_iokit_002.gif" alt = "An application communicating with a SCSI device through a device interface" width="217" height="227"></div><br/><p>To the application, the device interface is just a plug-in interface that provides access to the device through functions such as <code>open</code>, <code>close</code>, and <code>reset</code>. To the device nub, the device interface looks like just another driver the nub can communicate with.</p><a name="//apple_ref/doc/uid/TP30000386-CHDGJHHG" title="Working With SCSI Family Device Interfaces"></a><h2>Working With SCSI Family Device Interfaces</h2><p>Although each I/O Kit family that provides application-level access to devices may implement the device-interface mechanism in a slightly different way, the fundamental steps you take to use a device interface to access a device from an application remain the same:</p><ol class="ol"><li class="li"><p>Get the I/O Kit master port that allows applications to communicate with the I/O Kit.</p></li><li class="li"><p>Use family matching information and I/O Kit functions to find the device.</p></li><li class="li"><p>Get the appropriate device interface for the device.</p></li><li class="li"><p>Open a connection to the device and send it commands (in some cases, this step requires you to get an additional device interface).</p></li><li class="li"><p>Close the device and release any device interfaces you’ve acquired.</p></li></ol><p>This section guides you through these steps, using code from the <em>SCSIOldAndNew</em> sample project to illustrate an example implementation. In the interest of brevity, this section does not reproduce the sample project in its entirety. Instead, this section provides partial listings from the project to illustrate the techniques you use to access a SCSI Parallel device using the API of the deprecated SCSI family. To run the sample project with your own devices, download the project from <span class="content_text"><a href="../../../../../samplecode/HardwareDrivers/idxSCSI-date.html#//apple_ref/doc/uid/TP30000925-TP40003576-TP30000567" target="_top">Sample Code > Hardware &amp; Drivers > SCSI</a></span> and build it on your computer.</p><p>Fundamental to the design of the <em>SCSIOldAndNew</em> sample project is the strict separation of the SCSI family functions from those of the SCSI Architecture Model family. Although you might choose to structure your code differently, the partitioning of the <em>SCSIOldAndNew</em> project is a useful feature to emulate. If your compatibility requirements change in the future, for example, it will be much easier to remove the code that uses the deprecated SCSI family API if it is kept separate from the rest of your application. The sample project divides its code into three modules:</p><ul class="ul"><li class="li"><p>A main module, called <code>SCSIOldAndNew.c</code>, that establishes the user interface and calls functions from the remaining two modules to find and access the user-selected device.</p></li><li class="li"><p>The <code>STUCMethod.c</code> module, which uses the SCSI Architecture Model family API to find and access the device. (The abbreviation STUC stands for SCSITaskUserClient, the in-kernel counterpart of the SCSI Architecture Model family’s SCSITaskDeviceInterface you use to access a SCSI device.)</p><p>For more information about the SCSI Architecture Model family’s device interfaces, see <span class="content_text"><a href="../WWS_SAMDevInt/WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIIFCJB">“Accessing SCSI Architecture Model Devices.”</a></span></p></li><li class="li"><p>The <code>OldMethod.c</code> module, which uses the deprecated SCSI family API to find and access the device.</p></li></ul><p>The <em>SCSIOldAndNew</em> sample project is a Carbon application that defines an application-level event handler to process the user’s device selection. Because this is a design issue that does not affect the core purpose of the application, this section glosses over the Carbon-related implementation details, focusing instead on the use of the I/O Kit and SCSI family APIs to find and access the device.</p><a name="//apple_ref/doc/uid/TP30000386-TPXREF111" title="Getting the I/O Kit Master Port"></a><h3>Getting the I/O Kit Master Port</h3><p>The first step in accessing a device from an application is getting the I/O Kit master port. Because this step is required regardless of which family’s API you use to find and access the device, the <em>SCSIOldAndNew</em> project performs it in its main module.</p><p>The main module of the <em>SCSIOldAndNew</em> project, called <code>SCSIOldAndNew.c</code>, gives the user a list of peripheral device types from which to choose. The application’s event handler, a function called <code><!--a-->DoAppCommandProcess<!--/a--></code>, passes the user’s choice to the function <code><!--a-->TestDevices<!--/a--></code>. <code><!--a-->TestDevices<!--/a--></code> (shown in <span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBBCHEA">Listing 1-1</a></span>) acquires the I/O Kit master port and then attempts to find a device with the passed-in peripheral device type, first with the SCSI Architecture Model family API and then with the SCSI family API.</p><a name="//apple_ref/doc/uid/TP30000386-CJBBCHEA" title="Listing 1-1Setting up device look-up for both families"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>Setting up device look-up for both families</p><div class="codesample"><table><tr><td scope="row"><pre>void TestDevices(int peripheralDeviceType)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_port_t     masterPort = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_iterator_t   iterator = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOMasterPort(MACH_PORT_NULL, &amp;masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr != kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf(stderr, "Couldn't retrieve the master I/O Kit port.<span></span></pre></td></tr><tr><td scope="row"><pre>                    (0x%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // First try to find the device using the SCSI Architecture<span></span></pre></td></tr><tr><td scope="row"><pre>    // Model family API:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (FindDevicesUsingSTUC(peripheralDeviceType, masterPort, &amp;iterator)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        TestDevicesUsingSTUC(peripheralDeviceType, iterator);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else // Now try the SCSI family API:<span></span></pre></td></tr><tr><td scope="row"><pre>        if (FindDevicesUsingOldMethod(peripheralDeviceType, masterPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;iterator)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        TestDevicesUsingOldMethod(iterator);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf(stderr, "No devices with peripheral device type %02Xh<span></span></pre></td></tr><tr><td scope="row"><pre>                    found.\n", peripheralDeviceType);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (iterator) {<span></span></pre></td></tr><tr><td scope="row"><pre>        IOObjectRelease(iterator);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (masterPort) {<span></span></pre></td></tr><tr><td scope="row"><pre>        mach_port_deallocate(mach_task_self(), masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Although you might choose to develop your application differently, you should consider replicating the basic structure of this function somewhere in your code. If you require compatibility with Mac OS X v10.2.x or earlier or your device wasn’t previously accessible using the SCSI Architecture Model family’s API, you should first attempt to find the device using the SCSI Architecture Model API and if that fails, then try to find the device using the SCSI family API. You should then use whichever API successfully found the device to access the device.</p><a name="//apple_ref/doc/uid/TP30000386-TPXREF112" title="Finding the Device"></a><h3>Finding the Device</h3><p>To perform device matching (finding a device by locating its entry in the I/O Registry), you first create a matching dictionary. A matching dictionary is a dictionary of key-value pairs that describe the properties of a device or other service. Recall that when a device is discovered on a Mac OS X system, the I/O Kit instantiates a nub object that represents the device, attaches the nub to the I/O Registry, and registers it. The device family publishes properties in the nub that the I/O Kit uses to find a suitable driver for the device. Once you’ve created a matching dictionary, you can add keys and values that specify these properties to match on.</p><p>The <em>SCSIOldAndNew</em> project performs all its SCSI family–specific device matching and device access tasks in the module named <code>OldMethod.c</code>. To find a device of the user-selected peripheral device type, the main module calls the <code><!--a-->FindDevicesUsingOldMethod<!--/a--></code> function (shown later in <span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBHHGHA">Listing 1-3</a></span>), passing it the peripheral device type, the I/O Kit master port, and a pointer to an iterator. The iterator, an object of type <code>io_iterator_t</code>, will hold a reference to the first device object in a list of matching device objects found in the I/O Registry, if any.</p><p>First, however, <code><!--a-->FindDevicesUsingOldMethod<!--/a--></code> must create a matching dictionary that describes the device. To do this, it declares a variable of type <code>CFMutableDictionaryRef</code> and passes the address of this dictionary and the peripheral device type to the function <code><!--a-->CreateMatchingDictionaryForOldMethod<!--/a--></code>, shown in <span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBFACCA">Listing 1-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30000386-CJBFACCA" title="Listing 1-2Creating a matching dictionary for a SCSI Parallel device"></a><p class="codesample"><strong>Listing 1-2&nbsp;&nbsp;</strong>Creating a matching dictionary for a SCSI Parallel device</p><div class="codesample"><table><tr><td scope="row"><pre>void CreateMatchingDictionaryForOldMethod(SInt32 peripheralDeviceType,<span></span></pre></td></tr><tr><td scope="row"><pre>                CFMutableDictionaryRef *matchingDict)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32  deviceTypeNumber = peripheralDeviceType;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFNumberRef deviceTypeRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set up a matching dictionary to search the I/O Registry by class name<span></span></pre></td></tr><tr><td scope="row"><pre>    // for all subclasses of IOSCSIDevice.<span></span></pre></td></tr><tr><td scope="row"><pre>    *matchingDict = IOServiceMatching(kIOSCSIDeviceClassName);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (*matchingDict != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Add key for device type to refine the matching dictionary.<span></span></pre></td></tr><tr><td scope="row"><pre>        // First create a CFNumber to store in the dictionary.<span></span></pre></td></tr><tr><td scope="row"><pre>        deviceTypeRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;deviceTypeNumber);<span></span></pre></td></tr><tr><td scope="row"><pre>        CFDictionarySetValue(*matchingDict, CFSTR(kSCSIPropertyDeviceTypeID),<span></span></pre></td></tr><tr><td scope="row"><pre>                        deviceTypeRef);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>IOProviderClass</code>-<em>myDeviceClassName</em> key-value pair is a common one in matching dictionaries. The function in <span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBFACCA">Listing 1-2</a></span> passes the device-class name to the I/O Kit convenience function <code><!--a-->IOServiceMatching<!--/a--></code>, which creates the matching dictionary and places in it this key-value pair. Because the resulting dictionary would match on a potentially large number of devices, however, the <code><!--a-->CreateMatchingDictionaryForOldMethod<!--/a--></code> function also adds another key-value pair to narrow down the search to devices that identify themselves as the passed-in peripheral device type.</p><p>With the matching dictionary from <code><!--a-->CreateMatchingDictionaryForOldMethod<!--/a--></code>, the <code><!--a-->FindDevicesUsingOldMethod<!--/a--></code> function performs device look-up, using the I/O Kit function <code><!--a-->IOServiceGetMatchingServices<!--/a--></code>. This I/O Kit function looks in the I/O Registry for devices whose properties match the key-value pairs in the matching dictionary. It returns an <code>io_iterator_t</code> object you can think of as a pointer to a list of matching devices. To access each device, you pass the iterator object to the I/O Kit function <code><!--a-->IOIteratorNext<!--/a--></code>, which returns an <code><!--a-->io_object_t<!--/a--></code> object representing a matching device and resets the iterator to “point to” the next matching device. A partial listing of <code><!--a-->FindDevicesUsingOldMethod<!--/a--></code> is shown in <span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBHHGHA">Listing 1-3</a></span>.</p><a name="//apple_ref/doc/uid/TP30000386-CJBHHGHA" title="Listing 1-3Finding a device"></a><p class="codesample"><strong>Listing 1-3&nbsp;&nbsp;</strong>Finding a device</p><div class="codesample"><table><tr><td scope="row"><pre>boolean_t FindDevicesUsingOldMethod(SInt32 peripheralDeviceType,<span></span></pre></td></tr><tr><td scope="row"><pre>                mach_port_t masterPort, io_iterator_t *iterator)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMutableDictionaryRef  matchingDict = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    boolean_t           result = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CreateMatchingDictionaryForOldMethod(peripheralDeviceType,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;matchingDict);<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Now search I/O Registry for matching devices.<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOServiceGetMatchingServices(masterPort, matchingDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                            iterator);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (*iterator &amp;&amp; kr == kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>        result = true;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // IOServiceGetMatchingServices consumes a reference to the matching<span></span></pre></td></tr><tr><td scope="row"><pre>    // dictionary, so we don't need to release the dictionary reference.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The result <code><!--a-->FindDevicesUsingOldMethod<!--/a--></code> returns tells the main module if it found any devices of the specified peripheral device type that the SCSI family supports.</p><a name="//apple_ref/doc/uid/TP30000386-TPXREF113" title="Getting the Device Interface"></a><h3>Getting the Device Interface</h3><p><a name="//apple_ref/doc/uid/TP30000386-DontLinkElementID_8"></a>A<a name="//apple_ref/doc/uid/TP30000386-DontLinkElementID_9"></a> device interface provides functions your application or other code running on Mac OS X can use to access a device. Device interfaces are plug-in interfaces that conform to the Core Foundation plug-in model (for more information on Core Foundation plug-ins, see <span class="content_text"><a href="../../../../../referencelibrary/CoreFoundation/idxProcessManagement-date.html#//apple_ref/doc/uid/TP30000943-TP30000421-TP30000456" target="_top">Reference Library > Core Foundation</a></span>). </p><p>An I/O Kit family that provides a device interface defines a type that represents the collection of interfaces it supports and a type for each individual interface. The family gives these types UUIDs (universally unique IDs) that identify them. Most families also define meaningful names for these identifiers you can use in place of the 128-bit UUID values. The SCSI family, for example, defines the constant <code><!--a  -->kIOSCSIUserClientTypeID<!--/a--></code> as a synonym for the UUID B4291228-0F0F-11D4-9126-0050E4C6426F that identifies the SCSI device interface.</p><p>Before you can get a family-specific device interface, however, you must first create an interface of type <code>IOCFPlugInInterface</code>. This interface sets up functions required for all interfaces based on the Core Foundation plug-in model. Chief among these is the <code><!--a-->QueryInterface<!--/a--></code> function, which creates instances of family-specific device interfaces.</p><p>To get the SCSI family device interface, your application performs the following steps:</p><ol class="ol"><li class="li"><p>Get an intermediate interface of type <code>IOCFPlugInInterface</code>.</p><p><a name="//apple_ref/doc/uid/TP30000386-DontLinkElementID_10"></a>To obtain this interface, the application calls the <code>IOCreatePlugInInterfaceForService</code> function, passing the <code>io_object_t</code> representing the matching device (received from <code><!--a-->IOIteratorNext<!--/a--></code>), the value <code>kIOSCSIUserClientTypeID</code> for the plug-in type parameter, and the value <code>kIOCFPlugInInterfaceID</code> for the interface type parameter. (<code>kIOSCSIUserClientTypeID</code> is defined in <code>IOSCSILib.h</code> and <code>kIOCFPlugInInterfaceID</code> and <code><!--a-->IOCreatePlugInInterfaceForService<!--/a--></code> are defined in <code>IOCFPlugIn.h</code>.)</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP30000386-DontLinkElementID_11"></a>Get a SCSI device interface.</p><p>To do this, the application calls the <code><!--a-->QueryInterface<!--/a--></code> function of the IOCFPlugInInterface object, passing the UUID of the desired device interface. To retrieve the UUID from the family-defined device interface name, use the following term:</p><p><code>CFUUIDGetUUIDBytes(kIOSCSIDeviceInterfaceID)</code></p></li><li class="li"><p>Release the intermediate IOCFPlugInInterface object.</p><p>To do this, the application calls the <code><!--a-->IODestroyPlugInInterface<!--/a--></code> function (defined in <code>IOCFPlugIn.h</code>).</p></li></ol><p>After completing these steps, you have a device interface of type <code>IOSCSIDeviceInterface</code> you can use to examine the device’s cached information, open the device, and create the more specific CDB command interface.</p><p>The <em>SCSIOldAndNew</em> project performs these steps in the <code><!--a-->CreateDeviceInterfaceUsingOldMethod<!--/a--></code> function in the <code>OldMethod.c</code> module. <span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBJDDFI">Listing 1-4</a></span> shows part of this function, which is passed an <code>io_object_t</code> representing a matching device (received from a call to <code><!--a-->IOIteratorNext<!--/a--></code>) and a pointer to an interface of type <code>IOSCSIDeviceInterface</code>.</p><a name="//apple_ref/doc/uid/TP30000386-CJBJDDFI" title="Listing 1-4Creating a SCSI device interface"></a><p class="codesample"><strong>Listing 1-4&nbsp;&nbsp;</strong>Creating a SCSI device interface</p><div class="codesample"><table><tr><td scope="row"><pre>void CreateDeviceInterfaceUsingOldMethod(io_object_t scsiDevice,<span></span></pre></td></tr><tr><td scope="row"><pre>                    IOSCSIDeviceInterface ***interface)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOCFPlugInInterface **plugInInterface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    HRESULT     plugInResult = S_OK;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kr = kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32      score = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the base interface of type IOCFPlugInInterface.<span></span></pre></td></tr><tr><td scope="row"><pre>    // This object will be used to create the SCSI device interface object.<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOCreatePlugInInterfaceForService( scsiDevice,<span></span></pre></td></tr><tr><td scope="row"><pre>                          kIOSCSIUserClientTypeID, kIOCFPlugInInterfaceID,<span></span></pre></td></tr><tr><td scope="row"><pre>                          &amp;plugInInterface, &amp;score);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr != kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf(stderr, "Couldn't create a plug-in interface for the<span></span></pre></td></tr><tr><td scope="row"><pre>                    io_service_t. (0x%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Query the base plug-in interface for an instance of the specific<span></span></pre></td></tr><tr><td scope="row"><pre>        // SCSI device interface object.<span></span></pre></td></tr><tr><td scope="row"><pre>        plugInResult = (*plugInInterface)->QueryInterface(plugInInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>                            CFUUIDGetUUIDBytes(kIOSCSIDeviceInterfaceID),<span></span></pre></td></tr><tr><td scope="row"><pre>                            (LPVOID *) interface);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (plugInResult != S_OK) {<span></span></pre></td></tr><tr><td scope="row"><pre>            fprintf(stderr, "Couldn't create SCSI device interface.<span></span></pre></td></tr><tr><td scope="row"><pre>                        (%ld)\n", plugInResult);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        // We're now finished with the instance of IOCFPlugInInterface.<span></span></pre></td></tr><tr><td scope="row"><pre>        IODestroyPlugInInterface(plugInInterface);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000386-TPXREF114" title="Opening the Device and Sending Commands"></a><h3>Opening the Device and Sending Commands</h3><p>With the SCSIDeviceInterface object you’ve created, you can examine cached information about a device before you open it. You might choose to do this if, for example, you want to display this information and allow the user to verify that this is, in fact, the desired device. </p><p>The SCSIDeviceInterface defines a function called <code><!--a-->getInquiryData<!--/a--></code> that retrieves the information about the device. In the <code>OldMethod.c</code> module of the <em>SCSIOldAndNew</em> project, the function <code><!--a-->GetInquiryDataUsingOldMethod<!--/a--></code> (shown in <span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBEECID">Listing 1-5</a></span>) demonstrates how to call this device-interface function.</p><a name="//apple_ref/doc/uid/TP30000386-CJBEECID" title="Listing 1-5Getting cached data about a SCSI Parallel device"></a><p class="codesample"><strong>Listing 1-5&nbsp;&nbsp;</strong>Getting cached data about a SCSI Parallel device</p><div class="codesample"><table><tr><td scope="row"><pre>void GetInquiryDataUsingOldMethod(IOSCSIDeviceInterface **interface)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8       inquiryData[255];<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32      inquiryDataSize = sizeof(inquiryData);<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kr = kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    bzero(inquiryData, sizeof(inquiryData));    // Zero data block.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Call a function of the SCSI device interface that returns cached<span></span></pre></td></tr><tr><td scope="row"><pre>    // information about the device.<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = (*interface)->getInquiryData(interface, (SCSIInquiry *) inquiryData,<span></span></pre></td></tr><tr><td scope="row"><pre>                        sizeof(inquiryData), &amp;inquiryDataSize);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If error, print message and hang (for debugging purposes).<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr != kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf(stderr, "Couldn't get inquiry data for device. (0x%08x)\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                    kr);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        PrintSCSIInquiryDataUsingOldMethod((SCSIInquiry *) inquiryData,<span></span></pre></td></tr><tr><td scope="row"><pre>                    inquiryDataSize);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The function <code><!--a-->PrintSCSIInquiryDataUsingOldMethod<!--/a--></code> (not shown here) simply formats and displays device information, including:</p><ul class="spaceabove"><li class="li"><p>Peripheral device type</p></li><li class="li"><p>Vendor ID</p></li><li class="li"><p>Product ID and revision level</p></li><li class="li"><p>Response data format</p></li><li class="li"><p>Removability of media</p></li></ul><p>Although you can get this information without opening the device, if you want to send commands to a SCSI Parallel device, you must open the device and create an additional interface, called a CDBCommandInterface.</p><p>The SCSIDeviceInterface defines the <code><!--a-->open<!--/a--></code> function, which opens the device and, if it succeeds, causes all other calls to <code><!--a-->open<!--/a--></code> to fail with the <code><!--a  -->kIOReturnExclusiveAccess<!--/a--></code> error. After you’ve opened the device, you use the SCSIDeviceInterface’s <code><!--a-->QueryInterface<!--/a--></code> function (common to all Core Foundation plug-in interfaces) to create a CDBCommandInterface. You can use the CDBCommandInterface to send to the SCSI Parallel device commands such as:</p><ul class="spaceabove"><li class="li"><p>INQUIRY</p></li><li class="li"><p>TEST UNIT READY</p></li><li class="li"><p>READ BUFFER</p></li><li class="li"><p>WRITE BUFFER</p></li><li class="li"><p>REQUEST SENSE</p></li></ul><p>These and other commands are defined in <code>SCSIPublic.h</code> in the I/O Kit framework.</p><p>The function <code><!--a-->TestADeviceUsingOldMethod<!--/a--></code> (not shown here) demonstrates how to open a SCSI Parallel device using the <code><!--a-->open<!--/a--></code> function of the passed-in SCSIDeviceInterface:</p><p><code>(*interface)->open(interface);</code></p><p>It then passes the SCSIDeviceInterface object to the function <code><!--a-->CreateCommandInterfaceUsingOldMethod<!--/a--></code> to create the CDBCommandInterface object. <code><!--a-->CreateCommandInterfaceUsingOldMethod<!--/a--></code> is shown in <span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBJEHEC">Listing 1-6</a></span>.</p><a name="//apple_ref/doc/uid/TP30000386-CJBJEHEC" title="Listing 1-6Getting a CDBCommandInterface object"></a><p class="codesample"><strong>Listing 1-6&nbsp;&nbsp;</strong>Getting a CDBCommandInterface object</p><div class="codesample"><table><tr><td scope="row"><pre>IOCDBCommandInterface **CreateCommandInterfaceUsingOldMethod<span></span></pre></td></tr><tr><td scope="row"><pre>                            (IOSCSIDeviceInterface **interface)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    HRESULT         plugInResult = S_OK;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOCDBCommandInterface   **cdbCmdInterface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fprintf(stderr, "Opened device\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use the constant kIOCDBCommandInterfaceID, defined in<span></span></pre></td></tr><tr><td scope="row"><pre>    // IOCDBLib.h, to identify the CDBCommandInterface.<span></span></pre></td></tr><tr><td scope="row"><pre>    plugInResult = (*interface)->QueryInterface(interface,<span></span></pre></td></tr><tr><td scope="row"><pre>                        CFUUIDGetUUIDBytes(kIOCDBCommandInterfaceID),<span></span></pre></td></tr><tr><td scope="row"><pre>                        (LPVOID *) &amp;cdbCmdInterface);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If error, print message and hang (for debugging purposes).<span></span></pre></td></tr><tr><td scope="row"><pre>    if (plugInResult != S_OK) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf(stderr, "Couldn't create a CDB command. (%ld)\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                            plugInResult);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return cdbCmdInterface;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>With a CDBCommandInterface, you can send SCSI commands to your device. The <code><!--a-->ExecuteInquiryUsingOldMethod<!--/a--></code> function in the <code>OldMethod.c</code> module uses the INQUIRY command to illustrate how to set up a CDB command structure (defined in <code>CDBCommand.h</code>) and send it to the device. To do this, the <code><!--a-->ExecuteInquiryUsingOldMethod<!--/a--></code> function performs the following steps:</p><ol class="ol"><li class="li"><p>It allocates and initializes stack variables (including <code>inquiryData</code>, <code>range</code>, and <code>cdb</code>) to specify an INQUIRY command and to store the results.</p></li><li class="li"><p>It sets up a variable of type <code>CDBInfo</code> to specify the command, then calls the <code>setAndExecuteCommand</code> function of the CDB command interface to set command values and execute the command.</p><p>On return from the <code>setAndExecuteCommand</code> function, for an asynchronous command, the <code>seqNumber</code> variable contains a unique sequence number. For a synchronous command, the sequence number is always 0.</p><p>The <code>setAndExecuteCommand</code> function (defined in <code>IOCDBLib.h</code>) is a utility function you can use instead of making multiple calls to set values and then calling the <code>execute</code> function.</p></li><li class="li"><p>It calls the <code>getResults</code> function of the CDB command interface to obtain the results of the INQUIRY command.</p></li><li class="li"><p>It calls the <code>MyPrintSCSIInquiryData</code> utility function (not shown here) to print the results.</p></li><li class="li"><p>Because it uses only stack variables, it has nothing to release.</p></li></ol><p><span class="content_text"><a href="WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-CJBHHJBI">Listing 1-7</a></span> shows the <code><!--a-->ExecuteInquiryUsingOldMethod<!--/a--></code> function, minus its error-checking code.</p><a name="//apple_ref/doc/uid/TP30000386-CJBHHJBI" title="Listing 1-7Using a CDBCommandInterface object to send commands"></a><p class="codesample"><strong>Listing 1-7&nbsp;&nbsp;</strong>Using a CDBCommandInterface object to send commands</p><div class="codesample"><table><tr><td scope="row"><pre>void ExecuteInquiryUsingOldMethod(IOCDBCommandInterface<span></span></pre></td></tr><tr><td scope="row"><pre>                        **cdbCommandInterface)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8           inquiryData[36 /* 255 */];<span></span></pre></td></tr><tr><td scope="row"><pre>    IOVirtualRange  range[1];<span></span></pre></td></tr><tr><td scope="row"><pre>    CDBInfo         cdb;<span></span></pre></td></tr><tr><td scope="row"><pre>    CDBResults      results;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32          seqNumber;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kr = kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    bzero(inquiryData, sizeof(inquiryData));    // Zero data block.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    range[0].address = (IOVirtualAddress) inquiryData;<span></span></pre></td></tr><tr><td scope="row"><pre>    range[0].length  = sizeof(inquiryData);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    bzero(&amp;cdb, sizeof(cdb));<span></span></pre></td></tr><tr><td scope="row"><pre>    cdb.cdbLength = 6;<span></span></pre></td></tr><tr><td scope="row"><pre>    cdb.cdb[0] = kSCSICmdInquiry;<span></span></pre></td></tr><tr><td scope="row"><pre>    cdb.cdb[4] = sizeof(inquiryData);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kr = (*cdbCommandInterface)->setAndExecuteCommand(<span></span></pre></td></tr><tr><td scope="row"><pre>                                    cdbCommandInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    &amp;cdb,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    sizeof(inquiryData),<span></span></pre></td></tr><tr><td scope="row"><pre>                                    range,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    sizeof(range) / sizeof(range[0]),<span></span></pre></td></tr><tr><td scope="row"><pre>                                    0, /* isWrite */<span></span></pre></td></tr><tr><td scope="row"><pre>                                    0, /* timeoutMS */<span></span></pre></td></tr><tr><td scope="row"><pre>                                    0, /* target */<span></span></pre></td></tr><tr><td scope="row"><pre>                                    0, /* callback */<span></span></pre></td></tr><tr><td scope="row"><pre>                                    0, /* refcon */<span></span></pre></td></tr><tr><td scope="row"><pre>                                    &amp;seqNumber);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Check to be sure the INQUIRY command executed correctly here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kr = (*cdbCommandInterface)->getResults(cdbCommandInterface, &amp;results);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Check to be sure the getResults command executed correctly here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    PrintSCSIInquiryDataUsingOldMethod((SCSIInquiry *) inquiryData,<span></span></pre></td></tr><tr><td scope="row"><pre>                    results.bytesTransferred);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000386-TPXREF115" title="Closing the Device"></a><h3>Closing the Device</h3><p>When you’ve finished sending commands to the SCSI Parallel device, you must close it and release the device interfaces you acquired. Functions in the <code>OldMethod.c</code> module perform these tasks in reverse order, starting with the most recently acquired interface. The <code><!--a-->TestADeviceUsingOldMethod<!--/a--></code> function releases the CDBCommandInterface object:</p><div class="codesample"><table><tr><td scope="row"><pre>IOCDBCommandInterface **cdbCommandInterface;<span></span></pre></td></tr><tr><td scope="row"><pre>(*cdbCommandInterface)->Release(cdbCommandInterface);<span></span></pre></td></tr></table></div><p>Next, it closes the device, using the SCSIDeviceInterface function <code><!--a-->close<!--/a--></code>:</p><div class="codesample"><table><tr><td scope="row"><pre>IOSCSIDeviceInterface **interface;<span></span></pre></td></tr><tr><td scope="row"><pre>(*interface)->close(interface);<span></span></pre></td></tr></table></div><p>Finally, the <code><!--a-->TestDevicesUsingOldMethod<!--/a--></code> function releases the SCSIDeviceInterface object:</p><div class="codesample"><table><tr><td scope="row"><pre>IOSCSIDeviceInterface **interface;<span></span></pre></td></tr><tr><td scope="row"><pre>(*interface)->Release(interface);<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WWS_Intro/WWS_Intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WWS_SAMDevInt/WWS_SAM_DevInt.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WorkingWithSAM/WWS_ParaSCSI/WWS_ParallelSCSI.html%3Fid%3DTP40000971-2.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WorkingWithSAM/WWS_ParaSCSI/WWS_ParallelSCSI.html%3Fid%3DTP40000971-2.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WorkingWithSAM/WWS_ParaSCSI/WWS_ParallelSCSI.html%3Fid%3DTP40000971-2.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>