<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Mixed Mode (IM: PS)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING14></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="PPCSoftware-13.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCSoftware-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCSoftware-86.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCSoftware-15.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="PPCSoftware-2.html"><B>PowerPC System Software</B></A> / <BR><DD><A HREF="PPCSoftware-11.html"><B>Chapter 1 - Introduction to PowerPC System Software</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING14-0></A>
<H1><A NAME=MARKER-9-78></A>Mixed Mode</H1>
 <A NAME=MARKER-2-153></A>An <B>instruction set architecture</B> is the set of instructions recognized by a particular processor or family of processors. The <B>Mixed Mode Manager</B> is the part of the Macintosh system software that manages <B>mode switches</B> between code in different instruction set architectures, switching the execution context between the CPU's native PowerPC context and the 68LC040 Emulator. The 68LC040 Emulator is responsible for handling all code in the 680x0 instruction set. This includes existing 680x0 applications, device drivers, system extensions, and even parts of the system software itself that have not yet been rewritten to use the PowerPC instruction set.<A NAME=MARKER-2-45></A><A NAME=MARKER-2-48></A><A NAME=MARKER-2-49></A><P>
 Mode switches are required not only when the user switches from an emulated to a native application (or vice versa), but also when any application calls a system software routine or any other code that exists in a different instruction set. For example, the Memory Manager has been reimplemented in the first version of system software for PowerPC processor-based Macintosh computers as native PowerPC code. When an existing 680x0 application running under the 68LC040 Emulator calls a Memory Manager routine such as <CODE>NewHandle</CODE>, a mode switch is required to move out of the emulator and into the native PowerPC environment. Then, once the Memory Manager routine completes, another mode switch is required to return to the 68LC040 Emulator and to allow the 680x0 application to continue executing.<P>
 Similarly, PowerPC applications cause mode switches whenever they invoke routines that exist only as 680x0 code. For example, if a PowerPC application calls a part of <BR>the Macintosh Toolbox or Operating System that has not been ported native, a mode <BR>switch is required to move from the native environment to the environment of the 68LC040 Emulator.<P>
 The Mixed Mode Manager exists solely to manage these kinds of mode switches. It makes it possible for the execution environment of PowerPC processor-based Macintosh computers to accommodate a mixture of 680x0 applications, PowerPC applications, 680x0 system software, PowerPC system software, 680x0 executable resources, PowerPC executable resources, 680x0 device drivers, PowerPC device drivers, and so forth. The 68LC040 Emulator and the Mixed Mode Manager together allow both 680x0 code and PowerPC code to execute on the PowerPC microprocessor.<P>
 The Mixed Mode Manager is designed to hide, as much as possible, the hybrid nature of the mixed environment supported on PowerPC processor-based Macintosh computers. Occasionally, however, some executable code needs to interact directly with the Mixed Mode Manager to ensure that a mode switch occurs at the correct time. Because the 68LC040 Emulator is designed to allow existing 680x0 applications and system software to execute without modification, it's always the responsibility of native applications <BR>and system software to implement any changes necessary to interact with the Mixed Mode Manager.<P>
 This section describes the basic operation of the Mixed Mode Manager. It shows you how, if you're writing a native application, you might need to modify your application to make it compatible with the mixed environment of the system software for PowerPC processor-based Macintosh computers. If you use fairly simple techniques for calling code external to your application and use only the standard types of callback routines, the information in this section might be sufficient for your needs. If not, see the chapter "Mixed Mode Manager" in this book for complete information about the Mixed <BR>Mode Manager.<P>
<A NAME=HEADING14-7></A>
<H2>Cross-Mode Calls</H2>
 The Mixed Mode Manager is intended to operate transparently to most applications and other kinds of software. This means, in particular, that most <B>cross-mode calls</B> (calls <BR>to code in a different instruction set from the caller's instruction set) are detected automatically by the Mixed Mode Manager and handled without explicit intervention by the calling software. For instance, when a 680x0 application calls a Memory Manager routine--which, as you have already learned, exists as PowerPC code in the system software for PowerPC processor-based Macintosh computers--the Trap Manager dispatches to the code pointed to by the appropriate entry in the trap dispatch table. For routines that are implemented as native code, the entry in the trap dispatch table is a pointer to a routine descriptor, a data structure used by the Mixed Mode Manager to encapsulate information about a routine. The first field in a routine descriptor is an executable 680x0 instruction that invokes the Mixed Mode Manager. The Mixed Mode Manager handles all the details of switching to the native mode, calling the native code, and then returning to the 68LC040 Emulator. The calling application is completely unaware that any mode switches have occurred.<P>
 The operation of the Mixed Mode Manager is also completely transparent when a PowerPC application calls a system software routine that exists as 680x0 code, although the exact details are slightly different. When a native application calls a system soft-<BR>ware routine, the Operating System executes some glue code in an import library of executable code. The glue code inspects the trap dispatch table for the address of the called routine. If the called routine exists only as 680x0 code, the Mixed Mode Manager switches modes and calls the 680x0 routine. When the 680x0 code returns, the Mixed Mode Manager switches back to the native PowerPC environment and the execution of the PowerPC application continues.<P>
<DL>
<DT><B>Note</B>
<DD>See <A HREF=PPCSoftware-15.html#MARKER-9-121>"The PowerPC Native Environment" beginning on page 1-19</A> <BR>for information about the native execution environment, including import libraries.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 When writing PowerPC code, you need to explicitly intervene in the mode-switching process only when you execute code (or have code executed on your behalf) whose instruction set architecture might be different from that of the calling code. For example, whenever you pass the address of a callback routine to the Operating System or Toolbox, it's possible that the instruction set architecture of the code whose address you are passing is different from the instruction set architecture of the routine you're passing <BR>it to. In such cases, you need to explicitly signal the type of code you're passing and its calling conventions. Otherwise, the Mixed Mode Manager might not be called to make a required mode switch.<P>
 To see this a bit more clearly, suppose that you are writing a native PowerPC application that calls the Control Manager procedure <CODE>TrackControl</CODE>. <CODE>TrackControl</CODE> accepts as one of its parameters the address of an action procedure that is called repeatedly while the user holds down the mouse button in a control. <CODE>TrackControl</CODE> has no way of determining in advance the instruction set architecture of the code whose address you will pass it. Moreover, you have no way of determining in advance the instruction set architecture of the <CODE>TrackControl</CODE> procedure, so you cannot know whether your action procedure and the <CODE>TrackControl</CODE> procedure are of the same instruction set architecture. As a result, you must explicitly indicate the instruction set architecture of any callback routines whose addresses you pass to the system software.<P>
<A NAME=HEADING14-13></A>
<H2><A NAME=MARKER-9-83></A>Routine Descriptors<A NAME=MARKER-2-84></A></H2>
 You indicate the instruction set architecture of a particular routine by creating a <B>routine descriptor</B> for that routine. Here is the structure of a routine descriptor.<A NAME=MARKER-2-86></A><P>
<PRE>
struct RoutineDescriptor {
   unsigned short       goMixedModeTrap;  /*mixed-mode A-trap*/
   char                 version;          /*routine descriptor version*/
   RDFlagsType          routineDescriptorFlags;
                                          /*routine descriptor flags*/
   unsigned long        reserved1;        /*reserved*/
   unsigned char        reserved2;        /*reserved*/
   unsigned char        selectorInfo;     /*selector information*/
   short                routineCount;     /*index of last RR in this RD*/
   RoutineRecord        routineRecords[1];/*the individual routines*/
};
typedef struct RoutineDescriptor RoutineDescriptor;
</PRE>
 As you can see, the first field of a routine descriptor is an executable 680x0 instruction that invokes the Mixed Mode Manager. When the Mixed Mode Manager is called, it inspects the remaining fields of the routine descriptor--in particular the <CODE>routineRecords</CODE> field--to determine whether a mode switch is required. The <CODE>routineRecords</CODE> field is an array of <B>routine records,</B> each element of which describes a single routine. In the simplest case, the array of routine records contains a single element. Here is the structure of a routine record.<A NAME=MARKER-2-87></A><P>
<PRE>
struct RoutineRecord {
   ProcInfoType         procInfo;         /*calling conventions*/
   unsigned char        reserved1;        /*reserved*/
   ISAType              ISA;              /*instruction set architecture*/
   RoutineFlagsType     routineFlags;     /*flags for each routine*/
   ProcPtr              procDescriptor;   /*the thing we're calling*/
   unsigned long        reserved2;        /*reserved*/
   unsigned long        selector;         /*selector for dispatched calls*/
};
typedef struct RoutineRecord RoutineRecord;
typedef RoutineRecord *RoutineRecordPtr, **RoutineRecordHandle;
</PRE>
 The most important fields in a routine record are the <CODE>procInfo</CODE> field and the <CODE>ISA</CODE> field. The <CODE>ISA</CODE> field encodes the instruction set architecture of the routine being described. It must always contain one of these two constants:<P>
<PRE>
enum {
   kM68kISA          = (ISAType)0,     /*MC680x0 architecture*/
   kPowerPCISA       = (ISAType)1      /*PowerPC architecture*/};
</PRE>
 The <CODE>procInfo</CODE> field contains the routine's <B>procedure information,</B> which encodes <BR>the routine's calling conventions and information about the number and location of the routine's parameters. For the standard kinds of callback procedures and other <BR>types of "detached" code, the universal interface files include definitions of procedure information. For example, the C language interface file <CODE>Controls.h</CODE> includes <BR>this definition:<A NAME=MARKER-2-88></A><A NAME=MARKER-2-89></A><P>
<PRE>
enum {
   uppControlActionProcInfo = kPascalStackBased
       | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(ControlHandle)))
       | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))
};
</PRE>
 This procedure information specification indicates that a control action procedure follows standard Pascal calling conventions and takes two stack-based parameters, a control handle and a part code; the action procedure returns no result. Similarly, the file <CODE>Controls.h </code>defines the procedure information for a control definition function as follows:<A NAME=MARKER-2-34></A><A NAME=MARKER-2-91></A><P>
<PRE>
enum {
   uppControlDefProcInfo = kPascalStackBased
       | RESULT_SIZE(SIZE_CODE(sizeof(long)))
       | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))
       | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(ControlHandle)))
       | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(short)))
       | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long)))
};
</PRE>
 You can create a routine descriptor by calling the Mixed Mode Manager function <CODE>NewRoutineDescriptor</CODE>, as shown in <A HREF=#MARKER-9-92>Listing 1-1</A>.<P>
<B>Listing 1-1  <A NAME=MARKER-9-92></A>Creating a routine descriptor</B><P>
<PRE>
UniversalProcPtr myActionProc;
myActionProc = NewRoutineDescriptor((ProcPtr)MyAction, 
                                    uppControlActionProcInfo, 
                                    GetCurrentISA());
</PRE>
 <A NAME=MARKER-2-93></A>Here, <CODE>MyAction</CODE> is the address of your control action procedure and <CODE>GetCurrentISA</CODE> <BR>is a C language macro that returns the current instruction set architecture. When executed in the PowerPC environment, the <CODE>NewRoutineDescriptor</CODE> function creates <BR>a routine descriptor in your application heap and returns the address of that routine descriptor. When executed in the 680x0 environment, the <CODE>NewRoutineDescriptor</CODE> function simply returns its first parameter. Notice that the result returned by <BR>the NewRoutineDescriptor function is of type UniversalProcPtr. A <B>universal procedure pointer</B> is defined to be either a 680x0 procedure pointer or a pointer to a routine descriptor, essentially as follows:<P>
<PRE>
#if !USESROUTINEDESCRIPTORS
typedef ProcPtr UniversalProcPtr, *UniversalProcHandle;
#else
typedef RoutineDescriptor *UniversalProcPtr, **UniversalProcHandle;
#endif
</PRE>
 Once you've executed the code in <A HREF=#MARKER-9-92>Listing 1-1</A> (probably at application launch time), you can later call TrackControl like this:<P>
<PRE>
TrackControl(myControl, myPoint, myActionProc);
</PRE>
 If your application is a PowerPC application, the value passed in the <CODE>gActionProc</CODE> parameter is not the address of your action procedure itself, but the address of the routine descriptor created in <A HREF=#MARKER-9-92>Listing 1-1</A>. When a 680x0 version of <CODE>TrackControl</CODE> executes your action procedure, it begins by executing the instruction contained in the first field of the routine descriptor. That instruction invokes the Mixed Mode Manager, which inspects the instruction set architecture of the action routine (contained in the <CODE>ISA</CODE> field of the routine record contained in the routine descriptor). If that instruction set architecture differs from the instruction set architecture of the <CODE>TrackControl</CODE> routine, the Mixed Mode Manager causes a mode switch. Otherwise, if the two instruction set architectures are identical, the Mixed Mode Manager simply executes the action procedure without switching modes.<A NAME=MARKER-2-94></A><A NAME=MARKER-2-95></A><P>
 In short, you solve the general problem of indicating a routine's instruction set archi-<BR>tecture by creating routine descriptors and by using the addresses of those routine descriptors where you would have used procedure pointers in the 680x0 programming environment. You have to do this, however, only when you need to pass the address of a routine to some external piece of code (such as the Toolbox or Operating System or some other application) that might be in a different instruction set architecture from that of the routine. There are quite a number of cases in which you pass procedure pointers to the system software and which therefore require you to use the techniques illustrated above for Control Manager action procedures. Some of the typical routines you need to create routine descriptors for include<P>
<UL>
<LI>grow-zone functions<A NAME=MARKER-2-96></A>
<LI>control action procedures<A NAME=MARKER-2-97></A>
<LI>event filter functions<A NAME=MARKER-2-98></A>
<LI>VBL tasks<A NAME=MARKER-2-99></A>
<LI>Time Manager tasks
<LI>trap patches<A NAME=MARKER-2-101></A><A NAME=MARKER-2-102></A>
<LI>completion routines<A NAME=MARKER-2-103></A><P>
</UL>
 <A NAME=MARKER-2-104></A>The interface files for the PowerPC system software have been revised to change <BR>all references to parameters or fields of type <CODE>ProcPtr</CODE> to references of type <CODE>UniversalProcPtr</CODE>. In addition, these new <B>universal interface files</B> contain procedure information definitions for all the standard kinds of callback routines. Moreover, the universal interface files define new routines that you can use in place of the more general code shown in <A HREF=#MARKER-9-92>Listing 1-1 on page 1-17</A>. For example, the interface file <CODE>Controls.h</CODE> contains the definition shown in <A HREF=#MARKER-9-106>Listing 1-2</A> for the <CODE>NewControlActionProc</CODE> function.<A NAME=MARKER-2-105></A><P>
<B>Listing 1-2  <A NAME=MARKER-9-106></A>The definition of the <CODE>NewControlActionProc</CODE> routine</B><P>
<PRE>
typedef UniversalProcPtr ControlActionUPP;
#define NewControlActionProc(userRoutine) \
   (ControlActionUPP) NewRoutineDescriptor((ProcPtr)userRoutine, \
   uppControlActionProcInfo, GetCurrentISA())
</PRE>
 Because this routine is defined in the universal header files, you can replace the code in <A HREF=#MARKER-9-92>Listing 1-1</A> with the simpler code shown in <A HREF=#MARKER-9-107>Listing 1-3</A>.<P>
<B>Listing 1-3  <A NAME=MARKER-9-107></A>Creating a routine descriptor for a control action procedure</B><P>
<PRE>
ControlActionUPP myActionProc;
myActionProc = NewControlActionProc((ProcPtr)MyAction);
</PRE>
 In general, you should use the specific routines defined throughout the universal header files instead of the general technique illustrated in <A HREF=#MARKER-9-92>Listing 1-1</A>.<A NAME=MARKER-2-108></A><A NAME=MARKER-2-109></A><A NAME=MARKER-2-110></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD><A NAME=MARKER-9-111></A>You do not need to create routine descriptors for routines that are called only by your application. More generally, if you know for certain that a routine is always called by code of the same instruction set architecture, you can and should continue to use procedure pointers instead of universal procedure pointers. If, however, the address of one of your application's routines might be passed to a Toolbox or Operating System routine, you should make sure to use a routine descriptor.<EM></EM><A NAME=MARKER-2-113></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING14-48></A>
<H2>Memory Considerations</H2>
 The technique described in the previous section for using routine descriptors is by far the simplest and easiest to implement: any routine descriptors needed by an application are allocated in the application heap at application launch time. The descriptors remain allocated until the application terminates, at which time the entire application heap is reclaimed by the Process Manager. As a result, you don't have to dispose of any routine descriptors created in this way.<P>
 <A NAME=MARKER-2-114></A><A NAME=MARKER-2-115></A>If, in some case, you know that you won't be needing a routine descriptor any more during the execution of your application, you can explicitly dispose of it by calling <BR>the <CODE>DisposeRoutineDescriptor</CODE> function. This is most useful when you allocate a routine descriptor for temporary use only. For example, you might call some code that uses a callback procedure only very infrequently. In that case you can allocate the routine descriptor when the code is called and then release it when the code is done.<A NAME=MARKER-2-116></A><A NAME=MARKER-2-117></A><P>
 Finally, you can create a routine descriptor on the stack if you intend to use it only within a single procedure. The Mixed Mode Manager interface file <CODE>MixedMode.h</CODE> defines the C language macro <CODE>BUILD_ROUTINE_DESCRIPTOR</CODE> that you can use for this purpose, as well as for initializing static routine descriptors. For details, see <A HREF=PPCSoftware-19.html#MARKER-9-83>"Using Static Routine Descriptors" on page 2-22</A> in the chapter "Mixed Mode Manager" in this book.<A NAME=MARKER-2-347></A><A NAME=MARKER-2-345></A><A NAME=MARKER-2-120></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="PPCSoftware-13.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCSoftware-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCSoftware-86.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCSoftware-15.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="PPCSoftware-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
