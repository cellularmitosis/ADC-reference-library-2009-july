<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>TObject (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING24></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-23.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-25.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-22.html"><B>Chapter 2 - Basic Operations</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING24-0></A>
<H1><A NAME=MARKER-9-58></A><A NAME=MARKER-9-59></A><A NAME=MARKER-2-60></A>TObject</H1>
 Most of the classes in the MacApp class library descend from the <CODE>TObject</CODE> class. The <CODE>TObject</CODE> class defines fields and methods that provide basic functions used by many subclasses. To avoid unnecessary storage in the classes that descend from it, the <CODE>TObject</CODE> class defines a minimum of fields. In fact, its only fields serve as part of MacApp's RTTI support.<P>
 The methods of the <CODE>TObject</CODE> class enable an object to<P>
<UL>
<LI>provide RTTI information about its class hierarchy
<LI>initialize and free its data
<LI>create and delete objects
<LI>register as a dependent of another object and be notified of changes in the objects on which it depends
<LI>write its data to, or read its data from, a stream destination of any type (a file stream, a handle stream, and so on)
<LI>create a copy of itself
<LI>compare itself to another object
<LI>identify an operation that must be supplied by a subclass<P>
</UL>
 These services are described in the following sections.<P>
<A NAME=HEADING24-12></A>
<H2><A NAME=MARKER-9-61></A><A NAME=MARKER-9-62></A><A NAME=MARKER-2-63></A>RTTI Fields and Methods</H2>
 <A NAME=MARKER-2-64></A>MacApp supplies a number of macro definitions to make runtime type information available to your application, as described in <A HREF=MacAppProgGuide-23.html#MARKER-9-21>"Runtime Type Information," beginning on page 27</A>. MacApp's <CODE><A NAME=MARKER-2-65></A>MA_DECLARE_CLASS</CODE> macro is expanded to provide each class that uses it with a static <CODE>ClassDesc</CODE> field:<P>
<PRE>
static const ClassDesc fgClassDesc;
</PRE>
 Because the field is static (that is, one variable per class is instantiated, initialized at static init time, and accessed through the field), MacApp's RTTI support inserts just one <CODE>ClassDesc</CODE> field per class, not one per object.<P>
 When expanded, the <CODE>MA_DECLARE_CLASS</CODE> macro also defines the <CODE>GetClassDescDynamic</CODE> method, which returns the <CODE>ClassDesc</CODE> field for the class. Each class that uses MacApp's RTTI macros overrides this method to return its own <CODE>ClassDesc</CODE> field, so all subclasses of <CODE>TObject</CODE> are compatible for RTTI. This is important for operations such as determining whether an object belongs in a list of objects of a specific type.<P>
 You don't normally call <CODE>GetClassDescDynamic</CODE> directly--instead you call one of the following methods:<P>
<DL>
<DT><CODE>GetClassID</CODE>
<DD> Gets the class ID from the <CODE>ClassDesc</CODE> field
<DT><CODE>GetClassName</CODE>
<DD> Gets the class name from the <CODE>ClassDesc</CODE> field
<DT><CODE>GetStandardSignature</CODE>
<DD> Gets the class signature from the <CODE>ClassDesc</CODE> field
<DT><CODE>DescendsFrom</CODE>
<DD> Determines whether the object descends from the class specified by the passed <CODE>ClassDesc</CODE>
<DT><CODE>GetSuperClass</CODE>
<DD> Returns the <CODE>ClassDesc</CODE> field for the object's immediate superclass
<DT><CODE>IsSameClass</CODE>
<DD> Determines whether the object's <CODE>ClassDesc</CODE> information matches a specified <CODE>ClassDesc</CODE>
</DL>
 You can also use the <CODE>MA_MEMBER</CODE> and <CODE>MA_DYNAMIC_CAST</CODE> macros to access RTTI information, as shown in the following code fragment:<P>
<PRE>
if (MA_MEMBER(theControl, TPopup))
   ...; // Do something that requires theControl to descend from TPopup.

MMailable* mailDoc = MA_DYNAMIC_CAST(MMailable, fDocument);
if (!mailDoc)
   Failure(minErr, 0); // "...program error" if the document
                     // can't be cast to the desired type.
</PRE>
<A NAME=HEADING24-26></A>
<H2><A NAME=MARKER-2-28></A><A NAME=MARKER-9-67></A>Initializing and Freeing Objects</H2>
 MacApp uses a two-phase process for initializing objects. When you create a new object with the <CODE>new</CODE> routine, the first phase of initialization takes place automatically--the object's constructor routines are called (one for each class in the object's class hierarchy that has a constructor). Then you perform the second phase by calling the object's initialization method. An object's initialization method typically calls the initialization method of its parent object, and so on, up the class hierarchy. MacApp uses this two-phase initialization for objects it creates as well.<P>
 You free an object by calling its <CODE>Free</CODE> method, or by calling the convenience routine <CODE>FreeIfObject</CODE>, which is described later in this section. You can call <CODE>Free</CODE> on any object that descends from <CODE>TObject</CODE>, since <CODE>TObject</CODE> implements a <CODE>Free</CODE> method.<P>
 The following describes a useful approach for initializing and freeing objects in your application, using the class <CODE>T<I>YourClass</I></CODE> as an example:<P>
<UL>
<LI>When you define a class, supply it with a constructor routine that has the same name as the class itself (<CODE>T<I>YourClass</I></CODE>). In the constructor, set fields of the object to default or safe values (such as <CODE>NULL</CODE>). Don't do anything in the constructor that might fail, such as allocating memory--if a failure occurs in a constructor, the object may still have uninitialized references that make it unsafe to delete. That's why MacApp provides a two-phase initialization. (MacApp's failure mechanism is described in <A HREF=MacAppProgGuide-25.html#MARKER-9-21>Chapter 3, "Core Technologies."</A>)
<LI>If your class requires additional initialization, supply an initialization method. By convention, initialization methods start with an <CODE>I</CODE>, such as <CODE>I<I>YourClass</I></CODE>. If the parent class of <CODE>T<I>YourClass</I></CODE> has an initialization method, you normally call it from <CODE>I<I>YourClass</I></CODE>, often as the first action. In the <CODE>I<I>YourClass</I></CODE> method, do any memory allocation or other initialization that can't be safely done in the constructor routine.<P>
If <CODE>I<I>YourClass</I></CODE> does anything that may fail, put failure handling in a wrapper routine that creates an instance of your object and calls the initialization method. If a failure occurs, your destructor routine (described in the next item) will free the memory from any successful memory allocations; if it is appropriate to free the object itself, the wrapper routine can do so, using the <CODE>FreeIfObject</CODE> routine.
<LI>Supply your object with a destructor routine, <CODE>~T<I>YourClass</I></CODE>. A destructor method frees any memory allocated in the initialization method and performs any other necessary cleanup. It has the same name as the class, preceded by a tilde symbol (~), and is called automatically whenever an instance of the class is freed with the <CODE>delete</CODE> routine. Don't call any failure methods in the constructor. Use the <CODE>FreeIfObject</CODE> routine to free any objects allocated by <CODE>T<I>YourClass</I></CODE>.<P>
</UL>
 The <CODE>FreeIfObject</CODE> routine calls the <CODE>Free</CODE> method of the passed object. The <CODE>TObject::Free</CODE> method calls <CODE>ShallowFree</CODE>, which just calls <CODE>delete</CODE> to delete the object from the global object heap. The <CODE>delete</CODE> operator is described in the next section.<P>
 Your application may wish to prevent an object from being automatically freed when it is deleted. For example, you may be keeping track of references to an object and want to delete the object only when the reference count is zero. To prevent automatic freeing of a deleted object, you can imitate the MacApp class <CODE>TDeskScrapView</CODE>, which overrides the <CODE>Free</CODE> method but doesn't necessarily call <CODE>Inherited</CODE>.<A NAME=MARKER-2-161></A><P>
<A NAME=HEADING24-36></A>
<H2><A NAME=MARKER-2-69></A><A NAME=MARKER-9-44></A>Creating and Deleting Objects</H2>
 MacApp provides a global heap object, <CODE>gObjectHeap</CODE>, to allocate memory for objects your application creates with the global <CODE>new</CODE> operator. The <CODE>TObject</CODE> class overrides <CODE>operator</CODE> <CODE>new</CODE> and <CODE>operator</CODE> <CODE>delete</CODE> to work with MacApp's global heap object. The <CODE>operator</CODE> <CODE>new</CODE> routine calls MacApp's <CODE>MAOperatorNew</CODE> routine, which in turn calls <CODE>gObjectHeap-&gt;Allocate</CODE>. The <CODE>operator</CODE> <CODE>delete</CODE> routine calls the <CODE>MAOperatorDelete</CODE> routine, which in turn calls <CODE>gObjectHeap-&gt;Free</CODE>.<P>
 The global heap object is described in more detail in <A HREF=MacAppProgGuide-25.html#MARKER-9-21>Chapter 3, "Core Technologies."</A><P>
<A NAME=HEADING24-39></A>
<H2><A NAME=MARKER-2-71></A><A NAME=MARKER-9-72></A>Dependency Relationships</H2>
 MacApp implements a system for managing dependency relationships between objects. It allows an object to be registered as a dependent of another object and to be notified of changes in the object on which it depends. MacApp's dependency system is described in detail in <A HREF=MacAppProgGuide-25.html#MARKER-9-21>Chapter 3, "Core Technologies."</A><P>
 The <CODE>TObject</CODE> class supplies dependency support for all its subclasses, and works with the global dependency object, <CODE>gMacAppDependencies</CODE>, to support MacApp's dependency mechanism. The following <CODE>TObject</CODE> methods take part in dependency operations:<P>
<DL>
<DT><CODE>AddDependent</CODE>
<DD> Calls the global dependency space's <CODE>AddDependency</CODE> method to make the passed object a dependent of the current object
<DT><CODE>Changed</CODE>
<DD> Results in a call to <CODE>DoUpdate</CODE> for each dependent object (you call an object's <CODE>Changed</CODE> method when a change has occurred that should be reported to the object's dependents)
<DT><CODE>DoUpdate</CODE>
<DD> Called when a notifier of the current object changes; <CODE>DoUpdate</CODE> does nothing in <CODE>TObject</CODE>--subclasses add specific updating behavior
<DT><CODE>GetDependencySpace</CODE>
<DD> Accessor for the global dependency object, <CODE>gMacAppDependencies</CODE>
<DT><CODE>RemoveDependent</CODE>
<DD> Calls the global dependency space's <CODE>RemoveDependency</CODE> method to remove the passed object as a dependent of the current object
<DT><CODE>RemoveAllDependencies</CODE>
<DD> Calls the global dependency space's <CODE>RemoveDependencies</CODE> method to remove any dependency relationships based on the current object; <CODE>RemoveAllDependencies</CODE> is called by the <CODE>TObject::Free</CODE> method if <CODE>RemoveDependenciesOnFree</CODE> returns <CODE>TRUE</CODE>
<DT><CODE>RemoveDependenciesOnFree</CODE>
<DD> Returns <CODE>TRUE</CODE> in <CODE>TObject</CODE>, indicating that any dependency relationships that include this object should be removed when the object is freed
</DL>
 You can read more about these methods in the <I>MacApp Class and Method Reference</I>.<A NAME=MARKER-2-73></A><P>
<A NAME=HEADING24-50></A>
<H2><A NAME=MARKER-9-74></A><A NAME=MARKER-2-75></A>Reading and Writing Streams</H2>
 MacApp provides stream classes that are useful for transferring data between a variety of destinations, including files, memory, and resources.<P>
 The <CODE>TObject</CODE> class provides methods for reading and writing stream data. Any subclass of <CODE>TObject</CODE> can override the <CODE>WriteTo</CODE> method to write its data to a stream, and the <CODE>ReadFrom</CODE> method to read its data from a stream. MacApp's document classes use streams to write their data to disk.<P>
 MacApp's streaming mechanism is described in detail in <A HREF=MacAppProgGuide-25.html#MARKER-9-21>Chapter 3, "Core Technologies."</A><P>
<A NAME=HEADING24-54></A>
<H2><A NAME=MARKER-2-76></A><A NAME=MARKER-9-77></A>Cloning Objects</H2>
 You can create a new object by copying an existing object with the <CODE>Clone</CODE> method, which is implemented in <CODE>TObject</CODE>. Cloning produces an object whose fields have the same values as the original object. It can be an efficient way of duplicating an object without having to copy its values field by field.<P>
<A NAME=HEADING24-56></A>
<H3>Implementation of Cloning</H3>
 To implement cloning, the <CODE>TObject::Clone</CODE> method calls <CODE>TObject::ShallowClone</CODE>, which simply allocates a block of memory the size of the current object and uses the Toolbox <CODE>BlockMove</CODE> routine to copy the current object's data into the new object.<P>
 Classes that allocate memory or do any special handling need to override the <CODE>Clone</CODE> method. Typically, an override of <CODE>Clone</CODE> calls <CODE>Inherited::Clone</CODE> and casts the returned object to the type of the current class. It then clones any owned objects, sets up any special relationships, and does any other task that can't be handled by simply copying the original object.<P>
<A NAME=HEADING24-59></A>
<H3>Complications of Cloning</H3>
 Cloning can become complicated when the cloned object refers to another object. For example, should the referred-to object also be cloned? Or should the new object point to the same object the original object does? The answer can vary, depending on how the object reference is used. <P>
 Suppose, for example, you are cloning an object that has a reference to another object, and the referenced object logs an entry whenever the main object is accessed. You probably want to clone the log object as well, to keep a separate log for the new main object. You may also want to clear the log for the cloned object.<P>
 But suppose you are cloning an object that has a reference to a database object. Chances are you don't want to duplicate an entire database--you just want the original object and the new object to refer to the same database.<P>
 In still another case, suppose you are cloning a shape object that has a reference to a <CODE>TDrawingEnvironment</CODE> object. You might want all the shapes drawn in that environment to refer to the same <CODE>TDrawingEnvironment</CODE> object, or you might have reasons for keeping a separate copy with each shape.<P>
 You should consider these issues when cloning an object in your application. By default, the <CODE>Clone</CODE> method copies the original object exactly, so all references in the new object will point to the same items as the corresponding references in the cloned object. If this is not the desired behavior, you must change it by overriding the <CODE>Clone</CODE> method in your class.<P>
<DL>
<DT><B>Note</B>
<DD>Use of the <CODE>Clone</CODE> method may not be optimal for duplicating objects of type <CODE>TDocument</CODE> or its subclasses. You might instead call the application object's <CODE>DoMakeDocument</CODE> method to create a new document, then call a custom document-cloning method to copy specific information from the cloned document to the new document.<EM></EM><A NAME=MARKER-2-8></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING24-66></A>
<H2>Comparing Objects</H2>
 The <CODE>TObject</CODE> class provides several methods to test for object equality and inequality. The <CODE>IsSame</CODE> method compares the object to the passed object reference and returns <CODE>TRUE</CODE> if the object references match.<P>
 The <CODE>CompareObject</CODE> method and all of the <CODE>TObject</CODE> class operator comparison methods (<CODE>operator!=</CODE>, <CODE>operator&lt;</CODE>, <CODE>operator&lt;=</CODE>, <CODE>operator==</CODE>, <CODE>operator&gt;</CODE>, and <CODE>operator&gt;=</CODE>) call the <CODE>IsLessThan</CODE>, <CODE>IsGreaterThan</CODE>, and <CODE>IsEqual</CODE> methods to compare the object to the passed object reference. The <CODE>IsLessThan</CODE>, <CODE>IsEqual</CODE>, and <CODE>IsGreaterThan</CODE> methods do nothing in <CODE>TObject</CODE>, so you must override them if you wish to use them or to use <CODE>CompareObject</CODE> or the operator comparison methods.<P>
<DL>
<DT><B>Note</B>
<DD>Except for determining that two objects with the same numerical reference value are the same object, MacApp makes no definition of what object equality or inequality means. If you override MacApp's operator comparison methods, you should define these terms to have meaning in your application.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING24-70></A>
<H2><A NAME=MARKER-9-79></A>The SubClassResponsibility Method</H2>
 The <CODE><A NAME=MARKER-2-41></A>SubClassResponsibility</CODE> method reports that a method was called that should have been overridden by a subclass. This method can be useful during development as a reminder that a routine has not yet been implemented. The <CODE>SubClassResponsibility</CODE> method reports only in debug versions of the application--otherwise it does nothing.<A NAME=MARKER-9-81></A><A NAME=MARKER-9-82></A><A NAME=MARKER-2-83></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-23.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-25.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
