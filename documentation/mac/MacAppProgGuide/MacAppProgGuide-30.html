<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Dynamic Memory Allocation (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING30></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-29.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-31.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-25.html"><B>Chapter 3 - Core Technologies</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING30-0></A>
<H1><A NAME=MARKER-9-104></A><A NAME=MARKER-9-105></A><A NAME=MARKER-2-106></A>Dynamic Memory Allocation</H1>
 The Macintosh user interface, the Macintosh Toolbox, and MacApp all encourage the use of dynamic memory allocation. For example, many applications allow the user to open multiple files and windows, limited only by the amount of available memory. Since the number of windows and files that can be opened on a specific machine cannot be known in advance, applications usually allocate these data structures from the heap.<P>
 The Macintosh Operating System may also use the application heap to allocate memory. It doesn't notify the application when it does so, and if there isn't enough space in the heap for the system's needs, the application may crash. Some of the common uses of the application heap by the <A NAME=MARKER-2-107></A>operating system include <P>
<UL>
<LI>loading the application's code segments (on 68K-based machines)
<LI>loading system resources as required, including <CODE>'WDEF'</CODE> and <CODE>'CDEF'</CODE> resources, packages, and fonts
<LI>maintaining temporary data structures for purposes such as saving the screen area behind a pull-down menu, creating file lists for standard file dialog boxes, and allocating data structures for printing<P>
</UL>
 MacApp's memory management implements an overall strategy for working in such an environment. The goals of the strategy are twofold:<P>
<UL>
<LI>MacApp should always maintain enough free space in the application heap to satisfy the system's needs.
<LI>The heap should always have enough space to carry out essential program operations such as quitting or saving documents.<P>
</UL>
<A NAME=HEADING30-9></A>
<H2><A NAME=MARKER-9-108></A>Permanent and Temporary Memory</H2>
 MacApp's memory management scheme, implemented in the UMemory unit, attempts to ensure that critical memory requests always succeed. To do so, it defines two kinds of memory requests: temporary memory requests and permanent memory requests. A <A NAME=MARKER-2-109></A><B>temporary memory request</B> is a memory request that must succeed. For example, MacApp uses temporary requests to allocate memory for code segments and for Toolbox resources such as <CODE>'WDEF'</CODE> and <CODE>'CDEF'</CODE> resources.<P>
 A<A NAME=MARKER-2-110></A> <B>permanent memory request</B> is a memory request that can be allowed to fail. Permanent requests are used for normal allocations, such as memory needed to open a document. Permanent allocations are not purged until you explicitly dispose of them. <A HREF=MacAppProgGuide-123.html#MARKER-9-21>"Allocating Permanent and Temporary Memory," beginning on page 545</A>, describes how your application can allocate temporary and permanent memory.<P>
 The naming of temporary and permanent requests can be confusing. <I>Temporary</I> might seem to imply that a memory request is transient and therefore less important. The exact opposite is true: MacApp makes sure temporary requests are always satisfied--only permanent requests can fail. However, a temporary allocation <I>is</I> temporary in the sense that it can be purged if necessary.<P>
 MacApp attempts to preserve enough space in the heap so that all temporary memory requests can be satisfied at any point in the program's execution. This ensures that requests that <I>must</I> succeed, such as code segment allocations, do succeed, while requests that you would merely <I>like</I> to succeed, such as allocation of data structures for a second (or later) document, may fail. If the temporary reserve is sufficiently large, your application will never fail when loading a code segment or system resource.<P>
 To satisfy a <A NAME=MARKER-2-111></A>temporary memory request, MacApp may free other temporary items not currently in use. To keep track of temporary items, MacApp keeps four lists. The first two are used primarily by MacApp; the last two are intended for use by your application:<P>
<UL>
<LI><B><A NAME=MARKER-9-112></A>gCodeSegs. </B>The global variable <CODE>gCodeSegs</CODE> points to the first object in a list of <CODE>CCodeSegment</CODE> objects, one for each code resource in the application. It is used only by 68K applications. Each pointer stores information, including the size of the code segment, whether the code segment is resident, and a pointer to the next <CODE>CCodeSegment</CODE> object in the list. This list is kept up to date by MacApp as segments are swapped in and out (see <A HREF=MacAppProgGuide-32.html#MARKER-9-231>"MacApp's Patching for Segmentation," beginning on page 83</A>).
<LI><B><A NAME=MARKER-9-114></A>gSysMemList.</B> The <CODE>gSysMemList</CODE> list contains handles to RAM-based system resources, including all <CODE>'PACK'</CODE>, <CODE>'LDEF'</CODE>, <CODE>'MDEF</CODE>', <CODE>'WDEF'</CODE>, and <CODE>'CDEF'</CODE> resources in the system and application resource forks. You can add other resources, such as font resources, by calling <P>
<pre><CODE>gSysMemList-&gt;AddHandle(theResourceHandle)</CODE>;</pre>
<LI><B><A NAME=MARKER-9-117></A>gApp1MemList, gApp2MemList. </B>These are lists of handles to application data or resources, initialized to <CODE>NULL</CODE> by MacApp. You can add temporary handles you create to these lists using code like the following:<P>
<pre><CODE>gApp1MemList-&gt;AddHandle(theHandle)</CODE>;         // Add to <CODE>gApp1MemList</CODE>.<BR><CODE>gApp2MemList-&gt;<A NAME=MARKER-2-122></A>AddHandle(theHandle)</CODE>;         // Add to <CODE>gApp2MemList</CODE>.</pre><P>
</UL>
 When there is not enough memory in the application heap to satisfy a memory request, MacApp's <I>grow-zone function</I> attempts to free a block of memory large enough to satisfy the request. The grow-zone function may purge items from the application's global lists, in this order:<P>
<OL>
<LI>the <CODE>gCodeSegs</CODE> list (see <A HREF=#MARKER-9-143>page 68</A>)
<LI>the <CODE>gApp1MemList</CODE> list
<LI>the <CODE>gSysMemList</CODE> list
<LI>the <CODE>gApp2MemList</CODE> list<P>
</OL>
 <A HREF=#MARKER-9-140>"The Grow-Zone Function," beginning on page 67</A>, provides additional detail on MacApp's management of low-memory conditions. <A HREF=#MARKER-9-143>"Grow-Zone Hooks," beginning on page 68</A>, describes the classes MacApp uses to keep lists of purgeable memory allocations.<P>
<A NAME=HEADING30-26></A>
<H2><A NAME=MARKER-2-123></A><A NAME=MARKER-9-151></A>Determining the Size of Memory Reserves</H2>
 MacApp determines the size for a temporary memory reserve and for an additional, last-ditch low-space reserve using the following steps:<P>
<OL>
<LI><A NAME=MARKER-9-125></A>During initialization of the application, MacApp determines the largest amount of temporary memory that is likely to be needed at one time while the application is running. The total includes the sum of<P>
<UL>
<LI>the size of all segments listed in <CODE><A NAME=MARKER-2-126></A>'seg!'</CODE> resources (those segments likely to be loaded when the application is performing its most code-intensive operation)
<LI>any additional memory reserve specified in <CODE>'mem!'</CODE> resources supplied by your application or MacApp; additions to the temporary memory reserve are specified in the third field of the <CODE>'mem!'</CODE> resource
<LI>any processor-dependent temporary reserve specified in <CODE>'ppc!'</CODE> (or <CODE>'68k!'</CODE> for 68K applications) resources (also stored in the third field)<P>
The temporary reserve total is stored in the global variable <CODE><A NAME=MARKER-2-130></A>pSzTemporaryReserve</CODE>.<P>
</UL>
<LI>MacApp also determines the size for a last-ditch memory reserve, by adding the values stored in the fourth field of each <CODE>'mem!</CODE>' and <CODE>'ppc!'</CODE> (or <CODE>'68k!'</CODE> for 68K applications) resources, and stores it in the global variable <CODE><A NAME=MARKER-2-131></A>pSzMemReserve</CODE>.
<LI>MacApp then allocates a temporary reserve, <CODE><A NAME=MARKER-2-132></A>pTemporaryReserve</CODE>, based on <CODE>pSzTemporaryReserve</CODE>, and a low-space reserve, <CODE><A NAME=MARKER-2-133></A>pMemReserve</CODE>, based on <CODE>pSzMemReserve</CODE>.<P>
</OL>
 The <CODE>'seg!'</CODE> resource is described on <A HREF=MacAppProgGuide-31.html#MARKER-9-222>page 80</A>. The <CODE>'mem!'</CODE>, <CODE>'68k!'</CODE>, and <CODE>'ppc!'</CODE> resources are described in <A HREF=MacAppProgGuide-122.html#MARKER-9-19>Chapter 24, "Working With Memory and Failure Handling,"</A> beginning on <A HREF=MacAppProgGuide-123.html#MARKER-9-44>page 551</A>.<P>
 <A HREF=#MARKER-9-134>Figure 3-3</A> shows the application heap when the application is first initialized. The allocations that make up the temporary reserve are shaded. Note that the temporary reserve includes temporary handles and purgeable code segments.<P>
<B>Figure 3-3  <A NAME=MARKER-9-134></A>The <A NAME=MARKER-2-118></A>application heap, after initialization</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-056.gif"><P>
 As the user performs operations, the application may load and unload code segments and make other allocations. MacApp recalculates the temporary reserve at various times, such as when the operating system calls MacApp's grow-zone function (described in the next section). The temporary reserve is reduced by the size of any currently loaded, purgeable code segments in the <CODE><A NAME=MARKER-2-136></A>gCodeSegs</CODE> list and by the size of any purgeable handles in <CODE>gSysMemList</CODE>, <CODE><A NAME=MARKER-2-138></A>gApp1MemList</CODE>, and <CODE><A NAME=MARKER-2-139></A>gApp2MemList</CODE> (normally, all items in these lists are purgeable). These items can be purged, if necessary, to satisfy a temporary memory request, so their size can be considered part of the temporary reserve.<P>
<A NAME=HEADING30-40></A>
<H2><A NAME=MARKER-9-140></A><A NAME=MARKER-2-141></A>The Grow-Zone Function</H2>
 A <B>grow-zone function</B> is a routine in your application that attempts to free memory in the application heap. Whenever the Memory Manager finds there isn't enough space in the heap to satisfy a memory request, it calls the grow-zone function to free additional space. It calls the grow-zone function repeatedly until there is enough free space to satisfy the request or until no more space can be freed, in which case the allocation request fails. <P>
 By installing its own grow-zone function, an application can help determine which requests succeed and which fail. MacApp installs a grow-zone function (named <CODE><A NAME=MARKER-2-142></A>GrowZoneProc</CODE>) as part of its overall strategy of memory management. MacApp's grow-zone function distinguishes between temporary and permanent memory requests. It won't free memory in the temporary reserve to satisfy a permanent request unless there is enough left over for any anticipated temporary requests. In this way there will always be enough space to satisfy temporary requests.<P>
<DL>
<DT><B>Note</B>
<DD>The nature of a memory request, temporary or permanent, comes into play only when there is insufficient memory to satisfy the request, and the grow-zone function is called to free additional space. Otherwise, each request for memory, whether temporary or permanent, is satisfied from the application's available heap space, and no reorganization of the heap is necessary.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING30-44></A>
<H3><A NAME=MARKER-9-143></A>Grow-Zone Hooks</H3>
 <A NAME=MARKER-2-203></A>MacApp defines the <CODE>CGrowZoneHook</CODE> class to supply the grow-zone function with information about memory that can be purged in an emergency. MacApp also defines the following subclasses of <CODE>CGrowZoneHook</CODE>:<P>
<DL>
<DT><CODE>CCodeSegmentGrowZoneHook</CODE>
<DD> A <A NAME=MARKER-2-219></A><CODE>CCodeSegmentGrowZoneHook</CODE> object manages a list of segments (used only in 68K-based applications). The <CODE>gCodeSegmentGrowZoneHook</CODE> global variable manages the <CODE>gCodeSegs</CODE> list (see <A HREF=#MARKER-9-112>page 64</A>).
<DT><CODE>CMMHandleList</CODE>
<DD> A <A NAME=MARKER-2-146></A><CODE>CMMHandleList</CODE> object manages a list of handles. The <CODE>gApp1MemList</CODE> and <CODE>gApp2MemList</CODE> global variables (<A HREF=#MARKER-9-117>page 64</A>) are instantiated from this class.
<DT><CODE><A NAME=MARKER-2-147></A>CSysMemList</CODE>
<DD> This subclass of <CODE>CMMHandleList</CODE> manages system handle data. The <CODE>gSysMemList</CODE> global variable (<A HREF=#MARKER-9-114>page 64</A>) is instantiated from <CODE>CSysMemList</CODE>.
</DL>
 During application initialization, MacApp uses global variables to insert grow-zone hooks for the following lists, which may contain references to purgeable blocks of memory. When purging takes place, MacApp attempts to purge memory in the order in which the hooks are stored:<P>
<OL>
<LI>the <CODE>gCodeSegmentGrowZoneHook</CODE> (which manages the <CODE>gCodeSegs</CODE> list)
<LI>the <CODE>gApp1MemList</CODE> list
<LI>the <CODE>gSysMemList</CODE> list
<LI>the <CODE>gApp2MemList</CODE> list<P>
</OL>
 Your application can use the classes listed above (or subclasses you define) to create its own lists of references to blocks of memory that may be purgeable. You tell MacApp's grow-zone procedure about your list by making a call like either of the following:<P>
<PRE>
myMemList-&gt;InsertLast;// Insert last--free items in other lists first.
myMemList-&gt;InsertFirst;// Insert first--free items in this list first.
</PRE>
 The grow-zone procedure's purging algorithms are described in the next section.<P>
<A NAME=HEADING30-57></A>
<H3>Purging Algorithms</H3>
 The grow-zone function determines whether it has been called in response to a temporary or permanent request by examining the <CODE><A NAME=MARKER-2-148></A>pTemporaryAllocation</CODE> flag. Since system requests are temporary and tend to occur at unpredictable times, the normal state of this flag is <CODE>TRUE</CODE>, indicating that the next request should be temporary.<P>
 To release memory for a temporary memory request, MacApp's grow-zone routine uses the following algorithm:<P>
<UL>
<LI>The <CODE>GrowZoneProc</CODE> routine calls the <CODE>CGrowZoneHook::EachPurge</CODE> method, passing the size of the desired memory allocation.
<LI>The <CODE>EachPurge</CODE> method traverses the objects in the grow-zone hook list, calling the <CODE>Purge</CODE> method of each.
<LI>For each list, the <CODE>Purge</CODE> method attempts to free memory equal to or greater than the requested amount. It returns the amount actually purged.
<LI><CODE>EachPurge</CODE> accumulates the total purged memory until the total is equal to or greater than the requested amount or until all lists have been purged. <CODE>EachPurge</CODE> returns the amount of memory actually purged.
<LI>The <CODE>GrowZoneProc</CODE> routine returns the amount of memory purged.<P>
</UL>
 To release memory for a permanent memory request, MacApp's <CODE>GrowZoneProc</CODE> uses the following algorithm:<P>
<UL>
<LI>It determines if the temporary reserve (<CODE>pTemporaryReserve</CODE>) is larger than necessary by calling the <CODE>CGrowZoneHook::TotalTempSize</CODE> method, which in turn calls <CODE>TotalSize</CODE> for each grow-zone hook in the list. <CODE>TotalTempSize</CODE> returns the accumulated total of temporary memory stored by the hook lists.
<LI>If the amount of temporary memory is larger than necessary, it reduces it by calling <CODE>BuildTemporaryReserve</CODE>, passing the value returned by <CODE>TotalTempSize</CODE>.
<LI>The <CODE>BuildTemporaryReserve</CODE> method may free the low-space reserve (<CODE>pLowSpaceReserve</CODE>), call the Toolbox routine <CODE>PurgeMem</CODE> to purge memory, move large handles high in the heap, and perform other operations designed to free up as much memory as possible.
<LI>If the temporary reserve was already purged, or if rebuilding it didn't free enough memory, <CODE>GrowZoneProc</CODE> calls the <CODE>CGrowZoneHook::EachPurge</CODE> method (described in the previous algorithm). It then calls <CODE>BuildTemporaryReserve</CODE>, attempting to free as much temporary memory as possible.
<LI>If no memory has yet been freed, and if the low-space reserve (<CODE>MemReserve</CODE>) is intact, <CODE>GrowZoneProc</CODE> calls <CODE>ReleaseLowSpaceReserve</CODE> to purge the low-space reserve as a final attempt to free space.
<LI><CODE>GrowZoneProc</CODE> returns the amount of memory purged.<A NAME=MARKER-2-149></A><P>
</UL>
<A NAME=HEADING30-72></A>
<H2><A NAME=MARKER-2-280></A><A NAME=MARKER-9-21></A>Initializing MacApp's Memory Management</H2>
 MacApp's memory management is initialized as part of its overall initialization. Your application either calls the <CODE>InitUMacApp_Step1</CODE> routine <A HREF=MacAppProgGuide-35.html#MARKER-9-26>(page 88)</A> directly, or it calls the <CODE><A NAME=MARKER-2-152></A>InitUMacApp</CODE> macro, which in turn calls <CODE>InitUMacApp_Step1</CODE>. The <CODE>InitUMacApp_Step1</CODE> routine calls <CODE><A NAME=MARKER-2-153></A>UniversalStartup</CODE>, which in turn calls <CODE><A NAME=MARKER-2-112></A>ExpandHeap</CODE> to perform the first part of MacApp's memory management initialization. <CODE>ExpandHeap</CODE> does the following:<P>
<UL>
<LI>It examines the application's <CODE><A NAME=MARKER-2-113></A>'mem!'</CODE> and <CODE>'<A NAME=MARKER-2-114></A>ppc!'</CODE> resources to determine the size of the heap, heap increment, memory reserves, and stack. (For 68K applications, the <CODE>'<A NAME=MARKER-2-157></A>68K!'</CODE> resource is examined in place of the <CODE>'ppc!'</CODE> resource.) The <CODE>'mem!'</CODE>, <CODE>'ppc!'</CODE>, and <CODE>'68K!'</CODE> resources are described in <A HREF=MacAppProgGuide-122.html#MARKER-9-19>Chapter 24, "Working With Memory and Failure Handling,"</A> beginning on <A HREF=MacAppProgGuide-123.html#MARKER-9-44>page 551</A>.
<LI>It sets the stack to the determined size by calling MacApp's <CODE><A NAME=MARKER-2-158></A>SetStackSpace</CODE> routine, which in turn calls the Toolbox routine <CODE><A NAME=MARKER-2-159></A>SetApplLimit</CODE>.
<LI>It calls <CODE><A NAME=MARKER-2-228></A>MaxApplZone</CODE>, a Toolbox routine that expands the application heap zone to include all available heap memory.<P>
</UL>
 Later in MacApp's initialization, the <CODE>InitUMacApp_Step3</CODE> routine (see <A HREF=MacAppProgGuide-35.html#MARKER-9-39>page 90</A>) makes the following call:<P>
<PRE>
InitUMemory(callsToMoreMasters);
</PRE>
 The <CODE>InitUMemory</CODE> routine performs the following initialization tasks:<P>
<UL>
<LI>It calls the Toolbox routine <CODE><A NAME=MARKER-2-161></A>MoreMasters</CODE> as many times as specified by the <CODE>callsToMoreMasters</CODE> parameter, to create blocks of master pointers for the application, making every effort to allocate pointer blocks near the bottom of the heap.
<LI>It calls the <CODE><A NAME=MARKER-2-162></A>DoInitUMemory</CODE> routine to perform the following tasks:<P>
<UL>
<LI>It creates handles to store temporary and low-space memory reserves for the application.
<LI>It initializes <CODE><A NAME=MARKER-2-163></A>gSysMemList</CODE> and stores executable application resources, of type <CODE>'LDEF'</CODE>, <CODE>'CDEF'</CODE>, <CODE>'MDEF'</CODE>, <CODE>'WDEF'</CODE>, and <CODE>'PACK'</CODE>, in it.<P>
</UL>
<LI>It creates and initializes a private heap object, <CODE><A NAME=MARKER-2-164></A>gObjectHeap</CODE>, for the application. The heap object manages a private store of memory used to allocate application objects. This private store uses permanent memory.
<LI>It calls MacApp's <CODE>SetReserveSize</CODE> routine to allocate temporary and low-space memory reserves.
<LI>It initializes the grow-zone hook global variables gApp1MemList and gApp2MemList.
<LI>It calls the Toolbox routine <CODE><A NAME=MARKER-9-242></A>InstallGrowZoneProc</CODE>, passing a universal procedure pointer to set the application's grow-zone function to MacApp's <CODE>GrowZoneProc</CODE>.<P>
</UL>
 For more information on the memory management facilities provided by MacApp, see <A HREF=MacAppProgGuide-122.html#MARKER-9-19>Chapter 24, "Working With Memory and Failure Handling."</A><A NAME=MARKER-2-281></A><P>
<A NAME=HEADING30-89></A>
<H2><A NAME=MARKER-2-169></A><A NAME=MARKER-9-170></A>Initializing MacApp's Segment Management</H2>
 MacApp's segment management system, described in detail beginning on <A HREF=MacAppProgGuide-31.html#MARKER-9-202>page 75</A>, is part of memory management for 68K-based machines. Segment management is initialized from the <CODE>InitUMacApp_Step3</CODE> routine, which makes the following call:<P>
<PRE>
#if qSegments
   // Install MacApp's segment management system.
   InitUSegments();
#endif // qSegments
</PRE>
 MacApp's segment management system is needed only for segmented 68K-based applications. MacApp uses the <CODE>qSegments</CODE> flag to control compilation of this code.<P>
 The <CODE><A NAME=MARKER-9-186></A>InitUSegments</CODE> routine performs the following initialization tasks:<P>
<UL>
<LI>It installs a memory hook for the grow-zone procedure, using the global variable <CODE>gCodeSegmentGrowZoneHook</CODE>.
<LI>It calls the <CODE><A NAME=MARKER-9-240></A>DoInitUSegments</CODE> routine to perform the following actions:<P>
<UL>
<LI>It allocates the <CODE>gCodeSegs</CODE> list and stores information about the size and status of the application's code segments. The <CODE>gCodeSegs</CODE> list is described in <A HREF=#MARKER-9-108>"Permanent and Temporary Memory," beginning on page 63</A>.
<LI>It examines any <CODE>'seg!'</CODE> resources in the application and, based on the information in those resources, may increase or decrease the designated size for the application's temporary and low-space memory reserves.
<LI>It may also increase the temporary reserve for code segments not in the <CODE>'seg!'</CODE> resource that are marked as preload.<P>
</UL>
<LI>For applications built with 32-bit addressing or with <A NAME=MARKER-2-173></A>CFM-68K (the 68K Macintosh version of the Power Macintosh Code Fragment Manager), it provides the <A NAME=MARKER-2-174></A>runtime library (RTLib) with MacApp routines to call before and after a segment is loaded. For other 68K applications, it patches the Toolbox <CODE><A NAME=MARKER-2-175></A>LoadSeg</CODE> routine so that the application will get control when a segment is about to be loaded. For more information, see <A HREF=MacAppProgGuide-31.html#MARKER-9-207>"Segmentation Strategies," beginning on page 76</A>.
<LI>It calls MacApp's <CODE>UnloadAllSegments</CODE> routine to remove any initialization segments from the heap.
<LI>It calls MacApp's <CODE><A NAME=MARKER-2-176></A>LoadResidentSegments</CODE> routine to load all resident segments.
<LI>It calls MacApp's <CODE><A NAME=MARKER-2-177></A>SetReserveSize</CODE> routine, which may resize the application's temporary and low-space memory reserves.
<LI>It causes a failure if insufficient memory is left to run the application.<A NAME=MARKER-2-178></A><A NAME=MARKER-2-332></A><P>
</UL>
<A NAME=HEADING30-104></A>
<H2><A NAME=MARKER-9-180></A>Allocating Objects</H2>
 One of the most common uses for dynamic memory allocation is to allocate the objects that make up your application. MacApp uses pointer-based objects (which point to nonrelocatable blocks of memory) rather than handle-based objects (which point, through a double-reference system, to relocatable blocks of memory).<P>
 <A NAME=MARKER-2-181></A>Because most applications have many small objects, and because pointers don't move, they tend to fragment the heap. In addition, pointer allocation can be slow, because the Memory Manager will compact the entire heap to allocate a pointer with minimal fragmentation. However, MacApp provides a scheme to handle pointer-based object allocation efficiently and to avoid fragmentation, using a global object heap, <CODE><A NAME=MARKER-2-182></A>gObjectHeap</CODE>.<P>
 The storage space managed by the object heap is kept locked in memory and is accessed by pointers. During memory initialization, MacApp examines the <CODE>'mem!'</CODE> resource to determine the initial size and the increment size for the <A NAME=MARKER-2-183></A>object heap. The size of the heap is set to the sum of the values of the first field in each of the application's <CODE>'<A NAME=MARKER-2-184></A>mem!'</CODE> resources (with a default of 32 KB). The increment for growing the heap is set to the sum of the values of the second field in each <CODE>'mem!'</CODE> resource (with a default increment of 30 KB).<P>
 These values are chosen to give reasonable results for a normal application. If your application creates a great number of objects and your application heap becomes fragmented, you may wish to modify your <CODE>'mem!'</CODE> resource to specify a larger initial size or a larger increment, or both. However, it doesn't hurt to start with a smaller size, since the heap will grow when necessary, and experimentation has shown that an initial size of 32 KB is often more efficient than an initial size of 200 KB.<P>
<A NAME=HEADING30-109></A>
<H3><A NAME=MARKER-2-185></A>Creating an Object in the Object Heap</H3>
 To create an object in the object heap, the MacApp class library defines two routines, <CODE>operator</CODE> <CODE>new</CODE> and <CODE>operator</CODE> <CODE>delete</CODE>, that replace the standard global operators defined by C++. MacApp's <CODE><A NAME=MARKER-2-186></A>operator</CODE> <CODE>new</CODE> and<A NAME=MARKER-2-34></A> <CODE>operator</CODE> <CODE>delete</CODE> routines call <CODE><A NAME=MARKER-2-188></A>MAOperatorNew</CODE> and <CODE><A NAME=MARKER-2-189></A>MAOperatorDelete</CODE>, which in turn call the <CODE><A NAME=MARKER-2-49></A>Allocate</CODE> and <CODE>Free</CODE> functions of the <CODE><A NAME=MARKER-2-35></A>ObjectHeap</CODE> class.<P>
 This is the list of calls generated when an application creates a new object by name, using the <CODE>new</CODE> operator:<P>
<PRE>
new TYourObject
   operator new(sizeof(TYourObject))
      MAOperatorNew(sizeof(TYourObject))
         MemoryHeap::Allocate(sizeof(TYourObject))
            ObjectHeap::DoAllocate(sizeof(TYourObject))
</PRE>
 The <CODE><A NAME=MARKER-2-192></A>ObjectHeap</CODE> class descends from <CODE><A NAME=MARKER-2-193></A>BestFitHeap</CODE>, which in turn descends from <CODE>MemoryHeap</CODE>. The <CODE>ObjectHeap::<A NAME=MARKER-2-194></A>DoAllocate</CODE> method directly allocates objects below a certain size, using a chunky approach: a chunk of memory large enough for a number of objects is allocated, then objects are handed out one at a time until a new chunk is needed. Allocated chunks are kept in a linear list.<P>
 The object heap calls <CODE>BestFitHeap::DoAllocate</CODE> to get memory for the chunks it uses and to try to satisfy requests it cannot handle. The <CODE>BestFitHeap</CODE> class uses an allocation mechanism that searches a binary tree of free blocks, ordered by size. If no free block is found, it expands the heap and repeats the search until the request is satisfied or until no more memory can be obtained.<P>
<A NAME=HEADING30-115></A>
<H3><A NAME=MARKER-2-25></A>Freeing an Object in the Object Heap</H3>
 You call the MacApp routine <CODE>FreeIfObject</CODE> to free an object in the object heap (allocated with a <CODE>new</CODE> call). <CODE><A NAME=MARKER-2-196></A>FreeIfObject</CODE> generates the following list of calls:<P>
<PRE>
FreeIfObject(aYourObject)
   aYourObject-&gt;Free()
      aYourObject-&gt;ShallowFree()
         operator delete(void* obj)
            MAOperatorDelete(void* obj)
               MemoryHeap::Free(void* blk)
                  ObjectHeap::DoFree(void* blk)
</PRE>
 Eventually the block of memory is freed according to its type--either a block in a list of chunky blocks, or a block in the binary tree of blocks stored by <CODE>BestFitHeap</CODE>. The memory occupied by the object becomes available for reuse.<P>
<A NAME=HEADING30-119></A>
<H3>Recovering Freed Memory</H3>
 In its current implementation, the object heap never shrinks. It starts out with a default size of 32 KB, and grows, if necessary, by a default increment of 30 KB. Memory allocated for the object heap is <I>never again</I> available to the application heap. When an object is freed, the memory it occupied is available to the object heap but the object heap itself doesn't shrink.<P>
 As a result, you should avoid situations where your application creates very large blocks of data in the object heap. Even though you free them after use, the object heap may grow to a size that interferes with other program operations. For very large memory requests, you can use the <CODE><A NAME=MARKER-2-125></A>NewPermHandle</CODE> routine to allocate a handle in permanent memory. After you free the handle, the memory is again available in the application heap.<P>
<A NAME=HEADING30-122></A>
<H3><A NAME=MARKER-2-50></A><A NAME=MARKER-9-199></A><A NAME=MARKER-9-200></A>Replacing MacApp's Global New and Delete Operators</H3>
 When you create an object with <CODE>new</CODE> or delete an object with <CODE>delete</CODE>, by default you are using MacApp's global routines <CODE>operator</CODE> <CODE>new</CODE> (which calls <CODE>MAOperatorNew</CODE>) and <CODE>operator</CODE> <CODE>delete</CODE> (which calls <CODE>MAOperatorDelete</CODE>).<P>
 You can replace MacApp's global <CODE>new</CODE> and <CODE>delete</CODE> operators with the default C++ operators or with your own creation and deletion routines. To suppress inclusion of MacApp's global <CODE>new</CODE> and <CODE>delete</CODE> operators, you include the following directive on your MacApp build line:<P>
<PRE>
-d qMAGlobalNew=FALSE
</PRE>
 For more information on building MacApp, see <A HREF=MacAppProgGuide-148.html#MARKER-9-10>Appendix A</A>.<P>
 Since <CODE>TObject</CODE> has its own <CODE>operator</CODE> <CODE>new</CODE> and <CODE>operator</CODE> <CODE>delete</CODE> routines, it is possible to use different global <CODE>new</CODE> and <CODE>delete</CODE> operators without affecting allocation of MacApp objects that are based on <CODE>TObject</CODE>.<A NAME=MARKER-2-201></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-29.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-31.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
