<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>JPEG File Interchange Format - /JFIF Translator/JFIF-PICT.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">JPEG File Interchange Format</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">JPEG File Interchange Format</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/JFIF Translator/JFIF-PICT.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/JFIF Preview Component/JFIFPreviewer.c</option>
<option value="listing2.html">/JFIF Preview Component/JFIFPreviewer.r</option>
<option value="listing3.html">/JFIF Translator/JFIF-PICT.c</option></select>
				</p>
				</form>
				<p><strong><a href="JPEG_File_Interchange_Format.zip">Download Sample</a></strong> (&#147;JPEG_File_Interchange_Format.zip&#148;, 58.1K)<BR>
<strong><a href="JPEG_File_Interchange_Format.dmg">Download Sample</a></strong> (&#147;JPEG_File_Interchange_Format.dmg&#148;, 122.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    JFIF-PICT.c  Contains:  Converts JPEG interchange files to JPEG PICT files, which can be used by any application.            The JPEG File  Interchange Format ( JFIF) is a cross platform standard file format for        storing JPEG compressed image files. This application shows you how you can easily convert        these to QuickTime PICT format, or vice-verse.                 You can use this in your application to open JFIF files directly or put a user interface         ( Drag and Drop would be cool ) on it to make a conversion program ). When files are to         be used on the Mac it is best to keep them in QTPict format so they can be easily copied        and pasted, but JFIF format is useful for transfering data to other platforms that cannot        use PICT formated JPEG images.                 NOTE: the PICT to JFIF format translator is incomplete in that it only converts PICT        files which are already in QuickTIme JPEG format and it does not handle banded JPEG        Picts ( which may be commonly created by QuickTime applications which call         CompressPictureFile in low memory conditions or which create their own banded picts)        To fully handle these images, the individual bands would have to be converted into a         single JPEG stream when put into JFIF format, and this code does not show you how        to do that.   Written by: Mark Krueger    Copyright:  Copyright &copy; 1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/17/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include  &lt;Gestalt.h&gt;#include  &lt;Fonts.h&gt;#include  &lt;Sound.h&gt;#include  &lt;FixMath.h&gt;/************************************************ * *  Function prototypes. * ************************************************/voidInitialize();char *MarkerDetect(char *data,short *width,short *height,long *hRes,long *vRes,short *depth);void SwallowHuffTable(char *data);void SwallowQuantTable(char *data);voidGetNewName(StringPtr newName,StringPtr oldName,StringPtr ext);ImageDescriptionHandleScanJPEG(short originalFile,Ptr *data,OpenCPicParams *pictureHeader);OSErrConvertFromJFIF(StringPtr name,short originalFile);OSErrConvertToJFIF(StringPtr name,short originalFile);pascal voidStdPixExtract(PixMap *src,Rect *srcRect,MatrixRecord matrix,short mode,RgnHandle mask,PixMap *matte,  Rect *matteRect,short flags);    /************************************************ * *  Set up application environment. * ************************************************/voidInitialize(){  long  resp;      MaxApplZone();  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  InitDialogs(nil);  InitCursor();  if ( Gestalt(gestaltCompressionMgr, &amp;resp) != noErr || resp &lt; 15 ) {    SysBeep(1);    ExitToShell();  }  }/************************************************ * *  Make a new name for the compressed file ( illustrative only, this is not the recommended method ). * ************************************************/voidGetNewName(StringPtr newName,StringPtr oldName,StringPtr ext) {  long  olen = oldName[0];  if ( olen &gt; (31-ext[0])  )    olen = 31-ext[0];  BlockMove(oldName+1,newName+1,olen);  BlockMove(ext+1,newName+1+olen,ext[0]);  newName[0] = olen + ext[0];}  /************************************************ * *  Our program. * ************************************************/void main(){  short    originalFile;  Point    pt = {100,100};  SFReply    sfr;    SFTypeList   types = { 'JFIF','JPEG','????','PICT' };  OSErr    result = 0;  /************************************************   *   *  Initialize everything, and then do it. Notice   *  the wonderful HIG conformant user interface.   *   ************************************************/    Initialize();  while ( 1 ) {    /************************************************   *   *  Ask for a input file   *   ************************************************/        SFGetFilePreview(pt,nil,nil,4,types,nil,&amp;sfr);    if ( !sfr.good  )      break;  /************************************************   *   *  Open the file, if we can.   *   ************************************************/      if ( (result=FSOpen(sfr.fName,sfr.vRefNum,&amp;originalFile)) != noErr ) {      break;    }    if ( sfr.fType == 'PICT' ) {          if ( result=ConvertToJFIF(sfr.fName,originalFile) )        break;          } else {            if ( result=ConvertFromJFIF(sfr.fName,originalFile) )        break;        }  }  if ( result )    SysBeep(1);}/************************************************ * *  Convert a JFIF file to a PICT file. * ************************************************/OSErrConvertFromJFIF(StringPtr name,short originalFile){  OSErr  result = 0;  short compressedFile = 0;  OpenCPicParams  header;  Str31    newName;  CWindowPtr  window = nil;  Rect    windRect;  long    l;  short    i;  char    zero=0;  MatrixRecord matrix;  Ptr      data = nil;  ImageDescriptionHandle  desc = nil;  PicHandle  originalPicture = nil;  SFReply    sfr;    Point    pt = {100,100};        /************************************************   *   *  Extract the JPEG data if possible and create Image Description.   *   ************************************************/  if ( (desc=ScanJPEG(originalFile,&amp;data,&amp;header)) == 0 ) {    result = -50;    goto done;  }  windRect = header.srcRect;  OffsetRect(&amp;windRect,40,40);    /************************************************   *   *  Create a window the size of the picture, and set our port to it.   *   ************************************************/  #ifdef  SHOW_IT    // make it visible if we want to see it before conversion  if ( (window = (CWindowPtr)NewCWindow(nil,&amp;windRect,sfr.fName,true,0,(WindowPtr)-1,false,0)) == nil ) {    result = -108;    goto done;  }#else    if ( (window = (CWindowPtr)NewCWindow(nil,&amp;windRect,sfr.fName,false,0,(WindowPtr)-1,false,0)) == nil ) {    result = -108;    goto done;  }#endif  SetPort((GrafPtr)window);      originalPicture = OpenCPicture(&amp;header);          /************************************************   *   * we have to use the FDecompressImage call to make sure that the accuracy   * param gets set to highQuality which ensures a better quality decode   * and real dithering when going to 8-bit screens.   *   ************************************************/          SetIdentityMatrix(&amp;matrix);    if ( (result=FDecompressImage(data,desc,((CGrafPtr)qd.thePort)-&gt;portPixMap,      &amp;header.srcRect,&amp;matrix,ditherCopy,(RgnHandle)nil,      (PixMapHandle)nil,(Rect *)nil,codecHighQuality,anyCodec,0,      nil,nil)) ){    ClosePicture();    KillPicture((PicHandle)originalPicture);    originalPicture = nil;    goto done;  }  ClosePicture();  if ( GetHandleSize((Handle)originalPicture) == sizeof(Picture) ) {    KillPicture((PicHandle)originalPicture);    originalPicture = nil;    goto done;  }#ifdef  SHOW_IT      /************************************************   *   *    Draw the picture in the window, slid up to the top left corner.   *   ************************************************/    DrawPicture(originalPicture,(*originalPicture)-&gt;pictureFrame);#endif  /************************************************   *   *    Ask her for the name of the new file.   *   ************************************************/    GetNewName(newName,name,&quot;\p Pict&quot;);  SFPutFile(pt,nil,newName,NULL,&amp;sfr);  if ( !sfr.good )  {    goto done;  }  BlockMove(sfr.fName,newName,32);    /************************************************   *   *  Create the new file, if we can.   *   ************************************************/    FSDelete(sfr.fName,sfr.vRefNum);  if ( (result=Create(sfr.fName,sfr.vRefNum,'ppxi','PICT')) != noErr ) {    goto done;  }  if ( (result=FSOpen(sfr.fName,sfr.vRefNum,&amp;compressedFile)) != noErr ) {    goto done;  }      /************************************************   *   * write the silly 512 bytes of zero needed at the start of a PICT file   *   ************************************************/      SetFPos(compressedFile,fsFromStart,512);  l = 1;  for ( i=0; i &lt; 512; i++) {    if ( (result=FSWrite(compressedFile,&amp;l,&amp;zero)) )      break;  }    /************************************************   *   * write the QuickTime picture data.   *   ************************************************/  l = GetHandleSize((Handle)originalPicture);      HLock((Handle)originalPicture);  result=FSWrite(compressedFile,&amp;l,*originalPicture);  done:    FSClose(originalFile);  if ( compressedFile )  {    FSClose(compressedFile);    if ( result != noErr )      FSDelete(sfr.fName,sfr.vRefNum);    FlushVol(nil,sfr.vRefNum);  }  if ( originalPicture )    KillPicture(originalPicture);  if ( data )    DisposePtr(data);  if ( desc )     DisposeHandle((Handle)desc);  if ( window )    CloseWindow((WindowPtr)window);  return result;}/************************************************  Scan a file for valid JPEG data, and fill in a picture header and ImageDescription  for it.*************************************************/ImageDescriptionHandleScanJPEG(short originalFile,Ptr *data,OpenCPicParams *pictureHeader){  short w,h;  ImageDescriptionHandle desc;  long  l;  char  *bitStream,*scanData,*buffer;  long  hRes = 72L&lt;&lt;16,vRes = 72L&lt;&lt;16;  short  depth = 32;    GetEOF(originalFile,&amp;l);  if ( (buffer= NewPtr(l)) == nil ) {    return(0);  }  FSRead(originalFile,&amp;l,buffer);  bitStream = buffer;    if ( (desc = (ImageDescriptionHandle)NewHandle(sizeof(ImageDescription))) == nil ) {    return(0);  }  if ( (scanData=MarkerDetect(bitStream,&amp;w,&amp;h,&amp;hRes,&amp;vRes,&amp;depth)) == 0 ) {    return(0);  }  (*desc)-&gt;idSize = sizeof(ImageDescription);  (*desc)-&gt;width = w;  (*desc)-&gt;height = h;  (*desc)-&gt;temporalQuality = 0;  (*desc)-&gt;spatialQuality = codecNormalQuality;  (*desc)-&gt;dataSize = l;  (*desc)-&gt;cType = 'jpeg';  (*desc)-&gt;version = 0;  (*desc)-&gt;revisionLevel = 0;  (*desc)-&gt;vendor = 0;  (*desc)-&gt;hRes = hRes;  (*desc)-&gt;vRes = vRes;  (*desc)-&gt;depth = depth;  (*desc)-&gt;clutID = -1;  BlockMove(&quot;\pPhoto&quot;,(*desc)-&gt;name,6);  SetRect(&amp;pictureHeader-&gt;srcRect,0,0,w,h);  pictureHeader-&gt;version = -2;  pictureHeader-&gt;reserved1 = 0;  pictureHeader-&gt;reserved2 = 0;  pictureHeader-&gt;hRes = hRes;  pictureHeader-&gt;vRes = vRes;  *data = bitStream;  return(desc);}/**********************************************************************  JPEG specific stuff.  ***********************************************************************//*  JPEG Marker code definitions.  */#define  MARKER_PREFIX  0xff#define  MARKER_SOI  0xd8    /* start of image */#define  MARKER_SOF  0xc0    /* start of frame */#define  MARKER_DHT  0xc4    /* define Huffman table */#define  MARKER_EOI  0xd9    /* end of image */#define  MARKER_SOS  0xda    /* start of scan */#define  MARKER_DQT  0xdb    /* define quantization tables */#define  MARKER_DNL  0xdc    /* define quantization tables */#define  MARKER_DRI  0xdd    /* define Huffman table */#define  MARKER_COM  0xfe    /* comment */#define MARKER_APP0  0xe0    /**********************************************************************  Read the quantization table from the JPEG bitstream.  ***********************************************************************/void SwallowQuantTable(char *data){  long  i;  long  length,pm,nm;  length = *(short *)data;      /* read length */  length -= 2;  data += 2;  while ( length ) {    nm= *data++;          /* read precision and number */    pm = nm&gt;&gt;4;      nm &amp;= 0xf;    length--;    if ( pm ) {      for(i=0;i&lt;64;i++) {        length -= 2;        data += 2;      }    } else {      for(i=0;i&lt;64;i++) {        length--;        data++;      }    }  }  }/**********************************************************************  Read the huffman table from the JPEG bitstream.  ***********************************************************************/void SwallowHuffTable(char *data){  short  i,tc,id;  long  length;    unsigned char  bin[17];  unsigned char  val[256];  bin[0] = 0;  length = *(short *)data;      /* read length */  data += 2;  length -= 2;  while ( length ) {    id=*data++;        /* read id */    length--;    if ( id != 0 &amp;&amp; id != 1 &amp;&amp; id != 0x10 &amp;&amp; id != 0x11) {      return;    }    tc = 0;    for(i=0;i&lt;16;i++) {      length--;      tc += (bin[i+1] = *data++);    }    for (i=0; i &lt; tc; i++ ) {      length--;      val[i] = *data++;    }  }}      /**********************************************************************  Scan the JPEG stream for the proper markers and fill in the image parameters    returns nil if it cant comprehend the data, otherwise a pointer to the start  of the JPEG data.      It does a cursory check on the JPEG data to see if it's reasonable.  Check out the ISO JPEG spec if you really want to know what's going on here.  ***********************************************************************/char *MarkerDetect(char *data,short *width,short *height,long *hRes,long *vRes,short *depth){  short  frame_field_length;  short  data_precision;  short  scan_field_length;  short  number_component,scan_components;  short  c1,hv1,q1,c2,hv2,q2,c3,hv3,q3;  short  dac_t1, dac_t2, dac_t3;  unsigned char  c;  short  qtabledefn;  short  htabledefn;  short  status;  short  length;  short  i;    c = *data++;  qtabledefn = 0;  htabledefn = 0;  status = 0;  while (c != (unsigned char)MARKER_SOS) {    while (c != (unsigned char)MARKER_PREFIX)      c = *data++;            /* looking for marker prefix bytes */    while (c == (unsigned char)MARKER_PREFIX)      c = *data++;            /* (multiple?) marker prefix bytes */    if (c == 0)      continue;                  /* 0 is never a marker code */    if (c == (unsigned char)MARKER_SOF) {      frame_field_length = *(short *)data;      data += 2;      data_precision = *data++;            if ( data_precision != 8 ) {         status = 2;      }      *height = *(short *)data;      data += 2;      *width = *(short *)data;      data += 2;                  number_component = *data++;            switch ( number_component  ) {      case 3:        c1 = *data++;        hv1 = *data++;        q1 = *data++;        c2 = *data++;        hv2 = *data++;        q2 = *data++;        c3 = *data++;        hv3 = *data++;        q3 = *data++;        *depth = 32;        break;      case 1:            c1 = *data++;        hv1 = *data++;        q1 = *data++;        *depth = 40;        break;      default:        status = 3;        break;      }      continue;    }      if (c == (unsigned char)MARKER_SOS) {      short tn;      scan_field_length = *(short *)data;      data += 2;      scan_components = *data++;      for ( i=0; i &lt; scan_components; i++ ) {        unsigned char cn,dac_t;                cn = *data++;        dac_t = *data++;        if ( cn == c1 ) {          dac_t1 = dac_t;        } else if ( cn == c2 ) {          dac_t2 = dac_t;        } else if ( cn == c3 ) {          dac_t3 = dac_t;        } else {            status = 29;          break;        }      }      switch ( tn=(dac_t1 &amp; 0xf) )  {      case 0:      case 1:        break;      case 0xf:        break;      default:        status = 33;        break;      }      switch (  tn=(dac_t2 &amp; 0xf) )  {      case 0:      case 1:        break;      case 0xf:        break;      default:        status = 33;        break;      }      switch (  tn=(dac_t3 &amp; 0xf) )  {      case 0:      case 1:        break;      case 0xf:        break;      default:        status = 33;        break;      }      /*  Initialize the DC tables */            switch (  tn=dac_t1 &amp; 0xf0 )  {      case 0:      case 0x10:        break;      case 0xf0:        break;      default:        status = 34;        break;      }      switch (  tn=dac_t2 &amp; 0xf0 )  {      case 0:      case 0x10:        break;      case 0xf0:        break;      default:        status = 34;        break;      }      switch (  tn=dac_t3 &amp; 0xf0 )  {      case 0:      case 0x10:        break;      case 0xf0:        break;      default:        status = 34;        break;      }      if ( *data++ != 0 )  {//        status = 18;      }      if ( *data++ != 63 )  {//        status = 19;      }      if ( *data++ != 0 ) {//        status = 20;      }      if ( status )        return(0);      else        return(data);    }    if (c == (unsigned char)MARKER_DQT) {      scan_field_length = *(short *)data;      SwallowQuantTable(data);      data += scan_field_length;      continue;    }    if (c == (unsigned char)MARKER_DHT) {      scan_field_length = *(short *)data;      SwallowHuffTable(data);      continue;    }    if (c == (unsigned char)MARKER_DRI) {      length = *(short *)data;      /* read length */      data += 2;      length = *(short *)data;            data += 2;      continue;    }    if (c == (unsigned char)MARKER_DNL) {      length = *(short *)data;      /* read length */      data += 2;      length = *(short *)data;            data += 2;      continue;    }    if (c &gt;= (unsigned char)0xD0 &amp;&amp; c &lt;= (unsigned char)0xD7) {      continue;    }    if (c == (unsigned char)MARKER_SOI || c == (unsigned char)MARKER_EOI)  /* image start, end marker */      continue;    if ( (c &gt;= (unsigned char)0xC1 &amp;&amp; c &lt;= (unsigned char)0xcF) || (c == (unsigned char)0xde) || (c == (unsigned char)0xdf) ) {      status = 12;      length = *(short *)data;      /* read length */      data += length;      continue;    }    if (c &gt;= (unsigned char)MARKER_APP0 &amp;&amp; c &lt;= (unsigned char)0xEF) {      length = *(short *)data;      /* read length */      data += 2;      length -= 2;      if ( (c == (unsigned char)MARKER_APP0) &amp;&amp; length &gt; 5 ) { /* check for JFIF marker */        char buf[5];        buf[0] = *data++;        buf[1] = *data++;        buf[2] = *data++;        buf[3] = *data++;        buf[4] = *data++;        length -= 5;                if ( buf[0] == 'J' &amp;&amp; buf[1] == 'F'  &amp;&amp; buf[2] == 'I'  &amp;&amp; buf[3] == 'F' ) {          short  units;          long  xres,yres;          short  version;                              version = *(short *)data; data += 2;length -= 2;          if ( version != 0x100 &amp;&amp; version != 0x101 ) {            status = 44;    // unknown JFIF version            break;          }          units = *data++; length--;          xres = *(short *)data; data += 2; length -= 2;          yres = *(short *)data; data += 2; length -= 2;          switch ( units ) {          case 0:      // no res, just aspect ratio            *hRes = FixMul(72L&lt;&lt;16,xres&lt;&lt;16);            *vRes = FixMul(72L&lt;&lt;16,yres&lt;&lt;16);            break;          case 1:      // dots per inch            *hRes = xres&lt;&lt;16;            *vRes = yres&lt;&lt;16;            break;          case 2:      // dots per centimeter (we convert to dpi )            *hRes = FixMul(0x28a3d,xres&lt;&lt;16);            *vRes = FixMul(0x28a3d,xres&lt;&lt;16);            break;            default:            break;          }          xres = *data++; length--;          yres = *data++; length--;                    /* skip JFIF thumbnail */                    xres *= yres;          data += xres*3; length -= xres*3;                    if (  length != 0 ) {            status = 44;    // bad jfif marker            break;          }        }      }      data += length;      continue;    }    if (c == (unsigned char)MARKER_COM) {      length = *(short *)data;      /* read length */      data += length;      continue;    }    if (c &gt;= (unsigned char)0xf0 &amp;&amp; c &lt;= (unsigned char)0xfd) {      length = *(short *)data;      /* read length */      data += length;      continue;    }    if ( c == 0x1 )      continue;    if ( (c &gt;= (unsigned char)0x2 &amp;&amp; c &lt;= (unsigned char)0xbF) ) {      length = *(short *)data;      /* read length */      status = 13;      data += length;      continue;    }  }  return(0);}  /************************************************     Convert a JPEG pict file to a JFIF file.************************************************/short extractionFile;OSErr extractionErr;OSErrConvertToJFIF(StringPtr name,short originalFile){  /************************************************************   This only works if the original file is a JPEG compressed file.    If it were not compressed with JPEG we could check and compress it  for the user, but then we would have to have a user interface for  selecting the quality. We could use the StdCompression dialog, but we  would have to restrict the user to choosing JPEG compression.    Also if the original image is banded or is a PICT with other opcodes   beside the JPEG QuickTime opcode, the JFIF file will only contain the first  JPEG opcode in the PICT. For the banded case, we could seam together the  individual bands into a single JPEG stream, but that is kind of hard, so   we leave that to you. For a mixed kind of picture, we could draw the whole  thing in a GWorld and then compress that with JPEG and use that for the JFIF   data.      ************************************************************/  CQDProcs  cprocs;  GWorldPtr  gw = nil;  CGrafPtr  savePort;  GDHandle  saveGD;  OSErr    result = 0;  Rect    rect = {0,0,1,1};  Str31    newName;  Point    pt = {100,100};  SFReply    sfr;  short    compressedFile = 0;    /************************************************   *   *    Ask her for the name of the new file.   *   ************************************************/      GetGWorld(&amp;savePort,&amp;saveGD);  GetNewName(newName,name,&quot;\p JFIF&quot;);  SFPutFile(pt,nil,newName,NULL,&amp;sfr);  if ( !sfr.good )  {    goto done;  }  BlockMove(sfr.fName,newName,32);    /************************************************   *   *  Create the new file, if we can.   *   ************************************************/    FSDelete(sfr.fName,sfr.vRefNum);  if ( (result=Create(sfr.fName,sfr.vRefNum,'ppxi','JFIF')) != noErr ) {    goto done;  }  if ( (result=FSOpen(sfr.fName,sfr.vRefNum,&amp;compressedFile)) != noErr ) {    goto done;  }  /*************************************************   set globals used by extraction function     *************************************************/  extractionFile = compressedFile;  extractionErr = -1;    // our own error in case there is no data in pict      /*************************************************     make a temporary buffer to draw into - small as possible since it's not used       and draw the image into it while intercepting the QT bottleneck proc.      *************************************************/    if ( (result =  NewGWorld(&amp;gw,1,&amp;rect,0,0,0)) == noErr ) {    SetGWorld(gw,nil);        /* get std bottlenecks and grab the one we want */        SetStdCProcs(&amp;cprocs);    cprocs.newProc1 = NewStdPixProc(StdPixExtract);    gw-&gt;grafProcs = &amp;cprocs;        /* draw the picture - grab data with bottleneck */        result = DrawPictureFile(originalFile,&amp;gw-&gt;portRect,nil);    if ( result == 0 )      result = extractionErr;  }  done:    /************************************************    clean up and go home.    ************************************************/    if ( gw )     DisposeGWorld(gw);  FSClose(originalFile);  if ( compressedFile )  {    FSClose(compressedFile);    if ( result != noErr )      FSDelete(sfr.fName,sfr.vRefNum);    FlushVol(nil,sfr.vRefNum);  }  SetGWorld(savePort,saveGD);  return(result);}/************************************************************************************  bottle neck proc to extract data from quicktime pict  *************************************************************************************/pascal voidStdPixExtract(PixMap *src,Rect *srcRect,MatrixRecord matrix,short mode,RgnHandle mask,PixMap *matte,  Rect *matteRect,short flags) {#pragma  unused(srcRect,matrix,matte,matteRect,flags,mode,mask)  ImageDescriptionHandle  idh;  long buffSize;  ICMDataProcRecord dataProc;  ICMProgressProcRecord progressProc;  Ptr  data;    long    lb,l;  short    i,m;  char     *buf,*abuf=nil,tbuf[32];      /************************************************************     first check to see if it's a compressed pict opcode       ************************************************************/    if ( GetCompressedPixMapInfo(src,&amp;idh,&amp;data,&amp;buffSize,&amp;dataProc,&amp;progressProc) == 0 ) {        /*******************************         verify compression type           ********************************/            if (  (*idh)-&gt;cType != 'jpeg' ) {      extractionErr = paramErr;    // we only wanted jpeg      return;    }    l = (*idh)-&gt;dataSize;      /********************************           make a JFIF header opcode in case the data doesn't have one -       QT JPEG always includes one but other JPEG compressors may not            ********************************/            {      buf = tbuf;      m = 0;      buf[m++] = MARKER_PREFIX;        // marker prefix      buf[m++] = MARKER_APP0;        // APP0 marker      buf[m++] = 0;          // size word ( filled in later )      buf[m++] = 0;      buf[m++] = 'J';          // tag 5 bytes      buf[m++] = 'F';      buf[m++] = 'I';      buf[m++] = 'F';      buf[m++] = 0;          buf[m++] = 1;          // version word      buf[m++] = 1;      buf[m++] = 1;          // specify dpi      buf[m++] = (*idh)-&gt;hRes&gt;&gt;24;  // hres word      buf[m++] = (*idh)-&gt;hRes&gt;&gt;16;      buf[m++] = (*idh)-&gt;vRes&gt;&gt;24;  // vres word      buf[m++] = (*idh)-&gt;vRes&gt;&gt;16;      buf[m++] = 0;          // thumbnail x       buf[m++] = 0;          // thumbnail y     }    buf[2] = (m-2)&gt;&gt;8;          // fill in size    buf[3] = (m-2);    i = 0;        /********************************        Scan the JPEG data till we get to the start of image marker.        ********************************/            while ( data[i] == (char)MARKER_PREFIX ) {      if ( i++ &gt; 1024 ) {        extractionErr = -1;        if ( abuf )          DisposePtr(abuf);        return;      }    }    if ( data[i++] != (char)MARKER_SOI ) {       extractionErr = -1;      if ( abuf )        DisposePtr(abuf);      return;    }        /*******************************        Write out all the data up to and including the start of image marker        *******************************/        lb = i;    if ( dataProc.dataProc ) {      if ( extractionErr = CallICMDataProc(dataProc.dataProc,&amp;data,lb,dataProc.dataRefCon))        return;    }    if ( extractionErr = FSWrite(extractionFile,&amp;lb,data))  {      if ( abuf )        DisposePtr(abuf);      return;    }        /*******************************        Check to see if there is a JFIF marker in the data already        *******************************/          if ( data[i] == (char)MARKER_PREFIX &amp;&amp;  data[i+1] == (char)MARKER_APP0 ) {  // already have JFIF marker in stream      data += i;      l -= i;      goto no_jfif_marker;    } else {      data += i;      l -= i;    }      lb = m;    if ( extractionErr = FSWrite(extractionFile,&amp;lb,buf))  {      if ( abuf )        DisposePtr(abuf);      return;    }no_jfif_marker:    if ( abuf )      DisposePtr(abuf);      /*******************************        Read the rest of the JPEG data and write it into the output file.        *******************************/        if (  dataProc.dataProc ) {      lb = buffSize;      while ( l &gt; buffSize ) {        if ( extractionErr = CallICMDataProc(dataProc.dataProc,&amp;data,lb,dataProc.dataRefCon))  {          return;        }        if ( extractionErr = FSWrite(extractionFile,&amp;lb,data)) {          return;        }        data += lb;        l -= lb;      }      if ( extractionErr = CallICMDataProc(dataProc.dataProc,&amp;data,l,dataProc.dataRefCon)) {        return;      }      if ( extractionErr = FSWrite(extractionFile,&amp;l,data)) {        return;      }    } else {      if ( extractionErr = FSWrite(extractionFile,&amp;l,data))        return;    }        } else {      /*******************************        Not compressed data - return error.        *******************************/      extractionErr = paramErr;  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/JPEG_File_Interchange_Format/listing3.html%3Fid%3DDTS10000845-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/JPEG_File_Interchange_Format/listing3.html%3Fid%3DDTS10000845-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/JPEG_File_Interchange_Format/listing3.html%3Fid%3DDTS10000845-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>