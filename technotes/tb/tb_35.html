<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><meta name="keywords" content="finder multifinder waitnextevent"><meta name="Description" content="Technical Note TB35: This Technical Note discusses MultiFinder issues of which programmers should be aware."><title>Technical Note TB35: MultiFinder Miscellanea</title>                             <meta name="categories" content="Human Interface Toolbox"><meta name="week-posted" content="Oct 26, 1987 - Nov 6, 1987"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002786" title="MultiFinder Miscellanea"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxUserExperience-date.html">User Experience</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/UserExperience/index.html" target="_blank">Reference Library > User Experience</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TB35</div>
<div id="pageheadsub">MultiFinder Miscellanea</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Switching</A><BR><BR><A HREF="#Section2">Suspend and Resume Events</A><BR><BR><A HREF="#Section3">Referencing Global Data (A5 and MultiFinder)</A><BR><BR><A HREF="#Section4">Launching and MultiFinder</A><BR><BR><A HREF="#Section5">The Scrap and MultiFinder</A><BR><BR><A HREF="#Section6">_UnmountVol and MultiFinder</A><BR><BR><A HREF="#Section7">Displaying a Splash Screen</A><BR><BR><A HREF="#Section8">The Apple Menu and MultiFinder</A><BR><BR><A HREF="#Section9">Interprocess Communication</A><BR><BR><A HREF="#Section10">_PostEvent</A><BR><BR><A HREF="#Section11">Miscellaneous Miscellanea</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note discusses MultiFinder issues of which programmers should beaware.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Nov 01 1987]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Switching</h2><p>For conceptual clarity, it is best to think of MultiFinder 6.0 and earlier asusing three types of switching:  major, minor, and update.  All switchingoccurs at a well defined times, namely, when a call is made to either<code>_WaitNextEvent</code>, <code>_GetNextEvent</code>, or <code>_EventAvail</code>.</p><p><b>Major switching</b> is a complete context switch, that is, an application'swindows are moved from the background to the foreground or vice versa.<code>A5</code> worlds are switched, and the application's low-memory world isswitched.  If the application accepts Suspend and Resume events, it is sonotified at major switch time.</p><p>Major switching will not occur when a modal dialog is the frontmost window ofthe front layer, though minor and update switching will occur.  To determinewhether major switching will occur, MultiFinder checks (among other things) ifthe window definition procedure of that window is <code>dBoxProc</code>.  If it is,then MultiFinder won't allow a switch via the user clicking on anotherapplication.  A window definition procedure of <code>dBoxProc</code> isspecifically reserved for modal dialogs--when most users see a<code>dBoxProc</code>, they are expecting a modal situation.  If you are using a<code>dBoxProc</code> for a non-modal window, we strongly recommend that you changeit to some other window type, or risk the wrath of the User-Interface ThoughtPolice (UITP).</p><p><b>Minor switching</b> occurs when an application needs to be switched out to givetime to background processes.  In a minor switch, <code>A5</code> worlds areswitched, as are low-memory worlds, but the application's layer of windows is<b>not </b>switched, and the application won't be notified of the switch viaSuspend and Resume events.</p><p><b>Update switching</b> occurs when MultiFinder detects that one or more of thewindows of an application that is not frontmost needs updating.  This happenswhether or not the application has the <code>canBackground</code> bit in the<code>'SIZE' -1</code> resource set.  This switch is very similar to minorswitching, except that update events are sent to the application whose windowneed updating.</p><p>Both minor and update switches should be transparent to the frontmostapplication.</p><P><A HREF="#top">Back to top</A></p><a name="Section2"></a><h2>Suspend and Resume Events</h2><p>If your application does not accept Suspend and Resume events (as set in the<code>'SIZE' -1</code> resource), then if a mouse-click event occurs in a windowthat isn't yours, MultiFinder will send your application a mouse-down eventwith code <code>inMenuBar</code> (with <code>menuID</code> equal to the ID of the Applemenu and <code>menuItem</code> set to "About MultiFinder...").  The reason thatMultiFinder does this is to force your application to think that a deskaccessory is opening, so that it will convert any private scrap that it mightbe keeping.  MultiFinder is expecting your application to call<code>_MenuSelect</code>--if you don't, it will currently issue a few moremouse-down events in the menu bar before finally giving up.  This isn't reallya problem, but a lot of developers have run into it, especially in "quick anddirty" applications.</p><p>If you are switching menu bars with <code>_SetMenuBar</code> (and switching theApple Menu) during the execution of your application, then you shoulddefinitely make sure that your application accepts Suspend and Resume events.MultiFinder records the ID of the original Apple menu that you use and won'tkeep track of any changes that you make to the Apple menu.  So, in the abovesituation, MultiFinder will give you a mouse-down event in the menu bar withthe <code>menuItem</code> set to the item number of "About MultiFinder..." that wasin the original Apple menu, which could be quite a confusing situation.  If youset the MultiFinder friendly bit in the <code>'SIZE'</code> resource, MultiFinderwill never give you these mouse-down events.</p><P><A HREF="#top">Back to top</A></p><a name="Section3"></a><h2>Referencing Global Data (A5 and MultiFinder)</h2><p>MultiFinder maintains a separate <code>A5</code> world for each application.MultiFinder switches <code>A5</code> worlds as appropriate, so most applicationsdon't have to worry about <code>A5</code> at all (except to make sure that itpoints to a valid QuickDraw global record at <code>_GetNextEvent</code> or<code>_WaitNextEvent</code> time).  MultiFinder also switches low-memory globalsfor you.  To get the value of the application's <code>A5</code>, use the routinesfrom TM.OV.A5.</p><p>If an application uses routines that execute at interrupt time and accessesglobals, then it needs to be concerned about <code>A5</code>.  MultiFinder affectsfour basic types of interrupt routines:</p><ul type="disc">	<li>VBL tasks </li>	<li>Completion routines </li>	<li>Time Manager tasks </li>	<li>Interrupt service routines</li></ul><h3>VBL Tasks</h3><p>If an application installs a VBL task into its application heap, MultiFinderwill currently "unhook" that VBL routine when it switches that application out(using either a major or a minor switch).  It will "rehook" it when theapplication is switched back in.  A VBL task that is installed in the systemheap will always receive time, that is, it will never be "unhooked."  Giventhis condition, it is technically not necessary for a VBL task that is in theapplication's heap to worry about its <code>A5</code> context, since it will onlybe running when that application's partition is switched in.  However, we wouldstill like to encourage you to set up <code>A5</code> by carrying its value aroundwith the VBL, since we may change the way this works in future versions ofMultiFinder (and even without MultiFinder, the VBL could trigger at a time when<code>A5</code> is not correct).</p><p>The following short MPW examples show how to do this using the new MPW 3.0calls mentioned in M.OV.A5.  Please note that this technique does <b>not</b>involve writing into your code segment (we'll get to that later), we just putour value of the application's <code>A5</code> in a location where we can find itfrom our VBL task.  Nor does it depend on the VBL task information beingallocated globally.  This gives you more flexibility setting up your VBL.</p><p>This example also serves to demonstrate how one might write a completionroutine for an asynchronous Device Manager call.  It is not intended to be acomplete program, nor to demonstrate optimal techniques for displayinginformation.</p><h3>MPW Pascal 3.0</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>UNIT    VBLS;{$R-}INTERFACEUSES    Dialogs, Events, OSEvents, Retrace, Packages, Types, Traps;CONST    Interval = 6;    rInfoDialog = 140;    rStatTextItem = 1;TYPE    { Define a record to keep track of what we need.  Put theVBLTask into the    record first because its address will be passed to our VBL task in A0. }    VBLRec = RECORD        theVBLTask:    VBLTask;         { the actual VBLTask }        VBLA5:        LongInt;        { saved CurrentA5 where we can ( find it }    END;    VBLRecPtr = ^VBLRec;VAR    gCounter:    LongInt;            { Global counter incremented by ( VBL }PROCEDURE InstallVBL;IMPLEMENTATION{ GetVBLRec returns the address of the VBLRec associated with our VBL task.  This works because on entry into the VBL task, A0 points to the theVBLTask  field in the VBLRec record, which is the first field in the record and that  is the address we return.  Note that this method works whether the VBLRec  is allocated globally, in the heap (as long as the record is locked in  memory) or if it is allocated on the stack as is the case in this example.  In the latter case this is OK as long as the procedure which installed the  task does not exit while the task is running.  This trick allows us to get  to the saved A5, but it could also be used to get to anything we wanted to  store in the record. }FUNCTION GetVBLRec: VBLRecPtr;    INLINE $2E88;             { MOVE.L A0,(A7) }PROCEDURE DoVBL (VRP: VBLRecPtr);{ DoVBL is called only by StartVBL }BEGIN    gCounter := gCounter + 1;            { Show we can set a global }    VRP^.theVBLTask.vblCount := Interval;      { Set ourselves to run again }END;PROCEDURE StartVBL;{ This is the actual VBL task code.  It uses GetVBLRec to get our VBL record  and properly set up A5.  Having done that, it calls DoVBL to increment a  global counter and sets itself to run again.  Because of the vagaries of  MPW C 3.0 optimization, it calls a separate routine to actually access  global variables.  See M.OV.A5 for the reasons for this, as well  as for a description of SetA5. }VAR    curA5:         LongInt;    recPtr:        VBLRecPtr;BEGIN    recPtr := GetVBLRec;                { First get our record }    curA5:= SetA5(recPtr^.VBLA5);        { Get our application's A5 }                            { Now we can access globals }    DoVBL (recPtr);                { Call another routine for actual ( work}    curA5:= SetA5(curA5);            { restore original A5, ignoring ( result }END;PROCEDURE InstallVBL;{ InstallVBL creates a dialog just to demonstrate that the global variable  is being updated by the VBL Task.  Before installing the VBL, we store  our A5 in the actual VBL Task record, using SetCurrentA5 described in  M.OV.A5.  We'll run the VBL, showing the counter being incremented,  until the mouse button is clicked.  Then we remove the VBL Task, close the  dialog, and remove the mouse down events to prevent the application from  being inadvertently switched by MultiFinder. }VAR    theVBLRec:        VBLRec;    infoDPtr:         DialogPtr;    infoDStorage:     DialogRecord;    numStr:        Str255;    theErr:        OSErr;    theItemHandle:    Handle;    theItemType:        INTEGER;    theRect:        Rect;BEGIN    gCounter:= 0;                { initialize the global variable }    infoDPtr:= GetNewDialog(rInfoDialog, @infoDStorage, Pointer(-1));    DrawDialog(infoDPtr);    GetDItem(infoDPtr, rStatTextItem, theItemType, theItemHandle, theRect);    theVBLRec.VBLA5:= SetCurrentA5;    { get our A5 }    WITH theVBLRec.theVBLTask DO        BEGIN            vblAddr:= @StartVBL;    { pointer to VBL code }            vblCount:= Interval;    { frequency of VBL in System ticks }            qType:= ORD(vType);    { qElement is a VBL type }            vblPhase:= 0;        { no phases }        END;    theErr:= VInstall(@theVBLRec.theVBLTask);    { install this VBL task }    IF theErr = noErr THEN            { we'll show the global value in }        BEGIN                    { the dialog until a mouse click }            REPEAT                NumToString(gCounter, numStr);                SetIText(theItemHandle, numStr);            UNTIL Button;        theErr:= VRemove(@theVBLRec.theVBLTask); { remove the VBL task }        END;    CloseDialog(infoDPtr);            { get rid of the info dialog }    FlushEvents(mDownMask, 0);            { remove all mouse down events }END;</pre>	</TD></TR></TABLE></CENTER><h3>MPW C 3.0</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include &lt;Events.h&gt;#include &lt;OSEvents.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Packages.h&gt;#include &lt;Retrace.h&gt;#include &lt;Traps.h&gt;#define INTERVAL        6#define rInfoDialog        140#define rStatTextItem    1/* *  These are globals which will be referenced from our VBL Task */long    gCounter;        /* Counter incremented each time our VBL gets called *//* *  Define a struct to keep track of what we need.  Put theVBLTask into the *  struct first because its address will be passed to our VBL task in A0 */struct VBLRec {    VBLTask    theVBLTask;    /* the VBL task itself */    long        VBLA5;        /* saved CurrentA5 where we can find it */};typedef struct VBLRec VBLRec, *VBLRecPtr;/* *    GetVBLRec returns the address of the VBLRec associated with our VBL task. *  This works because on entry into the VBL task, A0 points to the theVBLTask *  field in the VBLRec record, which is the first field in the record and that *  is the address we return.  Note that this method works whether the VBLRec *  is allocated globally, in the heap (as long as the record is locked in *  memory) or if it is allocated on the stack as is the case in this example. *  In the latter case this is OK as long as the procedure which installed the *  task does not exit while the task is running.  This trick allows us to get *  to the saved A5, but it could also be used to get to anything we wanted to *  store in the record.  */VBLRecPtr GetVBLRec ()    = 0x2008;            /* MOVE.L    A0,D0 *//* *  DoVBL is called only by StartVBL () */void DoVBL (VRP)VBLRecPtr    VRP;{    gCounter++;                    /* Show we can set a global */    VRP-&gt;theVBLTask.vblCount = INTERVAL;    /* Set ourselves to run again */}/* *  This is the actual VBL task code.  It uses GetVBLRec to get our VBL record *  and properly set up A5.  Having done that, it calls DoVBL to increment a *  global counter and sets itself to run again.  Because of the vagaries of *  MPW C 3.0 optimization, it calls a separate routine to actually access *  global variables.  See M.OV.A5  - &quot;Setting and Restoring A5&quot; for *  the reasons for this, as well as for a description of SetA5. */void StartVBL (){    long        curA5;    VBLRecPtr    recPtr;    recPtr = GetVBLRec ();        /* First get our record */    curA5 = SetA5 (recPtr-&gt;VBLA5);    /* Get the saved A5 */                        /* Now we can access globals */    DoVBL (recPtr);            /* Call another routine to do actual work */    (void) SetA5 (curA5);        /* Restore old A5 */}/* *  InstallVBL creates a dialog just to demonstrate that the global variable *  is being updated by the VBL Task.  Before installing the VBL, we store *  our A5 in the actual VBL Task record, using SetCurrentA5 described in *  TM.OV.A5.  We'll run the VBL, showing the counter being incremented, *  until the mouse button is clicked.  Then we remove the VBL Task, close the *  dialog, and remove the mouse down events to prevent the application from *  being inadvertently switched by MultiFinder. */void InstallCVBL (){    VBLRec            theVBLRec;    DialogPtr        infoDPtr;    DialogRecord        infoDStorage;    Str255            numStr;    OSErr            theErr;    Handle            theItemHandle;    short            theItemType;    Rect            theRect;    gCounter = 0;                /* Initialize our global counter */    infoDPtr = GetNewDialog (rInfoDialog, (Ptr) &amp;infoDStorage, (WindowPtr) -1);    DrawDialog (infoDPtr);    GetDItem (infoDPtr, rStatTextItem, &amp;theItemType, &amp;theItemHandle,        &amp;theRect);    /*     *  Store the current value of A5 in the MyA5 field.  For more     *  information on SetCurrentA5, see M.OV.A5     */    theVBLRec.VBLA5 = SetCurrentA5 ();    /* Set the address of our routine */    theVBLRec.theVBLTask.vblAddr = (VBLProcPtr) StartVBL;    theVBLRec.theVBLTask.vblCount = INTERVAL;    /* Frequency of task, in ticks */    theVBLRec.theVBLTask.qType = vType;        /* qElement is a VBL task */    theVBLRec.theVBLTask.vblPhase = 0;    /* Now install the VBL task */    theErr = VInstall ((QElemPtr)&amp;theVBLRec.theVBLTask);    if (!theErr) {        do {            NumToString (gCounter, numStr);            SetIText (theItemHandle, numStr);        } while (!Button ());        theErr = VRemove ((QElemPtr)&amp;theVBLRec.theVBLTask); /* Remove it when done */    }    /* Finish up */    CloseDialog (infoDPtr);                /* Get rid of our dialog */    FlushEvents (mDownMask, 0);                /* Flush all mouse down events */</pre>	</TD></TR></TABLE></CENTER><h3>Completion Routines</h3><p>Currently, MultiFinder will not do a major, minor, or update switch if anasynchronous File Manager call is pending.  This may not be true in the future.We recommend that you use the above technique to save <code>A5</code> forasynchronous File Manager calls.  MultiFinder does allow a switch if anasynchronous Device Manager or Sound Manager call is pending.  When the callcompletes, the completion routine has no way of knowing whose partition isactive, that is, it doesn't know if <code>A5</code> is valid (it needs <code>A5</code>if it wants to access a global).  Sounds pretty hopeless, huh?</p><p>Well, actually this one is quite easy, you just need to put the value of<code>A5</code> that "belongs" to your partition in a place where you can find itfrom your completion routine.  It is guaranteed that <code>A0</code> will point toyour parameter block when your completion routine is called, so you can use thesame technique shown with VBL tasks to put the value of <code>A5</code> at a knownoffset from the beginning of the parameter block, and then reference it from<code>A0</code>.  Completion routines are normally written in assembly language,though you can also write them in a high-level language.  A simple example ofhow to do this in MPW Pascal and C can be found in the previous section aboutVBL tasks (it was easier to provide a clear, concise example for VBL tasks thanfor asynchronous Device Manager completion routines).</p><h3>Time Manager Tasks</h3><p>The Time Manager was rewritten for System 6.0.3.  The new version will put apointer to the <code>TMTask</code> record in <code>A1</code>.  This is not true inSystem 6.0.2 or earlier.  The technique shown in the example VBL for accessingan application's globals is possible using System 6.0.3 and the Time Manager.Prior to System 6.0.3, the task must also store the application's <code>A5</code>into its code.  This method is not a very good idea and runs the risk ofincompatibility (self-modifying code).</p><h3>Interrupt Service Routines</h3><p>If your application needs to get to its application globals, and it replacesthe standard 68xxx interrupt vectors (levels 1-7) with pointers to its ownroutines, it must also store the application's <code>A5</code> into its code (sincethere is no parameter block for interrupt service routines).  This method isnot a very good idea and runs the risk of compatibility (self-modifyingcode).</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>WDEFs should also maintain a copy of <code>A5</code> in the samefashion as Time Manager tasks (prior to System Software 6.0.3) and set up<code>A5</code> when called; WDEFs should also be non-purgeable.</P></TD></TR></TABLE></CENTER><BR>  <P><A HREF="#top">Back to top</A></p><a name="Section4"></a><h2>Launching and MultiFinder</h2><p>M.PS.SubLaunching discusses the sublaunching feature of Systems 4.1 and newer.If you are running MultiFinder, and you use the technique demonstrated in thatTechnical Note, your application will be able to launch the desired applicationand remain open.  </p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>MultiFinder does not support <code>_Chain</code>; yourapplication should never call this trap.</p></TD></TR></TABLE></CENTER><BR><p>The application that you launch will become the foreground application.  Unlikenon-MultiFinder systems, when the user quits the application that you havesublaunched, control will not necessarily return to your application, butrather to the next frontmost layer.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The warnings in M.PS.SubLaunching about sublaunching still apply,but, if you still wish to sublaunch, we strongly recommend that you set bothhigh bits of <code>LaunchFlags</code>.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></p><a name="Section5"></a><h2>The Scrap and MultiFinder</h2><p>MultiFinder 6.0 and earlier keeps separate scrap variables for each partition.MultiFinder only checks to see whether or not to increment the otherpartitions' <code>scrapCount</code> variables in response to a user-initiated Cutor Copy.  To do this, it watches for a call to <code>_SysEdit</code>(<code>SystemEdit</code>) or a menu event to determine if an official Cut or Copycommand has been issued.</p><p>When an application calls <code>_PutScrap</code> or <code>_ZeroScrap</code> in responseto a Cut or Copy menu selection, the other partitions' <code>scrapCount</code>variables will be incremented (the other partitions will know that somethingnew has been put in the scrap).</p><P><A HREF="#top">Back to top</A></p><a name="Section6"></a><h2>_UnmountVol and MultiFinder</h2><p><code>_UnmountVol</code> was changed in System 4.2 so that it would work better in ashared environment.  In systems 4.1 and prior, <code>_UnmountVol</code> wouldsuccessfully unmount a volume even if files were open on that volume.  UnderMultiFinder, that would be disastrous, since one application could unmount avolume that another application was using (this exact problem could occur whenMultiFinder is not active, if a DA unmounted a volume "out from under" anapplication).</p><p>System 4.2 changes the behavior of <code>_UnmountVol</code> (whether or notMultiFinder is active) so that it returns a -47 (<code>FBsyErr</code>) error if anyfiles are open on the volume you wish to unmount.  Since the Finder always hasa Desktop file open for each volume, a call to <code>_UnmountVol</code> asks it toclose the Desktop file so you won't get an error if the only file open is theDesktop file.  However, there is a bug with this new behavior.  In System6.0.3, and earlier, <code>_UnmountVol</code> does not close the Desktop file forMFS-formatted volumes.  Only the Finder can unmount a MFS volume (when the userdrags the disk icon to the trash).</p><P><A HREF="#top">Back to top</A></p><a name="Section7"></a><h2>Displaying a Splash Screen</h2><p>Some applications like  to put up a "splash screen" to give the user somethingto look at while the application is loading. If your application does this<b>and</b> has the <code>canBackground</code> bit set in the size resource, then itshould call <code>_EventAvail</code> several times (or <code>_WaitNextEvent</code> or<code>_GetNextEvent</code>) before putting up the splash screen, or the splashscreen will come up behind the frontmost layer.  If the <code>canBackground</code>bit is set, MultiFinder will not move your layer to the front until you call<code>_GetNextEvent</code>, <code>_WaitNextEvent</code>, or <code>_EventAvail</code>.</p><P><A HREF="#top">Back to top</A></p><a name="Section8"></a><h2>The Apple Menu and MultiFinder</h2><p>Applications should avoid doing anything untoward with the Apple menu.  Forexample, if your application puts an icon next to the "About MyApplication..."item, MultiFinder may unceremoniously write over it.  It is important toconsider the Apple Menu owned by the system.  You can have the standard aboutitem, but other than this, you should avoid using the Apple menu.  Don't makeany assumptions about the contents of this menu.  Even reading from its datamay be a compatibility risk since its structure may change.</p><P><A HREF="#top">Back to top</A></p><a name="Section9"></a><h2>Interprocess Communication</h2><p>MultiFinder 6.0, and earlier, does not have full-fledged interprocesscommunication facilities.  There is no standard way to communicate betweenapplications in MultiFinder 6.0.  There are, however, a couple of ways tocommunicate between applications.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>It is in your best interest to wait until Apple implementsInterapplication Communication (IAC) in System 7.0.</P></TD></TR></TABLE></CENTER><BR>   <P><A HREF="#top">Back to top</A></p><a name="Section10"></a><h2>_PostEvent</h2><p>Even though you can have many applications running at once, each with a fairlyindependent world, the Event Manager maintains only one event queue.  Becauseof this single queue, and because there is no facility implemented to keeptrack of which events belong to which layer, all events in the queue are passedto the frontmost application.  This situation can cause problems forapplications that take advantage of application-defined events.  If theapplication is in the background and posts one of these events, then it is theforeground application that receives it.</p><p>This does not apply to events which are not really stored in the event queue.The list of these events include, but is not limited to, activate and updateevents, which are generated by the Window Manager as needed, and are correctlyrouted to the right application.</p><P><A HREF="#top">Back to top</A></p><a name="Section11"></a><h2>Miscellaneous Miscellanea</h2><p>The sound driver glue that shipped with MPW 1.0 and 2.0 is <b>not</b>MultiFinder compatible and should not be used.  This also includes much of theglue supplied with older development systems.  Instead, applications should beusing the Sound Manager.</p><p>All code needs to be aware of the shared environment; this includes screensavers.  Screen savers should make sure that background processing continues.A simple scenario for a screen saver that's an INIT might be:  patch<code>_PostEvent</code> at INIT time, put up a full-screen black window spider,call <code>_WaitNextEvent</code>, and watch <code>_PostEvent</code> to see if an eventthat should cause the screen saver to go away has occurred.</p><P><A HREF="#top">Back to top</A></p><a name = "References"></a><h2>References</h2><P><i>Inside Macintosh</i>, Volume V, Compatibility Guidelines</p><P><i>Programmer's Guide to MultiFinder</i> (APDA)</p><P><A HREF = "../ps/ps_01.html">M.PS.SubLaunching</a></p><P><A HREF = "../ov/ov_16.html">M.OV.GestaltSysenvirons</a></p><P>M.TB.Multifinder</p><P>M.OV.Multifinder</p><P>M.OV.A5</p>         <a name="Downloads"></a>       <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (68K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tb_35.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tb/tb_35.html%3Fid%3DDTS10002786-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tb/tb_35.html%3Fid%3DDTS10002786-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tb/tb_35.html%3Fid%3DDTS10002786-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>