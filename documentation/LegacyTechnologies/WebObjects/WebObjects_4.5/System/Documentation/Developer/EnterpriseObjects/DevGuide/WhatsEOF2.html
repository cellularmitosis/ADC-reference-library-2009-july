<html><head><title>What Is Enterprise Objects Framework?</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="WhatsEOF.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="WhatsEOF1.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="6291"><h1> From Database to Objects</h1></a><a name="6292">Enterprise Objects Framework's database-to-objects mapping sets up a correspondence between database tables and enterprise objects classes so that database rows map to instances of the appropriate class as shown in <a href="WhatsEOF2.html#10287">Figure &#32;2</a>.<p></a><a name="10286"><p><img src="WhatsEOF3.gif"><p></a><a name="10287"><p>Figure 2.	   Mapping Between an Enterprise Object Class and a Single Table<p></a><a name="10288">The mapping is flexible. For example:<p></a><ul><a name="6643"><p><li>You can map an enterprise object to a single table, a subset of a table, or to more than one table. For instance, a Person object can get its first and last names from a PERSON table but get its street address, city, state and zip code from an ADDRESS table.</a><a name="6631"><p><li>Generally an enterprise object instance variable maps to a single column, but the column-to-instance variable correspondence is similarly flexible. You can map an instance variable to a derived column, such as "price * discount" or "salary * 12". </a><a name="6570"><p><li>You can map an enterprise object inheritance hierarchy to one or more database tables.</a></ul><a name="11560">In addition to mapping tables to enterprise object classes and database columns to instance variables, the Framework maps database primary and foreign keys to relationships between objects. The Framework defines two types of relationships-to-ones and to-manys-which are both illustrated in <a href="WhatsEOF2.html#6350">Figure &#32;3</a>. The relationship a MovieRole has to its Movie is &#32;a to-one relationship, while the relationship a Movie has to its MovieRoles is a to-many.<p></a><a name="6338"><p><img src="WhatsEOF8.gif"><p></a><a name="6350"><p>Figure 3.	  Mapping Relationships<p></a><a name="6820">For more information on database-to-objects mappings, see the chapter <a href="EOsI.html#14081"> "Designing Enterprise Objects"</a>, and to learn how to define this mapping with the EOModeler application, see the book <em>Enterprise Objects Framework Tools and Techniques</em>.<p></a><a name="7082"><h2> Uniquing</h2></a><a name="6821">In marrying relational databases to object-oriented programming, one of the key requirements is that a row in the database be associated with only one enterprise object in a given context in your application. Enterprise Objects Framework maintains the mapping of each enterprise object to its corresponding database row, and uses this information to ensure that your object graph does not have two (possibly inconsistent) objects for the same database row. <em>Uniquing</em> of enterprise objects, as this process is called, limits memory usage and allows you to know with confidence that the object you're interacting with represents the true state of its associated row as it was last fetched into the object graph.<p></a><a name="6822">Without uniquing, you'd get a new enterprise object every time you fetch its corresponding row, whether explicitly or through resolution of relationships. This is illustrated in <a href="WhatsEOF2.html#6838">Figure &#32;4</a>.<p></a><a name="6836"><p><img src="WhatsEOF9.gif"><p></a><a name="6838"><p>Figure 4.	  Uniquing of Enterprise Objects<p></a><a name="6766"><h2> Resolution of Relationships and Faulting</h2></a><a name="11614">When the Framework fetches an object, it creates objects representing the destinations of the fetched object's relationships. For example, if you fetch an employee object, you can ask for its manager and immediately receive an object; you don't have to get the manager's employee ID from the object you just fetched and fetch the manager yourself.<p></a><a name="11615">The Framework doesn't immediately fetch data for the destination objects of relationships, however. Fetching is fairly expensive, and further, if the Framework fetched objects related to the one explicitly asked for, it would also have to fetch the objects related to those, and so on, until all of the interrelated rows in the database had been retrieved. To avoid this waste of time and resources, the destination objects created are stand-ins, called <em>faults</em>, that fetch their data the first time they're accessed. <a href="WhatsEOF2.html#6805">Figure &#32;5</a> illustrates this process.<p></a><a name="7077">The framework allows you to tune relationship resolution by <em>prefetching</em> relationships and <em>batch faulting</em>. For more information on these features, see the chapter<a href="FAQ.html#7958"> "Answers to Common Design Questions"</a>. For more information on the general faulting mechanism, see the chapter <a href="BehindSc.html#8585"> "Behind the Scenes"</a>.<p></a><a name="6803"><p><img src="WhatsEOF.gif"><p></a><a name="6805"><p>Figure 5.	  Resolution of a Fault<p></a><P> <a href="WhatsEOF.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="WhatsEOF3.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>