<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLSL Showpiece Lite - /GLSLShowpiece Lite/Viewer/Sources/OpenGLView.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLSL Showpiece Lite</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLSL Showpiece Lite</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GLSLShowpiece Lite/Viewer/Sources/OpenGLView.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/GLSLShowpiece Lite/Exhibits/3Dlabs-license.txt</option>
<option value="listing2.html">/GLSLShowpiece Lite/Exhibits/ATI-License.txt</option>
<option value="listing3.html">/GLSLShowpiece Lite/Exhibits/Cloud1/Cloud1.h</option>
<option value="listing4.html">/GLSLShowpiece Lite/Exhibits/Cloud1/Cloud1.m</option>
<option value="listing5.html">/GLSLShowpiece Lite/Exhibits/Cloud2/Cloud2.h</option>
<option value="listing6.html">/GLSLShowpiece Lite/Exhibits/Cloud2/Cloud2.m</option>
<option value="listing7.html">/GLSLShowpiece Lite/Exhibits/Earth/Earth.h</option>
<option value="listing8.html">/GLSLShowpiece Lite/Exhibits/Earth/Earth.m</option>
<option value="listing9.html">/GLSLShowpiece Lite/Exhibits/EnvMap/EnvMap.h</option>
<option value="listing10.html">/GLSLShowpiece Lite/Exhibits/EnvMap/EnvMap.m</option>
<option value="listing11.html">/GLSLShowpiece Lite/Exhibits/Eroded/Eroded.h</option>
<option value="listing12.html">/GLSLShowpiece Lite/Exhibits/Eroded/Eroded.m</option>
<option value="listing13.html">/GLSLShowpiece Lite/Exhibits/Fire/Fire.h</option>
<option value="listing14.html">/GLSLShowpiece Lite/Exhibits/Fire/Fire.m</option>
<option value="listing15.html">/GLSLShowpiece Lite/Exhibits/Fur/Fur.h</option>
<option value="listing16.html">/GLSLShowpiece Lite/Exhibits/Fur/Fur.m</option>
<option value="listing17.html">/GLSLShowpiece Lite/Exhibits/Glass/Glass.h</option>
<option value="listing18.html">/GLSLShowpiece Lite/Exhibits/Glass/Glass.m</option>
<option value="listing19.html">/GLSLShowpiece Lite/Exhibits/Gooch/Gooch.h</option>
<option value="listing20.html">/GLSLShowpiece Lite/Exhibits/Gooch/Gooch.m</option>
<option value="listing21.html">/GLSLShowpiece Lite/Exhibits/Granite/Granite.h</option>
<option value="listing22.html">/GLSLShowpiece Lite/Exhibits/Granite/Granite.m</option>
<option value="listing23.html">/GLSLShowpiece Lite/Exhibits/Inferno/Inferno.h</option>
<option value="listing24.html">/GLSLShowpiece Lite/Exhibits/Inferno/Inferno.m</option>
<option value="listing25.html">/GLSLShowpiece Lite/Exhibits/LightworkDesign-license.txt</option>
<option value="listing26.html">/GLSLShowpiece Lite/Exhibits/Marble/Marble.h</option>
<option value="listing27.html">/GLSLShowpiece Lite/Exhibits/Marble/Marble.m</option>
<option value="listing28.html">/GLSLShowpiece Lite/Exhibits/Plasma/Plasma.h</option>
<option value="listing29.html">/GLSLShowpiece Lite/Exhibits/Plasma/Plasma.m</option>
<option value="listing30.html">/GLSLShowpiece Lite/Exhibits/Toon/Toon.h</option>
<option value="listing31.html">/GLSLShowpiece Lite/Exhibits/Toon/Toon.m</option>
<option value="listing32.html">/GLSLShowpiece Lite/Exhibits/Toyball/Toyball.h</option>
<option value="listing33.html">/GLSLShowpiece Lite/Exhibits/Toyball/Toyball.m</option>
<option value="listing34.html">/GLSLShowpiece Lite/Exhibits/VertexNoise/VertexNoise.h</option>
<option value="listing35.html">/GLSLShowpiece Lite/Exhibits/VertexNoise/VertexNoise.m</option>
<option value="listing36.html">/GLSLShowpiece Lite/Exhibits/Wobble/Wobble.h</option>
<option value="listing37.html">/GLSLShowpiece Lite/Exhibits/Wobble/Wobble.m</option>
<option value="listing38.html">/GLSLShowpiece Lite/Exhibits/Wood1/Wood1.h</option>
<option value="listing39.html">/GLSLShowpiece Lite/Exhibits/Wood1/Wood1.m</option>
<option value="listing40.html">/GLSLShowpiece Lite/Exhibits/Wood2/Wood2.h</option>
<option value="listing41.html">/GLSLShowpiece Lite/Exhibits/Wood2/Wood2.m</option>
<option value="listing42.html">/GLSLShowpiece Lite/Exhibits/WoodShader/WoodShader.h</option>
<option value="listing43.html">/GLSLShowpiece Lite/Exhibits/WoodShader/WoodShader.m</option>
<option value="listing44.html">/GLSLShowpiece Lite/Extras/Noise3DTexture/Noise3DTexture.cpp</option>
<option value="listing45.html">/GLSLShowpiece Lite/Extras/Noise3DTexture/Noise3DTexture.h</option>
<option value="listing46.html">/GLSLShowpiece Lite/Models/Bunny/Bunny.c</option>
<option value="listing47.html">/GLSLShowpiece Lite/Models/Bunny/Bunny.h</option>
<option value="listing48.html">/GLSLShowpiece Lite/Models/Models/Models.h</option>
<option value="listing49.html">/GLSLShowpiece Lite/Models/Models/Models.m</option>
<option value="listing50.html">/GLSLShowpiece Lite/Models/Teapot/Teapot.c</option>
<option value="listing51.html">/GLSLShowpiece Lite/Models/Teapot/Teapot.h</option>
<option value="listing52.html">/GLSLShowpiece Lite/Surfaces/Constants/GeometryConstants.h</option>
<option value="listing53.html">/GLSLShowpiece Lite/Surfaces/Klein Surface/Headers/KleinSurface.h</option>
<option value="listing54.html">/GLSLShowpiece Lite/Surfaces/Klein Surface/Sources/KleinSurface.mm</option>
<option value="listing55.html">/GLSLShowpiece Lite/Surfaces/Surfaces/Headers/Surfaces.h</option>
<option value="listing56.html">/GLSLShowpiece Lite/Surfaces/Surfaces/Sources/Surfaces.mm</option>
<option value="listing57.html">/GLSLShowpiece Lite/Utilities/Numerics/Numerics.h</option>
<option value="listing58.html">/GLSLShowpiece Lite/Utilities/Numerics/Numerics.m</option>
<option value="listing59.html">/GLSLShowpiece Lite/Utilities/UniformData/UniformData.h</option>
<option value="listing60.html">/GLSLShowpiece Lite/Utilities/UniformData/UniformData.m</option>
<option value="listing61.html">/GLSLShowpiece Lite/Viewer/Headers/Exhibit.h</option>
<option value="listing62.html">/GLSLShowpiece Lite/Viewer/Headers/OpenGLView.h</option>
<option value="listing63.html">/GLSLShowpiece Lite/Viewer/Headers/UIController.h</option>
<option value="listing64.html">/GLSLShowpiece Lite/Viewer/Sources/Exhibit.m</option>
<option value="listing65.html">/GLSLShowpiece Lite/Viewer/Sources/main.m</option>
<option value="listing66.html">/GLSLShowpiece Lite/Viewer/Sources/OpenGLView.m</option>
<option value="listing67.html">/GLSLShowpiece Lite/Viewer/Sources/UIController.m</option>
<option value="listing68.html">/LessonGuide/GLSLPrereqs HTML/GLSLPrereqs.html</option>
<option value="listing69.html">/LessonGuide/GLSLPrereqs HTML/GLSLPrereqs_files/GLSLPrereqs.css</option>
<option value="listing70.html">/Textures/EarthImages.txt</option>
<option value="listing71.html">/Textures/envmaps.txt</option></select>
				</p>
				</form>
				<p><strong><a href="GLSLShowpieceLite.zip">Download Sample</a></strong> (&#147;GLSLShowpieceLite.zip&#148;, 2.30M)<BR>
<strong><a href="GLSLShowpieceLite.dmg">Download Sample</a></strong> (&#147;GLSLShowpieceLite.dmg&#148;, 2.57M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//-------------------------------------------------------------------------
//
//  File: OpenGLView.m
//
//  Abstract: Main rendering class
//        
//  Disclaimer: IMPORTANT:  This Apple software is supplied to you by
//  Apple Inc. (&quot;Apple&quot;) in consideration of your agreement to the
//  following terms, and your use, installation, modification or
//  redistribution of this Apple software constitutes acceptance of these
//  terms.  If you do not agree with these terms, please do not use,
//  install, modify or redistribute this Apple software.
//  
//  In consideration of your agreement to abide by the following terms, and
//  subject to these terms, Apple grants you a personal, non-exclusive
//  license, under Apple's copyrights in this original Apple software (the
//  &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
//  Software, with or without modifications, in source and/or binary forms;
//  provided that if you redistribute the Apple Software in its entirety and
//  without modifications, you must retain this notice and the following
//  text and disclaimers in all such redistributions of the Apple Software. 
//  Neither the name, trademarks, service marks or logos of Apple Inc.
//  may be used to endorse or promote products derived from the Apple
//  Software without specific prior written permission from Apple.  Except
//  as expressly stated in this notice, no other rights or licenses, express
//  or implied, are granted by Apple herein, including but not limited to
//  any patent rights that may be infringed by your derivative works or by
//  other works in which the Apple Software may be incorporated.
//  
//  The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
//  MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
//  THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
//  FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
//  OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//  
//  IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
//  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
//  MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
//  AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
//  STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
// 
//  Copyright (c) 2004-2007 Apple Inc., All rights reserved.
//
//-------------------------------------------------------------------------

//------------------------------------------------------------------------

#import &lt;Accelerate/Accelerate.h&gt;

//------------------------------------------------------------------------

#import &quot;OpenGLView.h&quot;

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static const double          kViewRotationDegreesPerSecond        = 20.0;
static const double          kExhibitHeightMovementUnitsPerSecond = 0.5;
static const NSTimeInterval  kScheduledTimerInSeconds             = 1.0f/150.0f; 

//------------------------------------------------------------------------

//------------------------------------------------------------------------

typedef struct
{
  GLuint         imageBitsPerPixel;
  GLuint         imageBitsPerComponent;
  GLuint         imageSamplesPerPixel;
  GLuint         imageStorageSize;
  CGBitmapInfo   imageBitmapInfo;
  vImage_Buffer  imageBuffer;
} CGImageBitmap;

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static inline GLboolean CheckForExtension( const char *extensionName, const GLubyte *extensions )
{
  GLboolean  bExtensionAvailable = gluCheckExtension( (GLubyte *)extensionName, extensions );
  
  return bExtensionAvailable;
} // CheckForExtension

//------------------------------------------------------------------------

static inline void CheckForAndLogExtensionAvailable( const GLboolean extensionAvailable, const char *extensionName )
{
  if ( extensionAvailable == GL_FALSE )
  {
    NSLog( @&quot;&gt;&gt; WARNING: \&quot;%s\&quot; extension is not available!\n&quot;, extensionName );
  } // if
} // CheckForExtensions

//------------------------------------------------------------------------

static void CheckForShaders( NSOpenGLPixelFormatAttribute *thePixelAttributes )
{
  const GLubyte *extensions = glGetString( GL_EXTENSIONS );
  
  GLboolean  bShaderObjectAvailable      = CheckForExtension(       &quot;GL_ARB_shader_objects&quot;, extensions );
  GLboolean  bShaderLanguage100Available = CheckForExtension( &quot;GL_ARB_shading_language_100&quot;, extensions );
  GLboolean  bVertexShaderAvailable      = CheckForExtension(        &quot;GL_ARB_vertex_shader&quot;, extensions );
  GLboolean  bFragmentShaderAvailable    = CheckForExtension(      &quot;GL_ARB_fragment_shader&quot;, extensions );
  
  GLboolean  bForceSoftwareRendering =      ( bShaderObjectAvailable      == GL_FALSE )
                       || ( bShaderLanguage100Available == GL_FALSE )
                       || ( bVertexShaderAvailable      == GL_FALSE ) 
                       || ( bFragmentShaderAvailable    == GL_FALSE );
  
  if ( bForceSoftwareRendering )
  {
    // Force software rendering, so fragment shaders will execute

    CheckForAndLogExtensionAvailable(      bShaderObjectAvailable, &quot;GL_ARB_shader_objects&quot;       );
    CheckForAndLogExtensionAvailable( bShaderLanguage100Available, &quot;GL_ARB_shading_language_100&quot; );
    CheckForAndLogExtensionAvailable(      bVertexShaderAvailable, &quot;GL_ARB_vertex_shader&quot;        );
    CheckForAndLogExtensionAvailable(    bFragmentShaderAvailable, &quot;GL_ARB_fragment_shader&quot;      );

    thePixelAttributes [3] = NSOpenGLPFARendererID;
    thePixelAttributes [4] = kCGLRendererGenericFloatID;
  } // if
} // CheckForShaders

//------------------------------------------------------------------------

static void CheckForClipVolumeHint( NSOpenGLPixelFormatAttribute *thePixelAttributes )
{
  const GLubyte *extensions = glGetString(GL_EXTENSIONS);

  // Inform OpenGL that the geometry is entirely within the view volume and that view-volume 
  // clipping is unnecessary. Normal clipping can be resumed by setting this hint to GL_DONT_CARE. 
  // When clipping is disabled with this hint, results are undefined if geometry actually falls 
  // outside the view volume.

  GLboolean  bClipVolumeHintExtAvailable = CheckForExtension( &quot;GL_EXT_clip_volume_hint&quot;, extensions );
  
  if (  bClipVolumeHintExtAvailable == GL_TRUE )
  {
    glHint( GL_CLIP_VOLUME_CLIPPING_HINT_EXT,GL_FASTEST );
  } // if
} // CheckForClipVolumeHint

//------------------------------------------------------------------------

static void CheckForGLSLHardwareSupport( NSOpenGLPixelFormatAttribute *thePixelAttributes )
{
  // Create a pre-flight context to check for GLSL hardware support
  
  NSOpenGLPixelFormat  *pixelFormat = [[NSOpenGLPixelFormat alloc] initWithAttributes: thePixelAttributes];
  
  if ( pixelFormat != nil )
  {
    NSOpenGLContext *preflight = [[NSOpenGLContext alloc] initWithFormat:pixelFormat shareContext:nil];
    
    if ( preflight != nil )
    {
      [preflight makeCurrentContext];
    
        CheckForShaders( thePixelAttributes );
        CheckForClipVolumeHint( thePixelAttributes );
    
      [preflight   release];
    } // if
  
    [pixelFormat release];
  } // if
} // CheckForGLSLHardwareSupport

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static void OpenGLSetupProjections()
{
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glFrustum(-0.3, 0.3, 0.0, 0.6, 1.0, 8.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef(0.0, 0.0, -2.0);
} // OpenGLSetupProjections

//------------------------------------------------------------------------

static void OpenGLSetupBlending()
{
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
} // OpenGLSetupBlending

//------------------------------------------------------------------------

static void OpenGLSetup( const GLboolean setupBlending )
{
  // For some OpenGL implementations, texture coordinates generated during rasterization 
  // aren't perspective correct. However, you can usually make them perspective correct 
  // by calling glHint(GL_PERSPECTIVE_CORRECTION_HINT,GL_NICEST). Colors generated at the 
  // rasterization stage aren't perspective correct in almost every OpenGL implementation, 
  // and can't be made so. For this reason, you're more likely to encounter this problem 
  // with colors than texture coordinates.
  
  glHint(GL_PERSPECTIVE_CORRECTION_HINT,GL_NICEST);
  
  // Set up the projection

  OpenGLSetupProjections();

  // Use blending
  
  if ( setupBlending )
  {
    OpenGLSetupBlending();
  } // if
  
  // Turn on depth test
  
    glEnable( GL_DEPTH_TEST );
  
  // front- or back-facing facets can be culled
  
    glEnable( GL_CULL_FACE );
} // OpenGLSetup

//------------------------------------------------------------------------

static void OpenGLNoError( )
{
    while( glGetError() != GL_NO_ERROR )
  {
    ;
  } // while
} // OpenGLNoError

//------------------------------------------------------------------------

static void OpenGLDisableCapabilitiesForCopy( )
{
  glDisable(GL_COLOR_TABLE);
  glDisable(GL_CONVOLUTION_1D);
  glDisable(GL_CONVOLUTION_2D);
  glDisable(GL_HISTOGRAM);
  glDisable(GL_MINMAX);
  glDisable(GL_POST_COLOR_MATRIX_COLOR_TABLE);
  glDisable(GL_POST_CONVOLUTION_COLOR_TABLE);
  glDisable(GL_SEPARABLE_2D);
} // OpenGLDisableCapabilitiesForCopy

//------------------------------------------------------------------------

static void OpenGLPixelMap( )
{
  GLfloat values = 0.0f;
  
  glPixelMapfv(GL_PIXEL_MAP_R_TO_R, 1, &amp;values);
  glPixelMapfv(GL_PIXEL_MAP_G_TO_G, 1, &amp;values);
  glPixelMapfv(GL_PIXEL_MAP_B_TO_B, 1, &amp;values);
  glPixelMapfv(GL_PIXEL_MAP_A_TO_A, 1, &amp;values);
} // OpenGLPixelMap

//------------------------------------------------------------------------

static void OpenGLPixelStore( NSPoint *origin, NSRect *rect1, NSRect *rect2 )
{
  glPixelStorei(GL_PACK_SWAP_BYTES, 0);
  glPixelStorei(GL_PACK_LSB_FIRST, 0);
  glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
  glPixelStoref(GL_PACK_ROW_LENGTH, NSWidth(*rect2)); 
  glPixelStoref(GL_PACK_SKIP_PIXELS, origin-&gt;x);
  glPixelStoref(GL_PACK_SKIP_ROWS, NSHeight(*rect2) - (origin-&gt;y + NSHeight(*rect1)));
  glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
} // OpenGLPixelStore

//------------------------------------------------------------------------

static void OpenGLPixelTransfer( )
{
  glPixelTransferi(GL_MAP_COLOR, 0);
  glPixelTransferf(GL_RED_SCALE, 1.0f);
  glPixelTransferf(GL_RED_BIAS, 0.0f);
  glPixelTransferf(GL_GREEN_SCALE, 1.0f);
  glPixelTransferf(GL_GREEN_BIAS, 0.0f);
  glPixelTransferf(GL_BLUE_SCALE, 1.0f);
  glPixelTransferf(GL_BLUE_BIAS, 0.0f);
  glPixelTransferf(GL_ALPHA_SCALE, 1.0f);
  glPixelTransferf(GL_ALPHA_BIAS, 0.0f);
  glPixelTransferf(GL_POST_COLOR_MATRIX_RED_SCALE, 1.0f);
  glPixelTransferf(GL_POST_COLOR_MATRIX_RED_BIAS, 0.0f);
  glPixelTransferf(GL_POST_COLOR_MATRIX_GREEN_SCALE, 1.0f);
  glPixelTransferf(GL_POST_COLOR_MATRIX_GREEN_BIAS, 0.0f);
  glPixelTransferf(GL_POST_COLOR_MATRIX_BLUE_SCALE, 1.0f);
  glPixelTransferf(GL_POST_COLOR_MATRIX_BLUE_BIAS, 0.0f);
  glPixelTransferf(GL_POST_COLOR_MATRIX_ALPHA_SCALE, 1.0f);
  glPixelTransferf(GL_POST_COLOR_MATRIX_ALPHA_BIAS, 0.0f);
} // OpenGLPixelTransfer

//------------------------------------------------------------------------

static inline void OpenGLReadRGBAPixels( NSRect *rect, GLvoid *pixels )
{
  GLint    x      = (GLint) NSMinX(*rect);
  GLint    y      = (GLint) NSMinY(*rect);
  GLsizei  width  = (GLsizei) NSWidth(*rect);
  GLsizei  height = (GLsizei) NSHeight(*rect);
  GLenum   format = GL_RGBA;
  GLenum   type   = GL_UNSIGNED_BYTE;

  glReadPixels( x, y, width, height, format, type, pixels );
} // OpenGLReadRGBAPixels

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static GLvoid CGImageBitmapMemset( CGImageBitmap *imageBitmap )
{
  imageBitmap-&gt;imageBitsPerPixel     = 0;
  imageBitmap-&gt;imageBitsPerComponent = 0;
  imageBitmap-&gt;imageSamplesPerPixel  = 0;
  imageBitmap-&gt;imageBitmapInfo       = 0;
  imageBitmap-&gt;imageStorageSize      = 0;
  imageBitmap-&gt;imageBuffer.width     = 0;
  imageBitmap-&gt;imageBuffer.height    = 0;
  imageBitmap-&gt;imageBuffer.rowBytes  = 0;
  imageBitmap-&gt;imageBuffer.data      = NULL;
} // CGImageBitmapMemset

//------------------------------------------------------------------------

static BOOL CGImageBitmapMalloc( CGImageRef imageRef, CGImageBitmap *imageBitmap )
{
  BOOL  imageBitmapAllocated = NO;
  
  imageBitmap-&gt;imageBitsPerPixel     = 32;
  imageBitmap-&gt;imageBitsPerComponent = 8;
  imageBitmap-&gt;imageSamplesPerPixel  = 4;
  imageBitmap-&gt;imageBitmapInfo       = kCGImageAlphaPremultipliedLast; // RGBA
  imageBitmap-&gt;imageBuffer.width     = CGImageGetWidth( imageRef );
  imageBitmap-&gt;imageBuffer.height    = CGImageGetHeight( imageRef );
  imageBitmap-&gt;imageBuffer.rowBytes  = imageBitmap-&gt;imageBuffer.width * imageBitmap-&gt;imageSamplesPerPixel;
  imageBitmap-&gt;imageStorageSize      = imageBitmap-&gt;imageBuffer.rowBytes * imageBitmap-&gt;imageBuffer.height;
  imageBitmap-&gt;imageBuffer.data      = (GLvoid *)malloc( imageBitmap-&gt;imageStorageSize );
  
  if ( imageBitmap-&gt;imageBuffer.data != NULL )
  {
    imageBitmapAllocated = YES;
  } // if
  else
  {
    CGImageBitmapMemset( imageBitmap );
  } // else
  
  return imageBitmapAllocated;
} // CGImageBitmapMalloc

//------------------------------------------------------------------------

static BOOL CGImageBitmapFree( CGImageBitmap *imageBitmap )
{
  BOOL  imageBitmapFreed = NO;
  
  if ( imageBitmap-&gt;imageBuffer.data != NULL )
  {
    free( imageBitmap-&gt;imageBuffer.data );
    
    imageBitmapFreed = YES;
  } // if
  
  CGImageBitmapMemset( imageBitmap );
  
  return imageBitmapFreed;
} // CGImageBitmapFree

//------------------------------------------------------------------------

static CGContextRef CGImageBitmapContexMalloc( CGImageBitmap *imageBitmap )
{
  CGContextRef     imageContextRef    = NULL;
  CGColorSpaceRef  imageColorSpaceRef = CGColorSpaceCreateWithName( kCGColorSpaceGenericRGB );

  if ( imageColorSpaceRef != NULL )
  {
    imageContextRef = CGBitmapContextCreate( imageBitmap-&gt;imageBuffer.data, 
                         imageBitmap-&gt;imageBuffer.width, 
                         imageBitmap-&gt;imageBuffer.height, 
                         imageBitmap-&gt;imageBitsPerComponent,
                         imageBitmap-&gt;imageBuffer.rowBytes, 
                         imageColorSpaceRef, 
                          imageBitmap-&gt;imageBitmapInfo 
                         );
    
    CGColorSpaceRelease( imageColorSpaceRef );
  } // if

  return  imageContextRef;
} // CGImageBitmapContexMalloc

//------------------------------------------------------------------------

static BOOL CGImageBitmapVerticalReflect( CGImageRef imageRef, CGImageBitmap *imageBitmap )
{
  BOOL          imageBitmapReflected = NO;
  CGContextRef  imageContextRef      = CGImageBitmapContexMalloc( imageBitmap );

  if ( imageContextRef != NULL )
  {
    CGRect imageRect = { { 0, 0 }, { imageBitmap-&gt;imageBuffer.width, imageBitmap-&gt;imageBuffer.height } };

    // The alpha will be added here
    
    CGContextDrawImage( imageContextRef, imageRect, imageRef );
    
    vImageVerticalReflect_ARGB8888( &amp;(imageBitmap-&gt;imageBuffer), &amp;(imageBitmap-&gt;imageBuffer), kvImageNoFlags );

    CGContextRelease( imageContextRef );
    
    imageBitmapReflected = YES;
  } // if bitmap context
  
  return imageBitmapReflected;
} // CGImageBitmapVerticalReflect

//------------------------------------------------------------------------

static CGImageRef CGImageGetFromCGImageBitmap( CGImageBitmap  *imageBitmap )
{
  CGImageRef imageRef = NULL;
  
  // Create a data provider
  
  CGDataProviderRef imageDataProvider = CGDataProviderCreateWithData(  NULL,
                                    imageBitmap-&gt;imageBuffer.data,
                                    imageBitmap-&gt;imageStorageSize,
                                    NULL );
  if ( imageDataProvider != NULL )
  {
    // Create a color space for the image
    
    CGColorSpaceRef imageColorSpace = CGColorSpaceCreateWithName( kCGColorSpaceGenericRGB );

    if ( imageColorSpace != NULL )
    {
      // Create the actual image
      
      GLfloat                  *imageDecode            = NULL;
      bool                      imageShouldInterpolate = true;
      CGColorRenderingIntent    imageRenderingIntent   = kCGRenderingIntentDefault;
      
      imageRef = CGImageCreate(  imageBitmap-&gt;imageBuffer.width,
                    imageBitmap-&gt;imageBuffer.height,
                    imageBitmap-&gt;imageBitsPerComponent,
                    imageBitmap-&gt;imageBitsPerPixel,
                    imageBitmap-&gt;imageBuffer.rowBytes,
                    imageColorSpace,
                    imageBitmap-&gt;imageBitmapInfo,
                    imageDataProvider,
                    imageDecode,
                    imageShouldInterpolate,
                    imageRenderingIntent );

      // the image will retain the data provider &amp; colorspace as needed, so we can release them now
      
      CGColorSpaceRelease( imageColorSpace );
    } //if
    
    CGDataProviderRelease( imageDataProvider );
  } // if
  
  return  imageRef;
} // CGImageGetFromCGImageBitmap

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static NSImage *NSImageGetFromCGImage( CGImageRef imageRef )
{
  NSImage  *image = nil;
  
  if ( imageRef != NULL )
  {
    NSRect imageRect = NSMakeRect(0.0, 0.0, 0.0, 0.0);

    // Get the image dimensions
    
    imageRect.size.height = CGImageGetHeight( imageRef );
    imageRect.size.width  = CGImageGetWidth( imageRef );

    // Create a new image to receive the Quartz image data
    
    image = [[[NSImage alloc] initWithSize:imageRect.size] autorelease]; 
    
    if ( image != nil )
    {
      [image lockFocus];

        // Get the Quartz context and draw
        
        CGContextRef  imageContextRef = (CGContextRef) [[NSGraphicsContext currentContext] graphicsPort];
        
        if ( imageContextRef != NULL )
        {
          CGContextDrawImage( imageContextRef, *(CGRect*)&amp;imageRect, imageRef );
        } // if
        
      [image unlockFocus];
    } // if
  } // if
  
  return image;
} // NSImageGetFromCGImage

//------------------------------------------------------------------------

static NSImage *NSImageGetFromCGImageAddAlphaAndVerticalReflect( CGImageRef imageRefSrc )
{
  NSImage *imageDst = nil;
  
  if ( imageRefSrc != NULL )
  {
    CGImageBitmap  imageBitmap;
    
    if ( CGImageBitmapMalloc( imageRefSrc, &amp;imageBitmap ) )
    {
      if ( CGImageBitmapVerticalReflect( imageRefSrc, &amp;imageBitmap ) )
      {
        CGImageRef  imageRefDst = CGImageGetFromCGImageBitmap( &amp;imageBitmap );
        
        if ( imageRefDst != NULL )
        {
          imageDst = NSImageGetFromCGImage( imageRefDst );
          
          CGImageRelease( imageRefDst );
        } // if
      } // if image vertical reflect
    } // if bitmap data
  } // if image ref
  
  return  imageDst;
} // NSImageGetFromCGImageAddAlphaAndVerticalReflect

//------------------------------------------------------------------------

//------------------------------------------------------------------------

@implementation OpenGLView

//------------------------------------------------------------------------

- (GLdouble) getExhibitChangeInTime:(GLdouble *)theLastTime
{
  GLdouble  deltaTime = 0.0;
  GLdouble  now       = (GLdouble)[NSDate timeIntervalSinceReferenceDate];

  if ( *theLastTime &lt; 0 )
  {
    deltaTime = 0;
  } // if
  else
  {
    deltaTime = now - *theLastTime;
  } // else

  *theLastTime = now;
  
  return  deltaTime;
} // getExhibitChangeInTime

//------------------------------------------------------------------------

- (void) renderExhibit
{
  glPushMatrix( );

    glTranslatef(0.0f, 0.45f, 0.0f);       
    glScalef(0.2f, 0.2f, 0.2f);

    if ( targetExhibit )
    {
      [targetExhibit renderFrame];
    } // if

  glPopMatrix( );
} // renderExhibit

//------------------------------------------------------------------------

- (void) setExhibitPitch
{
  if (pitch &lt; -45.0f)
  {
    pitch = -45.0f;
  } // if
  else if (pitch &gt; 90.0f)
  {
    pitch = 90.0f;
  } // else if

  glRotatef(pitch, 1.0f, 0.0f, 0.0f);
} // setExhibitPitch

//------------------------------------------------------------------------

- (void) setExhibitAngle
{
  if ( !leftMouseIsDown &amp;&amp; !rightMouseIsDown )
  {
    GLdouble deltaTime = [self getExhibitChangeInTime:&amp;lastFrameReferenceTime];

    angle += kViewRotationDegreesPerSecond * deltaTime;
    
    if ( angle &gt;= 360.0f )
    {
      angle -= 360.0f;
    } // if
  } // if
  
  glRotatef( angle, 0.0f, 1.0f, 0.0f );
} // setExhibitAngle

//------------------------------------------------------------------------

-(void) rotateExhibit
{
  glPushMatrix( );
  
    // Constant rotation of the subject
    
    [self setExhibitPitch];
    
    glTranslatef(0.0f, -0.5f, -0.15f);

    [self setExhibitAngle];

    // Draw the exhibit
    
    [self renderExhibit];

  glPopMatrix( );
} // rotateExhibit

//------------------------------------------------------------------------

- (void) setExhibitPrespectiveMatrix:(GLfloat)theWidth  boundsHeight:(GLfloat)theHeight
{
  GLfloat   aspect =  theWidth / theHeight;
  GLdouble  right  =  0.15 * aspect * zoom;
  GLdouble  left   = -right;
  GLdouble  top    =  0.15 * zoom;
  GLdouble  bottom = -top;
  GLdouble  zNear  =  1.0;
  GLdouble  zFar   =  8.0;

  glMatrixMode( GL_PROJECTION );
  
    glLoadIdentity( );
    glFrustum( left, right, bottom, top, zNear, zFar );
    
  glMatrixMode( GL_MODELVIEW );
} // setExhibitPrespectiveMatrix

//------------------------------------------------------------------------

- (void) setExhibitViewport
{
  NSRect   theBounds = [self bounds];
  GLfloat  theWidth  = NSWidth(theBounds);
  GLfloat  theHeight = NSHeight(theBounds);

  [self setExhibitPrespectiveMatrix:theWidth boundsHeight:theHeight];
  
  glViewport( 0, 0, theWidth, theHeight );
} // setExhibitViewport

//------------------------------------------------------------------------

- (void) drawExhibit
{
  [[self openGLContext] makeCurrentContext];
  
  [self setExhibitViewport];

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

  [self rotateExhibit];
} // drawExhibit

//------------------------------------------------------------------------

- (void) updateExhibit
{
  [self drawExhibit];
  [self setNeedsDisplay:YES];
} // updateExhibit

//------------------------------------------------------------------------

- (void) setExhibit: (OpenGLExhibit *) newExhibit
{
  if ( newExhibit ) 
  {
    [targetExhibit release];
    targetExhibit = [newExhibit retain];
  } // if
} // setExhibit

//------------------------------------------------------------------------

-(void) setupOpenGL
{
  OpenGLSetup( GL_FALSE );
} // setupOpenGL

//------------------------------------------------------------------------

- (void) newUpdateTimer
{  
  GLint  swapInterval = 1;
  
  timer = [NSTimer timerWithTimeInterval: kScheduledTimerInSeconds 
            target: self
            selector: @selector(updateExhibit) 
            userInfo: nil
            repeats: YES];
  
  [timer retain];

  [[NSRunLoop currentRunLoop] addTimer: timer forMode: NSDefaultRunLoopMode];
  [[NSRunLoop currentRunLoop] addTimer: timer forMode: NSEventTrackingRunLoopMode];
  
  lastFrameReferenceTime = -1;
  leftMouseIsDown        = NO;
  rightMouseIsDown       = NO;

  angle = 0;
  pitch = 25;
  zoom  = 1;

  // Sync to VBL to avoid tearing.
    
  [[self openGLContext] setValues:&amp;swapInterval forParameter:NSOpenGLCPSwapInterval];
} // newUpdateTimer

//------------------------------------------------------------------------

- (id) initWithFrame:(NSRect)theFrame pixelFormat:(NSOpenGLPixelFormat*)thePixelFormat
{  
  // Create a GL Context to use - i.e. init the superclass
  
  if( thePixelFormat == nil )
  {
    NSOpenGLPixelFormatAttribute pixelAttributes [] 
                        =  {
                            NSOpenGLPFADoubleBuffer,
                            NSOpenGLPFADepthSize, 24,
                            NSOpenGLPFAStencilSize, 8,
                            0
                          };

    CheckForGLSLHardwareSupport( pixelAttributes );
    
    thePixelFormat = [[[NSOpenGLPixelFormat alloc] initWithAttributes: pixelAttributes] autorelease];
  } //  if
    
  if ( ( self = [super initWithFrame:theFrame pixelFormat:thePixelFormat] ) )
  {
    // Basic GL initializations
    
    [[self openGLContext] makeCurrentContext];
    
    [self setupOpenGL];
    
    // Basic initializations
    
    [self setFrameSize:theFrame.size];

    // Create an update timer
    
    [self newUpdateTimer];
    
    // Did the frame change?
    
    [self setPostsFrameChangedNotifications:YES];
  } // if  
  
  return self;
} // initWithFrame

//------------------------------------------------------------------------

- (id)init 
{
    if ( ( self = [super init] ) ) 
  {
    // superclass may return nil
    
        targetExhibit = nil;
    timer         = nil;
    } // if
  
    return self;
} // init

//------------------------------------------------------------------------

- (id) initWithFrame:(NSRect)theFrame
{
  return [self initWithFrame:theFrame pixelFormat:nil];
} // initWithFrame

- (void)update    // moved or resized
{
  [super update];
  [self drawExhibit];
} // update

//------------------------------------------------------------------------

- (void)reshape  // scrolled, moved or resized
{
  [super reshape];
  [self drawExhibit];
} // reshape

//------------------------------------------------------------------------

- (void) dealloc
{
  // Release the update timer
  
  if (timer) 
  {
    [timer invalidate];
    [timer release];
  } // if
  
  //Dealloc the superclass
  
  [super dealloc];
} // dealloc

//------------------------------------------------------------------------

- (void) drawRect: (NSRect) theRect
{
  [[self openGLContext] flushBuffer];
} // drawRect

//------------------------------------------------------------------------

- (void)mouseDown:(NSEvent *)event
{
  lastMousePoint  = [self convertPoint:[event locationInWindow] fromView:nil];
  leftMouseIsDown = YES;
} // mouseDown

//------------------------------------------------------------------------

- (void)rightMouseDown:(NSEvent *)event
{
  lastMousePoint   = [self convertPoint:[event locationInWindow] fromView:nil];
  rightMouseIsDown = YES;
} // rightMouseDown

//------------------------------------------------------------------------

- (void)mouseUp:(NSEvent *)event
{
  leftMouseIsDown = NO;
} // mouseUp

//------------------------------------------------------------------------

- (void)rightMouseUp:(NSEvent *)event
{
  rightMouseIsDown = NO;
} // rightMouseUp

//------------------------------------------------------------------------

- (void)mouseDragged:(NSEvent *)event
{
  if ( [event modifierFlags] &amp; NSRightMouseDown )
  {
    [self rightMouseDragged:event];
  } // if
  else
  {
    NSPoint mouse = [self convertPoint:[event locationInWindow] fromView:nil];

    pitch += lastMousePoint.y - mouse.y;
    angle -= lastMousePoint.x - mouse.x;

    lastMousePoint = mouse;
    
    [self setNeedsDisplay:YES];
  } // else
} // mouseDragged

//------------------------------------------------------------------------

- (void)rightMouseDragged:(NSEvent *)event
{
  NSPoint mouse = [self convertPoint:[event locationInWindow] fromView:nil];

  zoom += 0.01f * (lastMousePoint.y - mouse.y);
  
  if (zoom &lt; 0.05f)
  {
    zoom = 0.05f;
  } // if
  else if (zoom &gt; 2.0f)
  {
    zoom = 2.0f;
  } // else if

  lastMousePoint = mouse;

  [self setNeedsDisplay:YES];
} // rightMouseDragged

//------------------------------------------------------------------------

- (void)pageLayoutDidEnd: (NSPageLayout *)pageLayout returnCode: (int)returnCode contextInfo: (id)printInfo
{
    if(returnCode == NSOKButton) 
  {
        [NSPrintInfo setSharedPrintInfo: printInfo];
    } // if
} // pageLayoutDidEnd

//------------------------------------------------------------------------

- (void)runPageLayout: (id)sender
{
   NSPageLayout  *pageLayout = [NSPageLayout pageLayout];
   NSPrintInfo   *printInfo  = [NSPrintInfo sharedPrintInfo];
   
   [pageLayout beginSheetWithPrintInfo: printInfo
               modalForWindow: [self window]
               delegate: self
               didEndSelector: @selector(pageLayoutDidEnd:returnCode:contextInfo:)
               contextInfo: printInfo];
} // runPageLayout

//------------------------------------------------------------------------

- (void)copyPixelsTo: (GLvoid *)imageData sourceRect:(NSRect)srcRect baseView:(NSView *)view
{  
    NSRect    rect   = NSIntersectionRect([self bounds], srcRect);
  NSPoint   origin = [self convertPoint:rect.origin toView:view];
    GLvoid   *pixels = imageData;

    [self lockFocus];
  
    OpenGLNoError();
    
      glPushAttrib(GL_ALL_ATTRIB_BITS);
      
        glReadBuffer(GL_BACK);
        
        OpenGLDisableCapabilitiesForCopy( );
        
        OpenGLPixelMap( );
        OpenGLPixelStore( &amp;origin, &amp;rect, &amp;srcRect );
        OpenGLPixelTransfer( );
        
        OpenGLReadRGBAPixels( &amp;rect, pixels );
                
      glPopAttrib();
    
    // Get rid of any error, in order to not mislead the rest of the app
    
    OpenGLNoError();
  
    [self unlockFocus];
} // copyPixelsTo

//------------------------------------------------------------------------

- (NSImage *)getImageFromRect:(NSRect)rect
{
   if( NSIsEmptyRect(rect) )
   {
        rect = [self bounds];
   } // if
   
  NSImage *image = nil;
  
  GLuint   imageWidth           = NSWidth( rect );
  GLuint   imageHeight          = NSHeight( rect );
  GLuint   imageSamplesPerPixel = 4;
  GLuint   imageRowBytes        = imageWidth * imageSamplesPerPixel;
  GLuint   imageStorageSize     = imageRowBytes * imageHeight;
  GLvoid  *imageData            = (GLvoid *)malloc( imageStorageSize );

  if ( imageData != NULL )
  {
    // Create a data provider
    
    CGDataProviderRef imageDataProvider = CGDataProviderCreateWithData(  NULL, imageData, imageStorageSize, NULL );
    
    if ( imageDataProvider != NULL )
    {
      // Create a color space for the image
      
      CGColorSpaceRef  imageColorSpace = CGColorSpaceCreateWithName( kCGColorSpaceGenericRGB );

      if ( imageColorSpace != NULL )
      {
        // Create an empty CGImageRef so that we may utilize OpenGL read pixels to copy the
        // pixels from OpenGL view into this newly created CGImageRef
        
        GLuint                    imageBitsPerPixel      = 32;
        GLuint                    imageBitsPerComponent  = 8;
        GLfloat                  *imageDecode            = NULL;
        bool                      imageShouldInterpolate = true;
        CGColorRenderingIntent    imageRenderingIntent   = kCGRenderingIntentDefault;
        CGBitmapInfo              imageBitmapInfo        = kCGImageAlphaNone; // For now RGB; but later we'll fix the alpha
      
        CGImageRef imageRef = CGImageCreate(  imageWidth,
                            imageHeight,
                            imageBitsPerComponent,
                            imageBitsPerPixel,
                            imageRowBytes,
                            imageColorSpace,
                            imageBitmapInfo,
                            imageDataProvider,
                            imageDecode,
                            imageShouldInterpolate,
                            imageRenderingIntent );

        
        if ( imageRef != NULL )
        {
          [self copyPixelsTo:imageData sourceRect:rect baseView:self];
          
          // Get an NSImage from CGImageRef, add alpha (RGBA from RGB) and
          // vertically reflect the image
          
          image = NSImageGetFromCGImageAddAlphaAndVerticalReflect( imageRef );
          
          CGImageRelease( imageRef );
        } // if
        
        CGColorSpaceRelease( imageColorSpace );
      } //if
      
      CGDataProviderRelease( imageDataProvider );
    } // if
  } // if
  
  return  image;
} // getImageFromRect

//------------------------------------------------------------------------

- (void)print:(id)sender
{
  NSImage      *tiffImage = [self getImageFromRect:[self bounds]];
    NSImageView  *imageView = [[[NSImageView alloc] initWithFrame:[self bounds]] autorelease];
  
    [imageView setImage: tiffImage];
    
    if( imageView &amp;&amp; tiffImage ) 
  {
        // setup some reasonable state for GL printing. To get better output results,
    // fine tune this section of the code for better scaling.
    
        NSPrintInfo *printinfo = [NSPrintInfo sharedPrintInfo];
    
        [printinfo setHorizontalPagination: NSAutoPagination];
        [printinfo setVerticalPagination: NSAutoPagination];
        [printinfo setTopMargin: 0.0f];
        [printinfo setBottomMargin: 0.0f];
        [printinfo setRightMargin: 7.0f];
        [printinfo setLeftMargin: 7.0f];
    
        if ([imageView bounds].size.height &lt; [imageView bounds].size.width)
    {
            [printinfo setOrientation: NSLandscapeOrientation];
    } // if
        else
    {
            [printinfo setOrientation: NSPortraitOrientation];
    } // else
    
        // print imageView
    
        NSPrintOperation *printOperation = [NSPrintOperation printOperationWithView: imageView printInfo: printinfo];
    
        [printOperation  runOperationModalForWindow: [self window]
                        delegate: nil
                        didRunSelector: nil
                        contextInfo: nil];
    } // if
  else
  {
        NSRunCriticalAlertPanel(@&quot;Print Error&quot;,@&quot;Could not generate image data for printing.&quot;, @&quot;OK&quot;, nil, nil);
    } // else
} // sender

//------------------------------------------------------------------------

@end

//------------------------------------------------------------------------

//------------------------------------------------------------------------

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GLSLShowpieceLite/listing66.html%3Fid%3DDTS10004295-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GLSLShowpieceLite/listing66.html%3Fid%3DDTS10004295-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GLSLShowpieceLite/listing66.html%3Fid%3DDTS10004295-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>