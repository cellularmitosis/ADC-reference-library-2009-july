<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note FL510: File Manager Directory Handling Q&amp;As</title><meta name="keywords" content="Mac OS 8 File Manager desktop Working directory ID fBsyErr"><meta name="Description" content="Technical Note FL510: This Technical Note contains a collectionof archived Q&amp;As relating to File Manager Directory Handling--questionssent the Developer Support Center (DSC) along with answersfrom the DSC engineers. Archived questions include: How toget the list of mounted volumes and their icons located onthe DeskTop; System 7 and the copy-protect bit; How persistentdo Directory IDs have to be and how to get the ID from thefile pathname; Why using PBHDelete on a directory may returna fBsyErr; How to get HFS directories from full pathnames;How to detect PBCatSearch support; and How to distinguishbetween HFS and MFS calls.">                                       <meta name="categories" content="Files"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002465" title="File Manager Directory Handling Q&As"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxFileManagement-date.html" target="_blank">Carbon > File Management</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note FL510</div>
<div id="pageheadsub">File Manager Directory Handling Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Implementing Macintosh System 7 desktop button</a><BR><BR><A HREF="#Section2">System 7 and copy-protect bit</a><BR><BR><A HREF="#Section3">How persistent must Macintosh directory IDs be?</a><BR><BR><A HREF="#Section4">Getting folder directory ID based on path name or parent folder</a><BR><BR><A HREF="#Section5">PBHDelete insights and code snippet</a><BR><BR><A HREF="#Section6">Working directories and WDRefNum</a><BR><BR><A HREF="#Section7">Getting HFS directories from full pathnames</a><BR><BR><A HREF="#Section8">How a new Macintosh directory ID is determined</a><BR><BR><A HREF="#Section9">Changing a file's fork without changing last-modified date</a><BR><BR><A HREF="#Section10">Code for detecting PBCatSearch support</a><BR><BR><A HREF="#Section11">PBHGetDirAccess ioNamePtr (not ioFileName) &amp; ioDirID params</a><BR><BR><A HREF="#Section12">PBGetCatInfo NIL ioNamePtr bug and workaround</a><BR><BR>      <A HREF="#Section13">Forcing the Macintosh system to switch-launch</a><BR><BR>      <A HREF="#Section14">How can I tell which directory my Macintosh application is in?</a><BR><BR>      <A HREF="#Section15">Assembler code for distinguishing between HFS and MFS calls</a><BR><BR>        <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id ="introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specific topic--questions sent the Developer Support Center (DSC) along withanswers from the DSC engineers. Current Q&amp;As can be found on the <a href="../../qa/index.html">Macintosh Technical Q&amp;As web site</a>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><a name="Section1"></a><P><A HREF="#top">Back to top</A></P><h2>Implementing Macintosh System 7 desktop button</h2><p>Date Written:  6/22/92</p><p>Last reviewed: 6/14/93</p><p>We would like to know how to implement a desktop button under System 7 in adialog other than the standard system Open dialog. Is there an easy way to findthe mounted volumes and their icons and the files that are located on the desktop?</p><p>___</p><p>The items shown at the desktop level by Standard File are the mounted volumesand all items inside the invisible directory named Desktop Folder at the rootof the volume. You can find out what items are in the desktop folder by using<code>PBGetCatInfo</code> to enumerate the items in that directory. (For sample code showingthe basic technique of indexing through the entries in a directory, see theMacintosh Technical Note "Searching All Directories on an HFS Volume.")</p><p>To get a list of volumes, you need to index through the list of volumes with<code>PBHGetVInfo</code>. The snippet code below shows how to do that. To get the iconassociated with a specific volume, you need to make control call #21 to thevolume's disk driver as documented on page V-470 of <i>Inside Macintosh</i>Volume V. The function <code>GetDiskDriverInfo</code> below shows the proper way to make thecontrol call and safely return the icon and where string (the string that showswhere a volume is in the Finder's Get Info dialog box).</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION GetDiskDriverInfo (driveNumber: Integer;                                driverRefNum: Integer;                                VAR iconHandle: Handle;                                VAR whereString: Str255): OSErr;VAR    err: OSerr;    pb: ParamBlockRec;BEGIN    iconHandle := NewHandle(kLargeIconSize);    IF iconHandle = NIL THEN        BEGIN    { bail out if memory couldn't be allocated }            GetDiskDriverInfo := MemError;            Exit(GetDiskDriverInfo);        END;    { get the disk driver info }    WITH pb DO        BEGIN            ioVRefNum := driveNumber;            ioRefNum := driverRefNum;            csCode := 21;        END;    err := PBControlSync(@pb);    IF err = noErr THEN        BEGIN    { no error? then return the info }            { move the icon into it }            BlockMove(pb.ioMisc, iconHandle^, kLargeIconSize);            { copy where information string into a string variable }            whereString := StringPtr(ORD4(pb.ioMisc) + $100)^;        END    ELSE        BEGIN    { error? then clean up and return no info }            DisposHandle(iconHandle);            iconHandle := NIL;            whereString := '';        END;    GetDiskDriverInfo := err;END;Here's how you index through the list of volumes to get their names andhow to call the GetDiskDriverInfo function above to get the icon and"where" string.VAR    hPB: HParamBlockRec;    err: OSerr;    dErr: OSErr;    index: Integer;    gVolName: Str255;    gIconHandle: Handle;    gWhereString: Str255;BEGIN    index := 1;    REPEAT        WITH hPB DO            BEGIN                ioNamePtr := @gVolName;                ioVolIndex := index;            END;        err := PBHGetVInfoSync(@hPB);        IF err = noErr THEN            BEGIN                dErr := GetDiskDriverInfo(hPB.ioVDrvInfo, hPB.ioVDRefNum,                                          gIconHandle, gWhereString);                IF dErr = noErr THEN                    BEGIN               { Do something with the volume name, icon, and where string. }               { Don't forget to dispose the gIconHandle handle when you're }               { done with the icon. }                    END;            END;        index := index + 1;    UNTIL err &lt;&gt; noErr;END.</pre>	</TD></TR></TABLE></CENTER><p>If you want to get fancy, you can use the custom icon attacted to some files(for example, alias files to AppleShare volumes). Chapter 9 of <i>InsideMacintosh</i> Volume VI talks about custom icons and alias files on pages 9-28through 9-32. You can tell if a file or directory has a custom icon by lookingat the <code>hasCustomIcon</code> bit in the <code>fdFlags</code> word of the <code>FInfo</code> record returned by<code>PBGetCatInfo</code> (which you call to build the list of files and folders).</p><a name="Section2"></a><P><A HREF="#top">Back to top</A></P><h2>System 7 and copy-protect bit</h2><p>Date Written:  4/26/90</p><p>Last reviewed:  6/14/93</p><p>I need to prevent users from copying my application off a volume. Is there anew equivalent of the old Bozo bit?</p><p>___</p><p>The Bozo or <code>NoCopy</code> bit was bit 11 in the <code>fdFlags</code> word of the <code>FInfo</code> record. Asnoted in the Macintosh Technical Note "Finder Flags," this bit hasn't been usedfor that purpose since System 5. In fact, System 7 reused bit 11 for the<code>isStationery</code> bit. (See <i>Inside Macintosh</i> Volume VI, pages 9-36 and 9-37,for the current list of Finder flag bits.)</p><p>There isn't an equivalent of the Bozo bit. However, the System 7 Finder won'tcopy files that have the copy-protect bit (bit 6) set in the <code>ioFlAttrib</code> fieldreturned by the <code>PBGetCatInfo</code> function. However, the bits in the <code>ioFlAttrib</code>field can't be changed with the <code>PBSetCatInfo</code> function. Instead, they're used toreport the state of things set by other parts of the file system.</p><p>The copy-protect bit is set by the AppleShare external file system when itfinds that a file's copy-protect bit is returned by an AppleTalk FilingProtocol file server. The AppleShare external file system is the only filesystem we know of that sets the copy-protect bit. There's no way to make thelocal file system set the copy-protect bit for volumes it controls.</p><a name="Section3"></a><P><A HREF="#top">Back to top</A></P><h2>How persistent must Macintosh directory IDs be?</h2><p>Date Date Written:  8/28/92</p><p>Last reviewed:  11/1/92</p><p>How persistent must directory IDs be? In our external file system, directoryIDs are generated starting from <code>fsRtDirID</code> whenever a volume is mounted. Whenone of our volumes is unmounted and then remounted without rebooting the Macintosh in between, the Finder immediately does a <code>GetCatInfo</code> specifying a directory ID (5, I think it's looking for the Trash folder). This would imply that directory IDs need to persist across dismounts. Is this the case? Is there any way to get the Finder to forget the directory IDs it has stored, besides rebooting?</p><p>___</p><p>The Macintosh file system only expects directory ID numbers to be fixed whilethe volume is mounted.</p><p>However, other parts of the Macintosh operating system (for example, the AliasManager and the Finder) and applications expect directory IDs to persist between volume mounts so that they can find a particular directory when a volume is remounted. For example, under System 6, the correct way to store the location of a file is by saving the volume name, the volume's creation date (to help find the volume in the case where it is renamed), and the parent directory ID number. The Alias Manager under System 7 (and under System 6 when QuickTime is installed) uses the same technique when it creates an alias to a file or directory.</p><p>The Finder keeps the directory ID numbers of the directories it can find withthe FindFolder function in the volume's FndrInfo record, so that's why you'reseeing the Finder look for a particular directory ID.</p><a name="Section4"></a><P><A HREF="#top">Back to top</A></P><h2>Getting folder directory ID based on path name or parent folder</h2><p>Date Written:  4/26/90</p><p>Last reviewed:  6/14/93</p>Is there any Macintosh routine that gets the directory ID of a folder based on<p>the path name? How about if I know the parent folder's directory ID?</p><p>___</p><p>You can call <code>PBGetCatInfo</code> with <code>ioFDirIndex</code> set to zero to get the directory IDof a folder based on the path name. Call <code>PBHGetVInfo</code> to find its <code>vRefNum</code>.</p><p>You can also call <code>PBGetCatInfo</code> to get a folder's dirID based on its name andits parent's <code>dirID</code> and <code>vRefNum</code>.  Here's an example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>{ given a folder's name, vRefNum, and parent dirID, find its dirID }FUNCTION GetFolderDirID (parentFolderVRefNum: Integer;                         parentFolderDirID: LongInt; folderName: Str63;                         VAR folderDirID: LongInt): OSErr;  VAR    myCInfoPBRec: CInfoPBRec;    retCode: OSErr;  BEGIN    myCInfoPBRec.ioCompletion := NIL;    myCInfoPBRec.ioNamePtr := @folderName;    myCinfoPBRec.ioVRefNum := parentFolderVRefNum;    myCInfoPBRec.ioFDirIndex := 0; { use name, vRefNum, dirID }    myCInfoPBRec.ioDrDirID := parentFolderDirID; { will be changed }    retCode := PBGetCatInfoSync(@myCInfoPBRec); { IM IV-155 }    IF retCode = noErr THEN folderDirID := myCInfoPBRec.ioDrDirID;    GetFolderDirID := retCode;  END;</pre>	</TD></TR></TABLE></CENTER><a name="Section5"></a><P><A HREF="#top">Back to top</A></P><h2>PBHDelete insights and code snippet</h2><p>Date Written:  11/28/90</p><p>Last reviewed:  2/8/91</p><p>Using a synchronous call to delete an empty Macintosh directory using <code>PBHDelete</code>returns a <code>fBsyErr</code>.</p><p>___</p><p>I don't know exactly what is causing the <code>fBsyErr</code> on your machine, but here's mybest guess: The reason you are experiencing this problem is that something hasset a working directory to the one you're trying to delete. I was able to getthis to happen by setting the current directory in MPW to "foo:temp:" and thentrying to delete it. The bad news is that you can't close another process'sworking directory. There will be cases where your application won't be able todelete the directory until the user resets the default directory in the offending application. Such are the perils of working in a multitasking environment....</p><p>Also, I would suggest using a routine like the one included below. It ensuresthat the specified file is in fact a directory, and supplies a <code>vRefNum</code> andDirID to <code>PBHDelete</code>, which I feel is safer than just giving a full pathname.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/*****        DirDelete.c****            An MPW tool to delete a directory.**            Gets the target file from the command line.****            Neil Day**            MacDTS**            Apple Computer, Inc.**            11/29/90***/#include     &lt;Stdio.h&gt; /* compiler interfaces */#include     &lt;Files.h&gt;#include     &lt;Memory.h&gt;#include    &lt;Strings.h&gt;#define        DIR_BIT        4OSErr DirDelete (char *dirName); /* function prototypes */main (argc,argv)int argc;char **argv;{    int argCounter;    OSErr err;    if (argc &lt; 2) {        printf ("Format :  DirDelete &lt;file1&gt; [&lt;file2&gt;        ...  &lt;fileN&gt;]\n");        return;    }    for (argCounter = 1; argCounter &lt; argc; argCounter++) {        printf ("%s\n",argv[argCounter]);        err = DirDelete (argv[argCounter]);        if (err)            printf ("DirDelete :  got error %d while trying to            remove %s\n",                        err,argv[argCounter]);    }}/***   DirDelete**     Deletes a directory given the full pathname to the directory.****     Uses PBGetCatInfo to retrieve the vRefNum and DirID of the directory**     and its status flags.  Checks to see that the specified file is**     in fact a directory, and deletes it if it is...***/OSErr DirDelete (dirName)char *dirName;{    OSErr err;    CInfoPBPtr Info;    HParmBlkPtr delete_me;    err = noErr;    Info = (CInfoPBPtr) NewPtrClear (sizeof(CInfoPBRec));    Info-&gt;hFileInfo.ioNamePtr = c2pstr(dirName);    delete_me = (HParmBlkPtr) NewPtrClear (sizeof (HParamBlockRec));    err = PBGetCatInfo (Info,false);    if ((!err) &amp;&amp; ((Info-&gt;hFileInfo.ioFlAttrib&gt;&gt;DIR_BIT)        &amp; 0x01)) {        delete_me-&gt;fileParam.ioVRefNum = Info-&gt;hFileInfo.ioVRefNum;        delete_me-&gt;fileParam.ioDirID = Info-&gt;hFileInfo.ioDirID;        err = PBHDelete (delete_me,false);    }    DisposPtr ((Ptr)Info);    DisposPtr ((Ptr)delete_me);    return err;</pre>	</TD></TR></TABLE></CENTER><a name="Section6"></a><P><A HREF="#top">Back to top</A></P><h2>Working directories and WDRefNum</h2><p>Date Written:  12/13/90</p><p>Last reviewed:  6/14/93</p><p>How do I get the directory ID when using <code>HCreateResFile</code> (as described in theMacintosh Technical Note <u><A HREF = "../tb/tb_16.html">"New Resource Manager Calls."</a></u> Also, what exactly are working directories, and do I need to be concerned with them, or are they athing of the past?</p><p>___</p><p>The directory ID comes indirectly from the Standard File dialogue that the useruses to select an output or input file. Standard File returns a workingdirectory reference number in the <code>ioVRefNum</code>. Use the <code>PBGetWDInfo</code> call to breakthat up into an <code>ioVRefNum</code> and <code>ioDirID</code> pair.</p><p>Working directories are a compatibility item to allow programs written for MFSto run under HFS. Since MFS didn't support directories in any true sense, HFSneeded to be able to encode both volume and directory information in the sameplace. The vRefNum was the most logical spot to do that, and hence the <code>WDRefNum</code>was born. The first and last thing you should do with a <code>WDRefNum</code> is convert itto a <code>vRefNum</code> and <code>DirID</code> pair. For more information on the <code>PBGetWDInfo</code> call,please refer to <i>Inside Macintosh</i> Volume IV, page 159.</p><p>X-Ref:</p><p>DTS Macintosh Technote "New Resource Manager Calls"</p><p><i>Inside Macintosh </i>Volume IV, File Manager chapter, page 159</p><a name="Section7"></a><P><A HREF="#top">Back to top</A></P><h2>Getting HFS directories from full pathnames</h2><p>Date Written:  12/21/90</p><p>Last reviewed:  1/16/91</p><p>How can I determine Macintosh HFS directories from the full pathnames withoutgoing through <code>SFGetFile</code> or opening files?</p><p>___</p><p>Apple recommends not using full pathnames. They're unwieldy, they take up lotsof space, the File Manager doesn't deal with names longer than 255 characters,and they're unnecessary.</p><p>However, if you are working with a piece of software other than your own, itmay be unavoidable. If so, there are two methods depending on the size of thefull pathname: </p><p>1. If the full pathname is less than 255 characters, simply get the dirID ofthe directory by calling <code>PBGetCatInfo</code>.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    VAR            pbc:          CInfoPBRec;    BEGIN            name := 'Chinese Junk:Test:VMCalls:';            WITH pbc DO BEGIN                ioCompletion := NIL;                ioNamePtr := @name;                ioVRefNum := 0;                ioFDirIndex := 0;                ioDrDirID := 0;            END;            err := PBGetCatInfo(@pbc, FALSE);</pre>	</TD></TR></TABLE></CENTER><p>This will return to you the dirID of the folder in <code>ioDrDirID</code>.</p><p>2. If the full pathname is longer than 255 characters, you will have to breakup the name into smaller parts and get information incrementally. This is shownbelow. Note that this example is not quite realistic since I store the originalfull pathname in a Pascal string, which will always be smaller than 255 characters.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>VAR        pbc:                CInfoPBRec;        pbh:                HParamBlockRec;        name:               Str255;        tempname:           Str255;        vRefNum:            Integer;        dirID:              LONGINT;        done:               Boolean;        lastPos:            Integer;        curPos:             Integer;BEGIN        name := 'Chinese Junk:Test:VMCalls:';        tempname := name; {PBHGetVInfo modified ioNamePtr string,        so copy it}        WITH pbh DO BEGIN            ioCompletion := NIL;            ioNamePtr := @tempname;            ioVRefNum := 0;            ioVolIndex := 0;        END;        err := PBHGetVInfo(@pbh, FALSE);        vRefNum := pbh.ioVRefNum; {get vRefNum for PBGetCatInfo calls}        dirID := 0; {init dirID to zero}        done := FALSE;        lastPos := 1;        REPEAT            curPos := lastPos; {look for the next chunk surrounded            by colons}            REPEAT                curPos := curPos + 1;                done := curPos &gt;= LENGTH(name);            UNTIL (name[curPos] = ':') | (done);            tempname := Copy(name, lastPos, curPos - lastPos + 1);            lastPos := curPos;            WITH pbc DO BEGIN                ioCompletion := NIL;                ioNamePtr := @tempname;                ioVRefNum := vRefNum;                ioFDirIndex := 0;                ioDirID := dirID;            END;            err := PBGetCatInfo(@pbc, FALSE);            dirID := pbc.ioDrDirID; {get this dirID to use a parent                                     for next chunk}            Writeln('err = ', err);            Writeln('tempName = ', tempname);            Writeln('ioVRefNum = ', pbc.ioVRefNum);            Writeln('ioDrDirID = ', pbc.ioDrDirID);            Writeln('ioDrParID = ', pbc.ioDrParID);        UNTIL done;END.This will give you the following output:    err =        0    tempName = Chinese Junk:    ioVRefNum =       -2    ioDrDirID =        2    ioDrParID =        2    err =        0    tempName = :Test:    ioVRefNum =       -2    ioDrDirID =      271    ioDrParID =        2    err =        0    tempName = :VMCalls:    ioVRefNum =       -2     &lt;--- this is the vRefNum you want    ioDrDirID =    26399     &lt;--- this is the dirID you want    ioDrParID =      271</pre>	</TD></TR></TABLE></CENTER><a name="Section8"></a><P><A HREF="#top">Back to top</A></P><h2>How a new Macintosh directory ID is determined</h2><p>Date Written:  1/24/91</p><p>Last reviewed:  2/14/91</p><p>Our Macintosh application moves files between directories on a file system; thedirectories determine certain actions and are seldom changed; thus, theapplication keeps a persistent reference to the directories. The current formof this reference is &lt;volume name, path from root&gt;. According to a System7 lecture, the preferred form for a persistent file reference is &lt;volumename, directory ID, filename&gt;, which reduces to &lt;volume name, directoryID&gt;, the preferred form for a persistent directory reference. The process ofthrowing folders away and creating new ones could result in a directory IDbeing reused on an HFS volume. Is this truly a threat, or has the directoryallocation scheme been designed to require many transactions before reusing an ID?</p><p>___</p><p>You are correct in your assumption that many transactions need to take placebefore a directory ID gets reused. The system does not start with dir ID = 0and search the hard disk until it finds an ID that's not used. Instead, the IDof the last created folder is in a "last created ID" field on the disk. Whenthe system creates a new folder, it searches with that "last value" + 1. Sincethese are 32-bit values, you'd have to create over 4 billion folders before youwrap around again to zero.</p><a name="Section9"></a><P><A HREF="#top">Back to top</A></P><h2>Changing a file's fork without changing last-modified date</h2><p>Date Written:  7/9/91</p><p>Last reviewed:  6/14/93</p><p><i>Inside Macintosh</i> Volume VI, page 2-22, recommends updating the windowpositions in a file without changing the last modification date and time on thefile. How do I alter a file without automatically changing the timestamp?</p><p>___</p><p>To modify the contents of a file's data or resource fork without changing thelast modified date, get the modified date before performing any save operationson the file and restore it when you're done. You can use the <code>PBHGetFInfo</code> and<code>PBHSetFInfo</code> calls to do this. A short Pascal snippet that modifies the contentsof a known file's resource fork without modifying its modification date isshown below. The code shows how the parameter block is filled in with thefile's information at the start of the routine with a <code>PBHGetFInfo</code> call, and thesame data is then used without modification to set the file information at theend of the routine with a <code>PBHSetFInfo</code>. <i>Inside Macintosh</i> Volume IV, page150, tells you which fields can be changed with <code>PBHSetFInfo</code>.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Procedure DummyResource;var    a:stringHandle;    b:Integer;    fred:str255;    theBlock:HParamBlockRec;    anErr:OSErr;begin  {Set up the parameter block}  fred:='anIcon';  theBlock.ioCompletion:=nil;  theBlock.ioNamePtr:=@Fred;  theBlock.ioVRefNum:=0;  theBlock.ioFDirIndex:=0;  theBlock.ioDirID:=0; {Recover the files info to save the mod date}  anErr:=PBHGetFInfo(@theBlock,false); {modify the resource fork}  b:=OpenResFile('anIcon');  a:=StringHandle(GetResource('STR ',128));  a^^[1]:=char(ord(a^^[1])+1);  ChangedResource(Handle(a));  UpdateResFile(b);  CloseResFile(b); {Now restore the original last mod date in the files directory entry.}  theBlock.ioCompletion:=nil;  theBlock.ioNamePtr:=@Fred;  theBlock.ioVRefNum:=0;  theBlock.ioFDirIndex:=0;  theBlock.ioDirID:=0;  anErr:=PBHSetFInfo(@theBlock,false);end;</pre>	</TD></TR></TABLE></CENTER><a name="Section10"></a><P><A HREF="#top">Back to top</A></P><h2>Code for detecting PBCatSearch support</h2><p>Date Written:  9/26/91</p><p>Last reviewed:  10/15/91</p><p>Our code for volume searching using <code>PBCatSearch</code> doesn't work for AppleSharevolumes. Do you know how we can make it work?</p><p>___</p><p><code>PBCatSearch</code> works only on volumes that support it. If you attempt to use<code>PBCatSearch</code> on a volume that doesn't support it, you'll get a <code>wrgVolTypErr</code>(-123). (This isn't documented in <i>Inside Macintosh</i> Volume VI.)</p><p>AppleShare 2.0 volumes (AppleShare 2.0 is an AFP 2.0 server) and volumessupported by some other external file systems do not support <code>PBCatSearch</code>, soyou'll have to resort to recursively searching the catalog using a routinesimilar to the one shown in the Macintosh Technical Note "SearchingVolumes--Solutions and Problems" on those volumes. <code>PBCatSearch</code> is supported byAppleShare volumes on System 7 File Sharing servers because File Sharingsupports AFP version 2.1 which includes <code>CatSearch</code> as a supported command.</p><p>You can use the File Manager call <code>PBHGetVolParms</code> to check a volume for mostvolume-specific features, including support for <code>PBCatSearch</code>. Here's a shortfunction that shows how to do that:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION CatSearchable (vRefNum: Integer): Boolean;{See if PBCatSearch is supported on the volume specified by vRefNum}  VAR    pb: HParamBlockRec;    infoBuffer: GetVolParmsInfoBuffer;    err: OSErr;BEGIN  WITH pb DO    BEGIN      ioNamePtr := NIL;      ioVRefNum := vRefNum;      ioBuffer := @infoBuffer;      ioReqCount := SizeOf(infoBuffer);    END;  err := PBHGetVolParms(@pb, FALSE);  IF err = noErr THEN    IF BTst(infoBuffer.vMAttrib, bHasCatSearch) THEN      CatSearchable := TRUE    ELSE      CatSearchable := FALSE  ELSE    CatSearchable := FALSE;END;</pre>	</TD></TR></TABLE></CENTER><a name="Section11"></a><P><A HREF="#top">Back to top</A></P><h2>PBHGetDirAccess ioNamePtr (not ioFileName) &amp; ioDirID params</h2><p>Date Written:  12/20/91</p><p>Last reviewed:  6/14/93</p><p>Two <code>PBHGetDirAccess</code> parameters listed in <i>Inside Macintosh</i> Volume V, pageV-394, <code>ioFileName</code> and <code>ioDirID</code>, aren't in the MPW C 3.2 header files. Can anyoneshow me the correct way to call this function?</p><p>___</p><p>The ioFileName parameter is really <code>ioNamePtr</code> (<i>Inside Macintosh</i> Volume Vdocumentation error) and can be found in the <code>ParamBlockHeader</code>. The ioDirIDparameter is in the <code>FileParam</code> variant of the <code>ParamBlockRec</code>, so if you justrefer to it as <code>myHParamBlockRec.ioDirID</code>, you should be fine. You'll findsimilar cases in the C include files where you'll need to use two differentvariants to get to all the fields used by a call.</p><a name="Section12"></a><P><A HREF="#top">Back to top</A></P><h2>PBGetCatInfo NIL ioNamePtr bug and workaround</h2><p>Date Written:  3/6/92</p><p>Last reviewed:  6/14/93</p><p>I'm using <code>PBGetCatInfo</code> to index through the entries in a directory. Because I'mnot interested in the names of the directory entries, I set <code>ioNamePtr</code> to NIL.Everything worked great until I tried this on a volume shared with MacintoshFile Sharing. After running my program on a shared volume, the system startedacting unpredictably. What happened?</p><p>___</p><p>The problem you reported with <code>PBGetCatInfo</code> is caused by a bug in the MacintoshFile Sharing code. It doesn't check for a NIL value in <code>ioNamePtr</code> correctly and<i>always</i> copies the file or folder name found at a particular catalogposition to whatever <code>ioNamePtr</code> points to. This means up to 32 bytes starting atlocation 0 will be trashed if <code>ioNamePtr</code> = NIL. So until this problem is fixed,you should avoid using indexed calls to <code>PBGetCatInfo</code> when <code>ioNamePtr</code> = NIL;<code>ioNamePtr</code> should always point to storage for a Str255.</p><p>The AppleShare 3.0 file server does not have this problem, nor does System 7.1Macintosh File Sharing.</p><a name="Section13"></a><P><A HREF="#top">Back to top</A></P><h2>Forcing the Macintosh system to switch-launch</h2><p>Date Written:  11/21/89</p><p>Last reviewed:  11/21/90</p><p>How can I get my Macintosh application to force the system to switch to theapplication's disk when the user launches it, like Installer does?</p><p>___</p><p>This is called switch-launching. You can do what Installer does, setting aFinder flag that tells Finder to switch-launch to the new volume. Set this flagwith ResEdit by selecting the application, selecting Get Info from the File menu, then setting the appropriate checkbox. You can also set this with the MPW command:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    SetFile -a A foo</pre>	</TD></TR></TABLE></CENTER><p>Note that forcing a switch-launch in this way <i>never</i> works if any of thefollowing conditions are true:</p><p>* The new volume is not bootable--that is, has no system or Finder or is avolume like an AppleShare volume;</p><p>* MultiFinder is running;</p><p>* Either the system or Finder on the new volume is an older version than theone currently in use.</p><p>If any of these conditions are true and you try to force a switch-launch, theuser will get a dialog stating why switch-launching is not possible, and askingif the user wants to proceed with the launch (without the switch) or cancel it.</p><p>Because of these limitations, if you plan for your application to be used byothers and you depend on this capability, you need to think carefully about theconsequences of forcing switch-launching. For example, a user may (and probablywill) choose to run MultiFinder. There is no way for you to know if MultiFinderis running, and if you are depending on the switch, strange things may happen.Switch-launching may be even more restricted in the future.</p><p>X-Ref:</p><p>Macintosh Technical Note "Finder Flags"</p><a name="Section14"></a><P><A HREF="#top">Back to top</A></P><h2>How can I tell which directory my Macintosh application is in?</h2><p>Date Written:  5/3/89</p><p>Last reviewed:  11/21/90</p><p>How can I tell which directory my Macintosh application is in?</p><p>___</p><p>When an application is started, the default volume is set to the directory thatcontains the application. <code>GetVol</code> returns the default volume. If the applicationcalls <code>GetVol</code> before changing the default volume, it will have the directory forthe folder containing the application.</p><a name="Section15"></a><P><A HREF="#top">Back to top</A></P><h2>Assembler code for distinguishing between HFS and MFS calls</h2><p>Date Written:  3/9/92</p><p>Last reviewed:  6/14/93</p><p>I'm trying to patch the Macintosh <code>_Create</code> trap and save off the volume anddirectory ID of the file that is being created. How do I tell if the caller hasplaced a <code>HParamBlkPtr</code> or a <code>ParamBlkPtr</code> in A0 so I'll know whether to treat theioDirID element as significant?</p><p>___</p><p>When you're called from the trap dispatcher, the trap word you're being calledwith is placed in register D1. Since HFS calls can be distinguished from MFScalls by bit 9 being set in the trap word, you can simply see if this bit isset in D1 to determine whether the call is using an <code>HParamBlkPtr</code>. Here's anexample in 68000 of how you could check this bit:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>createPatch movem.l a0/d0-d1,-(sp) ; save registers            move.l  d1,d0            andi.w  #$0200,d0            beq.s   isCreateisHCreate   ...            ...            bra.s   doneisCreate    ...            ...done        movem.l  (sp)+,a0/d0-d1            move.l  createLink,-(sp)            rts</pre>	</TD></TR></TABLE></CENTER><p>Besides checking HFS vs. MFS, you can also use D1 to determine whether or notthe call was made asynchronously by checking bit 10 of D1.</p><P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (84K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/fl_510.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/fl/fl_510.html%3Fid%3DDTS10002465-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/fl/fl_510.html%3Fid%3DDTS10002465-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/fl/fl_510.html%3Fid%3DDTS10002465-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>