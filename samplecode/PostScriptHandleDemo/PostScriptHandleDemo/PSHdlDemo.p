{	File:		PSHdlDemo.p	Contains:	PSHdlDemo demonstrates how to use PostScriptHandle to send PostScript	 			from a text file to the printer.	Written by: Dave Hersey		Copyright:	Copyright © 1992-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/26/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				}PROGRAM PSHdlDemo;USES	Memory, QuickDraw, ToolUtils, Traps, Printing, Packages, PrintComments,StandardFile,Fonts,Events;{*------ SendPostScript ------------------------------------------------------------*}PROCEDURE SendPostScript(theBuffer: Ptr; buffSize : Longint);VAR    dataHdl		: Handle;    err			: OSErr;	BEGIN    	err := PtrToHand(theBuffer, dataHdl, buffSize);    IF (err = noErr) THEN	BEGIN		PicComment(PostScriptHandle, buffSize, dataHdl);    	DisposeHandle(dataHdl);	END;END;{*------ DrawStuff -----------------------------------------------------------------*}{** **  	DrawStuff will open up a text document and send it to the printer **  	as PostScript.  Hopefully, the text WILL BE PostScript! **} PROCEDURE DrawStuff(theFile: SFReply); CONST	fourK	= 4 * 1024;  VAR   	bytesToRead	, amtToRead	: Longint;	theBuffer				: Ptr;	err						: OSErr;	refNum					: Integer;      	postStr					: Str255;    BEGIN	{ Set up a clipping region.  Unless we do some QuickDraw, no clipping region will	  be set up and everything will be clipped, giving us a blank page. }	PenSize(0, 0);	MoveTo(0, 0); 	Line(0, 0);	PenSize(1, 1);		{ Set up the normal PostScript translation/rotation factors.  the Printing Manager	  changes these to match QuickDraw, and if we're just using straight PostScript,	  that will mess us up.}	postStr := '0 728 translate 1 -1 scale ';	SendPostScript(@postStr[1], Longint(postStr[0]));	{ Open our file, and determine its length. }	err := FSOpen(theFile.fName, theFile.vRefNum, refNum);	IF (err = noErr) THEN		err := GetEOF(refNum, bytesToRead);		{ Read in its contents and send it to the printer using PostScriptHandle.	  We read the data in in 4K blocks, because the driver will break it	  down to that size anyway. }	theBuffer := NewPtr(fourK);		WHILE ((err = noErr) AND (bytesToRead <> 0)) DO	BEGIN				IF bytesToRead > fourK THEN			amtToRead := fourK		ELSE		BEGIN			amtToRead := bytesToRead;			SetPtrSize(theBuffer, amtToRead);		END;				err := FSRead(refNum, amtToRead, theBuffer);				IF (err = noErr) THEN		BEGIN			bytesToRead := bytestoRead - amtToRead;			SendPostScript(theBuffer, amtToRead);		END;		END;		err := FSClose(refNum);	 END;  {**  DrawStuff  **}{*------ PrintStuff ----------------------------------------------------------------*}{** **		PrintStuff gets a text file to print (as PostScript) from the user and then **		makes all the print calls to print it. **}PROCEDURE PrintStuff;	VAR		numCopies, copy		: Integer;		oldPort  			: GrafPtr;		thePrRecHdl			: THPrint;		thePrPort			: TPPrPort;		theStatus			: TPrStatus;		theFile				: SFReply;		textTypes			: SFTypeList;		where				: Point;	BEGIN	GetPort(oldPort);		SetPt(where, 100, 100);	textTypes[0] := 'TEXT';	SFGetFile(where, '', nil, 1, @textTypes, nil, theFile);		thePrRecHdl := THPrint(NewHandle(SIZEOF(TPrint)));		IF (theFile.good) AND (MemError = noErr) AND (thePrRecHdl <> nil) THEN	BEGIN		PrOpen;		IF (PrError = noErr) THEN		BEGIN			PrintDefault(thePrRecHdl);			IF (PrError = noErr) THEN		    BEGIN			   IF PrStlDialog(thePrRecHdl) THEN			    BEGIN					IF PrJobDialog(thePrRecHdl) THEN 					BEGIN												numCopies := thePrRecHdl^^.prJob.iCopies;						FOR copy := 1 TO numCopies DO						BEGIN													thePrPort := PrOpenDoc(thePrRecHdl, nil, nil);													IF (PrError = noErr) THEN							BEGIN									PrOpenPage(thePrPort, nil);																	IF (PrError = noErr) THEN									DrawStuff(theFile);									 								PrClosePage(thePrPort);															END;								 							PrCloseDoc(thePrPort);						END;												IF (thePrRecHdl^^.prJob.bJDocLoop = bSpoolLoop) and (PrError = noErr) THEN							PrPicFile(thePrRecHdl, nil, nil, nil, @theStatus);					END;				END;			END;		END;				PrClose;	END;	 	IF (thePrRecHdl <> nil) THEN DisposeHandle(Handle(thePrRecHdl));END;  {**  PrintStuff  **}{*------ main ----------------------------------------------------------------------*}BEGIN	    InitGraf(@qd.thePort);	InitFonts;	FlushEvents(everyEvent, 0);		InitWindows;	InitMenus;	TEInit;	InitDialogs(nil);	InitCursor;	PrintStuff;END. {**  main  **}