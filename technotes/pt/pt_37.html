<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PT37: Using MPW for Non-Macintosh 68000 Systems</title>                                       <meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="May 29, 1989 - Jun 2, 1989"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002691" title="Using MPW for Non-Macintosh 68000 Systems"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxTools-date.html">Tools</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/DeveloperTools/idxCompilersDebuggers-date.html" target="_blank">Tools > Compiling & Debugging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PT37</div>
<div id="pageheadsub">Using MPW for Non-Macintosh 68000 Systems</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">A5-Relative Globals</A><BR><BR><A HREF="#Section3">Segmenting and the Jump Table</A><BR><BR><A HREF="#Section4">Toolbox and OS Routines</A><BR><BR><A HREF="#Section5">Setting Up Your Run-Time Environment</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note discusses using MPW 3.0 for creating software intended torun on 68000-based systems that do not implement the Macintosh run-timearchitecture.  These systems include NuBus(TM) cards, peripheral devices, andproprietary 68000 systems.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Jun 01 1989]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A> <h2>Introduction</h2><p>Occasionally there is a need to create routines or programs for non-Macintoshsystems.  Such situations can occur if you are writing a driver for a NuBusboard, developing a peripheral that uses a 68xxx microprocessor, or perhapstargeting a proprietary 68xxx machine (Apple uses MPW for all of its ROM andNuBus development.)</P><P>For tasks such as this, MPW 3.0 can provide the solution.  This Note discussesthe problems and issues that arise when doing using MPW 3.0 for this type ofdevelopment, and it gives some hints and solutions.</p><p>To aid you in your efforts, there are several tools available on AppleLink inthe Developer Services bulletin board (Developer TechicalSupport:Macintosh:Tools:Card Dev Tools:) and on <i>Phil &amp; Dave's ExcellentCD</i>.  These tools include utilities to generate checksum data and to prepareyour program for downloading.</p><p>The following is a brief summary of problem areas you may encounter:</p><ul type="disc">	<li><code>A5</code>-Relative Globals Segmenting and the Jump Table ToolBox and OS Routines Setting up Your Run-Time Environment </li></ul><a name="Section2"></a><P><A HREF="#top">Back to top</A></p><h2>A5-Relative Globals</h2><h3>The Problem</h3><p>In traditional machine environments, the compiler allocates a certain range ofmemory in which to store global variables.  This memory is established by themachine's memory architecture, and it can usually be referenced by usingabsolute addressing modes.</p><p>Because the Macintosh has a very dynamic run-time environment, programs cannotbe written with specific memory locations in mind.  Programs are not given afixed place in memory in which to store their data that will be the samebetween program invocations.  To solve this problem, all Macintosh programs aredesigned to store global variables in a 32K area pointed to by the 68000register <code>A5</code>.  This could be a problem if your needs require you toreference or store your variables in specific memory locations.</p><h3>The Solution</h3><p>This problem can be solved if you are willing to use some macros.  A set ofmacros to do this could look something like the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include    &lt;sysEqu.h&gt;#define pShort        *(short *)#define pLong            *(long *)#define lmSFSaveDisk        pShort SFSaveDisk#define lmCurDirStore    pLong CurDirStoremain(){    short foo;    long bar;    foo = lmSFSaveDisk;    lmCurDirStore = bar;/* or */    foo = pShort SFSaveDisk;    pLong CurDirStore = bar;</pre>	</TD></TR></TABLE></CENTER><a name="Section3"></a> <P><A HREF="#top">Back to top</A></p><h2>Segmenting and the Jump Table</h2><h3>The Problem</h3><p>When the Macintosh was first developed, memory space was tight.  For thisreason, a run-time architecture was designed that allowed programs to bedivided into segments that could be dynamically loaded and unloaded.  Becauseof this, a program cannot rely on any specific memory locations into which itcan be loaded, and hence it has to be freely relocatable.  This means that anyintra-segment calls (i.e., calls from one routine to another within the samecode segment) have to use the <code>PC</code>-relative addressing modes of the68000.  Since these instructions use only signed 16-bit offsets, these branchesare limited to a range of 32K bytes.  This, in turn, leads us to the historical32K limit on <code>'CODE'</code> resource segments.  While the restriction in thelinker limiting <code>'CODE'</code> resources to 32K has been lifted with MPW 3.0,it does not resolve the issues with long distance branching.</p><p>In order to be larger than 32K, a program should be divided into multiple<code>'CODE'</code> resource segments.  Calls from a procedure in one segment to aprocedure in another segment are called inter-segment calls.  These calls areperformed through a jump table referenced with positive offsets from<code>A5</code> (Refer to <i>Inside Macintosh</i>, Volume II-53, The SegmentLoader, for more information on the jump table).  The problems that arise fromthis mechanism are that ROMable code does not get loaded into memory by aSegment Loader, and supporting an <code>A5</code> jump table may not bedesirable.</p><h3>The Solution</h3><p>Programs compiled with Pascal or C currently <b>always</b> use the 16-bit<code>PC</code>-relative address mode when generating branch instructions.  Thereis no way to change that.  However, there are several ways you can get aroundit:</p><ul type="disc">	<li>Implement your own A5 world Use islands for long jumps Use assembly language</li></ul><ol type="1" start="1">	<li>Implement an <code>A5</code> world in your device that mimics the Macintosh's as closely as possible.  This is probably the easiest solution.  First, you will be able to program in a normal Macintosh style and not have to take into account considerations that are presented in solutions #2 and #3.  It will also allow you to compile and link your program without having to specify any special options.</li></ol><p>    After this has been done, and you are ready to download your program to itsdestination, you can run your program through a filter that:  a) determines thefinal locations of all of the <code>'CODE'</code> resource segments in the file,and b) creates a jump table with the addresses correctly resolved.  In essence,this would be the same as a Macintosh program with all of its segments loadedin memory at the same time.</p><p>    Let's take a look at an example.  Assume that you have developed a programthat is about 40K long, and you would like to have it loaded at location $1000.Because of its length, it is divided into two segments.  You have one routinein <code>'CODE' = 1</code> that is referenced from <code>'CODE' = 2</code> and threeroutines in <code>'CODE' = 2</code> that are referenced from <code>'CODE' = 1</code>.All of these routines will generate jump table entries.  In addition, a jumptable entry is generated for the main entry point of your program, as per theSegment Loader chapter of <i>Inside Macintosh</i>.  This gives us a total offive jump table entries in our program.  The file created with MPW would looksomething like the following:</p><p><code>'CODE' = 1</code></p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>00000000:        main()...        ...000038B4:        importantRoutine1()...        ...</pre>	</TD></TR></TABLE></CENTER><p><code>'CODE' = 2</code></p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>00000000:        importantRoutine2()...        ...00003D0F:        importantRoutine3()...        ...00004969:        importantRoutine4()...        ...</pre>	</TD></TR></TABLE></CENTER><p><code>'CODE' = 0 </code>(the jump table)</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>00000000:00000008:    $20 bytes of overhead00000010:00000018:00000020:    00 00 3F 3C 00 01 A9 F0    ; dc.w $0000 / MOVE.W #1,-(A7) / _LoadSeg00000028:    38 B4 3F 3C 00 01 A9 F000000030:    00 00 3F 3C 00 02 A9 F000000038:    3D 0F 3F 3C 00 02 A9 F0</pre>	</TD></TR></TABLE></CENTER><p>When we create our downloadable image, the routines that we are interested inwill end up at these locations:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>main()            $0000 1000    ($1000 + $0000)importantRoutine1()    $0000 48B4    ($1000 + $38B4)importantRoutine2()    $0000 59F0    ($1000 + $49F0 + $0000)importantRoutine3()    $0000 96FF    ($1000 + $49F0 + $3D0F)</pre>	</TD></TR></TABLE></CENTER><p>Therefore, we should modify our Jump Table to look like this:</p><p><code>'CODE' = 0 </code>(the jump table)</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>00000000:00000008:    $20 bytes of overhead00000010:00000018:00000020:    00 01 4E 59 00 00 10 00    ; dc.w $0001 / JMP $0000 100000000028:    00 01 4E 59 00 00 48 B400000030:    00 02 4E 59 00 00 59 F000000038:    00 02 4E 59 00 00 96 FF</pre>	</TD></TR></TABLE></CENTER><ol type="1" start="2">	<li>For some reason, it may be impossible or undesirable to segment your code in Macintosh fashion.  You may be importing source code from somewhere else, or you may not be able to utilize a jump table.  In cases like this, where your program has to be compiled as one segment, you will hit problems if it is a large program.  The Pascal and C compilers will still limit you to branches smaller than 32K.  In the cases where you need to execute long distance jumps, the only thing you can do is create "islands" that allow you to make several short hops to your destination.  For instance, if it turns out that you are writing a C program which needs to call a procedure that is 70K away, you will have to break up the branch into three smaller ones as follows:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>main()[ ... some random code ... ]procedureNearTheBeginningOfMyProgram(){    ...    Island1(); /*Calling importantButFarAwayRoutine() */    ...}[ ... 20K of intervening code ... ]Island1(){ Island2(); }[ ... 30K of intervening code ... ]Island2(){ importantButFarAwayRoutine(); }[ ... 20K of intervening code ... ]importantButFarAwayRoutine(){    ...</pre>	</TD></TR></TABLE></CENTER><ol type="1" start="3">	<li>If programming little islands into your program is too gross for you to comtemplate, then program using the 68xxx assembler, eschewing the high-level compilers.  This will allow you to use the absolute addressing mode directly, avoiding the fact that the compilers will not use them.  It will also allow you to store into and access fixed memory locations more easily.  The following shows some ways of doing this:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>test    Main    import test5    import test6    org $1000    jsr test2            ; test of an intraprocedure call just    jmp test2            ; a few bytes away.    jsr test3            ; test of an intraprocedure call a    jmp test3            ; significant number of bytes away.test2    jsr (test4).l        ; test of an intraprocedure call more    jmp (test4).l        ; than 32K away.; The following instructions won't work on a 68000, but will on a; 68020 or better. They demonstrate a better alternative to the above; method, in that they generate PC-relative branching. In order to; use them, include &quot;MACHINE MC68020&quot; in your assembly source code.;    bsr.l test4        ; test of an intraprocedure call more;    bra.l test4        ; than 32K away.    lea (test4).l,A0        ; alternate test of a &gt; 32K jump    jmp (A0)    ds.b 17000        ; padding to force &gt; 16K jumptest3    jsr test5            ; test of an interprocedure call a    jmp test5            ; significant number of bytes away    jsr (test6).l        ; test of an interprocedure call more    jmp (test6).l        ; than 32K away    ds.b 17000        ; padding to force &gt; 32K jumptest4    rts    endptest5    proc    entry test6    rts    ds.b 17000        ; padding to force &gt; 32K jumptest6    rts    endp</pre>	</TD></TR></TABLE></CENTER><a name="Section4"></a> <P><A HREF="#top">Back to top</A></p><h2>Toolbox and OS Routines</h2><h3>The Problem</h3><p>Because your program will be operating in a non-Macintosh environment, you willnot be able to make any ToolBox or operating system calls.  This would not seemto be a problem until you consider that the library routines you are calling mybe making such calls themselves.  For example, <code>malloc()</code> and most<code>stdio</code> calls fall into this category.</p><h3>The Solution</h3><p>Don't use our libraries.  Use your own.  Most of the MPW library routines are"clean," but the low-level routines that they rely on use the Toolbox or OS.Identifying those low-level routines that call the Macintosh operating system,determining all the high-level routines that depend upon them, and thenprogramming around them is too difficult a task to undertake.  Even if it weredone, you would still have to contend with routines that allocated globalvariables.  The best thing to do is avoid our libraries altogether and justwrite your own.</p><a name="Section5"></a> <P><A HREF="#top">Back to top</A></p><h2>Setting Up Your Run-Time Environment</h2><h3>The Problem</h3><p>The Pascal and C compilers do some hidden work to initialize the run-timeenvironment before the part of your application that you have written isactually executed.  It is possible that you may wish to take advantage of thissetup or may need to duplicate it in order to get your program to execute.</p><h3>The Solution</h3><p>With Pascal, most of this initialization is automatically inserted into yourmain procedure.  There is very little you can do about it except to put all ofyour Pascal routines into separately compiled UNITs and write your entry pointin C or assembly.</p><p>In the case of C, this initialization is performed by a routine in the fileCRuntime.o called <code>CMain()</code>.  The following is a description of whathappens to your source code from the time the C compiler gets it to the timethe code you have written is executed:</p><ul type="disc">	<li>MPW C compiles all of the source files and creates object files for the linker.  All functions are compiled in <b>exactly</b> the same way, including <code>main()</code>.</li>	<li>These files are linked together.  If you do not link with the file CRuntime.o, these routines will link together, but they will not have an entry point; the linker will not have any routine explicitly defined as the first one to be called, and it will default to setting up the first routine that it finds as the entry point.</li>	<li>If you <b>do</b> link with the file CRuntime.o, then you will be linking with a routine called <code>CMain()</code>.  This routine is marked as being an Entry routine, and it will be the routine that is executed when you launch the Macintosh program.</li></ul><ul type="disc">	<li><code>CMain()</code> performs the following steps:</li></ul><ol type="1" >	<li>Call <code>_RTInit</code> (runtime init) Call <code>setjmp()</code> Check the result of <code>setjmp()</code>.  If &lt;&gt; 0, go to 6. Call <code>main()</code> Call <code>exit()</code> with result from <code>main()</code>. <code>RTS</code></li></ol><ul type="disc">	<li>This is what <code>_RTInit</code> does:</li></ul><ol type="1" start="1">	<li>Call <code>_DataInit()</code>.</li>	<li>Save the return address back to whomever ran this program.</li>	<li>Check to see if launched by MPW.  If not, then setup <code>argv</code> and <code>argc</code> to indicate the name of the program with no parameters.</li>	<li>If launched under MPW, initialize some things so that the run-time environment will integrate with MPW.  <b>Calls the Memory Manager</b>, so make sure that this part of the code is never executed.  This is not likely to happen, as <code>_RTInit</code> checks and validates several memory locations before it gets this far.</li></ol><ul type="disc">	<li>This is what <code>_DataInit()</code> does:</li></ul><ol type="1" start="1">	<li>Assume that <code>A5</code> is valid, and that there is data appended to the end of <code>DataInit</code> that is used to initialize the globals.  This will be done by the linker automatically.</li>	<li>Determine the size of the globals and zero it out.</li>	<li>Read the data at the end of the procedure and use it to initialize the globals.  Normally, this process will attempt to use <code>_BlockMove</code> on sufficiently large blocks of data, and a small loop for small blocks of data. A version of <code>DataInit()</code> that does not call <code>_BlockMove</code> is available from Macintosh Developer Technical Support.  However, this limits you to 64K of contiguous pre-initialized storage.</li></ol><ul type="disc">	<li>This is what <code>exit()</code> does:</li></ul><ol type="1" start="1">	<li>Call any user installed exit procedures.</li>	<li>If called from MPW, set the value of <code>{Status}</code></li>	<li>Determine if <code>setjmp()</code> was ever called.  If so then call <code>longjmp()</code> with a value of 1.</li>	<li>If <code>setjmp()</code> was never called, then return directly to the process caller, as saved in step two of <code>_RTInit</code>.</li></ol><p>While MPW was designed with creating Macintosh programs in mind, it can also beused to write software for non-Macintosh targets.  After resolving such issuesas creating an appropriate run-time environment, making sure that Toolbox callsare not made, and being aware of the 32K limit for branches and jumps, youshould be able to use the high-level Pascal and C compilers.  By using assemblylanguage, you should even be able to avoid the problems that they pose.</p><a name="References"></a> <P><A HREF="#top">Back to top</A></p><h2>References</h2><P>   <i>Inside Macintosh</i>, Volume II-53, The Segment Loader</p><P>   M.OS.SegmentLoader</p><P>   NuBus is a trademark of Texas Instruments</p>         <a name=Downloads></A>                  <P><A HREF="#top">Back to top</A></p> <h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pt_37.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pt/pt_37.html%3Fid%3DDTS10002691-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pt/pt_37.html%3Fid%3DDTS10002691-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pt/pt_37.html%3Fid%3DDTS10002691-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>