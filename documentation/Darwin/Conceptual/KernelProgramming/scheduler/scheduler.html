<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Kernel Programming Guide: Mach Scheduling and Thread Interfaces</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Mach Scheduling and Thread Interfaces"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000905-CH211" title="Mach Scheduling and Thread Interfaces"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Kernel-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000532" target="_top">Kernel</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30000905-CH204-TPXREF101">Kernel Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../vm/vm.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../contexts/contexts.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000905-CH211-BEHJDFCA" title="Mach Scheduling and Thread Interfaces"></a><h1>Mach Scheduling and Thread Interfaces</h1><p>Mac OS X is based on Mach and BSD. Like Mach and most BSD UNIX systems, it contains an advanced scheduler based on the CMU Mach 3<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_481"></a> scheduler. This chapter describes the scheduler from the perspective of both a kernel programmer and an application developer attempting to set scheduling parameters.</p>
<p>This chapter begins with the <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-BABFGDHA">“Overview of Scheduling,”</a></span> which describes the basic concepts behind Mach scheduling at a high level, including real-time priority support.</p>
<p>The second section, <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-BABCHEEB">“Using Mach Scheduling From User Applications,”</a></span> describes how to access certain key Mach scheduler routines from user applications and from other parts of the kernel outside the scheduler.</p>
<p>The third section, <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-BABBEEBI">“Kernel Thread APIs,”</a></span> explains scheduler-related topics including how to create and terminate kernel threads and describes the BSD <code><!--a-->spl<!--/a--></code> macros and their limited usefulness in Mac OS X.</p>

<a name="//apple_ref/doc/uid/TP30000905-CH211-BABFGDHA" title="Overview of Scheduling"></a><h2>Overview of Scheduling</h2>
<p>The Mac OS X scheduler is derived from the scheduler used in OSFMK<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_482"></a> 7.3. In general, much documentation about prior implementations applies to the scheduler in Mac OS X, although you will find numerous differences. The details of those differences are beyond the scope of this overview.</p>
<p>Mach scheduling is based on a system of run queues at various priorities that are handled in different ways. The priority levels are divided into four bands according to their characteristics, as described in <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-TPXREF114">Table 9-1</a></span>.</p><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_483"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_484"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-TPXREF114" title="Table 9-1Thread priority bands"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 9-1&nbsp;&nbsp;</strong>Thread priority bands</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Priority Band</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Characteristics</p></th>
</tr>


<tr>
<td  scope="row"><p>Normal</p></td>
<td ><p>normal application thread priorities</p></td>
</tr>
<tr>
<td  scope="row"><p>System high priority</p></td>
<td ><p>threads whose priority has been raised above normal threads</p></td>
</tr>
<tr>
<td  scope="row"><p>Kernel mode only</p></td>
<td ><p>reserved for threads created inside the kernel that need to run at a higher priority than all user space threads (I/O Kit workloops, for example)</p></td>
</tr>
<tr>
<td  scope="row"><p>Real-time threads</p></td>
<td ><p>threads whose priority is based on getting a well-defined fraction of total clock cycles, regardless of other activity (in an audio player application, for example).</p></td>
</tr>

</table></div>
<p>Threads can migrate between priority levels for a number of reasons, largely as an artifact of the time sharing algorithm used. However, this migration is within a given band.</p>
<p>Threads marked as being real-time priority<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_485"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_486"></a> are also special in the eyes of the scheduler. A real-time thread tells the scheduler that it needs to run for <code>A</code> cycles out of the next <code>B</code> cycles. For example, it might need to run for 3000 out of the next 7000 clock cycles in order to keep up. It also tells the scheduler whether those cycles must be contiguous. Using long contiguous quanta is generally frowned upon but is occasionally necessary for specialized real-time applications.</p><p>The kernel will make every effort to honor the request, but since this is soft real-time, it cannot be guaranteed. In particular, if the real-time thread requests something relatively reasonable, its priority will remain in the real-time band, but if it lies blatantly about its requirements and behaves in a compute-bound fashion, it may be demoted to the priority of a normal thread.</p>
<p>Changing a thread’s priority to turn it into a real-time priority thread using Mach calls is described in more detail in <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-BABCHEEB">“Using Mach Scheduling From User Applications.”</a></span></p>
<p>In addition to the raw Mach RPC interfaces, some aspects of a thread’s priority can be controlled from user space using the POSIX thread priority API. The POSIX thread API is able to set thread priority only within the lowest priority band (0–63). For more information on the POSIX thread priority API, see <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-TPXREF109">“Using the pthreads API to Influence Scheduling.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-TPXREF108" title="Why Did My Thread Priority Change?"></a><h2>Why Did My Thread Priority Change?</h2>
<p>There are many reasons that a thread’s priority can change. This section attempts to explain the root cause of these thread priority changes.</p>
<p>A real-time thread, as mentioned previously, is penalized (and may even be knocked down to normal thread priority) if it exceeds its time quantum<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_487"></a> without blocking repeatedly. For this reason, it is very important to make a reasonable guess about your thread’s workload if it needs to run in the real-time band.</p>
<p>Threads that are heavily compute-bound are given lower priority to help minimize response time for interactive tasks so that high–priority compute–bound threads cannot monopolize the system and prevent lower–priority I/O-bound threads from running. Even at a lower priority, the compute–bound threads still run frequently, since the higher–priority I/O-bound threads do only a short amount of processing, block on I/O again, then allow the compute-bound threads to execute.</p>
<p>All of these mechanisms are operating continually in the Mach scheduler. This means that threads are frequently moving up or down in priority based upon their behavior and the behavior of other threads in the system.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-BABCHEEB" title="Using Mach Scheduling From User Applications"></a><h2>Using Mach Scheduling From User Applications</h2>
<p>There are three basic ways to change how a user thread is scheduled. You can use the BSD <code>pthreads</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_488"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_489"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_490"></a> API to change basic policy and importance. You can also use Mach RPC calls to change a task’s importance. Finally, you can use RPC calls to change the scheduling policy to move a thread into a different scheduling band. This is commonly used when interacting with CoreAudio.</p>
<p>The <code>pthreads</code> API is a user space API, and has limited relevance for kernel programmers. The Mach thread and task APIs are more general and can be used from anywhere in the kernel. The Mach thread and task calls can also be called from user applications.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-TPXREF109" title="Using the pthreads API to Influence Scheduling"></a><h3>Using the <code>pthreads</code> API to Influence Scheduling</h3>
<p>Mac OS X supports a number of policies at the POSIX threads API level. If you need real-time behavior, you must use the Mach <code><!--a-->thread_policy_set<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_491"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_492"></a> call. This is described in <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-BABHGEFA">“Using the Mach Thread API to Influence Scheduling.”</a></span></p>
<p>The <code>pthreads</code> API adjusts the priority of threads within a given task. It does not necessarily impact performance relative to threads in other tasks. To increase the priority of a task, you can use <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_493"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_494"></a><code><a href="../../../Reference/ManPages/man1/nice.1.html#//apple_ref/doc/man/1/nice" target="_top">nice</a></code> or <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_495"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_496"></a><code><a href="../../../Reference/ManPages/man8/renice.8.html#//apple_ref/doc/man/8/renice" target="_top">renice</a></code> from the command line or call <code><!--a target="_top" -->getpriority<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_497"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_498"></a> and <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_499"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_500"></a><code><!--a target="_top" -->setpriority<!--/a--></code> from your application.</p>
<p>The API provides two functions: <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_501"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_502"></a><code><a href="../../../Reference/ManPages/man3/pthread_getschedparam.3.html#//apple_ref/doc/man/3/pthread_getschedparam" target="_top">pthread_getschedparam</a></code> and <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_503"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_504"></a><code><a href="../../../Reference/ManPages/man3/pthread_setschedparam.3.html#//apple_ref/doc/man/3/pthread_setschedparam" target="_top">pthread_setschedparam</a></code>. Their prototypes look like this:</p>
<div class="codesample"><table><tr><td scope="row"><pre>pthread_setschedparam(pthread_t thread, int policy,<span></span></pre></td></tr><tr><td scope="row"><pre>        struct sched_param *param);<span></span></pre></td></tr><tr><td scope="row"><pre>pthread_getschedparam(pthread_t thread, int *policy,<span></span></pre></td></tr><tr><td scope="row"><pre>        struct sched_param *param)<span></span></pre></td></tr></table></div>
<p>The arguments for <code><a href="../../../Reference/ManPages/man3/pthread_getschedparam.3.html#//apple_ref/doc/man/3/pthread_getschedparam" target="_top">pthread_getschedparam</a></code> are straightforward. The first argument is a thread ID, and the others are pointers to memory where the results will be stored.</p>
<p>The arguments to <code><a href="../../../Reference/ManPages/man3/pthread_setschedparam.3.html#//apple_ref/doc/man/3/pthread_setschedparam" target="_top">pthread_setschedparam</a></code> are not as obvious, however. As with <code><a href="../../../Reference/ManPages/man3/pthread_getschedparam.3.html#//apple_ref/doc/man/3/pthread_getschedparam" target="_top">pthread_getschedparam</a></code>, the first argument is a thread ID.</p>
<p>The second argument to <code><a href="../../../Reference/ManPages/man3/pthread_setschedparam.3.html#//apple_ref/doc/man/3/pthread_setschedparam" target="_top">pthread_setschedparam</a></code> is the desired policy, which can currently be one of <code>SCHED_FIFO</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_505"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_506"></a> (first in, first out), <code>SCHED_RR</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_507"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_508"></a> (round-robin), or <code>SCHED_OTHER</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_509"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_510"></a>. The <code>SCHED_OTHER</code> policy is generally used for extra policies that are specific to a given operating system, and should thus be avoided when writing portable code.</p>
<p>The third argument is a structure that contains various scheduling parameters.</p>
<p>Here is a basic example of using <code>pthreads</code> functions to set a thread’s scheduling policy and priority.</p>
<div class="codesample"><table><tr><td scope="row"><pre>int set_my_thread_priority(int priority) {<span></span></pre></td></tr><tr><td scope="row"><pre>    struct sched_param sp;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    memset(&amp;sp, 0, sizeof(struct sched_param));<span></span></pre></td></tr><tr><td scope="row"><pre>    sp.sched_priority=priority;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (pthread_setschedparam(pthread_self(), SCHED_RR, &amp;sp)  == -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Failed to change priority.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_511"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_512"></a>This code snippet sets the scheduling policy for the current thread to round-robin scheduling, and sets the thread’s relative importance within the task to the value passed in through the <code>priority</code> argument.</p><p>For more information, see the manual page for <code><a href="../../../Reference/ManPages/man3/pthread.3.html#//apple_ref/doc/man/3/pthread" target="_top">pthread</a></code>.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-BABHGEFA" title="Using the Mach Thread API to Influence Scheduling"></a><h3>Using the Mach Thread API to Influence Scheduling</h3>
<p>This API is frequently used in multimedia applications to obtain real-time priority. It is also useful in other situations when the <code><a href="../../../Reference/ManPages/man3/pthread.3.html#//apple_ref/doc/man/3/pthread" target="_top">pthread</a></code> scheduling API cannot be used or does not provide the needed functionality.</p>
<p>The API consists of two functions, <code><!--a-->thread_policy_set<!--/a--></code> and <code><!--a-->thread_policy_get<!--/a--></code>.</p>
<div class="codesample"><table><tr><td scope="row"><pre>kern_return_t thread_policy_set(<span></span></pre></td></tr><tr><td scope="row"><pre>                thread_act_t thread,<span></span></pre></td></tr><tr><td scope="row"><pre>                thread_policy_flavor_t flavor,<span></span></pre></td></tr><tr><td scope="row"><pre>                thread_policy_t policy_info,<span></span></pre></td></tr><tr><td scope="row"><pre>                mach_msg_type_number_t count);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t thread_policy_get(<span></span></pre></td></tr><tr><td scope="row"><pre>                thread_act_t thread,<span></span></pre></td></tr><tr><td scope="row"><pre>                thread_policy_flavor_t flavor,<span></span></pre></td></tr><tr><td scope="row"><pre>                thread_policy_t policy_info,<span></span></pre></td></tr><tr><td scope="row"><pre>                mach_msg_type_number_t *count,<span></span></pre></td></tr><tr><td scope="row"><pre>                boolean_t *get_default);<span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_513"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_514"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_515"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_516"></a>The parameters of these functions are roughly the same, except that the <code><!--a-->thread_policy_get<!--/a--></code> function takes pointers for the <code>count</code> and the <code>get_default</code> arguments. The count is an <code>inout</code> parameter, meaning that it is interpreted as the maximum amount of storage (in units of <code>int32_t</code>) that the calling task has allocated for the return, but it is also overwritten by the scheduler to indicate the amount of data that was actually returned.</p>
<p>These functions get and set several parameters, according to the thread policy chosen. The possible thread policies are listed in <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-BABBEJDH">Table 9-2</a></span>.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-BABBEJDH" title="Table 9-2Thread policies"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 9-2&nbsp;&nbsp;</strong>Thread policies</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Policy</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th>
</tr>


<tr>
<td  scope="row"><p><code>THREAD_STANDARD_POLICY</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_517"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_518"></a></p></td>
<td ><p>Default value</p></td>
</tr>
<tr>
<td  scope="row"><p><code>THREAD_TIME_CONSTRAINT_POLICY</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_519"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_520"></a></p></td>
<td ><p>Used to specify real-time behavior.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>THREAD_PRECEDENCE_POLICY</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_521"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_522"></a></p></td>
<td ><p>Used to indicate the importance of computation relative to other threads in a given task.</p></td>
</tr>

</table></div>
<p>The following code snippet shows how to set the priority of a task to tell the scheduler that it needs real-time<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_523"></a> performance. The example values provided in comments are based on the estimated needs of <code>esd</code> (the Esound daemon).<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_524"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_525"></a></p>
<div class="codesample"><table><tr><td scope="row"><pre>#include &lt;mach/mach_init.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;mach/thread_policy.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;mach/sched.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int set_realtime(int period, int computation, int constraint) {<span></span></pre></td></tr><tr><td scope="row"><pre>    struct thread_time_constraint_policy ttcpolicy;<span></span></pre></td></tr><tr><td scope="row"><pre>    int ret;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ttcpolicy.period=period; // HZ/160<span></span></pre></td></tr><tr><td scope="row"><pre>    ttcpolicy.computation=computation; // HZ/3300;<span></span></pre></td></tr><tr><td scope="row"><pre>    ttcpolicy.constraint=constraint; // HZ/2200;<span></span></pre></td></tr><tr><td scope="row"><pre>    ttcpolicy.preemptible=1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ((ret=thread_policy_set(mach_thread_self(),<span></span></pre></td></tr><tr><td scope="row"><pre>        THREAD_TIME_CONSTRAINT_POLICY, (thread_policy_t)&amp;ttcpolicy,<span></span></pre></td></tr><tr><td scope="row"><pre>        THREAD_TIME_CONSTRAINT_POLICY_COUNT)) != KERN_SUCCESS) {<span></span></pre></td></tr><tr><td scope="row"><pre>            fprintf(stderr, "set_realtime() failed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>            return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return 1;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>The time values are in terms of Mach absolute time units. Since these values differ according to the bus speed of your computer, you should generally use numbers relative to HZ (a global variable containing the current number of ticks per second). You can either handle this conversion yourself by dividing this value by an appropriate quantity or use the conversion routines described in <span class="content_text"><a href="../services/services.html#//apple_ref/doc/uid/TP30000905-CH219-CHDJBFEF">“Using Kernel Time Abstractions .”</a></span></p>
<p>Say your computer reports 133 million for the value of HZ. If you pass the example values given as arguments to this function, your thread tells the scheduler that it needs approximately 40,000 (HZ/3300) out of the next 833,333 (HZ/160) bus cycles. The <code>preemptible</code> value (1) indicates that those 40,000 bus cycles need not be contiguous. However, the <code>constraint</code> value (HZ/2200) tells the scheduler that there can be no more than 60,000 bus cycles between the start of computation and the end of computation.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH211-SW1" title="Note"></a><p><strong>Note:</strong>&nbsp;Because the constraint sets a maximum bound for computation, it must be larger than the value for computation.</p></div>
<p>A straightforward example using this API is code that displays video directly to the framebuffer hardware. It needs to run for a certain number of cycles every frame to get the new data into the frame buffer. It can be interrupted without worry, but if it is interrupted for too long, the video hardware starts displaying an outdated frame before the software writes the updated data, resulting in a nasty glitch. Audio has similar behavior, but since it is usually buffered along the way (in hardware and in software), there is greater tolerance for variations in timing, to a point.</p>
<p>Another policy call is <code>THREAD_PRECEDENCE_POLICY</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_526"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_527"></a>. This is used for setting the relative importance of non-real-time threads. Its calling convention is similar, except that its structure is <code>thread_precedence_policy</code>, and contains only one field, an <code>integer_t</code> called <code>importance</code>. While this is a signed 32-bit value, the minimum legal value is zero (<code>IDLE_PRI</code>). threads set to <code>IDLE_PRI</code> will only execute when no other thread is scheduled to execute.</p>
<p>In general, larger values indicate higher priority. The maximum limit is subject to change, as are the priority bands, some of which have special purposes (such as real-time threads). Thus, in general, you should use pthreads APIs to achieve this functionality rather than using this policy directly unless you are setting up an idle thread.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-TPXREF110" title="Using the Mach Task API to Influence Scheduling"></a><h3>Using the Mach Task API to Influence Scheduling</h3>
<p>This relatively simple API is not particularly useful for most developers. However, it may be beneficial if you are developing a graphical user interface for Darwin. It also provides some insight into the prioritization of tasks in Mac OS X. It is presented here for completeness.</p>
<p>The API consists of two functions, <code><!--a-->task_policy_set<!--/a--></code> and <code><!--a-->task_policy_get<!--/a--></code>.<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_528"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_529"></a></p>
<div class="codesample"><table><tr><td scope="row"><pre>kern_return_t task_policy_set(<span></span></pre></td></tr><tr><td scope="row"><pre>                task_t task,<span></span></pre></td></tr><tr><td scope="row"><pre>                task_policy_flavor_t flavor,<span></span></pre></td></tr><tr><td scope="row"><pre>                task_policy_t policy_info,<span></span></pre></td></tr><tr><td scope="row"><pre>                mach_msg_type_number_t count);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t task_policy_get(<span></span></pre></td></tr><tr><td scope="row"><pre>                task_t task,<span></span></pre></td></tr><tr><td scope="row"><pre>                task_policy_flavor_t flavor,<span></span></pre></td></tr><tr><td scope="row"><pre>                task_policy_t policy_info,<span></span></pre></td></tr><tr><td scope="row"><pre>                mach_msg_type_number_t *count,<span></span></pre></td></tr><tr><td scope="row"><pre>                boolean_t *get_default);<span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_530"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_531"></a>As with <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_532"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_533"></a><code><!--a-->thread_policy_set<!--/a--></code> and <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_534"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_535"></a><code><!--a-->thread_policy_get<!--/a--></code>, the parameters are similar, except that the <code><!--a-->task_policy_get<!--/a--></code> function takes pointers for the <code>count</code> and the <code>get_default</code> arguments. The <code>count</code> argument is an <code>inout</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_536"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_537"></a> parameter. It is interpreted as the maximum amount of storage that the calling task has allocated for the return, but it is also overwritten by the scheduler to indicate the amount of data that was actually returned.</p>
<p>These functions get and set a single parameter, that of the role of a given task, which changes the way the task’s priority gets altered over time. The possible roles of a task are listed in <span class="content_text"><a href="scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-BABCFADD">Table 9-3</a></span>.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_538"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-BABCFADD" title="Table 9-3Task roles"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 9-3&nbsp;&nbsp;</strong>Task roles</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Role</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th>
</tr>


<tr>
<td  scope="row"><p><code>TASK_UNSPECIFIED</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_539"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_540"></a></p></td>
<td ><p>Default value</p></td>
</tr>
<tr>
<td  scope="row"><p><code>TASK_RENICED</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_541"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_542"></a></p></td>
<td ><p>This is set when a process is executed with <code>nice</code> or is modified by <code>renice</code>.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>TASK_FOREGROUND_APPLICATION</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_543"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_544"></a></p></td>
<td ><p>GUI application in the foreground. There can be more than one foreground application.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>TASK_BACKGROUND_APPLICATION<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_545"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_546"></a></code></p></td>
<td ><p>GUI application in the background.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>TASK_CONTROL_APPLICATION</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_547"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_548"></a></p></td>
<td ><p>Reserved for the dock or equivalent (assigned FCFS).</p></td>
</tr>
<tr>
<td  scope="row"><p><code>TASK_GRAPHICS_SERVER</code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_549"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_550"></a></p></td>
<td ><p>Reserved for <code>WindowServer</code> or equivalent (assigned FCFS).</p></td>
</tr>

</table></div>
<p>The following code snippet shows how to set the priority of a task to tell the scheduler that it is a foreground application (regardless of whether it really is).<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_551"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_552"></a></p>
<div class="codesample"><table><tr><td scope="row"><pre>#include &lt;mach/mach_init.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;mach/task_policy.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;mach/sched.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int set_my_task_policy(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    int ret;<span></span></pre></td></tr><tr><td scope="row"><pre>    struct task_category_policy tcatpolicy;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    tcatpolicy.role = TASK_FOREGROUND_APPLICATION;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ((ret=task_policy_set(mach_task_self(),<span></span></pre></td></tr><tr><td scope="row"><pre>        TASK_CATEGORY_POLICY, (thread_policy_t)&amp;tcatpolicy,<span></span></pre></td></tr><tr><td scope="row"><pre>        TASK_CATEGORY_POLICY_COUNT)) != KERN_SUCCESS) {<span></span></pre></td></tr><tr><td scope="row"><pre>            fprintf(stderr, "set_my_task_policy() failed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>            return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return 1;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP30000905-CH211-BABBEEBI" title="Kernel Thread APIs"></a><h2>Kernel Thread APIs</h2>
<p>The Mac OS X scheduler provides a number of public APIs. While many of these APIs should not be used, the APIs to create, destroy, and alter kernel threads are of particular importance. While not technically part of the scheduler itself, they are inextricably tied to it.</p>
<p>The scheduler directly provides certain services that are commonly associated with the use of kernel threads, without which kernel threads would be of limited utility. For example, the scheduler provides support for wait queues, which are used in various synchronization primitives such as mutex locks and semaphores.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-TPXREF111" title="Creating and Destroying Kernel Threads "></a><h3>Creating and Destroying Kernel Threads </h3><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_553"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_554"></a>
<p>The recommended interface for creating threads within the kernel is through the I/O Kit. It provides <code><a href="../../../Reference/KernelIOKitFramework/IOLib_h/index.html#//apple_ref/c/func/IOCreateThread" target="_top">IOCreateThread</a></code>, <code><a href="../../../Reference/KernelIOKitFramework/IOLib_h/index.html#//apple_ref/c/macro/IOThreadSelf" target="_top">IOThreadSelf</a></code>, and <code><a href="../../../Reference/KernelIOKitFramework/IOLib_h/index.html#//apple_ref/c/func/IOExitThread" target="_top">IOExitThread</a></code> functions that make it relatively painless to create threads in the kernel.</p><p>The basic functions for creating and terminating kernel threads are:</p>
<div class="codesample"><table><tr><td scope="row"><pre>IOThread IOCreateThread(IOThreadFunc function, void *argument);<span></span></pre></td></tr><tr><td scope="row"><pre>IOThread IOThreadSelf(void);<span></span></pre></td></tr><tr><td scope="row"><pre>void IOExitThread(void);<span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_555"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_556"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_557"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_558"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_559"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_560"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_561"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_562"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_563"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_564"></a>With the exception of <code><a href="../../../Reference/KernelIOKitFramework/IOLib_h/index.html#//apple_ref/c/func/IOCreateThread" target="_top">IOCreateThread</a></code> (which is a bit more complex), the I/O Kit functions are fairly thin wrappers around Mach thread functions. The types involved are also very thin abstractions. <code><!--a target="_top" -->IOThread<!--/a--></code> is really the same as <code><!--a target="_top" -->thread_t<!--/a--></code>.</p>
<p>The <code>IOCreateThread</code> function creates a new thread that immediately begins executing the function that you specify. It passes a single argument to that function. If you need to pass more than one argument, you should dynamically allocate a data structure and pass a pointer to that structure.</p><p>For example, the following code creates a kernel thread and executes the function <code>myfunc</code> in that thread:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;IOKit/IOLib.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;libkern/libkern.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/malloc.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>struct mydata {<span></span></pre></td></tr><tr><td scope="row"><pre>    int three;<span></span></pre></td></tr><tr><td scope="row"><pre>    char *string;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static void myfunc(void *myarg) {<span></span></pre></td></tr><tr><td scope="row"><pre>    struct mydata *md = (struct mydata *)myarg;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("Passed %d = %s\n", md->three, md->string);<span></span></pre></td></tr><tr><td scope="row"><pre>    IOExitThread();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void start_threads() {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOThread mythread;<span></span></pre></td></tr><tr><td scope="row"><pre>    struct mydata *md = (struct mydata *)malloc(sizeof(*md));<span></span></pre></td></tr><tr><td scope="row"><pre>    md->three = 3; md->string = (char *)malloc(2 * sizeof(char));<span></span></pre></td></tr><tr><td scope="row"><pre>    md->string[0] = '3'; md->string[1] = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Start a thread using IOCreateThread<span></span></pre></td></tr><tr><td scope="row"><pre>    mythread = IOCreateThread(&amp;myfunc, (void *)md);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>One other useful function is <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_565"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_566"></a><code><!--a-->thread_terminate<!--/a--></code>. This can be used to destroy an arbitrary thread (except, of course, the currently running thread). This can be<em> extremely </em>dangerous if not done correctly. Before tearing down a thread with <code><!--a-->thread_terminate<!--/a--></code>, you should lock the thread and disable any outstanding timers against it. If you fail to deactivate a timer, a kernel panic will occur when the timer expires.</p>
<p>With that in mind, you may be able to terminate a thread as follows:</p>
<div class="codesample"><table><tr><td scope="row"><pre>thread_terminate(getact_thread(thread));<span></span></pre></td></tr></table></div>
<p>There thread is of type <code><!--a target="_top" -->thread_t<!--/a--></code>. In general, you can only be assured that you can kill yourself, not other threads in the system. The function <code><!--a target="_top" -->thread_terminate<!--/a--></code> takes a single parameter of type <code><!--a target="_top" -->thread_act_t<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_567"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_568"></a> (a thread activation). The function <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_569"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_570"></a><code><!--a-->getact_thread<!--/a--></code> takes a thread shuttle (<code><!--a target="_top" -->thread_shuttle_t<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_571"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_572"></a>) or <code><!--a target="_top" -->thread_t<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_573"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_574"></a> and returns the thread activation associated with it.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-TPXREF112" title="SPL  and Friends"></a><h3><code>SPL</code>  and Friends</h3><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_575"></a>
<p>BSD–based and Mach–based operating systems contain legacy functions designed for basic single-processor synchronization. These include functions such as <code><!--a-->splhigh<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_576"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_577"></a>, <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_578"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_579"></a><code><!--a-->splbio<!--/a--></code>, <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_580"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_581"></a><code><!--a-->splx<!--/a--></code>, and other similar functions. Since these functions are not particularly useful for synchronization in an SMP situation, they are not particularly useful as synchronization tools in Mac OS X.</p>
<p>If you are porting legacy code from earlier Mach–based or BSD–based operating systems, you must find an alternate means of providing synchronization. In many cases, this is as simple as taking the kernel or network funnel. In parts of the kernel, the use of <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_582"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_583"></a><code><!--a-->spl<!--/a--></code> functions does nothing, but causes no harm if you are holding a funnel (and results in a panic if you are not). In other parts of the kernel, <code>spl</code> macros are actually used. Because <code><!--a-->spl<!--/a--></code> cannot necessarily be used for its intended purpose, it should not be used in general unless you are writing code it a part of the kernel that already uses it. You should instead use alternate synchronization primitives such as those described in <span class="content_text"><a href="../synchronization/synchronization.html#//apple_ref/doc/uid/TP30000905-CH218-BEHJDFCA">“Synchronization Primitives.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000905-CH211-TPXREF113" title="Wait Queues and Wait Primitives"></a><h3>Wait Queues and Wait Primitives</h3><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_584"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_585"></a>
<p>The wait queue API is used extensively by the scheduler and is closely tied to the scheduler in its implementation. It is also used extensively in locks, semaphores, and other synchronization primitives. The wait queue API is both powerful and flexible, and as a result is somewhat large. Not all of the API is exported outside the scheduler, and parts are not useful outside the context of the wait queue functions themselves. This section documents only the public API.</p>
<p>The wait queue API includes the following functions:<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_586"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_587"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_588"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_589"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_590"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_591"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_592"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_593"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_594"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_595"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_596"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_597"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_598"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_599"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_600"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_601"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_602"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_603"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_604"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_605"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_606"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_607"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_608"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_609"></a></p>
<div class="codesample"><table><tr><td scope="row"><pre>void wait_queue_init(wait_queue_t wq, int policy);<span></span></pre></td></tr><tr><td scope="row"><pre>extern wait_queue_t wait_queue_t wait_queue_alloc(int policy);<span></span></pre></td></tr><tr><td scope="row"><pre>void wait_queue_free(wait_queue_t wq);<span></span></pre></td></tr><tr><td scope="row"><pre>void wait_queue_lock(wait_queue_t wq);<span></span></pre></td></tr><tr><td scope="row"><pre>void wait_queue_lock_try(wait_queue_t wq);<span></span></pre></td></tr><tr><td scope="row"><pre>void wait_queue_unlock(wait_queue_t wq);<span></span></pre></td></tr><tr><td scope="row"><pre>boolean_t wait_queue_member(wait_queue_t wq, wait_queue_sub_t wq_sub);<span></span></pre></td></tr><tr><td scope="row"><pre>boolean_t wait_queue_member_locked(wait_queue_t wq, wait_queue_sub_t  wq_sub);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_link(wait_queue_t wq, wait_queue_sub_t  wq_sub);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_unlink(wait_queue_t wq, wait_queue_sub_t  wq_sub);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_unlink_one(wait_queue_t wq,<span></span></pre></td></tr><tr><td scope="row"><pre>            wait_queue_sub_t *wq_subp);<span></span></pre></td></tr><tr><td scope="row"><pre>void wait_queue_assert_wait(wait_queue_t wq, event_t event,<span></span></pre></td></tr><tr><td scope="row"><pre>            int interruptible);<span></span></pre></td></tr><tr><td scope="row"><pre>void wait_queue_assert_wait_locked(wait_queue_t wq, event_t event,<span></span></pre></td></tr><tr><td scope="row"><pre>            int interruptible, boolean_t unlocked);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_wakeup_all(wait_queue_t wq, event_t event,<span></span></pre></td></tr><tr><td scope="row"><pre>            int result);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_peek_locked(wait_queue_t wq, event_t event,<span></span></pre></td></tr><tr><td scope="row"><pre>            thread_t *tp, wait_queue_t *wqp);<span></span></pre></td></tr><tr><td scope="row"><pre>void wait_queue_pull_thread_locked(wait_queue_t wq, thread_t thread,<span></span></pre></td></tr><tr><td scope="row"><pre>            boolean_t unlock);<span></span></pre></td></tr><tr><td scope="row"><pre>thread_t wait_queue_wakeup_identity_locked(wait_queue_t wq, event_t  event,<span></span></pre></td></tr><tr><td scope="row"><pre>            int result, boolean_t unlock);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_wakeup_one(wait_queue_t wq, event_t event,<span></span></pre></td></tr><tr><td scope="row"><pre>            int result);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_wakeup_one_locked(wait_queue_t wq, event_t  event,<span></span></pre></td></tr><tr><td scope="row"><pre>            int result, boolean_t unlock);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_wakeup_thread(wait_queue_t wq, event_t  event,<span></span></pre></td></tr><tr><td scope="row"><pre>            thread_t thread, int result);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_wakeup_thread_locked(wait_queue_t wq, event_t  event,<span></span></pre></td></tr><tr><td scope="row"><pre>            thread_t thread, int result, boolean_t unlock);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t wait_queue_remove(thread_t thread);<span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_610"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_611"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_612"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_613"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_614"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_615"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_616"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_617"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_618"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_619"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_620"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_621"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_622"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_623"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_624"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_625"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_626"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_627"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_628"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_629"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_630"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_631"></a>Most of the functions and their arguments are straightforward and are not presented in detail. However, a few require special attention.</p>
<p>Most of the functions take an event_t as an argument. These can be arbitrary 32-bit values, which leads to the potential for conflicting events on certain wait queues. The traditional way to avoid this problem is to use the address of a data object that is somehow related to the code in question as that 32-bit integer value.</p>
<p>For example, if you are waiting for an event that indicates that a new block of data has been added to a ring buffer, and if that ring buffer’s head pointer was called <code>rb_head</code>, you might pass the value <code>&amp;rb_head</code> as the event ID. Because wait queue usage does not generally cross address space boundaries, this is generally sufficient to avoid any event ID conflicts.</p>
<p>Notice the functions ending in <code>_locked</code>. These functions require that your thread be holding a lock on the wait queue before they are called. Functions ending in <code>_locked</code> are equivalent to their nonlocked counterparts (where applicable) except that they do not lock the queue on entry and may not unlock the queue on exit (depending on the value of <code>unlock</code>). The remainder of this section does not differentiate between locked and unlocked functions.</p>
<p>The <code><!--a-->wait_queue_alloc<!--/a--></code> and <code><!--a-->wait_queue_init<!--/a--></code> functions take a policy parameter, which can be one of the following:</p>
<ul class="spaceabove"><li class="li"><p><code><!--a  -->SYNC_POLICY_FIFO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_632"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_633"></a>—first-in, first-out</p></li>
<li class="li"><p><code><!--a  -->SYNC_POLICY_FIXED_PRIORITY<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_634"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_635"></a>—policy based on thread priority</p></li>
<li class="li"><p><code><!--a  -->SYNC_POLICY_PREPOST<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_636"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_637"></a>—keep track of number of wakeups where no thread was waiting and allow threads to immediately continue executing without waiting until that count reaches zero. This is frequently used when implementing semaphores.</p></li></ul>
<p>You should not use the <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_638"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_639"></a><code><!--a-->wait_queue_init<!--/a--></code> function outside the scheduler. Because a wait queue is an opaque object outside that context, you cannot determine the appropriate size for allocation. Thus, because the size could change in the future, you should always use <code><!--a-->wait_queue_alloc<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_640"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_641"></a> and <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_642"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_643"></a><code><!--a-->wait_queue_free<!--/a--></code> unless you are writing code within the scheduler itself.</p>
<p>Similarly, the functions <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_644"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_645"></a><code><!--a-->wait_queue_member<!--/a--></code>, <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_646"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_647"></a><code><!--a-->wait_queue_member_locked<!--/a--></code>, <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_648"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_649"></a><code><!--a-->wait_queue_link<!--/a--></code>, <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_650"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_651"></a><code><!--a-->wait_queue_unlink<!--/a--></code>, and <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_652"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_653"></a><code><!--a-->wait_queue_unlink_one<!--/a--></code> are operations on subordinate queues, which are not exported outside the scheduler.</p>
<p>The function <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_654"></a><code><!--a-->wait_queue_member<!--/a--></code> determines whether a subordinate queue is a member of a queue.</p>
<p>The functions <code><!--a-->wait_queue_link<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_655"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_656"></a> and <code><!--a-->wait_queue_unlink<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_657"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_658"></a> link and unlink a given subordinate queue from its parent queue, respectively.</p>
<p>The function <code><!--a-->wait_queue_unlink_one<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_659"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_660"></a> unlinks the first subordinate queue in a given parent and returns it.</p>
<p>The function <code><!--a-->wait_queue_assert_wait<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_661"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_662"></a> causes the calling thread to wait on the wait queue until it is either interrupted (by a thread timer, for example) or explicitly awakened by another thread. The <code>interruptible</code> flag indicates whether this function should allow an asynchronous event to interrupt waiting.</p>
<p>The function <code><!--a-->wait_queue_wakeup_all<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_663"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_664"></a> wakes up all threads waiting on a given queue for a particular event.</p>
<p>The function <code><!--a-->wait_queue_peek_locked<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_665"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_666"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_667"></a> returns the first thread from a given wait queue that is waiting on a given event. It does not remove the thread from the queue, nor does it wake the thread. It also returns the wait queue where the thread was found. If the thread is found in a subordinate queue, other subordinate queues are unlocked, as is the parent queue. Only the queue where the thread was found remains locked.</p>
<p>The function <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_668"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_669"></a><code><!--a-->wait_queue_pull_thread_locked<!--/a--></code> pulls a thread from the wait queue and optionally unlocks the queue. This is generally used with the result of a previous call to <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_670"></a><code><!--a-->wait_queue_peek_locked<!--/a--></code>.</p>
<p>The function <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_671"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_672"></a><code><!--a-->wait_queue_wakeup_identity_locked<!--/a--></code> wakes up the first thread that is waiting for a given event on a given wait queue and starts it running but leaves the thread locked. It then returns a pointer to the thread. This can be used to wake the first thread in a queue and then modify unrelated structures based on which thread was actually awakened before allowing the thread to execute.</p>
<p>The function <a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_673"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_674"></a><code><!--a-->wait_queue_wakeup_one<!--/a--></code> wakes up the first thread that is waiting for a given event on a given wait queue.</p>
<p>The function <code><!--a-->wait_queue_wakeup_thread<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_675"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_676"></a> wakes up a given thread if and only if it is waiting on the specified event and wait queue (or one of its subordinates).</p>
<p>The function <code><!--a-->wait_queue_remove<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_677"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_678"></a> wakes a given thread without regard to the wait queue or event on which it is waiting<a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_679"></a><a name="//apple_ref/doc/uid/TP30000905-CH211-DontLinkElementID_680"></a>.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../vm/vm.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../contexts/contexts.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-11-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/KernelProgramming/scheduler/scheduler.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/KernelProgramming/scheduler/scheduler.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/KernelProgramming/scheduler/scheduler.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>