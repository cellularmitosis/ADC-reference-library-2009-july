<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Drawing Guide: Coordinate Systems and Transforms</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Coordinate Systems and Transforms"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003290-CH204" title="Coordinate Systems and Transforms"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290-CH201-SW1">Cocoa Drawing Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../GraphicsContexts/GraphicsContexts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Color/Color.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40003290-CH204-BCIDJJBI" title="Coordinate Systems and Transforms"></a><h1>Coordinate Systems and Transforms</h1><p>Coordinate spaces simplify the drawing code required to create complex interfaces. In a standard Mac OS X application, the window represents the base coordinate system for drawing, and all content must eventually be specified in that coordinate space when it is sent to the window server. For even simple interfaces, however, it is rarely convenient to specify coordinates relative to the window origin. Even the location of fixed items can change and require recalculation when the window resizes. This is where Cocoa makes things simple. </p><p>Each Cocoa view you add to a window maintains its own local coordinate system for drawing. Rather than convert coordinate values to window coordinates, you simply draw using the local coordinate system, ignoring any changes to the position of the view. Before sending your drawing commands to the window server, Cocoa automatically corrects coordinate values and puts them in the base coordinate space.</p><p>Even with the presence of local coordinate spaces, it is often necessary to change the coordinate space temporarily to affect certain behaviors. Changing the coordinate space is done using mathematical transformations (also known as transforms). Transforms convert coordinate values from one coordinate space to another. You can use transforms to alter the coordinate system of a view in a way that affects subsequent rendering calls, or you can use them to determine the location of points in the window or another view.  </p>
<p>The following sections provide information about how Cocoa manages the local coordinate systems of your views and how you can use transforms to affect your drawing environment. </p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIFCIHJ">Coordinate Systems Basics</a>
				
			<br/>
			
        
			
			
				<a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCICHEAF">Transform Basics</a>
				
			<br/>
			
        
			
			
				<a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIIJGAG">Using Transforms in Your Code</a>
				
			<br/>
			
        
			
			
				<a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-SW16">Flipped Coordinate Systems</a>
				
			<br/>
			
        
			
			
				<a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCICIJAJ">Doing Pixel-Exact Drawing</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIFCIHJ" title="Coordinate Systems Basics"></a><h2>Coordinate Systems Basics</h2>
<p>Cocoa and Quartz use the same base coordinate system model. Before you can draw effectively, you need to understand this coordinate space and how it affects your drawing commands. It also helps to know the ways in which you can modify the coordinate space to simplify your drawing code. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW2" title="Local Coordinate Systems"></a><h3>Local Coordinate Systems</h3>
<p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_851"></a>Cocoa uses a <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_852"></a>Cartesian coordinate system as its basic model for specifying coordinates. The <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_853"></a>origin in this system is located in the lower-left corner of the current drawing space, with positive values extending along the axes up and to the right of the origin point. The root origin for the entire system is located in the lower-left corner of the screen containing the menu bar<a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_854"></a>. </p>
<p>If you were forced to draw all your content in <strong>screen coordinates</strong>—the coordinate system whose origin is located at the lower-left corner of the computer’s primary screen—your code would be quite complex. To simplify things, Cocoa sets up a local coordinate system whose origin is equal to the origin of the window or view that is about to draw. Subsequent drawing calls inside the window or view take place relative to this local coordinate system. Once the code finishes drawing, Cocoa and the underlying graphics system convert coordinates in the local coordinates back to screen coordinates so that the content can be composited with content from other applications and sent to the graphics hardware.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH204-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp;If a computer has multiple monitors attached, those monitors can be set to mirror each other or to display one contiguous desktop. In mirroring mode, every screen has an origin of (0, 0), In contiguous mode, one screen has an origin of (0, 0) but other screens have an origin that is offset from that of the first screen.</p></div><p><span class="content_text">Figure 3-1</span> shows the coordinate-system origin points of the screen, a window, and a view. In each case, the value to the bottom-left of each point is the coordinate measured in its parent coordinate system. (The screen does not have a parent coordinate system, so both coordinate values are 0). The window’s parent is the screen and the view’s parent is the window. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-BCIDFFGE" title="Figure 3-1Screen, window, and view coordinate systems on the screen"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Screen, window, and view coordinate systems on the screen</p>
<img src = "../art/window_coordinate.jpg" alt = "Screen, window, and view coordinate systems on the screen" ></div><br/>
<p>Mapping from screen coordinates to local window or view coordinates takes place in the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_855"></a>current transformation matrix (<a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_856"></a>CTM) of the Cocoa graphics context object. Cocoa applies the CTM automatically to any drawing calls you make, so you do not need to convert coordinate values yourself. You can modify the CTM though to change the position and orientation of the coordinate axes inside your view. (For more information, see <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIGEJHE">“Transformation Operations.”</a></span>)</p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW5" title="Points Versus Pixels"></a><h3>Points Versus Pixels</h3><p>The drawing system in Mac OS X is based on a PDF drawing model, which is a vector-based drawing model. Compared to a raster-based drawing model, where drawing commands operate on individual pixels, drawing commands in Mac OS X are specified using a fixed-scale drawing space, known as the user coordinate space. The system then maps the coordinates in this drawing space onto the actual <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_857"></a>pixels of the corresponding target device, such as a monitor or printer. The advantage of this model is that graphics drawn using vector commands scale nicely to any resolution device. As the device resolution increases, the system is able to use any extra pixels to create a crisper look to the graphics.</p><p>In order to maintain the precision inherent with a vector-based drawing system, drawing <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_858"></a>coordinates are specified using floating-point values instead of integers. The use of floating-point values for Mac OS X coordinates makes it possible for you to specify the location of your program's content very precisely. For the most part, you do not have to worry about how those values are eventually mapped to the screen or other output device. Instead, Cocoa takes care of this mapping for you.</p><p>Even though the drawing model is based on PDF, there are still times when you need to render pixel-based content. Bitmap images are a common way to create user interfaces, and your drawing code may need to make special adjustments to ensure that any bitmap images are drawn correctly on different resolution devices. Similarly, you may want to ensure that even your vector-based graphics align properly along pixel boundaries so that they do not have an anti-aliased appearance. Mac OS X provides numerous facilities to help you draw pixel-based content the way you want it. </p>
<p>The following sections provide more detail about the coordinate spaces used for drawing and rendering content. There also follows some tips on how to deal with pixel-specific rendering in your drawing code. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW6" title="User Space"></a><h4>User Space</h4>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_859"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_860"></a>user coordinate space in Cocoa is the environment you use for all your drawing commands. It represents a fixed scale coordinate space, which means that the drawing commands you issue in this space result in graphics whose size is consistent regardless of the resolution of the underlying device. </p><p>Units in the user space are based on the printer's point, which was used in the publishing industry to measure the size of content on the printed page. A single <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_861"></a><strong>point</strong> is equivalent to 1/72 of an inch. Points were adopted by earlier versions of Mac OS as the standard resolution for content on the screen. Mac OS X continues to use the same effective “resolution” for user-space drawing. </p><p>Although a single point often corresponded directly to a <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_862"></a>pixel in the past, in Mac OS X, that may not be the case. Points are not tied to the resolution of any particular device. If you draw a rectangle whose width and height are exactly three points, that does not mean it will be rendered on the screen as a three-pixel by three-pixel rectangle.  On a 144 dpi screen, the rectangle might be rendered using six pixels per side, and on a 600-dpi printer, the rectangle would require 25 pixels per side. The actual translation from points to pixels is device dependent and handled for you automatically by Mac OS X. </p><p>For all practical purposes, the user coordinate space is the only coordinate space you need to think about. There are some exceptions to this rule, however, and those are covered in <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCICIJAJ">“Doing Pixel-Exact Drawing.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW7" title="Device Space"></a><h4>Device Space</h4>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_863"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_864"></a>device coordinate space refers to the native coordinate space used by the target device, whether it be a screen, printer, file, or some other device. Units in the device coordinate space are specified using pixels and the resolution of this space is device dependent. For example, most monitors have resolutions in the 100 dpi range but printers may have resolutions exceeding 600 dpi. There are some devices that do not have a fixed resolution, however. For example, PDF and EPS files are resolution independent and can scale their content to any resolution. </p>
<p>For Cocoa users, the device coordinate space is something you rarely have to worry about. Whenever you generate drawing commands, you always specify positions using user space coordinates. The only time that you might need to know about device space coordinates is when you are adjusting your drawn content to map more cleanly to a specific target device. For example, you might use device coordinates to align a path or image to specific pixel boundaries in order to prevent unwanted <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_865"></a>anti-aliasing. In such a situation, you can adjust your user space coordinates based on the resolution of the underlying device. For information on how to do this, see <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCICIJAJ">“Doing Pixel-Exact Drawing”</a></span></p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW1" title="Resolution-Independent User Interface"></a><h3>Resolution-Independent User Interface</h3>
<p>In Mac OS X v10.4 and earlier, Quartz and Cocoa always treated screen devices as if their <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_866"></a>resolution were always 72 dpi, regardless of their actual resolution. This meant that for screen-based drawing, one point in user space was always equal to one pixel in device space. As screens advanced well past 100 dpi in resolution, the assumption that one point equaled one pixel began to cause problems. Most noticeably, everything became much smaller. In Mac OS X v10.4, the first steps at decoupling the point-pixel relationship took place.</p>
<p>In Mac OS X v10.4, support was added for <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_867"></a>resolution independence in application user interfaces. The initial implementation of this feature provides a way for you to decouple your application’s user space from the underlying device space manually. You do this by choosing a scale factor for your user interface. The scale factor causes user space content to be scaled by the specified amount. Code that is implemented properly for resolution independence should look fine (albeit bigger). Code that is not implemented properly may see alignment problems or pixel cracks along shape boundaries. To enable resolution independence in your application, launch <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_868"></a>Quartz Debug and choose Tools > Show User Interface Resolution, then set your scale factor. After changing the resolution, relaunch your application to see how it responds to the new resolution.</p>
<p>For the most part, Cocoa applications should not have to do anything special to handle <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_869"></a>resolution-independent UI. If you use the standard Cocoa views and drawing commands to draw your content, Cocoa automatically scales any content you draw using the current scale factor. For path-based content, your drawing code should require little or no changes. For <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_870"></a>images, though, you may need to take steps to make sure those images look good at higher scale factors. For example, you might need to create higher-resolution versions to take advantage of the increased screen resolution. You might also need to adjust the position of images to avoid pixel cracks caused by images being drawn on nonintegral pixel boundaries.</p><p>For tips on how to make sure your content draws well at any resolution, see <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCICIJAJ">“Doing Pixel-Exact Drawing.”</a></span> For more information about resolution independence and how it affects your code, see <em><a href="../../../../UserExperience/Conceptual/HiDPIOverview/index.html#//apple_ref/doc/uid/TP40003409" target="_top">Resolution Independence Guidelines</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCICHEAF" title="Transform Basics"></a><h2>Transform Basics</h2>
<p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_871"></a>Transforms are a tool for manipulating coordinates (and coordinate systems) quickly and easily in your code. Consider a rectangle whose origin is at (0, 0). If you wanted to change the origin of this rectangle to (10, 3), it would be fairly simple to modify the rectangle’s origin and draw it. Suppose, though, that you wanted to change the origin of a complex path that incorporated dozens of points and several Bezier curves with their associated control points. How easy would it be to recalculate the position of each point in that path? It would probably take a lot of time and require some pretty sophisticated calculations. Enter transforms. </p>
<p>A transform is two-dimensional mathematical array used to map points from one coordinate space to another. Using transforms, you can scale, rotate, and translate content freely in two-dimensional space using only a few methods and undo your changes just as quickly. </p>
<p>Support for transforms in Cocoa is provided by the <code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAffineTransform" target="_top">NSAffineTransform</a></code> class. The following sections provide background information about transforms and their effects. For additional information about how to use transforms in your code, see <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIIJGAG">“Using Transforms in Your Code.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW8" title="The Identity Transform"></a><h3>The Identity Transform</h3>
<p>The simplest type of transform is the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_872"></a>identity <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_873"></a>transform. An identity transform maps any point to itself—that is, it does not transform the point at all. You always start with an identity transform and add transformations to it. Starting with the identity transform guarantees that you start from a known state. To create an identity transform, you would use the following code:</p>
<div class="codesample"><table><tr><td scope="row"><pre>NSAffineTransform* identityXform = [NSAffineTransform transform];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIGEJHE" title="Transformation Operations"></a><h3>Transformation Operations</h3>
<p>For two-dimensional drawing, you can transform content in several different ways, including translating, scaling, and rotating. Transforms modify the coordinate system for the current drawing environment and affect all subsequent drawing operations. Before applying a transform, it is recommended that you save the current graphics state. </p>
<p>The following sections describe each type of transformation and how it affects rendered content. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW9" title="Translation"></a><h4>Translation</h4>
<p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_874"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_875"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_876"></a>Translation involves shifting the origin of the current coordinate system horizontally and vertically by a specific amount. Translation is probably used the most because it can be used to position graphic elements in the current view. For example, if you create a path whose starting point is always (0, 0), you could use a translation transform to move that path around your view, as shown in <span class="content_text">Figure 3-2</span>. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-BCIEGEHE" title="Figure 3-2Translating content"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>Translating content</p>
<img src = "../art/translation.gif" alt = "Translating content" width="516" height="228"></div><br/>
<p>To translate content, use the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_877"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/translateXBy:yBy:" target="_top">translateXBy:yBy:</a></code> method of <code>NSAffineTransform</code>. The following example changes the origin of the current context from (0, 0) to (50, 20) in the view's coordinate space:</p>
<div class="codesample"><table><tr><td scope="row"><pre>NSAffineTransform* xform = [NSAffineTransform transform];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform translateXBy:50.0 yBy:20.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform concat];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW10" title="Scaling"></a><h4>Scaling</h4>
<p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_878"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_879"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_880"></a>Scaling lets you stretch or shrink the units of the user space along the x and y axes independently. Normally, one unit in user space is equal to 1/72 of an inch. If you multiple the scale of either axis by 2, one unit on that axis becomes equal to 2/72 of an inch. This makes content drawn with scale factors greater than 1 appear magnified and content drawn with scale factors less than 1 appear shrunken. </p>
<p><span class="content_text">Figure 3-3</span> shows the effects of scaling on content. In the figure, a translation transform has already been applied so that the origin is located at (1, 1) in the original user space coordinate system. After applying the scaling transform, you can see the modified coordinate system and how it maps to the original coordinate system. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-BCICACAH" title="Figure 3-3Scaling content"></a><p><strong>Figure 3-3&nbsp;&nbsp;</strong>Scaling content</p><img src = "../art/scaling.gif" alt = "Scaling content" width="426" height="221"></div><br/>
<p>Although you might normally scale proportionally by applying the same scale factor to both the horizontal and vertical axes, you can assign different scale factors to each axis to create a stretched or distorted image. To scale content proportionally, use the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_881"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/scaleBy:" target="_top">scaleBy:</a></code> method of <code>NSAffineTransform</code>. To scale content differently along the X and Y axes, use the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_882"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/scaleXBy:yBy:" target="_top">scaleXBy:yBy:</a></code> method. The following example demonstrates the scale factors shown in <span class="content_text">Figure 3-3</span>:</p>
<div class="codesample"><table><tr><td scope="row"><pre>NSAffineTransform* xform = [NSAffineTransform transform];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform scaleXBy:2.0 yBy:1.5];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform concat];<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH204-SW11" title="Note"></a><p><strong>Note:</strong>&nbsp;Scaling does not change the origin of the coordinate system.</p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW12" title="Rotation"></a><h4>Rotation</h4>
<p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_883"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_884"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_885"></a>Rotation changes the orientation of the coordinate axes by rotating them around the current origin, as shown in <span class="content_text">Figure 3-4</span>. You can change the orientation through a full circle of motion. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-BCICBIEA" title="Figure 3-4Rotated content"></a><p><strong>Figure 3-4&nbsp;&nbsp;</strong>Rotated content</p><img src = "../art/rotation.gif" alt = "Rotated content" width="508" height="215"></div><br/>
<p>To rotate content, use the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_886"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/rotateByDegrees:" target="_top">rotateByDegrees:</a></code> or <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_887"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/rotateByRadians:" target="_top">rotateByRadians:</a></code> methods of <code>NSAffineTransform</code>. Positive rotation values proceed counterclockwise around the current origin. For example, to rotate the current coordinate system 45 degrees around the current origin point (as shown in <span class="content_text">Figure 3-4</span>), you would use the following code:</p>
<div class="codesample"><table><tr><td scope="row"><pre>NSAffineTransform* xform = [NSAffineTransform transform];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform rotateByDegrees:45];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform concat];<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH204-SW13" title="Note"></a><p><strong>Note:</strong>&nbsp;Combining a non-uniform scaling transform with a rotation transform can also give your content a skewed effect.</p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW14" title="Transformation Ordering"></a><h3>Transformation Ordering</h3>
<p>The implementation of <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_888"></a>transforms uses matrix multiplication to map an incoming coordinate point to a modified coordinate space. Although the mathematics of matrices are covered in <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIIICJI">“Transform Mathematics,”</a></span> an important factor to note is that matrix multiplication is not always a commutative operation—that is, <code>a</code> times <code>b</code> does not always equal <code>b</code> times <code>a</code>. Therefore, the order in which you apply transforms is often crucial to achieving the desired results.</p>
<p><span class="content_text">Figure 3-5</span> shows the two transformations applied to a path in two different ways. In the top part of the figure, the content is translated by 60 points along the X axis and then rotated 45 degrees. In the bottom part of the figure, the exact same transformations are reversed with the rotation preceding the translation. The end result is two different coordinate systems.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-BCIBBIJA" title="Figure 3-5Transform ordering"></a><p><strong>Figure 3-5&nbsp;&nbsp;</strong>Transform ordering</p>
<img src = "../art/transform_multiple.gif" alt = "Transform ordering" width="655" height="560"></div><br/>
<p>The preceding figure demonstrates the key aspect of transformation ordering. Each successive transformation is applied to the coordinate system created by the previous transformations. When you translate and then rotate, the rotation begins around the origin of the translated coordinate system. Similarly, when you rotate and then translate, the translation occurs along the axes of the rotated coordinate system.</p>
<p>For transformations of the same type, the order of the transformations does not matter. For example, three rotations in a row creates a coordinate system whose final rotation is equal to the final sum of the three rotation angles. There may be other cases (such as scaling by 1.0) where the order of the transforms does not matter, but you should generally assume that order is significant.  </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIIICJI" title="Transform Mathematics"></a><h3>Transform Mathematics</h3>
<p>All <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_889"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_890"></a>transform operations contribute to the building of a mathematical <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_891"></a>matrix that is then used by the graphics system to compute the screen location of individual points. The <code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAffineTransform" target="_top">NSAffineTransform</a></code> class uses a 3 x 3 matrix to store the transform values. <span class="content_text">Figure 3-6</span> shows this matrix and identifies the key factors used to apply transforms. The <em>m11</em>, <em>m12</em>, <em>m21</em>, and <em>m22</em> values control both the scaling and rotation factors while t<sub>x</sub> and t<sub>y</sub> control translation.  </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-BCIBGCAA" title="Figure 3-6Basic transformation matrix"></a><p><strong>Figure 3-6&nbsp;&nbsp;</strong>Basic transformation matrix</p>
<img src = "../art/equation01.gif" alt = "Basic transformation matrix" width="100" height="93"></div><br/>
<p>Using linear algebra, it is possible to multiply a coordinate vector through the transform matrix to obtain a new coordinate vector whose position is equal to the original point in the new coordinate system. <span class="content_text">Figure 3-7</span> shows the matrix multiplication process and the resulting linear equations. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-BCIBCIIG" title="Figure 3-7Mathematical conversion of coordinates"></a><p><strong>Figure 3-7&nbsp;&nbsp;</strong>Mathematical conversion of coordinates</p>
<img src = "../art/equation02.gif" alt = "Mathematical conversion of coordinates" width="291" height="203"></div><br/>
<p>If you are already familiar with transform structures and the mathematics, you can set the values of a transform matrix directly using the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_892"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/setTransformStruct:" target="_top">setTransformStruct:</a></code> method of <code>NSAffineTransform</code>. This method replaces the six key transform values with the new ones you specify. Replacing all of the values at once is much faster than applying individual transformations one at a time. It does require you to precompute the matrix values, however.</p>
<p>For more information about the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_893"></a>mathematics behind matrix multiplications, see <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIIJGAG" title="Using Transforms in Your Code"></a><h2>Using Transforms in Your Code</h2>
<p>When it is time to draw, the code in your view’s <code>drawRect:</code> method must determine where to draw individual pieces of content. The position of some elements, such as images and rectangles, can be specified easily, but for complex elements like paths, transforms are an easy way to change the current drawing location.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIHIFEA" title="Creating and Applying a Transform"></a><h3>Creating and Applying a Transform</h3>
<p>To create a new <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_894"></a>transform object, call the <code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/clm/NSAffineTransform/transform" target="_top">transform</a></code> class method of <code>NSAffineTransform</code>. The returned transform object is set to the identity transform automatically. After you have added all of the desired transformations to the transform object, you call the <code>concat</code> method to apply them to the current context. Calling <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_895"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSAffineTransform_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/concat" target="_top">concat</a></code> adds your transformations to the CTM of the current graphics context. The modifications stay in effect until you explicitly undo them, as described in <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIJGDAA">“Undoing a Transformation,”</a></span> or a previous graphics state is restored.</p>
<p>The following example creates a new transform object and adds several transformations to it. </p>
<div class="codesample"><table><tr><td scope="row"><pre>NSAffineTransform* xform = [NSAffineTransform transform];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Add the transformations<span></span></pre></td></tr><tr><td scope="row"><pre>[xform translateXBy:50.0 yBy:20.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform rotateByDegrees:90.0]; // counterclockwise rotation<span></span></pre></td></tr><tr><td scope="row"><pre>[xform scaleXBy:1.0 yBy:2.0];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Apply the changes<span></span></pre></td></tr><tr><td scope="row"><pre>[xform concat];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIJGDAA" title="Undoing a Transformation"></a><h3>Undoing a Transformation</h3>
<p>Once applied, a <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_896"></a>transform affects all subsequent drawing calls in the current context. To undo a set of transformations, you can either restore a previous graphics state or apply an inverse transform. Both techniques have their advantages and disadvantages, so you should choose a technique based on your needs and the available information.</p>
<p>Restoring a previous <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_897"></a>graphics state is the simplest way to undo a transformation but has other side effects. In addition to undoing the transform, restoring the graphics state reverts all other attributes in the current drawing environment back to their previous state. </p>
<p>If you want to undo only the current transformation, you can add an <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_898"></a>inverse transform to the CTM. An inverse transform negates the effects of a given set of transformations using a complementary set of transformations. To create an inverse transform object, you use the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_899"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/invert" target="_top">invert</a></code> method of the desired transform object. You then apply this modified transform object to the current context, as shown in the following example:</p>
<div class="codesample"><table><tr><td scope="row"><pre>NSAffineTransform* xform = [NSAffineTransform transform];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Add the transformations<span></span></pre></td></tr><tr><td scope="row"><pre>[xform translateXBy:50.0 yBy:20.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform rotateByDegrees:90.0]; // counterclockwise rotation<span></span></pre></td></tr><tr><td scope="row"><pre>[xform concat];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Draw content...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Remove the transformations by applying the inverse transform.<span></span></pre></td></tr><tr><td scope="row"><pre>[xform invert];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform concat];<span></span></pre></td></tr></table></div>
<p>You might use this latter technique to draw multiple items using the same drawing attributes but at different positions in your view. Depending on the type of transformations you use, you might also be able to do incremental transformations. For example, if you are calling <code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/translateXBy:yBy:" target="_top">translateXBy:yBy:</a></code> only to reposition the origin, you could move the origin incrementally for each successive item. The following example, shows how you might position one item at (10, 10) and the next at (15, 10):</p>
<div class="codesample"><table><tr><td scope="row"><pre>[NSAffineTransform* xform = [NSAffineTransform transform];<span></span></pre></td></tr><tr><td scope="row"><pre>// Draw item 1<span></span></pre></td></tr><tr><td scope="row"><pre>[xform translateXBy:10.0 yBy:10.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[xform concat];<span></span></pre></td></tr><tr><td scope="row"><pre>[item1 draw];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Draw item 2<span></span></pre></td></tr><tr><td scope="row"><pre>[xform translateXBy:5.0 yBy:0.0]; // Translate relative to the previous  element.<span></span></pre></td></tr><tr><td scope="row"><pre>[xform concat];<span></span></pre></td></tr><tr><td scope="row"><pre>[item2 draw];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div>
<p>Remember that the preceding techniques are used in cases where you do not want to modify your original items directly. Cocoa provides ways to modify geometric coordinates without modifying the current transformation matrix. For more information, see <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIJDDBA">“Transforming Coordinates.”</a></span> </p><p>It is also worth noting that the effectiveness of an inverse transform is limited by mathematical <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_900"></a>precision. For rotation transforms, which involve taking sines and cosines of the desired rotation angle, an inverse transform may not be precise enough to undo the original rotation completely. In such a situation, you may want to simply save and restore the graphics state to undo the transform. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIJDDBA" title="Transforming Coordinates"></a><h3>Transforming Coordinates</h3>
<p>If you do not want to change the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_901"></a>coordinate system of the current drawing environment, but do want to change the position or orientation of a single object, you have several options. The <code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAffineTransform" target="_top">NSAffineTransform</a></code> class includes the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_902"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/transformPoint:" target="_top">transformPoint:</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_903"></a><code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/transformSize:" target="_top">transformSize:</a></code> methods for changing coordinate values directly. Using these methods does not change the CTM of the current graphics context. </p>
<p>If you want to alter the coordinates in a <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_904"></a>path, you can do so using the <code><a href="../../../Reference/ApplicationKit/Classes/NSAffineTransform_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/instm/NSAffineTransform/transformBezierPath:" target="_top">transformBezierPath:</a></code> method of <code>NSAffineTransform</code>. This method returns a transformed copy of the specified Bezier path object. This method differs slightly from the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_905"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/transformUsingAffineTransform:" target="_top">transformUsingAffineTransform:</a></code> method of <code>NSBezierPath</code>, which modifies the original object. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW15" title="Converting from Window to View Coordinates"></a><h3>Converting from Window to View Coordinates</h3>
<p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_906"></a>Events sent to your <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_907"></a>view by the operating system are sent using the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_908"></a>coordinate system of the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_909"></a>window. Before your view can use any coordinate values included with the event, it must convert those coordinates to its own local coordinate space. The <code>NSView</code> class provides several functions to facilitate the conversion of <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSPoint" target="_top">NSPoint</a></code>, <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSSize" target="_top">NSSize</a></code>, and <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSRect" target="_top">NSRect</a></code> structures. Among these methods are <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_910"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertPoint:fromView:" target="_top">convertPoint:fromView:</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_911"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertPoint:toView:" target="_top">convertPoint:toView:</a></code>, which convert points to and from the view’s local coordinate system. For a complete list of conversion methods, see <em><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/index.html#//apple_ref/doc/uid/TP40004149" target="_top">NSView Class Reference</a></em>. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_19" title="Important:"></a><p><strong>Important:</strong>&nbsp;Cocoa event objects return y coordinate values that are 1-based instead of 0-based. Thus, a mouse click on the bottom left corner of a window or view would yield the point (0, 1) in Cocoa and not (0, 0). Only y-coordinates are 1-based.</p><p></p></div>
<p>The following example converts the mouse location of a mouse event from window coordinates to the coordinates of the local view. To convert to the view’s local coordinate space, you use the <code>convertPoint:fromView:</code> method. The second parameter to this method specifies the view in whose coordinate system the point is currently specified. Specifying <code>nil</code> for the second parameter tells the current view to convert the point from the window’s coordinate system. </p>
<div class="codesample"><table><tr><td scope="row"><pre>NSPoint  mouseLoc = [theView convertPoint:[theEvent locationInWindow] fromView:nil];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40003290-CH204-SW16" title="Flipped Coordinate Systems"></a><h2>Flipped Coordinate Systems</h2><p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_912"></a>One topic that comes up frequently in Cocoa and Quartz is the use of flipped <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_913"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_914"></a>coordinate systems for drawing. By default, Cocoa uses a standard Cartesian coordinate system, where positive values extend up and to the right of the origin. It is possible, however, to “flip” the coordinate system, so that positive values extend down and to the right of the origin and the origin itself is positioned in the top-left corner of the current view or window, as shown in <span class="content_text">Figure 3-8</span>. </p><br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-BCIJADAG" title="Figure 3-8Normal and flipped coordinate axes"></a><p><strong>Figure 3-8&nbsp;&nbsp;</strong>Normal and flipped coordinate axes</p><img src = "../art/flipped_coordinates.gif" alt = "Normal and flipped coordinate axes" width="264" height="445"></div><br/><p>Flipping the coordinate system can make drawing easier in some situations. Text systems in particular use flipped coordinates to simplify the placement of text lines, which flow from top to bottom in most writing systems. Although you are encouraged to use the standard Cartesian (unflipped) coordinate system whenever possible, you can use flipped coordinates if doing so is easier to support in your code. </p><p>Configuring a view to use flipped coordinates affects only the content you draw directly in that view. Flipped coordinate systems are not inherited by child views. The content you draw in a view, however, must be oriented correctly based on the current orientation of the view. Failing to take into account the current view orientation may result in incorrectly positioned content or content that is upside down. </p><p>The following sections provide information about Cocoa support for flipped coordinates and some of the issues you may encounter when using flipped coordinate systems. Wherever possible, these sections also offer guidance on how to solve issues that arise due to flipped coordinate systems.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW17" title="Configuring Your View to Use Flipped Coordinates"></a><h3>Configuring Your View to Use Flipped Coordinates</h3><p>The first step you need to take to implement flipped coordinates is to decide the default orientation of your view. If you prefer to use flipped coordinates, there are two ways to configure your view’s coordinate system prior to drawing:</p><ul class="spaceabove"><li class="li"><p>Override your view’s <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/isFlipped" target="_top">isFlipped</a></code> method and return <code>YES</code>.</p></li><li class="li"><p>Apply a flip transform to your content immediately prior to rendering.</p></li></ul><p>If you plan to draw all of your view’s content using flipped coordinates, overriding the view’s <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_915"></a><code>isFlipped</code> method is by far the preferred option. Overriding this method lets Cocoa know that your view wants to use flipped coordinates by default. When a view’s <code>isFlipped</code> method returns <code>YES</code>, Cocoa automatically makes several adjustments for you. The most noticeable change is that Cocoa adds the appropriate <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_916"></a>conversion transform to the CTM before calling your view’s <code>drawRect:</code> method. This behavior eliminates the need for your drawing code to apply a flip transform manually. In addition, many Cocoa objects automatically adjust their drawing code to account for the coordinate system of the current view. For example, the <code>NSFont</code> object automatically takes the orientation of the coordinate system into account when setting the current font. This prevents text from appearing upside down when drawn in your view.</p><p>If you draw only a subset of your view’s content using flipped coordinates, you can use a flip transform (instead of overriding <code>isFlipped</code>) to modify the coordinate system manually. A flip transform lets you adjust the current coordinate system temporarily and then undo that adjustment when it is no longer needed. You would apply this transform to your view’s coordinate system immediately prior to drawing the relevant flipped content. For information on how to create a flip transform, see <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIHDAIJ">“Creating a Flip Transform.”</a></span>  </p><a name="//apple_ref/doc/uid/TP40003290-CH204-SW18" title="Drawing Content in a Flipped Coordinate System"></a><h3>Drawing Content in a Flipped Coordinate System</h3><p>Most of the work you do to support flipped coordinates occurs within your application’s drawing code. If you chose to use flipped coordinates in a particular view, chances are it was because it made your drawing code easier to implement. Drawing in a flipped coordinate system requires you to position elements differently relative to the screen but is otherwise  fairly straightforward. The following sections provide some tips to help you ensure any rendered content appears the way you want it. </p><a name="//apple_ref/doc/uid/TP40003290-CH204-SW19" title="Drawing Shape Primitives"></a><h4>Drawing Shape Primitives</h4><p>There are no real issues with drawing shape primitives in flipped coordinate systems. Shape primitives, such as rectangles, ovals, arcs, and Bezier curves can be drawn just as easily in flipped or unflipped coordinate systems. The only differences between the two coordinate systems is where the shapes are positioned and their vertical orientation. Laying out your shapes in advance to determine their coordinate points should solve any orientation issues you encounter.</p><a name="//apple_ref/doc/uid/TP40003290-CH204-SW20" title="Drawing With Application Kit Functions"></a><h4>Drawing With Application Kit Functions</h4><p>The Application Kit framework contains numerous functions for quickly drawing specific content. Among these functions are <code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectFill" target="_top">NSRectFill</a></code>, <code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSFrameRect" target="_top">NSFrameRect</a></code>, <code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSDrawGroove" target="_top">NSDrawGroove</a></code>, <code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSDrawLightBezel" target="_top">NSDrawLightBezel</a></code>, and so on. When drawing with these functions, Cocoa takes into account the orientation of the target view. Thus, if your view uses flipped coordinates, these functions continue to render correctly in that flipped coordinate space. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW21" title="Drawing Images"></a><h4>Drawing Images</h4>
<p>When rendering images in your custom views, you must pay attention to the relative orientation of your view and any <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_917"></a>images you draw in that view. If you draw an image in a flipped view using the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/drawInRect:fromRect:operation:fraction:" target="_top">drawInRect:fromRect:operation:fraction:</a></code> method, your image would appear upside down in your view. You could fix this problem using one of several techniques:</p><ul class="spaceabove"><li class="li"><p>You could apply a flip transform immediately prior to drawing the image; see <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIHDAIJ">“Creating a Flip Transform.”</a></span> </p></li><li class="li"><p>You could use one of the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_918"></a><code>compositeToPoint</code> methods of <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> to do the drawing.</p></li><li class="li"><p>You could invert the image data itself. (Although a suitable fix, this is usually not very practical.)</p></li></ul><p>Using a flip transform to negate the effects of a flipped view ensures that your image contents are rendered correctly in all cases. This technique retains any previous transformations to the coordinate system, including scales and rotations, but removes the inversion caused by the view being flipped. You should especially use this technique if you needed to draw your image using the <code>drawInRect:fromRect:operation:fraction:</code> method of <code>NSImage</code>. This method lets you scale your image to fit the destination rectangle and is one of the more commonly used drawing methods for images. </p><p>Although the <code>compositeToPoint</code> methods of <code>NSImage</code> provide you with a way to orient images properly without a flip transform, their use is not recommended. There are some side effects that make drawing with these methods more complicated. The <code>compositeToPoint</code> methods work by removing any custom scaling or rotation factors that you applied to the CTM. These methods also remove any scaling (but not translations) applied by any flip transforms, whether the transform was supplied by you or by Cocoa. (The methods also do not remove the scale factor in effect from resolution independence.) Any custom translation factors you applied to the CTM are retained, however. Although this behavior is designed to ensure that images are not clipped by your view’s bounding rectangle, if you do not compensate for the flip transform’s translation factor, clipping may still occur. </p><p><span class="content_text">Figure 3-9</span> shows what happens when you render an image in an unflipped view, and then in a flipped view, using the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/compositeToPoint:fromRect:operation:" target="_top">compositeToPoint:fromRect:operation:</a></code> method. In the unflipped view, the image renders as expected at the specified point in the view. In the flipped view, the scale factor for the y-axis is removed but the translation factor is not, which results in the image being clipped because it appears partially outside the view’s visible bounds. To compensate, you would need to adjust the y-origin of the image by subtracting the original value from the view height to get the adjusted position.  </p><br/><div><a name="//apple_ref/doc/uid/TP40003290-CH204-SW3" title="Figure 3-9Compositing an image to a flipped view"></a><p><strong>Figure 3-9&nbsp;&nbsp;</strong>Compositing an image to a flipped view</p><img src = "../art/flipped_views.jpg" alt = "Compositing an image to a flipped view" ></div><br/><p>The issues related to the drawing of images in a flipped coordinate system are essentially independent of how you create those images in the first place. Images use a separate coordinate system internally to orient the image data. Whether you load the image data from an existing file or create the image by locking focus on it, once the image data is loaded or you unlock focus, the image data is set. At that point, you must choose the appropriate drawing method or adjust the coordinate system yourself prior to drawing to correct for flipped orientation issues. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_20" title="Important:"></a><p><strong>Important:</strong>&nbsp;Although the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setFlipped:" target="_top">setFlipped:</a></code> method of <code>NSImage</code> might seem like a good way to change the orientation of an image after the fact, that is not actually the case. The <code>setFlipped:</code> method is there to let you specify the orientation of the image data before you issue a <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/lockFocus" target="_top">lockFocus</a></code> call and draw into the image. Using that method to correct for flipped coordinate systems during drawing might seem to work at times, but it is not a reliable way to flip images and its use in that capacity is highly discouraged.</p><p></p></div><p>For more information about images and their internal coordinate systems, see <span class="content_text"><a href="../Images/Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIBCHBA">“Image Coordinate Systems.”</a></span> </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_21" title="Important:"></a><p><strong>Important:</strong>&nbsp;Regardless of whether the contents of the image are flipped or unflipped, you always specify the location and size of the image using the coordinate system of the current context.</p><p></p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW22" title="Drawing Text"></a><h4>Drawing Text</h4>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_919"></a>text rendering facilities in Cocoa take their cues for text orientation from the current view. If your view’s <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/isFlipped" target="_top">isFlipped</a></code> method returns <code>YES</code>, Cocoa automatically inverts the text drawn in that view to compensate for its flipped coordinate system. If you apply a flip transform manually from your drawing code, however, Cocoa does not know to compensate when drawing text. Any text you render after applying a flip transform manually therefore appears upside down in your view. These rules apply whether you are using the Cocoa text system or the drawing facilities of <code>NSString</code> to draw your text. </p><p>If you lock focus on an image and draw some text into it, Cocoa uses the internal coordinate system of the <code>NSImage</code> object to determine the correct orientation for the text. As with other image content, if you subsequently render the image in a flipped view, the text you drew is flipped along with the rest of the image data.</p>
<p>For more information about working with text, see <span class="content_text"><a href="../Text/Text.html#//apple_ref/doc/uid/TP40003290-CH209-BCIEEIGC">“Text.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIHDAIJ" title="Creating a Flip Transform"></a><h3>Creating a Flip Transform</h3>
<p>If you want to <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_920"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_921"></a>flip the coordinate system of your view temporarily, you can create a flip transform and apply it to the current graphics context. A flip transform is an <code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAffineTransform" target="_top">NSAffineTransform</a></code> object configured with two transformations: a scale transformation and a translate transformation. The flip transform works by flipping the direction of the y axis (using the scale transformation) and then translating the origin to the top of the view. </p>
<p><span class="content_text">Listing 3-1</span> shows a <code>drawRect:</code> method that creates a flip transform and applies it to the current context. The flip transform shown here translates the origin first before reversing the direction of the vertical axis. You could also implement this transform by reversing the vertical axis first and then translating the origin in the negative direction—that is, using the negated value of the frame height. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCIFJFEA" title="Listing 3-1Flipping the coordinate system manually"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Flipping the coordinate system manually</p>
<div class="codesample"><table><tr><td scope="row"><pre>- (void)drawRect:(NSRect)rect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect frameRect = [self bounds];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAffineTransform* xform = [NSAffineTransform transform];<span></span></pre></td></tr><tr><td scope="row"><pre>    [xform translateXBy:0.0 yBy:frameRect.size.height];<span></span></pre></td></tr><tr><td scope="row"><pre>    [xform scaleXBy:1.0 yBy:-1.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [xform concat];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Draw flipped content.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>The flip transform merely toggles the orientation of the current coordinate system. If your view already draws using flipped coordinates, because its <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/isFlipped" target="_top">isFlipped</a></code> method returns <code>YES</code>, applying a flip transform reverts the coordinate system back to the standard orientation. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-SW23" title="Cocoa Use of Flipped Coordinates"></a><h3>Cocoa Use of Flipped Coordinates</h3>
<p>Some Cocoa classes inherently support flipped coordinates and some do not. If you are using unmodified Cocoa views and controls in your user interface, it should not matter to your code whether those views and controls use flipped coordinates. If you are subclassing, however, it is important to know the coordinate system orientation. The following controls and views currently use flipped coordinates by default:</p>
<ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSButton_Class/Reference/Reference.html#//apple_ref/occ/cl/NSButton" target="_top">NSButton</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSMatrix_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMatrix" target="_top">NSMatrix</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSProgressIndicator_Class/Reference/Reference.html#//apple_ref/occ/cl/NSProgressIndicator" target="_top">NSProgressIndicator</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSScrollView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSScrollView" target="_top">NSScrollView</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSSlider_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSlider" target="_top">NSSlider</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSSplitView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSplitView" target="_top">NSSplitView</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTabView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTabView" target="_top">NSTabView</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTableHeaderView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTableHeaderView" target="_top">NSTableHeaderView</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTableView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTableView" target="_top">NSTableView</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTextField_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextField" target="_top">NSTextField</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTextView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextView" target="_top">NSTextView</a></code></p></li></ul>
<p>Some Cocoa classes support flipped coordinates but do not use them all the time. The following list includes the known cases where flipped-coordinate support depends on other mitigating factors. </p>
<ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_922"></a>Images do not use flipped coordinates by default; however, you can flip the image’s internal coordinate system manually using the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setFlipped:" target="_top">setFlipped:</a></code> method of <code>NSImage</code>. All representations of an <code>NSImage</code> object use the same orientation. For more information about images and flipped coordinates, see <span class="content_text"><a href="../Images/Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIBCHBA">“Image Coordinate Systems.”</a></span></p></li>
<li class="li"><p>The Cocoa <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_923"></a>text system takes cues from the current context to determine whether text should be flipped. If the text is to be displayed in an <code>NSTextView</code> object, text system objects (such as <code>NSFont</code>) also uses flipped coordinates to ensure that text is rendered right-side up. If you are drawing text in a custom view that uses standard coordinate, the text system objects do not use flipped coordinates.</p></li><li class="li"><p>An <code><a href="../../../Reference/ApplicationKit/Classes/NSClipView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSClipView" target="_top">NSClipView</a></code> object determines whether to use flipped coordinates by looking at the coordinate system of its document view. If the document view uses flipped coordinates, so does the clip view. Using the same coordinate system ensures that the scroll origin matches the bounds origin of the document view. </p></li><li class="li"><p>Graphics convenience functions, such as those declared in <code>NSGraphics.h</code>, take flipped coordinate systems into account when drawing. For information about the available graphics convenience functions, see <em><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/index.html#//apple_ref/doc/uid/TP40004154" target="_top">Application Kit Functions Reference</a></em>. </p></li></ul>
<p>As new controls and views are introduced in Cocoa, those objects may also support flipped coordinates. Check the class reference documentation for any subclassing notes on whether a class supports flipped coordinates. You can also invoke the view’s <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/isFlipped" target="_top">isFlipped</a></code> method at runtime to determine if it uses flipped coordinates.<a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_924"></a></p>
<a name="//apple_ref/doc/uid/TP40003290-CH204-BCICIJAJ" title="Doing Pixel-Exact Drawing"></a><h2>Doing Pixel-Exact Drawing</h2><p>Although it is possible to create applications using only the views, controls, and images provided by Cocoa, it is common for applications to use one or more custom views or images. And although Cocoa provides default behavior for laying out custom content, there are many times when you may want to adjust the position of individual views or images to avoid visual artifacts. This is especially true when tiling or drawing bitmap images on high-resolution devices (such as printers) or devices where resolution independent scale factors are in effect.</p><p>The following sections provide guidelines and practical advice for how to prevent visual artifacts that can occur during high-resolution drawing. For additional information on resolution independence and how to adapt your code to support different scale factors, see <em><a href="../../../../UserExperience/Conceptual/HiDPIOverview/index.html#//apple_ref/doc/uid/TP40003409" target="_top">Resolution Independence Guidelines</a></em>.</p><a name="//apple_ref/doc/uid/TP40003290-CH204-SW26" title="Tips for Resolution Independent Drawing in Cocoa"></a><h3>Tips for Resolution Independent Drawing in Cocoa</h3><p>Cocoa applications provide a tremendous amount of support for rendering to high-resolution devices. Although much of this support is automatic, you still need to do some work to ensure your content looks good. The following list includes some approaches to take when designing your interface: </p><ul class="spaceabove"><li class="li"><p>Use high-resolution images.</p></li><li class="li"><p>During layout, make sure views and images are positioned on integral pixel boundaries.</p></li><li class="li"><p>When creating tiled background images for custom controls, use the <code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSDrawThreePartImage" target="_top">NSDrawThreePartImage</a></code> and <code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSDrawNinePartImage" target="_top">NSDrawNinePartImage</a></code> methods to draw your background rather than trying to draw it yourself.</p></li><li class="li"><p>Use antialiased text rendering modes for nonintegral scale factors and be sure to lay out your text views on pixel boundries.</p></li><li class="li"><p>Test your applications with nonintegral scale factors such as 1.25 and 1.5. These factors tend to generate odd numbers of pixels, which can reveal potential pixel cracks.</p></li></ul><p>If you are using OpenGL for drawing, you should also be aware that in Mac OS X v10.5, the bounding rectangle of a view drawn into an <code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOpenGLContext" target="_top">NSOpenGLContext</a></code> is measured in pixels and not in points (as it is in non OpenGL situations). This support may change in the future, however, so OpenGL developers should be sure to convert coordinates directly using the coordinate conversion methods of <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code>. For example, the following conversion code for a view object is guaranteed to return the correct values needed by OpenGL.  </p><div class="codesample"><table><tr><td scope="row"><pre>NSSize boundsInPixelUnits = [self convertRect:[self bounds] toView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>glViewport(0, 0, boundsInPixelUnits.size.width, boundsInPixelUnits.size.height);<span></span></pre></td></tr></table></div><p>For more information about resolution independence and how it affects rendered content, see <em><a href="../../../../UserExperience/Conceptual/HiDPIOverview/index.html#//apple_ref/doc/uid/TP40003409" target="_top">Resolution Independence Guidelines</a></em>. </p><a name="//apple_ref/doc/uid/TP40003290-CH204-SW24" title="Accessing the Current Scale Factor"></a><h3>Accessing the Current Scale Factor</h3><p>Knowing the current scale factor can help you make decisions about how best to render your content. The <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSScreen_Class/Reference/Reference.html#//apple_ref/occ/cl/NSScreen" target="_top">NSScreen</a></code> classes both include a <code><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_925"></a>userSpaceScaleFactor</code> method that you can call to obtain the current <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_926"></a>scale factor, if any, for your application. In Mac OS X v10.5 and earlier, this method usually returns 1.0, indicating that the user space and device space have the same resolution (where one point equals one pixel). At some point though, this method may return a value that is greater than 1.0. For example, a value of 1.25 would indicate a screen resolution of approximately 90 dpi, while a value of 2.0 would indicate a screen resolution of 144 dpi.</p><p>If you want to know the actual <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_927"></a>resolution of a particular screen, the <code>NSScreen</code> class includes information about the display resolution in its device description dictionary (accessed using the <code><a href="../../../Reference/ApplicationKit/Classes/NSScreen_Class/Reference/Reference.html#//apple_ref/occ/instm/NSScreen/deviceDescription" target="_top">deviceDescription</a></code> method). You can use this information (instead of multiplying scale factors) to determine the appropriate resolution to use for your images. </p><a name="//apple_ref/doc/uid/TP40003290-CH204-SW27" title="Adjusting the Layout of Your Content"></a><h3>Adjusting the Layout of Your Content</h3>
<p><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_928"></a>Because screens are relatively low-resolution devices, drawing glitches are often more noticeable on a screen than they are on higher-resolution devices such as printers. Drawing glitches can occur when you render content in a way that requires tweaking to match the underlying pixels sent to the screen. For example, images and shapes drawn on non-<a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_929"></a>pixel boundaries might require aliasing and therefore might appear less crisp than those drawn exactly on pixel boundaries. In addition, scaling an image to fit into a different-sized area requires interpolation, which can introduce artifacts and graininess.</p><p>Although pixel-alignment issues can occur on any version of Mac OS X, they are more likely to occur as the operating system changes to support resolution independence. Under resolution independence, units in the user coordinate space and device coordinate space are no longer required to maintain a one-to-one relationship. For high-resolution screens, this means that a single unit in user space may be backed by multiple pixels in device space. So even if your user-space coordinates fall on integral unit boundaries, they may still be misaligned in device space. The presence of extra pixels can also lead to pixel cracks, which occur when misaligned shapes leave small gaps because they do not fill the intended drawing area entirely.  </p><p>If your images or shapes are not drawing the way you expect, or if your graphics content displays evidence of pixel cracks, you can remove many of these issues by adjusting the coordinate values you use to draw your content. The following steps are not required if the current scale factor is 1.0 but would be required for other scale factors. </p><ol class="ol"><li class="li"><p>Convert the user-space point, size, or rectangle value to device space coordnates.</p></li><li class="li"><p>Normalize the value in device space so that it is aligned to the appropriate pixel boundary.</p></li><li class="li"><p>Convert the normalized value back to user space.</p></li><li class="li"><p>Draw your content using the adjusted value.</p></li></ol><p>The best way to get the correct device-space rectangle is to use the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/centerScanRect:" target="_top">centerScanRect:</a></code> method of <code>NSView</code>. This method takes a rectangle in user space coordinates, performs the needed calculations to adjust the position of rectangles based on the current scale factor and device, and returns the resulting user space rectangle. For layout, you can also use the methods described in <span class="content_text"><a href="Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-SW25">“Converting Coordinate Values.”</a></span></p><p>If you want more control over the precise layout of items in device space, you can also adjust coordinates yourself. Mac OS X provides several functions for normalizing <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_930"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_931"></a>coordinate <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_932"></a><a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_933"></a>values once they are in device space, including the the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_934"></a><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSIntegralRect" target="_top">NSIntegralRect</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_935"></a><code><a href="../../../../GraphicsImaging/Reference/CGGeometry/Reference/reference.html#//apple_ref/c/func/CGRectIntegral" target="_top">CGRectIntegral</a></code> functions. You can also use the <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_936"></a><code><a href="../../../../Darwin/Reference/ManPages/man3/ceil.3.html#//apple_ref/doc/man/3/ceil" target="_top">ceil</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH204-DontLinkElementID_937"></a><code><a href="../../../../Darwin/Reference/ManPages/man3/floor.3.html#//apple_ref/doc/man/3/floor" target="_top">floor</a></code> functions in <code>math.h</code> to round device space coordinates up or down as needed.</p><a name="//apple_ref/doc/uid/TP40003290-CH204-SW25" title="Converting Coordinate Values"></a><h3>Converting Coordinate Values</h3><p>In Mac OS X v10.5, several methods were added to <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> to simplify the conversion between user space and device space coordinates: </p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertPointToBase:" target="_top">convertPointToBase:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertSizeToBase:" target="_top">convertSizeToBase:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertRectToBase:" target="_top">convertRectToBase:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertPointFromBase:" target="_top">convertPointFromBase:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertSizeFromBase:" target="_top">convertSizeFromBase:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertRectFromBase:" target="_top">convertRectFromBase:</a></code></p></li></ul><p>These convenience methods make it possible to convert values to and from the base (device) coordinate system. They take into account the current backing store configuration for the view, including whether it is backed by a layer. </p><p>To change the coordinate values of an <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSPoint" target="_top">NSPoint</a></code> structure, the beginning of your view’s <code>drawRect:</code> method might have code similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)drawRect:(NSRect)rect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint myPoint = NSMakePoint(1.0, 2.0);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGFloat scaleFactor = [[self window] userSpaceScaleFactor];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (scaleFactor != 1.0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSPoint    tempPoint = [self convertPointToBase:myPoint];<span></span></pre></td></tr><tr><td scope="row"><pre>        tempPoint.x = floor(tempPoint.x);<span></span></pre></td></tr><tr><td scope="row"><pre>        tempPoint.y = floor(tempPoint.y);<span></span></pre></td></tr><tr><td scope="row"><pre>        myPoint = [self convertPointFromBase:tempPoint];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // Draw the content at myPoint<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>It is up to you to determine which normalization function is best suited for your drawing code. The preceding example uses the <code>floor</code> function to normalize the origin of the given shape but you might use a combination of <code>floor</code> and <code>ceil</code> depending on the position of other content in your view.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../GraphicsContexts/GraphicsContexts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Color/Color.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-01-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Transforms/Transforms.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Transforms/Transforms.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Transforms/Transforms.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>