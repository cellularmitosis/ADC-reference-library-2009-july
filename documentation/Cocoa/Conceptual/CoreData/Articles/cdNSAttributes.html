<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Data Programming Guide: Non-Standard Persistent Attributes</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Non-Standard Persistent Attributes"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001919" title="Non-Standard Persistent Attributes"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Core Data Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdRelationships.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdValidation.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40001919-SW1" title="Non-Standard Persistent Attributes"></a><hr /><H1>Non-Standard Persistent Attributes</H1><p>Core Data supports a range of common types for values of persistent attributes, including string, date, and number. Sometimes, however, you want an attribute's value to be a type that is not supported directly. For example, in a graphics application you might want to define a Rectangle entity that has attributes <code>color</code> and <code>bounds</code> that are an instance of <code>NSColor</code> and an <code>NSRect</code> struct respectively. This article describes the two ways in which you can use non-standard attribute types: using transformable attributes, or by using a transient property to represent the non-standard attribute backed by a supported persistent property. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001919-SW18" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are using Mac OS X v10.4, read <span class="content_text"><a href="cdZ104NSAttributes.html#//apple_ref/doc/uid/TP40006648-SW1">“Mac OS X v10.4: Non-Standard Persistent Attributes”</a></span> instead.</p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW6">Introduction</a>
				
			<br/>
			
        
			
			
				<a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW7">Transformable Attributes</a>
				
			<br/>
			
        
			
			
				<a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW8">Custom Code</a>
				
			<br/>
			
        
			
			
				<a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW17">Type-Checking</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001919-SW6" title="Introduction"></a><h2>Introduction</h2><p>Persistent attributes must be of a type recognized by the Core Data framework so that they can be properly stored to and retrieved from a persistent store. Core Data provides support for a range of common types for persistent attribute values, including string, date, and number (see <code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAttributeDescription" target="_top">NSAttributeDescription</a></code> for full details). Sometimes, however, you want to use types that are not supported directly, such as colors and C structures. </p><p>You can use non-standard types for persistent attributes either by using transformable attributes or by using a <em>transient</em> property to represent the non-standard attribute backed by a supported persistent property. The principle behind the two approaches is the same: you present to consumers of your entity an attribute of the type you want, and “behind the scenes” it’s converted into a type that Core Data can manage. The difference between the approaches is that with transformable attributes you specify just one attribute and the conversion is handled automatically. In contrast, with transient properties you specify two attributes and you have to write code to perform the conversion.</p><a name="//apple_ref/doc/uid/TP40001919-SW7" title="Transformable Attributes"></a><h2>Transformable Attributes</h2><p>The idea behind transformable attributes is that you access an attribute as a non-standard type, but behind the scenes Core Data uses an instance of <code><a href="../../../Reference/Foundation/Classes/NSValueTransformer_Class/Reference/Reference.html#//apple_ref/occ/cl/NSValueTransformer" target="_top">NSValueTransformer</a></code> to convert the attribute to and from an instance of <code>NSData</code>. Core Data then stores the data instance to the persistent store. By default, Core Data uses the <code><a href="../../../Reference/Foundation/Classes/NSValueTransformer_Class/Reference/Reference.html#//apple_ref/c/data/NSKeyedUnarchiveFromDataTransformerName" target="_top">NSKeyedUnarchiveFromDataTransformerName</a></code> transformer, however you can specify your own transformer if you want.</p><p>To use a transformable attribute, you first simply add an attribute to your entity and specify that it is transformable. If you are using the model editor in Xcode, select Transformable in the Type popup; if you are setting the type programmatically, use <code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAttributeDescription/setAttributeType:" target="_top">setAttributeType:</a></code> and pass <code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/c/econst/NSTransformableAttributeType" target="_top">NSTransformableAttributeType</a></code> as the parameter. You then specify the name of the transformer to use: if you are using the model editor in Xcode, type the name in the Value Transformer Name text field; if you are setting the name programmatically, use <code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAttributeDescription/setValueTransformerName:" target="_top">setValueTransformerName:</a></code>. (You don’t have to specify a name if you are using the default transformer.) If you specify a custom transformer, it must transform an instance of the non-standard data type into an instance of <code>NSData</code> and support reverse transformation.</p><p>In principle, you don’t have to do anything else. In practice, to suppress compiler warnings you should declare a property for the attribute as shown in the following example (notice <code>favoriteColor</code>):</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Employee :  NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, retain) NSString * firstName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, retain) NSString * lastName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, retain) NSSet* directReports;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, retain) Employee * manager;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, retain) Department * department;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, retain) NSColor * favoriteColor;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>You can also add an implementation directive, but (since the default is <code>dynamic</code>) this is not necessary.</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation Employee<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic firstName;<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic lastName;<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic directReports;<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic manager;<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic department;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic favoriteColor;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>You can now use the attribute as you would any other standard attribute, as illustrated in the following code fragment:</p><div class="codesample"><table><tr><td scope="row"><pre>Employee *newEmployee =<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSEntityDescription insertNewObjectForEntityForName:@"Employee"<span></span></pre></td></tr><tr><td scope="row"><pre>        inManagedObjectContext:myManagedObjectContext];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>newEmployee.firstName = @"Captain";<span></span></pre></td></tr><tr><td scope="row"><pre>newEmployee.lastName = @"Scarlet";<span></span></pre></td></tr><tr><td scope="row"><pre>newEmployee.favoriteColor = [NSColor redColor];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001919-SW8" title="Custom Code"></a><h2>Custom Code</h2><p>The following sections illustrate implementations for object and scalar values. Both start, however, with a common task—you must specify a persistent attribute.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001919-SW19" title="Note"></a><p><strong>Note:</strong>&nbsp;The example for an object value uses an instance of <code>NSColor</code>; if you are using Mac OS X v10.5, you should typically use a transformable attribute instead. </p></div><a name="//apple_ref/doc/uid/TP40001919-SW9" title="Basic Approach"></a><h3>Basic Approach</h3><p>To use non-supported types, in the managed object model you define two attributes. One is the attribute you actually want (its value is for example a color object or a rectangle struct). This attribute is transient. The other is a "shadow" representation of that attribute. This attribute is persistent.</p><p>You specify the type of the transient attribute as undefined (<code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/c/econst/NSUndefinedAttributeType" target="_top">NSUndefinedAttributeType</a></code>). Since Core Data does not need to store and retrieve transient properties, you can use any object type you want for the attribute in your implementation. Core Data does, though, track the state of transient properties so that they can participate in the object graph management (for example, for undo and redo). </p><p>The type of the shadow attribute must be one of the "concrete" supported types. You then implement a custom managed object class with suitable accessor methods for the transient attribute that retrieve the value from and store the value to the persistent attribute.</p><p>The basic approach for object and scalar values is the same—you must find a way to represent the unsupported data type as one of the supported data types—however there is a further constraint in the case of scalar values.</p><a name="//apple_ref/doc/uid/TP40001919-SW10" title="Scalar Value Constraints"></a><h3>Scalar Value Constraints</h3><p>A requirement of the accessor methods you write is that they must be key-value coding (and key-value observing) compliant. Key-value coding only supports a limited number of structures—<code>NSPoint</code>, <code>NSSize</code>, <code>NSRect</code>, and <code>NSRange</code>. </p><p>If you want to use a scalar type or structure that is not one of those supported directly by Core Data and not one of the structures supported by key-value coding, you must store it in your managed object as an object—typically an <code>NSValue</code> instance, although you can also define your own custom class. You will then treat it as an object value as described later in this article. It is up to users of the object to extract the required structure from the <code>NSValue</code> (or custom) object when retrieving the value, and to transform a structure into an <code>NSValue</code> (or custom) object when setting the value.</p><a name="//apple_ref/doc/uid/TP40001919-SW11" title="The Persistent Attribute"></a><h3>The Persistent Attribute</h3><p>For any non-standard attribute type you want to use, you must choose a supported attribute type that you will use to store the value. Which supported type you choose depends on the non-standard type and what means there are of transforming it into a supported type. In many cases you can easily transform a non-supported object into an <code>NSData</code> object using an archiver. For example, you can archive a color object as shown in the following code sample. The same technique can be used if you represent the attribute as an instance of <code>NSValue</code> or of a custom class (note that your custom class would, of course, need to adopt the <code>NSCoding</code> protocol or provide some other means of being transformed into a supported data type).</p><div class="codesample"><table><tr><td scope="row"><pre>NSData *colorAsData = [NSKeyedArchiver archivedDataWithRootObject:aColor];<span></span></pre></td></tr></table></div><p>You are free to use whatever means you wish to effect the transformation. For example, you could transform an <code>NSRect</code> structure into a string object (strings can of course be used in a persistent store).</p><div class="codesample"><table><tr><td scope="row"><pre>NSRect aRect; // instance variable<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *rectAsString = NSStringFromRect(aRect);<span></span></pre></td></tr></table></div><p>You can transform the string back into a rectangle using <code>NSRectFromString</code>. You should bear in mind, however, that since the transformation process may happen frequently, you should ensure that it is as efficient as possible.</p><p>Typically you do not need to implement custom accessor methods for the persistent attribute. It is an implementation detail, the value should not be accessed other than by the entity itself. If you do modify this value directly, it is possible that the entity object will get into an inconsistent state.</p><a name="//apple_ref/doc/uid/TP40001919-SW12" title="An Object Attribute"></a><h3>An Object Attribute</h3><p>If the non-supported attribute is an object, then in the managed object model you specify its type as undefined, and that it is transient. When you implement the entity’s custom class, there is no need to add an instance variable for the attribute—you can use the managed object's private internal store. A point to note about the implementations described below is that they cache the transient value. This makes accessing the value more efficient—it is also necessary for change management. If you define custom instance variables, you should clean up these variables in <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/didTurnIntoFault" target="_top">didTurnIntoFault</a></code> rather than <code>dealloc</code> or <code>finalize</code>.</p><p>There are two strategies both for getting and for setting the transient value. You can retrieve the transient value either "lazily" (on demand—described in <span class="content_text"><a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW2">“The On-demand Get Accessor”</a></span>) or during awakeFromFetch (described in <span class="content_text"><a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW3">“The Pre-calculated Get”</a></span>). It may be preferable to retrieve it lazily if the value may be large (if for example it is a bitmap). For the persistent value, you can either update it every time the transient value is changed (described in <span class="content_text"><a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW4">“The Immediate-Update Set Accessor”</a></span>), or you can defer the update until the object is saved (described in <span class="content_text"><a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW5">“The Delayed-Update Set Accessor”</a></span>).</p><a name="//apple_ref/doc/uid/TP40001919-SW2" title="The On-demand Get Accessor"></a><h4>The On-demand Get Accessor</h4><p>In the get accessor, you retrieve the attribute value from the managed object's private internal store. If the value is <code>nil</code>, then it is possible it has not yet been cached, so you retrieve the corresponding persistent value, then if that value is not <code>nil</code>, transform it into the appropriate type and cache it. The following example illustrates the on-demand get accessor for a color attribute.</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSColor *)color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSColor *color = [self primitiveColor];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (color == nil)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSData *colorData = [self colorData];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (colorData != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];<span></span></pre></td></tr><tr><td scope="row"><pre>            [self setPrimitiveColor:color];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return color;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001919-SW3" title="The Pre-calculated Get"></a><h4>The Pre-calculated Get</h4><p>Using this approach, you retrieve and cache the persistent value in <code>awakeFromFetch</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)awakeFromFetch<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super awakeFromFetch];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSData *colorData = [self colorData];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (colorData != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSColor *color;<span></span></pre></td></tr><tr><td scope="row"><pre>        color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPrimitiveColor:color];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In the get accessor you then simply return the cached value.</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSColor *)color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSColor *color = [self primitiveColor];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    return color;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This technique is useful if you are likely to access the attribute frequently—you avoid the conditional statement in the get accessor.</p><a name="//apple_ref/doc/uid/TP40001919-SW4" title="The Immediate-Update Set Accessor"></a><h4>The Immediate-Update Set Accessor</h4><p>In this set accessor, you set the value for both the transient and the persistent attributes at the same time. You transform the unsupported type into the supported type to set as the persistent value. You must ensure that you invoke the key-value observing change notification methods, so that objects observing the managed object—including the managed object context—are notified of the modification. The following example illustrates the set accessor for a color attribute.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setColor:(NSColor *)aColor<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setPrimitiveValue:aColor forKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setValue:[NSKeyedArchiver archivedDataWithRootObject:aColor]<span></span></pre></td></tr><tr><td scope="row"><pre>                forKey:@"colorData"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The main disadvantage with this approach is that the persistent value is recalculated each time the transient value is updated, which may be a performance issue.</p><a name="//apple_ref/doc/uid/TP40001919-SW5" title="The Delayed-Update Set Accessor"></a><h4>The Delayed-Update Set Accessor</h4><p>In this technique, in the set accessor you only set the value for the transient attribute. You implement a <code>willSave</code> method that updates the persistent value just before the object is saved.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setColor:(NSColor *)aColor<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setPrimitiveValue:aColor forKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)willSave<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSColor *color = [self primitiveValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (color != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPrimitiveValue:[NSKeyedArchiver archivedDataWithRootObject:color]<span></span></pre></td></tr><tr><td scope="row"><pre>                forKey:@"colorData"];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPrimitiveValue:nil forKey:@"colorData"];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    [super willSave];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If you adopt this approach, you must take care when specifying your optionality rules. If color is a required attribute, then (unless you take other steps) you must specify the color attribute as not optional, and the color data attribute as optional. If you do not, then the first save operation may generate a validation error.</p><p>When the object is first created, the value of <code>colorData</code> is <code>nil</code>. When you update the color attribute, the <code>colorData</code> attribute is unaffected (that is, it remains <code>nil</code> ). When you save, <code>validateForUpdate:</code> is invoked before <code>willSave</code>. In the validation stage, the value of <code>colorData</code> is still <code>nil</code>, and therefore validation fails. </p><a name="//apple_ref/doc/uid/TP40001919-SW13" title="Scalar Values"></a><h3>Scalar Values</h3><p>You can declare properties as scalar values, but for scalar values Core Data cannot dynamically generate accessor methods—you must provide your own implementations (see <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW1" target="_self">Managed Object Accessor Methods</a></span>). Note that Core Data automatically synthesizes the primitive accessor methods (<code>primitiveLength</code> and <code>setPrimitiveLength:</code>), however you need to declare them to suppress compiler warnings.</p><p>For objects that will be used in either a Foundation collection or an AppKit view, you should typically allow Core Data to use its default storage instead of creating scalar instances to hold property values:</p><ul class="spaceabove"><li class="li"><p>There is CPU and memory overhead in creating and destroying autoreleased <code>NSNumber</code> object wrappers for your scalars;</p></li><li class="li"><p>Core Data optimizes at runtime any accessor methods you do not override—for example, it inlines the access and change notification method calls.</p></li></ul><p>The advantages of allowing Core Data to manage its own storage usually outweigh any advantages of interacting directly with scalar values, although if you suspect that this is not true for your application you should use performance analysis tools to check. </p><p>You can declare properties as scalar values. Core Data cannot, though, dynamically generate accessor methods for scalar values—you must provide your own implementations. If you have an attribute <code>length</code> that is specified in the model as a <code>double</code> (<code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/c/econst/NSDoubleAttributeType" target="_top">NSDoubleAttributeType</a></code>), in the interface file you declare <code>length</code> as: </p><div class="codesample"><table><tr><td scope="row"><pre>@property double length;<span></span></pre></td></tr></table></div><p>In the implementation file, you implement accessors that invoke the relevant access and change notification methods, and the primitive accessors. Core Data automatically synthesizes the primitive accessor methods (<code>primitiveLength</code> and <code>setPrimitiveLength:</code>), but you need to declare them to suppress compiler warnings.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyManagedObject (PrimitiveAccessors)<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSNumber *)primitiveLength;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPrimitiveLength:(NSNumber *)newLength;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (double)length<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"primitiveLength"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber *tmpValue = [self primitiveLength];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"primitiveLength"];<span></span></pre></td></tr><tr><td scope="row"><pre>    return (tmpValue!=nil) ? [tmpValue doubleValue] : 0.0; // or a suitable representation for nil<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setLength:(double)value<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber* temp = [[NSNumber alloc] initWithDouble: value];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"primitiveLength"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setPrimitiveLength:temp];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"primitiveLength"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [temp release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001919-SW14" title="A Non-Object Attribute"></a><h3>A Non-Object Attribute</h3><p>If the non-supported attribute is one of the structures supported by key-value coding (<code>NSPoint</code>, <code>NSSize</code>, <code>NSRect</code>, or <code>NSRange</code>), then in the managed object model you again specify its type as undefined, and that it is transient. When you implement the entity’s custom class, you typically add an instance variable for the attribute. For example, given an attribute called <code>bounds</code> that you want to represent using an <code>NSRect</code> structure, your class interface might be like that shown in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyManagedObject : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSRect)bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setBounds:(NSRect)aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Alternatively, if you want to give the instance variable a name other than the name of the attribute, you should also implement primitive get and set accessors (see <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW5">“Custom Primitive Accessor Methods”</a></span>), as shown in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyManagedObject : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect myBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSRect)primitiveBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPrimitiveBounds:(NSRect)aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSRect)bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setBounds:(NSRect)aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The primitive methods simply get and set the instance variable—they do not invoke key-value observing change or access notification methods—as shown in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSRect)primitiveBounds<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return myBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPrimitiveBounds:(NSRect)aRect<span></span></pre></td></tr><tr><td scope="row"><pre>    myBounds = aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Whichever strategy you adopt, you then implement accessor methods mostly as described for the object value. For the get accessor you can adopt either the lazy or pre-calculated technique, and for the set accessor you can adopt either the immediate update or delayed update technique. The following sections illustrate only the former versions of each.</p><a name="//apple_ref/doc/uid/TP40001919-SW15" title="The Get Accessor"></a><h4>The Get Accessor</h4><p>In the get accessor, you retrieve the attribute value from the managed object's private internal store. If the value has not yet been set, then it is possible it has not yet been cached, so you retrieve the corresponding persistent value, then if that value is not <code>nil</code>, transform it into the appropriate type and cache it. The following example illustrates the get accessor for a rectangle (this example makes a simplifying assumption that the bounds width cannot be <code>0</code>, so if the value is <code>0</code> then the bounds has not yet been unarchived).</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSRect)bounds<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"bounds"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect aRect = bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"bounds"];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (aRect.size.width == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *boundsAsString = [self boundsAsString];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (boundsAsString != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            bounds = NSRectFromString(boundsAsString);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001919-SW16" title="The Set Accessor"></a><h4>The Set Accessor</h4><p>In the set accessor, you must set the value for both the transient and the persistent attributes. You transform the unsupported type into the supported type to set as the persistent value. You must ensure that you invoke the key-value observing change notification methods, so that objects observing the managed object—including the managed object context—are notified of the modification. The following example illustrates the set accessor for a rectangle.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setBounds:(NSRect)aRect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"bounds"];<span></span></pre></td></tr><tr><td scope="row"><pre>    bounds = aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"bounds"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *rectAsString = NSStringFromRect(aRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setValue:rectAsString forKey:@"boundsAsString"]; }<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001919-SW17" title="Type-Checking"></a><h2>Type-Checking</h2><p>If you define an attribute to use a non-standard type, you can also specify the name of the class used to represent the value, using <code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/occ/instm/NSAttributeDescription/setAttributeValueClassName:" target="_top">setAttributeValueClassName:</a></code>. If you do, Core Data automatically checks any value set and throws an exception if it is an instance of the wrong class.</p><p>You can only set the value class name in code. The following example shows how you can modify the managed object model of a subclass of <code><a href="../../../Reference/ApplicationKit/Classes/NSPersistentDocument_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPersistentDocument" target="_top">NSPersistentDocument</a></code> to include a value class name for a non-standard attribute (<code>favoriteColor</code>) represented in this case by a an instance of a custom class, <code>MyColor</code>. Notice the subsequent programming error in setting the Captain Scarlet’s favorite color to an instance of <code>NSColor</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSManagedObjectModel *)managedObjectModel<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myManagedObjectModel == nil)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSBundle *bundle = [NSBundle bundleForClass:[self class]];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *path = [bundle pathForResource:@"MyDocument" ofType:@"mom"];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSURL *url = [NSURL fileURLWithPath:path];<span></span></pre></td></tr><tr><td scope="row"><pre>        myManagedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:url];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        NSEntityDescription *employeeEntity =<span></span></pre></td></tr><tr><td scope="row"><pre>            [[myManagedObjectModel entitiesByName] objectForKey:@"Employee"];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSAttributeDescription *favoriteColorAttribute =<span></span></pre></td></tr><tr><td scope="row"><pre>            [[employeeEntity attributesByName] objectForKey:@"favoriteColor"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // set the attribute value class to MyColor<span></span></pre></td></tr><tr><td scope="row"><pre>        [favoriteColorAttribute setAttributeValueClassName:@"MyColor"];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return myManagedObjectModel;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)windowControllerDidLoadNib:(NSWindowController *)windowController<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super windowControllerDidLoadNib:windowController];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Employee *newEmployee =<span></span></pre></td></tr><tr><td scope="row"><pre>        [NSEntityDescription insertNewObjectForEntityForName:@"Employee"<span></span></pre></td></tr><tr><td scope="row"><pre>            inManagedObjectContext:[self managedObjectContext]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    newEmployee.firstName = @"Captain";<span></span></pre></td></tr><tr><td scope="row"><pre>    newEmployee.lastName = @"Scarlet";<span></span></pre></td></tr><tr><td scope="row"><pre>    newEmployee.favoriteColor = [NSColor redColor]; // exception thrown here<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>Note that the attribute value class must actually exist at runtime. If you misspell the class name itself (for example, <code>MyColour</code> instead of <code>MyColor</code>), the check succeeds silently.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdRelationships.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdValidation.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdNSAttributes.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdNSAttributes.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdNSAttributes.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
