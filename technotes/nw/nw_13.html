<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note NW13: AppleTalk: The Rest of the Story</title><meta name="keywords" content=""><meta name="Description" content="Technical Note NW13: ">    <meta name="categories" content="Networking"><meta name="week-posted" content="Jan 27, 1992 - Feb 7, 1992"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002555" title="AppleTalk: The Rest of the Story"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Networking/index.html" target="_blank">Reference Library > Networking</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note NW13</div>
<div id="pageheadsub">AppleTalk: The Rest of the Story</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->					<p id="menutext">					<a href="#Overview">Overview</a><BR><BR>					<a href="#Introduction">Introduction</a><BR><BR><a href="#References">References</a><BR><BR><A HREF="#Changes">Change History</A><BR><BR><a href="#Downloads">Downloadables</a></p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note discusses the updates, and modifications to a number offacets of the lower levels of AppleTalk Phase 2 since the release of <i>InsideMacintosh</i> Volume VI. Topics range from discussion of the new DatagramDelivery Protocol (DDP) layer calls to the AppleTalk Multiple Node Architectureto a discussion at the driver level of the new Multivendor ADEV Architecture.Most of the information presented here concerns AppleTalk version 56 through58; however, additional material is presented to clarify and correct materialpresented in other AppleTalk documentation relating to all versions ofAppleTalk.</p><P id = "introtext">Reordered subjects according to the order of the AppleTalk version in which thefeature was first implemented. Added a table of contents to make it easier tofind material. Added a discussion on Multivendor ADEV Architecture, the .TOKNdriver interface, plus information on making AppleTalk drivers compatible withvirtual memory under system software version 7.0.x. Added a description of thechange to the .ENET interface presented by the Apple SONIC based Ethernetdrivers. Added socket listener sample code plus corrections to the originalsample socket listener.  Added AppleTalk version list.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Feb 01 1994]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><a name="Overview"></a><h2>Overview</h2>    <P>This technote is broken down into the following topics</p><ul type="disc">	<li>Where Can I Get the Latest Version of AppleTalk?</li><li>Going, Going, Gone...  </li><li>The 'atkv' Gestalt Selector  </li><li>Sample Socket Listener   </li><li>Socket Listener Review     </li><li>Timing Considerations for LocalTalk    </li><li>Register Usage     </li><li>Socket Listener Overview     </li><li>Socket Listener Assembler Code     </li><li>Initializing the Socket Listener     </li><li>Using the Socket Listener     </li><li>The AppleTalk Transition Queue     </li><li>Bug with LAPAddATQ and LAPRmvATQ Glue Code    </li><li>Calling the AppleTalk Transition Queue    </li><li>Standard AppleTalk Transition Constants    </li><li>The Flagship Naming Service    </li><li>The ATTransNameChangeAskTask Transition    </li><li>The ATTransNameChangeTellTask Transition     </li><li>The ATTransCancelNameChange Transition    </li><li>System 7.0 Sharing Setup cdev / Flagship Naming Service Interaction</li><li>AppleTalk Remote Access Network Transition Event    </li><li>The ATTransNetworkTransition Transition    </li><li>Network Transition Event for AppleTalk Remote Access    </li><li>Cable Range Change Transition Event    </li><li>The ATTransCableChange Transition    </li><li>The Speed Change Transition Event   </li><li>The ATTransSpeedChange Transition    </li><li>Sample Pascal Source to LAPMgrExists Function   </li><li>Sample AppleTalk Transition Queue Function    </li><li>Sample AppleTalk Transition Queue Function in C    </li><li>Sample AppleTalk Transition Queue Function in Pascal   </li><li>Multivendor ADEV Architecture   </li><li>Original Limitations    </li><li>.TOKN Driver Shell   </li><li>.TOKN Driver Basics   </li><li>Driver Considerations for Virtual Memory Limiting DeferUserFn Calls     Implementing DeferUserFn </li><li>.TOKN Application Programming Interface (API)   </li><li>Using L802Attach on Token Ring   </li><li>Writing the Protocol Handler for the LAP Manager   </li><li>.FDDI Application Programming Interface (API)   </li><li>SONIC-Based Ethernet Driver Software Interface Change    </li><li>EGetInfo Changes   </li><li>Distinguishing Apple's SONIC-Based Ethernet Systems   </li><li>Correction to the ENET.h Header File    </li><li>AppleTalk Multiple Node Architecture   </li><li>What Is It?    </li><li>Glue Code For Multinode Control Calls   </li><li>Things You Need to Know When Writing a Multinode Application   </li><li>AddNode (csCode=262)    </li><li>Receiving Packets   </li><li>Sending Datagrams Through Multinodes    </li><li>NetWrite (csCode=261)   </li><li>AppleTalk Remote Access Network Number Remapping   </li><li>Is There a Router on the Network?   </li><li>New for AppleTalk ADEVs    </li><li>AGetInfo (D0=3)    </li><li>ADelNode  (D0=10)    </li><li>AGetNodeRef  (D0=11)    </li><li>AOpen  (D0=7)   </li><li>AClose (D0=8)    </li><li>AInstall (D0=1)    </li><li>AShutDown (D0=2)    </li><li>Receiving Packets    </li><li>Defending Multinode Addresses    </li><li>Corrections/Clarifications to the LAP Manager    </li><li>LRdDispatch (D0 = 1)    </li><li>LWrtInsert (D0 = 2)    </li><li>AppleTalk Version Information    </li><li>Contacting Apple Software Licensing</li></ul>  <P><A HREF="#top">Back to top</A></P>  <a name="Introduction"></a><h2>Introduction</h2><P>This Technote differs from previous revisions in that the subjects have beenreordered. The topics are presented according to the  order of the AppleTalkversion in which the feature was first implemented. You can find new topics andmodifications to this Technote by looking for material set off by change barsin the margins.</p><p>The first section in this Note presents a list of the original AppleTalkManager calls which are *NOT* being ported to the PowerPC platform.  The listincludes the Preferred AppleTalk version of the function call, or the preferredmethod for implementing this functionality.  It is important that you reviewthis list and check whether your program is using any of these original calls.If so, and you want your program code to be compatible with the Power PCplatform, it is advised that you modify your program to use the PreferredAppleTalk interface calls.</p><p>The next section in this Note, "The <code>'atkv'</code> Gestalt Selector," discusses the newGestalt selector <code>'atkv'</code>, which provides version information when AppleTalk isavailable.</p> <P>The next section, "Sample Socket Listener," presents a sample socket listener,including initialization code to assist high-level language programmers. Thesocket listener comments describe in detail the basic functions of packethandling at the data link layer.  Information is included on how to make thissocket listener compatible with Virtual Memory.</p><p>The next section, "The AppleTalk Transition Queue," discusses the AppleTalkTransition Queue, including its support for the Flagship Naming Service,AppleTalk Remote Access, and changes to processor speed that can affectLocalTalk and other processes dependent on processor speed. Included is Pascalsource code for checking whether the Phase 2 LAP Manager exists to support theTransition Queue mechanism, plus sample Transition Queue handlers written inboth C and Pascal.  This section includes a description of an important bugwhich exists in the glue code, implemented for the LAPAddATQ and the LAPRmvATQfunctions in MPW v3.2.x.  Under MPW v3.3, the glue routines for these functionshas been corrected.  The glue code is from the MPW Interface.o file.Replacement glue routines are provided to work around the problem for both MPWv3.2.x and Think programmers, v5.x and earlier.</p><p>The section "Multivendor ADEV Architecture" presents the Multivendor ADEVArchitecture, which allows for Ethernet and token ring cards from multiplevendors to be installed on the same system. Included is a description of thefunctionality of the new driver shells for Ethernet and token ring, plus adescription of the .TOKN interface required for compatibility with the new ADEVArchitecture.</p><p>The section, "Driver Considerations for Virtual Memory," shows how to modifydriver code for compatibility with system software version 7.0 virtualmemory.</p><p>The section "Ethernet NB and Macintosh Quadra Built-in Software InterfaceChange" presents a change to the .ENET interface that resulted from theimplementation of the SONIC Network Interface Controller on the Ethernet NBCard and in the Macintosh Quadra computer's built-in Ethernet. The changeconcerns the EGetInfo function, which now returns additional networkinformation for Apple Ethernet products based on the SONIC chip.</p><p>The section "Correction to the ENET.h Header File" presents a correction to theheader file for programs which will make a parameter block Control call to the.ENET, .TOKN, or .FDDI driver, to add or delete multicast addresses. Thisproblem only applies to C programs which are written to include the ENET.h filesupplied with MPW v3.2.x and with Think C v5.0 to v5.0.4.</p><p>The section "AppleTalk Multiple Node Architecture" discusses the new programinterfaces to the AppleTalk Multiple Node Architecture. The new architecturewas developed to support multiple node capability on the Macintosh computer,which allows the Macintosh to present itself as separate entities, or uniquenodes on the network. The AppleTalk Remote Access program uses Multinodecapability to implement Remote Access functionality. This section presents theDatagram Delivery Protocol (DDP) interface for Multinode AppleTalk forapplications to take advantage of this new functionality. This Note, however,does not discuss the Remote Access program.</p><p>The section, "New for AppleTalk ADEVs," presents the changes required of anADEV's <code>'atlk'</code> code resource for compatibility with the AppleTalkMultinode Architecture. While we recommend that developers of Ethernet andtoken ring network hardware conform to the specifications of the MultivendorADEV Architecture, this information is presented for those developers ofnetwork products for which Apple does not supply an ADEV.</p><p>The final section, "AppleTalk Version Information," lists the various versionsof AppleTalk, and the new products that require the support of the AppleTalkversion.</p><P><A HREF="#top">Back to top</A></P>  <h3>Where Can I Get the Latest Version of AppleTalk?</h3><P>For testing purposes, the latest version of AppleTalk and related software isavailable on the latest <i>Developer CD</i> <i>Series</i> disc, on AppleLink onthe Developer Services Bulletin Board, and on the Internet through anonymousFTP to ftp.apple.com (130.43.2.3). It  can be installed by using the NetworkSoftware Installer.</p><P><A HREF="#top">Back to top</A></P>  <h3>Going, Going, Gone...</h3><P>Five years ago in Technote #132, "AppleTalk Interface Update", we alerteddevelopers that the use of the old alternate AppleTalk interface functions "maycause future compatibility problems."  For PowerPC, the old alternate AppleTalkinterface functions are not being ported.  These calls make Memory Managercalls and are of limited use in contrast to the Preferred Style calls presentedin "Inside Macintosh" Volume V.  The following is a list of the AppleTalk callswhich are going away and along with their Preferred counterpart.</p><p align="center"><img src="images/nw_13_001.gif" width=312 height=360 alt=""></p><p><i>Inside Macintosh Volume II</i>, presents additional interface functions which are available through MPW glue in the Interface.o library, and are of dubious value.  They are:</P><ul type="disc">	<li><code>MPPOpen</code> - You should instead use <code>OpenDriver</code>('.MPP', <code>refNum</code>) to open the .MPP driver which also makes available the driver <code>refNum</code>.</li>	<li><code>ATPLoad</code> - opening the .MPP driver automatically loads the .ATP driver.</li>	<li><code>ATPUnload</code> - one should not be unloading the .ATP driver.  In addition, this function applies only to the Macintosh 128K</li>	<li><code>GetNodeAddress</code> - It is preferable to use the <code>PGetAppleTalkInfo</code> function to obtain the network and node number.  <code>GetNodeAddress</code> accesses low memory globals.  <code>PGetAppleTalkInfo</code> will be easier to support in the future.</li>	<li><code>IsMPPOpen</code> - accesses a low memory global.  Instead, use the <code>OpenDriver</code> function to open the .MPP driver.  You can also use the Gestalt function with the <code>gestaltAppleTalkVersion</code> selector to find out if the .MPP driver is open. Refer to the <code>AppleTalkVersion</code> sample function listed below.</li>	<li><code>IsATPOpen</code> - the .ATP driver is open if the .MPP driver is open.</li></ul><p>The only function which is still useful among the glue routines from the ABpackage is the <code>NBPExtract</code> function.</p><P><A HREF="#top">Back to top</A></P>  <h3>The 'atkv' Gestalt Selector</h3><P>The <code>'atkv'</code> Gestalt selector is available beginning with AppleTalkversion 56 to provide more complete version information regarding AppleTalk,and as an alternative to the existing <code>'atlk'</code> Gestalt selector.Beginning with AppleTalk version 54, the <code>'atlk'</code> Gestalt selector wasavailable to provide basic version information. The <code>'atlk'</code> selector isnot available when AppleTalk is turned off in the Chooser. It is important tonote that the information between the two resources is provided in a differentmanner. Calling Gestalt with the <code>'atlk'</code> selector provides the majorrevision version information in the low-order byte of the function result.Calling Gestalt with the <code>'atkv'</code> selector provides the versioninformation in a manner similar to the <code>'vers'</code> resource. The format ofthe <code>LONGINT</code> result is as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    byte;                        /* Major revision */    byte;                        /* Minor revision */    byte        development = 0x20,    /* Release stage  */            alpha = 0x40,            beta = 0x60,            final = 0x80, /* or */ release = 0x80;    byte;                        /* Nonfinal release # */</pre>	</TD></TR></TABLE></CENTER>    <p>For example, passing the <code>'atkv'</code> selector in a Gestalt call underAppleTalk version 57 gives the following <code>LONGINT</code> result:<code>0x39008000</code>.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>With the release of the System 7 Tuner product, AppleTalk will not beloaded at startup, if prior to the previous shutdown AppleTalk was turned offin the Chooser. Under this circumstance, the <code>'atkv'</code> selector is notavailable. If the<code> 'atkv'</code> selector is not available under System 7,this is an indicator that AppleTalk cannot be turned on without doing so in theChooser and rebooting the system.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P>  <h3>Sample Socket Listener</h3><P>The preferred AppleTalk calls presented in <i>Inside Macintosh</i> Volume V,page 513, do not include a preferred style call for <code>DDPRead</code>. As aresult developers are faced with the prospect of writing their socket listenersand using the <code>POpenSkt</code> function when upgrading their programs.<i>Inside Macintosh</i> Volume II, page 324, presents an overview of how socketlisteners should function.  <i>Inside Macintosh</i> states that socketlisteners, as well as protocol handlers, need to be written in assembly code,since parameters are passed in registers. To assist high-level programmers withimplementing a socket listener, the generic listener code is provided. Thefollowing code demonstrates how to do the following:</P><ul type="disc">	<li>buffer multiple packets  return DDP/LAP header information that has already been read into the Read Header Area (RHA) by DDP  calculate and compare the packet checksum when a packet uses a long DDP header, and includes the checksum value</li></ul><P>Some of the things that the listener sample does not do, which you might wishto implement, are the following:</P><ul type="disc">	<li>Check the DDP type and ignore any packets that don't match the desired  type(s) that you're interested in.</li>	<li>Check the source node ID and ignore any packets that don't come from the  desired node(s).</li>	<li>If the socket listener is used by more than one socket, it could route the  packets differently based on the socket number found in D0.</li>	<li>The socket listener does not handle the implementation of a completion  routine to be executed when the packet is processed.</li></ul><p>The example listener code includes an initialization routine which the listenerclient uses to notify the listener code of the "available" and "used" bufferqueues.  The sample initialization routine also provides information about thelistener code which will enable the client to protect the listener code frombeing paged out when Virtual Memory is present.  A high-level procedure isprovided to demonstrate the initialization of the listener, the use of thesocket listener and a technique for protecting the listener code in thepresence of Virtual Memory.</p><p>For users concerned with the compatibility between this sample socket listenerand PowerPC, the PowerPC mixed mode magic will handle 68000 Assemblerinstructions transparently</P><P><A HREF="#top">Back to top</A></P>  <h3>Socket Listener Review</h3><P>The reader is advised to refer to <i>Inside Macintosh</i> Volume II, pages 324to 330, for a description of protocol handlers, socket listeners, and datareception in the AppleTalk Manager over LocalTalk. The same architectureapplies to AppleTalk on Ethernet and token ring. With the advent of AppleTalkPhase 2, the size of the Read Header Area (RHA) has been expanded toaccommodate the long DDP header.</p><p>After every <code>ReadPacket</code> or <code>ReadRest </code>call, the listener code must check the Z (Zero) condition code for errors. If an error is detected from<code>ReadPacket</code> , the code must not call <code>ReadRest</code>.</p><P>It is the responsibility of the socket listener code to check for the existenceof the DDP checksum. In contrast with the Frame Check Sequence which thehardware uses to verify frame, the DDP checksum is implemented in extended DDPheaders to verify that the packet data is not corrupted by memory or data buserrors within routers on the Internet. If the checksum has been entered, thenthe socket listener code must calculate the checksum after the packet has beenread in, and compare the computed value with the passed checksum value. Thesample listener code demonstrates this check and calculation of the checksum.The listener code sets a flag which the program can check to determine whetherthe checksum matched or not.</p><p>The record structure presented in this sample returns the DDP type, destinationnode ID, source address in <code>AddrBlock</code> format, the hop count, the sizeof the packet, a flag to indicate whether a checksum error occurred, followedby the actual datagram. The record structure can be extended to returnadditional information, such as the tick count at the time the socket handlerwas called. </p><P><A HREF="#top">Back to top</A></P>  <h3>Timing Considerations for LocalTalk</h3><P>If LocalTalk is being used, your socket listener has less than 95 microseconds(best case) to read more data with a <code>ReadPacket</code> or <code>ReadRest</code>call. If you need more time, you might consider reading another three bytesinto the RHA to buy another 95 microseconds. Remember that the RHA may onlyhave eight bytes still available.</p><P><A HREF="#top">Back to top</A></P>  <h3>Register Usage</h3><P>When the socket listener is called, the registers will be set up as follows:</P>    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Register(s)       Contents     A0-A1          SCC addresses used by MPP     A2                Pointer to MPP's local variables     A3                Pointer to next free byte in RHA     A4                Pointer to ReadPacket {JSR (A4)} and ReadRest {JSR2(A4)} jump table     D0               This packet's destination socket number     D1                Number of bytes left to read in packet</pre>	</TD></TR></TABLE></CENTER><p>Registers D0, D2, and D3 can be used freely throughout the socket listener.A6, and D4 to D7 must be preserved.</p><p>From entry to socket listener until <code>ReadRest</code> is called:</p><p>The A5 register can be used.</p><p>Registers A0-A2, A4, and D1 must be preserved.</p><p align="center">From <code>ReadRest</code> until exit from socket listener:</p><P>The A5 register must be preserved.<BR>Registers A0-A3 and D0-D3 are free to use.</p><P>You should assume only eight bytes are still available in the RHA for your use.The RHA will contain one of the following:</P><P align=center><img src="images/nw_13_002.gif" alt="" width=416 height=207></P><P><A HREF="#top">Back to top</A></P>  <h3>Socket Listener Overview</h3><P>The sample socket listener utilizes two standard Operating System (OS) queues(see <i>Inside Macintosh</i> II-372), a free queue of available buffers whichthe listener uses to fill with incoming datagrams. The second linked list is aused queue of buffers which the listener has processed, but have not beenprocessed by the listener client. The <code>SL_InitSktListener</code> routine is called to pass the listener the pointers to the two OS queues.  In addition, the<code>SL_InitSktListener</code>  routine returns the address and length of the socket listener code.  A client process can then check for the presence of Virtual Memory, and call <code>HoldMemory</code> to protect the socket listener code from being paged out.</p><p>When the listener is called to process a packet, the listener checks whetherthere is an available buffer record in the free queue by checking that<code>qHead</code> element of the free queue is not nil. If so, then the listenersets register A3 to point to the <code>buffer_data</code> element of the record andcalls the <code>ReadRest</code> routine. If there is no available buffer record,the packet is ignored by calling <code>ReadRest</code> with a buffer size value of0. Perhaps the next time a packet is handled, a buffer will be available. If anerror occurs during the <code>ReadRest</code> function, then the listener simplyreturns to the caller.</p><p>If the packet is successfully read, the listener processes the headerinformation. The header information has been stored by the hardware driver inthe MPP local variable space pointed to in register A2. The listener code fillsin the hop count  field of the packet buffer record and determines the packetlength. The listener then figures out whether it is dealing with a short orextended DDP header and fills in the remaining fields of the packet buffer. Acheck is made to determine whether the checksum field of the DDP header isnon-zero. If the field is non-zero, the value is passed to the<code>SL_DoChkSum</code> function to verify that the resulting checksum iszero. If the resulting checksum is non-zero, the <code>buffer_CheckSum</code> fieldis set to <code>ckSumErr</code>, <code>-3103</code>, otherwise the field is set to<code>noErr</code>. Finally, the listener <code>Enqueues</code> the packet buffer intothe used queue and <code>Dequeues</code>  it from the free queue before returningto the caller.</p><p>The calling program periodically checks the <code>QHead</code> element of the usedqueue. When <code>QHead</code> is no longer nil, a packet is available forprocessing. The program processes the packet buffer.  When finished, the packetbuffer is <code>Enqueued</code> into the free queue and <code>Dequeued</code> from theused queue. The program might then check for additional packets in the usedqueue and process them in the same manner.</p><p>The program needs to define a sufficient number of packet buffers so that thelistener has buffers available in the free queue between times when the programchecks the used queue and processes incoming packets.</p><P><A HREF="#top">Back to top</A></P>  <h3>Socket Listener Assembler Code</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>;_________________________________________________________________________; Socket Listener Sample;; 3/92 Jim Luther,  Apple DTS;; (c)1992 Apple Computer, Inc.;_________________________________________________________________________    INCLUDE    'QuickEqu.a'    INCLUDE    'ToolEqu.a'    INCLUDE    'SysEqu.a'    INCLUDE    'Traps.a'    INCLUDE    'ATalkEqu.a'    INCLUDE    'SysErr.a';;; Record Types;;_________________________________________________________________________;QHdr                  RECORD    0;qFlags                DS.W      1;qHead                 DS.L      1;qTail                 DS.L      1;                      ENDRPacketBuffer          RECORD    0qLink                 DS.L      1qType                 DS.W      1buffer_Type           DS.W      1            ; DDP Typebuffer_NodeID         DS.W      1            ; Destination nodebuffer_Address        DS.L      1            ; Source address in AddrBlock formatbuffer_Hops           DS.W      1            ; Hop countbuffer_ActCount       DS.W      1            ; length of DDP datagrambuffer_CheckSum       DS.W      1            ; Chksum error returned here                                             ;(cksumErr or noErr)buffer_Ticks          DS.L      1            ; TickCount when handler calledbuffer_Data           DS.B      ddpMaxData   ; the DDP datagram                      ENDR;_________________________________________________________________________;; Local Variables;;_________________________________________________________________________SL_Locals    PROC        ENTRY free_queue,used_queue,current_qelemfree_queue        DC.L    0      ; pointer to freeQ QHdr - init'd by InitSktListenerused_queue        DC.L    0      ; pointer to usedQ QHdr - init'd by InitSktListenercurrent_qelem     DC.L    0      ; pointer to current PacketBuffer record                                 ; initialized by InitSktListener, then                                 ; set by socket listener after every packet.                                 ; NIL if no buffer is available.    ENDP;_________________________________________________________________________;; SL_DoChksum - accumulate ongoing checksum (from Inside Macintosh);;    Input:;     D1 (word) = number of bytes to checksum;     D3 (word) = current checksum;     A1 points to the bytes to checksum;;    Return:;     D0 is modified;     D3 (word) = accumulated checksum;_________________________________________________________________________SL_DoChksum    PROC    CLR.W      D0                    ; Clear high byte    SUBQ.W     #1,D1                 ; Decrement count for DBRAChksumLoop:    MOVE.B     (A1)+,D0              ; read a byte into D0    ADD.W      D0,D3                 ; accumulate checksum    ROL.W      #1,D3                 ; rotate left one bit    DBRA       D1,ChksumLoop         ; loop if more bytes    RTS    ENDP;_________________________________________________________________________;; SL_TheListener;;_________________________________________________________________________;_________________________________________________________________________;; SL_TheListner - process packets received at the designated socket;;    Input:;     D0 (byte) = packet's destination socket number;     D1 (word) = number of bytes left to read in packet;     A0 points to the bytes to checksum;     A1 points to the bytes to checksum;     A2 points to MPP's local variables;     A3 points to next free byte in Read Header Area;     A4 points to ReadPacket and ReadRest jump table;;    Return:;     D0 is modified;     D3 (word) = accumulated checksum;_________________________________________________________________________SL_TheListener  PROC    EXPORT    EXPORT  SL_InitSktListener    WITH    PacketBuffer; get pointer to current PacketBufferGetBuffer:    LEA       current_qelem,A3          ; get the pointer to the PacketBuffer to use    MOVE.L    (A3),A3    MOVE.L    A3,D0                     ; if no PacketBuffer    BEQ.S     NoBuffer                  ; then ignore packet; read rest of packet into PacketBuffer.datagramData    MOVE.L    D1,D3                     ; read rest of packet    LEA       buffer_data(A3),A3        ; A3 = ^bufferData    JSR       2(A4)                     ; ReadRest    BEQ.S     ProcessPacket             ; If no error, continue    BRA       RcvRTS                    ; there was an error, so ignore packet; No buffer; ignore the packetNoBuffer      CLR D3                    ; Set to ignore packet (buffer size = 0)    JSR       2(A4)                     ; ReadRest    BRA       GetNextBuffer             ; We missed this packet, but maybe there                                        ; will be a buffer for the next packet...; Process the packet you just read in.; ReadRest has been called so registers A0-A3 and D0-D3 are free to use.; We'll use registers this way:PktBuff         EQU    A0        ; the current PacketBufferMPPLocals       EQU    A2        ; pointer to MPP's local variables (still set up                                 ;  from entry to socket listener)HopCount        EQU    D0        ; used to get the hop countDatagramLength  EQU    D1        ; used to determine the datagram lengthSourceNetAddr   EQU    D2        ; used to build the source network addressProcessPacket:    LEA        current_qelem,PktBuff          ; PktBuff = current_qelem    MOVE.L     (PktBuff),PktBuff; do everything that's common to both long and short DDP headers; save tickCount in buffer_Ticks field    MOVE.L     Ticks,buffer_Ticks(PktBuff); first, clear buffer_Type and buffer_NodeID to ensure their high bytes are 0    CLR.W      buffer_Type(PktBuff)           ; clear buffer_Type    CLR.W      buffer_NodeID(PktBuff)         ; clear buffer_NodeID; clear SourceNetAddr to prepare to build network address    MOVEQ      #0,SourceNetAddr               ; build the network address in                                              ; SourceNetAddr; get the hop count    MOVE.W     toRHA+lapHdSz+ddpLength(MPPLocals),HopCount ; Get hop/length field    ANDI.W     #DDPHopsMask,HopCount          ; Mask off the hop count bits    LSR.W      #2,HopCount                    ; shift hop count into low bits of                                              ; high byte    LSR.W      #8,HopCount                    ; shift hop count into low byte    MOVE.W     HopCount,buffer_Hops(PktBuff)  ; and move it into the PacketBuffer; get the packet length (including the DDP header)    MOVE.W     toRHA+lapHdSz+ddpLength(MPPLocals),DatagramLength ; Get length field    ANDI.W     #ddpLenMask,DatagramLength     ; Mask off the hop count bits; now, find out if the DDP header is long or short    MOVE.B     toRHA+lapType(MPPLocals),D3    ; Get LAP type    CMPI.B     #shortDDP,D3                   ; is this a long or short DDP header?    BEQ.S      IsShortHdr                     ; skip if short DDP header; it's a long DDP header    MOVE.B     toRHA+lapHdSz+ddpType(MPPLocals),buffer_Type+1(PktBuff); get DDP type    MOVE.B     toRHA+lapHdSz+ddpDstNode(MPPLocals),buffer_NodeID+1(PktBuff)                                              ; get destination node from LAP header    MOVE.L     toRHA+lapHdSz+ddpSrcNet(MPPLocals),SourceNetAddr                                              ; source network in hi word                                              ; source node in lo byte    LSL.W      #8,SourceNetAddr    ; shift source node up to high byte of low word                                              ; get source socket from DDP header    MOVE.B     toRHA+lapHdSz+ddpSrcSkt(MPPLocals),SourceNetAddr    SUB.W      #ddpType+1,DatagramLength      ; DatagramLength = number of bytes in                                              ; datagram; checksum time...    TST.W      toRHA+lapHdSz+ddpChecksum(MPPLocals) ;Does packet have checksum?    BEQ.S      noChecksum; Calculate checksum over DDP header    MOVE.W     DatagramLength,-(SP)           ; save DatagramLength (D1)    CLR        D3                             ; set checksum to zero    MOVEQ      #ddphSzLong-ddpDstNet,D1       ; D1 = length of header part to                                              ; checksum pointer to dest network                                              ; number in DDP header    LEA        toRHA+lapHdSz+ddpDstNet(MPPLocals),A1    JSR        SL_DoChksum                    ; checksum of DDP header part                                              ; (D3 holds accumulated checksum); Calculate checksum over data portion (if any)    LEA        buffer_Data(PktBuff),A1        ; pointer to datagram    MOVE.W     (SP)+,DatagramLength           ; restore DatagramLength (D1)    MOVE.W     DatagramLength,-(SP)           ; save DatagramLength (D1)                                              ;  before calling SL_DoChksum    BEQ.S      TestChecksum                   ; don't checksum datagram if its                                              ; length = 0    JSR        SL_DoChksum                    ; checksum of DDP datagram part                                              ; (D3 holds accumulated checksum)TestChecksum:    MOVE.W     (SP)+,DatagramLength           ; restore DatagramLength (D1); Now make sure the checksum is OK.    TST.W      D3                             ; is the calculated value zero?    BNE.S      NotZero                        ; no -- go and use it    SUBQ.W     #1,D3                          ; it is 0; make it -1NotZero:    CMP.W      toRHA+lapHdSz+ddpChecksum(MPPLocals),D3    BNE.S      ChecksumErr                    ; Bad checksum    MOVE.W     #0,buffer_CheckSum(A0)         ; no errors    BRA.S      noChecksumChecksumErr:    MOVE.W     #ckSumErr,buffer_CheckSum(PktBuff) ; checksum errornoChecksum:    BRA.S      MoveToBuffer; it's a short DDP headerIsShortHdr:                                              ; get DDP type    MOVE.B     toRHA+lapHdSz+sddpType(MPPLocals),buffer_Type+1(PktBuff)                                              ; get destination node from LAP header    MOVE.B     toRHA+lapDstAdr(MPPLocals),buffer_NodeID+1(PktBuff)                                              ; get source node from LAP header    MOVE.B     toRHA+lapSrcAdr(MPPLocals),SourceNetAddr    LSL.W      #8,SourceNetAddr               ; shift src node up to high byte of                                              ; low word                                              ; get source socket from short DDP                                              ;  header    MOVE.B     toRHA+lapHdSz+sddpSrcSkt(MPPLocals),SourceNetAddr                                              ; DatagramLength = number of bytes in                                              ; datagram    SUB.W      #sddpType+1,DatagramLengthMoveToBuffer:                                      ;move source network address into PacketBuffer    MOVE.L     SourceNetAddr,buffer_Address(PktBuff)                                      ; move datagram length into PacketBuffer    MOVE.W     DatagramLength,buffer_ActCount(PktBuff); Now that we're done with the PacketBuffer, enqueue it into the usedQ and get; another buffer from the freeQ for the next packet.    LEA        used_queue,A1                   ; A1 = ^used_queue    MOVE.L     (A1),A1                         ; A1 = used_queue (pointer to usedQ)    _Enqueue                                    ; put the PacketBuffer in the usedQGetNextBuffer:    LEA        free_queue,A1                   ; A1 = ^free_queue    MOVE.L     (A1),A1                         ; A1 = free_queue (pointer to freeQ)    LEA        current_qelem, A0               ; copy freeQ.qHead into current_qelem    MOVE.L     qHead(A1),(A0)    MOVEA.L    qHead(A1),A0                    ; A0 = freeQ.qHead    _DequeueRcvRTS:    RTS                                        ; return to callerlistenerSize   EQU     *-SL_TheListener        ; calculate the size of the listenerENDWITH;_________________________________________________________________________; Function SL_InitSktListener(freeQ, usedQ: QHdrPtr;;                             VAR listenerAddress: ProcPtr;;                             VAR listenerLength: LongInt): OSErr;SL_InitSktListener:StackFrame     RECORD    {A6Link},DECR     ; build a stack frame recordResult1        DS.W      1                 ; function's result returned to callerParamBegin     EQU       *                 ; start parameters after this pointfreeQ          DS.L      1                 ; freeQ parameterusedQ          DS.L      1                 ; usedQ parameterlistenerAddress DS.L     1                 ; listenerAddress parameterlistenerLength DS.L      1                 ; listenerLength parameterParamSize      EQU       ParamBegin-*      ; size of all the passed parametersRetAddr        DS.L      1                 ; placeholder for return addressA6Link         DS.L      1                 ; placeholder for A6 linkLocalSize      EQU       *                 ; size of all the local variables               ENDR    WITH       StackFrame,QHdr             ; use these record types    LINK       A6,#LocalSize               ; allocate our local stack frame    MOVEA.L    listenerLength(A6),A2       ; address of listenerLength in A2    MOVE.L     #listenerSize,(A2)          ; return the listener length    LEA        SL_TheListener,A0           ; get address of SL_TheListener    MOVE.L     A0,D0                       ; setup for StripAddress    _StripAddress    MOVEA.L    listenerAddress(A6),A2      ; address of listenerAddresss in A2    MOVE.L     D0,(A2)                     ; return the listener address; copy queue header pointers into our local storage for use in the listener    LEA        used_queue,A0               ; copy usedQ into used_queue    MOVE.L     usedQ(A6),(A0)    LEA        free_queue,A0               ; copy freeQ into free_queue    MOVE.L     freeQ(A6),(A0); dequeue the first buffer record from freeQ and set current_qelem to it    MOVEA.L    freeQ(A6),A1                ; A1 = ^freeQ    LEA        current_qelem, A0           ; copy freeQ.qHead into                                           ; current_qelem    MOVE.L     qHead(A1),(A0)    MOVEA.L    qHead(A1),A0                ; A0 = freeQ.qHead    _Dequeue    MOVE.W     D0,Result1(A6)              ; Return status@1  UNLK       A6                          ; destroy the link    MOVEA.L    (SP)+,A0                    ; pull off the return address    ADDA.L     #ParamSize,SP               ; strip all of the caller's                                           ; parameters    JMP        (A0)                        ; return to the caller    ENDWITH    ENDP    END                                    ; end of this source file</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>Initializing the Socket Listener</h3><P>To initialize the socket listener, define the free and used queue <code>QHdr</code>variables, plus a <code>ProcPtr</code> and length variables for use in getting the address and size of the socket listener code. You'll need to define a <code>PacketBuffer</code> structure to match the record structure defined in the socket listener code. Ifyou add any new fields, then you need to modify the <code>PacketBuffer</code>structure defined in the listener code. In the sample below, an array of 10<code>PacketBuffers</code> is declared.  Initialize the buffer packets, then queuethem into the free queue using the <code>_Enqueue</code> trap. Call<code>SL_InitSktListener</code> and pass the addresses of the <code>QHdr</code>variable for the free and used queues, plus pointers to ProcPtr Address andlength variables.  </p><p>The <code>SL_InitSktListener</code> routine returns the address and size of thesocket listener code so that steps can be taken to protect against a doublepage fault should Virtual Memory be active.  In addition, it is also importantto protect the <code>PacketBuffer</code> memory.  The simplest method to protectthe socket listener code, buffers, and <code>QHdr</code> variables is to detect whetherVirtual Memory is on somewhere during program initialization.  If VirtualMemory is enabled, then call the <code>HoldMemory</code> function, passing each ofthe memory locations and structure sizes as arguments.  Note that the<code>HoldMemory</code> option is preferable to allocating the<code>PacketBuffer</code> memory or loading the socket listener code resource inthe System heap.  A future release of the operating system may not allow anapplication to allocate memory from the system heap.  Remember to use theUnholdMemory function on each memory location passed to <code>HoldMemory</code>.  Thefollowing Pascal code demonstrates a sample initialization technique:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>USES MEMTYPES, QUICKDRAW, OSINTF, APPLETALK;CONST  ddpMaxData = 586;TYPE    PacketBuffer = RECORD        qLink: QElemPtr;        qType: Integer;        buffer_Type: Integer;        buffer_NodeID: Integer;        buffer_Address: AddrBlock;        buffer_Hops: Integer;        buffer_ActCount: Integer;        buffer_CheckSum: OSErr;        buffer_Data: ARRAY[1..ddpMaxData] OF SignedByte;    END;    PacketBufPtr = ^PacketBuffer;VAR    Buffers: ARRAY[1..10] OF PacketBuffer;    freeQ, usedQ: QHdr;    SocketListenerAddr: ProcPtr;    SktListenerLen: LONGINT;    VMEnabled: Boolean;        { determine if VM is enabled using Gestalt }                               { and gestaltVMAttr selector }PROCEDURE SL_TheListener;External;Function SL_InitSktListener(freeQ, usedQ: QHdrPtr;                             VAR listenerAddress: ProcPtr;                             VAR listenerLength: LongInt): OSErrExternal;FUNCTION SetUpSocketListener: OSErr;    VAR        err: OSErr;        i: Integer;    BEGIN        freeQ.QHead := NIL;    { initialize to nil to indicate empty queue }        freeQ.QTail := NIL;    { initialize to nil to indicate end of queue }        usedQ.QHead := NIL;    { initialize to nil to indicate empty queue }        usedQ.QTail := NIL;    { initialize to nil to indicate end of queue }        IF VMEnabled THEN      { VMEnabled is user defined - is true if VM }            BEGIN              {  on }                err := HoldMemory(@Buffers, sizeof(Buffers));  { protect buffer }                IF err = noErr THEN                    err := HoldMemory(@freeQ, sizeof(QHdr));   { protect freeQ }                IF err = noErr THEN                    err := HoldMemory(@usedQ, sizeof(QHdr));   { protect usedQ}            END;        IF err = noErr THEN            BEGIN                FOR i := 1 TO 10 DO                    Enqueue(QElemPtr(Buffers[i]), @freeQ);                               { call socket listener init code }                err := SL_InitSktListener(@freeQ, @usedQ,                                          SocketListenerAddr, SktListenerLen);                IF (err = noErr) AND VMEnabled  THEN                    err = HoldMemory(SocketListenerAddr, SktListenerLen);            END;        SetUpSocketListener := err;    END;</pre>	</TD></TR></TABLE></CENTER><P>For C Programmer's the initialization code is as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include    &lt;types.h&gt;#include    &lt;appletalk.h&gt;#include    &lt;OSUtils.h&gt;#include    &lt;stdio.h&gt;#include    &lt;errors.h&gt;#define ddpMaxData   586typedef struct {    QElemPtr    qLink;    short       qType;    short       buffer_type;        /* DDP Type */    short       buffer_NodeID;      /* Destination Node */    AddrBlock   buffer_Address;     /* Source Address in AddrBlock format */    short       buffer_Hops;        /* Hop count */    short       buffer_ActCount;    /* length of DDP datagram */    OSErr       buffer_CheckSum;    /* Checksum returned here */    char        buffer_Data[ddpMaxData]; /* the DDP datagram */} PacketBuffer;typedef struct PacketBuffer *PacketBufPtr;PacketBufPtr  buffers[10];QHdr          freeQ, usedQ;ProcPtr       SocketListenerAddr;   /* address of socket listener */unsigned longint SktListenerLen;    /* length of listener code */Boolean       VMEnabled;     /* determine if VM is enabled using Gestalt */                             /* and gestaltVMAttr selector */extern void SL_THELISTENER(void);extern pascal OSErr SL_INITSKTLISTENER (QHdrPtr freeQ, QHdrPtr usedQ,                                        ProcPtr *SocketListenerAddr,                                        unsigned longint *SktListenerLen);OSErr SetUpSocketListener(){    OSErr  err = noErr;    short  i;    freeQ.qHead = nil;       /* initialize to nil to indicate empty queue */    freeQ.qTail = nil;       /* initialize to nil to indicate end of queue */    usedQ.qHead = nil;       /* initialize to nil to indicate empty queue */    usedQ.qTail = nil;       /* initialize to nil to indicate end of queue */    if (VMEnabled) {         /* VMEnabled is user defined - is true if VM */                             /*  is on */        err = HoldMemory(&amp;buffers, sizeof(buffers));   /* protect buffers */        if (err == noErr)            err = HoldMemory(&amp;freeQ, sizeof(QHdr));    /* protect freeQ */        if (err == noErr)            err = HoldMemory(&amp;usedQ, sizeof(QHdr));    /* protect usedQ */        if (err)            return (err);    }    for (i = 0; i &lt; 10; i++) {        Enqueue((QElemPtr)&amp;buffers[i], &amp;freeQ);    }                             /* call socket listener init code */    err = SL_INITSKTLISTENER (&amp;freeQ, &amp;usedQ, &amp;SocketListenerAddr, &amp;SktListenerLen);        if ((err == noErr) &amp;&amp; VMEnabled)            err = HoldMemory(SocketListenerAddr, SktListenerLen);    return(err);}</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>Using the Socket Listener</h3><P>The socket listener is set in use with the <code>POpenSkt</code> function, or withthe more specific <code>POpenATPSkt</code> function. The program then periodicallychecks the <code>usedQ.QHead</code> value to determine whether the socket listenerhas processed a packet. If so, the packet is processed, <code>Dequeued</code> fromthe used queue, and <code>Enqueued</code> into the free queue. It's also possiblefor the same socket listener to be used by separate processes in the program.If so, then program must scan the list for the desired packet(s). Note that ifmultiple packets are expected, it is possible that the program may process thefirst packet before the listener processes the second packet.  The programneeds to be designed to check the <code>usedQ.QHead</code> value later for theadditional packets.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>TYPE    PacketBuffer = RECORD        qLink: QElemPtr;        qType: Integer;        buffer_Type: Integer;        buffer_NodeID: Integer;        buffer_Address: AddrBlock;        buffer_Hops: Integer;        buffer_ActCount: Integer;        buffer_CheckSum: OSErr;        buffer_Data: ARRAY[1..ddpMaxData] OF SignedByte;    END;    PacketPtr = ^PacketBuffer;VAR    freeQ, usedQ: QHdr;    bufPtr : PacketPtr;    .    .    .    WHILE (usedQ.QHead &lt;&gt; nil) DO     { is packet available for processing? }        BEGIN            bufPtr := PacketPtr(usedQ.QHead);  { get the packet ptr }            IF (Dequeue(QElemPtr(bufPtr), @usedQ) &lt;&gt; noErr) THEN                BEGIN                    { Process the packet information }                    { requeue the packet buffer for use. }                    Enqueue(QElemPtr(bufPtr), @freeQ);                END            ELSE                BEGIN                    { error occurred dequeueing packet }                    { - perform error processing here }                END;        END;</pre>	</TD></TR></TABLE></CENTER>        <P>For C Programmers, the  socket listener code is used as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct {    QElemPtr    qLink;    short       qType;    short       buffer_type;        /* DDP Type */    short       buffer_NodeID;      /* Destination Node */    AddrBlock   buffer_Address;     /* Source Address in AddrBlock format */    short       buffer_Hops;        /* Hop count */    short       buffer_ActCount;    /* length of DDP datagram */    OSErr       buffer_CheckSum;    /* Checksum returned here */    char        buffer_Data[ddpMaxData]; /* the DDP datagram */} PacketBuffer;typedef PacketBuffer *PacketPtr;QHdr       freeQ, usedQ;PacketPtr  bufPtr;    .    .    .    while (usedQ.QHead != nil) {     /* is packet available for processing */        bufPtr = (PacketPtr)usedQ.QHead;       /* get the packet ptr */        if (Dequeue(QElemPtr(bufPtr), &amp;usedQ) == noErr {            /* Process the packet information */            /* requeue the packet buffer for use. */            Enqueue(QElemPtr(bufPtr), &amp;freeQ);        }        else {            /* error occurred dequeueing packet */            /* - perform error processing here */        }    }</pre>	</TD></TR></TABLE></CENTER>    <P><A HREF="#top">Back to top</A></P>  <h3>The AppleTalk Transition Queue</h3><P>The AppleTalk Transition Queue keeps applications and other resident processeson the Macintosh informed of AppleTalk events, such as the opening and closingof AppleTalk drivers, or changes to the Flagship name (to be discussed later inthis Note). A comprehensive discussion of the AppleTalk Transition Queue ispresented in <i>Inside Macintosh</i> Volume VI, Chapter 32. New to theAppleTalk Transition Queue are messages regarding the Flagship Naming Service,the AppleTalk Multiple Node Architecture (also to be discussed later in thisNote), changes to processor speed that may affect LocalTalk timers, and atransition to indicate change of the network cable range.</p> <P>Later in this section is a sample Transition Queue procedure in both C andPascal which includes the known transition selectors. There is also a samplePascal source for determining whether the LAP Manager version 53 or laterexists. Calling <code>LAPAddATQ</code> for AppleTalk versions 52 and earlier willresult in a system crash since the LAP Manager is not implemented prior toAppleTalk version 53. The Boolean function, <code>LAPMgrExists</code>, should beused instead of checking the low-memory global <code>LAPMgrPtr, $0B18</code>.</p><P><A HREF="#top">Back to top</A></P>  <h3>Bug with LAPAddATQ and LAPRmvATQ Glue Code</h3><P>A bug exists in the glue code for the <code>LAPAddATQ</code> and for the <code>LAPRmvATQ</code> routinesin the Interface.o file of MPW v3.2.x.  The same glue code is used with theThink C v5.0.x product and will affect those users as well.  The glue code forthese routines are correct under MPW v3.3 and for Think C v6.0.  The followingsection remains in this Technote for developers who have not upgraded to theserecent development platforms.</p><p>In the glue code, these calls use the Pascal stack calling convention byallocating memory on the stack for the <code>OSErr</code> result. The <code>ATQEntryPtr</code> is thenpushed onto the stack and the LAP Manager is called.  Upon return from a JSRinstruction to the LAP Manager code, the return address is placed in register<code>A0</code> and the stack incremented. The glue code should then move the two byteresult onto the stack into the location reserved for the result. Instead, theglue code decrements the stack pointer by two bytes before moving the resultonto the stack. The glue code jumps to the return address in register <code>A0</code>. Uponreturn, the stack is off by two bytes.  If local variables are used and arereferenced from the stack pointer in register <code>A7</code>, following the return fromthese LAP Manager calls, access to the local variables may not be correct.  </p><P>The following Assembler glue code is supplied for MPW users to Assemble andlink with their programs. For the remainder of this Technote, the call<code>LAPAddATQFix</code> and <code>LAPRmvATQFix</code> will be used instead and refer to the followingcode. For Think C programmers, the same functions are presented using inlineAssembler. For Think Pascal programmers, one solution is to compile the Think Ccode and to link with the resulting Library file.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>;_________________________________________________________________________;; ATQFix.a;_________________________________________________________________________;; DTS Code Sample;; (c)1992 Apple Computer, Inc.;; Replacement code for LAPAddATQ and LAPRmvATQ in which; the glue code in Interface.o for MPW v3.2.x, does not restore the stack to; it's original condition.  Use the following code as opposed; to that in the Interface.o file.; MWP v3.3 users, disregard;;_________________________________________________________________________;; interface; pascal OSErr LAPAddATQFix(ATQEntryPtr theATQEntry);; pascal OSErr LAPRmvATQFix(ATQEntryPtr theATQEntry);LAPAddATQFix   PROC   EXPORT           MOVE.W     #$0017,D0       ; D0 selector $0017 = LAPAddATQ           MOVEA.L    $0004(A7),A0    ; A0 -&gt; ATQ Proc           MOVEA.L    $0B18,A1        ; Set up to call LAP Manager           MOVE.L     (A7)+,(A7)      ; Move return address up 4 bytes           JSR        $0002(A1)       ; call LAP Manager           MOVEA.L    (A7)+,A0        ; Move return address into A0           MOVE.W     D0,(A7)         ; Move result into space reserved onstack           JMP        (A0)            ; Return           ENDPLAPRmvATQFix   PROC   EXPORT           MOVE.W     #$0018,D0       ; D0 selector $0018 = LAPRmvATQ           MOVEA.L    $0004(A7),A0    ; A0 -&gt; ATQ Proc           MOVEA.L    $0B18,A1        ; Set up to call LAP Manager           MOVE.L     (A7)+,(A7)      ; Move return address up 4 bytes           JSR        $0002(A1)       ; call LAP Manager           MOVEA.L    (A7)+,A0        ; Move return address into A0           MOVE.W     D0,(A7)         ; Move result into space reserved onstack           JMP        (A0)            ; Return           ENDP           END;_________________________________________________________________________; End File: ATQFix.a;_________________________________________________________________________</pre>	</TD></TR></TABLE></CENTER><P>For Think C, v5.x Programmers, the following code sample can be used.  ThinkPascal programmers can link with the library file produced by compiling thiscode with the Think C compiler.  For Think C v6.0 Programmers, the glue codesupplied with the development environment is correct, and the following sampleis not necessary.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* *_________________________________________________________________________ * File: ATQFix.c *_________________________________________________________________________ * * DTS Code Sample * * (c)1992 Apple Computer, Inc. * * Replacement code for LAPAddATQ and LAPRmvATQ for Think C, v5.x programmers * to fix the glue code to fix a bug in the Think C library supplied via * the MPW Interface.o file.  The glue code does not restore the stack to * it's original condition.  Use the following code as opposed * to that in the Think C library instead.  Think C 6.0 programmers do not * need to implement this solution. * *_________________________________________________________________________ */#ifndef __TYPES__#include &lt;Types.h&gt;#endif#define LAPAddATQCall    0x17#define LAPRmvATQCall    0x18#define LAPMgrPtr        0xB18#define LAPMgrCall       2/**********  Prototypes ****************************/pascal OSErr LAPAddATQFix(ATQEntryPtr theATQEntry);pascal OSErr LAPRmvATQFix(ATQEntryPtr theATQEntry);pascal OSErr LAPAddATQFix(ATQEntryPtr theATQEntry){        asm {            MOVE.W     #LAPAddATQCall,D0          /* D0 selector $0017 =LAPAddATQ */            MOVEA.L    theATQEntry,A0             /* A0 -&gt; ATQ Proc */            MOVEA.L    LAPMgrPtr,A1               /* Set up to call LAP Manager*/            JSR        LAPMgrCall(A1)             /* call LAP Manager */            MOVE.W     D0,12(A6)                  /* move result in D0 onto thestack */        }}pascal OSErr LAPRmvATQFix(ATQEntryPtr theATQEntry){        asm {            MOVE.W     #LAPRmvATQCall,D0          /* D0 selector $0018 =LAPRmvATQ */            MOVEA.L    theATQEntry,A0             /* A0 -&gt; ATQ Proc */            MOVEA.L    LAPMgrPtr,A1               /* Set up to call LAP Manager*/            JSR        LAPMgrCall(A1)             /* call LAP Manager */            MOVE.W     D0,12(A6)                  /* move result in D0 onto thestack */        }}/* *_________________________________________________________________________ * End file: ATQFix.c *_________________________________________________________________________ */</pre>	</TD></TR></TABLE></CENTER> <P><A HREF="#top">Back to top</A></P>  <h3>Calling the AppleTalk Transition Queue</h3><P>System software version 7.0 requires the use of the MPW version 3.2 interfacefiles and libraries. The AppleTalk interface presents two new routines forcalling all processes in the AppleTalk Transition Queue. Rather than useparameter block control calls as described in <code>M.NW.AppleTalk2Mac</code>, use the<code>ATEvent</code> procedure or the <code>ATPreFlightEvent</code> function to send transitionnotification to all queue elements. These procedures are discussed in <i>InsideMacintosh</i> Volume VI, Chapter 32.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>You can call the <code>ATEvent</code> and <code>ATPreFlightEvent</code> routines only atvirtual memory safe time. See the Memory Management chapter of <i>InsideMacintosh</i> Volume VI, Chapter 28, for information on virtual memory.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P>  <h3>Standard AppleTalk Transition Constants</h3><P>Use the following constants for the standard AppleTalk transitions:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>CONST    ATTransOpen    = 0;  {open transition }    ATTransClose    = 2;  {prepare-to-close transition }    ATTransClosePrep    = 3;  {permission-to-close transition }    ATTransCancelClose    = 4;  {cancel-close transition }    ATTransNetworkTransition    = 5;  {.MPP Network ADEV Transition }    ATTransNameChangeTellTask    = 6;  {change-Flagship-name transition }    ATTransNameChangeAskTask    = 7;  {permission-to-change-Flagship-name trans }    ATTransCancelNameChange    = 8;  {cancel-change-Flagship-name transition }    ATTransCableChange    = 'rnge' {cable range change transition }    ATTransSpeedChange    = 'sped' {change in cpu speed }</pre>	</TD></TR></TABLE></CENTER>    <P>The following information concerns the new transitions from<code>ATTransNetworkTransition</code> through <code>ATTransSpeedChange</code>.</p><P><A HREF="#top">Back to top</A></P>  <h3>The Flagship Naming Service</h3><P>System software version 7.0 allows the user to enter a personalized name bywhich her system will be published when connected to an AppleTalk network. TheSystem <code>'STR '</code> resource ID -16413 is used to hold this name. The name (listed asMacintosh Name) can be up to 31 characters in length and can be set using theSharing Setup Control Panel Device (cdev). This resource is different from theChooser name, System <code>'STR '</code> resource ID -16096. When providing network servicesfor a workstation, the Flagship name should be used so that the user canpersonalize his workstation name while maintaining the use of the Chooser namefor server connection identification. It's important to note that the Flagshipname resource is available only from system software version 7.0. DTSrecommends that applications not change either of these 'STR ' resources.</p><P>Applications taking advantage of this feature should place an entry in theAppleTalk Transition Queue to stay informed as to changes to this name. Threenew transitions have been defined to communicate Flagship name changes betweenapplications and other resident processes. Support for the Flagship NamingService Transitions is provided starting from AppleTalk version 56. Note thatAppleTalk version 56 can be installed on pre-7.0 systems; however, the FlagshipNaming Service  is available only from System 7.0 and later.</p><P><A HREF="#top">Back to top</A></P>  <h3>The ATTransNameChangeAskTask Transition</h3><P>From Assembly language, the stack upon calling looks as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>ATQEvent            RECORD   0ReturnAddr          DS.L     1      ; address of callertheEvent            DS.L     1      ; = 7; ID of ATTransNameChangeAskTasktransactionaqe                 DS.L     1      ; pointer to task recordinfoPtr             DS.L     1      ; pointer to NameChangeInfo parameterblock                    ENDR</pre>	</TD></TR></TABLE></CENTER>                    <p>The <code>NameChangeInfo</code> record block is as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>NameChangeInfoPtr: ^NameChangeInfo;NameChangeInfo  = RECORD                    newObjStr:     Str32;       {new Flagship name to change to}                    name:          StringPtr;   {ptr to location to place ptrto process }                                                {name }                  END;</pre>	</TD></TR></TABLE></CENTER>                  <P>The <code>ATTransChangeNameAskTask</code> is issued under system software version7.0 to inform Flagship clients that a process wants to change the Flagshipname. Each AppleTalk Transition Queue element that  processes the<code>ATTransChangeNameAskTask</code> can inspect the<code>NameChangeInfoPtr^.newObjStr</code> to determine the new Flagship name. Ifyou deny the request, you must set the <code>NameChangeInfoPtr^.name</code> pointerwith a pointer to a Pascal string buffer containing the name of yourapplication <b>or</b> to the nil pointer. The AppleTalk Transition Queueprocess returns this pointer. The requesting application can display a dialognotifying the user of the name of the application that  refused the changerequest.</p><p>While processing this event, you can make synchronous calls to the Name-BindingProtocol (NBP) to attempt to register your entity under the new name. It isrecommended that you register an entity using the new Flagship name whilehandling the <code>ATTransChangeNameAskTask</code> event. You should not deregisteran older entity at this point. Your routine must return a function result of 0in the D0 register, indicating that it accepts the request to change theFlagship name, or a non zero value, indicating that it denies the request.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Warning:</B><BR>DTS does not recommend that you change the Flagship name. TheSharing Setup cdev does not handle this event and the Macintosh name will notbe updated to reflect this change if the cdev is open.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P>  <h3>The ATTransNameChangeTellTask Transition</h3><P>From Assembly language, the stack upon calling looks as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>ATQEvent       RECORD  0ReturnAddr     DS.L   1   ; address of callertheEvent       DS.L   1   ; = 6 ID of ATTransNameChangeTellTask transactionaqe            DS.L   1   ; pointer to task recordinfoPtr        DS.L   1   ; pointer to the new Flagship name               ENDR</pre>	</TD></TR></TABLE></CENTER>               <P>A process uses <code>ATEvent</code> to send the <code>ATTransNameChangeTellTask</code>to notify AppleTalk Transition Queue clients that the Flagship name is being changed. The LAP Manager then calls every routine in the AppleTalk Transition Queue that the Flagship name is being changed.</p><p>When the AppleTalk Manager calls your routine with a<code>ATTransNameChangeTellTask</code> transition, the third item on thestack is a pointer to a Pascal string of the new Flagship name to beregistered. Your process should deregister any entities under the old Flagshipname at this time. You can make synchronous calls to NBP to deregister anentity. Return a result of <code>0</code> in the <code>D0</code> register.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>When the AppleTalk Manager calls your process with a <code>TellTask</code>transition (that is, with a routine selector of<code>ATTransNameChangeTellTask</code>), you cannot prevent the Flagship name frombeing changed.</P></TD></TR></TABLE></CENTER><BR><p>To send notification that your process intends to change the Flagship name, usethe <code>ATEvent</code> function described above. Pass <code>ATTransNameChangeTellTask</code>as the event parameter and a pointer to the new Flagship name (Pascal string)as the <code>infoPtr</code> parameter.</p><P><A HREF="#top">Back to top</A></P>  <h3>The ATTransCancelNameChange Transition</h3><P>From Assembly language, the stack upon calling looks as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>ATQEvent    RECORD    0ReturnAddr    DS.L    1    ; address of callertheEvent    DS.L    1    ; = 8; ID of ATTransCancelNameChange transactionaqe    DS.L    1    ; pointer to task record    ENDR</pre>	</TD></TR></TABLE></CENTER><P>The <code>ATTransCancelNameChange</code> transition complements theATTransNameChangeAskTask transition. Processes that acknowledged an<code>ATTransNameChangeAskTask</code> transition will be sent the<code>ATTransCancelNameChange</code> transition if a later process disallows thechange of Flagship name. Your process should deregister any NBP entitiesregistered during the <code>ATTransNameChangeAskTask</code> transition. You canmake synchronous calls to NBP to deregister an entity. Return a result of 0 inthe D0 register.</p><P><A HREF="#top">Back to top</A></P>  <h3>System 7.0 Sharing Setup cdev / Flagship Naming Service Interaction:</h3><P>The Flagship Naming Service is a new system service built into System 7. It isused to publish the workstation using the Flagship name. The Flagship NamingService implements an AppleTalk Transition Queue element to respond to changesin the Flagship name. For example, the Sharing Setup cdev can be used to resetthe Flagship name. When a new Macintosh (Flagship) name is entered in SharingSetup, Sharing Setup sends an <code>ATTransNameChangeAskTask</code> message to theAppleTalk Transition Queue to request permission to change the Flagship name.The Flagship Naming Service receives the <code>ATTransNameChangeAskTask</code>transition and registers the new name under the type "Workstation" on the localnetwork. Sharing Setup follows with the <code>ATTransNameChangeTellTask</code> tonotify AppleTalk Transition Queue clients that a change in Flagship name willoccur. The Flagship Naming Service responds by deregistering the workstationunder the old Flagship name.</p><p>If an error occurs from the <code>NBPRegister</code> call, Flagship Naming Service returns anon-zero error (the error returned from <code>NBPRegister</code>) and a pointer to its namein the <code>NameChangeInfoPtr^.Name</code> field. Note that the Workstation nameis still registered under the previous Flagship name at this point.</p><P><A HREF="#top">Back to top</A></P>  <h3>AppleTalk Remote Access Network Transition Event</h3><P>AppleTalk Remote Access allows you to establish an AppleTalk connection betweentwo Macintosh computers over standard telephone lines. If the Macintosh youdial-in to is on an AppleTalk network, such as LocalTalk or Ethernet, yourMacintosh becomes, effectively, a node on that network. You are then able touse all the services on the new network. Given this new capability, it isimportant that services running on your Macintosh be notified when newAppleTalk connections are established and broken. For this reason, theATTransNetworkTransition event has been added to AppleTalk version 57.With version 57 present, this event can be expected in system software version6.0.5 or later.</p><p>Internally, both the AppleTalk Session Protocol (ASP) and the AppleTalk DataStream Protocol (ADSP) have been modified to respond to this transition event.When a disconnect transition event is detected, these drivers close downsessions on the remote side of the connection.</p><P><A HREF="#top">Back to top</A></P>  <h3>The ATTransNetworkTransition Transition</h3><P>From Assembly language, the stack upon calling looks as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>ATQEvent    RECORD    0ReturnAddr    DS.L    1    ; address of callertheEvent    DS.L    1    ; = 5; ID of ATTransNetworkTransitionaqe    DS.L    1    ; pointer to task recordinfoPtr    DS.L    1    ; pointer to the TNetworkTransition record    ENDR</pre>	</TD></TR></TABLE></CENTER><p>The <code>TNetworkTransition</code> record block is passed as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>TNetworkTransition    RECORD    0private    DS.L    1    ; pointer used internally by AppleTalk Remote AccessnetValidProc    DS.L    1    ; pointer to the network validate procedurenewConnectivity    DS.B    1    ; true = new connectivity, false = loss ofconnectivity    ENDR</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3> Network Transition Event for AppleTalk Remote Access</h3><P>Network Transition events are generated by AppleTalk Remote Access to informAppleTalk Transition Queue applications and resident processes that networkconnectivity has changed. The type of change is indicated by the<code>NetTransPtr^.newConnectivity</code> flag. If this flag is true, a connectionto a new internet has taken place. In this case, all network addresses will bereturned as reachable. If the <code>newConnectivity</code> flag is false, certainnetworks are no longer reachable. Since AppleTalk Remote Access is connectionbased, it has knowledge of where a specific network exists. AppleTalk RemoteAccess can take advantage of that knowledge during a disconnect to informAppleTalk Transition Queue clients that a network is no longer reachable. Thisinformation can be used by clients to age out connections immediately ratherthan waiting a potentially long period of time before discovering that theother end is no longer responding.</p><p>When AppleTalk Remote Access is disconnecting, it passes a network validationhook in the <code>TNetworkTransition</code> record, <code>NetTransPtr^.netValidProc</code>. Aclient can use the validation hook to ask AppleTalk Remote Access whether aspecific network is still reachable. If the network is still reachable, thevalidate function will return true. A client can then continue to check othernetworks of interest until the status of each one has been determined. After aclient has finished checking networks, control returns to AppleTalk RemoteAccess where the next AppleTalk Transition Queue client is called.</p><p>The information the network validation hook returns is valid only if a clienthas just been called as a result of a transition. A client can validatenetworks only when she has been called to handle a Network Transition event.Note that the Network Transition event can be called as the result of aninterrupt, so a client should obey all of the normal conventions involved withbeing called at this time (for example, don't make calls that move memory anddon't make <i>synchronous</i> Preferred AppleTalk calls).</p><p>To check a network number for validity the client uses the network validateprocedure to call AppleTalk Remote Access. This call is defined using C callingconventions as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal long netValidProc(TNetworkTransition *thetrans, unsigned longtheAddress);    thetrans    --&gt;    Pass in the TNetworkTransition record given to you when your               transition handler was called.    theAddress    --&gt;    This is the network address you want checked. The formatof            theAddress is the same as AddrBlock as defined in <i>Inside</i>            <i>Macintosh</i> II, page 281:            Bytes 2 &amp; 3 (High Word) - Network Number            Byte 1 - Node Number            Byte 0 (Low Byte) - Socket Number</pre>	</TD></TR></TABLE></CENTER><p>Result codes<br>true    network is still reachable<br>false    network is no longer reachable</P><P>AppleTalk Transition Queue handlers written in Pascal must implement glue codeto use the <code>netValidProc</code>.</p><P><A HREF="#top">Back to top</A></P>  <h3>Cable Range Change Transition Event</h3><P>The Cable Range Transition, <code>ATTransCableChange</code>, event informsAppleTalk Transition Queue processes that the cable range for the currentnetwork has changed. This can occur when a router is first seen, when the lastrouter ages out, or when an RTMP broadcast packet is first received with acable range that is different from the current range. The<code>ATTransCableChange</code> event is implemented beginning with AppleTalkversion 57. This transition is useful when an application must stay informed asto the presence of zones.  With version 57 present, this event can be expectedin system software version 6.0.5 and later.</p><P><A HREF="#top">Back to top</A></P>  <h3>The ATTransCableChange Transition</h3><P>From Assembly language, the stack upon calling looks as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>ATQEvent    RECORD    0ReturnAddr    DS.L    1    ; address of callertheEvent    DS.L    1    ; = 'rnge'; ID of ATTransCableChangeaqe    DS.L    1    ; pointer to task recordinfoPtr    DS.L    1    ; pointer to the TNetworkTransition record    ENDR</pre>	</TD></TR></TABLE></CENTER>    <P>The <code>TNewCRTrans</code> record block is passed as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>TNewCRTrans    RECORD    0newCableLo    DS.W    1    ; the new Cable Lo received from RTMPnewCableHi    DS.W    1    ; the new Cable Hi received from RTMP    ENDR</pre>	</TD></TR></TABLE></CENTER><P>The cable range is a range of network numbers starting from the lowest networknumber through the highest network number defined by a seed router for anetwork. All node addresses acquired on a network must have a network numberwithin the defined cable range. For non extended networks, the lowest and thehighest network numbers are the same. If the cable range on the networkchanges, for example, if the router on the network goes down, the Cable RangeChange event will be issued with the parameters described earlier in thisTechnical Note.</p><p>After receiving the event, a multinode application should use the new cablerange to check if all the multinodes it obtained prior to the event are stillvalid. For the invalid multinodes, the application should issue the .MPP<code>RemoveNode</code> control call to get rid of invalid nodes. The .MPP<code>AddNode </code>control call can be issued immediately after removing invalidnodes to obtain new valid multinodes in the new cable range. This Cable RangeChange Transition event will be issued only during system task time.</p><P><A HREF="#top">Back to top</A></P>  <h3>The Speed Change Transition Event</h3><P>The <code>ATTransSpeedChange</code> Transition event is defined for applicationsthat change CPU speed without rebooting, to notify time-dependent processesthat such change has taken place. Such speed change occurs when altering thecache states on the 68030 or 68040 CPUs, or with third-party accelerator cardsthat allow speed changes on the fly via a cdev. Any process that alters theeffective CPU speed should use the <code>ATEvent</code> to notify processes of thischange. Issue the <code>ATTransSpeedChange </code>event <b>only</b> at<code>SystemTask</code> time! Any process that depends on changes to the CPU speedshould watch for this event. The Speed Change Transition event is issued onlyduring system task time.</p><p>One time-dependent code module is LocalTalk, whose low-level timer values mustbe recalculated when the CPU speed changes. Note that altering the cache stateon the 68030 does not affect LocalTalk; however, doing so on the 68040 doesaffect LocalTalk timers. This event must be sent by any application thattoggles caching on the 68040 processor on the fly. If the cache is toggled andLocalTalk is not notified, a loss of network connection will result ifLocalTalk is the current network connection. Note that only LocalTalkimplemented in AppleTalk version 57 or later recognizes the Speed ChangeTransition event. Contact Apple Software Licensing for licensing AppleTalkversion 57.</p><p>Regarding LocalTalk on the Macintosh Plus, the timing values are hard-coded inROM regardless of the CPU speed. Vendors of accelerators for Macintosh Pluscomputers should contact DTS for information on how to make LocalTalk work foryou.</p><P><A HREF="#top">Back to top</A></P>  <h3>The ATTransSpeedChange Transition</h3><P>From Assembly language, the stack upon calling looks as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>ATQEvent    RECORD    0ReturnAddr    DS.L    1    ; address of callertheEvent    DS.L    1    ; = 'sped'; ID of ATTransSpeedChangeaqe    DS.L    1    ; pointer to task record    ENDR</pre>	</TD></TR></TABLE></CENTER><P>To notify LocalTalk that a change in processor speed has taken place, use the<code>ATEvent</code>  procedure. Pass<code> ATTransSpeedChange</code> as the <code>event</code>parameter and a nil pointer as the<code> infoPtr </code>parameter. This eventmust be issued only at system task time.  The <code>ATEvent</code>  procedure isimplemented as a glue routine in MPW 3.2 or greater.  The following line ofcode demonstrates notification of the <code>ATTransSpeedChange</code> event.</p><P><code>ATEvent (ATTransSpeedChange, nil);</code></P><P><A HREF="#top">Back to top</A></P>  <h3>Sample Pascal Source to LAPMgrExists Function</h3><P>It is important to check whether the LAP Manager exists before making LAPManager calls like <code>LAPAddATQ</code>. The LAP Manager is implemented beginningwith AppleTalk version 53. Rather than check the low-memory global<code>LAPMgrPtr</code>, it is preferable to check for its existence from a higherlevel. The following Pascal source demonstrates this technique:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION GestaltAvailable: Boolean;CONST    _Gestalt = $A1AD;BEGIN    GestaltAvailable := TrapAvailable(_Gestalt);    { TrapAvailable is documented in Inside Macintosh Volume VI, page 3-8 }END;FUNCTION AppleTalkVersion: Integer;CONST    versionRequested = 1; { version of SysEnvRec }VAR    refNum: INTEGER;    world: SysEnvRec;    attrib: LONGINT;BEGIN    AppleTalkVersion := 0;    { default to no AppleTalk }    IF OpenDriver('.MPP', refNum) = noErr THEN    { open the AppleTalk driver }        IF GestaltAvailable THEN        BEGIN            IF (Gestalt(gestaltAppleTalkVersion, attrib) = noErr) THEN                AppleTalkVersion := BAND(attrib, $000000FF);        END        ELSE    { Gestalt or gestaltAppleTalkVersion selector isn't available. }            IF SysEnvirons(versionRequested, world) = noErr THEN                AppleTalkVersion := world.atDrvrVersNum;END;FUNCTION LAPMgrExists: Boolean;BEGIN    { AppleTalk phase 2 is in AppleTalk version 53 and later }    LAPMgrExists := (AppleTalkVersion &gt;= 53);END;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>Sample AppleTalk Transition Queue Function</h3><P>A sample AppleTalk Transition Queue function has been implemented in both C andPascal. These samples have been submitted as snippet code to appear on the<i>Developer CD Series</i> disc. Since Transition Queue handlers are calledwith a C-style stack frame, the Pascal sample includes the necessary C glue.</p><P><A HREF="#top">Back to top</A></P>  <h3>Sample AppleTalk Transition Queue Function in C</h3><P>The following is a sample AppleTalk Transition Queue handler for C programmers.To place the handler in the AppleTalk Transition Queue, define a structure oftype <code>myATQEntry</code> in the main body of the application. Assign theSampleTransQueue function to the <code>myATQEntry.CallAddr</code> field. Use the<code>LAPAddATQFixed </code>function to add the handler to the AppleTalk TransitionQueue. Remember to remove the handler with the <code>LAPRmvATQFixed</code> functionbefore quitting the application.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Warning:</B><BR>The System 7 Tuner extension will not load AppleTalk resourcesif it detects that AppleTalk is off at boot time. Remember to check the resultfrom the <code>LAPAddATQFixed</code> function to determine whether the handler wasinstalled successfully.</P></TD></TR></TABLE></CENTER><BR> <P>The following code was written with MPW C v3.2:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/*----------------------------------------------------------------------  file: TransQueue.h----------------------------------------------------------------------*/#include &lt;AppleTalk.h&gt;/* *  Transition Queue routines are designed with C calling conventions inmind. *  They are passed parameters with a C-style stack and return values areexpected *  to be in register D0. */#define ATTransOpen                    0        /* .MPP just opened */#define ATTransClose                    2        /* .MPP is closing */#define ATTransClosePrep                3        /* OK for .MPP to close? */#define ATTransCancelClose            4        /* .MPP close was canceled */#define ATTransNetworkTransition    5        /* .MPP Network ADEV transition */#define ATTransNameChangeTellTask    6        /* Flagship name is changing */#define ATTransNameChangeAskTask    7        /* OK to change Flagship name */#define ATTransCancelNameChange        8        /* Flagship name change was canceled */#define ATTransCableChange            'rnge'    /* Cable Range Change has occurred */#define ATTransSpeedChange            'sped'    /* Change in processor speed has occurred*//*----------------------------------------------------------------------        NBP Name Change Info record----------------------------------------------------------------------*/typedef struct NameChangeInfo {    Str32     newObjStr;    /* new NBP name */    Ptr    name;            /* Ptr to location to place a pointer to Pascal string of */                            /* name of process that NAK'd the event */}    NameChangeInfo, *NameChangePtr, **NameChangeHdl;/*----------------------------------------------------------------------        Network Transition Info Record----------------------------------------------------------------------*/typedef struct TNetworkTransition {    Ptr        private;            /* pointer to private structure */    ProcPtr    netValidProc;        /* pointer to network validation procedure */    Boolean     newConnectivity;    /* true = new connection */                                     /* false = loss of connection */}    TNetworkTransition , *TNetworkTransitionPtr, **TNetworkTransitionHdl;typedef    pascal long    (*NetworkTransitionProcPtr)(TNetworkTransitionPtr netTrans,\                      unsigned long theNet);/*----------------------------------------------------------------------        Cable Range Transition Info Record----------------------------------------------------------------------*/typedef struct TNewCRTrans {    short    newCableLo;    /* the new Cable Lo received from RTMP */    short    newCableHi;    /* the new Cable Hi received from RTMP */}    TNewCRTrans , *TNewCRTransPtr, **TNewCRTransHdl;/*----------------------------------------------------------------------        AppleTalk Transition Queue Element----------------------------------------------------------------------*/typedef struct    myATQEntry {    Ptr        qLink;        /* -&gt; next queue element */    short        qType;        /* unused */    ProcPtr    CallAddr;    /* -&gt; transition procedure */    Ptr        globs;        /* -&gt; to user defined globals */}    myATQEntry, *myATQEntryPtr, **myATQEntryHdl;/*----------------------------------------------------------------------  file: TransQueue.c----------------------------------------------------------------------*/#include &lt;Memory.h&gt;#include &lt;AppleTalk.h&gt;#include &quot;TransQueue.h&quot;long SampleTransQueue(long selector, myATQEntry *q, void *p){    long                        returnVal = 0; /* return 0 for unrecognized events */    NameChangePtr                myNameChangePtr;    TNewCRTransPtr            myTNewCRTransPtr;      TNetworkTransitionPtr    myTNetworkTransitionPtr;    NetworkTransitionProcPtr    myNTProcPtr;    StringPtr                    newNamePtr;    long                        checkThisNet;    char                         **t;    short                        myCableLo, myCableHi;    /*     * This is the dispatch part of the routine. We'll check the selector passed into     * the task; its location is 4 bytes off the stack (selector).     */    switch(selector) {        case ATTransOpen:            /*             *  Someone has opened the .MPP driver. This is where one would reset the             *  application to its usual network state (that is, you could register your             *  NBP name here). Always return 0.             */            break;        case ATTransClose:            /*             *  When this routine is called, .MPP is going to shut down no matter what we             *  do. Handle that type of situation here (that is, one could remove an NBP             *  name and close down all sessions); 'p' will be nil. Return 0             *  to indicate no error.             */            break;        case ATTransClosePrep:            /*             *  This event gives us the chance to deny the closing of AppleTalk if we             *  want. Returning    a value of 0 means it's OK to close; nonzero             *  indicates we'd rather not close at this time.             *             *  With this event, the parameter 'p' actually means something. 'p' in             *  this event is a pointer to an address that can hold a pointer to a             *  string of our choosing. This string indicates to the user which task             *  would rather not close. If you don't want AppleTalk to close, but you             *  don't have a name to stick in there, you MUST place a nil value in             *  there instead.             *             *  (We're doing this all locally to this case because it's C and we can, so             *  there.)             */            newNamePtr = (StringPtr)NewPtr(sizeof(Str32));            /*             *  Assume Ptr allocation successful.             */            newNamePtr = &quot;\pBanana Mail&quot;;    /* This will either be an Ax reference or PC             *  relative depending on compiler and options. */            /*             *  Get a new reference to the address we were passed (in a form we can use).             */            t = (char **) p;            /*             *  Place the address of our string into the address we were passed.             */            *t = (char *)newNamePtr;            /*             *  Return a nonzero value so that AppleTalk knows we'd rather not close.             */            returnVal = 1;            break;        case ATTransCancelClose:            /*             *  Just kidding, we didn't really want to cancel that AppleTalk closing             *  after all. Reset all your network activities that you have disabled*  here (if any). In our case, we'll just fall through. 'p' will be nil.             */            break;        case ATTransNetworkTransition:            /*             *  A Remote AppleTalk connection has been made or broken.             *  'p' is a pointer to a TNetworkTransition record.             *   Always return 0.             */            myTNetworkTransitionPtr = (TNetworkTransitionPtr)p;            /*             *  Check newConnectivity element to determine whether             *  Remote Access is coming up or going down.             */            if (myTNetworkTransitionPtr-&gt;newConnectivity) {                /*                 * Have a new connection                 */            }            else {                /*                 * Determine which network addresses need to be validated                 * and assign the value to checkThisNet.                 */                checkThisNet = 0x1234FD80;  /* network 0x1234, node 0xFD, socket 0x80 */                myNTProcPtr = (NetworkTransitionProcPtr)myTNetworkTransitionPtr-&gt;netValidProc;                if ((*myNTProcPtr)(myTNetworkTransitionPtr, checkThisNet)) {                    /*                     * Network is still valid.                     */                }                else {                    /*                     * Network is no longer valid.                     */                }            }            break;        case ATTransNameChangeTellTask:            /*             *  Someone is changing the Flagship name and there is nothing we can do.             *  The parameter 'p' is a pointer to a Pascal-style string that holds the new             *  Flagship name.               */            newNamePtr = (StringPtr) p;            /*             *  You should deregister any previously registered NBP entries under the             *  'old' Flagship name. Always return 0.             */            break;        case ATTransNameChangeAskTask:            /*             *  Someone is messing with the Flagship name.             *  With this event, the parameter 'p' actually means something. 'p' is             *  a pointer to a NameChangeInfo record. The newObjStr field contains the             *  new Flagship name. Try to register a new entity using the new Flagship name.             *  Returning a value of 0 means it's OK to change the Flagship name.             */            myNameChangePtr = (NameChangePtr)p;            /*             *  If the NBPRegister is unsuccessful, return the error. You must also set             *  p-&gt;name pointer with a pointer to a Pascal-style string of the process             *  name.             */            break;        case ATTransCancelNameChange:            /*             *  Just kidding, we didn't really want to change that name after             *  all. Remove new NBP entry registered under the ATTransNameChangeAskTask             *  Transition. In our case,  we'll just fall through. 'p' will be nil. Remember             *  to return 0.             */            break;        case ATTransCableChange:            /*             *  The cable range for the network has changed. The pointer 'p' points             *  to a structure with the new network range. (TNewCRTransPtr)p-&gt;newCableLo             *  is the lowest value of the new network range. (TNewCRTransPtr)p-&gt;newCableHi             *  is the highest value of the new network range. After handling this event,             *  always return 0.             */            myTNewCRTransPtr = (TNewCRTransPtr)p;            myCableLo = myTNewCRTransPtr-&gt;newCableLo;            myCableHi = myTNewCRTransPtr-&gt;newCableHi;            break;        case ATTransSpeedChange:            /*             *  The processor speed has changed. Only LocalTalk responds to this event.             *  We demonstrate this event for completeness only.             *  Always return 0.             */            break;        default:            /*             *  For future Transition Queue events (and yes, Virginia, there will be more).             */            break;    } /* end of switch */    /*     *    return value in register D0     */    return returnVal;}</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>Sample AppleTalk Transition Queue Function in Pascal</h3><P>The following is a sample AppleTalk Transition Queue handler for Pascalprogrammers. AppleTalk Transition Queue handlers are passed parameters usingthe C parameter passing convention. In addition, the 4-byte function resultmust be returned in register D0. To meet this requirement, a C procedure isused to call the handler, then to place the 4-byte result into register D0. Thestub procedure listing follows the handler.</p> <P>To place the handler in the AppleTalk Transition Queue, define a structure oftype <code>myATQEntry</code> in the main body of the application. Assign the<code>CallTransQueue </code>C procedure to the <code>myATQEntry.CallAddr </code>field.  Use the <code>LAPAddATQFixed</code> function to add the handler to the AppleTalkTransition Queue. Remember to remove the handler with the<code>LAPRmvATQFixed</code> function before quitting the application.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The System 7 Tuner extension will not load AppleTalk resources ifit detects that AppleTalk is off at boot time. Remember to check the resultfrom the <code>LAPAddATQFixed</code> function to determine whether the handler wasinstalled successfully.</P></TD></TR></TABLE></CENTER><BR><P>The following code was written with MPW Pascal and Assembler v3.2:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>{*******************************************************************************  file: TransQueueGlue.a********************************************************************************;FUNCTION CallTransQueue(selector : LONGINT; q : ATQEntryPtr; p : Ptr) : LONGINT; ;EXTERNAL;;{; *  CallTransQueue is the routine passed to the LAP Manager using the LAPAddATQ; *  function.  This glue routine is necessary since the LAP Manager sends stack; *  parameters in the C stack passing convention.  Before calling the LAPAddATQ; *  function, the users set the PATQProcPtr to the address of the PAscal style; *  ATQ handler.  The glue routine takes the parameters from the stack and sets up; *  a Pascal stack, then calls the function pointed to by the PATQProcPtr field.; *  On return, the result is pulled from the stack and put into the D0 register; *  where the LAP Manager expects the result.  This routine must be written in; *  Assembler or C; *; }CallTransQueue    PROC    EXPORT           LINK       A6,#$0000       ; set up a local stack frame }           CLR.L      -(A7)           ; set space for return result }           MOVE.L     $0008(A6),-(A7) ; move selector to stack }           MOVE.L     $000C(A6),-(A7) ; move ATQPtr to stack }           MOVEA.L    $000E(A7),A0    ; move Ptr to pascal ATQ func to stack }           MOVE.L     $0010(A6),-(A7) ; move last parameter - Ptr to stack }           JSR        (A0)            ; call the pascal ATQ func }           MOVE.L     (A7)+,D0        ; move result into D0 }           UNLK       A6              ; tear down local stack frame }           RTS                        ; return           ENDP           END{*******************************************************************************  file: TransQueue.p********************************************************************************UNIT TransQueue;INTERFACEUSES MemTypes, QuickDraw, OSIntF, AppleTalk;CONST(*  Comment the following 4 constants since they are already defined in the AppleTalk unit.    ATTransOpen                 =   0;  { .MPP is opening }    ATTransClose                =   2;  { .MPP is closing }    ATTransClosePrep            =   3;  { OK for .MPP to close? }    ATTransCancelClose          =   4;  { .MPP close was canceled }*)    ATTransNetworkTransition    =   5;  { .MPP Network ADEV transition }    ATTransNameChangeTellTask   =   6;  { Flagship name is changing }    ATTransNameChangeAskTask    =   7;  { OK to change Flagship name }    ATTransCancelNameChange     =   8;  { Flagship name change was canceled.}    ATTransCableChange          =   'rnge'; { Cable Range Change has occurred.}    ATTransSpeedChange          =   'sped'; { Change in processor speed hasoccurred. }{----------------------------------------------------------------------        NBP Name Change Info record----------------------------------------------------------------------}TYPENameChangeInfo = RECORD    newObjStr    : Str32;        { new NBP name }    name        : Ptr;            { Ptr to location to place a pointer to Pascal string of }                                { name of process that NAK'd the event }    END;NameChangePtr = ^NameChangeInfo;NameChangeHdl = ^NameChangePtr;{----------------------------------------------------------------------        Network Transition Info Record----------------------------------------------------------------------}TNetworkTransition = RECORD    private        : Ptr;            { pointer to private structure }    netValidProc    : ProcPtr;    { pointer to network validation procedure }    newConnectivity : Boolean;    { true = new connection, }                                     { false = loss of connection }    END;TNetworkTransitionPtr = ^TNetworkTransition;TNetworkTransitionHdl = ^TNetworkTransitionPtr;{ The netValidProc procedure has the following C interface. Note the }{ CallNetValidProc C function, which follows. The C Glue routine allows thePascal }{ handler to make the call to the netValidProc function. }{typedef pascal long    (*NetworkTransitionProcPtr)(TNetworkTransitionPtr netTrans,\                      unsigned long theNet);}{----------------------------------------------------------------------        Cable Range Transition Info Record----------------------------------------------------------------------}TNewCRTrans = RECORD    newCableLo    : INTEGER;    { the new Cable Lo received from RTMP }    newCableHi    : INTEGER;    { the new Cable Hi received from RTMP }    END;TNewCRTransPtr = ^TNewCRTrans;TNewCRTransHdl = ^TNewCRTransPtr;{----------------------------------------------------------------------        AppleTalk Transition Queue Element----------------------------------------------------------------------}myATQEntry = RECORD    qlink        : Ptr;            { -&gt; next queue element }    qType        : INTEGER;    { unused }    CallAddr    : ProcPtr;    { -&gt; transition procedure }    globs        : Ptr;            { -&gt; to user defined globals }    PATQProcPtr    : ProcPtr;    {.-&gt; to pascal ATQ routine }    END;myATQEntryPtr = ^myATQEntry;myATQEntryHdl = ^myATQEntryPtr;{---------------- Prototypes --------------------}FUNCTION SampleTransQueue (selector :LONGINT; q :myATQEntryPtr;  p :Ptr) :LONGINT;{ *  Transition Queue routines are designed with C calling conventions in mind. *  They are passed parameters with a C-style stack and return values are expected *  to be in register D0. Note that the CallTransQueue C glue routine is used *  to reverse the C-style stack to Pascal style before calling the handler. The *  procedure CallTransQueue follows this listing. To install this Trans Queue *  handler, assign CallTransQueue to the CallAddr field, NOT SampleTransQueue. }FUNCTION CallNetValidProc(netTrans : TNetworkTransitionPtr; theNet : LONGINT;                          p : ProcPtr) : LONGINT;{ *  CallNetValidProc is used to call the netValidProc passed in theTNetworkTransition *  record. Since Pascal cannot call the ProcPtr directly, a glue routine is *  used. }    INLINE        $205F,  { MOVEA.L  (SP)+,A0 ; get ProcPtr into A0, and make stack right for call }        $4E90;  { JSR      (A0)     ; call ProcPtr, and return to caller }IMPLEMENTATIONFUNCTION SampleTransQueue (selector :LONGINT; q :myATQEntryPtr;  p :Ptr) :LONGINT;VAR    returnVal                    : LONGINT;    myNameChgPtr                : NameChangePtr;    myTNewCRTransPtr            : TNewCRTransPtr;    myTNetworkTransitionPtr    : TNetworkTransitionPtr;    newNamePtr                : StringPtr;    processNameHdl            : StringHandle;    myCableLo, myCableHi        : INTEGER;    shortSelector                : INTEGER;    checkThisNet                : LONGINT;BEGIN    returnVal := 0;                     { return 0 for unrecognized events )    {     *  This is the dispatch part of the routine. We'll check the selector passed into     *  the task; its location is 4 bytes off the stack (selector).     }    IF ((selector &lt;= ATTransCancelNameChange) AND (selector &gt;= ATTransOpen)) THEN    {     *  Check whether a numeric selector is being used whose known values are between     *  8 and 0 so that we can implement a CASE statement with an INTEGER var.     }    BEGIN        shortSelector := selector;        CASE shortSelector OF            ATTransOpen:            BEGIN                {                 *  Someone has opened the .MPP driver. This is where one would reset the                 *  application to its usual network state (that is, you could register your                 *  NBP name here). Always return 0.                 }            END;            ATTransClose:            BEGIN                {                 *  When this routine is called, .MPP is going to shut down no matter what we                 *  do. Handle that type of situation here (that is, one could remove an NBP                 *  name and close down all sessions). 'p' will be nil. Return 0 to                 *  indicate no error.                 }            END;            ATTransClosePrep:            BEGIN                {                 *  This event gives us the chance to deny the closing of AppleTalk IF we                 *  want. Returning a value of 0 means it's OK to close; nonzero                 *  indicates we'd rather not close at this time.                 *                 *  With this event, the parameter 'p' actually means something. 'p' in                 *  this event is a pointer to an address that can hold a pointer to a                 *  string of our choosing. This string indicates to the user which task                 *  would rather not close. If you don't want AppleTalk to close, but you                 *  don't have a name to stick in there,  you MUST place a nil value in                 *  there instead.                 }                {                 *  Get a new reference to the address we were passed (in a form we can use).                 *  (We're doing this all locally to this case because we can, so                 *  there.)                 }                processNameHdl := StringHandle(NewHandle(sizeof(Str32)));                {                 *  Place the address of our string into the address we were passed.                 }                 := 'Banana Mail';                Ptr(p) := Ptr(processNameHdl);                {                 *  Return a nonzero value so that AppleTalk knows we'd rather not close.                 }                returnVal := 1;            END;            ATTransCancelClose:            BEGIN                {                 *  Just kidding, we didn't really want to cancel that AppleTalk closing                 *  after all. Reset all your network activities that you have disabled here                 *  (IF any). In our case, we'll just fall through. 'p' will be nil.                 }            END;            ATTransNetworkTransition:            BEGIN                {                 *  A Remote AppleTalk connection has been made or broken.                 *  'p' is a pointer to a TNetworkTransition record.                 *   Always return 0.                 }                myTNetworkTransitionPtr := TNetworkTransitionPtr(p);                {                 *  Check newConnectivity element to determine whether                 *  Remote Access is coming up or going down.                 }                if (myTNetworkTransitionPtr^.newConnectivity) THEN                BEGIN                    {                     * Have a new connection.                     }                END                ELSE                BEGIN                    {                     * Determine which network addresses need to be validated                     * and assign the value to checkThisNet.                     }                    checkThisNet = $1234FD80;  /* network $1234, node $FD, socket $80 */                    if (CallNetValidProc(myTNetworkTransitionPtr, checkThisNet,                        myTNetworkTransitionPtr^.netValidProc) &lt;&gt; 0) THEN                    BEGIN                        {                         * Network is still valid.                         }                    END                    ELSE                    BEGIN                        {                         * Network is no longer valid.                         }                    END;                END;            END;            ATTransNameChangeTellTask:            BEGIN                {                 *  Someone is changing the Flagship name and there is nothing we can do.                 *  The parameter 'p' is a pointer to a Pascal-style string that holds the new                 *  Flagship name.                }                newNamePtr := StringPtr (p);                {                 *  You should deregister any previously registered NBP entries under the                 *  'old' Flagship name. Always return 0.                 }            END;            ATTransNameChangeAskTask:            BEGIN                {                 *  Someone is messing with the Flagship name.                 *  With this event, the parameter 'p' actually means something. 'p' is                 *  a pointer to a NameChangeInfo record. The newObjStr field contains the                 *  new Flagship name. Try to register a new entity using the new Flagship                 *  name. Returning a value of 0 means it's OK to change the Flagship name.                 }                myNameChgPtr := NameChangePtr (p);                {                 *  If the NBPRegister is unsuccessful, return the error. You must also set                 *  p-&gt;name pointer with a pointer to a string of the process name.                 }            END;            ATTransCancelNameChange:            BEGIN                {                 *  Just kidding, we didn't really want to cancel that name change after                 *  all. Remove new NBP entry registered under the                 *  ATTransNameChangeAskTask Transition. 'p' will be nil.                 *  Remember to return 0.                 }            END;            OTHERWISE                returnVal := 0;                {                 *  Just in case some other numeric selector is implemented.                 }        END; { CASE }    END    ELSE IF (ResType(selector) = ATTransCableChange) THEN    BEGIN        {         *  The cable range for the network has changed. The pointer 'p' points         *  to a structure with the new network range.  (TNewCRTransPtr)p-&gt;newCableLo         *  is the lowest value of the new network range. (TNewCRTransPtr)p-&gt;newCableHi         *  is the highest value of the new network range. After handling this event,         *  always return 0.         }        myTNewCRTransPtr := TNewCRTransPtr(p);        myCableLo := myTNewCRTransPtr^.newCableLo;        myCableHi := myTNewCRTransPtr^.newCableHi;        returnVal := 0;    END    ELSE IF (ResType(selector) = ATTransSpeedChange) THEN    BEGIN        {         *  The processor speed has changed. Only LocalTalk responds to this event.         *  We demonstrate this event for completeness only.         *  Always return 0.         }         returnVal := 0;    END; { IF }    SampleTransQueue := returnVal;END;END. { of UNIT }</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>Multivendor ADEV Architecture</h3><P>With the release of AppleTalk version 56, Apple implemented the MultivendorADEV Architecture. Under the original architecture with versions of AppleTalkprior to 56, using EtherTalk or TokenTalk on Macintosh II class machinespermitted only one brand of NuBus card where multiple Ethernet or token ringconnections were desired. Furthermore, there was no support for a configurationof a NuBus slot device and a "slotless" device, such as a SCSI Ethernetconnection.</p><p>As Ethernet comes built in on next-generation CPUs, this clearly presents aproblem for customers wishing to mix Ethernet controller brands on the sameCPU. The Multivendor Architecture presents a common interface through whichbasic AppleTalk services are provided. The new architecture simplifies softwaredevelopment whereas AppleTalk engineering provides the ADEV file, and thedeveloper provides the hardware level driver software for Ethernet and tokenring. By following the new architecture, Ethernet and token ring hardware cardswill be compatible as new services are provided by AppleTalk (for example,AppleTalk Remote Access and MacTCP).</p> <P>AppleTalk version 56 and later is compatible with system software version 6.0.5 unless specifically stated otherwise in the release notes.</p> <P><A HREF="#top">Back to top</A></P>  <h3>Original Limitations</h3><P>The original product allowed only one type of NuBus Ethernet or token ringcontroller or one "slotless" controller. This Multivendor ADEV Architecturedeals only with the restriction of differing NuBus controllers. It does notaddress the mutual exclusion of slot and slotless devices, nor does it addressthe singularity of slotless devices.</p><p>NuBus slot Ethernet or token ring controller hardware is recognized by theoriginal product through a series of Slot Manager <code>SNextTypesRsrc </code> calls. Any NuBus device that is in the <i>network</i>  category and has atype classification of <i>Ethernet</i> <i>/token ring</i>  is considered aNuBus slot controller device. Whenever such a device is found in a NuBus slot,the user can select it as the current AppleTalk network connection, or it canbe used as a port in a Internet Router configuration.</p><p>When the AppleTalk network system uses this connection, an _Open, IMMED trapcall is made with an <i>ioNamePtr</i> -&gt; ".ENET/.TOKN", and the<i>ioSlot</i>  field set to the slot containing the card. Since only one driverresource can be installed in the system with this name, only one type ofEthernet or token ring card was supported under the original architecture.</p><P><A HREF="#top">Back to top</A></P>  <h3>.ENET Driver Shell</h3><P>System software version 7.0 and later (and Network Software Installers (NSI)system software version 1.1 and later) is packaged with the .ENET driver shellthat will support multiple NuBus Ethernet controllers. The sole function ofthis driver is to locate the appropriate driver resource for the particulardevice selected, and transfer control to the open routine for that driver. Itaccomplishes this in the following fashion:</P>* Obtains the <i>Board ID</i>  from the board sResource information for thegiven slot<p>* For the driver shell installed using NSI v1.2.4 and greater, the shellsearches for resources of type 'enet' with the ID equal to the <i>Board ID</i>in the System file and in the System ROM, and for a driver in the slotresources in the ROM of the slot device.  It uses the word (2 bytes)immediately following the DRVR name to determine which driver is the mostrecent; higher values are newer versions.  If no driver is found, an open erroris returned.</p><p>    For the driver shell installed prior to NSI v1.2.4, the shell uses<code>_GetResource </code>to obtain a resource of type 'enet' with the id equal tothe <i>Board ID</i>  from the system file.  If the resource is present,proceeds to use it as the driver code resource as defined below, otherwiseattempts to load the driver from the slot resources in the ROM of the slotdevice. If neither code resource is found, returns an open error.</p><ul type="disc">	<li>Detaches the newly loaded resource</li>	<li>Modifies the device control entry for the current <code>_Open call</code> with information from the loaded driver code (address to the driver)</li>	<li>Obtains the address of the open routine from the driver header information</li>	<li>JSRs to the open routine of the loaded driver</li>	<li>If the open is successful, returns, otherwise recovers the handle for the loaded driver and disposes of it</li></ul><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The <code>'enet'</code> resource must have it's locked resource bit set, as theDriver Shell will NOT perform this function.  This is also true for the <code>'tokn'</code>resource.</P></TD></TR></TABLE></CENTER><BR><p>This very simple technique allows developers to quickly repackage driverresources by simply changing the resource type and ID.</p><p>Built-in Ethernet on newer CPUs makes use of the board sResource list for slotzero, which should be present on all CPUs. These systems also have the Ethernetdevice sResource lists, and also have the .ENET driver in the sResources aswell.</p><p>The Easy Install process supplied on the Network Software Installer version 1.1and later, and on the system software installers for 7.0 and later, install thedriver shell when it recognizes that an Apple EtherTalk NB or Ethernet NB (orother Ethernet board with Board ID 8) is installed in the system.</p> <P><A HREF="#top">Back to top</A></P>  <h3>.TOKN Driver Shell</h3><P>The .TOKN driver shell is currently available from Apple Software Licensing(SW.LICENSE) for licensing. The driver and Multivendor TokenTalk ADEV are beingpackaged beginning with system software version 7.0.1 and AppleTalk productsthat require AppleTalk version 57 or later. The operation of the .TOKN drivershell is similar to the .ENET driver shell. In place of searching for andloading the 'enet' resource, a 'tokn' resource will be used instead. The newdriver will affect all developers whose .TOKN drivers get replaced by thedriver shell.  For those who are interested in programming to the .TOKN API,skip the section ".TOKN Application Programming Interface (API)".</p><P><A HREF="#top">Back to top</A></P>  <h3>.TOKN Driver Basics</h3><P>The following guidelines describe the minimum requirements for developers oftoken ring products for the Macintosh to be compatible with the TokenTalk Phase2 driver software. MacDTS strongly recommends that all developers of token ringproducts implement the basic functionality described below. By following theseguidelines, the product will be compatible with AppleTalk Remote Access,MacTCP, and future releases of AppleTalk and related products.  Forapplications developers, the API for the token ring driver is describedbelow.</p><p>The .TOKN driver interface is similar to the interface of the .ENET driver asdescribed in Appendix B, "Macintosh Ethernet Driver Details" in the<i>Macintosh AppleTalk Connections Programmer's Guide</i> (Final Draft 2,November 11, 1989) and more recently in <i>Inside Macintosh</i> Volume VI, page32-88. These documents describe the expected functionality of the .ENET driver.The .TOKN driver interface that you design can be a superset of thefunctionality discussed here. The following are some additional guidelines andexceptions to consider:</P><UL><li>The driver can obtain the slot number from the DCE entry<code>dCtlSlot</code><i>.[]</i></li><li>The driver need only support <code>EAttach</code> protocol type 0. Return anerror on other protocol types.</li><li>Implement the add and delete functional address in place of the<code>EAddMulti</code> and <code>EDelMulti </code>commands.</li><li>Implement the<code> ESetGeneral</code> call to return a result of noErr.</li><li>Implement source routing support if the driver is to support the sourcerouting bridges.</li></ul><p>On <code>EWrite</code> call:</P><P>The first buffer in the WDS contains a 802.3 MAC header (6-byte destinationaddress + 6-byte source address + 2-byte length field). The 6-byte destinationaddress is the only important field to the driver. The source address and thelength fields are not used for token ring media. The header is 14 bytes inlength.  </p><P>The second buffer in the WDS contains the LLC header and the SNAP header. This buffer is 8 bytes in length.  The remainder of the WDS is the user data.  Note that there may not be a second or third buffer in the WDS.  The complete frame may get passed in the first buffer of the WDS.</p><p>The packet which gets put out on the "wire" will not include the 2-byte lengthfield.  The packet header will have the 6-byte destination address, followed bythe 6-byte source address, followed by the LLC and SNAP header, and the userdata.  </P><P>On Receive:</P><P>Define a Read Header Area (RHA) into which to create the 14 byte 802.3 MACheader.  Read the header into the RHA and set A3 to point to the end of theRHA; place the 6-byte destination and source addresses into the first 12 byteof the RHA.  From the hardware, get the length of the packet and place it intothe last 2 bytes of the RHA.  This step is necessary as the LAP Manager isdesigned to handle and Ethernet style packet.</p><p>Calculate the packet length (LLC header + SNAP header + data). Place thelength in register D1.W. Also place the computed length into the length fieldof the 802.3 MAC header (this length does not include the source routing and802.5 fields). Place the address of the <code>ReadPacket</code> routine intoregister A4.  Disable the interrupt.  Call the protocol handler or use<code>DeferUserFn</code> as described below.  Enable the interrupt.</p><p>As A0 is reserved for use by the driver, it could be used to point to the nextbyte to be read by the driver, for the <code>ReadPacket</code> and <code>ReadRest</code> functions.</p><p>Other Notes:</P><ol type="1">	<li>If the protocol handler calls your ReadRest routine with a buffer too small to hold the entire remaining packet, set the Z-bit in the CCR before returning. Clearing the Z-bit indicates that the ReadRest routine handled the packet successfully.</li>	<li>In general, the 'tokn' driver should expect an Ethernet style frame to be passed down from the upper layers when processing a write function.  On receive, the 'tokn' driver needs to return an Ethernet style packet to the upper layer.</li>	<li>The System Heap and the Locked resource flags must be set for the <code>'tokn'</code> resource.  The driver shell does not automatically lock the resource once it is loaded.</li>	<li>There is no equivalent to the Ethernet 'eadr' resource used to define the hardware address to be registered by the token ring card on startup.</li></ol><P><A HREF="#top">Back to top</A></P>  <h3>Driver Considerations for Virtual Memory</h3><P>With the release of system software version 7.0 and the virtual memory option,it is critical for driver software to protect against the possibility of adouble page fault. Since driver software runs at interrupt time, a non-virtualmemory compatible packet processing routine could cause a page fault while theMacintosh is already processing a page fault. To protect against thispossibility, the <code>DeferUserFn</code> is provided to allow interruptservice routines to defer code, which might cause a page fault, until a safetime. The following guidelines will help make your driver code compatible withvirtual memory.</p><ul type="disc">	<li>In the Open routine, use Gestalt to test for the presence of virtual memory, and whether it's on. If so, set a flag in your <code>dctlstorage</code> that you can reference later.</li>	<li>If virtual memory is enabled, always use <code>DeferUserFn</code> to defer the delivery of your packet data to your clients. This is necessary to protect against page faults at interrupt time when your client reads data into her own (probably unlocked) memory. In addition, do not touch any memory that is not locked down (in the virtual memory sense, not the Memory Manager sense) while processing your interrupts.</li>	<li>Set the <code>VMImmuneBit</code> to keep the system from locking down memory (bit 0 at offset <code>dCtlFlag</code>s + 1).  If the <code>VMImmuneBit</code> isn't set, the system locks the user's parameter block. In contrast, the user's buffers remain unlocked unless locked by the application. As a result, it is necessary to assume that the buffers are unlocked, and to use <code>DeferUserFn</code> accordingly. Having the system lock the parameter block results in a noticeable performance hit. The solution to this problem is to set the <code>VMImmuneBit</code>, and to be careful to  "touch" the parameter block only when it is "safe" to do so. One time when it might be "unsafe" is in a completion routine. Therefore, use <code>DeferUserFn</code>.</li></ul><p>The <code>VMImmune</code> bit is not currently found in the MPW headers. Add thefollowing line somewhere at the beginning of your driver code:</P><P> <code>      VMImmuneBit     EQU    0</code></p><p>Somewhere in the beginning of your code, assuming that the driver is nowvirtual memory-aware, add the following line:</P><P> <code>      BSET  #VMImmuneBit,dCtlFlags+1(A1)    ; set the bit</code></p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Do not assume that DeferUserFn will always successfullyqueue your packet- handling routine. Check the return result. Under specificsituations, the Defer-Function Queue can become full. If the return result iscannotDeferErr exit the slot interrupt routine with a result of zero toindicate that the interrupt could not be serviced.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P>  <h3>Limiting DeferUserFn Calls</h3><P>Your interrupt service routine can reduce the number of calls to<code>DeferUserFn</code> depending on the Network Interface Controller (NIC) beingused. With the SONIC and other NICs, incoming packets are queued. An ISR forsuch a NIC can be designed to process not only the packet that generated theinterrupt, but also successive packets. As a result, the ISR can be designed toset a "deferred function" flag to indicate that the service routine has beenqueued, then process all packets that it finds in the card's queue. When theservice routine has completed, it can then reset the deferred function flag. Ifthe ISR is reentered, it can check whether the deferred function flag is set.If so, simply exit with a non zero result in register D0 to indicate that thepacket was processed.</p> <P>Using this algorithm, it is important to reset the NIC's interrupt serviceregister each time the ISR determines that a packet will be processed by apreviously deferred function. If the register is not cleared, the card willremain in a constant state of interrupt, and the deferred function will neverget a chance to execute.</p><P><A HREF="#top">Back to top</A></P>  <h3>Implementing DeferUserFn</h3><P>The question may arise as to where to implement the <code>DeferUserFn</code> Thefollowing approach is one possible suggestion for devices that are not able toempty the NIC's packet RAM all at once, and which implement a circular bufferor linked buffer list. Define an entry point where the ISR begins processingthe packet from the card. At this entry point, there may be some code to checkwhether a packet transmission is under way and to perform a cleanup. There mayalso be code here to check whether the buffer has become overrun and to resetthe NIC according to manufacturer's guidelines. The driver code would copy theheader into the RHA (Read Header Area), identify the protocol handler and setup register A4 with a pointer to the ReadPacket routine, then call the handler.Upon completion, the ISR might check whether additional packets have beenreceived, if applicable. A flowchart of the deferred function process is asfollows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>myDeferedFunction(){    If transmit complete        do final cleanup of packet transmission    If buffer overrun        Reset the NIC according to manufacturer's guidelines    while(received packets are waiting in adapter ram)    {        process packet        call protocol handler    }}</pre>	</TD></TR></TABLE></CENTER><P>On entry to the ISR, see whether virtual memory is active by checking the flagset by the open routine. Perform whatever processing is necessary, then pass<code>DeferUserFn</code>, the entry point described above, if virtual memory isactive. If virtual memory is inactive, branch to the entry point and processthe packet.</p><P><A HREF="#top">Back to top</A></P>  <h3>.TOKN Application Programming Interface (API)</h3><P>The Apple specification for the .TOKN interface specifies that the .TOKN driverprocess token ring packets to the upper protocol layers in the same manner asfor the .ENET specification.  An important difference from Ethernet is that thespecification calls for the handling of Logical Link Control (LLC) token ringframes only.  There is no default protocol handler specification, andapplications must implement a protocol handler and use the LAP Manager toattach the handler.  The .TOKN API for sending and receiving 802.2 (LLC)packets over token ring uses many of the same Control calls implemented forEthernet.  Use the same parameter block style of Control calls and the samecsCode values.  Set the <code>ioRefNum</code> field to the reference number of the .TOKNdriver acquired when opening the driver.  The programming sequence is quitesimilar except for the specifics listed here.  The general programmingalgorithm follows.</p><p>As described in <i>Inside Macintosh</i> Volume VI, Chapter 32, a suggestedprogramming sequence is presented here.</p><ol type="1">	<li>Use the Slot Manager to identify installed token ring cards.  In calling the <code>SGetTypeSRsrc</code> function, set the <code>spCategory</code> field to <code>catNetwork</code> (4), and the <code>spCType</code> field to <code>typeTokenRing</code> (2).</li>	<li>Use the OpenSlot function to open the driver, setting the <code>ioNamePtr</code> field to ".TOKN", instead of ".ENET".  If there are no NuBus token ring cards found, the application should also try opening the ".TOKN0" driver using the <code>OpenDriver</code> function call.</li>	<li>If a process requires the use of functional addresses (the token ring equivalent to Ethernet multicast addresses) use the <code>EAddMulti</code> function to register a functional address.</li>	<li>Instead of using the <code>EAttachPH</code> call to install a protocol handler, use the LAP Manager equivalent.  A discussion of the reasons for using the LAP Manager follows.  Note also that the .TOKN interface does not define a default protocol handler.  Calls to <code>ERead</code> will return a ControlErr (-17).</li>	<li>Use the <code>EWrite</code> function in the same manner as under Ethernet to send packets across the token ring network.  Similar to Ethernet, the complete data packet can be pointed to by the first and only entry in the Write Data Structure (WDS).  At a minimum, the first WDS entry must consist of 14 bytes, with the destination address in the first 6 bytes, and the packet length occupying the 13th and 14th bytes.  The .TOKN driver fills in the source address into bytes 7 - 12.</li>	<li>The <code>ERdCancel</code> function is not defined under the Apple .TOKN specification and should not be used.  A call to this function will return a ControlErr, -17.</li>	<li>The <code>ESetGeneral</code> function does not apply to token ring and should simply return <code>noErr</code>.</li>	<li>The <code>EDetachPH</code> is implemented under the Apple .TOKN specification but should not be used.  See the discussion which follows.</li>	<li>The <code>EGetInfo</code> function does not apply to token ring.  Instead network processes should get the Simple Network Management Protocol Programmer's guide available from APDA to learn how to obtain communications statistics relating to token ring.</li>	<li>Use the <code>EDelMulti</code> function to remove a registered functional address, when finished.</li></ol><P><A HREF="#top">Back to top</A></P>  <h3>Using L802Attach on Token Ring</h3><P>The Apple token ring driver specification specifies that the driver needsupport only the default protocol type 0, which equates to IEEE 802.2 Type 1, aconnectionless or datagram service.  Furthermore, the Apple .TOKN interfacedefines support for only the Sub-Network Access Protocol (SNAP), a protocolwhich includes only 802.2 packets with a destination Service Access Point of$AA.  Since the .TOKN driver interface allows the attachment of only a singleprotocol handler, the LAP Manager has been designed to install a genericprotocol handler and which maintains an index of registered protocol IDs andpointers to their associated protocol handler.  When the <code>L802Attach</code> call ismade, a network process specifies the driver reference number, the protocolspecification, and the pointer to the protocol handler.  It is assumed that thenetwork process will open the token ring driver.  The LAP Manager determineswhether the generic protocol handler has already been installed to that driver.If not, then an <code>EAttachPH</code> call is made, and the protocol specification andhandler are stored in a lookup table.  If the generic handler has beeninstalled, then the protocol specification and handler pointer are simplyentered into the lookup table.</p><p>The advantage of using the LAP Manager is best described by example.  Supposethat the user has specified that the default AppleTalk connection is throughsome installed Ethernet hardware.  Imagine that the user launches a MacTCPapplication which communicates across an installed token ring card on the sameworkstation.  MacTCP will install a protocol handler into the LAP Manager,which in turn installs it's generic handler into the token ring driver. The LAPManager must now process both token ring and Ethernet packets, sending theEthernet packets up to DDP and the token ring packet to MacTCP.  Imagine now,that the user decides to switch the AppleTalk connection on the fly to thetoken ring hardware.  The token ring ADEV will make the OpenSlot call to obtainthe reference number, make the <code>EAddMulti</code> call to register the AppleTalkmulticast address, then make the <code>L802Attach</code> call to the LAP Manager to installthe AppleTalk protocol handler.  The LAP Manager finds that the generic handlerhas already been installed and simply registers the AppleTalk protocol type.</p><p>If one imagines the case were the MacTCP driver to find that the .TOKN driverwasn't open, and made the <code>EAttachPH</code> call directly to the driver.  When theAppleTalk connection switch is attempted, the <code>EAttachPH</code> call would fail, sincethe driver will report that a protocol handler for type 0 already exists.  Forthis reason, it is strongly recommended that token ring applications do NOTmake the EAttachPH call to the .TOKN driver.</p><P><A HREF="#top">Back to top</A></P>  <h3> Writing the Protocol Handler for the LAP Manager</h3><P>Now that you're going to do the right thing and register the protocol handlerwith the LAP Manager, you need to know how to write the protocol handler.First, some overview.  When the .TOKN driver calls the LAP Manager, it willalready have read in the 14-byte frame header otherwise known as the 802.3header.  Since the frame length field will likely be some value of 1500 orless, the .TOKN driver will call the LAP Manager to process the packet.  TheLAP Manager  will read the 3-byte 802.2 header (which includes the source anddestination SAPs - $AA for both), and the 5 byte SNAP header.  The LAP Managerwill then scan it's lookup table searching for a matching protocolspecification.  If one is found, the associated protocol handler is called.</p><p>On entry to the protocol handler, the following register conventions apply.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Register     Description/Contents  A0           preserve until ReadRest called  A1           preserve until ReadRest called  A3           Pointer to next free byte in RHA                -5(A3) is the beginning of the SNAP address                -8(A3) is the beginning of the 802.2 address                -24(A3) is the beginning of the 6-byte destination address  A4           Pointer to ReadPacket and ReadRest routines.  A5           Free for use until ReadRest call made  D1           Number of bytes remaining to read in the packet  D2.          driver reference number  </pre>	</TD></TR></TABLE></CENTER>    <P>Thestandard protocol handler requirements specified in <i>Inside Macintosh</i>Volume II, pages 326/327 apply here.  The sample socket listener code describedabove could easily be modified for use as a .token ring protocol handler.</p><P><A HREF="#top">Back to top</A></P>  <h3>.FDDI Application Programming Interface (API)</h3><P>The Apple specification for the .FDDI interface specifies that the .FDDI driverprocess FDDI packets to the upper protocol layers in the same manner as for the.ENET specification.  An important difference from Ethernet is that thespecification calls for the handling of Logical Link Control (LLC) token ringframes only.  There is no default protocol handler specification, andapplications must implement a protocol handler and use the LAP Manager toattach the handler.  The .FDDI API for sending and receiving 802.2 (LLC)packets over token ring uses many of the same Control calls implemented forEthernet.  Use the same parameter block style of Control calls and the samecsCode values.  Set the <code>ioRefNum</code> field to the reference number of the .FDDIdriver acquired when opening the driver.  The programming sequence is quitesimilar except for the specifics listed here.  The general programmingalgorithm follows.</p><p>As described in <i>Inside Macintosh</i> Volume VI, Chapter 32, a suggestedprogramming sequence is presented here.</p><UL><LI>Use the Slot Manager to identify installed FDDI cards.  In calling the<code>SGetTypeSRsrc</code> function, set the <code>spCategory</code> field to <code>catNetwork</code> (4), and the<code>spCType</code> field to <code>typeFDDI</code> (0x11).</li><LI> Use the OpenSlot function to open the driver, setting the <code>ioNamePtr</code> field to".FDDI", instead of ".ENET".  If there are no NuBus token ring cards found, theapplication should also try opening the ".FDDI0" driver using the <code>OpenDriver</code>function call.</li><LI> If a process requires the use of multicast addresses, use the <code>EAddMulti</code>function to register a functional address.  The valid AppleTalk multicastaddresses under FDDI are the same as for Ethernet.</li><LI> Instead of using the <code>EAttachPH</code> call to install a protocol handler, use theLAP Manager equivalent.  The reasons for using the LAP Manager to install aprotocol handler are the same as for token ring, described above.  As withtoken ring, the .FDDI interface does not define a default protocol handler.Calls to <code>ERead</code> will return a <code>ControlErr</code> (-17).</li><LI> Use the <code>EWrite</code> function in the same manner as under Ethernet to send packetsacross the token ring network.  Similar to Ethernet, the complete data packetcan be pointed to by the first and only entry in the Write Data Structure(WDS).  At a minimum, the first WDS entry must consist of 14 bytes, with thedestination address in the first 6 bytes, and the packet length occupying the13th and 14th bytes.  The .FDDI driver fills in the source address into bytes 7- 12.</li><LI> The <code>ERdCancel</code> function is not defined under the Apple .FDDI specificationand should not be used.  A call to this function will return a <code>ControlErr</code>,-17.</li><LI> The <code>ESetGeneral</code> function does not apply to token ring and should simplyreturn <code>noErr</code>.</li><LI> The <code>EDetachPH</code> is implemented under the Apple .FDDI specification but shouldnot be used.  See the previous discussion  regarding token ring and the LAPManager.</li><LI> The <code>EGetInfo</code> function does not apply to FDDI.  Instead, obtain the SimpleNetwork Management Protocol Programmer's guide available from APDA to learn howto obtain communications statistics relating to token ring.</li><LI> Use the <code>EDelMulti</code> function to remove a registered functional address, whenfinished.</li></ul> <p>It is important to note that the Apple FDDI driver spec calls for the driver tohandle 802.2 packets to Service Access Points (SAP) other than to only SAP $AA.</p><P>In writing a protocol handler for the FDDI application, follow the guidelineslisted above for writing a protocol handler for the LAP Manager.</p><P><A HREF="#top">Back to top</A></P>  <h3>SONIC-Based Ethernet Driver Software Interface Change</h3><P>With the introduction of SONIC based Ethernet controllers, a modification wasimplemented into the Ethernet driver software to return additional informationavailable from the SONIC chip network statistics counters. This sectiondescribes the format of the information returned by an <code>EGetInfo</code> callwhen the current network connection is through an Ethernet NB Card, anEthernet LC Card, or through the built-in Ethernet available on the MacintoshQuadra and Centris systems.</p><P><A HREF="#top">Back to top</A></P>  <h3>EGetInfo Changes</h3><P>The <code>EGetInfo </code>call can return up to 60 additional bytes of newinformation making the maximum number of bytes returned 78. As with the AppleEtherTalk NB Card (Apple/3Com card), the first 6 bytes returned contain thecard's Ethernet address. The remaining bytes that are returned containinformation different from that returned with the Apple EtherTalk NB Card.</p><p>The next 12 bytes (offset 6-17) returned contain NO information but are alwaysreturned zero filled for compatibility. The remaining 60 bytes returned containSONIC chip network statistic counters. The counters are listed below in thefollowing table with the decimal and hexadecimal offsets given from the startof the return buffer. Note that the offset of the first item in the returnbuffer, the Ethernet address, is at offset 0.</p> <p align="center"><img src="images/nw_13_003.gif" width=400 height=213 alt=""></p><P>With the release of AppleTalk version 58, a minor change was implemented into the <code>EGetInfo</code> call such that the number of bytes filled in by the call, is returned in the <code>eDataSize</code> field.  The revised parameter block description for the .ENET driver supplied with AppleTalk v58 is:</p><p align="center"><img src="images/nw_13_004.gif" width=480 height=136 alt=""></p><P><A HREF="#top">Back to top</A></P>  <h3>Distinguishing Apple's SONIC-Based Ethernet Systems</h3><P>When making the <code>EGetInfo</code> call, it is important to pass the correctsize buffer. The control call will only fill in the buffer with the number ofbytes specified in the <code>eBuffSize</code> field. Unless it is already knownthat the active Ethernet card is the Apple (3Com) EtherTalk NB Card, it isrecommended that you pass a buffer large enough to accommodate the additionalinformation returned by the driver for the SONIC chip.  One method todistinguish the Apple (3Com) EtherTalk NB Card from Apple's SONIC-basedsystems, is to fill the 78-byte buffer with a byte pattern like 0xFF. For theApple EtherTalk NB Card, the last 60 bytes of the buffer will still be filledwith the byte pattern. For Apple's SONIC-based systems, the last 60 bytes ofthe buffer will NOT all contain the byte pattern.  </P><P>With the Ethernet driver released under AppleTalk version 58, an alternatemethod to distinguishing the two Apple Ethernet hardware cards is to pass in apointer to a 78-byte buffer in the <code>ePointer</code> field, then to check the <code>EDataSize</code>value for the number of bytes filled into the buffer. For the originalEtherTalk NB card, the number of returned bytes is 18; for the Ethernet NBcard, the number of returned bytes will be 78.</p><P><A HREF="#top">Back to top</A></P>  <h3>Correction to the ENET.h Header File</h3><P>Programs written for compilation with MPW C, which use the ENET.h header filesupplied with MPW v3.2.x and greater, are alerted to the fact the followingdeclaration is incorrect. Users of Think C should check their ENET.h headerfile for the same error, as the v5.0.x and 6.0 products was shipped with theheader files supplied by the MPW team. This problem does not affect thecorresponding Pascal interface file.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct {      EParamHeader      EParamMisc1 EParms1;      char eMultiAddr[5];                 /*Multicast Address*/}EParamMisc2;</pre>	</TD></TR></TABLE></CENTER><P>The correct declaration has <code>theMultiAddr</code> field immediately following the<code>EParamHeader</code> structure and the character array allocated 6 instead of 5 bytesas follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct {      EParamHeader      char eMultiAddr[6];                 /*Multicast Address*/}EParamMisc2;</pre>	</TD></TR></TABLE></CENTER><P>The <code>EParamMisc2</code> structure applies only to the <code>EAddMulti</code> and <code>EDelMulti</code> controlcalls to the Ethernet, Token Ring and FDDI drivers.  If you are using thesecalls, you might include a revised structure declaration in your source codefile so that you need not worry about overwriting the corrected header filewhen supplied with a new version of MPW.  The declaration would be asfollows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include &lt;ENET.h&gt;../* The following structure declaration replaces the incorrect EParamMisc2 * structure declaration presented in the ENET.h files supplied with MPW * to v3.2.4 and possibly greater. */typedef struct {      EParamHeader      char eMultiAddr[6];                 /*Multicast Address*/}EParamMultiCast;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>AppleTalk Multiple Node Architecture</h3><P>Supporting multiple node addresses on a single machine connected to AppleTalkis a feature that has been created to support software applications such asAppleTalk Remote Access. Its implementation is general enough to be used byother applications as well.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>AppleTalk version 57 or later is required to support the AppleTalkMultiple Node Architecture. Version 57 is compatible with system softwareversion 6.0.5 and greater. If you implement multinode functionality into yourprogram you should also plan to include AppleTalk version 57 with your product.Contact Apple's Software Licensing department (see end of this Note) forinformation on licensing AppleTalk.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P>  <h3>What Is It?</h3><P>Multiple Node AppleTalk provides network node addresses that are in addition tothe normal (user node) DDP address assigned when AppleTalk is opened. Theseadditional addresses have different characteristics from those of the user nodeaddress.  The new architecture provides a means for a multinode process toprocess AppleTalk packets in a custom manner.  For example, a multinode processwill receive all NBP Lookup requests.  It is up to the multinode process todecide how to respond to the Lookup requests, and to all other AppleTalkpackets which it receives.  There are no AppleTalk hooks for the multinodeprocess to pass packets back to the AppleTalk stack for processing.</p><p>Multinode processes are not connected to the protocol stack above the data linklayer. When a process acquires a multinode, the process has to supply a receiveroutine through which AppleTalk will deliver broadcasts and packets directed tothat multinode address.  The multinode process becomes responsible forprocessing all AppleTalk packets which it receives.  This includes EchoProtocol packets.</p><p>The number of multinode addresses that can be supported on one single machineis determined by a static limit imposed by the AppleTalk ADEV itself (forexample, EtherTalk). The limit is currently 253 nodes for Apple'simplementation of EtherTalk ($0, $FF, and $FE being invalid node addresses) and254 for LocalTalk ($0 and $FF being invalid node addresses). The number ofreceive routines that .MPP supports is determined by the static limit of 256.If all of the multiple nodes acquired need to have unique receive routines,then only a maximum of 256 nodes can be acquired, even if the ADEV providessupport for more than 256 nodes. .MPP will support the lesser of either themaximum of 256 receive routines, or the node limit imposed by the ADEV.</p><p>Outbound DDP packets can be created with a user-specified <b>source network,node, </b>and<b> socket</b> (normally equal to a multinode address) with thenew Network Write call. With this capability and the packet reception rulesdescribed above, a single machine can effectively become several nodes on anetwork. The <b>user</b> node continues to function as it always has.</p><P><A HREF="#top">Back to top</A></P>  <h3>Glue Code For Multinode Control Calls</h3><P>The following files are provided for C and Pascal programmers to implement thenew multinode calls presented in this Technote. First, for C programmers:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/*----------------------------------------------------------------------  file: MultiNode.c----------------------------------------------------------------------*/#include &lt;Types.h&gt;#include &lt;Devices.h&gt;#include &lt;OSUtils.h&gt;#include &lt;AppleTalk.h&gt;enum {/*  MultiNode .MPP csCodes */    netWrite = 261,                 /* Send packet through multinode */    addNode = 262,                  /* Request a multinode */    removeNode = 263               /* Remove multinode */};enum {  tryAddNodeAgainErr = -1021,       /* .MPP was not able to add node, try again*/  mnNotSupported =     -1022,       /* Multinode is not supported by thecurrent ADEV */  noMoreMultiNodes =   -1023        /* no node address is available on thenetwork */};typedef struct {    MPPATPHeader       char filler1;       unsigned char checkSumFlag;     /* perform checksum on datagram */       Ptr wdsPointer;                 /* Ptr to write-data structure */       char filler2[2];       union {           AddrBlock reqNodeAddr;      /* preferred address requested */           AddrBlock nodeAddr;         /* node address to be deleted */              } MNaddrs;       AddrBlock actNodeAddr;          /* actual node address acquired */       Ptr recvRoutine;                /* address of packet receive routine*/       short reqCableLo;               /* preferred network range for the */       short reqCableHi;               /*  node being acquired */       char reserved[70];} MNParamBlock;typedef MNParamBlock*MNParmBlkPtr;#ifdef __cplusplusextern &quot;C&quot; {#endifpascal OSErr MNAddNode(MNParmBlkPtr thePBptr);pascal OSErr MNRemoveNode(MNParmBlkPtr thePBptr,Boolean async);pascal OSErr MNNetWrite(MNParmBlkPtr thePBptr,Boolean async);#ifdef __cplusplus}#endif#pragma parameter __D0 PBControlImmedSync(__A0)pascal OSErr PBControlImmedSync(ParmBlkPtr paramBlock)       = 0xA204;pascal OSErr MNAddNode(MNParmBlkPtr thePBptr){       OSErr  err;       thePBptr-&gt;csCode = addNode;       thePBptr-&gt;ioRefNum = mppUnitNum;           /* AddNode must be made synchronously and as an Immediate Controlcall*/           /* Make Control call continuously if the Immed call returns the */           /*   tryAddNodeAgainErr  */       do {            err = PBControlImmedSync((ParmBlkPtr)thePBptr);       }       while (err == tryAddNodeAgainErr );       return (err);}pascal OSErr MNRemoveNode(MNParmBlkPtr thePBptr,Boolean async){       thePBptr-&gt;csCode = removeNode;       thePBptr-&gt;ioRefNum = mppUnitNum;       return (PBControl((ParmBlkPtr)thePBptr, async));}pascal OSErr MNNetWrite(MNParmBlkPtr thePBptr,Boolean async){       thePBptr-&gt;csCode = netWrite;       thePBptr-&gt;ioRefNum = mppUnitNum;       return (PBControl((ParmBlkPtr)thePBptr, async));}</pre>	</TD></TR></TABLE></CENTER><P>Now for Pascal Programmers:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>UNIT MultiNode;INTERFACEUSES    MemTypes, QuickDraw, OSIntf, AppleTalk;CONST{    MultiNode .MPP csCodes }    netWrite = 261;                 { Send packet through multinode }    addNode = 262;                  { Request a multinode }    removeNode = 263;               { Remove multinode }{    MultiNode errors  }    tryAddNodeAgainErr = -1021;     { .MPP was not able to add node, try again}    mnNotSupported =     -1022;     { Multinode is not supported by the currentADEV }    noMoreMultiNodes =   -1023;     { no node address is available on thenetwork }TYPEMNParmType = (AddNodeParm,RemoveNodeParm);MNParamBlock = PACKED RECORD    qLink: QElemPtr;                  {next queue entry}    qType: INTEGER;                   {queue type}    ioTrap: INTEGER;                  {routine trap}    ioCmdAddr: Ptr;                   {routine address}    ioCompletion: ProcPtr;            {completion routine}    ioResult: OSErr;                  {result code}    ioNamePtr: StringPtr;             {-&gt;filename}    ioVRefNum: INTEGER;               {volume reference or drive number}    ioRefNum: INTEGER;                {driver reference number}    csCode: INTEGER;                  {call command code AUTOMATICALLY set}       filler1: Byte;       checkSumFlag: Byte;            { perform checksum on datagram }       wdsPointer: Ptr;               { Ptr to write-data structure }       filler2: INTEGER;       CASE MNParmType of         AddNodeParm:          (reqNodeAddr: AddrBlock;    { preferred address requested }           actNodeAddr: AddrBlock;    { actual node address acquired }           recvRoutine: ProcPtr;      { address of packet receive routine }           reqCableLo: INTEGER;       { preferred network range for the }           reqCableHi: INTEGER;       {  node being acquired }           reserved: PACKED ARRAY [1..70] of Byte);         RemoveNodeParm:          (nodeAddr: AddrBlock);  { node address to be deleted }    END;MNParmBlkPtr = ^MNParamBlock;FUNCTION MNAddNode(thePBptr: MNParmBlkPtr): OSErr;FUNCTION MNRemoveNode(thePBptr: MNParmBlkPtr; async: BOOLEAN): OSErr;FUNCTION MNNetWrite(thePBptr: MNParmBlkPtr; async: BOOLEAN): OSErr;IMPLEMENTATIONFUNCTION PBControlImmedSync(paramBlock: ParmBlkPtr): OSErr;    INLINE $205F,$A204,$3E80;FUNCTION MNAddNode(thePBptr: MNParmBlkPtr): OSErr;VAR       err : OSErr;BEGIN       thePBptr^.csCode := addNode;       thePBptr^.ioRefNum := mppUnitNum;           { AddNode must be made synchronously and as an Immediate Controlcall }           { Make Control call continuously if the Immed call returns the }           {   tryAddNodeAgainErr  }       REPEAT           err := PBControlImmedSync(ParmBlkPtr(thePBptr));       UNTIL (err &lt;&gt; tryAddNodeAgainErr);       MNAddNode := err;END;FUNCTION MNRemoveNode(thePBptr: MNParmBlkPtr; async: BOOLEAN): OSErr;BEGIN       thePBptr^.csCode := removeNode;       thePBptr^.ioRefNum := mppUnitNum;       MNRemoveNode := PBControl(ParmBlkPtr(thePBptr), async);END;FUNCTION MNNetWrite(thePBptr: MNParmBlkPtr; async: BOOLEAN): OSErr;BEGIN       thePBptr^.csCode := netWrite;       thePBptr^.ioRefNum := mppUnitNum;       MNNetWrite := PBControl(ParmBlkPtr(thePBptr), async);END;END.</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>Things You Need to Know When Writing a Multinode Application</h3><P>Two new .MPP driver control calls have been added to allow multinodeapplications to add and remove multinodes.</p><P><A HREF="#top">Back to top</A></P>  <h3>AddNode (csCode=262)</h3><P>A user can request an extra node using a control call to the .MPP driver afterit has opened. Only one node is acquired through each call.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Parameter Block:      --&gt;    24    ioRefNum      short        ; driver ref. number      --&gt;    26    csCode        short        ; always = AddNode (262)      --&gt;    36    reqNodeAddr   AddrBlock    ; the preferred addressrequested                                              ; by the user.      &lt;--    40    actNodeAddr   AddrBlock    ; actual node addressacquired.      --&gt;    44    recvRoutine   long         ; address of the receiveroutine for MPP                                              ; to call during packetdelivery.      --&gt;    48    reqCableLo    short        ; the preferred range for the      --&gt;    50    reqCableHi    short        ; node being acquired.      --&gt;    52    reserved[70]  char         ; 70 reserved bytesAddrBlock:      aNet         short                      ; network #      aNode        unsigned char              ; node #      aSocket      unsigned char              ; should be zero for thiscall.</pre>	</TD></TR></TABLE></CENTER><P>The <code>AddNode</code> call must be made as an <code>IMMEDIATE</code> control call atsystem task time. The glue code above, implements this requirement.  The .MPPdriver will try to acquire the requested node address. The result code will bereturned in the <code>ioResult</code> field in the parameter block. The result code-1021 indicates that the .MPP driver was unable to continue with the<code>AddNode</code> call because of the current state of .MPP. The caller shouldretry the <code>AddNode</code> call (the retry can be issued immediately after the<code>AddNode</code> call failed with -1021) until a node address is successfullyattained or another error is returned.  The glue code above demonstrates onetechnique for implementing the immediate <code>AddNode</code> call.  Because theimmediate Control call is made repeatedly if error -1021 is returned, the callcannot be made asynchronously.</p><p>If the requested node address is zero, invalid, or already taken by anothermachine on the network, a random node address will be generated by the .MPPdriver. The parameters <code>reqCableLo</code> and <code>reqCableHi</code> willbe used only if there is no router on the network and all the node addresses inthe network number specified in <code>NetHint</code> (the last used network numberstored in parameter RAM) are taken up.</p><p>In this case, the .MPP driver tries to acquire a node address from the networkrange as specified by <code>reqCableLo</code> and <code>reqCableHi</code>. The networkrange is defined by the seed router on a network. If a specific cable range isnot important to the application, set the <code>reqCableLo</code> and<code>reqCableHi </code>fields to zero. The <code>recvRoutine</code><i> </i>is anaddress of a routine in the application to receive broadcasts and directedpackets for the corresponding multinode.</p><P>Possible Error Codes:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    noErr            0        ; success    tryAddNodeAgainErr     -1021        ; .MPP was not able to add node, try again.    MNNotSupported    -1022        ; Multinode is not supported by                ; the current ADEV.    noMoreMultiNodes    -1023        ; no node address is available on                          ; the network.</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>RemoveNode (csCode=263)</h3><P>This call removes a multinode address and must be made at system task time.Removal of the user node is not allowed.</p><code>Parameter Block:</code>    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>--&gt;    24    ioRefNum    word        ; driver ref. number    --&gt;    26    csCode        word        ; always = RemoveNode (263)    --&gt;    36    NodeAddr    AddrBlock    ; node address to be deleted.</pre>	</TD></TR></TABLE></CENTER><P>Possible Error Codes:</P>    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>noErr        0        ; success    paramErr    -50        ; bad parameter passed</pre>	</TD></TR></TABLE></CENTER>    <P><A HREF="#top">Back to top</A></P>  <h3>Receiving Packets</h3><P>Broadcast packets are delivered to both the user's node and the multinodes onevery machine. If several multinodes are acquired with the same<code>recvRoutine</code> address, the <code>recvRoutine</code> , listening for thesemultinodes, will be called only once in the case of a broadcast packet.</p><p>Multinode receive handlers should determine the number of bytes already readinto the Read Header Area (RHA) by subtracting the beginning address of the RHAfrom the value in A3 (see <i>Inside Macintosh</i>  Volume II, page 326, for adescription of the Read Header Area). A3 points past the last byte read in theRHA. The offset of RHA from the top of the .MPP variables is defined by theequate <code>ToRHA</code> in the MPW include file <code>ATalk</code>.<code>Equ.a.</code>The receive handler is expected to call <code>ReadRest </code>to read in therest of the packet. In the case of LocalTalk, ReadRest should be done as soonas possible to avoid loss of the packet. Register A4 contains the pointer tothe <code>ReadPacket </code>and <code>ReadRest </code>routines in the ADEV.</p><p>To read in the rest of the packet:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>              JSR    2(A4)On entry:              A3            pointer to a buffer to hold the bytes              D3            size of the buffer (word), which can be zero to throw away packetOn exit:              D0            modified              D1            modified              D2            preserved              D3            Equals zero if requested number of bytes was read; is                            less than zero if packet was -D3 bytes too large to fit                            in buffer and was truncated; is greater than zero if D3                            bytes were not read (packet is smaller than buffer)              A0            preserved              A1            preserved              A2            preserved              A3            pointer to 1 byte after the last byte read</pre>	</TD></TR></TABLE></CENTER>              <p>For more information about <code>ReadPacket </code>and <code>ReadRest</code>, refer tothe <i>Inside Macintosh  </i>Volume II, page 327.</p><p>A user can determine if a link is extended by using the<code>GetAppleTalkInfo</code> control call. The <code>Configuration </code>fieldreturned by this call is a 32-bit word that describes the AppleTalkconfiguration. Bit number 15 (0 is LSB) is on if the link in use is extended.Refer to <i>Inside Macintosh  </i>Volume VI, page 32-15.</p><P><A HREF="#top">Back to top</A></P>  <h3>Sending Datagrams Through Multinodes</h3><P>To send packets through multinodes, use the new .MPP control call,<code>NetWrite. NetWrite allows</code> the owner of the multinode to specify a<b>source network, node, </b>and<b> socket </b>from which to send a datagram.</p><P><A HREF="#top">Back to top</A></P>  <h3>NetWrite (csCode=261)</h3><P><code>Parameter Block:</code></p>    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>--&gt;    26    csCode        word        ; always NetWrite (261)    --&gt;    29    checkSumFlag    byte        ; checksum flag    --&gt;    30    wdsPointer    pointer    ; write data structure</pre>	</TD></TR></TABLE></CENTER>    <p>Possible Error Codes:</P>    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>noErr        0        ; success    ddpLenErr    -92        ; datagram length too big    noBridgeErr    -93        ; no router found    excessCollsns    -95        ; excessive collisions on write</pre>	</TD></TR></TABLE></CENTER>    <P>This call is very similar to the <code>WriteDDP</code> call. The key differencesare as follows:</P><ul type="disc">	<li>The source socket is not specified in the parameter block. Instead it is specified along with the source network number and source node address in the DDP header pointed to by the write-data structure (WDS). Furthermore, the socket need not be opened. Refer to <i>Inside Macintosh  </i>Volume II, page 310, for a description of the write-data structure. It is important to note that the caller needs to fill in the WDS with the source network, source node, and source socket values. .MPP does not set these values for the NetWrite call.</li>	<li>The <code>checkSumFlag</code> field has a slightly different meaning. If true (non zero), then the checksum for the datagram will be calculated prior to transmission and placed into the DDP header of the packet. If false (zero), then the <b>checksum field is left alone</b> in the DDP header portion of the packet. Thus if a checksum is already present, it is passed along unmodified. For example, the AppleTalk Remote Access program sets this field to zero, since remote packets that it passes to the .MPP driver already have valid checksum fields. Finally, if the application desires no checksum, the checksum field in the DDP header in the WDS header must be set to zero.</li></ul><p>Datagrams sent with this call are <i>always sent using a long DDP header</i>.Refer to <i>Inside AppleTalk</i>, second edition, page 4-16, for a descriptionof the DDP header. Even if the destination node is on the same LocalTalknetwork, a long DDP datagram is used so that the source information can bespecified. The LAP header source node field will always be equal to the usernode address (<code>sysLapAddr</code>), regardless of the source node address in the DDPheader.</p><P><A HREF="#top">Back to top</A></P>  <h3>AppleTalk Remote Access Network Number Remapping</h3><P>Network applications should be careful not to pass network numbers as data in anetwork transaction. AppleTalk Remote Access performs limited network numberremapping. If network numbers are passed as data, they will not get remapped.AppleTalk Remote Access recognizes network numbers in the DDP header and amongthe various standard protocol packets, NBP, ZIP, RTMP, and so on.</p><P><A HREF="#top">Back to top</A></P>  <h3>Is There a Router on the Network?</h3><P>Do not assume that there are no routers on the network if your network numberis zero. With AppleTalk Remote Access, you can be on network zero and beconnected to a remote network. Network applications should use the<code>GetZoneList</code> or the <code>GetBridgeAddress</code> calls to determine ifthere is a router on the network.</p><P><A HREF="#top">Back to top</A></P>  <h3>New for AppleTalk ADEVs </h3><P>First, a word from our sponsors: The information in this section is provided toassist ADEV developers in updating their products for compatibility withAppleTalk Remote Access. If you are a Ethernet or token ring developer, MacDTSstrongly urges that you consider following the Multivendor ADEV Architecturedescribed earlier. For developers of Fiber Data Distribution Interface (FDDI)network interface cards, please contact Apple Software Licensing forinformation on licensing  the new FDDI Phase 2 ADEV and Driver shell.</p> <P>Several new calls have been implemented into the .MPP driver for AppleTalkversion 57. Two calls, <code>AOpen </code>and <code>AClose</code>, were built intoAppleTalk version 54 and later, and are also documented here. These callsnotified the ADEV of changes in the status of the .MPP driver. For AppleTalkversion 57, three new calls, <code>AAddNode,</code> <code>ADelNode</code>, and<code>AGetNodeRef</code>, plus a change to the <code>AGetInfo </code>call, wereimplemented to support the Multiple Node Architecture.</p><p>With the release of AppleTalk version 58, support is provided for the SimpleNetwork Management Protocol (SNMP), and for the new Router Manager product.Programmer's Guides for each of these products are available from APDA. For allADEV's, an important change is required for the Router Manager product toprovide basic SNMP support. An ADEV must be modified to support a minor changein the AGetInfo call. The ADEV must respond to the <code>AGetInfo</code> call by returningthe slot number of the network device being supported, in the second reservedbyte. This change is required so that when queried by a console, the RouterManager can report the slot number of the connection being supported. For thosenetwork devices running via the LocalTalk ports, the second reserved byteshould continue to return zero. There is no support for such ADEV's at thistime.</p><p>EtherTalk Phase 2, version 2.3, and TokenTalk phase 2, version 2.4, driverssupport the new Multiple Node Architecture. Both drivers and AppleTalk version57 are available through the Network Software Installer, version 1.1. Asmentioned previously, AppleTalk version 57 and these drivers are compatiblewith system software version 6.0.5 and later. Note that the AppleTalk RemoteAccess product includes the EtherTalk Phase 2, version 2.3 driver, but<i>not</i> the multinode-compatible TokenTalk Phase 2, version 2.4, driver.Token ring developers, who license TokenTalk Phase 2, version 2.2 and earlier,should contact Apple's Software Licensing department.</p><p>The following information describes changes to the ADEV that are required formultinode compatibility. This information is of specific importance todevelopers of custom ADEVs. The ADEV can be expected to function under version6.0.5 and later. A version 3 ADEV <b>must</b> be used with AppleTalk version 57or later. Developers of custom ADEVs will want to contact Software Licensing tolicense AppleTalk version 57.</p><p>For compatibility with Multinode AppleTalk, the <code>'atlk'</code> resource of an ADEV mustbe modified to respond to these calls as described below. To determine whetheran ADEV is multinode compatible, the .MPP driver makes an AGetInfo call todetermine whether the ADEV version is 3 or later. Any ADEVs responding with aversion of 3 or later must be prepared to respond to the new calls:<code>AAddNode</code>, <code>ADelNode</code>, and <code>AGetNodeRef</code>. See the<i>Macintosh AppleTalk Connections Programmer's Guide</i> for more informationabout writing an AppleTalk ADEV.</p><p>The desired architecture for a multinode-compatible ADEV is such that itdelivers incoming packets to the LAP Manager along with an address referencenumber, AddrRefNum. The LAP Manager uses the  AddrRefNum to locate the correctreceive routine to process the packet. For broadcast packets, the LAP Managerhandles multiple deliveries of the packet to each multinode receive routine.</p><p>The .MPP driver for AppleTalk version 57 supports the new control call to addand remove multinodes, along with the network write call that allows thespecification of the source address. .MPP includes a modification in its writefunction to check for one multinode sending to another. .MPP supportsinter-multinode transmission within the same machine. For example, the usernode may want to send a packet to a multinode within the same system.</p><P><A HREF="#top">Back to top</A></P>  <h3>AGetInfo (D0=3)</h3><P>The <code>AGetInfo</code> call should be modified to return the maximum number of<b>AppleTalk </b>nodes that can be provided by the atlk. This limit will beused by .MPP to control the number of multinodes that can be added on a singlemachine. The new interface is as follows:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Call:        D1 (word)    length (in bytes) of reply buffer        A1 -&gt;         Pointer to GetInfo record bufferReturn:    A1 -&gt;        Pointer to GetInfo record        D0        non zero if error (buffer is too small)    AGetInfoRec = RECORD&lt;--    version:        INTEGER;    { version of ADEV, set to three (3) }&lt;--    length:        INTEGER;    { length of this record in bytes }&lt;--    speed:            LongInt;    { speed of link in bits/sec }&lt;--    BandWidth:        Byte;        { link speed weight factor }&lt;--    reserved:        Byte;        { set to zero }&lt;--    slot:                   Byte;        { device slot number or zero for LocalTalkports }&lt;--    reserved:        Byte;        { set to zero }&lt;--    flags:            Byte;        { see below }&lt;--    linkAddrSize:        Byte;        { of link addr in bytes }&lt;--    linkAddress:        ARRAY[0..5] OF Byte;&lt;--    maxnodes:         INTEGER;    END;    flags:    bit 7 = 1 if this is an extended AppleTalk, else 0        bit 6 = 1 if the link is used for a router-only connection (reserved            for half-routing)        bit 5 through 0 reserved, = 0</pre>	</TD></TR></TABLE></CENTER>        <P><code>maxnodes</code> is the total number of nodes (user node and multinodes) the ADEVsupports. If a version 3 ADEV does not support multinodes, it must return 0 or1 in the <code>maxnodes</code><b><i> </i></b>field in <code>AGetInfoRec</code> and theADEV will not be called to acquire multinodes. The version 3 ADEV will becalled by .MPP in one of the following two ways to acquire the user node:</P><ul type="disc">	<li>If the ADEV returns a value of 0 in <code>maxnodes</code>, .MPP will issue Lap Write calls to the ADEV with D0 set to $FF indicating that ENQs should be sent to acquire the user node. .MPP is responsible for retries of ENQs to make sure no other nodes on the network already have this address. This was the method .MPP used to acquire the user node before multinodes were introduced. This method of sending ENQs must be available, even though the new <code>AAddNode</code> call is provided, to allow older versions of AppleTalk to function properly with a version 3 ADEV.</li>	<li>If the ADEV returns a value of 1 in <code>maxnodes</code>, the new <code>AAddNode</code> function will be called by .MPP to acquire the user node.</li></ul><p>For values of <code>maxnode</code> greater than 1, the new <code>AAddNode</code> function willbe called by .MPP to acquire the additional multinodes.</p><P><A HREF="#top">Back to top</A></P>  <h3>AAddNode (D0=9)</h3><P>This is a <b>new</b> call which is used to request the acquisition of anAppleTalk node address. It is called by the .MPP driver during the execution ofthe <code>AddNode</code> control call mentioned earlier. The ADEV is responsible forretrying enough ENQs to make sure no other nodes on the network already havethe address. .MPP makes this call only during system task time.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Call:         A0-&gt;        Pointer to parameter blockReturn:     D0         = zero if address was acquired successfully                != zero if no more addresses can be acquired    atlkPBRec        Record    csParam--&gt;    NetAddr        DS.L    1    ; offset 0x1C  24-bit node address to acquire--&gt;    NumTrys        DS.W    1    ; offset 0x20  # of tries for address--&gt;    DRVRPtr        DS.L    1    ; offset 0x22  ptr to .MPP vars--&gt;    PortUsePtr        DS.L    1    ; offset 0x26  ptr to port use byte--&gt;    AddrRefNum        DS.W    1    ; offset 0x2A  address ref number used by .MPP                EndR</pre>	</TD></TR></TABLE></CENTER><P>The offset values describe the location of the fields from the beginning of theparameter block pointed to by A0. <code>atlkPBRec </code>is the standard parameterblock record header for a <code>_Control</code> call. The field <code>NetAddr</code><i> </i>isthe 24-bit AppleTalk node address that should be acquired. The node number isin the least significant byte 0 of <code>NetAddr</code>. The network number is inbytes 1 and 2 of <code>NetAddr</code><i> </i>; byte 3 is unused. <code>NumTrys</code>is the number of tries the atlk should send AARP probes on non-LocalTalknetworks to verify that the address is not in use by another entity. OnLocalTalk networks, <code>NumTrys</code> x 32 number of ENQs will be sent to verifyan address.</p> <P><code>DRVRPtr</code> and <code>PortUsePtr </code>are normally passed when the ATLK iscalled to perform a write function. For ADEVs that support multinodes,AppleTalk calls the new <code>AAddNode</code> function rather than the writefunction in the ADEV to send ENQs to acquire nodes. However, the values<code>DRVRPtr</code> and <code>PortUsePtr </code>are still required for the ADEV tofunction properly and are passed to the <code>AAddNode </code>call.<code>AddrRefNum</code><i> </i>is a reference number passed in by .MPP. The ADEVmust store each reference number with its corresponding multinode address. Theuse of the reference number is described in the following two sections.</p><p>For multinode-compatible ADEVs, .MPP issues the first <code>AAddNode </code>call toacquire the user node. The <code>AddrRefNum</code><i> </i>associated with the usernode must be 0xFFFF. It is important to assign 0xFFFF as the<code>AddrRefNum</code> of the user node, and to disregard the <code>AddrRefNum</code>passed by .MPP for the user node. See the discussion at the end of the<code>ADelNode </code>description.</p><P><A HREF="#top">Back to top</A></P>  <h3>ADelNode <i> </i>(D0=10)</h3><P>This is a <b>new</b> call which is used to remove an AppleTalk node address. Itcan be called by the .MPP driver to process the <code>RemoveNode</code> control callmentioned earlier.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Call:     A0-&gt;       Pointer to parameter block                     NetAddr contains the node address to be deletedReturn:   D0         = zero if address is removed successfully                     != zero if address does not exist                     atlkPBRec.AddrRefNum = AddrRefNum to be used by .MPP if the                     operation is successful       atlkPBRec     Record       csParam   --&gt; NetAddr       DS.L  1      ; offset 0x1C  24-bit node address to remove   &lt;-- AddrRefNum    DS.W  1      ; offset 0x2A  AddrRefNum passed in by AAddNode                                  ;    on return                     EndR</pre>	</TD></TR></TABLE></CENTER>                     <P>The field <code>NetAddr</code> is the 24-bit AppleTalk node address that should beremoved. As with the <code>AAddNode </code>selector, the node number is in theleast significant byte 0 of <code>NetAddr</code> . The network number is in bytes 1and 2 of <code>NetAddr</code> ; byte 3 is unused. The address reference number,<code>AddrRefNum</code>, associated with the <code>NetAddr</code> , must be returned to.MPP in order for .MPP to clean up its data structures for the removed nodeaddress.</p><p>As mentioned above, a value of 0xFFFF must be returned to .MPP after deletingthe user node. When the AppleTalk connection is started up for the first timeon an extended network, the ADEV can expect to process an <code>AAddNode</code> requestfollowed shortly by an <code>ADelNode </code>request. This results from theimplementation of the provisional node address for the purpose of talking withthe router to determine the valid network number range to which the node isconnected. After obtaining the network range, .MPP issues the <code>ADelNode</code>call to delete the provisional node. The next <code>ADelNode </code>call willbe to acquire the unique node ID for the user node. As mentioned previously,.MPP can pass a value different from 0xFFFF for the user node. The user node isacquired before any multinode. The ADEV needs to keep track of the number of<code>AAddNode</code> and <code>ADelNode</code> calls issued to determine whether theuser node is being acquired. Refer to <i>Inside AppleTalk</i>, second edition,page 4-8, for additional information.</p><P><A HREF="#top">Back to top</A></P>  <h3>AGetNodeRef (D0=11)</h3><P>This is a <b>new</b> call which is used by .MPP to find out if a multinodeaddress exists on the current ADEV. This call is currently used by .MPP tocheck if a write should be looped back to one of the other nodes on the machine(the packet does not actually need to be sent through the network) or should besent to the ADEV for transmission.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Call:     A0-&gt;       Pointer to parameter blockReturn:   D0         = zero if address does not exist on this machine                     != zero if address exists on this machine                     atlkPBRec.AddrRefNum = AddrRefNum (corresponding to                     the node address) if the operation is successful       atlkPBRec     Record        csParam   --&gt; NetAddr       DS.L  1       ; offset 0x1C  24-bit node address to remove   &lt;-- AddrRefNum    DS.W  1       ; offset 0x2A  AddrRefNum passed in by AAddNode                                   ;   on return                     EndR</pre>	</TD></TR></TABLE></CENTER><P>The field <code>NetAddr </code>is the 24-bit AppleTalk node address whose<code>AddrRefNum</code> is requested. The node number is in the least significant byte 0 of<code>NetAddr</code>.  The network number is in bytes 1 and 2 of <code>NetAddr </code>;byte 3 is unused. The address reference number, <code>AddrRefNum</code> , associated withthe <code>NetAddr </code>, must be returned to .MPP. Remember to return 0xFFFF asthe AddrRefNum for the user node.</p><P><A HREF="#top">Back to top</A></P>  <h3>AOpen (D0=7)</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Call:    --&gt;    D4.B        current port number</pre>	</TD></TR></TABLE></CENTER>    <P>ADEVs should expect the <code>AOpen</code> call whenever the .MPP driver is beingopened. This is a good time for the ADEV to register multicast addresses withthe link layer or register a Transition Queue handler. After this call iscompleted, .MPP is ready to receive packets. If the ADEV does not process thismessage, simply return, <code>RTN</code> with a <code>ControlErr</code>.</p><p>Note that <code>AOpen</code> is not specific to the Multinode Architecture.</p><P><A HREF="#top">Back to top</A></P>  <h3>AClose (D0=8)</h3><P><code>AClose</code> is called only when .MPP is being closed (for example, .MPP isclosed when the "inactive" option is selected in the Chooser or when the userswitches links in network cdev). The ADEV can use this event to deregister anymulticast addresses with the link layer or remove an existing Transition Queuehandler. After this <code>AClose</code> call is completed, the ADEV should notdefend for any node addresses until .MPP reopens and acquires new nodeaddresses. If the ADEV does not process this message, simply return, RTN with a<code>ControlErr</code>.</p><p>Note that <code>AClose</code> is not specific to the Multinode Architecture.</p><p>For comparison, descriptions of <code>AInstall</code> and <code>AShutDown</code> are documented as follows:</P><P><A HREF="#top">Back to top</A></P>  <h3>AInstall (D0=1)</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Call:    --&gt;    D1.L =    value from PRAM (slot, ID, unused, atlk resource ID)    &lt;--    D1.L =    high 3 bytes for parameter RAM returned by the ADEV, if no error    &lt;--    D0.W =    error code</pre>	</TD></TR></TABLE></CENTER>     <p>The <code>AInstall</code> call is made before .MPP is opened either during boottime or when the user switches links in network cdev. This call is made duringsystem task time so that the ADEV is allowed to allocate memory, make filesystem calls, or load resources and so on.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR><code>AOpen</code> call will bemade during .MPP opens.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P>  <h3>AShutDown (D0=2)</h3><P>ADEVs should expect the <code>AShutDown</code> call to be made when the userswitches links in the Network cdev. The network cdev closes .MPP, which causesthe <code>AClose</code> call to be made before the cdev issues the<code>AShutDown</code> call. </p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The <code>AShutDown</code> call is always madeduring system task time; therefore, deleting memory, unloading resources, andfile system calls can be done at this time.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P>  <h3>Receiving Packets</h3><P>The address reference number (<code>AddrRefNum</code>) associated with each nodeaddress must be passed to .MPP when delivering packets upward. When making theLAP Manager call <code>LReadDispatch</code> to deliver packets to AppleTalk, theADEV must fill the high word of <code>D2</code> in with the address referencenumber, corresponding to the packet's destination address (LAP node address inthe LocalTalk case and DDP address in the non-LocalTalk case). There are a fewspecial cases:</P><UL type = "disc"><LI>In the case of broadcasts and packets directed to the user node, $FFFF (word)should be used as the address reference number.</LI><LI>On non-LocalTalk networks, packets with DDP destination addresses matchingneither the user node address nor any of the multinode addresses should stillbe delivered to the LAP Manager so that the router can forward the packet on tothe appropriate network. In this case, the high word of <code>D2</code> should befilled in with the address reference number, $FFFE, to indicate to MPP thatthis packet is not for any of the nodes on the machine in the case of a routerrunning on a machine on an extended network.</LI><LI>On LocalTalk networks, the ADEV looks only at the LAP address; therefore, ifthe LAP address is not the user node, one of the multinodes, or a broadcast,the packet should be thrown away.</LI></ul><P><A HREF="#top">Back to top</A></P>  <h3>Defending Multinode Addresses</h3><P>Both LocalTalk (RTS and CTS) and non-LocalTalk (AARP) ADEVs have to be modifiedto defend not only for the user node address but also for any active multinodeaddresses.</p><P><A HREF="#top">Back to top</A></P>  <h3>Corrections/Clarifications to the LAP Manager</h3><P>The interface for the Link Access Protocol (LAP) Manager is presented in thedocument <i>Macintosh AppleTalk Connections Programmer's Guide</i>, availablefrom ADPA, p/n M7056/A.  This section provides additional descriptions to theLAP Manager functions described in the Programmer's Guide.</p><P><A HREF="#top">Back to top</A></P>  <h3>LRdDispatch (D0 = 1)</h3><P>The LRdDispatch routine is called by an ADEV's <code>'atlk'</code> packet handling routineto notify the LAP Manager that a packet has been received, and to pass thepacket to the LAP Manager for processing by the appropriate protocol handler.The documentation indicates that this routine "even though it is called with aJSR, does not return to the caller, but jumps to the protocol handler that isattached to the protocol indicated in (register) D2."</p><P>When called to handle LRdDispatch, the LAP Manager searches it's protocol tablefor a match to the protocol specified in D2. If found, the return addressplaced on the stack by the JSR instruction is removed.  For this reason, thecaller will not be returned to if a protocol handler is found.  This also meansthat the packet handling routine which calls <code>LRdDispatch</code>, must restore thestack to the state the stack was in, when the packet handler was entered.</p><P><A HREF="#top">Back to top</A></P>  <h3>LWrtInsert (D0 = 2)</h3><P>The LWrtInsert description indicates that setting bit 6 of the flag byte inregister D1, "does not disable the port B serial communications controller(SCC)...".  This bit no longer has any meaning under AppleTalk.</p><P><A HREF="#top">Back to top</A></P>  <h3>AppleTalk Version Information</h3><P>The following table is presented to assist AppleTalk developers inunderstanding which versions of AppleTalk are required by the various AppleTalkproducts. This list does not identify the individual bug fixes associated witheach release of AppleTalk.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>AppleTalk     .MPP Version  .ATP Version   Apple Products Using That VersionVersion19            19            19            Macintosh Plus ROM48            48            46            Macintosh SE ROM                                          Macintosh Classic ROM48.1          48            46            AppleShare File Server v1.049            49            49            Macintosh II ROM                                          Macintosh IIcx ROM                                          Macintosh SE/3050            50            49            AppleShare File Server v1.151            51            51            AppleShare Print Server v2.052            52            52            AppleShare File Server v2.0                                          Macintosh IIx ROM                                          Macintosh IIci ROM                                          Macintosh Portable ROM                                          PowerBook 100 ROM</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>Phase 1 drivers</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>AppleTalk     .MPP Version  .ATP Version   Apple Products Using That VersionVersion53            53            53            AppleTalk Phase 2 products                                          AppleTalk Internet Router v2.0                                          Apple EtherTalk NB Card 2.0                                          Apple TokenTalk NB Card 2.054            54            54            Macintosh IIfx                                          Macintosh LC, LC II, &amp; IIsi55            55            55            Apple Ethernet LC Card (for Macintosh LC)56            56            56            System 7.0, 7.0.1                                          Macintosh Classic II                                          PowerBook 100, 140, 170                                          Macintosh Quadra 700, 900, 95057.0.1        57.0.1        57.0.1        AppleTalk Remote Access                                          Apple Token ring 4/16 NB Card                                          Apple Ethernet NB Card57.0.3        57.0.3        57.0.3        Apple Ethernet LC Card (for Macintosh LC                                          II)57.0.4        57.0.4        57.0.4        MacTCP Token Ring Extension v1.0                                          System 7.1, MacTCP 1.1.1                                          Macintosh Duo 210, 230                                          Macintosh IIvi, IIvx                                          Macintosh Color Classic                                          Macintosh LC II                                          PowerBook 145, 145b, 160, 165c, 180, 180c                                          Macintosh Quadra 800                                          Macintosh Centris 610, 65058            58            58            Apple Internet Router v3.0                                          Mac SNMP58.0.2        58.0.2        58.0.2        AppleShare File Server 4.058.0.3        58.0.3        58.0.3        Macintosh Quadra 840AV, Centris 660AV58.1          58.1          58.1          PowerTalk58.1.1        58.1.1        58.1.1        Ethernet NB Twisted Pair</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>  <h3>Phase 2 drivers</h3><P>Some interesting notes:</P><ul type="disc">	<li>.MPP and .ATP driver versions weren't always the same in versions of AppleTalk before version 51. The .MPP driver version is the AppleTalk version number.</li>	<li>The Phase 1 RAM-based drivers (versions 49 through 52) were supplied as file that could be drag-installed (that is, the installation consisted of dropping them into the System Folder).</li>	<li>The Phase 2 RAM-based drivers (versions 53 through 58) must be installed by an Installer script that will install the various system pieces (files, resources, and so on) needed to load and support these new drivers; these versions cannot be drag-installed.</li>	<li>AppleTalk version 56 or greater includes the .DSP driver (ADSP). Starting with version 56, the .DSP driver version is the same as the AppleTalk version.</li></ul> <p>Apple software products that require the Phase 2 RAM-based drivers must beinstalled using the Installer program. Apple supplies an Installer script thatwill copy all files and system resources needed. Apple licenses the source toan Installer script that you can use if you license AppleTalk to ship with yourproducts.</p><P><A HREF="#top">Back to top</A></P>  <h3>Contacting Apple Software Licensing</h3><P>Software Licensing can be reached as follows:</P>    <P>Software Licensing<br>    Apple Computer, Inc.<br>    20525 Mariani Avenue, M/S 38-I<br>    Cupertino, CA  95014<br>    MCI:  312-5360<br>    AppleLink:  SW.LICENSE<br>    Internet: SW.LICENSE@AppleLink.Apple.com<br>    (408)974-4667</p>                         <a name="References"></a><h2>References</h2><P><i>Inside AppleTalk,</i> Second Edition, Addison-Wesley</P><P><i>Inside Macintosh</i>, Volume II, <i>The AppleTalk Manager</i>,Addison-Wesley</P><P><i>Inside Macintosh</i>, Volume V, <i>The AppleTalk Manager</i>,Addison-Wesley</P><P> <i>Inside Macintosh</i>, Volume VI, <i>The AppleTalk Manager</i>,Addison-Wesley</P><P><i>Macintosh AppleTalk Connections Programmer's Guide</i>, Final Draft 2,Apple Computer, Inc. (M7056/A)</P><P><i>AppleTalk Phase 2 Protocol Specification</i>, Apple Computer, Inc.(C0144LL/A)</P><P><i>AppleTalk Remote Access Developer's Toolkit, </i> Apple Computer, Inc.(R0128LL/A)</P><P>M.NW.AppleTalk2Mac</P><P>NuBus is a trademark of Texas Instruments.</P><P><A HREF="#top">Back to top</A></P>              <P><A NAME=Changes></A></P>                  <H2>Change History</H2>                                 <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-Feb-1994</P>               </TD>               <td align="left">                  <P>Provide list of original AppleTalk Managerroutines which will are NOT being ported to the PowerPC platform.  Correctedthe Multinode Protocol glue to reflect that the <code>AddNode</code> call must be made as asynchronous immediate Control call to the .MPP driver.  Included information onmaking the sample socket listener compatible with Virtual Memory.  Added notethat the <code>LAPAddATQ</code> and <code>LAPRmvATQ</code> routines have been corrected in theInterface.o library supplied with MPW v3.3.  Added information on using the.TOKN and .FDDI API.  Made corrections to socket listener code so that theChecksumming feature worked correctly.</P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-Jan-1993</P>               </TD>               <td align="left">                  <P>Corrected the .TOKN interface to removereference to the A1 register on packet reception. Describe a bug with the<code>LAPAddATQ</code> the <code>LAPRmvATQ</code> glue code which exists in the MPW Interface.o libraryfile, and publish an Assembler glue code file to work around the problem.Describe change to the .ENET <code>EGetInfo</code> call interface.  Describe change to the<code>'atlk' AGetInfo</code> call required of ADEV's to support SNMP (Simple NetworkManagement Protocol). Discuss other changes required for .TOKN and .ENETsupport of SNMP. Provide additional clarification to the LAP Manager calls,<code>LRdDispatch</code>, and <code>LWrtInsert</code>. Present correction to the ENET.h header filesupplied with MPW 3.2.x.</P>               </TD>            </TR>         </TABLE>         <BR>                                                      <P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (424K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/nw_13.pdf">Download</A></P>               </TD>            </TR>                     </TABLE>         <BR>         <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/nw/nw_13.html%3Fid%3DDTS10002555-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/nw/nw_13.html%3Fid%3DDTS10002555-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/nw/nw_13.html%3Fid%3DDTS10002555-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>