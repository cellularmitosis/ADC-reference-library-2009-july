<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>SCSI Architecture Model Device Interface Guide: Accessing SCSI Architecture Model Devices</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Accessing SCSI Architecture Model Devices"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000387" title="Accessing SCSI Architecture Model Devices"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/SCSI-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000567" target="_top">SCSI</a> &gt; <a href="../WWS_Intro/WWS_Intro.html#//apple_ref/doc/uid/TP30000743-BAJDAJDJ">SCSI Architecture Model Device Interface Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WWS_ParaSCSI/WWS_ParallelSCSI.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WWS_RevHistory/WWS_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000387-SW1" title="Accessing SCSI Architecture Model Devices"></a><h1><a name="//apple_ref/doc/uid/TP30000387-BCIIFCJB" title="Accessing SCSI Architecture Model Devices"></a>Accessing SCSI Architecture Model Devices</h1><p>For devices supported by SCSI Architecture Model family drivers, the SCSI Architecture Model family provides two types of device interface, one for exclusive access to the device and one for nonexclusive access to media-mastering devices only. This chapter focuses on how to use these device interfaces to communicate with devices supported by SCSI Architecture Model family drivers and includes sample code that illustrates how to gain access to a CD-R/W drive.</p><p>If you need to access a SCSI Parallel device <em>and</em> your application must run in versions of Mac OS X prior to v10.2, see <span class="content_text"><a href="../WWS_ParaSCSI/WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386-BAJDAJDJ">“Accessing SCSI Parallel Devices”</a></span> for information on how to use the API of both the SCSI Architecture Model family and the deprecated SCSI family to find your device. (Note that the APIs of the deprecated SCSI family will not work in an Intel-based Macintosh.)</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_7" title="Important:"></a><p><strong>Important:</strong>&nbsp;The sample code in this document is designed to work with Mac OS X v10.1 and later and will not work with earlier versions.</p><p></p></div><p>Although the sample code in this document has been compiled and tested, it is not intended to meet the needs of a commercial application. For example, error handling is minimal and simply facilitates debugging of this code—you should develop your own techniques for detecting and handling errors. In addition, you must employ your own method of disk arbitration. Therefore Apple does not recommend that you directly incorporate the entire sample program into a commercial application.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BBIDHAFI">SCSI Architecture Model Family Device Support</a>
				
			<br/>
			
        
			
			
				<a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-SW2">SCSI Device Access in an Intel-Based Macintosh</a>
				
			<br/>
			
        
			
			
				<a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIBGEFH">Using SCSI Architecture Model Family Device Interfaces</a>
				
			<br/>
			
        
			
			
				<a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIIEGJJ">Accessing a SCSI Architecture Model Device</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000387-BBIDHAFI" title="SCSI Architecture Model Family Device Support"></a><h2>SCSI Architecture Model Family Device Support</h2><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_12"></a>The SCSI Architecture Model family supports peripheral devices that comply with both the SCSI Primary Commands specification, or SPC, and one of the following bus transport protocols:</p><ul class="ul"><li class="li"><p>The ATA/ATAPI-5 specification (<span class="content_text"><a href="http://t13.org" target="_blank">http://t13.org</a></span>)</p></li><li class="li"><p>The FireWire SBP-2 specification (<span class="content_text"><a href="http://t10.org" target="_blank">http://t10.org</a></span>)</p></li><li class="li"><p>The USB Mass Storage Class specification (<span class="content_text"><a href="http://www.usb.org" target="_blank">http://www.usb.org</a></span>)</p></li><li class="li"><p>The SCSI Parallel specification (SPI-4)</p></li></ul><p>The SCSI Architecture Model family provides in-kernel logical unit drivers that translate generic I/O requests into device-specific commands for devices on these buses that declare one of the following four peripheral device types:</p><ul class="ul"><li class="li"><p>$00 for block storage devices that comply with the SCSI block commands specification</p></li><li class="li"><p>$05 for multimedia devices that comply with the SCSI multimedia commands specification</p></li><li class="li"><p>$07 for magneto-optical devices that comply with the SCSI block commands specification</p></li><li class="li"><p>$0E for reduced block command devices that comply with the SCSI reduced block commands specification</p></li></ul><p>For devices that declare other peripheral device types, such as scanners, tape drives, and medium changers, the SCSI Architecture Model family provides a device interface, called the SCSITaskDeviceInterface, that allows an application to be the logical unit driver for that device.</p><p>The SCSI Architecture Model family also provides access to authoring devices that are supported by in-kernel logical unit drivers. The device interface for multimedia commands, called the MMCDeviceInterface, allows an application to gain nonexclusive access to an authoring device. This allows the application to get information about the device prior to obtaining exclusive access to it with the SCSITaskDeviceInterface.</p><p>The SCSI Architecture Model family provides a third interface, called the SCSITaskInterface, that allows an application acting as a logical unit driver to manipulate the in-kernel SCSITask object. The SCSITask object contains the command being sent to the device, together with information such as task status and callback function pointers.</p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_3" title="Sending SCSI or ATA Commands to a Storage Device"></a><h3>Sending SCSI or ATA Commands to a Storage Device</h3><p>By design, Mac OS X does not allow applications to send SCSI or ATA commands to storage devices unless the application developer also provides an in-kernel device driver that supports the commands. The SCSI Architecture Model family allows only one logical unit driver to control a device at a time and provides in-kernel logical unit drivers for storage devices (as listed in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BBIDHAFI">“SCSI Architecture Model Family Device Support”</a></span>). Similarly, the ATA family does not allow applications to send ATA commands directly to ATA or SATA (Serial ATA) devices. This design preserves the integrity of the operating system and enhances the security of the user's data in two ways: </p><ul class="spaceabove"><li class="li"><p>An arbitrary application cannot directly change the state of a device without the explicit cooperation of a developer's custom in-kernel logical unit driver.</p></li><li class="li"><p>An application cannot bypass the file-system permissions set by the user by sending I/O commands directly to a storage device.</p></li></ul><p>Both the SCSI Architecture Model family and the ATA family provide device interfaces that allow applications various types of access to devices. The remaining sections in this chapter describe the device interfaces the SCSI Architecture Model family provides to allow an application to send commands to specific device types. The ATA family provides a device interface that allows applications to get SMART (self-monitoring, analysis, and reporting technology) data from ATA and SATA devices that implement the SMART feature set. For more information on this device interface, see the API reference documentation for <code>ATASMARTLib.h</code> in <em><a href="../../../../Darwin/Reference/IOKit/index.html#//apple_ref/doc/uid/TP30000815" target="_top">I/O Kit Framework Reference</a></em>.</p><p>If your application needs information available from a SCSI <code>INQUIRY</code> or ATA <code>IDENTIFY DEVICE</code> command, however, you do not need to send commands to the device or use a device interface. Much of the information provided by the <code>INQUIRY</code> and <code>IDENTIFY DEVICE</code> commands is available in the I/O Registry, which you can view with the I/O Registry Explorer application (in /<code>Developer/Applications)</code> or the command-line tool <code>ioreg</code>. </p><p>If your application needs to perform block-level I/O operations on a storage device, you can access the BSD raw disk device node in <code>/dev</code>. For more information on how to do this, see <em><a href="../../WorkingWStorage/index.html#//apple_ref/doc/uid/TP40000968" target="_top">Device File Access Guide for Storage Devices</a></em>. </p><p>If you decide that your application must send SCSI or ATA commands to devices not supported by the device interfaces provided by the SCSI Architecture Model and ATA families, you will need to write a custom in-kernel logical unit driver. If you do create your own in-kernel logical unit driver, be sure you don't send <code>READ</code> or <code>WRITE</code> commands from the driver. If you send these commands, you create a security hole malicious code can take advantage of by using your driver to read or destroy data on a device that a user has protected by setting access permissions. For more information on how to write a custom in-kernel logical unit driver, see <em><a href="../../MassStorage/index.html#//apple_ref/doc/uid/TP40000974" target="_top">Mass Storage Device Driver Programming Guide</a></em> and the code sample <em><a href="../../../../../samplecode/VendorSpecificType00/index.html#//apple_ref/doc/uid/DTS10000433" target="_top">VendorSpecificType00</a></em>. </p><a name="//apple_ref/doc/uid/TP30000387-BCIJJEGC" title="SCSI Architecture Model Devices on Mac OS X"></a><h3>SCSI Architecture Model Devices on Mac OS X</h3><p>When a device is discovered on Mac OS X, the I/O Kit finds and loads the drivers required to support it. In the case of a SCSI Architecture Model peripheral device that declares a peripheral device type of $00, $05, $07, or $0E, the I/O Kit loads several layers of drivers. Together, these layers are known as the mass storage driver stack (for more in-depth information about the mass storage driver stack, see <span class="content_text"><a href="../../MassStorage/01_Introduction/Introduction.html#//apple_ref/doc/uid/TP30000733" target="_top">Introduction to Mass Storage Device Driver Programming Guide</a></span>).</p><p>The mass storage driver stack is divided into three main layers.</p><ul class="spaceabove"><li class="li"><p>The physical interconnect layer includes physical interconnect drivers that support the physical connection of the device to the bus.</p></li><li class="li"><p>The transport driver layer includes the logical unit driver and protocol services driver that translate generic I/O requests into device-specific commands suitable for transport across a particular bus.</p></li><li class="li"><p>The device services layer includes the block storage driver which supports generic system requests and optional filter drivers that can implement encryption or validation schemes.</p></li></ul><p><span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIDIEJB">Figure 2-1</a></span> shows the mass storage driver stack supporting a mass storage device that declares a peripheral device type of $00, $05, $07, or $0E.</p><br/><div><a name="//apple_ref/doc/uid/TP30000387-BCIDIEJB" title="Figure 2-1The mass storage driver stack"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>The mass storage driver stack</p><img src = "../art/ahsamdrvstack.gif" alt = "The mass storage driver stack" width="248" height="435"></div><br/><p>The SCSI Architecture Model family supports the transport driver layer. It provides the logical unit driver that translates generic system requests into commands specific to the SCSI command set the device is compliant with and the protocol services driver that packages the commands from the logical unit driver into the format the bus expects.</p><p>The SCSI Architecture Model family enforces an exclusive-access policy for logical unit drivers. This means that there can be only one logical unit driver for each logical unit of a device. This applies to both in-kernel and application-based logical unit drivers.</p><p>When a device declaring a peripheral device type of $00, $05, $07, or $0E is discovered on one of the supported buses, the I/O Kit first finds and loads the appropriate physical interconnect drivers and protocol services driver. Then, an I/O Kit nub object, called the peripheral device nub, queries the device and publishes its peripheral device type in the I/O Registry. The I/O Kit then finds and loads the logical unit driver that matches the published peripheral device type.</p><p>Another I/O Kit nub object, called the device services linkage object, then publishes the logical unit driver’s type in the I/O Registry. If the device is authoring-capable, the SCSI Architecture Model family publishes the <code>SCSITaskDeviceCategory</code> key in this nub object. This key, with the value <code>SCSITaskAuthoringDevice</code>, indicates that the MMCDeviceInterface is available for the device. The SCSI Architecture Model family also adds a globally unique identification value (or GUID) to the nub that an application can use to identify the device.</p><p>Next, the I/O Kit finds and loads the block storage driver, and, if the device is a CD-ROM or DVD-ROM with media present, it loads a CD or DVD partition scheme. The device is then ready to process I/O requests from the host system.<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_13"></a></p><a name="//apple_ref/doc/uid/TP30000387-BCICJIDI" title="The SCSITaskDeviceInterface"></a><h3>The SCSITaskDeviceInterface</h3><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_14"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_15"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_16"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_17"></a>When a device that declares a peripheral device type other than $00, $05, $07, or $0E is discovered on a supported bus, the I/O Kit begins the matching and loading process described in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIJJEGC">“SCSI Architecture Model Devices on Mac OS X.”</a></span></p><p>As before, the peripheral device nub publishes the peripheral device type reported by the device. Because the peripheral device type is <em>not</em> $00, $05, $07, or $0E, the SCSI Architecture Model family adds the GUID and the <code>SCSITaskDeviceCategory</code> key with the value <code>SCSITaskUserClientDevice</code> to the peripheral device nub. This key-value pair indicates that an application can use the<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_18"></a> SCSITaskDeviceInterface to drive the device.</p><p>Because there are no in-kernel logical unit drivers that match on a peripheral device type other than $00, $05, $07, or $0E, the building of the driver stack halts after the peripheral device nub is published. <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIEIGFC">Figure 2-2</a></span> shows the mass storage driver stack when an application-based driver is the logical unit driver for a device that declares a peripheral device type of $01.</p><br/><div><a name="//apple_ref/doc/uid/TP30000387-BCIEIGFC" title="Figure 2-2An application-based logical unit driver"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>An application-based logical unit driver</p><img src = "../art/ahsamappstack.gif" alt = "An application-based logical unit driver" width="313" height="335"></div><br/><p>When an application-based driver for a device with no in-kernel logical unit driver starts, it searches the I/O Registry for the device or device type it can drive. When it finds the device, it acquires a SCSITaskDeviceInterface and the application becomes the logical unit driver for the device.</p><p>Because the application has exclusive access to the device, the device has no other clients and the device services layer of the mass storage driver stack is unnecessary.<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_19"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_20"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_21"></a></p><a name="//apple_ref/doc/uid/TP30000387-BCIFJFFC" title="The MMCDeviceInterface"></a><h3>The MMCDeviceInterface</h3><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_22"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_23"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_24"></a>When an authoring or media-mastering device, such as a CD-R/W or DVD-R/W, is discovered on a supported bus, the I/O Kit performs the matching and loading of drivers required to build the entire mass storage driver stack (as shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIDIEJB">Figure 2-1</a></span>). Because the SCSI Architecture Model family enforces an exclusive access policy, however, an authoring application must somehow replace the in-kernel logical unit driver to gain exclusive access to the device. <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCICIEGD">Figure 2-3</a></span> shows the mass storage driver stack when an authoring application is the logical unit driver for a CD-R/W device.</p><br/><div><a name="//apple_ref/doc/uid/TP30000387-BCICIEGD" title="Figure 2-3An authoring application"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>An authoring application</p><img src = "../art/ahsamauthorstack.gif" alt = "An authoring application" width="313" height="466"></div><br/><p>The authoring application replaces the logical unit driver, with the help of the SCSI Architecture Model family and the I/O Kit, in two phases:</p><ol class="ol"><li class="li"><p>The authoring application obtains an MMCDeviceInterface that provides nonexclusive access to the device while the in-kernel logical unit driver continues to drive it. The MMCDeviceInterface allows the application to safely query the device and determine if it can, in fact, support it.</p><p>The application can also use the MMCDeviceInterface to determine if media is present in the device and, if so, to get information about the media such as its type and size.</p></li><li class="li"><p>Based on information obtained from its query, the application reserves the media, obtains a SCSITaskDeviceInterface, and requests exclusive access to the device.</p></li></ol><p>When the request for exclusive access is granted, the in-kernel logical unit driver yields control to the authoring application. The block storage driver in the device services layer also relinquishes control and the Storage family tears down any partition schemes that were present. While the authoring application has exclusive access to the device, it can perform authoring functions.</p><p>When the authoring application terminates, the in-kernel logical unit driver and the block storage driver regain control of the device and the Storage family rebuilds the partition scheme, if needed.<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_25"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_26"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_27"></a></p><a name="//apple_ref/doc/uid/TP30000387-TPXREF101" title="The SCSITaskInterface"></a><h3>The SCSITaskInterface</h3><p>Logical unit drivers, whether in-kernel or application-based, use SCSITask objects to communicate with devices. The SCSITask object encapsulates all the information required during the life span of a single I/O transaction. This information includes the command descriptor block (or CDB) appropriate to the SCSI command set specification the device complies with, task retry status, and callback function pointers.</p><p>An application-based logical unit driver must have exclusive access to a device before it can create and use SCSITask objects. Because an application-based driver cannot manipulate the in-kernel SCSITask object directly, it must obtain a SCSITaskInterface<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_28"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_29"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_30"></a>. The SCSITaskInterface provides access to the in-kernel SCSITask object—each SCSITaskInterface object corresponds to exactly one SCSITask object.<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_31"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_32"></a></p><a name="//apple_ref/doc/uid/TP30000387-SW2" title="SCSI Device Access in an Intel-Based Macintosh"></a><h2>SCSI Device Access in an Intel-Based Macintosh</h2><p>This section provides an overview of some of the issues related to developing a universal binary version of an application that accesses a SCSI Architecture Model (or SCSI Parallel) device. Before you read this section, be sure to read <em><a href="../../../../MacOSX/Conceptual/universal_binary/index.html#//apple_ref/doc/uid/TP40002217" target="_top">Universal Binary Programming Guidelines, Second Edition</a></em>. That document covers architectural differences and byte-ordering formats and provides comprehensive guidelines for code modification and building universal binaries. The guidelines in that document apply to all types of applications, including those that access hardware.</p><p>Before you build your application as a universal binary, make sure that:</p><ul class="ul"><li class="li"><p>You port your project to GCC 4 (Xcode uses GCC 4 to target Intel-based Macintosh computers)</p></li><li class="li"><p>You install the Mac OS X v10.4 universal SDK</p></li><li class="li"><p>You develop your project in Xcode 2.1 or later</p></li></ul><p>Devices that comply with the SCSI architecture and command-set standards return data in the big-endian format, regardless of the native endian format of the computer your application is running in. Because a PowerPC-based Macintosh is also big-endian, you should examine your PowerPC application for places where you might assume that multibyte data never needs to be swapped. </p><p>You should also search for hard-coded byte swaps in your application (such as code that always swaps a multibyte value from one endian format to another). If your code contains such swaps (or it assumes byte swaps will never be necessary), it will not run correctly in an Intel-based Macintosh. Replace all hard-coded swaps with the appropriate conditional byte-swapping macros defined in the Kernel framework in <code>libkern/OSByteOrder.h</code>. These macros are available for use in any project, including high-level applications. For example, the Authoring Unit Test sample project (in <code>/Developer/Examples/IOKit/scsi/SCSITaskLib/Authoring/Cocoa</code>) uses the <code><!--a-->OSReadBigInt16<!--/a--></code> function to ensure the data returned from the disc is in host-endian byte order, as shown in <span class="content_text">Listing 2-1</span>:</p><a name="//apple_ref/doc/uid/TP30000387-SW3" title="Listing 2-1Ensuring correct endian format of data read from a disc"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Ensuring correct endian format of data read from a disc</p><div class="codesample"><table><tr><td scope="row"><pre>// Here, "interface" is an instance of an MMCDeviceInterface.<span></span></pre></td></tr><tr><td scope="row"><pre>- (void) testReadDiscInfo {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8            discInfoBuffer[4096];<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn         err;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSITaskStatus   taskStatus;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSI_Sense_Data  senseData;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16           discInfoSize;<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    // Issue a READ_DISC_INFORMATION command to the device. Ask for<span></span></pre></td></tr><tr><td scope="row"><pre>    // 4 bytes to get the length field.<span></span></pre></td></tr><tr><td scope="row"><pre>    err = (*interface)->ReadDiscInformation (interface, discInfoBuffer, 4, &amp;taskStatus, &amp;senseData);<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...If the command completed successfully:<span></span></pre></td></tr><tr><td scope="row"><pre>    // The first word contains the size. Add 2 bytes for the first word since it isn't counted<span></span></pre></td></tr><tr><td scope="row"><pre>    discInfoSize = OSReadBigInt16 ( discInfoBuffer, 0 ) + sizeof ( UInt16 );<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Fortunately, the SCSI command model specification defines the CDB (command descriptor block) as a byte array. This means that these bytes are stored in the defined order regardless of the native endian format of the computer your application is running in. As you create CDB commands using a SCSITaskInterface object, you do not have to worry about the endian format of the values you use.</p><p>You may need to perform byte swapping on values your application reads from a SCSI Parallel or SCSI Architecture Model device. Whether you have to perform byte swapping on the values you send and receive in parameters to device interface functions depends on the type of the value:</p><ul class="ul"><li class="li"><p>A buffer containing multibyte fields that gets passed in a parameter must be in the big-endian format. For example, if you use the MMCDeviceInterface function <code><!--a target="_top" -->SetWriteParametersModePage<!--/a--></code> to issue a <code>MODE_SELECT</code> command, the buffer pointed to by the <code>buffer</code> parameter must be in the big-endian format.</p></li><li class="li"><p>Other parameter values do not need to be byte-swapped. You should pass these parameter values in the computer's host format and the values you receive in the device interface functions will be in the computer's host format.</p></li></ul><a name="//apple_ref/doc/uid/TP30000387-BCIBGEFH" title="Using SCSI Architecture Model Family Device Interfaces"></a><h2>Using SCSI Architecture Model Family Device Interfaces</h2><p>The device interfaces the SCSI Architecture Model family provides are plug-ins that specify functions your application can call to communicate with a device. These interfaces are defined in <code>/System/Library/Frameworks/IOKit.framework/Headers/scsi/SCSITaskLib.h</code></p><p>Before you can use these interfaces, however, you must find the device you’re interested in. Device matching is the process of using I/O Kit functions to search the I/O Registry for particular devices or device types. This process varies depending on whether you are developing an authoring application or an application-based driver for a device that has no in-kernel logical unit driver. The next two sections describe how to perform device matching for both cases. Then, <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIDCIAB">“Accessing the Device”</a></span> outlines the remaining steps in the process of getting and using SCSI Architecture Model family device interfaces.</p><a name="//apple_ref/doc/uid/TP30000387-BCIHBFGG" title="Device Matching for Authoring-Capable Devices"></a><h3>Device Matching for Authoring-Capable Devices</h3><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_33"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_34"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_35"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_36"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_37"></a>If you’re developing an authoring application, you first create a matching dictionary that matches on authoring-capable SCSI Architecture Model devices. To create the dictionary, you use Core Foundation functions as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef          matchingDictionary;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>matchingDictionary = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL, NULL );<span></span></pre></td></tr></table></div><p>Now you need to place a key-value pair in the matching dictionary. The key is the <code>IOPropertyMatch</code> key and the value is a subdictionary you create. The subdictionary contains the <code>SCSITaskDeviceCategory</code> key with the value <code>SCSITaskAuthoringDevice</code>. <span class="content_text">Listing 2-2</span> shows how to create the subdictionary.</p><a name="//apple_ref/doc/uid/TP30000387-BCIHJFDJ" title="Listing 2-2Creating a subdictionary for the SCSITaskDeviceCategory"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Creating a subdictionary for the SCSITaskDeviceCategory</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef          subDictionary;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>subDictionary = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionarySetValue ( subDictionary, CFSTR ( kIOPropertySCSITaskDeviceCategory ), CFSTR ( kIOPropertySCSITaskAuthoringDevice ) );<span></span></pre></td></tr></table></div><p>If you do not need to perform a more specific search, you add the <code>IOPropertyMatch</code> key and this subdictionary to the matching dictionary you created earlier, as in this example:</p><p><code>CFDictionarySetValue ( matchingDictionary, CFSTR ( kIOPropertyMatchKey ), subDictionary );</code></p><p>You can refine this search by adding other properties to match on. For example, you can define a match on your device’s GUID. You add a key-value pair for the GUID to the subdictionary you created above, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>CFDictionarySetValue ( subDictionary, CFSTR ( kIOPropertySCSITaskUserClientInstanceGUID ), myGUID );<span></span></pre></td></tr></table></div><p>You can also create other subdictionaries that contain the physical interconnect protocol or device characteristics that describe your device. You then add these subdictionaries to the <code>SCSITaskDeviceCategory</code> subdictionary you created.</p><p>The Protocol Characteristics subdictionary can contain either or both of the following keys:</p><ul class="spaceabove"><li class="li"><p><code>Physical Interconnect</code></p></li><li class="li"><p><code>Physical Interconnect Location</code></p></li></ul><p>The Device Characteristics subdictionary can contain any of the following keys:</p><ul class="spaceabove"><li class="li"><p><code>Vendor Name</code></p></li><li class="li"><p><code>Product Name</code></p></li><li class="li"><p><code>Product Revision Level</code></p></li></ul><p>If, for example, you need to match on a particular vendor and product name, you can create a subdictionary that contains those key-value pairs and add it to the <code>SCSITaskDeviceCategory</code> subdictionary you created earlier. <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCICJJEE">Listing 2-3</a></span> shows how to do this.</p><a name="//apple_ref/doc/uid/TP30000387-BCICJJEE" title="Listing 2-3Creating a device characteristics subdictionary"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Creating a device characteristics subdictionary</p><div class="codesample"><table><tr><td scope="row"><pre>#define kMyVendorNameString     "MyVendorName"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kMyProductNameString    "MyProductName"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFMutableDictionaryRef          deviceCharacteristicsDict;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>deviceCharacteristicsDict = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionarySetValue ( deviceCharacteristicsDict, CFSTR ( kIOPropertyVendorNameKey ), CFSTR ( kMyVendorNameString ) );<span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionarySetValue ( deviceCharacteristicsDict, CFSTR ( kIOPropertyProductNameKey ), CFSTR ( kMyProductNameString ) );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionarySetValue ( subDictionary, CFSTR ( kIOPropertyDeviceCharacteristicsKey ), deviceCharacteristicsDict );<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000387-TPXREF102" title="Device Matching for Nonauthoring-Capable Devices"></a><h3>Device Matching for Nonauthoring-Capable Devices</h3><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_38"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_39"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_40"></a>For an application that drives a device with no in-kernel logical unit driver, you create a matching dictionary that contains the <code>IOPropertyMatch</code> key. The value of this key is a subdictionary you create that contains the <code>SCSITaskDeviceCategory</code> key and the value <code>SCSITaskUserClientDevice</code>. <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIGHEGB">Listing 2-4</a></span> shows how to do this.</p><a name="//apple_ref/doc/uid/TP30000387-BCIGHEGB" title="Listing 2-4Creating a matching dictionary for a nonauthoring device"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Creating a matching dictionary for a nonauthoring device</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef          matchingDictionary;<span></span></pre></td></tr><tr><td scope="row"><pre>CFMutableDictionaryRef          subDictionary;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>matchingDictionary = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>subDictionary = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionarySetValue ( subDictionary, CFSTR ( kIOPropertySCSITaskDeviceCategory ), CFSTR ( kIOPropertySCSITaskUserClientDevice ) );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionarySetValue ( matchingDictionary, CFSTR ( kIOPropertyMatchKey ), subDictionary );<span></span></pre></td></tr></table></div><p>You can refine this search by matching on your device’s GUID. Before you add the subdictionary to the matching dictionary, you place a key-value pair that represents the GUID in the subdictionary, as in this example:<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_41"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_42"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_43"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_44"></a></p><div class="codesample"><table><tr><td scope="row"><pre>CFDictionarySetValue ( subDictionary, CFSTR ( kIOPropertySCSITaskUserClientInstanceGUID ), myGUID );<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000387-BCIDCIAB" title="Accessing the Device"></a><h3>Accessing the Device</h3><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_45"></a>The steps you take to access a device are divided into two sets. The first set applies only to authoring applications. The second set applies to both application-based drivers of devices with no in-kernel logical unit drivers <em>and</em> authoring applications that have already completed the first set of steps. The sample code in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIIEGJJ">“Accessing a SCSI Architecture Model Device”</a></span> accesses a CD-R/W device and follows both sets of steps.</p><p>Use these steps <em>only</em> if you’re developing an authoring application. Once you have completed these steps, continue on to the second set of steps. If you’re developing an application that drives a device with no in-kernel driver, skip these steps and follow the second set of steps.</p><ol class="ol"><li class="li"><p>Get the device interface MMCDeviceInterface. This device interface provides functions that give you information about the media in the device, such as its size and whether or not it is blank.</p></li><li class="li"><p>Use the MMCDeviceInterface functions to query the device, if necessary.</p></li><li class="li"><p>If a disc is currently in the drive, reserve the media.</p></li></ol><p>Use these steps if you’re developing an application-based driver for a device with no in-kernel logical unit driver <em>or</em> you’re developing an authoring application and you’ve already followed the first set of steps.</p><ol class="ol"><li class="li"><p>Get the device interface SCSITaskDeviceInterface. This device interface provides functions to help you prepare to send SCSITask objects to the device. It also enforces the exclusive access policy and provides functions to add asynchronous callback mechanisms to your run loop.</p></li><li class="li"><p>Request exclusive access to the device. To do this, you use the SCSITaskDeviceInterface function <code>ObtainExclusiveAccess</code>.</p></li><li class="li"><p>Create a SCSITask object to communicate with the device. To do this you use the SCSITaskDeviceInterface function <code>CreateSCSITask</code>.<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_46"></a></p></li></ol><a name="//apple_ref/doc/uid/TP30000387-BCIIEGJJ" title="Accessing a SCSI Architecture Model Device"></a><h2>Accessing a SCSI Architecture Model Device</h2><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_47"></a>This section provides step-by-step instructions, including sample code, for accessing a CD-R/W drive. The sample code finds the device in the I/O Registry by setting up a matching dictionary like the one in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIHBFGG">“Device Matching for Authoring-Capable Devices”</a></span> and then follows the first set of steps in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIDCIAB">“Accessing the Device”</a></span> to acquire an MMCDeviceInterface. Then, it follows the second set of steps to get a SCSITaskDeviceInterface and request exclusive access.</p><p>When the sample code has exclusive access to the CD-R/W drive, it gets a SCSITaskInterface and sends SCSITask objects to test the device. The sample code also shows how to set up notifications for the dynamic addition and removal of a device.</p><a name="//apple_ref/doc/uid/TP30000387-TPXREF103" title="Setting Up Your Project"></a><h3>Setting Up Your Project</h3><p>The sample code in this chapter is from an Xcode project that builds a Core Foundation tool. If you need detailed documentation on using Xcode you can find it at <span class="content_text"><a href="../../../../DeveloperTools/Xcode-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000557" target="_top">Guides > Tools > Xcode</a></span>.</p><p>To set up Xcode to build the sample code, do the following:</p><ol class="ol"><li class="li"><p>Choose “Core Foundation Tool” when creating your project. This creates a skeletal <code>main.c</code> file and includes <code>CoreFoundation.h</code> in the project.</p></li><li class="li"><p>Use Add Frameworks... from the Projects menu to add <code>IOKit.framework</code> and <code>System.framework</code> to your project.</p></li><li class="li"><p>Replace the <code>main.c</code> file with <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIGIIFD">Listing 2-5</a></span> through <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIGFJAE">Listing 2-14</a></span>, inclusive.</p></li><li class="li"><p>Build your code in the Mach-O executable format (Xcode’s default format).</p></li><li class="li"><p>It’s recommended that you start by building with debugging turned on. To do this in Xcode, open the target list by clicking the disclosure triangle. Double-click the only target listed. In the inspector that appears, click the build tab, then click the checkbox next to 'Generate Debug Symbols'.</p></li></ol><p><span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIGIIFD">Listing 2-5</a></span> shows the header files you’ll need to include for the sample code in this chapter.</p><a name="//apple_ref/doc/uid/TP30000387-BCIGIIFD" title="Listing 2-5Header files"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>Header files</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;IOKit/IOKitLib.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/scsi-commands/SCSITaskLib.h><span></span></pre></td></tr></table></div><p>The sample code in this chapter uses the global variables in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIEDECA">Listing 2-6</a></span> to set up asynchronous notifications for device addition and removal.</p><a name="//apple_ref/doc/uid/TP30000387-BCIEDECA" title="Listing 2-6Global variables"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>Global variables</p><div class="codesample"><table><tr><td scope="row"><pre>static IONotificationPortRef    gNotifyPort;<span></span></pre></td></tr><tr><td scope="row"><pre>static io_iterator_t            gAppearedIter;<span></span></pre></td></tr><tr><td scope="row"><pre>static io_iterator_t            fDisappearedIter;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000387-TPXREF104" title="Creating a Main Function"></a><h3>Creating a Main Function</h3><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_48"></a>The sample code for working with a CD-R/W drive supported by a SCSI Architecture Model family driver begins with the <code>main</code> function, shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIJAFDJ">Listing 2-7</a></span>. This function accomplishes the following tasks.</p><ul class="spaceabove"><li class="li"><p>It sets up a signal handler (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIDCDAG">Listing 2-8</a></span>) to take care of the command line interrupt used to exit the run loop.</p></li><li class="li"><p>It establishes communication with the I/O Kit and sets up a matching dictionary to find authoring devices.</p></li><li class="li"><p>It sets up an asynchronous notification that is called when a device is first attached to the I/O Registry and another that is called when a device is removed.</p></li><li class="li"><p>It starts the run loop so the notifications will be received.</p></li></ul><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_49"></a>The <code>main</code> function uses<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_50"></a> I/O Kit functions to set up and modify a matching dictionary and set up notifications and Core Foundation functions to set up the run loop for receiving the notifications. It calls the following functions to get access to the device.</p><ul class="spaceabove"><li class="li"><p><code>DeviceAppeared</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIDIEEB">Listing 2-9</a></span>) iterates over the set of matching devices and calls <code>TestDevice</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCICHADC">Listing 2-11</a></span>) for each one.</p></li><li class="li"><p><code>DeviceDisappeared</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIIGFJF">Listing 2-10</a></span>) iterates over the set of matching devices and releases each one in turn.</p></li></ul><a name="//apple_ref/doc/uid/TP30000387-BCIJAFDJ" title="Listing 2-7Setting up a main function to access a CD-R/W device"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>Setting up a main function to access a CD-R/W device</p><div class="codesample"><table><tr><td scope="row"><pre>int main (int argc, const char *argv[])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_port_t         masterPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMutableDictionaryRef  matchingDict;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMutableDictionaryRef  subDict;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopSourceRef      runLoopSource;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t       kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    sig_t           oldHandler;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set up a signal handler so we can clean up when we're interrupted from the command line<span></span></pre></td></tr><tr><td scope="row"><pre>    // Otherwise we stay in our run loop forever.<span></span></pre></td></tr><tr><td scope="row"><pre>    oldHandler = signal(SIGINT, SignalHandler);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (oldHandler == SIG_ERR)<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Could not establish new signal handler");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // first create a master_port for my task<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOMasterPort(MACH_PORT_NULL, &amp;masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr || !masterPort)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("ERR: Couldn't create a master IOKit Port(%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>        return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the dictionaries<span></span></pre></td></tr><tr><td scope="row"><pre>    matchingDict = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>    subDict      = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a dictionary with the "SCSITaskDeviceCategory" key = "SCSITaskAuthoringDevice"<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionarySetValue (  subDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                            CFSTR ( kIOPropertySCSITaskDeviceCategory ),<span></span></pre></td></tr><tr><td scope="row"><pre>                            CFSTR ( kIOPropertySCSITaskAuthoringDevice ) );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add the dictionary to the main dictionary with the key "IOPropertyMatch" to<span></span></pre></td></tr><tr><td scope="row"><pre>    // narrow the search to the above dictionary.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionarySetValue (  matchingDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                            CFSTR ( kIOPropertyMatchKey ),<span></span></pre></td></tr><tr><td scope="row"><pre>                            subDict );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a notification port and add its run loop event source to our run loop<span></span></pre></td></tr><tr><td scope="row"><pre>    // This is how async notifications get set up.<span></span></pre></td></tr><tr><td scope="row"><pre>    gNotifyPort = IONotificationPortCreate(masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    runLoopSource = IONotificationPortGetRunLoopSource(gNotifyPort);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, kCFRunLoopDefaultMode);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Retain a reference since we arm both the appearance and disappearance notifications<span></span></pre></td></tr><tr><td scope="row"><pre>    // and the call to IOServiceAddMatchingNotification() consumes a reference each time.<span></span></pre></td></tr><tr><td scope="row"><pre>    matchingDict = ( CFMutableDictionaryRef ) CFRetain ( matchingDict );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Now set up two notifications, one to be called when a raw device is first matched by I/O Kit, and the other to be<span></span></pre></td></tr><tr><td scope="row"><pre>    // called when the device is terminated.<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOServiceAddMatchingNotification(  gNotifyPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            kIOFirstMatchNotification,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            matchingDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            DeviceAppeared,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            &amp;gAppearedIter );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    DeviceAppeared(NULL, gAppearedIter);    // Iterate once to get already-present devices and<span></span></pre></td></tr><tr><td scope="row"><pre>                                                // arm the notification<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOServiceAddMatchingNotification(  gNotifyPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            kIOTerminatedNotification,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            matchingDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            DeviceDisappeared,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            &amp;gDisappearedIter );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    DeviceDisappeared(NULL, gDisappearedIter);  // Iterate once to arm the notification<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Now done with the master_port<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_port_deallocate(mach_task_self(), masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    masterPort = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Start the run loop. Now we'll receive notifications.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopRun();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // We should never get here<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When you press Control-C to stop the run loop and exit the program, some objects may still be in use. The <code>SignalHandler</code> function, shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIDCDAG">Listing 2-8</a></span>, releases these objects and exits.<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_51"></a></p><a name="//apple_ref/doc/uid/TP30000387-BCIDCDAG" title="Listing 2-8Handling command-line interrupts"></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>Handling command-line interrupts</p><div class="codesample"><table><tr><td scope="row"><pre>void SignalHandler(int sigraised)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("\nInterrupted\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Clean up here<span></span></pre></td></tr><tr><td scope="row"><pre>    IONotificationPortDestroy(gNotifyPort);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (gAppearedIter)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        IOObjectRelease(gAppearedIter);<span></span></pre></td></tr><tr><td scope="row"><pre>        gAppearedIter = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (gDisappearedIter)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        IOObjectRelease(gDisappearedIter);<span></span></pre></td></tr><tr><td scope="row"><pre>        gDisappearedIter = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    exit(0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_52"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_53"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_54"></a>Now that you’ve obtained an iterator for a set of matching devices, you can use it to gain access to each device. The function <code>DeviceAppeared</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIDIEEB">Listing 2-9</a></span>) uses the I/O Kit function <code>IOIteratorNext</code> to access each device object and then calls the function <code>TestDevice</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCICHADC">Listing 2-11</a></span>)to create device interfaces for the device and test it.</p><a name="//apple_ref/doc/uid/TP30000387-BCIDIEEB" title="Listing 2-9Accessing the set of matching devices"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>Accessing the set of matching devices</p><div class="codesample"><table><tr><td scope="row"><pre>void DeviceAppeared(void *refCon, io_iterator_t iterator)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_service_t    obj;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (obj = IOIteratorNext(iterator))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Device appeared.\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        TestDevice(obj);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        kr = IOObjectRelease(obj);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The function <code>DeviceDisappeared</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIIGFJF">Listing 2-10</a></span>) simply uses the iterator obtained from the <code>main</code> function (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIJAFDJ">Listing 2-7</a></span>) to release each device object. This also has the effect of arming the device termination notification so it will notify the program of future device removals.</p><a name="//apple_ref/doc/uid/TP30000387-BCIIGFJF" title="Listing 2-10Releasing the device objects"></a><p class="codesample"><strong>Listing 2-10&nbsp;&nbsp;</strong>Releasing the device objects</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void DeviceDisappeared(void *refCon, io_iterator_t iterator)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_service_t    obj;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (obj = IOIteratorNext(iterator))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Device disappeared.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = IOObjectRelease(obj);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000387-TPXREF105" title="Testing the Device"></a><h3>Testing the Device</h3><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_55"></a>The function <code>TestDevice</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCICHADC">Listing 2-11</a></span>) creates an intermediate plug-in interface for the device and then queries this interface to obtain an MMCDeviceInterface. The sample code does not use the MMCDeviceInterface to query the device although functions such as <code>GetPerformance</code> and <code>GetTrayState</code> are available.</p><p>The function <code>TestDevice</code> uses I/O Kit functions to create the MMCDeviceInterface and then calls the MMCDeviceInterface function <code>GetSCSITaskDeviceInterface</code> to create the SCSITaskDeviceInterface. Once it gets the SCSITaskDeviceInterface, it calls its function <code>ObtainExclusiveAccess</code> to request exclusive access to the device. After receiving exclusive access, <code>TestDevice</code> calls the following functions to create SCSITask objects and send them to the device.</p><ul class="spaceabove"><li class="li"><p><code>Inquiry</code>, (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIJHCIC">Listing 2-12</a></span>), creates a SCSITask object to send an INQUIRY command to the device and prints out the inquiry data it receives.</p></li><li class="li"><p><code>TestUnitReady</code>, (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIHDABH">Listing 2-13</a></span>), creates a SCSITask object to send a TEST_UNIT_READY command to the device and calls <code>PrintSenseString</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIGFJAE">Listing 2-14</a></span>) to print the sense string the device returns.</p></li></ul><p><code>TestDevice</code> then<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_56"></a> relinquishes exclusive access<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_57"></a> to the device and releases the SCSITaskDeviceInterface and MMCDeviceInterface.</p><a name="//apple_ref/doc/uid/TP30000387-BCICHADC" title="Listing 2-11Getting an MMCDeviceInterface and obtaining exclusive access"></a><p class="codesample"><strong>Listing 2-11&nbsp;&nbsp;</strong>Getting an MMCDeviceInterface and obtaining exclusive access</p><div class="codesample"><table><tr><td scope="row"><pre>void TestDevice(io_service_t service)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                          score;<span></span></pre></td></tr><tr><td scope="row"><pre>    HRESULT                         herr;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t                   err;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOCFPlugInInterface             **plugInInterface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    MMCDeviceInterface              **mmcInterface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSITaskDeviceInterface         **interface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the IOCFPlugIn interface so we can query it.<span></span></pre></td></tr><tr><td scope="row"><pre>    err = IOCreatePlugInInterfaceForService (   service,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                kIOMMCDeviceUserClientTypeID,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                kIOCFPlugInInterfaceID,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                &amp;plugInInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                &amp;score );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( err != noErr )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("IOCreatePlugInInterfaceForService returned %d\n", err);<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Query the interface for the MMCDeviceInterface.<span></span></pre></td></tr><tr><td scope="row"><pre>    herr = ( *plugInInterface )->QueryInterface ( plugInInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        CFUUIDGetUUIDBytes ( kIOMMCDeviceInterfaceID ),<span></span></pre></td></tr><tr><td scope="row"><pre>                                        ( LPVOID *) &amp;mmcInterface );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( herr != S_OK )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("QueryInterface returned %ld\n", herr);<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    interface = ( *mmcInterface )->GetSCSITaskDeviceInterface ( mmcInterface );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( interface == NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("GetSCSITaskDeviceInterface returned NULL\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = ( *interface )->ObtainExclusiveAccess ( interface );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( err != noErr )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("ObtainExclusiveAccess returned %d\n", err);<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Inquiry(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>    TestUnitReady(interface);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ( *interface )->ReleaseExclusiveAccess ( interface );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Release the SCSITaskDeviceInterface.<span></span></pre></td></tr><tr><td scope="row"><pre>    ( *interface )->Release ( interface );<span></span></pre></td></tr><tr><td scope="row"><pre>    ( *mmcInterface )->Release ( mmcInterface );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IODestroyPlugInInterface ( plugInInterface );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>Now that you’ve obtained exclusive access, you can create SCSITask objects and send them to the device. The function <code>Inquiry</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIJHCIC">Listing 2-12</a></span>) uses the SCSITaskDeviceInterface function <code>CreateSCSITask</code> to create a SCSITaskInterface object. It then uses SCSITaskInterface functions to prepare the object to send an INQUIRY command. If the command executes successfully, <code>Inquiry</code> prints the results. Finally, <code>Inquiry</code> releases the SCSITaskInterface object and returns.</p><a name="//apple_ref/doc/uid/TP30000387-BCIJHCIC" title="Listing 2-12Sending an INQUIRY command to the device"></a><p class="codesample"><strong>Listing 2-12&nbsp;&nbsp;</strong>Sending an INQUIRY command to the device</p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_58"></a><div class="codesample"><table><tr><td scope="row"><pre>void Inquiry(SCSITaskDeviceInterface **interface)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SCSICmd_INQUIRY_StandardData    inqBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSITaskStatus                  taskStatus;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSI_Sense_Data                 senseData;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSICommandDescriptorBlock      cdb;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSITaskInterface **            task  = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8 *                         bufPtr = ( UInt8 * ) &amp;inqBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    char                            vendorID[9];<span></span></pre></td></tr><tr><td scope="row"><pre>    char                            productID[17];<span></span></pre></td></tr><tr><td scope="row"><pre>    char                            firmwareRevLevel[5];<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn                        err   = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                          index = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOVirtualRange *                range = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt64                          transferCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                          transferCountHi = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                          transferCountLo = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a task now that we have exclusive access<span></span></pre></td></tr><tr><td scope="row"><pre>    task = ( *interface )->CreateSCSITask ( interface );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( task != NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Zero the buffer.<span></span></pre></td></tr><tr><td scope="row"><pre>        memset ( bufPtr, 0, sizeof ( SCSICmd_INQUIRY_StandardData ) );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Allocate a virtual range for the buffer. If we had more than 1 scatter-gather entry,<span></span></pre></td></tr><tr><td scope="row"><pre>        // we would allocate more than 1 IOVirtualRange.<span></span></pre></td></tr><tr><td scope="row"><pre>        range = ( IOVirtualRange * ) malloc ( sizeof ( IOVirtualRange ) );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( range == NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** ERROR Malloc'ing IOVirtualRange ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // zero the senseData and CDB<span></span></pre></td></tr><tr><td scope="row"><pre>        memset ( &amp;senseData, 0, sizeof ( senseData ) );<span></span></pre></td></tr><tr><td scope="row"><pre>        memset ( cdb, 0, sizeof ( cdb ) );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Set up the range. The address is just the buffer's address. The length is our request size.<span></span></pre></td></tr><tr><td scope="row"><pre>        range->address  = ( IOVirtualAddress ) bufPtr;<span></span></pre></td></tr><tr><td scope="row"><pre>        range->length   = sizeof ( SCSICmd_INQUIRY_StandardData );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // We're going to execute an INQUIRY to the device as a<span></span></pre></td></tr><tr><td scope="row"><pre>        // test of exclusive commands.<span></span></pre></td></tr><tr><td scope="row"><pre>        cdb[0] = 0x12 /* inquiry */;<span></span></pre></td></tr><tr><td scope="row"><pre>        cdb[4] = sizeof ( SCSICmd_INQUIRY_StandardData );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Set the actual CDB in the task<span></span></pre></td></tr><tr><td scope="row"><pre>        err = ( *task )->SetCommandDescriptorBlock ( task, cdb, kSCSICDBSize_6Byte );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( err != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** ERROR Setting CDB ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Set the scatter-gather entry in the task<span></span></pre></td></tr><tr><td scope="row"><pre>        err = ( *task )->SetScatterGatherEntries ( task, range, 1, sizeof ( SCSICmd_INQUIRY_StandardData ),<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    kSCSIDataTransfer_FromTargetToInitiator );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( err != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** ERROR Setting SG Entries ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Set the timeout in the task<span></span></pre></td></tr><tr><td scope="row"><pre>        err = ( *task )->SetTimeoutDuration ( task, 10000 );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( err != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** ERROR Setting Timeout ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("*********** Requesting Inquiry Data ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Send it!<span></span></pre></td></tr><tr><td scope="row"><pre>        err = ( *task )->ExecuteTaskSync ( task, &amp;senseData, &amp;taskStatus, &amp;transferCount );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( err != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** ERROR Executing Task ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Get the transfer counts<span></span></pre></td></tr><tr><td scope="row"><pre>        transferCountHi = ( ( transferCount >> 32 ) &amp; 0xFFFFFFFF );<span></span></pre></td></tr><tr><td scope="row"><pre>        transferCountLo = ( transferCount &amp; 0xFFFFFFFF );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("taskStatus = %d, transferCountHi = 0x%08lx, transferCountLo = 0x%08lx\n", taskStatus, transferCountHi, transferCountLo);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Task status is not GOOD, print any sense string if they apply.<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( taskStatus == kSCSITaskStatus_GOOD )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** INQUIRY DATA ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Peripheral Device Type = %d\n", bufPtr[0] &amp; 0x1F);<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Removable Media Bit = %d\n", ( bufPtr[1] &amp; 0x80 ) == 0x80);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            for ( index = 8; index &lt; 16; index++ )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                if ( bufPtr[index] == 0 )<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                vendorID[index-8] = bufPtr[index];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            vendorID[index-8] = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            for ( index = 16; index &lt; 32; index++ )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                if ( bufPtr[index] == 0 )<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                productID[index-16] = bufPtr[index];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            productID[index-16] = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            for ( index = 32; index &lt; 36; index++ )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                if ( bufPtr[index] == 0 )<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                firmwareRevLevel[index-32] = bufPtr[index];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            firmwareRevLevel[index-32] = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Vendor Identification = %s\n", ( char * ) vendorID);<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Product Identification = %s\n", ( char * ) productID);<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Product Revision Level = %s\n", ( char * ) firmwareRevLevel);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            printf("\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Be a good citizen and cleanup<span></span></pre></td></tr><tr><td scope="row"><pre>        free ( range );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Release the task interface<span></span></pre></td></tr><tr><td scope="row"><pre>        ( *task )->Release ( task );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The function <code>TestUnitReady</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIHDABH">Listing 2-13</a></span>) sends a TEST_UNIT_READY command to the device. First, it creates a SCSITaskInterface object and then it creates a CDB that contains the command. After sending the command, <code>TestUnitReady</code> checks the task status and, depending on the status value, calls the function <code>PrintSenseString</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIGFJAE">Listing 2-14</a></span>) to print the sense data. Before returning, <code>TestUnitReady</code> releases the SCSITaskInterface object.</p><a name="//apple_ref/doc/uid/TP30000387-BCIHDABH" title="Listing 2-13Sending a TEST_UNIT_READY command to the device"></a><p class="codesample"><strong>Listing 2-13&nbsp;&nbsp;</strong>Sending a TEST_UNIT_READY command to the device</p><div class="codesample"><table><tr><td scope="row"><pre>void TestUnitReady(SCSITaskDeviceInterface **interface)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SCSITaskStatus                  taskStatus;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSI_Sense_Data                 senseData;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSICommandDescriptorBlock      cdb;<span></span></pre></td></tr><tr><td scope="row"><pre>    SCSITaskInterface **            task  = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn                        err   = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt64                          transferCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a task now that we have exclusive access<span></span></pre></td></tr><tr><td scope="row"><pre>    task = ( *interface )->CreateSCSITask ( interface );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( task != NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // zero the senseData and CDB<span></span></pre></td></tr><tr><td scope="row"><pre>        memset ( &amp;senseData, 0, sizeof ( senseData ) );<span></span></pre></td></tr><tr><td scope="row"><pre>        memset ( cdb, 0, sizeof ( cdb ) );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // The TEST_UNIT_READY code consists of all zeroes so it is<span></span></pre></td></tr><tr><td scope="row"><pre>        // not necessary to set any additional values in the CDB<span></span></pre></td></tr><tr><td scope="row"><pre>        // Set the actual CDB in the task<span></span></pre></td></tr><tr><td scope="row"><pre>        err = ( *task )->SetCommandDescriptorBlock ( task, cdb, kSCSICDBSize_6Byte );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( err != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** ERROR Setting CDB ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Set the timeout in the task<span></span></pre></td></tr><tr><td scope="row"><pre>        err = ( *task )->SetTimeoutDuration ( task, 5000 );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( err != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** ERROR Setting Timeout ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Send it!<span></span></pre></td></tr><tr><td scope="row"><pre>        err = ( *task )->ExecuteTaskSync ( task, &amp;senseData, &amp;taskStatus, &amp;transferCount );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( err != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("*********** ERROR Executing Task ***********\n\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("taskStatus = %d\n", taskStatus);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Task status is not GOOD, print any sense string if they apply.<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( taskStatus == kSCSITaskStatus_GOOD )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Good Status\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // Something happened. Print the sense string<span></span></pre></td></tr><tr><td scope="row"><pre>            PrintSenseString(&amp;senseData);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("taskStatus = 0x%08x\n", taskStatus);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Release the task interface<span></span></pre></td></tr><tr><td scope="row"><pre>        ( *task )->Release ( task );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_59"></a><a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_60"></a>The function <code>PrintSenseString</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIGFJAE">Listing 2-14</a></span>) prints the sense data the device returns after executing the TEST_UNIT_READY command sent in <code>TestUnitReady</code> (shown in <span class="content_text"><a href="WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387-BCIHDABH">Listing 2-13</a></span>).<a name="//apple_ref/doc/uid/TP30000387-DontLinkElementID_61"></a></p><a name="//apple_ref/doc/uid/TP30000387-BCIGFJAE" title="Listing 2-14Printing the sense data"></a><p class="codesample"><strong>Listing 2-14&nbsp;&nbsp;</strong>Printing the sense data</p><div class="codesample"><table><tr><td scope="row"><pre>void<span></span></pre></td></tr><tr><td scope="row"><pre>PrintSenseString ( SCSI_Sense_Data * sense )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    char    str[256];<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8   key, ASC, ASCQ;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    key     = sense->SENSE_KEY &amp; 0x0F;<span></span></pre></td></tr><tr><td scope="row"><pre>    ASC     = sense->ADDITIONAL_SENSE_CODE;<span></span></pre></td></tr><tr><td scope="row"><pre>    ASCQ    = sense->ADDITIONAL_SENSE_CODE_QUALIFIER;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Print the sense string information.<span></span></pre></td></tr><tr><td scope="row"><pre>    sprintf ( str, "Key: $%02lx, ASC: $%02lx, ASCQ: $%02lx  ", key, ASC, ASCQ );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WWS_ParaSCSI/WWS_ParallelSCSI.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WWS_RevHistory/WWS_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WorkingWithSAM/WWS_SAMDevInt/WWS_SAM_DevInt.html%3Fid%3DTP40000971-2.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WorkingWithSAM/WWS_SAMDevInt/WWS_SAM_DevInt.html%3Fid%3DTP40000971-2.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WorkingWithSAM/WWS_SAMDevInt/WWS_SAM_DevInt.html%3Fid%3DTP40000971-2.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>