<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"            "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!--Template 06-20-02--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Q&amp;A GX05: Supporting QuickDraw GX with EPS</title><meta name="keywords" content="Mac OS 8 QuickDraw GX EPS postscript converting files "><meta name="Description" content="Technical Q&amp;A GX05: Note: The latest Mac OS releases, MacOS 8.5.x and 8.6, will be the final operating system releasesfrom Apple to include support for QuickDraw GX. Q&amp;A providesa way to convert a QuickDraw GX shape into a postscript imagefor printing that is position dependent on a page. Q&amp;A alsoprovides the sample code for a function called EPStoShapethat will convert an EPS file into its corresponding GXShapes,in simple cases."><meta name="categories" content="QuickDraw GX"><meta name="week-posted" content="Oct 21, 1996 - Nov 1, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10001210" title="Supporting QuickDraw GX with EPS"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalqas/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A GX05</div>
<div id="pageheadsub">Supporting QuickDraw GX with EPS</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment -->            <!-- begin_content --> <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=600><TR> <td align="left"><hr width=500 align=center><p id = p2>Q:  What is the correct way to support EPS files using QuickDraw GX?Converting the QuickDraw preview into a GX shape and attaching a tag containingthe PostScript code looks OK, but results in a vertically flipped PostScriptimage when printed. This is presumably because of the difference in orientationbetween GX and PostScript. Is it necessary to modify the PostScript code tosolve this problem?</p><p id=p4>A:  It's true that when using PostScript synonyms, you need to account for the QDcoordinate space. QD defines 0,0 as the top-left corner of the page, whilePostScript defines 0,0 as the bottom-left coordinate. There is a small note onpage 4-13 of the 'Quickdraw GX Printing' manual that mentions this.</p> <p id=p4>There are many ways to handle this. One method is to use translate and scale toswitch the coordinate system back. If, for example, the page is 760 pixelstall, you could use:</p> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    0 760 translate    1 -1 scale    newpath</pre>	</TD></TR></TABLE></CENTER><p id=p4>to translate 0,0 back to the bottom left corner of the page. The rest of yourPostScript code can then be sent as-is. Be sure to undo the effects of thetranslate and scale operations before attempting to draw any GX objects, orthey will be upside-down as well.</p><p id = p2>Q:  The method you suggested is a fine way of supporting EPS inQuickDraw GX for many applications, assuming that they do not allow users toexport the EPS. However, we need to support EPS as a position-independent shape(as part of a flattened picture shape). Since the method below relies onknowledge of the page height, it does not work for exchanging data betweenapplications (for example, 'qdgx' clipboard and file formats).</p><p id=p4>I tried to enclose the EPS preview shape within a picture shape. The EPSsynonym tag was attached to the picture shape, and a vertical reflectionmapping was applied both to the preview shape and the picture shape itself. Theidea was that the PostScript would be reflected once vertically (and thus printcorrectly) while the enclosed preview shape would be reflected twice vertically(and thus display correctly). Unfortunately, the PostScript did not print inthe correct place, while the preview shape displayed correctly, but glacially.I'd appreciate any suggestions as to how to handle this in aposition-independent manner.</p><p id=p4>A:  We've provided a function called EPStoShape that is an example of how toencapsulate your EPS into a GX shape. This sample is very simple, and it needsto be extended for use in a real application. </p><p id=p4>There are two cases that the sample code cannot handle:</p> <ol type="1" start="1">	<li><p id=p4>With large EPS files, the EPStoShape routine reads the entire EPS file into a single handle, which is added to the shape as a 'post' collection. This works fine for small sample files, but to support larger EPS files, you should modify this routine to read the file in sections, adding multiple, smaller collections to the shape. This reduces the memory requirements at print time.</p></li> 	<li><p id=p4>The EPStoShape function looks for the %%BoundingBox comment in the EPS file to determine the size of the document/shape. This comment is usually found just before the actual document data, and it is followed by 4 integers representing the top,left,bottom,right of the bounding box. However, to make writing EPS files easier, the format of this comment was extended. Now, do the following:</p></li></ol> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   %% BoundingBox: (atend)    &lt;Actual Document Data&gt;    %% BoundingBox: 0 0 10 10</pre>	</TD></TR></TABLE></CENTER><p id=p4>In this case, the '(atend)' tells the reader that the actual bounding box canbe found at-end of document data. The EPStoShape function assumes that thefirst BoundingBox comment has the four coordinates and generates bogusPostScript code if the (atend) keyword is found instead. To use this routine inyour application, you should modify it to check for the (atend) construct andto look for the second BoundingBox comment, if it is found.</p> <p id=p4>Both of these modifications should be easy to implement.</p><H3>Routine: EPSFileToShape</H3>    <p id=p4>Reads in an EPS file and makes a shape out of it. If there was a PICT resource in it, it translates it to Skia, if there is no PICT resource, it will make a rectangle shape the width and height of the bounding box from the EPS BoundingBox:: comment with first point at 0,0.</P><p id=p4>In either case, the EPS file will be attached to the shape with 'post' tag synonyms.</P><p id=p4>Additional PostScript will be attached to make it so the PostScript renders through the shape's transform (obviously, no perspective allowed here) properly when printing through the Skia-PostScript Imaging System.</P>    <p id=p4>The algorithm for this comes from the <I>PostScript Language Reference Manual, 2nd edition</I>.  Page 724.</P>    <ol type="1" start="3">	<li>left bottom translate      %% where left,bottom is left, bottom of QD shape's bounds.</li>	<li>1 -1 scale                 %% Put us back in PostScript space, we were in Skia.</li>	<li>-x1 -y1 translate          %% Put the origin at the EPS bounding box's lower left.</li></ol><p id=p4>Routine does not check for the validity of the EPS data or version. It assumes the PostScript is valid EPS with bounding box comment.</P>/******************************************************/ <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>gxShape EPSFileToShape(Str255 fName, short vRefNum)    {        OSErr               status;        PicHandle       thePict;        Rect                theRect;        Point               patStretch = {1,1};        gxShape             theShape = nil;        short               refNum;        gxTag                   synTag;        long                size;        Handle          hPsData;        long                startComment, endComment;        Str32               num1;        char                tagString[300];        long                tagSize, pieceSize;        gxTranslationStatistic              seanStats;        /** Now get the PostScript data **/        status = FSOpen(fName, vRefNum, &amp;refNum);        ncheck(status);        GetEOF(refNum, &amp;size);        hPsData = NewHandle(size);        HLock(hPsData);        /** Read in the whole EPS file **/        status = FSRead(refNum, &amp;size, *hPsData);        ncheck(status);        FSClose(refNum);        /** Find the bounding box comment (Numbers only) **/        startComment = Munger(hPsData, 0, "%%BoundingBox:", 14, nil, 0) + 14;        endComment = Munger(hPsData , startComment, "\n", 1, nil, 0);        refNum = OpenRFPerm(fName, vRefNum, 0);        thePict = (PicHandle)GetResource('PICT', 256);        if (thePict != nil) {            theRect = (*thePict)-&gt;picFrame;            theShape = GXNewShape(gxPictureType);            (void) GXConvertPICTToShape(thePict, gxDefaultOptionsTranslation,            &amp;theRect, &amp;theRect, patStretch,            theShape, &amp;seanStats);            status = GXGetGraphicsError(nil);            ncheck(status);            ReleaseResource((Handle)thePict);        } else {            float            x1, y1, x2, y2;            gxRectangle  theRectangle;            sscanf(*hPsData + startComment, "%f %f %f %f", &amp;x1, &amp;y1,            &amp;x2, &amp;y2);            theRectangle.top = 0;            theRectangle.left = 0;            theRectangle.right = X2Fix(x2 - x1);            theRectangle.bottom = X2Fix(y2 - y1);            /** We need the QuickDraw rectangle for the            embedded PostScript origin translage **/            theRect.top = 0;            theRect.left = 0;            theRect.bottom= theRectangle.bottom &gt;&gt; 16;            theRect.right = theRectangle.right &gt;&gt; 16;            theShape = GXNewRectangle(&amp;theRectangle);        }//end if        CloseResFile(refNum);        /** translate to Left Bottom of QuickDraw rectangle **/        tagSize = 0;        NumToString(theRect.left, num1);        num1[(unsigned char)num1[0] + 1] = ' ';        pieceSize = (unsigned char)num1[0] + 1;        BlockMove(&amp;(num1[1]), tagString, pieceSize);        tagSize += pieceSize;        NumToString(theRect.bottom, num1);        pieceSize = (unsigned char)num1[0];        BlockMove(&amp;(num1[1]), tagString + tagSize, pieceSize);        tagSize += pieceSize;        BlockMove(" translate\n", tagString + tagSize, 11);        tagSize += 11;        /** flip y axis **/        BlockMove(" 1 -1 scale\n", tagString + tagSize, 12);        tagSize += 12;        synTag = GXNewTag( gxPostScriptTag, tagSize, tagString);        GXSetShapeTags(theShape, gxPostScriptTag, 0, 0, 1, &amp;synTag);        GXDisposeTag(synTag);        /** Translate to -(LLx) -(LLy) **/        // 4 bbox numbers from operand comment string on operand stack        synTag = GXNewTag( gxPostScriptTag, endComment - startComment + 1,        *hPsData + startComment);        GXSetShapeTags(theShape, gxPostScriptTag, 0, 0, 1, &amp;synTag);        GXDisposeTag(synTag);        // Pop the second two, translate to negative of first two.        synTag  = GXNewTag( gxPostScriptTag, 36,        "pop pop neg exch neg exch translate\n");        GXSetShapeTags(theShape, gxPostScriptTag, 0, 0, 1,        &amp;synTag);        GXDisposeTag(synTag);        /** The PostScript Synonym itself **/        synTag = GXNewTag( gxPostScriptTag, size, *hPsData);        GXSetShapeTags(theShape, gxPostScriptTag, 0, 0, 1, &amp;synTag);        GXDisposeTag(synTag);        DisposHandle(hPsData);        check(theShape);        return(theShape);    }//EPSFileToShape</pre>	</TD></TR></TABLE></CENTER></td></tr></table></center><!-- end_content --><!-- begin_date --><H4 ALIGN=center>[May 01 1995]</H4><!-- end_date --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/gx/gx05.html%3Fid%3DDTS10001210-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/gx/gx05.html%3Fid%3DDTS10001210-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/gx/gx05.html%3Fid%3DDTS10001210-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --> <hr width=500 align=center> </BODY> </HTML>