<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using Text Picture Comments (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING469></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-468.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-470.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-465.html"><B>Appendix B - Using Picture Comments for Printing</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING469-0></A>
<H1><A NAME=MARKER-9-71></A>Using Text Picture Comments</H1>
 <A NAME=MARKER-2-72></A>The text picture comments listed in <A HREF=QuickDraw-466.html#MARKER-9-1>Table B-1 on page B-8</A> allow you to disable the printer driver's line layout capabilities (as described in the next section), construct lines of text out of disparate strings (as described in <A HREF=#MARKER-9-94>"Delimiting Strings" on page B-19</A>), and rotate text on the page (as described in <A HREF=#MARKER-9-98>"Rotating Text" on page B-20</A>).<P>
 For information on drawing text, see <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>.<P>
<A NAME=HEADING469-3></A>
<H2><A NAME=MARKER-9-73></A>Disabling and Reenabling Line Layout</H2>
 <A NAME=MARKER-2-74></A>When your application draws text into a printing graphics port, the printer driver may do a lot of extra work depending on the current printer; the printer driver may have to scale and smooth fonts, remap characters, and substitute one font used onscreen for another that exists on the printer (this last action is called <B>font substitution</B>). <A NAME=MARKER-2-75></A><P>
 After it selects the appropriate font, the printer driver matches the width of the printed line with the width of the screen line. If the driver has to perform font substitution, the two lines may be very different. For example, if your application draws a document with the Geneva bitmapped font (instead of the Geneva TrueType font), a PostScript printer driver could substitute the Helvetica<Superscript>\xC6<EM></EM> font for Geneva in the PostScript code it generates. Since Helvetica is a different font, it has different metrics. A rather exaggerated example of the effects of font substitution can be found in <A HREF=#MARKER-9-76>Figure B-1</A>. <P>
<B>Figure B-1  <A NAME=MARKER-9-76></A>The line layout error between a bitmapped font and a PostScript font</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/AppB-L-02.jpg"><BR>
 <A NAME=MARKER-2-77></A>For the typical user, the appearance of Helvetica on the printed page is not that much different from the appearance of Geneva on the screen. However, the width of the lines using the two fonts is different; this difference is called the<B> line layout error.</B> The line of text using the bitmapped screen font is much wider than the line of text using the PostScript printer font. (Depending on the font used in the document or substituted on the printer, you might also run into cases where the screen width is narrower than the printed width.) <P>
<DL>
<DT><B>Note</B>
<DD>There are no line layout problems with TrueType fonts, unless one font has the same name as--but a different character width from--a printer-resident PostScript font.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To distribute the layout error, a printer driver must effectively increase or decrease the width of each glyph in the line. A <B>glyph</B> is the distinct representation of a character in a form that a screen or printer can display. A glyph may represent one character (the lowercase <I>a</I>), more than one character (the <I>fi</I> ligature, two characters but one glyph), or a nonprinting character (the space character). When using Roman scripts, most lines of text contain some number of space character glyphs. Printer drivers take advantage of this fact and normally apply most of the layout error to space glyphs (known as the <B>major glyphs</B>) and the rest of the error to the other glyphs in the string (known as the <B>minor glyphs</B>).<A NAME=MARKER-2-78></A><P>
 In <A HREF=#MARKER-9-79>Figure B-2</A>, the <I>i</I>, <I>s</I>, and <I>a</I> characters are examples of minor glyphs, where <I>s</I> and <I>a</I> are separated by the major glyph (the space character).<P>
<B>Figure B-2  <A NAME=MARKER-9-79></A>Major and minor glyphs</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/AppB-L-03.jpg"><BR>
 The amount of error applied to the major glyph is known as the <B>major error,</B> and the amount applied to the other glyphs is the <B>minor error.</B><A NAME=MARKER-2-80></A><P>
 In <A HREF=#MARKER-9-81>Figure B-3</A>, the printer driver corrects most of the difference between the line widths by expanding the width of the space glyphs in the string. <P>
<B>Figure B-3  <A NAME=MARKER-9-81></A>Distributing layout error to the major glyphs</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/AppB-L-04.jpg"><BR>
 However, if the printer driver expands only the width of the spaces, the line has a strange appearance. To balance the changes made to the space glyphs, the driver's line layout routines increase the space between each glyph in the string by a small amount. After the line is laid out in this way, the printed string should be almost exactly as wide as the string that was displayed on the screen. As shown in <A HREF=#MARKER-9-84>Figure B-4</A>, the space between the uppercase <I>T</I> and the lowercase <I>h</I> in the word <I>This</I> has been increased, but only slightly; most of the error has been applied to the spaces. By default, most drivers apply about 80 percent of the total line layout error to the major glyphs and the other 20 percent to the minor glyphs. When using a script system that does not use the space glyph to delimit words, the layout error is distributed evenly across all characters in the line.<A NAME=MARKER-2-82></A><A NAME=MARKER-2-83></A><P>
<B>Figure B-4  <A NAME=MARKER-9-84></A>Distributing layout error among major and minor glyphs</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/AppB-L-05.jpg"><BR>
 A printer driver's line layout routines are device-dependent. Since different devices have different resident fonts, the layout error can be quite large. For this reason, you should not assume that if you have the correct output on one type of laser printer you will have the correct output on all devices or with all fonts. <P>
 Although the printer driver can compute the placement of a line of text on the page so that it closely approximates the placement of the line on the screen, there are times when adjusting the line of text by adding space can have an adverse effect on the line layout that your application has already done. <P>
 You can disable the line layout routines of the current printer driver and give your application more control over placement of the glyphs on the page by using the <CODE>LineLayoutOff</CODE> picture comment. You may want to use this picture comment if your application prints monospaced, tab-formatted text; draws notes or other music symbols using glyphs from a music font; or renders mathematical equations or formulas. For example, if your application displays musical notation, the notes should stay where your application placed them, because small shifts in position can cause the music to be misread. <A NAME=MARKER-2-85></A><P>
 <A NAME=MARKER-2-86></A>The <CODE>LineLayoutOff</CODE> picture comment instructs the printer driver to make no adjustments to the text being sent. Your application is then responsible for identically matching the appearance of text displayed on the screen to the printer. If the current printer driver does not support these comments, it ignores them and places the text on the page as well as it can. <P>
 You can reenable the printer driver's line layout routines with the <CODE>LineLayoutOn</CODE> picture comment (however, some printer drivers support only the <CODE>LineLayoutOff</CODE> comment). Although general line layout is disabled, some small shifts in glyph position may still occur. These shifts are usually not a problem, but, if they are, you should use the <CODE>PrGeneral</CODE> procedure with the <CODE>getRslDataOp</CODE> and <CODE>setRslOp</CODE> opcodes (described in the chapter "Printing Manager" in this book) to draw text at the resolution of the current printer. <A NAME=MARKER-2-87></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Setting the <CODE>FractEnable</CODE> global variable (described in the chapter "Font Manager" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>) to <CODE>TRUE</CODE> does not have precisely the same effect as using the <CODE>LineLayoutOff</CODE> picture comment. You should explicitly use the <CODE>LineLayoutOff</CODE> picture comment rather than the <CODE>SetFractEnable</CODE> procedure.<EM></EM><A NAME=MARKER-2-88></A><A NAME=MARKER-9-87></A><A NAME=MARKER-2-90></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-91>Figure B-5</A> compares the results of an application using the <CODE>LineLayoutOff</CODE> picture comment and the <CODE>LineLayoutOn</CODE> picture comment. In the first example, the text is printed exactly as it is rendered on the printer, with a much smaller width. In the second example, the printer driver's line layout routines make the screen and printer lines the same length.<P>
<B>Figure B-5  <A NAME=MARKER-9-91></A>Using the <CODE>LineLayoutOff</CODE> and <CODE>LineLayoutOn</CODE> picture comments</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/AppB-L-06.jpg"><BR>
 In computing the required line layout adjustments, the PostScript LaserWriter driver proceeds as follows:<P>
<OL>
<LI>It collects text processed by the routine pointed to in the <CODE>textProc</CODE> field of the printing graphics port's <CODE>QDProcs</CODE> record, and assembles the text into a logically contiguous line. This includes text moved vertically away from the baseline to take care of diacritical marks or exponents in the text. The accumulation of text stops when the PostScript LaserWriter driver detects that the pen position has moved horizontally since the conclusion of the previous text-drawing instruction, or when the driver encounters picture comments such as <CODE>TextBegin</CODE>, <CODE>TextEnd</CODE>, <CODE>StringBegin</CODE>, and <CODE>StringEnd</CODE>.
<LI>It determines the width of the accumulated logical line of text, both on the screen and on the printer, and distributes the line layout error among the interword and intercharacter spacing of the printed output.<P>
</OL>
 The <CODE>LineLayoutOff</CODE> picture comment disables only the second step (distribution of the line layout error); the algorithm of accumulating text into a logically contiguous piece is not affected. Otherwise, if the character widths of the printer font are different from those of the screen font, and if the text contains diacritical marks or exponents, the diacritical marks and exponents would often be misplaced.<A NAME=MARKER-2-92></A><P>
 If you want precise control over the placement of different text strings within a line, you must override the heuristic line accumulation algorithm of the PostScript LaserWriter driver (described in the first step). A good way to override this algorithm is to use the <CODE>StringBegin</CODE> and <CODE>StringEnd</CODE> picture comments to mark individual strings as logically independent text entities; this prevents the PostScript LaserWriter driver from assembling the strings into one logically contiguous line of text. The <CODE>StringBegin</CODE> and <CODE>StringEnd</CODE> picture comments are described in the next section; <A HREF=#MARKER-9-97>Listing B-3 on page B-19</A> illustrates how to completely disable line layout by using the <CODE>LineLayoutOff</CODE> and <CODE>StringBegin</CODE> picture comments.<A NAME=MARKER-2-93></A><P>
<A NAME=HEADING469-35></A>
<H2><A NAME=MARKER-9-94></A>Delimiting Strings</H2>
 <A NAME=MARKER-2-95></A>You may want to draw a particular text string in pieces instead of a whole. For example, to draw kerned glyphs, you can draw the first part of the string--up to the point where kerning occurs--using the <CODE>DrawText</CODE> procedure, and you can then adjust the pen and draw the kerned glyph using the <CODE>DrawChar</CODE> procedure. (The <CODE>DrawText</CODE> and <CODE>DrawChar</CODE> procedures are described in the chapter "QuickDraw Text" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>.) You can also draw a single string that contains different fonts, styles, or sizes--if you call <CODE>DrawText</CODE> each time the typeface or font style changes. To identify the beginning of a single string that will be drawn using multiple calls to a QuickDraw text-drawing routine, you can use the <CODE>StringBegin</CODE> picture comment. Use the <CODE>StringEnd</CODE> picture comment to mark its end. <P>
 <A NAME=MARKER-2-96></A>You can use the <CODE>StringBegin</CODE> and <CODE>StringEnd</CODE> picture comments if your application needs complete control over glyph placement on a page. If your application uses text-editing boxes for individual strings, it can use these picture comments to treat each string as a separate piece of text and place all glyphs into one text-editing box.<P>
 <A HREF=#MARKER-9-97>Listing B-3</A> uses the <CODE>StringBegin</CODE> and <CODE>StringEnd</CODE> picture comments. Use the <CODE>LineLayoutOff</CODE> picture comment (described in the preceding section) in conjunction with the <CODE>StringBegin</CODE> comment to turn line layout completely off.<P>
<B>Listing B-3  <A NAME=MARKER-9-97></A>Disabling line layout by using the <CODE>LineLayoutOff</CODE> and <CODE>StringBegin</CODE> picture comments</B><P>
<PRE>
PROCEDURE MyStringReconDemo (x: XArray; y: Integer);
BEGIN
   PicComment(LineLayoutOff,0,NIL);
   PicComment(StringBegin,0,NIL);
   {position each character of the word 'Test' using }
   { MoveTo and DrawChar}
   MoveTo(x[1],y); DrawChar('T');
   MoveTo(x[2],y); DrawChar('e');
   MoveTo(x[3],y); DrawChar('s');
   MoveTo(x[4],y); DrawChar('t');
   {reenable the printer driver's line layout routines}
   PicComment(StringEnd,0,NIL);
   PicComment(LineLayoutOn,0,NIL);
END;
</PRE>
<A NAME=HEADING469-41></A>
<H2><A NAME=MARKER-9-98></A>Rotating Text</H2>
 <A NAME=MARKER-2-99></A>You can use picture comments to rotate text on PostScript devices and on any QuickDraw-based drivers that support text rotation. (This is not the kind of rotation associated with landscape and portrait orientation of the printer paper as selected by the user through the style dialog box. This rotation occurs in reference to the current QuickDraw graphics port only.) The picture comments to rotate text are <CODE>TextBegin</CODE>, <CODE>TextCenter</CODE>, and <CODE>TextEnd</CODE>. <A NAME=MARKER-2-100></A><P>
 If you use picture comments to rotate text, you should also generate a device-independent representation, such as a bitmapped version of the text, to be used on QuickDraw devices that don't support these picture comments. Printer drivers that support <CODE>TextBegin</CODE>, <CODE>TextCenter</CODE>, and <CODE>TextEnd</CODE> are expected to ignore calls to the <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, and <CODE>CopyDeepMask</CODE> procedures (as well as QuickDraw clipping regions) between the <CODE>TextBegin</CODE> and <CODE>TextEnd</CODE> picture comments. In this way, you can use <CODE>CopyBits</CODE> to draw a bitmap representation of rotated text on QuickDraw printers; the bitmap is not used if the <CODE>TextBegin</CODE> and <CODE>TextEnd</CODE> picture comments are supported, but it is used if <CODE>TextBegin</CODE> and <CODE>TextEnd</CODE> are not supported.<P>
 Some versions of 2-byte Kanji systems print Kanji glyphs by calling the <CODE>CopyBits</CODE> procedure instead of calling standard text-drawing routines. You cannot use the text rotation picture comments with these fonts. Instead, use the picture comments described in <A HREF=QuickDraw-470.html#MARKER-9-147>"Rotating Graphics" beginning on page B-31</A>.<P>
 To use picture comments to rotate text, you begin by specifying the amount of rotation as a parameter to the <CODE>TextBegin</CODE> comment. Next, you pass the center of rotation in the <CODE>TextCenter</CODE> comment. The printer driver rotates any text drawn between the <CODE>TextCenter</CODE> and <CODE>TextEnd</CODE> comments. <A NAME=MARKER-2-101></A><P>
 The <CODE>TextBegin</CODE> picture comment allows your application to specify left, right, center, or full justification; horizontal or vertical flipping; and degrees of rotation. The possible types of alignment are shown in <A HREF=#MARKER-9-102>Figure B-6</A>.<P>
<B>Figure B-6  <A NAME=MARKER-9-102></A>Variations in text alignment</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/AppB-L-07.jpg"><BR>
 When you specify the <CODE>TextBegin</CODE> picture comment in the <CODE>kind</CODE> parameter of the <CODE>PicComment</CODE> procedure, you also specify a <CODE>TTxtPicHdl</CODE> handle (a handle to a <CODE>TTxtPicRec</CODE> record) in the <CODE>dataHandle</CODE> parameter. Here is how you should declare these as Pascal data types in your application:<P>
<PRE>
TYPE 
   TTxtPicHdl  = ^TTxtPicPtr;
   TTxtPicPtr  = ^TTxtPicRec;
   TTxtPicRec  =
   PACKED RECORD
      tJus:          Byte;    {justification of text}
      tFlip:         Byte;    {horizontal or vertical flipping}
      tAngle:        Integer; {0..360 degrees clockwise rotation }
                              { in integer format}
      tLine:         Byte;    {reserved}
      tCmnt:         Byte;    {reserved}
      tAngleFixed:   Fixed;   {0..360 degrees clockwise rotation }
                              { in fixed-number format}
   END;
</PRE>
 <A NAME=MARKER-2-103></A>You supply the <CODE>tJus</CODE> field with one of these constants to specify the alignment setting of the text:<P>
<PRE>
   CONST
      tJusNone    = 0;  {no alignment}
      tJusLeft    = 1;  {flush left}
      tJusCenter  = 2;  {centered}
      tJusRight   = 3;  {flush right}
      tJusFull    = 4;  {full justification}
</PRE>
 Setting the <CODE>tJus</CODE> field to left, right, or centered tells the printer driver to maintain only the left, right, or center point of the line (respectively), preventing the driver from recalculating the interword spacing. A value of <CODE>tJusFull</CODE> specifies that both endpoints of the line must be maintained, so the driver recalculates interword spacing instead of rejustifying text.<A NAME=MARKER-2-104></A><P>
 <A NAME=MARKER-2-105></A>You supply the <CODE>tFlip</CODE> field with one of these constants to specify the horizontal or vertical flipping of text about the center point (which, in turn, is specified with the <CODE>TextCenter</CODE> picture comment):<A NAME=MARKER-2-106></A><P>
<PRE>
   CONST
      tFlipNone         = 0; {no flip of text}
      tFlipHorizontal   = 1; {horizontal flip of text}
      tFlipVertical     = 2; {vertical flip of text}
</PRE>
 You supply the <CODE>tAngle</CODE> field with an integer to specify the number of degrees by which the printer driver should rotate the text. <A NAME=MARKER-2-107></A><P>
 The <CODE>tLine</CODE> and <CODE>tCmnt</CODE> fields are reserved.<P>
 <A NAME=MARKER-2-108></A>You supply the <CODE>tAngleFixed</CODE> field with a fixed-point number to specify the number of degrees by which the printer driver should rotate the text. <P>
 In a <CODE>TTxtPicRec</CODE> record, you can provide the degrees of rotation both as an integer (in the <CODE>tAngle</CODE> field) and as a fixed-point number (in the <CODE>tAngleFixed</CODE> field). You should always specify the rotation in both fields, even for drivers that support only integral rotation. The driver determines which field to use based on the size of the handle passed to <CODE>PicComment</CODE>. If you do not define the <CODE>tAngleFixed</CODE> field in the <CODE>TTxtPicRec</CODE> record, the printer driver automatically uses the <CODE>tAngle</CODE> field.<A NAME=MARKER-2-109></A> <A NAME=MARKER-2-110></A><A NAME=MARKER-2-111></A><P>
 To rotate an object, a printer driver needs information concerning the center of rotation. Immediately after a <CODE>TextBegin</CODE> comment, the driver expects the <CODE>TextCenter</CODE> picture comment specifying the offset to the center of rotation for any text enclosed within the text picture comments. The driver stores this offset and adds it to the location of the first text-drawing routine after it receives the <CODE>TextCenter</CODE> picture comment. This allows you to send multiple runs of text to be rotated with different centers of rotation, while using only one set of <CODE>TextBegin</CODE> and <CODE>TextEnd</CODE> picture comments. The printer driver expects the string locations to be in the coordinate system of the current graphics port. <P>
 The printer driver rotates the entire graphics port to draw the text, so it can draw several strings with one <CODE>TextBegin</CODE> picture comment and one <CODE>TextCenter</CODE> picture comment. You should always include as much text as possible in a single <CODE>TextBegin</CODE> picture comment so that the driver makes the fewest number of rotations.<A NAME=MARKER-2-112></A><P>
 The printer driver can draw nontextual objects within the bounds of the text rotation comments, but it must restore the printing graphics port to its original state to draw the object, and then rotate the printing graphics port again to draw the next string of text. You must send another <CODE>TextCenter</CODE> comment before each new rotation. <P>
 When you specify the <CODE>TextCenter</CODE> (or <CODE>RotateCenter</CODE>) picture comment in the <CODE>kind</CODE> parameter of the <CODE>PicComment</CODE> procedure, you also supply in the <CODE>dataHandle</CODE> parameter a <CODE>TCenterHdl</CODE> handle, which is a handle to a <CODE>TCenterRec</CODE> record. You can use this record to specify the center of rotation for text or (as described in <A HREF=QuickDraw-470.html#MARKER-9-147>"Rotating Graphics" beginning on page B-31</A>) for graphics. Here is how you should declare these as Pascal data types in your application:<P>
<PRE>
TYPE
   TCenterHdl  = ^TCenterPtr;
   TCenterPtr  = ^TCenterRec;
   TCenterRec  = 
   RECORD
      y:    Fixed;   {vertical offset from current pen location}
      x:    Fixed;   {horizontal offset from current pen location}
   END; 
</PRE>
 You use the <CODE>y</CODE> field to specify the vertical offset along the y-axis from the current pen location to the center of rotation.<A NAME=MARKER-2-113></A><P>
 You use the <CODE>x</CODE> field to specify the horizontal offset along the x-axis from the current pen location to the center of rotation.<A NAME=MARKER-2-114></A><A NAME=MARKER-2-115></A><P>
 The application-defined routine <CODE>MyDrawXString</CODE>, shown in <A HREF=#MARKER-9-117>Listing B-4</A>, rotates the strings by the degrees specified in the <CODE>rot</CODE> parameter. The rotation occurs around the current point, offset by the value passed in the <CODE>ctr</CODE> parameter. The strings are justified and flipped according to the <CODE>just</CODE> and <CODE>flip</CODE> parameters. If the printer driver supports the <CODE>TextBegin</CODE>, <CODE>TextCenter</CODE>, and <CODE>TextEnd</CODE> picture comments, the printer driver rotates the text at device resolution; otherwise, an application-defined procedure is called to generate a bitmap of the rotated and flipped text, using <CODE>CopyBits</CODE> to draw the text in the printing graphics port. The pen position is preserved. (<A HREF=QuickDraw-470.html#MARKER-9-158>Listing B-8 on page B-33</A> illustrates how to use the <CODE>TCenterRec</CODE> record to rotate graphics.)<A NAME=MARKER-2-116></A><P>
<B>Listing B-4  <A NAME=MARKER-9-117></A>Displaying rotated text using picture comments</B><P>
<PRE>
PROCEDURE MyDrawXString(s: Str255; ctr: Point;
                       just, flip: Integer; rot: Fixed);
VAR
   hT:         TTxtPicHdl;
   hC:         TCenterHdl;
   zeroRect:   Rect;
   pt:         Point;
   oldClip:    RgnHandle;
BEGIN
   GetPen(pt);    {to preserve the pen position}
   hT := TTxtPicHdl(NewHandle(SizeOf(TTxtPicRec)));
   hC := TCenterHdl(NewHandle(SizeOf(TCenterRec)));
   WITH hT^^ DO
   BEGIN
      tJus := just;
      tFlip := flip; 
      tAngle := - FixRound(rot); {counterclockwise}
      tLine := 0; {reserved}
      tCmnt := 0; {used internally by the printer driver}
      tAngleFixed := - rot;
   END;
   hC^^.y := Long2Fix(ctr.v);
   hC^^.x := Long2Fix(ctr.h);
   MyFlushPostScriptState; {see Listing B-2 on page B-11}
   PicComment(TextBegin,SizeOf(TTxtPicRec),Handle(hT));
   PicComment(TextCenter,SizeOf(TCenterRec),Handle(hC));
   {graphics state now has rotated/flipped coordinates}
   oldClip := NewRgn;
   GetClip(oldClip);
   SetRect(zeroRect,0,0,0,0);
   ClipRect(zeroRect);  {hides this DrawString from }
   DrawString(s);       { QuickDraw in the rotated }
                        { environment}
   ClipRect(oldClip^^.rgnBBox);
   {now the &quot;fallback&quot; bitmap representation}
   MyQDStringRotation(s, ctr, just, flip, rot);
   PicComment(TextEnd, 0, NIL);
   {set environment back to the original state}
   DisposeHandle(Handle(hT));
   DisposeHandle(Handle(hC));
   MoveTo(pt.h, pt.v);  {restore the pen position}
END;
</PRE>
 Because the PostScript LaserWriter driver buffers generated PostScript code, and because the driver ignores clipping regions between the <CODE>TextBegin</CODE> and <CODE>TextEnd</CODE> picture comments, clipping regions for drawing instructions that precede <CODE>TextBegin</CODE> may be affected. Therefore, <CODE>MyDrawXString</CODE> uses the application-defined routine <CODE>MyFlushPostScriptState</CODE> (shown in <A HREF=QuickDraw-468.html#MARKER-9-70>Listing B-2 on page B-14</A>) immediately before using the <CODE>TextBegin</CODE> picture comment.<A NAME=MARKER-2-118></A><A NAME=MARKER-2-119></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-468.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-470.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
