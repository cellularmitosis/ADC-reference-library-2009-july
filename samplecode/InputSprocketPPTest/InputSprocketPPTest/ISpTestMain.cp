/*	File:		ISpTestMain.cp	Contains:	xxx put contents here xxx	Version:	xxx put version here xxx	Copyright:	© 1998 by Apple Computer, Inc., all rights reserved.	File Ownership:		DRI:				xxx put dri here xxx		Other Contact:		xxx put other contact here xxx		Technology:			xxx put technology here xxx	Writers:		(BWS)	Brent Schorsch		(sjb)	Steve Bollinger	Change History (most recent first):	   <SP9>	10/20/98	BWS		Pause and Quit are now separate needs		 <8>	 7/17/98	BWS		fix for new ISpNeedsStruct		 <7>	 6/18/98	sjb		InputSprocket.h comes from <> place*//*************************************************************************************File:      ISpTestMain.cpCopyright © 1996, 1997, 1998 Apple Computer, Inc., All Rights ReservedYou may incorporate this sample code into your applications withoutrestriction, though the sample code has been provided "AS IS" and theresponsibility for its operation is 100% yours.  However, what you arenot permitted to do is to redistribute the source as "DSC Sample Code"after having made changes. If you're going to re-distribute the source,we require that you make it clear in the source that the code wasdescended from Apple Sample Code, but that you've made changes.*************************************************************************************/#include "ISpTestMain.h"#include <Types.h>#include <InputSprocket.h>#include <LGrowZone.h>#include <LWindow.h>#include <PP_Messages.h>#include <PP_Resources.h>//#include <PPobClasses.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <LEditField.h>#include <Events.h>#include "ISpTestGlobals.h"#include "ISpEventPane.h"#include "ISpElementView.h"#include "ISpLQuitWindow.h"// put declarations for resource ids (ResIDTs) hereconst ResIDT	window_Sample		= 1;	// EXAMPLEconst OSType kCreatorCode		= 'ISPP';const OSType kSubCreatorCode	= '0001';	// we'll use this as versioning for needs list#define	kResourceID_isap						128#define	kResourceID_setl						128Boolean EventProc(EventRecord *inEvent);Boolean EventProc(EventRecord *inEvent){	if (gMyApp == nil) { return false; }		if (inEvent->what == updateEvt)	{		gMyApp->DispatchEvent(*inEvent);	}	return false;}// ===========================================================================//		¥ Main Program// ===========================================================================void main(void){	OSStatus err;		err = ISpGetGlobalElementList(&gElementList);		err = ISpElementList_Extract(	gElementList,									kMaxGlobalElements, 									&gNumElements,									gElementBuffer);								gElement = gElementBuffer[gCurElement];		err = ISpElementList_New(0, 0, &gElementList, 0);		gStatus = err;										// Set Debugging options	SetDebugThrow_(debugAction_Alert);	SetDebugSignal_(debugAction_Alert);	InitializeHeap(3);				// Initialize Memory Manager									// Parameter is number of Master Pointer									//   blocks to allocate										// Initialize standard Toolbox managers	UQDGlobals::InitializeToolbox(&qd);		new LGrowZone(20000);			// Install a GrowZone function to catch									//    low memory situations.	CPPStarterApp	theApp;			// replace this with your App type	gMyApp = &theApp;	theApp.Run();	}// ---------------------------------------------------------------------------//		¥ CPPStarterApp 			// replace this with your App type// ---------------------------------------------------------------------------//	ConstructorCPPStarterApp::CPPStarterApp(){	URegistrar::RegisterClass(ISpElementView::class_ID, (ClassCreatorFunc) ISpElementView::CreateISpElementViewStream);	URegistrar::RegisterClass(ISpEventPane::class_ID, (ClassCreatorFunc) ISpEventPane::CreateISpEventPaneStream);	URegistrar::RegisterClass(LQuitWindow::class_ID, (ClassCreatorFunc) LQuitWindow::CreateLQuitWindowStream);	// Register functions to create core PowerPlant classes	//	RegisterAllPPClasses();}// ---------------------------------------------------------------------------//		¥ ~CPPStarterApp			// replace this with your App type// ---------------------------------------------------------------------------//	Destructor//CPPStarterApp::~CPPStarterApp(){	ISpElement_DisposeVirtual(kNumNeeds, mVirtualElements);}// ---------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------//	This function lets you do something when the application starts up. //	For example, you could issue your own new command, or respond to a system//  oDoc (open document) event.voidCPPStarterApp::StartUp(){	InitNeeds();	LWindow *theWindow;		theWindow = LWindow::CreateWindow(1, this);		theWindow->Show();	theWindow = LWindow::CreateWindow(2, this);		theWindow->Show();}static void EnableDeviceClass(OSType deviceClass, Boolean enable){	enum {		kDeviceList_COUNT = 100	};		OSStatus err;	UInt32 count;	ISpDeviceReference deviceList[kDeviceList_COUNT];		// NOTE: This is not the correct way to handle the list count thing.  We	// should actually call once with NULL for the device list, malloc a list of	// that size, and call again.		err = ISpDevices_ExtractByClass(			deviceClass,			kDeviceList_COUNT,			&count,			deviceList);		if (err)	{		gStatus = err;		return;	}		if (count > kDeviceList_COUNT)	{		count = kDeviceList_COUNT;	}		if (enable)	{		err = ISpDevices_Activate(				count,				deviceList);				if (err)		{			gStatus = err;			return;		}	}	else	{		err = ISpDevices_Deactivate(				count,				deviceList);				if (err)		{			gStatus = err;			return;		}	}			gStatus = err;}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCPPStarterApp::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {			// Deal with command messages (defined in PP_Messages.h).		// Any that you don't handle will be passed to LApplication 					case cmd_New:										// EXAMPLE, create a new window			break;		case cmd_Suspend:			gStatus = ISpSuspend();			break;					case cmd_Resume:			gStatus = ISpResume();			break;				case cmd_NextElement:			gStatus = noErr;			gCurElement = (gCurElement + 1) % gNumElements;			gElement = gElementBuffer[gCurElement];			break;					case cmd_PrevElement:			gStatus = noErr;			gCurElement = (gCurElement + gNumElements - 1) % gNumElements;			gElement = gElementBuffer[gCurElement];			break;		case cmd_AddElement:			gStatus = ISpElementList_AddElements(	gElementList, 													gCurElement,													1,													&gElement);			break;		case cmd_DeleteElement:			gStatus = ISpElementList_RemoveElements(	gElementList, 														1,														&gElement);			break;		case cmd_UIStart:			gStatus = ISpInit(	kNumNeeds,								mNeeds,								mVirtualElements,								kCreatorCode,								kSubCreatorCode,								0,	// flags								kResourceID_setl,								0); // reserved			break;					case cmd_UIConfigure:			gStatus = ISpConfigure(&EventProc);			break;					case cmd_UIStop:			gStatus = ISpStop();			break;			case cmd_ActivateKeyboard:			EnableDeviceClass(kISpDeviceClass_Mouse, false);			EnableDeviceClass(kISpDeviceClass_Keyboard, true);			break;			case cmd_ActiveMouse:			EnableDeviceClass(kISpDeviceClass_Keyboard, false);			EnableDeviceClass(kISpDeviceClass_Mouse, true);			break;					case cmd_DeactiveBoth:			EnableDeviceClass(kISpDeviceClass_Mouse, false);			EnableDeviceClass(kISpDeviceClass_Keyboard, false);			break;					default:			cmdHandled = LApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	This function enables menu commands.//voidCPPStarterApp::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	SInt16		&outMark,	Str255		outName){	switch (inCommand) {			// Return menu item status according to command messages.		// Any that you don't handle will be passed to LApplication		case cmd_New:					// EXAMPLE			outEnabled = false;			break;					case cmd_Suspend:		case cmd_Resume:		case cmd_UIStart:		case cmd_UIConfigure:		case cmd_UIStop:			outEnabled = false;			break;					case cmd_NextElement:		case cmd_PrevElement:		case cmd_AddElement:		case cmd_DeleteElement:		case cmd_ActivateKeyboard:		case cmd_ActiveMouse:		case cmd_DeactiveBoth:			outEnabled = true;			// enable the New command			break;		default:			LApplication::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}void CPPStarterApp::EventResume		(const EventRecord &inMacEvent){	LApplication::EventResume(inMacEvent);	ISpResume();}void CPPStarterApp::EventSuspend	(const EventRecord &inMacEvent){	ISpSuspend();		LApplication::EventSuspend(inMacEvent);}void CPPStarterApp::InitNeeds(void){	ISpNeed tempNeeds[kNumNeeds] =	{		{			"\pForward Thrust",			kIconSuiteID_YThrust,			0,		// player number			0,		// group number			kISpElementKind_Axis,			kISpElementLabel_Axis_YAxis,			0,		// flags			0,		// reserved 1			0,		// reserved 2			0		// reserved 3		},		{			"\pSide Thrust",			kIconSuiteID_XThrust, 			0,		// player number			0,		// group number			kISpElementKind_Axis,			kISpElementLabel_Axis_XAxis,			0,		// flags			0,		// reserved 1			0,		// reserved 2			0		// reserved 3		},		{			"\pVertical Thrust",			kIconSuiteID_ZThrust, 			0,		// player number			0,		// group number			kISpElementKind_Axis,			kISpElementLabel_Axis_ZAxis,			0,		// flags			0,		// reserved 1			0,		// reserved 2			0		// reserved 3		},		{			"\pLook", 			kIconSuiteID_Look, 			0,		// player number			0,		// group number			kISpElementKind_Movement,			kISpElementLabel_None,			0,		// flags			0,		// reserved 1			0,		// reserved 2			0		// reserved 3		},		{			"\pFire", 			kIconSuiteID_Fire, 			0,		// player number			0,		// group number			kISpElementKind_Button,			kISpElementLabel_Btn_Fire,			0,		// flags			0,		// reserved 1			0,		// reserved 2			0		// reserved 3		},		{			"\pStart/Pause", 			kIconSuiteID_Pause, 			0,		// player number			0,		// group number			kISpElementKind_Button,			kISpElementLabel_Btn_StartPause,			kISpNeedFlag_NoMultiConfig,	// flags			0,		// reserved 1			0,		// reserved 2			0		// reserved 3		},		{			"\pQuit", 			kIconSuiteID_Start,			0,		// player number			0,		// group number			kISpElementKind_Button,			kISpElementLabel_Btn_Quit,			kISpNeedFlag_NoMultiConfig,		// flags			0,		// reserved 1			0,		// reserved 2			0		// reserved 3		},	};		int itr;	for(itr = 0; itr < kNumNeeds; itr++)	{		mNeeds[itr] = tempNeeds[itr];	}	OSStatus err;  	err = ISpElement_NewVirtualFromNeeds(kNumNeeds, mNeeds, mVirtualElements, 0);  	  	if (err != noErr) { DebugStr("\pISpElement_NewVirtualFromNeeds failed!"); }}