<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Relocations</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING98></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-97.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-99.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-89.html"><B>Chapter 8 - PEF Structure</B></A> / <A HREF="RTArch-95.html"><B>The Loader Section</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING98-0></A>
<H2><A NAME=MARKER-9-75></A>Relocations</H2>
 <A NAME=MARKER-2-76></A>Relocations (sometimes called fix-ups) are part of a process by which the Code Fragment Manager replaces references to code and data with actual addresses at runtime. The loader section contains information on how to perform these relocations. These relocations apply to any symbols accessed via pointers, such as imported code and data, or a fragment's own pointer-based function calls. <P>
 By the very nature of pointer-based references, you cannot know the actual address that a pointer refers to at build time. Instead, the compiler includes placeholders than can be fixed up by the Code Fragment Manager at preparation time. <P>
 For example, a reference to an imported routine points to a transition vector. Before preparation, the pointer in the calling fragment that points to the transition vector has the value <CODE>0</CODE>. After instantiating the called fragment at preparation time, the actual address of the transition vector becomes known. The Code Fragment Manager then executes a relocation instruction that adds the address of the transition vector to the pointer that references it. The pointer then points to the transition vector in the called fragment's data section. <P>
 Relocation information is stored in PEF containers using a number of specialized instructions and variables, which act much like machine-language instructions for a pseudo-microprocessor. These elements reduce the number of bytes required to store the relocation information and reduce the time required to perform the relocations.<P>
 The pseudo-microprocessor maintains state information in pseudo-registers. For the state to be correct for each instruction, relocation instructions must be executed in order from start to finish for each section.<P>
 <A NAME=MARKER-2-77></A>The relocation instructions make use of the variables shown in <A HREF=#MARKER-9-8>Table 8-4</A>. The initial values are set by the Code Fragment Manager prior to executing the relocations for each section.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><B>Table 8-4  <A NAME=MARKER-9-8></A>Relocation variables</B></CAPTION>
<TH>Name<TH>Description<TR>
<TD><CODE>relocAddress</CODE><TD>Holds an address within the section where the relocations are to be performed. The initial value is the base address of the section that is to be relocated. <TR>
<TD><CODE>importIndex</CODE><TD>Holds a symbol index, which is used to access an imported symbol's address.(The address can then be used for relocation.) The initial value is <CODE>0</CODE>.<TR>
<TD><CODE>sectionC</CODE><TD>Holds the memory address of an instantiated section within the PEF container; this variable is used by relocation instructions that relocate section addresses. The initial value is the memory address of section 0 if that section is present and instantiated. Otherwise the initial <CODE>sectionC</CODE> value is <CODE>0</CODE>.<P>Note that relocation instructions can change the value of <CODE>SectionC</CODE>; this affects subsequent relocation instructions that refer to this variable.<P>The name <CODE>sectionC</CODE> is given for convenience only; use of this variable is not restricted to code sections. <TR>
<TD><CODE>sectionD</CODE><TD>Holds the memory address of an instantiated section within the PEF container; this variable is used by relocation instructions that relocate section addresses. The initial value is the memory address of section 1 if that section is present and instantiated. Otherwise the initial <CODE>sectionD</CODE> value is <CODE>0</CODE>. <P>Note that relocation instructions can change the value of <CODE>sectionD</CODE>; this affects subsequent relocation instructions that refer to this variable.<P>The name <CODE>sectionD</CODE> is given for convenience only; use of this variable is not restricted to data sections. </TABLE>
<P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>sectionC</CODE> and <CODE>sectionD</CODE> variables actually contain the memory address of an instantiated section minus the default address for that section. The default address for a section is contained in the <CODE>defaultAddress</CODE> field of the section header. However, in almost all cases the default address should be <CODE>0</CODE>, so the simplified definition suffices.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The relocation instructions themselves generally accomplish one of the following functions:<P>
<UL>
<LI>assign a value to one of the relocation variables
<LI>add an imported symbol's address to the current location (pointed to by <CODE>relocAddress</CODE>), then increment <CODE>importIndex</CODE> and <CODE>relocAddress</CODE>
<LI>add the <CODE>sectionC</CODE> value to the current location, then increment <CODE>relocAddress</CODE>
<LI>add the <CODE>sectionD</CODE> value to the current location, then increment <CODE>relocAddress</CODE>
<LI>add the <CODE>sectionC</CODE> value to the current location and increment <CODE>relocAddress</CODE>, then add the <CODE>sectionD</CODE> value to the new current location, and increment <CODE>relocAddress </CODE>again<P>
</UL>
<A NAME=HEADING98-14></A>
<H3>The Relocation Headers Table</H3>
 <A NAME=MARKER-2-78></A>If an instantiated section requires one or more relocations, it has an entry in the relocation headers table. A header entry data structure is of fixed size (12 bytes) and has the form shown in <A HREF=#MARKER-9-79>Listing 8-5</A>.<P>
<B>Listing 8-5  <A NAME=MARKER-9-79></A>Relocation header entry data structure</B><P>
<PRE>
struct PEFLoaderRelocationHeader {
   UInt16sectionIndex;   
   UInt16reservedA;      
   UInt32relocCount;     
   UInt32firstRelocOffset; 
};
</PRE>
 The header fields are as follows:<P>
<UL>
<LI>The <CODE>sectionIndex</CODE> field (2 bytes) designates the section number to which this relocation header refers.
<LI>The <CODE>reservedA</CODE> field (2 bytes) is currently reserved and must be set to <CODE>0</CODE>. 
<LI>The <CODE>relocCount</CODE> field (4 bytes) indicates the number of 16-bit relocation blocks for this section.
<LI>The <CODE>firstRelocOffset</CODE> field (4 bytes) indicates the byte offset from the start of the relocations area to the first relocation instruction for this section.<P>
</UL>
 Note that the <CODE>relocCount</CODE> field is the number of 16-bit relocation blocks (that is, one half the total number of bytes of relocation instructions).  Although most relocation instructions are 16 bits long, some are longer, so the number of complete relocation instructions may be less than the <CODE>relocCount</CODE> value.<A NAME=MARKER-2-80></A><P>
<A NAME=HEADING98-24></A>
<H3>The Relocation Area</H3>
 The relocation area consists of a sequence of relocation instructions that describe how to fix up pointers to the fragment's own code and data and to imported symbols during the preparation process. These instructions are grouped by section number, and they are accessed through the relocation headers described earlier. See <A HREF=#MARKER-9-86>"Relocation Instruction Set" (page 8-27)</A> for a detailed description of the relocation instructions.<P>
<A NAME=HEADING98-26></A>
<H3>A Relocation Example</H3>
 <A NAME=MARKER-2-81></A>This section gives an example of how various relocation instructions are used. In this example, a fragment calls the imported routine <CODE>moo</CODE>. At build time, all pointers to <CODE>moo</CODE> in the calling fragment are set to <CODE>0</CODE>, since the compiler or linker cannot know the actual runtime address of the routine. Similarly, in the fragment that contains <CODE>moo</CODE>, the transition vector for <CODE>moo</CODE> contains only offset values for the location of its code and its data world. <A HREF=#MARKER-9-82>Figure 8-9</A> shows the unprepared state for the two fragments. <P>
<B>Figure 8-9  <A NAME=MARKER-9-82></A>Unprepared fragments</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-89.jpg"> <P>
 After instantiating both fragments, the Code Fragment Manager fixes up the calling fragment's pointer by executing instructions as follows (see <A HREF=#MARKER-9-83>Figure 8-10</A>):<P>
<OL>
<LI>Set <CODE>relocAddress</CODE> to point to the data pointer for <CODE>moo</CODE>.
<LI>Set <CODE>importIndex</CODE> to select the imported symbol entry for <CODE>moo</CODE>. 
<LI>Execute a relocation instruction that adds the address of the imported symbol <CODE>moo </CODE>(that is, the address of its transition vector) to the 4 bytes at <CODE>relocAddress</CODE>.<P>
</OL>
<B>Figure 8-10  <A NAME=MARKER-9-83></A>Relocations for the calling fragment</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-90.jpg"> <P>
 After being fixed up, the calling fragment's pointer now points to the transition vector for <CODE>moo</CODE>.<P>
 The pointers for the called fragment are fixed up as follows (see <A HREF=#MARKER-9-84>Figure 8-11</A>):<P>
<OL>
<LI>Set <CODE>relocAddress</CODE> to point to the beginning of the transition vector for <CODE>moo</CODE>.
<LI>Set <CODE>sectionC</CODE> to point to the beginning of the code section containing <CODE>moo</CODE>.
<LI>Set <CODE>sectionD</CODE> to point to the beginning of the called fragment's data section.
<LI>Execute a relocation instruction that adds <CODE>sectionC</CODE> to the contents of the location pointed to by <CODE>relocAddress</CODE>; increments <CODE>relocAddress</CODE> (4 bytes); adds <CODE>sectionD</CODE> to the contents of the location pointed to by the new <CODE>relocAddress</CODE>; and increments <CODE>relocAddress</CODE> again. <P>
</OL>
<B>Figure 8-11  <A NAME=MARKER-9-84></A>Relocations for the called fragment</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-91.jpg"> <P>
 After being fixed up, the transition vector for <CODE>moo</CODE> now contains the actual address of <CODE>moo</CODE> and the base register address for its data world. The routine <CODE>moo</CODE> is now prepared for execution. <A NAME=MARKER-2-85></A><P>
<A NAME=HEADING98-45></A>
<H3><A NAME=MARKER-9-86></A>Relocation Instruction Set</H3>
 <A NAME=MARKER-2-87></A>Relocation instructions are stored in 2-byte relocation blocks<B>.</B> Most instructions take up one block that combines an opcode and related arguments. Instructions that are larger than 2 bytes have an opcode and some of the operands in the first 2-byte block, with other operands in the following 2-byte blocks. The opcode occupies the upper (higher-order) bits of the block that contains it. Relocation instructions can be decoded from the high-order 7 bits of their first block. <A HREF=#MARKER-9-88>Listing 8-6</A> shows the high-order 7 bits for the currently defined relocation opcode values. Binary values indicated by "<CODE>x</CODE>" are "don't care" operands. For example, any combination of the high-order 7 bits that starts with two zero bits (<CODE>00</CODE>) indicates the RelocBySectDWithSkip instruction. <P>
 All currently defined relocation instructions relocate locations as words (that is, 4-byte values).<P>
<B>Listing 8-6  <A NAME=MARKER-9-88></A>Relocation opcode values</B><P>
<PRE>
enum {

   kPEFRelocBySectDWithSkip= 0x00,/* binary: 00xxxxx */

   kPEFRelocBySectC     = 0x20,  /* binary: 0100000 */
   kPEFRelocBySectD     = 0x21,  /* binary: 0100001 */
   kPEFRelocTVector12   = 0x22,  /* binary: 0100010 */
   kPEFRelocTVector8    = 0x23,  /* binary: 0100011 */
   kPEFRelocVTable8     = 0x24,  /* binary: 0100100 */
   kPEFRelocImportRun   = 0x25,  /* binary: 0100101 */

   kPEFRelocSmByImport  = 0x30,  /* binary: 0110000 */
   kPEFRelocSmSetSectC  = 0x31,  /* binary: 0110001 */
   kPEFRelocSmSetSectD  = 0x32,  /* binary: 0110010 */
   kPEFRelocSmBySection = 0x33,  /* binary: 0110011 */

   kPEFRelocIncrPosition= 0x40,  /* binary: 1000xxx */
   kPEFRelocSmRepeat    = 0x48,  /* binary: 1001xxx */

   kPEFRelocSetPosition = 0x50,  /* binary: 101000x */
   kPEFRelocLgByImport  = 0x52,  /* binary: 101001x */
   kPEFRelocLgRepeat    = 0x58,  /* binary: 101100x */
   kPEFRelocLgSetOrBySection= 0x5A,/* binary: 101101x */

};
</PRE>
<DL>
<DT><B>IMPORTANT</B>
<DD>If you wish to create your own relocation instructions, the 3 highest order bits must be set (<CODE>111xxxx</CODE>) to indicate a third-party opcode. All other undocumented opcode values are reserved.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The following sections describe the individual instructions in more detail.<P>
<A NAME=HEADING98-52></A>
<H4>RelocBySectDWithSkip</H4>
 The <CODE>RelocBySectDWithSkip</CODE> instruction (opcode 00) has the structure shown in <A HREF=#MARKER-9-89>Figure 8-12</A>.<P>
<B>Figure 8-12  <A NAME=MARKER-9-89></A>Structure of the <CODE>RelocBySectDWithSkip</CODE> instruction</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-42.jpg"> <P>
 This instruction first increments <CODE>relocAddress</CODE> by skipCount <EM>*</EM> 4 bytes. It then adds the value of <CODE>sectionD</CODE> to the next relocCount contiguous words. After the instruction is executed, <CODE>relocAddress</CODE> points just past the last modified word.<P>
<A NAME=HEADING98-57></A>
<H4>The Relocate Value Group</H4>
 Instructions in the Relocate Value group of opcodes all begin with <CODE>010</CODE> and have the structure shown in <A HREF=#MARKER-9-90>Figure 8-13</A>.<P>
<B>Figure 8-13  Structure of the Relocate Value opcode group<A NAME=MARKER-9-90></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-43.jpg"> <P>
 Instructions in this group add a value to the next runLength items starting at address <CODE>relocAddress</CODE>. The subopcode indicates the type and size of the items to be added as shown in <A HREF=#MARKER-9-9>Table 8-5</A>. After execution, <CODE>relocAddress</CODE> points to just past the last modified item. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The value stored in this instruction is one less than the actual run length (runLength-1).<EM></EM>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-9></A><B>Table 8-5 Subopcodes for the RelocateValue opcode group</B></CAPTION>
<TH>Value<TH>Instruction name<TH>Description<TR>
<TD><CODE>0000</CODE><TD><CODE>RelocBySectC</CODE><TD>Add the value in the variable <CODE>sectionC</CODE> to the next runLength contiguous 4-byte items (words).<TR>
<TD><CODE>0001</CODE><TD><CODE>RelocBySectD</CODE><TD>Add the value in the variable <CODE>sectionD</CODE> to the next runLength contiguous 4-byte items (words).<TR>
<TD><CODE>0010</CODE><TD><CODE>RelocTVector12</CODE><TD>Add values to runLength 12-byte items as follows: add the value in <CODE>sectionC</CODE> to the first word and the value in <CODE>sectionD</CODE> to the second word. No value is added to the third word. <TR>
<TD><CODE>0011</CODE><TD><CODE>RelocTVector8</CODE><TD>Add values to runLength 8-byte items as follows: add the value in <CODE>sectionC</CODE> to the first word and the value in <CODE>sectionD</CODE> to the second word.<TR>
<TD><CODE>0100</CODE><TD><CODE>RelocVTable8</CODE><TD>Add values to runLength 8-byte items as follows: add the value in <CODE>sectionD</CODE> to the first word and do not add any value to the second word. <TR>
<TD><CODE>0101</CODE><TD><CODE>RelocImportRun</CODE><TD>Add the addresses of a sequence of imported symbols to the next runLength contiguous 4-byte items (words). The <CODE>importIndex</CODE> variable is incremented by 1 after every 4-byte relocation (runLength times total).</TABLE>
  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING98-63></A>
<H4><A NAME=MARKER-9-91></A>The Relocate By Index Group</H4>
 Instructions in the Relocate By Index group all begin with <CODE>011</CODE> and have the structure shown in <A HREF=#MARKER-9-92>Figure 8-14</A>.<P>
<B>Figure 8-14  <A NAME=MARKER-9-92></A>Structure of the Relocate By Index opcode group</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-44.jpg"> <P>
 Instructions in this group fix up values according to the subopcode values shown in <A HREF=#MARKER-9-10>Table 8-6</A>.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-10></A><B>Table 8-6 Subopcodes for the Relocate By Index opcode group</B></CAPTION>
<TH>Value<TH>Instruction name<TH>Description<TR>
<TD><CODE>0000</CODE><TD><CODE>RelocSmByImport</CODE><TD>Add the address of the imported symbol whose index is held in index to the word pointed to by <CODE>relocAddress</CODE>. After the addition, <CODE>relocAddress</CODE> points to just past the modified word, and <CODE>importIndex</CODE> is set to index +1.<TR>
<TD><CODE>0001</CODE><TD><CODE>RelocSmSetSectC</CODE><TD>Set the variable <CODE>sectionC</CODE> to the memory address of the instantiated section specified by index.<TR>
<TD><CODE>0010</CODE><TD><CODE>RelocSmSetSectD</CODE><TD>Set the variable <CODE>sectionD</CODE> to the memory address of the instantiated section specified by index.<TR>
<TD><CODE>0011</CODE><TD><CODE>RelocSmBySection</CODE><TD>Add the address of the instantiated section specified by index to the word pointed to by <CODE>relocAddress</CODE>. After execution, <CODE>relocAddress</CODE> points to just past the modified word.</TABLE>
<P>
<A NAME=HEADING98-68></A>
<H4>RelocIncrPosition</H4>
 The <CODE>RelocIncrPosition</CODE> instruction (opcode 1000) has the structure shown in <A HREF=#MARKER-9-93>Figure 8-15</A>.<P>
<B>Figure 8-15  <A NAME=MARKER-9-93></A>Structure of the <CODE>RelocIncrPosition</CODE> instruction</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-45.jpg"> <P>
 This instruction increments <CODE>relocAddress</CODE> by offset bytes. The value of offset is treated as an unsigned value. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The value stored in this instruction is one less than the actual offset (offset-1).<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING98-74></A>
<H4>RelocSmRepeat</H4>
 The <CODE>RelocSmRepeat</CODE> instruction (opcode 1001) has the structure shown in <A HREF=#MARKER-9-94>Figure 8-16</A>.<P>
<B>Figure 8-16  <A NAME=MARKER-9-94></A>Structure of the <CODE>RelocSmRepeat</CODE> instruction</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-46.jpg"> <P>
 This instruction repeats the preceding blockCount relocation blocks repeatCount number of times. Note that you cannot nest this instruction within itself or within the <CODE>RelocLgRepeat</CODE> instruction.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The values of blockCount and repeatCount stored in this instruction are one less than the actual values.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING98-80></A>
<H4>RelocSetPosition</H4>
 The <CODE>RelocSetPosition</CODE> instruction (opcode 101000) takes two relocation blocks (4 bytes) rather than the usual one; the extra bytes allow you to specify an unsigned offset parameter of up to 26 bits.<P>
 The <CODE>RelocSetPosition</CODE> instruction has the structure shown in <A HREF=#MARKER-9-95>Figure 8-17</A>.<P>
<B>Figure 8-17  <A NAME=MARKER-9-95></A>Structure of the <CODE>RelocSetPosition</CODE> instruction</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-47.jpg"> <P>
 This instruction sets <CODE>relocAddress</CODE> to the address of the section offset offset.<P>
<A NAME=HEADING98-86></A>
<H4>RelocLgByImport</H4>
 The <CODE>RelocLgByImport</CODE> instruction (opcode 101001) takes two relocation blocks (4 bytes); the extra bytes allow you to specify an unsigned index parameter of up to 26 bits.<P>
 The <CODE>RelocLgByImport</CODE> instruction has the structure shown in <A HREF=#MARKER-9-96>Figure 8-18</A>.<P>
<B>Figure 8-18  <A NAME=MARKER-9-96></A>Structure of the <CODE>RelocLgByImport</CODE> instruction</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-93.jpg"> <P>
 This instruction adds the address of the imported symbol whose index is held in index to the word pointed to by <CODE>relocAddress</CODE>. After the addition, <CODE>relocAddress</CODE> points to just past the modified word, and <CODE>importIndex</CODE> is set to index +1.<P>
<A NAME=HEADING98-92></A>
<H4>RelocLgRepeat</H4>
 The <CODE>RelocLgRepeat</CODE> instruction (opcode 101100) takes two relocation blocks and has the structure shown in <A HREF=#MARKER-9-97>Figure 8-19</A>.<P>
<B>Figure 8-19  <A NAME=MARKER-9-97></A>Structure of the <CODE>RelocLgRepeat</CODE> instruction</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-48.jpg"> <P>
 This instruction repeats the preceding blockCount relocation blocks repeatCount number of times. The <CODE>RelocLgRepeat</CODE> instruction is very similar to the <CODE>relocSmRepeat</CODE> (opcode 1001) instruction, but it allows for larger repeat counts.<P>
 You cannot nest this instruction, either within itself or within the <CODE>relocSmRepeat</CODE> instruction.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Note that the repeat value stored in this instruction is the actual value (repeatCount), while for the <CODE>relocSmRepeat</CODE> instruction the value stored is repeatCount-1. The block count value stored is blockCount-1 for both repeat instructions.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING98-99></A>
<H4>RelocLgSetOrBySection</H4>
 The <CODE>RelocLgSetOrBySection</CODE> instruction (opcode 101101) takes two relocation blocks and has the form shown in <A HREF=#MARKER-9-98>Figure 8-20</A>.<P>
<B>Figure 8-20  <A NAME=MARKER-9-98></A>Structure of the <CODE>RelocLgSetOrBySection</CODE> instruction</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-86.jpg"> <P>
 This instruction performs instructions identical to those shown in <A HREF=#MARKER-9-91>"The Relocate By Index Group" (page 8-31)</A>, but with a larger (up to 22-bit, unsigned) section number. The action specified depends on the value of subopcode as shown in <A HREF=#MARKER-9-11>Table 8-7</A>.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-11></A><B>Table 8-7 Subopcodes for the <CODE>RelocLgSetOrBySection</CODE> instruction</B></CAPTION>
<TH>Subopcode<TH>Action<TR>
<TD>0000<TD>Add the address of the instantiated section specified by index to the word at <CODE>relocAddress</CODE>. After the addition, <CODE>relocAddress</CODE> points to just past the modified word. (Same as <CODE>RelocSmBySection</CODE>.)<TR>
<TD>0001<TD>Set the variable <CODE>sectionC</CODE> to the memory address of the instantiated section specified by index. (Same as <CODE>RelocSmSetSectC</CODE>.)<TR>
<TD>0010<TD>Set the variable <CODE>sectionD</CODE> to the memory address of the instantiated section specified by index. (Same as <CODE>RelocSmSetSectD</CODE>.) <A NAME=MARKER-2-12></A><A NAME=MARKER-2-13></A></TABLE>
<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="RTArch-97.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-99.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
