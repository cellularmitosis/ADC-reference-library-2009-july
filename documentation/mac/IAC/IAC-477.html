<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the High-Level Interface(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING477></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-476.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-478.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-469.html"><B>Chapter 12 - Data Access Manager</B></A> / <A HREF="IAC-474.html"><B>Using the Data Access Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING477-0></A>
<H2><A NAME=MARKER-9-108></A><A NAME=MARKER-21-109></A>Using the High-Level Interface</H2>
 <A NAME=MARKER-2-110></A>Use the high-level interface to the Data Access Manager if you want to use a query document to do the work of communicating with a data source. You can use the high-level interface to open a query document, execute the query definition function in the query document, establish communication (initiate a session) with a data server, send the query to the data server, execute the query, retrieve any data requested by the query, and convert the retrieved data to text. Although two or three high-level routines accomplish most of these tasks, you may need to call a few low-level routines as well to control a session with a data server. <P>
 Applications that implement this type of data access must provide user control and feedback as described in <A HREF=IAC-476.html#MARKER-9-98>"General Guidelines for the User Interface" on page 12-13</A>. In addition, you should include an Open Query command in the File menu. The Open Query command is equivalent to the Open (file) command in meaning. When the user chooses this command, display an open file dialog box filtered to show only query documents (file type <CODE>'qery'</CODE>). The user can then select the desired query document. The query document contains the query to be sent to the data source. Depending on the type of query, the data source could receive information, send back information, report the status of the data source, or perform some other task<A NAME=MARKER-2-111></A><A NAME=MARKER-2-112></A>. <P>
 <A NAME=MARKER-2-113></A><A HREF=#MARKER-9-117>Figure 12-4</A> is a flowchart of a typical session using the high-level interface. <BR>As <A HREF=#MARKER-9-117>Figure 12-4</A> illustrates, you must follow this procedure to use the high-level interface:<P>
<OL>
<LI>Call the <CODE>InitDBPack</CODE> function to initialize the Data Access Manager.
<LI>Select the query document that you want to use and determine the resource ID of the <CODE>'qrsc'</CODE> resource in that query document. You can use any method you like to select the query document. One possibility is to use the <CODE>StandardGetFile</CODE> procedure to let the user select the query document. A query document should contain only one <CODE>'qrsc'</CODE> resource; you can then use the Resource Manager to determine the resource ID of the <CODE>'qrsc'</CODE> resource in the document that the user selected. For further information, see the description of the <CODE>StandardGetFile</CODE> procedure in the chapter "Standard File Package" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I> and the chapter "Resource Manager" in <I>Inside Macintosh: More Macintosh Toolbox.</I>
<LI>Call the <CODE>DBGetNewQuery</CODE> function. The <CODE>DBGetNewQuery</CODE> function creates in memory a data structure called a <I>query record</I> from the <CODE>'qrsc'</CODE> resource that you specify. 
<LI>Call the <CODE>DBStartQuery</CODE> function specifying the handle to the query record that you created with the <CODE>DBGetNewQuery</CODE> function (step 3). <P>
You should also provide the <CODE>DBStartQuery</CODE> function with a handle to your status routine. A <A NAME=MARKER-6-114></A><B>status routine</B> is a routine that you provide to update windows, check the results of the low-level calls made by the <CODE>DBStartQuery</CODE> and <CODE>DBGetQueryResults</CODE> functions, and cancel execution of these functions when you consider it appropriate to do so. <A NAME=MARKER-0-115></A><A NAME=MARKER-2-116></A><P>
</OL>
<B>Figure 12-4  <A NAME=MARKER-9-117></A><A NAME=MARKER-21-118></A>A flowchart of a session using the high-level interface</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DA-L-07.jpg"><P>
The <CODE>DBStartQuery</CODE> function calls the query definition function (if any) referred to by the query record. The query definition function can prompt the user for information and modify the query record. <P>
<A NAME=MARKER-2-119></A>After the query definition function has completed execution, the <CODE>DBStartQuery</CODE> function calls your status routine so that you can update your windows if necessary. The <CODE>DBStartQuery</CODE> function then checks whether communication has been established with the data server. If not, it calls your status routine so that you can display a status dialog box and then calls the <CODE>DBInit</CODE> function to establish communication (initiate a session) with the data server. The <CODE>DBStartQuery</CODE> function obtains the values it needs for the <CODE>DBInit</CODE> function parameters from the query record. When the <CODE>DBInit</CODE> function completes execution, the <CODE>DBStartQuery</CODE> function calls your status routine again. <P>
<A NAME=MARKER-2-120></A>The <CODE>DBInit</CODE> function returns an identification number, called a <A NAME=MARKER-6-121></A><B>session ID.</B> This session ID is unique; no other current session, for any database extension, has the same session ID. You must specify the session ID any time you want to send data to or retrieve data from this session. If you prefer, you can use the <CODE>DBInit</CODE> function to establish communication before you call the <CODE>DBStartQuery</CODE> function. In that case, you must specify the session ID as an input parameter to the <CODE>DBStartQuery</CODE> function. See <A HREF=IAC-479.html#MARKER-9-141>"Using the Low-Level Interface" beginning on page 12-28</A> for more information on using the <CODE>DBInit</CODE> function. <A NAME=MARKER-2-116></A><P>
Once communication has been established, the <CODE>DBStartQuery</CODE> function calls the <CODE>DBSend</CODE> function to send the data server the query specified by the query record. When the <CODE>DBSend</CODE> function has completed execution, the <CODE>DBStartQuery</CODE> function calls your status routine. Finally, the <CODE>DBStartQuery</CODE> function uses the <CODE>DBExec</CODE> function to execute the query. The <CODE>DBStartQuery</CODE> function calls your status routine after the <CODE>DBExec</CODE> function has completed execution (that is, the query has started executing and the <CODE>DBExec</CODE> function has returned control to the <CODE>DBStartQuery</CODE> function) and again just before the <CODE>DBStartQuery</CODE> function completes execution. <P>
<OL>
<LI>If you requested data and want to know when the data is available, but do not want to retrieve the data immediately, you can call the <CODE>DBState</CODE> function. This function tells you when the data server has finished executing the query, but it does not retrieve the data. If you requested data and want to retrieve it as soon as it is available, you do not have to call the <CODE>DBState</CODE> function; go to step 6 instead.<P>
If you did not request data, you can use the <CODE>DBState</CODE> function to determine the status of the query. When the data server has finished executing the query, skip to step 8.
<LI>Call the <CODE>DBGetQueryResults</CODE> function. If the query has not finished executing, this function returns the <CODE>rcDBExec</CODE> result code. If the query has finished executing, the <CODE>DBGetQueryResults</CODE> function calls the <CODE>DBGetItem</CODE> function repeatedly until the data server has returned all of the data available. <P>
The <CODE>DBGetQueryResults</CODE> function puts the returned data into a record that contains handles to arrays that contain the data, the type of data in each column, and the length of each data item. The Data Access Manager allocates the memory for this data in the application heap.<P>
The <CODE>DBGetQueryResults</CODE> function calls your status routine after it retrieves each data item. You can use this opportunity to display the data item for the user and to give the user the opportunity to cancel execution of the function. The <CODE>DBGetQueryResults</CODE> function also calls your status routine just before completing execution, so that you can dispose of any memory allocated by the status routine, remove any dialog box that you displayed, and update your windows if necessary.<P>
To convert the returned data to text, go to the next step. If you do not want to convert the returned data to text, skip to step 9.
<LI>Call the <CODE>DBResultsToText</CODE> function. This function calls a result handler function for each data type. The result handler converts the data to text, places it in a buffer, and returns a handle to the buffer. Some result handlers are provided with the Data Access Manager; you can provide as many with your application as you wish. Result handlers are discussed in <A HREF=IAC-481.html#MARKER-9-189>"Converting Query Results to Text" beginning on page 12-43</A>.
<LI>If you are finished using the query record, call the <CODE>DBDisposeQuery</CODE> function to dispose of the query record and free all the memory associated with the query record. If you want to reuse the same query, return to step 5. You should close the query document when you are finished using it.<P>
If you want to use a new query document, return to step 3.
<LI><A NAME=MARKER-2-100></A>When you are finished using the data source, you must use the <CODE>DBEnd</CODE> function to terminate the session. You must call the <CODE>DBEnd</CODE> function after the <CODE>DBInit</CODE> function has returned a nonzero session ID, even if it also returned an error.<A NAME=MARKER-2-124></A><P>
</OL>
 <A HREF=#MARKER-9-125>Listing 12-1</A> illustrates the use of the high-level interface. This code initiates a session with a remote database, lets the user select a query document to execute, opens the selected file, finds a <CODE>'qsrc'</CODE> resource, and creates a query record. Next, it executes the query, checks the status of the remote database server, retrieves the data when it's available, and converts this data to text. When the query has finished executing, the code disposes of the query record, ends the session, and closes the user-selected query document. In general, there's no reason why there can't be multiple sessions open at once. You can identify each session by its session ID. <A HREF=#MARKER-9-125>Listing 12-1</A> shows just one session.<P>
 <A HREF=#MARKER-9-125>Listing 12-1</A> assumes that you are using a database extension that supports asynchronous execution of Data Access Manager routines. This listing shows just one possible approach to sending a query and retrieving data asynchronously. <P>
<B>Listing 12-1  <A NAME=MARKER-9-125></A><A NAME=MARKER-21-126></A>Using the high-level interface</B><P>
<PRE>
PROCEDURE MyHiLevel(VAR rr: ResultsRecord; myTextHdl: Handle;
                  VAR thisSession: LongInt; VAR sessErr: OSErr);
TYPE
   {define a record to include space for the current value in }
   { A5 so a completion routine can find it}
   CRRec = RECORD
      QPB: DBAsyncParamBlockRec;       {the parameter block}
      appsA5: LongInt;                 {append A5 to the }
                                       { parameter block}
   END;
   CRRecPtr = ^CRRec;
VAR
   StartPB, GetQRPB:                            CRRec;
   SFR:                                         StandardFileReply;
   packErr, startQErr, getQErr, disposeQErr:    OSErr;
   getnewQErr, gStartQErr, gGetQRErr:           OSErr;
   endErr, fsopenErr, fscloseErr, resultsErr:   OSErr;
   gStart, gQueryResults:                       Boolean;
   qrscHandle:                                  Handle;
   rsrcID:                                      Integer;
   rsrcType:                                    ResType;
   rsrcName:                                    Str255;
   myQHandle:                                   QueryHandle;
   savedResFile:                                Integer;
   typeList:                                    SFTypeList;
   fsRefNum:                                    Integer;

FUNCTION GetQPB: CRRecPtr;
   INLINE $2E88;                 {MOVE.L  A0,(SP)}

BEGIN
   gStart := FALSE;
   gQueryResults := FALSE;
   sessErr := noErr;             {assume everything went fine}
   packErr := InitDBPack;        {initialize the Data Access Mgr}
   {display a dialog box to let the user pick a query document}
   typeList[0] := 'qery';
   StandardGetFile(NIL, 1, typeList, SFR);
   IF SFR.sfGood = TRUE THEN
      fsopenErr := FSpOpenRF(SFR.sfFile, fsCurPerm, fsRefNum);
   IF (fsopenErr &lt;&gt; noErr) OR (SFR.sfGood = FALSE) THEN
   BEGIN
      sessErr := fsopenErrOrUserCanceled;
      EXIT(MyHiLevel);
   END;
   savedResFile := CurResFile;   {save current resource file}
   UseResFile(fsRefNum);         {get query info from here}
   {a query document should have only one 'qrsc' resource}
   qrscHandle := Get1IndResource('qrsc', 1);
   IF ResError &lt;&gt; noErr THEN
   BEGIN
      sessErr := ResError;
      EXIT(MyHiLevel);
   END;
   {get the resource ID of the 'qrsc' resource}
   GetResInfo(qrscHandle, rsrcID, rsrcType, rsrcName);
   {create a query record using the resource ID}
   getnewQErr := DBGetNewQuery(rsrcID, myQHandle);
   IF getnewQErr &lt;&gt; noErr THEN
   BEGIN
      sessErr := getnewQErr;
      endErr := DBEnd(thisSession, NIL);
      EXIT(MyHiLevel);
   END;
   StartPB.QPB.completionProc := @MyStartCompRoutine;
   StartPB.appsA5 := SetCurrentA5;     {save this for the }
                                       { completion routine}
   {MyStartStatus is a status routine that handles messages sent }
   { by the DBStartQuery function when it calls a low-level }
   { function}
   startQErr := DBStartQuery(thisSession, myQHandle,
                              @MyStartStatus, @StartPB);
   IF startQErr &lt;&gt; noErr THEN
   BEGIN
      sessErr := startQErr;
      IF thisSession &lt;&gt; 0 THEN 
         endErr := DBEnd(thisSession, NIL);
      EXIT(MyHiLevel);
   END;
   WHILE NOT gStart DO  {while waiting for gStart to go TRUE, }
   BEGIN                { MyGoDoSomething calls WaitNextEvent }
      MyGoDoSomething;  { to give other routines a chance to run}
   END;     {while}
   {the DBStartQuery call has completed}
   IF gStartQErr &lt;&gt; noErr THEN
   BEGIN
      sessErr := gStartQErr;
      IF thisSession &lt;&gt; 0 THEN 
         endErr := DBEnd(thisSession, NIL);
      EXIT(MyHiLevel);
   END;
   GetQRPB.QPB.completionProc := @MyGetQRCompRoutine;
   GetQRPB.appsA5 := SetCurrentA5;        {save this for the }
                                          { completion routine}
   {MyGetQRStatus is a status routine that handles messages sent }
   { by the DBGetQueryResults function when it calls a low-level }
   { function.}
   getQErr := DBGetQueryResults(thisSession, rr, kDBWaitForever,
                                 @MyGetQRStatus, @GetQRPB);
   IF getQErr &lt;&gt; noErr THEN
   BEGIN
      sessErr := getQErr;
      endErr := DBEnd(thisSession, NIL);
      EXIT(MyHiLevel);
   END;
   WHILE NOT gQueryResults DO
   BEGIN
      MyGoDoSomething;
   END; {while}
   {The DBGetQueryResults call has completed. Assuming the call }
   { completed successfully, you may want to convert the }
   { retrieved data to text, return memory you have borrowed, }
   { and end the session.}
   IF gGetQRErr &lt;&gt; noErr THEN
   BEGIN
      sessErr := gGetQRErr;
      endErr := DBEnd(thisSession, NIL);
      EXIT(MyHiLevel);
   END;
   {the data has been retrieved; convert it to text}
   resultsErr := DBResultsToText(rr, myTextHdl);
   {The current query is finished.  You can elect to execute }
   { the next 'qrsc' resource of the file, or select another }
   { query document.  This example just returns to the caller.}
   disposeQErr := DBDisposeQuery(myQHandle);
   UseResFile(savedResFile);{restore current resource file}
   fscloseErr := FSClose(fsRefNum); {close the query document}
   IF fscloseErr &lt;&gt; noErr THEN 
      DoError(fscloseErr);
   endErr := DBEnd(thisSession, NIL);
   IF endErr &lt;&gt; noErr THEN 
      DoError(endErr);
   END;
</PRE>
 <A HREF=#MARKER-9-127>Listing 12-2</A> shows the completion routines <CODE>MyStartCompRoutine</CODE> and <CODE>MyGetQRCompRoutine</CODE> used in <A HREF=#MARKER-9-125>Listing 12-1</A>.<P>
<B>Listing 12-2  <A NAME=MARKER-9-127></A>Two completion routines</B><P>
<PRE>
PROCEDURE MyStartCompRoutine(aCRRecPtr: CRRecPtr);
VAR
   curA5:   LongInt;
BEGIN
   aCRRecPtr := GetQPB;                {get the param block}
   curA5 := SetA5(aCRRecPtr^.appsA5);  {set A5 to the app's A5}
   gStart := TRUE;                     {query has been started}
   gStartQErr := aCRRecPtr^.QPB.result;{send back result code}
   {do whatever else you want to do}
   curA5 := SetA5(curA5);{restore original A5}
END;  {MyStartCompRoutine}
PROCEDURE MyGetQRCompRoutine(aCRRecPtr: CRRecPtr);
VAR
   curA5:   LongInt;
BEGIN
   aCRRecPtr := GetQPB;                {get the param block}
   curA5 := SetA5(aCRRecPtr^.appsA5);  {set A5 to the app's A5}
   gQueryResults := TRUE;{query results are complete}
   gGetQRErr := aCRRecPtr^.QPB.result; {send back the result code}
   {do whatever else you want to do}
   curA5 := SetA5(curA5);              {restore original A5}
END;  {MyGetQRCompRoutine}
</PRE>
 The next section provides information about status routines.<A NAME=MARKER-2-128></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-476.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-478.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
