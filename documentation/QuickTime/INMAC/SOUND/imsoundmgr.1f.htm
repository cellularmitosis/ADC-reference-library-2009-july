<!-- legacy work start --><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"        "http://www.w3.org/TR/html4/loose.dtd"><!-- legacy work end --><HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><TITLE> Using Callback Procedures (deprecated)</title><!-- legacy work start -->        <META NAME="Generator" CONTENT="manual">        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">        <META NAME="IndexTitle" CONTENT="Sound Input Manager (Not Recommended)">        <meta name="xcode-display" content="render">        <LINK REL="stylesheet" TYPE="text/css" HREF="../../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->        <script type="text/javascript" language="JavaScript" src="../../../Resources/JavaScript/page.js"></script><!-- legacy work end --></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><!-- QTnavbar start --><P><I>Inside Macintosh: Sound</I><P>| <A target="doc" HREF="imsoundmgr.1e.htm">Previous</A> | <A target="doc" HREF="imsoundmgr.1.htm">Chapter contents</A> | <A target="doc" HREF="imsoundmgr.htm">Chapter top</A> | <A target="doc" HREF="imsoundmgr.1e.htm">Section top</A> | <A target="doc" HREF="imsoundmgr.20.htm">Next</a> | <!-- QTnavbar end --><!-- legacy work start --><script type="text/javascript"> placeWatermark()</script><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox" style="position: relative;"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b><i>Sound Input Manager</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="http://developer.apple.com/referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div><!-- legacy work end --><H1 CLASS="H3.Heading3"><A NAME="pgfId=2245"> </A><A NAME="40692"> </A>Using Callback Procedures</H1><P CLASS="T0.Text0"><A NAME="pgfId=2369"> </A>This section shows how you can use callback procedures to play one sound asynchronously at a given time. <A target="doc" HREF="imsoundmgr.23.htm#22498" CLASS="XRef">&quot;Managing Multiple Sound Channels&quot;</A> expands the techniques in this section to show how you can play several asynchronous sounds simultaneously.</P><P CLASS="T1.Text1"><A NAME="pgfId=2137"> </A>The <TT CLASS="cv">SndNewChannel</TT> function allows you to associate a callback procedure with a sound channel. For example, the following code opens a new sound channel for which memory has already been allocated and associates it with the callback procedure <TT CLASS="cv">MyCallBack</TT>:</P><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=9867"> </A>myErr := SndNewChannel(gSndChan, sampledSynth, initMono, @MyCallback);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=2139"> </A>After filling a channel created by <TT CLASS="cv">SndNewChannel</TT> with various commands to create sound, you can then issue a <TT CLASS="cv">callBackCmd</TT> command to the channel. When the Sound Manager encounters a <TT CLASS="cv">callBackCmd</TT> command, it executes your callback procedure. Thus, by placing the <TT CLASS="cv">callBackCmd</TT> command last in a channel, you can ensure that the Sound Manager executes your callback procedure only after it has processed all of the channel's other sound commands.</P><P CLASS="Note"><A NAME="pgfId=2140"> </A>Be sure to issue <TT CLASS="cv">callBackCmd</TT> commands with the <TT CLASS="cv">SndDoCommand</TT> function and not the <TT CLASS="cv">SndDoImmediate</TT> function. If you issue a <TT CLASS="cv">callBackCmd</TT> command with <TT CLASS="cv">SndDoImmediate</TT>, your callback procedure might be called before other sound commands you have issued finish executing. </P><P CLASS="T1.Text1"><A NAME="pgfId=2141"> </A>A callback procedure has the following syntax:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=9871"> </A>PROCEDURE MyCallBack (chan: SndChannelPtr; cmd: SndCommand);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=2143"> </A>Because the callback procedure executes at interrupt time, it cannot access its application global variables unless the application's A5 world is set correctly. (For more information on the A5 world, see the chapter &quot;Memory Management Utilities&quot; in <I CLASS="italics">Inside Macintosh: Memory</I>.) When called, the callback procedure is passed two parameters: a pointer to the sound channel that received the <TT CLASS="cv">callBackCmd</TT> command and the sound command that caused the callback procedure to be called. Applications can use <TT CLASS="cv">param1</TT> or <TT CLASS="cv">param2</TT> of the sound command as flags to pass information or instructions to the callback procedure. If your callback procedure is to use your application's global data storage, it must first reset A5 to your application's A5 and then restore it on exit. For example, <A target="doc" HREF="imsoundmgr.1f.htm#13623" CLASS="XRef">Listing 1-28</A> illustrates how to set up a <TT CLASS="cv">callBackCmd</TT> command that contains the required A5 information in the <TT CLASS="cv">param2</TT> field. The <TT CLASS="cv">MyInstallCallback</TT> function defined there must be called at a time when your application's A5 world is known to&nbsp;be&nbsp;valid.<A NAME="marker=357"> </A></P><P CLASS="L.Listing"><A NAME="pgfId=2144"> </A>Listing&nbsp;28 <A NAME="13623"> </A>Issuing a callback command</P><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=9875"> </A>FUNCTION MyInstallCallback (mySndChan: SndChannelPtr): OSErr;<BR>CONST<BR>&nbsp;&nbsp;&nbsp;&nbsp;kWaitIfFull = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{wait for room in queue}<BR>VAR<BR>&nbsp;&nbsp;&nbsp;&nbsp;mySndCmd:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SndCommand;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{a sound command}<BR>BEGIN<BR>&nbsp;&nbsp;&nbsp;&nbsp;WITH mySndCmd DO<BR>&nbsp;&nbsp;&nbsp;&nbsp;BEGIN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd := callBackCmd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{install the callback command}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param1 := kSoundComplete;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{last command for this channel}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param2 := SetCurrentA5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pass the callback the A5}<BR>&nbsp;&nbsp;&nbsp;&nbsp;END;<BR>&nbsp;&nbsp;&nbsp;&nbsp;MyInstallCallback := SndDoCommand(mySndChan, mySndCmd, kWaitIfFull);<BR>END;<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=2145"> </A><A NAME="marker=9877"> </A>In this function, <TT CLASS="cv">kSoundComplete</TT> is an application-defined constant that indicates that the requested sound has finished playing. You could define it like this:</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=9881"> </A>CONST<BR>&nbsp;&nbsp;&nbsp;&nbsp;kSoundComplete = 1;{sound is done playing}<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=2148"> </A>Because <TT CLASS="cv">param2</TT> of a sound command is a long integer, <A target="doc" HREF="imsoundmgr.1f.htm#13623" CLASS="XRef">Listing 1-28</A> uses it to pass the application's A5 to the callback procedure. That allows the callback procedure to gain access to the application's A5 world.</P><P CLASS="Note"><A NAME="pgfId=4621"> </A>You can also pass information to a callback routine in the <TT CLASS="cv">userInfo</TT> field of the sound channel. </P><P CLASS="T1.Text1"><A NAME="pgfId=2149"> </A>The sample callback procedure defined in <A target="doc" HREF="imsoundmgr.1f.htm#26695" CLASS="XRef">Listing 1-29</A> can thus set A5 to access the application's global variables.</P><P CLASS="L.Listing"><A NAME="pgfId=2150"> </A>Listing&nbsp;29 -- <A NAME="26695"> </A>Defining a callback procedure</P><CODE CLASS="Cv.Code"><A NAME="pgfId=9885"> </A>PROCEDURE MyCallback (theChan: SndChannelPtr; theCmd: SndCommand);<BR>VAR<BR>&nbsp;&nbsp;&nbsp;&nbsp;myA5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LongInt;<BR>BEGIN<BR>&nbsp;&nbsp;&nbsp;&nbsp;IF theCmd.param1 = kSoundComplete THEN<BR>&nbsp;&nbsp;&nbsp;&nbsp;BEGIN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myA5 := SetA5(theCmd.param2);&nbsp;&nbsp;&nbsp;&nbsp;{set my A5}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gCallbackPerformed := TRUE;&nbsp;&nbsp;&nbsp;&nbsp;{set a global flag}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myA5 := SetA5(myA5);&nbsp;&nbsp;&nbsp;&nbsp;{restore the original A5}<BR>&nbsp;&nbsp;&nbsp;&nbsp;END;<BR>END;</CODE><BR><P><B>WARNING</B><BR>Callback procedures are called at interrupt time and therefore must not attempt to allocate, move, or dispose of memory, dereference an unlocked handle, or call other routines that do so. Also, assembly-language programmers should note that a callback procedure is a Pascal procedure and must preserve all registers other than A0�A1 and D0�D2.</P><P>Callback procedures cannot dispose of channels themselves, because that involves disposing of memory. To circumvent this restriction, the callback procedure in Listing 2-29 simply sets the value of a global flag variable that your application defines. Then, once each time through its main event loop, your application must call a routine that checks to see if the flag is set. If the flag is set, the routine should dispose of the channel, release any other memory allocated specifically for use in the channel, and reset the flag variable. Listing 2-30 defines such a routine. Your application should call it once each time through its main event loop.</P><P>Listing 30 -- Checking whether a callback procedure has executed</P><CODE>PROCEDURE MyCheckSndChan;CONST<BR>&nbsp;&nbsp;&nbsp;&nbsp;kQuietNow = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;{need to quiet channel?}<BR>VAR<BR>&nbsp;&nbsp;&nbsp;&nbsp;myErr:&nbsp;&nbsp;&nbsp;&nbsp;OSErr;<BR>BEGIN<BR>&nbsp;&nbsp;&nbsp;&nbsp;IF gCallbackPerformed THEN&nbsp;&nbsp;&nbsp;&nbsp;{check global flag}<BR>&nbsp;&nbsp;&nbsp;&nbsp;BEGIN&nbsp;&nbsp;&nbsp;&nbsp;{channel is done}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gCallbackPerformed := FALSE;&nbsp;&nbsp;&nbsp;&nbsp;{reset global flag}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF gSndChan^.userInfo <> 0 THEN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BEGIN&nbsp;&nbsp;&nbsp;&nbsp;{release sound data}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HUnlock(Handle(gSndChan^.userInfo));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPurge(Handle(gSndChan^.userInfo));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr := MyDisposeSndChannel(gSndChan, kQuietNow);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gSndChan := NIL;&nbsp;&nbsp;&nbsp;&nbsp;{set pointer to NIL}<BR>&nbsp;&nbsp;&nbsp;&nbsp;END;<BR>END;</CODE><BR><P>The <CODE>MyCheckSndChan</CODE> procedure defined in Listing 2-30 checks the <CODE>userInfo</CODE> field of the sound channel to see if it contains the address of a handle. Thus, if you would like the <CODE>MyCheckSndChan</CODE> procedure to release memory associated with a sound handle, you need only put the address of the handle in the <TT>userInfo</TT> field of the sound channel. (If you do not want the <TT>MyCheckSndChan</TT> procedure to release memory associated with a handle, then you should set the userInfo field to 0 when you allocate the channel. The <TT>MyCreateSndChannel</TT> function defined in Listing 2-1 automatically sets this field to 0.) After releasing the memory associated with the sound handle, the <TT>MyCheckSndChan</TT> procedure calls the <TT>MyDisposeSndChannel</TT> function (defined in Listing 2-3) to release the memory occupied by both the sound channel and the sound channel record.</P><P>To ensure that the <CODE>MyCheckSndChan</CODE> procedure defined in Listing 2-30 does not attempt to dispose a channel before you have created one, you should initialize the <TT>gCallbackPerformed</TT> variable to <TT>FALSE</TT>. Also, you should initialize the <TT>gSndChan</TT> variable to <TT>NIL</TT>, so that other parts of your application can check to see if a sound is playing simply by checking this variable. For example, if your application must play a sound but another sound is currently playing, you might ensure that the application gives priority to the newer sound by stopping the old one. Listing 2-31 defines a procedure that stops the sound that is playing.</P><P>Listing 31 -- Stopping a sound that is playing asynchronously</P><CODE>PROCEDURE MyStopPlaying;<BR>BEGIN<BR>&nbsp;&nbsp;&nbsp;&nbsp;IF gSndChan <> NIL THEN&nbsp;&nbsp;&nbsp;&nbsp; {is sound really playing?}<BR>&nbsp;&nbsp;&nbsp;&nbsp;gCallbackPerformed := TRUE; {set global flag}<BR>&nbsp;&nbsp;&nbsp;&nbsp;MyCheckSndChan;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {call routine to do disposing}<BR>END;</CODE><BR><P>Once you have defined a callback procedure, a routine that installs the callback procedure, a routine that checks the status of the callback procedure, and a routine that can stop sound play, you need only allocate a sound channel, call the SndPlay function, and install your callback procedure to start an asynchronous sound play. Listing 2-32 defines a procedure that starts an asynchronous play.</P><P>Listing 32 -- Starting an asynchronous sound play</P><CODE>PROCEDURE MyStartPlaying (mySndID: Integer);<BR>CONST<BR>&nbsp;&nbsp;&nbsp;&nbsp;kAsync = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;{play is asynchronous}<BR>VAR<BR>&nbsp;&nbsp;&nbsp;&nbsp;mySndHandle:&nbsp;&nbsp;&nbsp;&nbsp;Handle;&nbsp;&nbsp;&nbsp;&nbsp;{handle to an 'snd ' resource}<BR>&nbsp;&nbsp;&nbsp;&nbsp;myErr:&nbsp;&nbsp;&nbsp;&nbsp;OSErr;<BR>BEGIN<BR>&nbsp;&nbsp;&nbsp;&nbsp;IF gSndChan <> NIL THEN&nbsp;&nbsp;&nbsp;&nbsp;{check if channel is active}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyStopPlaying;<BR>&nbsp;&nbsp;&nbsp;&nbsp;gSndChan := MyCreateSndChannel(0, 0, @MyCallbackProc, stdQLength);<BR>&nbsp;&nbsp;&nbsp;&nbsp;mySndHandle := GetResource('snd ', mySndID);<BR>&nbsp;&nbsp;&nbsp;&nbsp;IF (mySndHandle <> NIL) AND (gSndChan <> NIL) THEN<BR>&nbsp;&nbsp;&nbsp;&nbsp;BEGIN&nbsp;&nbsp;&nbsp;&nbsp;{start sound playing}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DetachResource(mySndHandle);&nbsp;&nbsp;&nbsp;&nbsp;{detach resource from file}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{remember to release sound handle}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gSndChan^.userInfo := LongInt(mySndHandle);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLock(mySndHandle);&nbsp;&nbsp;&nbsp;&nbsp;{lock the resource data}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr := SndPlay(gSndChan, mySndHandle, kAsync);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF myErr = noErr THEN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr := MyInstallCallback(gSndChan);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF myErr <> noErr THEN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(myErr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;END;<BR>END;</CODE><BR><P>The <TT>MyStartPlaying</TT> procedure uses the <TT>MyCreateSndChannel</TT> function defined in Listing 2-1 to create a sound channel, requesting that the function allocate a standard-sized sound channel command queue. By using such a queue, you can be sure that your application can play any sound resource that contains up to 127 sound commands. If you are sure that your application will play only sampled-sound resources created by the Sound Input Manager, you should request a queue of only two sound commands, thereby leaving enough room for just the <TT>bufferCmd</TT> command contained within the sound resource and the <TT>callBackCmd</TT> command that your application issues. </P><P>Before playing the sound, the <TT>MyStartPlaying</TT> procedure defined in Listing 2-32 detaches the sound resource from its resource file after loading it. This is important if the resource file could close while the sound is still playing, or if your application might create another sound channel to play the same sound resource while the sound is still playing. </P><hr>&#169; 1999 Apple Computer, Inc.<!-- QTnavbar start --><P><I>Inside Macintosh: Sound</I><P>| <A target="doc" HREF="imsoundmgr.1e.htm">Previous</A> | <A target="doc" HREF="imsoundmgr.1.htm">Chapter contents</A> | <A target="doc" HREF="imsoundmgr.htm">Chapter top</A> | <A target="doc" HREF="imsoundmgr.1e.htm">Section top</A> | <A target="doc" HREF="imsoundmgr.20.htm">Next</a> | <!-- QTnavbar end --><!-- legacy work start --><script type="text/javascript"> placeWatermark()</script><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox" style="position: relative;"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b><i>Sound Input Manager</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="http://developer.apple.com/referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div><!-- legacy work end --></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>