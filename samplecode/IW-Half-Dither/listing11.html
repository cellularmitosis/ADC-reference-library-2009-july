<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>IW-Half-Dither - /source/NewApp.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">IW-Half-Dither</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">IW-Half-Dither</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/NewApp.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/source/ChooserSupport.a</option>
<option value="listing2.html">/source/ChooserSupport.r</option>
<option value="listing3.html">/source/ChooserSupportLDEF.c</option>
<option value="listing4.html">/source/ChooserSupportPACK.c</option>
<option value="listing5.html">/source/ChooserSupportProtos.h</option>
<option value="listing6.html">/source/CommonDefines.h</option>
<option value="listing7.html">/source/DriverProtos.h</option>
<option value="listing8.html">/source/GXPrintingResEquates.r</option>
<option value="listing9.html">/source/GXPrintingResTypes.r</option>
<option value="listing10.html">/source/NewApp.a</option>
<option value="listing11.html">/source/NewApp.c</option>
<option value="listing12.html">/source/NewApp.r</option>
<option value="listing13.html">/source/NewDriverProtos.h</option>
<option value="listing14.html">/source/OldApp.a</option>
<option value="listing15.html">/source/OldApp.c</option>
<option value="listing16.html">/source/OldApp.r</option></select>
				</p>
				</form>
				<p><strong><a href="IW-Half-Dither.zip">Download Sample</a></strong> (&#147;IW-Half-Dither.zip&#148;, 91.3K)<BR>
<strong><a href="IW-Half-Dither.dmg">Download Sample</a></strong> (&#147;IW-Half-Dither.dmg&#148;, 159.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  copyright &copy; 1991-1994 Apple Computer Inc.  All rights reserved.    NewApp.c  This file contains all new API implementations for the ImageWriter driver.    Modification history  03/19/91    TED        New file today  04/23/91    Sam Weiss    Changed Inherit to Forward  05/29/91    TED        Added manual feed and faster mode support  12/20/93    dmh        Sync'd with the shipping 1.0b3 GX driver.  03/24/94    Ken Hittleman  Updated manual feed to use gxTrayFeedInfo  03/30/94    Ken Hittleman  Added call to paper matching CheckStatus when switching to auto-feed  07/05/94    Ken Hittleman  Removed set color and page size from IW I path, which blew cookies on it  08/26/94    dmh        Sync'd with the shipping 1.0.1 GX driver.  05/21/96      Jason H-H    Updated for ETO#19/MW.  05/21/96    Don Swatman     Modifications for halftoning, dithering and plane seperations.*//**** DEFINE DEBUG ON ****///#define DEBUGLEVEL DEBUGON/*************************/#include &lt;Memory.h&gt;#include &lt;Errors.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Resources.h&gt;#include &lt;Packages.h&gt;#include &lt;GXPrinterDrivers.h&gt;#include &lt;GXPrinting.h&gt;#include &lt;FixMath.h&gt;#include &lt;GXMath.h&gt;#include &lt;GXGraphics.h&gt;#include &lt;GraphicsLibraries.h&gt;#include &lt;GXLayout.h&gt;#include &lt;CollectionLibrary.h&gt;#include &lt;JobFormatModeLibrary.h&gt;#include &lt;PaperTypeLibrary.h&gt;#include &lt;PicturesAndPICTLibrary.h&gt;#include &quot;CommonDefines.h&quot;#include &quot;NewDriverProtos.h&quot;/*  -----------------------------------------------------------------------  __Startup__ contains our jump table to the overrides.  This code must be kept in sync with the assembly jump table  in NewApp.a and the gxOverrideType resources in NewApp.rsrc  -----------------------------------------------------------------------  */#if defined(__MWERKS__)asm void __Startup__(void);asm void __Startup__(void)  {    dc.L  0          // Reserved for owner count.    // Universal messages    jmp SD_Initialize    jmp SD_ShutDown    jmp SD_DefaultPrinter    jmp SD_DefaultFormat    jmp SD_DefaultJob    jmp SD_JobFormatDialog    jmp SD_JobFormatModeQuery    jmp SD_RenderPage    jmp SD_OpenConnection    jmp SD_CloseConnection    jmp SD_StartSendPage    jmp SD_FinishSendPage    jmp SD_DumpBuffer    jmp SD_FreeBuffer    jmp SD_SetupImageData    jmp SD_JobIdle    jmp SD_JobPrintDialog    jmp SD_HandlePanelEvent    // Raster messages    jmp SD_PackageBitmap    jmp SD_LineFeed        rts              // this is needed so __Startup__ symbol works  }#endif/* ------------------------------------------------------------------------------------  *//*  INTERNAL DEFINES                                  *//* ------------------------------------------------------------------------------------  */  // positive error for aborting job and placing on hold#define kPutJobOnHoldErr      3// timeout (in ticks) for the initial query#define kQueryTimeout        (7*60);// things this specific driver puts into the DTP config file#define  kImageWriterConfigType    'ifig'#define kImageWriterConfigID    (0)      typedef struct  {    Boolean  hasColorRibbon;    Boolean  hasSheetFeeder;    Boolean  isImageWriterII;    // is this an ImageWriter II, or an older model?  } ImageWriterConfigRecord, *ImageWriterConfigPtr, ** ImageWriterConfigHandle;  /* Define special characters needed */#define ESCAPE        (char) 27/* A record to hold a set margins command */typedef struct SetMarginsRecord  {  char    cEscape;          // ESCAPE character  char    cCommand;          // Set Margins command character  char    cIndentDistance[4];      // number of dots to indent  } SetMarginsRecord, *SetMarginsPtr;#define kSetMarginsCommand  (char)'F'    // ImageWriter II uses 'F' for tabbing#define kSetMarginsSize    6/*   Define a record that can hold one scan line's worth of data, 1280 will  only happen at 160 dpi. and 14 inch wide paper.   */typedef struct ScanLineRecord  {  char      cColorEscape;          // ESCAPE character  char      cSetColorCommand;        // Set color command  char      cColor;              // The color  char      cEscape;            // ESCAPE character  char      cCommand;            // 'enter graphics' command  char      cLineLength[4];          // number of dots to print  char      iTheData[2240];          // Bits for the data, enough for one line's worth  } ScanLineRecord, *ScanLinePtr;#define kGraphicsCommand  (char)'G'    /* graphics printing command */#define kRepeatGroup    (char)'V'    /* repeat group character */#define kSetColorCommand   (char)'K'    /* Set color command */#define kGroupSize      6        /* Size of one group header */#define kScanLineSize     3        /* NOTE: this is just the header size! */// Status flags for PAP status queries#define  kColorRibbonBit    0#define kSheetFeederBit    1#define kPaperOutBit    2#define kCoverOpenBit    3#define kOffLineBit      4#define kPaperJamBit    5#define kPrinterFaultBit  6#define kHeadMovingBit    7#define kPrinterBusyBit    8#define kOutOfPaperMask      (  (0x8000 &gt;&gt; kPaperJamBit) | (0x8000 &gt;&gt; kCoverOpenBit) | (0x8000 &gt;&gt; kOffLineBit) )#define kPrinterOfflineMask    (  (0x8000 &gt;&gt; kOffLineBit) )#define kPrinterBusyMask    (  (0x8000 &gt;&gt; kPrinterBusyBit) )#define kHeadMovingMask      (  (0x8000 &gt;&gt; kHeadMovingBit) )// Color pass#define kYellowPass   1#define kMagentaPass  2#define kCyanPass     3#define kBlackPass    4//-------------------------------------------------------------------// Structures and constants for the render options collection//// This is structured so it can be used by the gxExtendedDITLType// resource -'xdtl'. The types and allignment are significant.//// Booleans : unsigned char : These are byte alligned.// Pop-up   : short         : Word (2Byte) alligned// Float    : fixed         : Word (2Byte) alligned//-------------------------------------------------------------------#define kDitherIt   0#define kHalfToneIt 1#define kRenderOptsCyan    0#define kRenderOptsMagenta 1#define kRenderOptsYellow  2#define kRenderOptsBlack   3struct CMYKRenderCollection{// Plane flags, set to true to print the plane  unsigned char cyanIsOn;  unsigned char magentaIsOn;  unsigned char yellowIsOn;  unsigned char blackIsOn;// Set to &quot;kDitherIt&quot; for dithered output, or &quot;kHalfToneIt&quot; for half tone  unsigned char renderMode;  unsigned char fill1;  // used when in dither mode to select the level of dither  short ditherLevel;// used when in half tone mode to select how to half tone  short dotType;  Fixed angles[4];  Fixed frequency[4];};typedef struct CMYKRenderCollection CMYKRenderCollection;//&lt;FF&gt;/* ------------------------------------------------------------------------------------  *//*  INTERNAL ROUTINES                                *//* ------------------------------------------------------------------------------------  */void Long2Dec(long aLong, Ptr emitHere)/*  Converts a long into an ASCII string, padded with leading zeros.*/{    char  aString[10];  short  i, actualWidth, strLength;    NumToString(aLong, (unsigned char*)aString);    // Get the width of the string, check for being too small  strLength = aString[0];  actualWidth = strLength;  if (actualWidth &lt; 4)    actualWidth = 4;      // output the string, padding with the requested character  strLength = actualWidth-strLength;  for (i = 0; i &lt; actualWidth; ++i)    {    *emitHere++ = (i &lt; strLength)       ? '0' : aString[(i+1)-(strLength)];    }    } // Long2Dec//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */Boolean PrinterHasColorRibbon(gxPrinter thePrinter)/*  Returns true if the config file says that the printer is blessed with a color ribbon,  false if it is a black and white ribbon.*/{  Boolean            hasColor = true;  Str32            deviceName;  OSErr            anErr;  ImageWriterConfigHandle    configHandle;    // if not formatting to a particular device, assume color ribbon, for widest range of colorSpaces  GXGetPrinterName(thePrinter, deviceName);  if (deviceName[0] != 0)    {    // if we are going to a particular device, assume no color, as that is more common    hasColor = false;        anErr = GXFetchDTPData(deviceName, kImageWriterConfigType, kImageWriterConfigID, (Handle*)&amp;configHandle);    if (anErr == noErr)      {      hasColor = (**configHandle).hasColorRibbon;      DisposHandle((Handle) configHandle);      }    }    return(hasColor);  } // PrinterHasColorRibbon//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */gxViewDevice  NewDeviceResolutionViewDevice(void)/*  This routine creates a viewDevice and gives it a scale factor in it's mapping  appropriate for this device (144 dpi in the case of the IW)*/{  gxViewDevice    vd;    // create the viewDevices with a fake bitmap  {  gxShape    tempBitmap;  gxBitmap    aBitmap;    aBitmap.pixelSize   = 1;  aBitmap.rowBytes   = 0;  aBitmap.width     = 0;  aBitmap.height     = 0;  aBitmap.image     = (char*)gxMissingImagePointer;  aBitmap.space     = gxNoSpace;  aBitmap.set     = nil;  aBitmap.profile   = nil;    tempBitmap = GXNewBitmap(&amp;aBitmap, nil);  vd = GXNewViewDevice(gxScreenViewDevices, tempBitmap);  GXDisposeShape(tempBitmap);  }  // setup a mapping for a 144 (2X) viewDevice  {  gxMapping  vdMapping;    ResetMapping(&amp;vdMapping);  ScaleMapping(&amp;vdMapping, ff(2), ff(2), ff(0), ff(0));    GXSetViewDeviceMapping(vd, &amp;vdMapping);  }    return(vd);  } // NewDeviceResolutionViewDevice//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */Boolean  JobIsBest(long *imagewriterOptions)/*  Returns true if the current job is a final quality mode job, else returns false.  Also, returns the imagewriter rendering options.*/{  Boolean      isFinal;  gxQualityInfo  jobQualitySettings;  long      itemSize = sizeof(jobQualitySettings);  OSErr      status;  Collection    jobCollection;    // cache the collection  jobCollection = GXGetJobCollection(GXGetJob());    // find out the info      isFinal = false;    status = GetCollectionItem(jobCollection,                   gxQualityTag, gxPrintingTagID,                   &amp;itemSize, &amp;jobQualitySettings);    if ( (status == noErr) &amp;&amp; (jobQualitySettings.currentQuality == (jobQualitySettings.qualityCount-1)) )    isFinal = true;    // we default to super res  *imagewriterOptions = kSuperRes;  itemSize = sizeof(imagewriterOptions);  status = GetCollectionItem(jobCollection,                   DriverCreator, 0,                   &amp;itemSize, imagewriterOptions);          // and return the job quality mode  return(isFinal);  } // JobIsBest//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr  DoTheQuery(unsigned short * statusReturn, Boolean papStatus)/*  Returns in statusString the current status for the printer.  Returns various  errors from IO package if the printer's status could not be found.*/{  OSErr        anErr = noErr;  long        statusLength;          // status string size  SpecGlobalsHdl     hGlobals = GetMessageHandlerInstanceContext();  char        cmdData[4];  Str255        theTerminatorStr;   theTerminatorStr[0] = 0x01;    //  teminator codes for query  theTerminatorStr[1] = 0x0D;    //  CR == 0x0D  cmdData[0] =  0x1B;      // cmdData control codes to query ImageWriter II   cmdData[1] =   0x3F;  // default to a clear status  *statusReturn = 0;  // send the query  if (papStatus)  {    char  statusString[255];        // returned string        // According to the old IW driver, sometimes it will return all of the bits    // set.  This is an error, but we can just try again.    do    {      statusLength = 255;      anErr = Send_GXGetDeviceStatus(nil, 0, statusString, &amp;statusLength, nil);    } while ( (anErr == noErr) &amp;&amp; (statusString[0] == 0xFF) );    // return the printer status bits in the PAP case    *statusReturn = *(unsigned short*)&amp;statusString[0];  }  else  {    char  statusString[8];        // returned string    if ((**hGlobals).isImageWriterII)    {      statusLength = 8; // max number of characters to get back      anErr = Send_GXGetDeviceStatus((Ptr)&amp;cmdData, 2, statusString, &amp;statusLength, theTerminatorStr);              if ( anErr == gxAioTimeout)      {        *statusReturn = kPrinterOfflineMask;        anErr = noErr;      }      else      {        if (anErr == noErr)        {          // generate printer status bits in the serial case          if (statusString[4] == 'C')            *statusReturn |= 0x8000 &gt;&gt; kColorRibbonBit;          if ( (statusString[5] == 'F') || (statusString[4] == 'F') )            *statusReturn |= 0x8000 &gt;&gt; kSheetFeederBit;        }      }    }  }      nrequire(anErr, Send_GXGetDeviceStatus);// FALL THROUGH EXCEPTION HANDLING  Send_GXGetDeviceStatus:    return(anErr);} // DoTheQuery//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr FetchStatusString(unsigned short * statusReturn, Boolean papStatus, Boolean doRetry)/*  Returns in statusString the current status for the printer.  Returns various  errors from IO package if the printer's status could not be found.    Handles reporting error conditions to the user.*/{  OSErr        anErr;  SpecGlobalsHdl     hGlobals = GetMessageHandlerInstanceContext();    anErr = DoTheQuery(statusReturn, papStatus);      nrequire(anErr, Send_GXGetDeviceStatus);    // printer offline?  if (       (doRetry) &amp;&amp;    ( ((*statusReturn) &amp; kPrinterOfflineMask) != 0 )      )    {    gxStatusRecord    theStat;    gxStatusRecord    *pStat = &amp;theStat;    Boolean        printerIsFixed = false;        pStat-&gt;statusOwner  = 'drvr';    pStat-&gt;statResId   = kDriverStatus;        pStat-&gt;statResIndex = kCheckOnline;          pStat-&gt;bufferLen    = 0;    pStat-&gt;dialogResult = 0;  // ORIGINALLY SET TO ===&gt; nil;        // keep sending the user the alert until either    //  a) the problem resolves itself    //  b) the user responds via the dialog    //  c) some other (fatal) error happens    do      {            // tell the user      anErr = GXAlertTheUser(pStat);            // based on the user's response, continue or cancel      switch (pStat-&gt;dialogResult)        {        case ok:          // retry          break;                  case cancel:          anErr = gxPrUserAbortErr;          break;                  case 3:          anErr = kPutJobOnHoldErr;          break;        }              // error to return from next idle      (**hGlobals).idleError = anErr;      // if printer got suddenly turned online, do an OK      if ( (anErr == noErr) &amp;&amp; ((papStatus) || (pStat-&gt;dialogResult == ok)) )        {        pStat-&gt;dialogResult = 0;  // ORIGINALLY SET TO ===&gt; nil;        (void) DoTheQuery(statusReturn, papStatus);            if (             ( ((*statusReturn) &amp; kPrinterOfflineMask) == 0 )           )          {          printerIsFixed = true;          pStat-&gt;dialogResult = ok;          anErr = noErr;          }        }              } while ((anErr == noErr) &amp;&amp; (pStat-&gt;dialogResult == 0)); // WAS ORIGINALLY ====&gt;  (pStat-&gt;dialogResult == nil)    // printer is okay -- no error    if (printerIsFixed)      anErr = noErr;        // display &quot;sending data to the printer&quot; message    if (anErr == noErr)      anErr = GXReportStatus(kDriverStatus, kSendingData);    }// FALL THROUGH EXCEPTION HANDLING  Send_GXGetDeviceStatus:    return(anErr);  } // FetchStatusString//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr UpdateConfiguration(void)/*  This routine queries the printer for its hardware configuration (color ribbon and  sheet feeder options), and stores that info into the configuration file.*/{  SpecGlobalsHdl         hGlobals;  Str32            deviceName;  OSErr            anErr = noErr;  ImageWriterConfigHandle    configHandle;  ImageWriterConfigPtr    configPtr;  Boolean            isImageWriterII;  ResType            commType;    hGlobals = GetMessageHandlerInstanceContext();    isImageWriterII = false;// find out what we are printing to, and how we are connected  GXGetPrinterName(GXGetJobOutputPrinter(GXGetJob()), deviceName);  anErr = GXFetchDTPData(deviceName, gxDeviceCommunicationsType, gxDeviceCommunicationsID, (Handle*)&amp;configHandle);  nrequire(anErr, FetchCommType);  commType = **(ResType**)configHandle;  DisposHandle((Handle) configHandle);      // store away the communications type for future use  //{  //  SpecGlobalsHdl       hGlobals = GetMessageHandlerInstanceContext();  //    //  (**hGlobals).commType = commType;  //}    // find out the original configuration  if (GXFetchDTPData(deviceName, kImageWriterConfigType, kImageWriterConfigID, (Handle*)&amp;configHandle) == noErr)  {    // remember if we thought we had an IW2 when we started    configPtr = *configHandle;    (**hGlobals).isImageWriterII = isImageWriterII = configPtr-&gt;isImageWriterII;    DisposeHandle((Handle) configHandle);    // if we aren't an ImageWriter II, bail out now - because the timeout takes two minutes!    if (!isImageWriterII)    {      return(noErr);          }  }  else  {        if (commType == 'PPTL')    {      isImageWriterII = true;    }      // Assume IW 2 so we do the query for real    (**hGlobals).isImageWriterII = true;  }      // make a handle to hold our configuration information for the printer  configHandle = (ImageWriterConfigHandle) NewHandle(sizeof(ImageWriterConfigRecord) );  anErr = MemError();  nrequire(anErr, NewHandle);    // setup the default for the device - in case the query fails  configPtr = *configHandle;  configPtr-&gt;hasColorRibbon = false;  configPtr-&gt;hasSheetFeeder = false;  configPtr-&gt;isImageWriterII = true;    // send initial data first to make sure IO handshaking is working,  // to load the first sheet of paper into the feeder (if any),  // and to take up &quot;gear lash&quot; in the device.  This is copied from  // what the old driver did.  Not doing this will cause the sheet  // feeder not to feed the initial page of data.  {  char  sendBuffer[11];    // &lt;CR&gt;  sendBuffer[0] = 0x0D;    // linefeed size = 18/144th  sendBuffer[1] = ESCAPE;  sendBuffer[2] = 'T';  sendBuffer[3] = '1';  sendBuffer[4] = '8';    // reverse line feed  sendBuffer[5] = ESCAPE;  sendBuffer[6] = 'r';  sendBuffer[7] = 0x0A;    // forward line feed  sendBuffer[8] = ESCAPE;  sendBuffer[9] = 'f';  sendBuffer[10] = 0x0A;    anErr = Send_GXWriteData(sendBuffer, 11);  nrequire(anErr, Failed_SendInitialData);  }    {    unsigned short  statusReturn;        // query the device    if ((isImageWriterII) &amp;&amp; (commType == 'SPTL') )      (**hGlobals).idleTimeout = TickCount() + kQueryTimeout;    anErr = FetchStatusString(&amp;statusReturn, (Boolean)(commType == 'PPTL'), isImageWriterII);    if ( (anErr == noErr) &amp;&amp; ( (statusReturn &amp; kPrinterOfflineMask) != 0 )  )      anErr = gxAioTimeout;    (**hGlobals).idleTimeout = 0;    GXReportStatus(kDriverStatus, kSendingData);        // and scan the string looking for information about printer kind and options    configPtr = *configHandle;    if ( anErr == gxAioTimeout )    {      // if we timeout and we don't know the printer kind - assume IW1      if (!isImageWriterII)      {        anErr = noErr;        isImageWriterII = configPtr-&gt;isImageWriterII = false;      }    }    else    {      isImageWriterII = true;      configPtr-&gt;hasColorRibbon = (statusReturn &amp; (0x8000 &gt;&gt; kColorRibbonBit)) != 0;      configPtr-&gt;hasSheetFeeder = (statusReturn &amp; (0x8000 &gt;&gt; kSheetFeederBit)) != 0;    }    nrequire(anErr, FetchStatusString);  }    // Remember if this was an ImageWriter II after the query  (**hGlobals).isImageWriterII = isImageWriterII;    // write out the new configuration  anErr = GXWriteDTPData(deviceName, kImageWriterConfigType, kImageWriterConfigID, (Handle)configHandle);    // CLEANUP EXCEPTION HANDLINGFetchStatusString:Failed_SendInitialData:  DisposHandle((Handle) configHandle);  NewHandle:Send_GXWriteData:FetchCommType:  return(anErr);  } // UpdateConfiguration/* ------------------------------------------------------------------------------------  */OSErr WriteDraftChars(long **draftTable, unsigned char *draftChar, long numChars)/*  This routine writes out a single character in the native set of the printer.  It uses a table that's part of the driver to do the right thing in order to generate this  character.*/{  OSErr    anErr = noErr;  char    outputChars[20];        // a maximum of 20 characters can be generated  short    charCount;              // For each character in the buffer, determine how to map the character to a draft character  for (; numChars &gt; 0; --numChars, ++draftChar)  {    // No characters yet for this output character    charCount = 0;          // Only consider characters in the printable range    if (*draftChar &gt;= 0x20)    {      unsigned long  draftControl = (*draftTable)[*draftChar-0x20];  // Fetch native mode long word corresponding to this character      unsigned char  outChar;      unsigned char  nationalSet;      short        i;            // For each word which composes the native mode long word       for (i = 1; i &gt;= 0; --i)      {        // Should we send a backspace character (to overstrike)?        if ( (draftControl &amp; 0x80000000) != 0 )          outputChars[charCount++] = 0x08;                outChar = (draftControl &gt;&gt; 16) &amp; 0xFF;        if (outChar != 0)        {          // Determine the national character set to select          nationalSet = (draftControl &gt;&gt; 24) &amp; 0xF;              //  Is this character in the standard, built-in character set?          if (nationalSet == 0)          {            outputChars[charCount++] = outChar;          }          else  //  T =&gt; Must select a foreign language character set           {            outputChars[charCount++] = 0x1B;            outputChars[charCount++] = 0x44;            outputChars[charCount++] = nationalSet;            outputChars[charCount++] = 0x00;            outputChars[charCount++] = outChar;            outputChars[charCount++] = 0x1B;        // We always switch back to the kAmerican character set            outputChars[charCount++] = 0x5A;            outputChars[charCount++] = 0x07;            outputChars[charCount++] = 0x00;          }        }                // Take the next (low) word and process it (if we're not all done)        draftControl &lt;&lt;= 16;      }      }          // If we generated any data, send it out now    if (charCount &gt; 0)      anErr = Send_GXBufferData(outputChars, charCount, gxNoBufferOptions);  }      return(anErr);    } // WriteDraftChars/* ------------------------------------------------------------------------------------  */OSErr GetPointerThisBig(Ptr *theBuff, long numBytes) {  OSErr    anErr = noErr;    if (*theBuff != nil)  {    if ( GetPtrSize(*theBuff) &lt; numBytes )  //  T =&gt; Won't be big enough; make a new one    {      DisposPtr(*theBuff);      *theBuff = nil;    }  }  if (*theBuff == nil)  {    *theBuff = NewPtrClear(numBytes);    anErr = MemError();  }    return(anErr);  } // GetPointerThisBig/* ------------------------------------------------------------------------------------  */OSErr GetTextAndPosition(  gxShape      theShape,               Ptr        *theChars,               long      *numChars,               gxPoint      *textPosition){  OSErr    anErr = noErr;  long    textLength;    // Determine the size of the text data and the position of the text  textLength = GXGetLayout(theShape, nil, nil, nil, nil, nil, nil, nil, nil, textPosition);  // Make sure we have a buffer pointer large enough to hold all of the data    anErr = GetPointerThisBig(theChars, textLength);  require(anErr == noErr, CantAllocTextBuff);    // Now we retrieve the text  GXGetLayout(theShape, *theChars, nil, nil, nil, nil, nil, nil, nil, nil);    // Remember the number of characters in the shape  *numChars = textLength;  /******* Clean-up *******/CantAllocTextBuff:  return(anErr);  } // GetTextAndPosition/* ------------------------------------------------------------------------------------  */OSErr PrintPageInDraftMode(gxShape thePage, gxRasterImageDataHdl imageData){  OSErr          anErr = noErr;  long          i;  long          numItems;  Fixed          currYPos = ff(0);  Ptr            theChars = nil;  long          numChars = 0;  gxPoint          textPosition;  Fixed          oldTextSize = ff(0);  SpecGlobalsHdl       hGlobals = GetMessageHandlerInstanceContext();    // Since the page picture we need to process is a picture shape that's embedded in  // thePage (a shape containing one item =&gt; a picture), we need to extract the real  // page picture from thePage.    thePage = GetPictureItem(thePage, 1, nil, nil, nil, nil);  numItems = GXGetPicture(thePage, nil, nil, nil, nil);    // For each shape within the picture, check its type and process it accordingly    for (i = 1; i &lt;= numItems; ++i)  {    gxShape        theShape;    short        theType;            theShape = GetPictureItem(thePage, i, nil, nil, nil, nil);    theType = GXGetShapeType(theShape);        if (theType == gxLayoutType)  //  T =&gt; We have a layout shape    {      Fixed    textSize;      char    buff[12];      char    theFace;      short    cmndBuffSz;            // First determine the style in which we're printing            theFace = GetStyleCommonFace( GXGetShapeStyle(theShape) );            buff[0] = ESCAPE;      if ( (theFace &amp; bold) != 0 )  //  T =&gt; Turn bold facing on        buff[1] = '!';      else                  //  T =&gt; Turn it off        buff[1] = '&quot;';            buff[2] = ESCAPE;      if ( (theFace &amp; underline) != 0 )  //  T =&gt; Turn underline facing on        buff[3] = 'X';      else                      //  T =&gt; Turn it off        buff[3] = 'Y';              cmndBuffSz = 4;            // Next determine if we need to change the size of the font being used            textSize = GXGetShapeTextSize(theShape);      if (textSize != oldTextSize)  //  T =&gt; Must issue LQ command to change font size      {        buff[4] = ESCAPE;        //  The first escape command selects black color        buff[5] = kSetColorCommand;        buff[6] = '0';                buff[7] = ESCAPE;        //  The second escape command selects a draft font        buff[8] = 'a';        buff[9] = '1';                buff[10] = ESCAPE;        //  The third escape command selects the character pitch                if ( textSize &lt;= ff(10) )  //  T =&gt; Select 10 cpi        {          buff[11] = 'N';        }        else  //  T =&gt; All other sizes get mapped to 12 cpi        {          buff[11] = 'E';        }                // Remember the last text size        oldTextSize = textSize;                  // Adjust the size of the data to be sent to the printer        cmndBuffSz += 8;      }      // else - no change in font size            // Send the commands to the printer      anErr = Send_GXBufferData(buff, cmndBuffSz, gxDontSplitBuffer);      require(anErr == noErr, CantSendFontCmnd);      // Get the ASCII text and the starting position of the data      anErr = GetTextAndPosition(theShape, &amp;theChars, &amp;numChars, &amp;textPosition);      require(anErr == noErr, CantGetTextAndPos);            if ( (currYPos != ff(0)) &amp;&amp; (currYPos != textPosition.y) )  //  T =&gt; Moving to a lower line, finish the last ;line with a CR      {        char    c = 0x0D;                anErr = Send_GXBufferData(&amp;c, 1, gxNoBufferOptions);        require(anErr == noErr, CantSendCRCmnd);      }            // Position the print head to the proper location on the page      {        gxMapping        theMapping;        long          lineFeedSize;        Str255          positionCmndsBuff;        unsigned long      bytesInBuff = 0;        unsigned char      *p;        GXGetShapeMapping(theShape, &amp;theMapping);        MapPoints(&amp;theMapping, (long) 1, &amp;textPosition);  //  Just map the first point                // Now position the print head vertically        lineFeedSize = (textPosition.y - currYPos) &gt;&gt; 16;        anErr = Send_GXRasterLineFeed(&amp;lineFeedSize, (char*)positionCmndsBuff, &amp;bytesInBuff, imageData);        require(anErr == noErr, CantEmitLineFeeds);                // Update the current Y position pointer on the page        currYPos = textPosition.y;        // Now position the print head horizontally on the page        p = &amp;positionCmndsBuff[bytesInBuff];            *p++ = ESCAPE;        *p++ = 'F';        Long2Dec((*hGlobals)-&gt;leftMargin + FixedToInt(textPosition.x), (char*)p);  // Convert left margin into ASCII and place it at the start of the scan line                // Update the number of bytes in the buffer        bytesInBuff += 6;        // Send the positioning info to the printer        anErr = Send_GXBufferData((char*)positionCmndsBuff, bytesInBuff, gxDontSplitBuffer);        require(anErr == noErr, CantSendPositionCmnds);      }            // Now we send the text data to the printer      anErr = WriteDraftChars((long **) (*hGlobals)-&gt;draftTable, (unsigned char*)theChars, numChars);      require(anErr == noErr, CantWriteChars);    }  }  // for  // Send one last CR to wrap the last line (if there was one)  {    char    c = 0x0D;        anErr = Send_GXBufferData(&amp;c, 1, gxNoBufferOptions);  }/******* Clean-up *******/CantWriteChars:CantSendPositionCmnds:CantEmitLineFeeds:CantSendCRCmnd:CantGetTextAndPos:CantSendFontCmnd:  if (theChars != nil)    DisposPtr(theChars);          return(anErr);  } // PrintPageInDraftMode //&lt;FF&gt;/* ------------------------------------------------------------------------------------  *//*  SPECIFIC DRIVER UNIVERSAL OVERRIDES                          *//* ------------------------------------------------------------------------------------  */OSErr SD_Initialize (void) /*  The SD_Initalize message is called when a new job is created.  The standard  thing to do is to allocate and fill out your globals as you see fit.*/{  SpecGlobalsHdl   hGlobals;  OSErr       anErr;      // we make our globals  hGlobals = (SpecGlobalsHdl) NewHandleClear( sizeof(SpecGlobals) );  anErr = MemError();  // and we save them away  SetMessageHandlerInstanceContext(hGlobals);  // is everything okay?  nrequire(anErr, MNewHandleClear);    // Don't need to initialize because of the NewHandleCLEAR  //(**hGlobals).draftTable = nil;  //(**hGlobals).lineFeeds = 0;  //(**hGlobals).packagingOptions = kNoPackagingOptions;  //(**hGlobals).idleError     = noErr;  //(**hGlobals).idleQuery     = false;  //(**hGlobals).idleTimeout     = 0;  //(**hGlobals).timeoutPending   = false;      return(noErr);    /*-----EXCEPTION HANDLING------*/MNewHandleClear:  return(anErr);  } // SD_Initialize//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr SD_ShutDown(void) /*  Shutdown is called when the job is done with.  A good thing to do is to get  rid of any additional storage that is laying around.*/{  // clean up our stuff  SpecGlobalsHdl hGlobals = GetMessageHandlerInstanceContext();  // get rid of the draft table (if we have one)  if (hGlobals)    DisposHandle((**hGlobals).draftTable);    // we get rid of our storage  DisposHandle((Handle) hGlobals);    // clear out our globals - to avoid double disposes  SetMessageHandlerInstanceContext(nil);  return(noErr);    } // SD_ShutDown//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr  SD_DefaultPrinter(gxPrinter thePrinter)/*  This call is made to setup the default printer object.  The job of the  specific driver is to add in any viewDevices that it wishes applications  to be able to format specifically for.*/{  OSErr      anErr;  gxViewDevice  vd;  gxJob      theJob = GXGetJob();    // add the standard viewDevices first  anErr = Forward_GXDefaultPrinter(thePrinter);  nrequire(anErr, DefaultPrinter);    // add a 144 b/w viewDevice  vd = NewDeviceResolutionViewDevice();  {  gxSetColor    theColors[2];  gxSetColor    *pColor;  gxColorSet    theSet;    pColor = &amp;theColors[0];    pColor-&gt;rgb.red = pColor-&gt;rgb.green = pColor-&gt;rgb.blue = 0xFFFF;    pColor++;  pColor-&gt;rgb.red = pColor-&gt;rgb.green = pColor-&gt;rgb.blue = 0x0000;    theSet = GXNewColorSet(gxRGBSpace, 2, theColors);  SetViewDeviceColorSet(vd, theSet);  GXDisposeColorSet(theSet);  }      anErr = GXAddPrinterViewDevice(thePrinter, vd);  nrequire(anErr, FailedAddBWViewDevice);    // add a 144 color viewDevice with 8 colors in it  //  //  Color    Index    R      G      B  //  white    0      0xFFFF    0xFFFF    0xFFFF      //  yellow    1      0xFFFF    0xFFFF    0x0000  //  magenta    2      0xFFFF    0x0000    0xFFFF  //  red      3      0xFFFF    0x0000    0x0000  //  cyan    4      0x0000    0xFFFF    0xFFFF  //  green    5      0x0000    0xFFFF    0x0000  //  blue    6      0x0000    0x0000    0xFFFF  //  black    7      0x0000    0x0000    0x0000    if (PrinterHasColorRibbon(thePrinter))    {    gxSetColor    theColors[8];    gxSetColor    *pColor;    gxColorSet    theSet;    short      idx;    vd = NewDeviceResolutionViewDevice();        pColor = &amp;theColors[0];    for (idx = 0; idx &lt; 8; ++idx)      {      // default the color to black      pColor-&gt;rgb.red = pColor-&gt;rgb.green = pColor-&gt;rgb.blue = 0x0000;            // and give it componants to go along with this index      if (idx &amp; 0x04)        pColor-&gt;rgb.red   = 0xFFFF;      if (idx &amp; 0x02)        pColor-&gt;rgb.green   = 0xFFFF;      if (idx &amp; 0x01)        pColor-&gt;rgb.blue   = 0xFFFF;              // move on to the next color      ++pColor;      }        theSet = GXNewColorSet(gxRGBSpace, 8, theColors);    SetViewDeviceColorSet(vd, theSet);    GXDisposeColorSet(theSet);    anErr = GXAddPrinterViewDevice(thePrinter, vd);    nrequire(anErr, FailedAddColorViewDevice);    }    /* Only if we are the output printer (not the formatting printer) */  if (GXGetJobPrinter(theJob) == GXGetJobOutputPrinter(theJob)) {    Collection      jobCollection = GXGetJobCollection(GXGetJob());    Handle         jobQualitySettingsHdl;      gxQualityInfo    *qualitySettings;    Ptr          p;    Str255        bestString, roughString;    // read in our quality mode strings    {    short  curResFile = CurResFile();        UseResFile(GXGetMessageHandlerResFile());        GetIndString( bestString, kNewQualityID, kBestString);    GetIndString( roughString, kNewQualityID, kRoughString);    UseResFile(curResFile);    }        jobQualitySettingsHdl = NewHandle(0);    anErr = MemError();    nrequire(anErr, FailedNewHandle);    anErr = GetCollectionItemHdl (   jobCollection,                    gxQualityTag,                    gxPrintingTagID,                    jobQualitySettingsHdl );    if (anErr == noErr)       {  /* Check for proper structure -- count as not found if different */      HLockHi(jobQualitySettingsHdl);      qualitySettings = *((gxQualityInfo **) jobQualitySettingsHdl);      p = qualitySettings-&gt;qualityNames;      if (qualitySettings-&gt;disableQuality)         anErr = collectionItemNotFoundErr;      else if (qualitySettings-&gt;qualityCount != 2)        anErr = collectionItemNotFoundErr;      else if (! IUEqualString((ConstStr255Param)p, bestString))        anErr = collectionItemNotFoundErr;      else if (! IUEqualString((ConstStr255Param)(p + p[0] + 1), roughString))        anErr = collectionItemNotFoundErr;      HUnlock(jobQualitySettingsHdl);      }    if (anErr == collectionItemNotFoundErr)       {      Size      count;      /* Create the proper quality item */      SetHandleSize(jobQualitySettingsHdl,(sizeof(gxQualityInfo) + bestString[0] + roughString[0] + 2 ));      anErr = MemError();      nrequire( anErr, FailedSetHandleSize );              qualitySettings = *((gxQualityInfo **) jobQualitySettingsHdl);            qualitySettings-&gt;disableQuality = false;      qualitySettings-&gt;defaultQuality = 1;      qualitySettings-&gt;currentQuality = 1;      qualitySettings-&gt;qualityCount = 2;      count = bestString[0]+1;      p = qualitySettings-&gt;qualityNames;      BlockMove( bestString, p, count );      p += count;      BlockMove( roughString, p, roughString[0]+1 );      /* Add the proper quality item */      anErr = AddCollectionItemHdl (   jobCollection,                      gxQualityTag,                      gxPrintingTagID,                      jobQualitySettingsHdl );      /* Make it vilatile by driver */      if (anErr == noErr)        (void) SetCollectionItemInfo(jobCollection, gxQualityTag, gxPrintingTagID, 0x0000FFFF, gxVolatileOutputDriverCategory);      }    FailedSetHandleSize:    DisposHandle(jobQualitySettingsHdl);  }FailedNewHandle:  return(noErr);      // EXCEPTION HANDLINGFailedAddColorViewDevice:FailedAddBWViewDevice:  GXDisposeViewDevice(vd);  DefaultPrinter:  return(anErr);  } // SD_DefaultPrinter//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr SD_DefaultFormat(gxFormat theFormat){  OSErr        anErr;  Handle         jobQualitySettingsHdl;      anErr = Forward_GXDefaultFormat(theFormat);    // now, if the application has set up a special formatting mode, we need to update  // the quality mode collection item (and any private ones we use)  if (anErr == noErr)    {    gxPoint        dpiPoint;    gxMapping      vdMapping;    gxViewDevice    selectedDevice;    dpiPoint.x = ff(72);    dpiPoint.x = ff(72);    selectedDevice = GXGetPrinterViewDevice(GXGetJobPrinter(GXGetFormatJob(theFormat)), 0);    if (selectedDevice != GXGetPrinterViewDevice(GXGetJobPrinter(GXGetFormatJob(theFormat)), 1) )      {      GXGetViewDeviceMapping(selectedDevice, &amp;vdMapping);      MapPoints(&amp;vdMapping, 1, &amp;dpiPoint);            {      Collection      jobCollection = GXGetJobCollection(GXGetJob());      gxQualityInfo    *qualitySettings;        jobQualitySettingsHdl = NewHandle(0);      anErr = MemError();      nrequire(anErr, FailedNewHandle);      anErr = GetCollectionItemHdl (   jobCollection,                          gxQualityTag,                           gxPrintingTagID,                         jobQualitySettingsHdl );      nrequire(anErr, FailedGetCollectionItemHdl);      qualitySettings = *((gxQualityInfo **) jobQualitySettingsHdl);      qualitySettings-&gt;currentQuality =         (dpiPoint.y &gt; ff(100)) ? (qualitySettings-&gt;qualityCount-1) : 0;      anErr = AddCollectionItemHdl (   jobCollection,                      gxQualityTag,                      gxPrintingTagID,                      jobQualitySettingsHdl );                               DisposHandle(jobQualitySettingsHdl);      }          if (anErr == noErr)        {        long  formatOptions;                // turn off super-res        formatOptions = 0;        anErr = AddCollectionItem(GXGetFormatCollection(theFormat),           DriverCreator, 0,          sizeof(formatOptions),          &amp;formatOptions);        }      }    }FailedNewHandle:      return(anErr);FailedGetCollectionItemHdl:  DisposHandle(jobQualitySettingsHdl);  return(anErr);  } // SD_DefaultFormat//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr SD_DefaultJob()/*  We override this message to add our default - highest res possible*/{  OSErr  anErr;    anErr = Forward_GXDefaultJob();  if (anErr == noErr)    {    long    imagewriterOptions = kSuperRes;        anErr = AddCollectionItem(GXGetJobCollection(GXGetJob()),           DriverCreator,          0,          sizeof(imagewriterOptions),          &amp;imagewriterOptions);              }  return(anErr);  } // SD_DefaultJob/* ------------------------------------------------------------------------------------  */OSErr SD_OpenConnection(void)/*  The OpenConnection message is sent in order to open the connection to the device.*/{  OSErr  anErr;  SpecGlobalsHdl  hGlobals = (SpecGlobalsHdl)GetMessageHandlerInstanceContext();    // how to process idle events  (**hGlobals).idleError     = noErr;  (**hGlobals).idleQuery     = false;  (**hGlobals).idleTimeout   = 0;  (**hGlobals).timeoutPending = false;    // first, open the connection the standard way  anErr = Forward_GXOpenConnection();  nrequire(anErr, OpenConnection);    // then, bring the configuration file up to date  anErr = UpdateConfiguration();  nrequire(anErr, UpdateConfiguration);  return(noErr);  // EXCEPTION HANDLINGUpdateConfiguration:  GXCleanupOpenConnection();  OpenConnection:  return(anErr);  } // SD_OpenConnection/* ------------------------------------------------------------------------------------  */OSErr SD_CloseConnection(void){  unsigned short  statusReturn;  OSErr      anErr, anErr2;  SpecGlobalsHdl  hGlobals = (SpecGlobalsHdl)GetMessageHandlerInstanceContext();  ResType      commType = (**hGlobals).commType;  if (commType == 'PPTL')    {    // flush out all data so that we can query the printer properly  one last time    anErr = Send_GXWriteData(nil, 0);    nrequire(anErr, Send_GXWriteData1);        // for PAP: bring the configuration file up to date &amp; check that the printer is online    anErr2 = UpdateConfiguration();    if (anErr == noErr) anErr = anErr2;    }  else    {    // for serial: flush out all data so that we can query the printer properly  one last time    anErr = Send_GXWriteData(nil, 0);    nrequire(anErr, Send_GXWriteData2);    // one last time check up on printer status     if ((**hGlobals).isImageWriterII)      {      anErr2 = FetchStatusString(&amp;statusReturn, false, true);      if (anErr == noErr) anErr = anErr2;      }    }  Send_GXWriteData2:Send_GXWriteData1:FetchStatusString:  // close the connection the standard way  anErr2 = Forward_GXCloseConnection();  if (anErr == noErr) anErr = anErr2;      return(anErr);  } // SD_CloseConnection/* ------------------------------------------------------------------------------------  */OSErr SD_JobIdle(){  OSErr      anErr = noErr;  SpecGlobalsHdl  hGlobals = (SpecGlobalsHdl)GetMessageHandlerInstanceContext();  SpecGlobalsPtr  pGlobals;    pGlobals = *hGlobals;  if ( (pGlobals-&gt;idleQuery) &amp;&amp; (pGlobals-&gt;commType == 'PPTL') )    {    unsigned short  statusReturn;    pGlobals-&gt;idleQuery = false;        anErr = FetchStatusString(&amp;statusReturn, true, true);    nrequire(anErr, FetchStatusString);    anErr = Forward_GXJobIdle();    // EXCEPTION HANDLING    FetchStatusString:      pGlobals = *hGlobals;      pGlobals-&gt;idleQuery = true;    }  else      anErr = Forward_GXJobIdle();    // if we continue looping here too long during the initial query -- give the user  // a chance to bail or correct the problem  pGlobals = *hGlobals;  if ( (!(pGlobals-&gt;timeoutPending)) &amp;&amp; (pGlobals-&gt;idleTimeout != 0) )    {    if (TickCount() &gt; pGlobals-&gt;idleTimeout)      {      gxStatusRecord    theStat;      gxStatusRecord    *pStat = &amp;theStat;            pStat-&gt;statusOwner  = 'drvr';      pStat-&gt;statResId   = kDriverStatus;          pStat-&gt;statResIndex = kCheckOnline;            pStat-&gt;bufferLen    = 0;      pStat-&gt;dialogResult = 0;  // ORIGINALLY SET TO ===&gt; nil;                  // tell the user to check the printer      pGlobals-&gt;timeoutPending = true;      (void) GXAlertTheUser(pStat);      pGlobals = *hGlobals;      pGlobals-&gt;timeoutPending = false;              // based on the user's response cancel      switch (pStat-&gt;dialogResult)        {        case ok:          pGlobals-&gt;idleTimeout = TickCount() + kQueryTimeout;          break;                  case cancel:          pGlobals-&gt;idleError = gxPrUserAbortErr;          break;                  case 3:          pGlobals-&gt;idleError = kPutJobOnHoldErr;          break;        }      // display &quot;sending data to the printer&quot; message      if (anErr == noErr)        anErr = GXReportStatus(kDriverStatus, kSendingData);      }    }      if (anErr == noErr)    anErr = pGlobals-&gt;idleError;      return(anErr);  } // SD_JobIdle/* ------------------------------------------------------------------------------------  */OSErr SD_FreeBuffer(gxPrintingBuffer * theBuffer){  OSErr      anErr = noErr;  OSErr      firstError = noErr;  SpecGlobalsHdl  hGlobals = (SpecGlobalsHdl)GetMessageHandlerInstanceContext();    if ((**hGlobals).commType == 'PPTL')    {    unsigned short  statusReturn;    anErr = FetchStatusString(&amp;statusReturn, true, true);    nrequire(anErr, FetchStatusString);    }      do    {    // we can idle query now if we need to      (**hGlobals).idleQuery = true;    // try to send the buffer again    anErr = Forward_GXFreeBuffer(theBuffer);    if (firstError == noErr)      firstError = anErr;      (**hGlobals).idleQuery = false;    // timeout dialog!    if (anErr == gxAioTimeout)      {      gxStatusRecord    theStat;      gxStatusRecord    *pStat = &amp;theStat;            pStat-&gt;statusOwner  = 'drvr';      pStat-&gt;statResId   = kDriverStatus;          pStat-&gt;statResIndex = kCheckOnline;            pStat-&gt;bufferLen    = 0;      pStat-&gt;dialogResult = 0;  // ORIGINALLY SET TO ====&gt; nil;                  // tell the user to check the printer      (void) GXAlertTheUser(pStat);              // based on the user's response cancel      switch (pStat-&gt;dialogResult)        {        case ok:          anErr = gxAioTimeout;          break;                  case cancel:          anErr = gxPrUserAbortErr;          break;                  case 3:          anErr = kPutJobOnHoldErr;          break;        }      }          } while (anErr == gxAioTimeout);    // put down the timeout dialog, if we ever put one up  if (firstError != noErr)    (void) GXReportStatus(kDriverStatus, kSendingData);  // error to return from next idle  (**hGlobals).idleError = anErr;  FetchStatusString:      return(anErr);  } // SD_FreeBuffer/* ------------------------------------------------------------------------------------  */OSErr SD_DumpBuffer(gxPrintingBuffer * theBuffer){  OSErr  anErr;  SpecGlobalsHdl  hGlobals = (SpecGlobalsHdl)GetMessageHandlerInstanceContext();      if ((**hGlobals).commType == 'PPTL')    {    unsigned short  statusReturn;    anErr = FetchStatusString(&amp;statusReturn, true, true);    nrequire(anErr, FetchStatusString);    }  anErr = Forward_GXDumpBuffer(theBuffer);FetchStatusString:      return(anErr);  } // SD_DumpBuffer/* ------------------------------------------------------------------------------------  */OSErr SD_StartSendPage(gxFormat pageFormat)/*  The StartSendPage message is sent just before the page begins to be rendered.    Note that the StartSendPage message will not be sent until imaging/communication  time, so that user interaction alerts are considered okay here*/{  OSErr            anErr = noErr;  gxJob            theJob = GXGetJob();  Collection          jobCollection;  gxPaperType          thePaperType;  gxTrayFeedInfo        trayFeedInfo;  long            itemSize = sizeof(trayFeedInfo);  ResType            commType;  unsigned short        statusReturn;    jobCollection = GXGetJobCollection(theJob);    // cache communications type  commType = (**(SpecGlobalsHdl)GetMessageHandlerInstanceContext()).commType;  if (commType == 'PPTL')    {    anErr = FetchStatusString(&amp;statusReturn, true, true);    nrequire(anErr, FetchStatusString);    }  else    statusReturn = 0;      // check to see if this particular page is to be manually fed  anErr = GetCollectionItem(jobCollection, gxTrayFeedTag, gxPrintingTagID, &amp;itemSize, &amp;trayFeedInfo);  nrequire(anErr, FailedGetCollectionItem);        // manual feed or out of paper?  Time to ask the user what to do  if   (   trayFeedInfo.manualFeedThisPage    ||  ( ( (statusReturn &amp; kOutOfPaperMask) != 0 ) )    )    {    // Wait for all IO to complete, so that we can correctly tell the user what to do.    // Since the WriteData message makes sure all data is flushed before performing the    // IO, this call insures that pending IO is complete.    anErr = Send_GXWriteData(nil, 0);    nrequire(anErr, FlushAllData);    // then, conduct the alert with the user    {    gxStatusRecord    *pStat;        // make a status record containing the request to the user - note that     // we have to make room for ManualFeedRecord OR OutOfPaperRecord, but manual is bigger    pStat = (gxStatusRecord *)NewPtrClear(sizeof(gxStatusRecord)  + sizeof(gxManualFeedRecord));    anErr = MemError();    nrequire(anErr, NewPtrClear);            pStat-&gt;statusOwner  = 'univ';    pStat-&gt;statResId   = gxUnivAlertStatusResourceId;  // we use the built-in status for this    pStat-&gt;dialogResult = 0;  // ORIGINALLY SET TO =====&gt; nil;        if (trayFeedInfo.manualFeedThisPage)      {      gxManualFeedRecord  *pFeed;            pStat-&gt;statResIndex = gxUnivManualFeedIndex;      // status meaning &quot;manual feed alert&quot;      pStat-&gt;bufferLen    = sizeof(gxManualFeedRecord);      pFeed = (gxManualFeedRecord*)&amp;pStat-&gt;statusBuffer;          // we can switch to autofeed if we want - and tell the user what kind of paper to load in      pFeed-&gt;canAutoFeed = true;      GXGetPaperTypeName(thePaperType = GXGetFormatPaperType(pageFormat), pFeed-&gt;paperTypeName);      }    else      {      gxOutOfPaperRecord  *pOut;            pStat-&gt;statResIndex = gxUnivOutOfPaperIndex;      // status meaning &quot;manual feed alert&quot;      pStat-&gt;bufferLen    = sizeof(gxOutOfPaperRecord);            pOut = (gxOutOfPaperRecord*)&amp;pStat-&gt;statusBuffer;      GXGetPaperTypeName(GXGetFormatPaperType(pageFormat), pOut-&gt;paperTypeName);      }          // keep sending the user the alert until either    //  a) the problem resolves itself    //  b) the user responds via the dialog    //  c) some other (fatal) error happens    do      {            // tell the user      anErr = GXAlertTheUser(pStat);            // if the paper got suddenly loaded, do an OK      if (commType == 'PPTL')        {        (void) FetchStatusString(&amp;statusReturn, true, true);        if ((statusReturn &amp; kOutOfPaperMask) == 0)          {          pStat-&gt;dialogResult = ok;          anErr = noErr;          }        }              } while ((anErr == noErr) &amp;&amp; (pStat-&gt;dialogResult == 0));  // ORIGINALLY SET TO ==&gt; (pStat-&gt;dialogResult == nil)    // based on the user's response, continue, cancel, or switch to auto feed    switch ( pStat-&gt;dialogResult )      {      case ok:        // paper is loaded        break;              case cancel:        // user wishes to stop the printing process        anErr = gxPrUserAbortErr;        break;              case gxAutoFeedButtonId:        // do rest of job with auto feed                {        gxPaperFeedInfo paperFeed;                /* Update for job */        paperFeed.autoFeed = true;        (void) AddCollectionItem(jobCollection, gxPaperFeedTag, gxPrintingTagID, sizeof(paperFeed), &amp;paperFeed);        }                /* Update as it may be reused */        trayFeedInfo.manualFeedThisPage = false;  /* Other trayInfo fields are still valid */        (void) AddCollectionItem(jobCollection, gxTrayFeedTag, gxPrintingTagID, sizeof(trayFeedInfo), &amp;trayFeedInfo);                /* Can pass paper type reference as this IS device communication time */        anErr = Send_GXCheckStatus((Ptr) &amp;thePaperType, sizeof(thePaperType), 0, 'univ');                /* No need to reset tray from gxTrayFeedInfo.feedTrayIndex as there is only one tray! */        break;              } // switch                // done with the status now    DisposPtr((Ptr) pStat);    }          } // if manual feed job      // display &quot;sending data to the printer&quot; message  if (anErr == noErr)    anErr = GXReportStatus(kDriverStatus, kSendingData);      nrequire(anErr, FailedWaitForPaper);  // continue with the standard starting of the page  anErr = Forward_GXStartSendPage(pageFormat);        // FALL THROUGH AND HANDLE EXCEPTIONSFailedWaitForPaper:NewPtrClear:FlushAllData:FailedGetCollectionItem:FetchStatusString:  return(anErr);  } // SD_StartSendPage/* ------------------------------------------------------------------------------------  */OSErr SD_FinishSendPage(){  OSErr    anErr = noErr;  Str63    formLength;      // should be more than big enough for form skipping  char    len = 0;  // we may have issued line feeds RIGHT up to the end of the page.  If  // we do that and then issue a form feed, we'll kick out a blank page.  // to avoid that, we back up a tad and then let the normal form feed  // go through.  Option 2 would be to track each and every motion control  // we send to the printer -- but that's more work than this.  In addition,  // this method makes sure we are synced up exactly to the hardware  formLength[len++] = ESCAPE;  formLength[len++] = 'T';  formLength[len++] = '0';  formLength[len++] = '1';  formLength[len++] = ESCAPE;  formLength[len++] = 'r';  formLength[len++] = 0x0A;    // reset to forward motion for the form feed  formLength[len++] = ESCAPE;  formLength[len++] = 'f';    anErr = Send_GXBufferData((char*)&amp;formLength[0], len, gxNoBufferOptions );  nrequire(anErr, Send_GXBufferData);    // Default implementation provides the actual form feed  anErr = Forward_GXFinishSendPage();// FALL THROUGH EXCEPTION HANDLINGSend_GXBufferData:  return(anErr);  } // SD_FinishSendPage/* ------------------------------------------------------------------------------------  */OSErr SD_JobFormatDialog(gxDialogResult*  theResult)/*  This message is sent in response to the user's request to put up a formatting dialog*/{  OSErr           anErr;  gxJobFormatModeTableHdl  theJobFormatModeList;  long          i;  gxJob           theJob = GXGetJob();    // set up the JobFormatMode information    anErr = GXGetAvailableJobFormatModes(&amp;theJobFormatModeList);  if ((!anErr) &amp;&amp; (theJobFormatModeList))    {    for (i = 0; i &lt;= (*theJobFormatModeList)-&gt;numModes - 1; ++i)       {      if ((*theJobFormatModeList)-&gt;modes[i] == gxTextJobFormatMode)         {        GXSetPreferredJobFormatMode(gxTextJobFormatMode, false);        break;        }      }    DisposHandle((Handle)theJobFormatModeList);    }      // do the normal dialogs after handling the job format mode stuff  return(Forward_GXJobDefaultFormatDialog(theResult));  } // SD_JobFormatModeQuery/* ------------------------------------------------------------------------------------  */OSErr SD_JobFormatModeQuery(  gxQueryType    theQuery,                void*      srcData,                void*      dstData)/*  This message is sent to find out information about the current job format mode.*/{  OSErr    anErr = noErr;  Handle    theFonts;  Handle    theStyles;    // What type of query is being requested?  switch(theQuery)   {    case gxSetStyleJobFormatCommonStyleQuery:    {      char        *pStyleName;      // Fetch the list of supported styles            anErr = Send_GXFetchTaggedDriverData('STR#', kFormatModeStylesID, &amp;theStyles);      require(anErr == noErr, FailedToLoadStyles1);            HNoPurge(theStyles);      HLock(theStyles);            // Determine which style is being referenced and set the corresponding style (only 2 styles      // are currently supported)            if (**((short **) theStyles) == 2)  //  T =&gt; We have the correct number of styles      {        char    whichFace = 0;                pStyleName = ((char *) *theStyles) + sizeof(short);                 if ( IUCompString((ConstStr255Param)pStyleName, (ConstStr255Param)srcData) == 0 )  //  T =&gt; They want bold face        {          whichFace = bold;        }        else        {          // Point to the next name in the list          pStyleName += *pStyleName + 1;          if ( IUCompString((ConstStr255Param)pStyleName, (ConstStr255Param)srcData) == 0 )  //  T =&gt; They want underline face          {            whichFace = underline;          }        }        //  If the client specified a valid face, set it now        if (whichFace != 0)        {          SetStyleCommonFace((gxStyle) dstData, GetStyleCommonFace((gxStyle) dstData) | whichFace);        }      }      // else - something is wrong with our resource            // Dump the temporary handle      DisposHandle(theStyles);            break;    }          case gxGetJobFormatFontCommonStylesQuery:    {      short        numStyles;      short        i;      char        *pStyleName;      // Fetch the list of supported styles            anErr = Send_GXFetchTaggedDriverData('STR#', kFormatModeStylesID, &amp;theStyles);      require(anErr == noErr, FailedToLoadStyles2);            HNoPurge(theStyles);      HLock(theStyles);            // Determine the number of styles in the list      numStyles = **((short **) theStyles);      if (*(Handle *)dstData != nil)  //  T =&gt; Resize the handle to hold info. on the styles        SetHandleSize(*(Handle *)dstData, sizeof(gxStyleNameTable) + ((numStyles - 1) * sizeof(Str255)));      else        *(Handle *)dstData = NewHandle(sizeof(gxStyleNameTable) + ((numStyles - 1) * sizeof(Str255)));            anErr = MemError();      require(anErr == noErr, StyleTableResizeFailed);            // Now extract the name of each of the supported fonts            for (i = 1, pStyleName = ((char *) *theStyles) + sizeof(short); i &lt;= numStyles; ++i, pStyleName += *pStyleName + 1)      {        BlockMove(pStyleName, (*((gxStyleNameTableHdl) *(Handle *)dstData))-&gt;styleNames[i - 1], *pStyleName + 1);      }            (*((gxStyleNameTableHdl) *(Handle *)dstData))-&gt;numStyleNames = numStyles;            // Dump the temporary handle      DisposHandle(theStyles);            break;    }          case gxGetJobFormatLineConstraintQuery:      //  This type of query is not supported      if (*(Handle *)dstData != nil)        SetHandleSize(*(Handle *)dstData, 0);    // Don't return any data      break;          case gxGetJobFormatFontsQuery:    {      short        numFonts;      short        i;      char        *pFontName;      // Fetch the list of supported fonts            anErr = Send_GXFetchTaggedDriverData('STR#', kFormatModeFontsID, &amp;theFonts);      require(anErr == noErr, FailedToLoadFonts);            HNoPurge(theFonts);      HLock(theFonts);            // Determine the number of fonts in the list      numFonts = **((short **) theFonts);      if (*(Handle *)dstData != nil)  //  T =&gt; Resize the handle to hold info. on the fonts        SetHandleSize(*(Handle *)dstData, sizeof(gxFontTable) + ((numFonts - 1) * sizeof(gxFont)));      else        *(Handle *)dstData = NewHandle(sizeof(gxFontTable) + ((numFonts - 1) * sizeof(gxFont)));            anErr = MemError();      require(anErr == noErr, FontTableResizeFailed);            // Now generate a reference to each of the supported fonts            for (i = 1, pFontName = ((char *) *theFonts) + sizeof(short); i &lt;= numFonts; ++i, pFontName += *pFontName + 1)      {        gxFont      thisFont;        gxFontTable    *pFontTable;              //   ORIGINAL CODE        //  thisFont = FindPNameFont(gxFullFontName, (ConstStr255Param)pFontName);        // END OF ORIGINAL CODE                // CODE ADDED IN FROM GX FONTLIBRARY.C AS THINK C WON'T COMPILE LIBRARY          GXFindFonts(0, gxFullFontName,                gxMacintoshPlatform,                gxRomanScript,                gxEnglishLanguage,                pFontName[0], (ConstStr255Param)pFontName, 1, 1, &amp;thisFont);          // ENDCODE ADDED IN FROM LIBRARY                pFontTable = *((gxFontTableHdl) *(Handle *)dstData);        pFontTable-&gt;fonts[i - 1] = thisFont;      }            (*((gxFontTableHdl) *(Handle *)dstData))-&gt;numFonts = numFonts;            // Dump the temporary handle      DisposHandle(theFonts);      break;    }          case gxGetJobFormatFontConstraintQuery:    {      gxPositionConstraintTable    *pPositionTable;            if ( *(Handle *)dstData != nil)  //  T =&gt; Resize the handle to hold info. on position constraints        SetHandleSize(*(Handle *)dstData, sizeof(gxPositionConstraintTable) + sizeof(Fixed));      else        *(Handle *)dstData = NewHandle( sizeof(gxPositionConstraintTable) + sizeof(Fixed) );            pPositionTable = *((gxPositionConstraintTableHdl) *(Handle *)dstData);            pPositionTable-&gt;phase.x   = 0;        //  Start at the top left corner of the page      pPositionTable-&gt;phase.y   = 0;      pPositionTable-&gt;offset.x   = ff(12);    // Indent from the top left by a six lines per inch margin      pPositionTable-&gt;offset.y   = ff(12);           pPositionTable-&gt;numSizes   = 2;        // Two font sizes supported      pPositionTable-&gt;sizes[0]   = ff(10);     // 10 pitch      pPositionTable-&gt;sizes[1]   = ff(12);     // 12 pitch            break;    }  } // switch    return(anErr);  /******* Clean-up *******/StyleTableResizeFailed:  DisposHandle((Handle) theStyles);  return(anErr);FontTableResizeFailed:  DisposHandle((Handle) theFonts);FailedToLoadStyles1:FailedToLoadStyles2:FailedToLoadFonts:  return(anErr);  } // SD_JobFormatModeQuery//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr SD_SetupImageData(  gxRasterImageDataHdl hImageData)    // raster image data stuff/*  This message is called to setup the constant data used for imaging the entire job.*/{  SpecGlobalsHdl         hGlobals = GetMessageHandlerInstanceContext();  OSErr            anErr;  gxRasterImageDataPtr    pImageData;  Boolean           isJobNotFinalQuality;  Boolean           isTextJobFormatMode;  long            imagewriterOptions;  short                       count;  Handle                      draftTable;    CMYKRenderCollection planes;  long             itemSize = sizeof(CMYKRenderCollection);  Collection           jobCollection;  gxJob         theJob;    gxSetColor        theColors[9];  gxColorSet        theSet;  short          idx;  gxPlaneSetupRec     *pOnePlane;// do the default setup  anErr = Forward_GXSetupImageData(hImageData);  nrequire(anErr, Forward_GXSetupImageData);  // test for 'final' quality mode  isJobNotFinalQuality = !JobIsBest(&amp;imagewriterOptions);  // test for textJobFormatMode  isTextJobFormatMode = ( GXGetJobFormatMode( GXGetJob() ) == gxTextJobFormatMode);      // if the job is not final quality or using textJobFormatMode,//               downgrade the imaging data to our lower quality  if (isJobNotFinalQuality  ||  isTextJobFormatMode)  {//// ROUGH OR TEXT MODE//      // dereference for size and speed      pImageData = *hImageData;          // image at 80 or 72 dpi    if (imagewriterOptions &amp; kSuperRes)      pImageData-&gt;hImageRes = ff(80);    else      pImageData-&gt;hImageRes = ff(72);    pImageData-&gt;vImageRes = ff(72);      // textJobFormatMode loads up the draft table, else setup halftones    if (isTextJobFormatMode)    {      anErr = Send_GXFetchTaggedDriverData('idft', gxPrintingDriverBaseID, &amp;draftTable);      nrequire(anErr, FailedToLoadDraftTable);          // store away the draft table      (**hGlobals).draftTable = draftTable;    // Download something?        anErr = Send_GXFetchTaggedDriverData('idft', gxPrintingDriverBaseID+1, &amp;draftTable);      if (anErr == resNotFound)      {        draftTable = nil;        anErr = noErr;      }      nrequire(anErr, GetDownloadTable);            if (draftTable)      {        HLock(draftTable);        anErr = Send_GXBufferData(*draftTable, GetHandleSize(draftTable), gxDontSplitBuffer);        DisposHandle(draftTable);        nrequire(anErr, SendDownloadTable);      }    }    else    {        // use dither level that will look better at 72 dpi   // resolution than our default values (MAYBE: 4 is the default now anyway)      pImageData-&gt;theSetup.planeSetup[0].planeHalftone.method = 4;        // of course, turn off color matching when in non-final mode!      pImageData-&gt;theSetup.planeSetup[0].planeProfile = nil;    }          if (isJobNotFinalQuality)    {      if (imagewriterOptions &amp; kSuperRes)      {    // use bidirectional instead of unidirectional    // and also &lt;esc&gt;N instead of &lt;esc&gt;p for quality mode        pImageData-&gt;packageControls.startPageStringID = gxPrintingDriverBaseID+3;      }      else      {    // use bidirectional instead of unidirectional    // and also &lt;esc&gt;n instead of &lt;esc&gt;p for quality mode            pImageData-&gt;packageControls.startPageStringID = gxPrintingDriverBaseID+2;      }    }      // packaging data    pImageData-&gt;packagingInfo.headHeight     = 8;    // 8 pins (instead of 16)    pImageData-&gt;packagingInfo.numberPasses     = 1;    // in 1 head pass (instead of 2)    pImageData-&gt;packagingInfo.passOffset     = 0;    // with no space between passes  }  else  {//// FINAL QUALITY//  // dereference for size and speed      pImageData = *hImageData;          // image at 160 or 144 dpi    if (imagewriterOptions &amp; kSuperRes)    {      pImageData-&gt;hImageRes = ff(160);      pImageData-&gt;packageControls.startPageStringID = gxPrintingDriverBaseID+1;    }    else    {      pImageData-&gt;hImageRes = ff(144);      pImageData-&gt;packageControls.startPageStringID = gxPrintingDriverBaseID+0;    }  }  // not a color ribbon?  Setup for black and white - do a B/W halftone rather than a dither  if (!PrinterHasColorRibbon(GXGetJobOutputPrinter(GXGetJob())))  {// dereference for size and speed      pImageData = *hImageData;// one plane, no color flags, move the halftone info up into correct position    pImageData-&gt;theSetup.planes = 1;    pImageData-&gt;theSetup.depth = 1;    pImageData-&gt;packagingInfo.colorPasses = 1;    pImageData-&gt;packagingInfo.packageOptions = 0;    pImageData-&gt;theSetup.planeSetup[0].planeSpace = gxNoSpace;    pImageData-&gt;theSetup.planeSetup[0].planeSet = nil;    pImageData-&gt;theSetup.planeSetup[0].planeProfile = nil;    pImageData-&gt;theSetup.planeSetup[0].planeOptions = gxDefaultOffscreen;    pImageData-&gt;theSetup.planeSetup[0].planeHalftone.method = gxRoundDot;    pImageData-&gt;theSetup.planeSetup[0].planeHalftone.tintSpace = gxRGBSpace;  }  else  {// It has a color ribon, so if it has a render options collection, then set up the options// approriately.// First, see if the job has render options    theJob = GXGetJob();    jobCollection = GXGetJobCollection(theJob);    if (!GetCollectionItem( jobCollection,                 kCMYKRenderCollectionType, kCMYKRenderCollectionID,                 &amp;itemSize, &amp;planes))    {      pImageData = *hImageData;                if (planes.renderMode == kDitherIt)      {//// Dither setup//  // Create a color set        for (idx = 0; idx &lt; 9; ++idx)          {        // default the color to black          theColors[idx].rgba.red            = theColors[idx].rgba.green            = theColors[idx].rgba.blue            = theColors[idx].rgba.alpha = 0x0000;                  // and give it componants to go along with this index          if (   (idx == 0)            || (idx == 1)            || (idx == 2)            || (idx == 3)            || (idx == 7))            theColors[idx].rgba.red   = 0xFFFF;          if (   (idx == 0)            || (idx == 1)            || (idx == 4)            || (idx == 5)            || (idx == 7))            theColors[idx].rgba.green   = 0xFFFF;          if (   (idx == 0)            || (idx == 2)            || (idx == 4)            || (idx == 6)            || (idx == 7))            theColors[idx].rgba.blue   = 0xFFFF;                      }        theSet = GXNewColorSet(gxRGBSpace, 9, theColors);// Step through each plane, setting up the appropriate values        for (count = 0; count &lt; 4; ++count)        {    // dereference for size and speed                pOnePlane = &amp;(pImageData-&gt;theSetup.planeSetup[count]);              // Set up the options for dithering          pOnePlane-&gt;planeOptions = gxDontSetHalftone + gxDotTypeIsDitherLevel;    // Angle and frequency are not used when dithering          pOnePlane-&gt;planeHalftone.angle     = 0;          pOnePlane-&gt;planeHalftone.frequency = 0;              // When the planeOption's gxDotTypeIsDitherLevel flag is set, then planeHalftone.method    // is used for the dither level              pOnePlane-&gt;planeHalftone.method  = planes.ditherLevel;        // Set default for luminance          pOnePlane-&gt;planeHalftone.tinting = gxLuminanceTint;      // Set up the dot color          pOnePlane-&gt;planeHalftone.dotColor.space              = gxRGBSpace;          pOnePlane-&gt;planeHalftone.dotColor.profile            = nil;                // default each plane to 0          pOnePlane-&gt;planeHalftone.dotColor.element.rgba.red              = pOnePlane-&gt;planeHalftone.dotColor.element.rgba.green              = pOnePlane-&gt;planeHalftone.dotColor.element.rgba.blue              = pOnePlane-&gt;planeHalftone.dotColor.element.rgba.alpha              = 0;          if (   (count == 0)            || (count == 1))            pOnePlane-&gt;planeHalftone.dotColor.element.rgba.red   = 0xFFFF;          if (   (count == 0)            || (count == 2))            pOnePlane-&gt;planeHalftone.dotColor.element.rgba.green   = 0xFFFF;          if (   (count == 2)            || (count == 3))            pOnePlane-&gt;planeHalftone.dotColor.element.rgba.blue   = 0xFFFF;      // Set up the background dot color          pOnePlane-&gt;planeHalftone.backgroundColor.space              = gxRGBSpace;          pOnePlane-&gt;planeHalftone.backgroundColor.profile            = nil;          pOnePlane-&gt;planeHalftone.backgroundColor.element.rgba.red            = pOnePlane-&gt;planeHalftone.backgroundColor.element.rgba.green            = pOnePlane-&gt;planeHalftone.backgroundColor.element.rgba.blue            = pOnePlane-&gt;planeHalftone.backgroundColor.element.rgba.alpha            = 0xFFFF;      // Set up for an RGB tint space          pOnePlane-&gt;planeHalftone.tintSpace = gxRGBSpace;    // And an indexed plane space          pOnePlane-&gt;planeSpace    = gxIndexedSpace;    // Set up the plane to the same as the one we just created          pOnePlane-&gt;planeSet     = theSet;    // no color profile so set to nil          pOnePlane-&gt;planeProfile = nil;        }      }      else      {//// Half-Tone setup//        for (count = 0; count &lt; 4; ++count)        {    // dereference for size and speed                pOnePlane = &amp;(pImageData-&gt;theSetup.planeSetup[count]);      // Set up the options for halftonning...gxDefaultOffscreen          pOnePlane-&gt;planeOptions = gxDefaultOffscreen;    // Set this dot type from the collection          pOnePlane-&gt;planeHalftone.method    = planes.dotType;    // Set this planes angle and frequency from the collection    // and the appropriate tint for this plane          switch (count+1) {            case (kYellowPass) :               pOnePlane-&gt;planeHalftone.angle     = planes.angles   [kRenderOptsYellow];              pOnePlane-&gt;planeHalftone.frequency = planes.frequency[kRenderOptsYellow];              pOnePlane-&gt;planeHalftone.tinting   = gxComponent3Tint;              break;            case (kMagentaPass) :               pOnePlane-&gt;planeHalftone.angle     = planes.angles   [kRenderOptsMagenta];              pOnePlane-&gt;planeHalftone.frequency = planes.frequency[kRenderOptsMagenta];              pOnePlane-&gt;planeHalftone.tinting   = gxComponent2Tint;              break;            case (kCyanPass) :               pOnePlane-&gt;planeHalftone.angle     = planes.angles   [kRenderOptsCyan];              pOnePlane-&gt;planeHalftone.frequency = planes.frequency[kRenderOptsCyan];              pOnePlane-&gt;planeHalftone.tinting   = gxComponent1Tint;              break;            case (kBlackPass) :               pOnePlane-&gt;planeHalftone.angle     = planes.angles   [kRenderOptsBlack];              pOnePlane-&gt;planeHalftone.frequency = planes.frequency[kRenderOptsBlack];              pOnePlane-&gt;planeHalftone.tinting   = gxComponent4Tint;              break;          }    // Set up the dot color to black          pOnePlane-&gt;planeHalftone.dotColor.space              = gxRGBSpace;          pOnePlane-&gt;planeHalftone.dotColor.profile            = nil;          pOnePlane-&gt;planeHalftone.dotColor.element.rgba.red            = pOnePlane-&gt;planeHalftone.dotColor.element.rgba.green            = pOnePlane-&gt;planeHalftone.dotColor.element.rgba.blue            = pOnePlane-&gt;planeHalftone.dotColor.element.rgba.alpha            = 0;      // Set up the background dot color to white          pOnePlane-&gt;planeHalftone.backgroundColor.space              = gxRGBSpace;          pOnePlane-&gt;planeHalftone.backgroundColor.profile            = nil;          pOnePlane-&gt;planeHalftone.backgroundColor.element.rgba.red            = pOnePlane-&gt;planeHalftone.backgroundColor.element.rgba.green            = pOnePlane-&gt;planeHalftone.backgroundColor.element.rgba.blue            = pOnePlane-&gt;planeHalftone.backgroundColor.element.rgba.alpha            = 0xFFFF;      // Set up for an CMYK tint space          pOnePlane-&gt;planeHalftone.tintSpace = gxCMYKSpace;    // No explicit color space          pOnePlane-&gt;planeSpace   = gxNoSpace;        // No color set          pOnePlane-&gt;planeSet     = nil;    // No profile specified          pOnePlane-&gt;planeProfile = nil;        }      }    }  }  return(noErr);  // EXCEPTION HANDLINGSendDownloadTable:GetDownloadTable:  DisposHandle((**hGlobals).draftTable);  (**hGlobals).draftTable = nil;  FailedToLoadDraftTable:Forward_GXSetupImageData:  return(anErr);  } // SD_SetupImageData/* ------------------------------------------------------------------------------------  */OSErr SD_FetchDriverData(  ResType      theType,  short      theID,  Handle*      theData){  OSErr  anErr;    anErr = Forward_GXFetchTaggedDriverData(theType, theID, theData);    // do the translation at the proper DPI by modifying the old API  // customization resource  if ( (anErr   == noErr)    &amp;&amp;         // got the resource okay     (theType == 'cust')   &amp;&amp;        // it was a customization resource      (theID   == -8192)   )          // with the old API id    {    long imagewriterOptions;        if (!JobIsBest(&amp;imagewriterOptions))      {      **((short**)theData)   = 72;      **((short**)theData+1) = 72;      }    }      return(anErr);  } // SD_FetchDriverData/* ------------------------------------------------------------------------------------  */OSErr SD_RenderPage(  gxFormat        theFormat,            gxShape          thePage,            gxPageInfoRecord    *pageInfo,            gxRasterImageDataHdl  imageInfo)/*  The message sent to render an entire page.*/{  OSErr  theError = noErr;  // if not text mode, do it the normal (raster) way  if (GXGetJobFormatMode(GXGetJob()) != gxTextJobFormatMode)     {    gxRectangle      paperSize;    Str63        formLength;      // should be more than big enough for form skipping    char        aNumber[8];    char        len = 0;    short        formLen;      // form length (in 144 dpi)    short        i;            // find out how big our paper is    GXGetPaperTypeDimensions(GXGetFormatPaperType(theFormat), nil, &amp;paperSize);        // determine the left margin (in pixels)    {    SpecGlobalsHdl       hGlobals = GetMessageHandlerInstanceContext();    SpecGlobalsPtr      pGlobals;    gxRasterImageDataPtr  pImageData;    // dereference for size and speed      pImageData   = *imageInfo;    pGlobals = *hGlobals;    paperSize.left += ff(18);    // ImageWriter's can't go tighter than .25 inch    if (paperSize.left &gt; 0)      paperSize.left = 0;    pGlobals-&gt;leftMargin   = FixedToInt(                  FixMul(-paperSize.left,                     FixDiv(pImageData-&gt;hImageRes, ff(72))));        // set this to be the top of form    formLength[len++] = ESCAPE;    formLength[len++] = 'v';    // set the form length to be the size of the page iff ImageWriterII    if (pGlobals-&gt;isImageWriterII)      {      formLength[len++] = ESCAPE;      formLength[len++] = 'H';      formLen = FixedToInt(FixMul(paperSize.bottom-paperSize.top, ff(2)) );  // length is set in 144 dpi      NumToString(formLen, (unsigned char*)aNumber);      for (i = 0; i &lt; 4-aNumber[0]; ++i)        formLength[len++] = '0';      for (i = 1; i &lt;= aNumber[0]; ++i)        formLength[len++] = aNumber[i];      }    }    // NOW: move over the top margin    formLen = -FixedToInt( FixMul(paperSize.top, ff(2)) );          // Forward line feed      formLength[len++] = ESCAPE;      formLength[len++] = 'f';      // send multiples of 99      if (formLen &gt;= 99)        {        formLength[len++] = ESCAPE;        formLength[len++] = 'T';        formLength[len++] = '9';        formLength[len++] = '9';        while (formLen &gt;= 99)          {          formLength[len++] = 0x0A;    // line feed                    formLen -= 99;          }        }              // send remaining line feeds      if (formLen &gt; 0)        {        formLength[len++] = ESCAPE;        formLength[len++] = 'T';        NumToString(formLen, (unsigned char*)aNumber);        if (aNumber[0] == 1)          {          formLength[len++] = '0';          formLength[len++] = aNumber[1];          }        else          {          formLength[len++] = aNumber[1];          formLength[len++] = aNumber[2];          }        formLength[len++] = 0x0A;    // line feed        }    // we've got all of this data, now send it    theError = Send_GXBufferData((char*)formLength, len, gxNoBufferOptions );    nrequire(theError, SetFormLength);                // continue with normal rendering    theError = Forward_GXRenderPage(theFormat, thePage, pageInfo, imageInfo);    }   else     {    theError = PrintPageInDraftMode(thePage, imageInfo);    }failed_WrongShape:SetFormLength:  return(theError);  } // SD_RenderPage//&lt;FF&gt;/* ------------------------------------------------------------------------------------  *//*  SPECIFIC DRIVER RASTER OVERRIDES                          *//* ------------------------------------------------------------------------------------  */OSErr SD_LineFeed (  long *lineFeedSize,             // amount to line feed by  Ptr buffer, unsigned long  * bufferPos,   // data goes here  gxRasterImageDataHdl hImageData)      // raster image data stuff/*  Message is sent to output paper advance commands to the printer*/{  OSErr  anErr;  Boolean  amLowRes;  long  actualLineFeed = *lineFeedSize;  amLowRes = ((**hImageData).vImageRes == ff(72));  // if we are in low res mode, we double the line feed size, as all ImageWriter   // line feed commands are expressed at 144 dpi.  if (amLowRes)    *lineFeedSize &lt;&lt;= 1;    // optimize small motions (particularlly -1 followed by +1 with no data between)  // into groups.  This gets rid of the &quot;paper dance&quot; for blank colors passes.  {    SpecGlobalsHdl  hGlobals = GetMessageHandlerInstanceContext();  SpecGlobalsPtr  pGlobals = *hGlobals;    if (  (pGlobals-&gt;packagingOptions == kDoSmallLineFeeds) ||       (*lineFeedSize &lt; -1) ||       (*lineFeedSize &gt; 1) )    {    *lineFeedSize += pGlobals-&gt;lineFeeds;    pGlobals-&gt;lineFeeds = 0;    // do the line feed in the default way    anErr = Forward_GXRasterLineFeed(lineFeedSize, buffer, bufferPos, hImageData);    }  else    {    pGlobals-&gt;lineFeeds += *lineFeedSize;    *lineFeedSize = 0;    anErr = noErr;    }  }    // and if in low quality mode, we divide the result to make up for the multiplication  // that we do above  if (amLowRes)    *lineFeedSize &gt;&gt;= 1;          return(anErr);  } // SD_LineFeed//&lt;FF&gt;//-------------------------------------------------------------------// PrintThisBand//// Gets the render options collection, and tests the current printer// band against it to see if it needs to draw this band//-------------------------------------------------------------------Boolean PrintThisBand ( short printerBand ){  Boolean         displayPlane = true;  OSErr          theErr;  CMYKRenderCollection   planes;  Collection         jobCollection;  long          itemSize = sizeof(CMYKRenderCollection);  gxJob          theJob;    theJob = GXGetJob();  jobCollection = GXGetJobCollection(theJob);  theErr = GetCollectionItem( jobCollection,                 kCMYKRenderCollectionType, kCMYKRenderCollectionID,                 &amp;itemSize, &amp;planes);  nrequire(theErr, FailedGetCollectionItem);  if (!theErr)  {    switch (printerBand){      case kYellowPass  : displayPlane = planes.yellowIsOn;        break;      case kMagentaPass : displayPlane = planes.magentaIsOn;        break;      case kCyanPass    : displayPlane = planes.cyanIsOn;        break;      case kBlackPass   : displayPlane = planes.blackIsOn;        break;    }  }FailedGetCollectionItem:  return displayPlane;}//&lt;FF&gt;/* ------------------------------------------------------------------------------------  */// This macro stores one group into the pointer://  P = Pointer to fill into//  G = Character for group//  S = Length of group run in pixels#define EMITGROUP(P, G, S)          \    P-&gt;cEscape = ESCAPE;        \    P-&gt;cCommand = G;          \    Long2Dec(S, P-&gt;cLineLength);    //&lt;FF&gt;/* ------------------------------------------------------------------------------------  */OSErr SD_PackageBitmap (  gxRasterPackageBitmapRec  *pPackage,  Ptr             buffer,   // data goes here + bufferPos  unsigned long         *bufferPos,  // how much of the buffer already is full  gxRasterImageDataHdl     hImageData)  // private image data/*  Packages a bitmap for the ImageWriter  This routine is called in order to add your rotated and packaged pixel  data to the buffer.  It is called once for each head pass.  This routine  is pretty complex because it also does IW run length compression.   It has also been modified so it can handle color seperations. It does this by  by comparing the color of the current pass to the render options collection.  This is done by PrintThisBand().    It must do the following:      1)  Start filling the buffer from buffer+bufferPos.  Remember    that this pointer may not be word aligned - so be careful    assigning things into it.      2)  If your printer does SetMargins, put a &quot;fake&quot; set of commands at    the begining of the data.  Since most of the time you don't    know the margins, you can save away the value of the bufferPos,    and backpatch it after you have finished with the offscreen.    SetMargins is used on printers that allow you to not send starting    and ending whitespace.      3)  Add in the rotated data for your printer.  The data to stuff starts    at location startY in hOffscreen.  Stuff the bits from here until    you reach startY+&lt;your band size&gt;, which is the size of your single    band in this resolution mode.  Increment your number by     &lt;your pass offset&gt; + 1, which is the number of microspaces    you will send between head passes to form this band.   Take care    that you don't step off of the end of the offscreen in this operation,    you may be called with startY at the end of the offscreen if the first part    of the band is white.        colorBand contains the color band which you should be stuffing, from    1 to the number of color passes your printer needs (usually 4).    Pack in the correct color band.  The packager will call you once    for each color band, and correctly handle line feeds and backward    line feeds to do the correct thing.  If your printer takes full    RGB or CYMK data, I would define your number of colors to be    1 and pack the full RGB or CYMK data with the one call to StuffBuffers.        If you request kSendAllColors in your raster pack resource, then this    message will always be called for all color passes, even those that    do not have data on them.  For some printers, this is useful.  For the    case of the ImageWriter, this option is not specified, so this message    will only be sent for colors that actually have dirty bits within them.      4)  Backpatch SetMargins from your saved value in step 2) now that you    know the margins.      5)  Increment bufferPos by the number of bytes you have    added to the buffer.  Be sure to take into account the Set Margins    command if you added one.  */{// #pragma unused (isColorDirty)  OSErr          anErr;          // would you beleive we could make mistakes?  ScanLinePtr        pTheScanLine;      // Pointer to the start of scan line data  unsigned short      lastDirtyCol;      // Last dirty part of the scan line  unsigned short      firstDirty;        // First dirty pixel  unsigned short      lastDirty;        // Last dirty pixel  Boolean          bandIsDirty;      // Is this band dirty?  unsigned short      numberBytesAdded;    // Number of bytes we have added to the row  unsigned short      repeatCount;      // Number of times we have seen this bitmap    register unsigned short  whichCol;        // Index into the scan line data  register unsigned short  x,y;          // Index values into the offscreen      register Ptr      thePtr;          // Pointer to each Y scanline  register unsigned char  tempColumn;        // Placeholder for the working column  unsigned char      lastColumn;        // What was in the contents of the last column?    Ptr            basePtr;        // Pointer to current X byte  unsigned char      outputMask;        // Mask of bit to set in rotated image  unsigned char      inputMask;        // Mask of bit to look at in X  unsigned char      startingInputMask;    // Mask of first bit of interest  unsigned short      yPointerOffset;      // Increment pointer by this to get to next scanline    unsigned short      endY, endX, incrY;    // To remove loop invariants.  unsigned short      packingColor;      // number of colors packing  unsigned long       originalBufferPos;    // where we were in the buffer before we started;  long          originalLineFeeds;    // how many line feeds did we have before?  SpecGlobalsHdl      hGlobals;  SpecGlobalsPtr      pGlobals;  SetMarginsPtr        marginBuffer;// Get the globals  hGlobals = GetMessageHandlerInstanceContext();  pGlobals = *hGlobals;  // save away original position in order to do a restore should the band be clean  originalBufferPos = *bufferPos;  originalLineFeeds = pGlobals-&gt;lineFeeds;  if (originalLineFeeds == 0)  {    anErr = noErr;  }  else  {// if we have any extra line feeds saved up, do them now!      pGlobals-&gt;lineFeeds = 0;    pGlobals-&gt;packagingOptions = kDoSmallLineFeeds;    anErr = Send_GXRasterLineFeed((long*)&amp;originalLineFeeds, buffer, bufferPos, hImageData);    pGlobals = *hGlobals;    pGlobals-&gt;packagingOptions = kNoPackagingOptions;  }  nrequire(anErr, SendInitialLineFeeds);  // See if we need to print this color band  if (   (  (*hImageData)-&gt;packagingInfo.colorPasses == 4)    &amp;&amp; (! PrintThisBand ( pPackage-&gt;colorBand )) )    bandIsDirty = false;  else  {  // Set color if ImageWriterII    if ((**hGlobals).isImageWriterII)    {      pTheScanLine = (ScanLinePtr) (buffer + kSetMarginsSize + (*bufferPos));        // Set color mode for this scan line, if needed      pTheScanLine-&gt;cColorEscape    = ESCAPE;      pTheScanLine-&gt;cSetColorCommand  = kSetColorCommand;            packingColor = (*hImageData)-&gt;packagingInfo.colorPasses;      if (packingColor == 4)      {        switch (pPackage-&gt;colorBand)        {          case kYellowPass:            pTheScanLine-&gt;cColor  = '1';            startingInputMask = 0x10;            break;                      case kMagentaPass:            pTheScanLine-&gt;cColor  = '2';            startingInputMask = 0x20;            break;                      case kCyanPass:            pTheScanLine-&gt;cColor  = '3';            startingInputMask = 0x40;            break;                      case kBlackPass:            pTheScanLine-&gt;cColor  = '0';            startingInputMask = 0x80;            break;                }      }      else      {        pTheScanLine-&gt;cColor = '0';        startingInputMask = 0x80;      }    }    else  // Backup to eliminate cColorEscape, cSetColorCommand and cColor    {      pTheScanLine = (ScanLinePtr) (buffer + kSetMarginsSize + (*bufferPos) - 3);      packingColor = (*hImageData)-&gt;packagingInfo.colorPasses;      startingInputMask = 0x80;    }  // Start with the first bit in the offscreen     inputMask = startingInputMask;    // We start out with no dirty bits     firstDirty = 0;    lastDirty = 0;    bandIsDirty = false;    // Set our array index to zero     whichCol = 0;    lastDirtyCol = 0;    numberBytesAdded = 0;    // Set up RLL variables     repeatCount = 0;    lastColumn = 0;    // Get the byte pointer for the start of this color band     basePtr = pPackage-&gt;bitmapToPackage-&gt;image;    // Get the byte pointer for the start of the first scan line      basePtr += pPackage-&gt;startRaster * pPackage-&gt;bitmapToPackage-&gt;rowBytes;    // Save away loop invariants     endY   = pPackage-&gt;startRaster + (*hImageData)-&gt;packagingInfo.headHeight;   // Ending scan line    incrY   = (*hImageData)-&gt;packagingInfo.passOffset + 1;      // Number of scanlines to increment by    endX   = pPackage-&gt;dirtyRect.right;              // Ending X pos    yPointerOffset = incrY * pPackage-&gt;bitmapToPackage-&gt;rowBytes;  // amount to add to the input// pointer to move to the next scanline    // If the ending position is too large for the bitmap we have been given,//  truncate it, so that we don't print garbage    if (endY &gt; pPackage-&gt;bitmapToPackage-&gt;height)      endY = pPackage-&gt;bitmapToPackage-&gt;height;    // For the entire width of the offscreen, move a rolling mask along in the// X direction, rotating up 8 bits of Y data per column.  In addition, compress// runs of columns that are &gt; 14 length.     for (x = 0; x &lt; endX; x++)    {      // The bits in this column are clear to begin with       tempColumn = 0;        // Which byte to look at in the input buffer       thePtr = basePtr;        //   Where to place the bit in the output. The ImageWriter takes the bit  //  pattern upside down.       outputMask = 0x01;        // Scan through this band, setting each of the 8 bits == the bit in that scan line       for (y = pPackage-&gt;startRaster; y &lt; endY; y += incrY)      {  // If we have a bit in the input, rotate it into the output         if ((*thePtr) &amp; inputMask)          tempColumn |= outputMask;          // move onto next position in the output data                outputMask &lt;&lt;= 1;          // move onto the next scan line in the input data        thePtr += yPointerOffset;      } // for y              // Save the column info        pTheScanLine-&gt;iTheData[whichCol] = tempColumn;        // Get the next bit from the current pointer       inputMask &gt;&gt;= packingColor;      if (!inputMask)      {  // If we run out of bits, get the next byte         basePtr++;        // And reset the bit mask to the first bit         inputMask = startingInputMask;      }        // If we have some form of data       if (tempColumn != 0)      {        if (!bandIsDirty)        {  // This is the first dirty pixels we have so far           bandIsDirty = true;          firstDirty = x;        }        // This is also the last dirty pixels so far         lastDirty = x;      } // SetDirty        // If we have some dirty bits       if (bandIsDirty)      {  // Move on to the next column         whichCol++;          // If this is a dirty column, then it is the last one so far         if (tempColumn != 0)          lastDirtyCol = whichCol;          // If we have a duplication, up the repeat count         if (tempColumn == lastColumn) // if (false) // turn off repeat groups        {          repeatCount++;          if (repeatCount == 14)          {  // Kick out the old group             whichCol -= 14;            EMITGROUP(pTheScanLine, kGraphicsCommand, whichCol);            numberBytesAdded += whichCol + kGroupSize;            pTheScanLine = (ScanLinePtr)(((Ptr) pTheScanLine) +            whichCol + kGroupSize);                        whichCol = 1;            lastDirtyCol = 1;            pTheScanLine-&gt;iTheData[0] = tempColumn;          }        }        else        {  // If we were repeating, emit the repeat group           if (repeatCount &gt;= 14)          {            EMITGROUP(pTheScanLine, kRepeatGroup, repeatCount);            numberBytesAdded += 1 + kGroupSize;            pTheScanLine = (ScanLinePtr) (((Ptr) pTheScanLine) +  1 + kGroupSize);                        whichCol = 1;            lastDirtyCol = 1;            pTheScanLine-&gt;iTheData[0] = tempColumn;          }          repeatCount = 0;          lastColumn = tempColumn;        }              } // BandIsDirty          } // end of loop for width of bitmap      }// if we have a dirty band - emit the final bit of data we have packaged up   if (bandIsDirty)  {        // Set the margins to be the first and last dirty pixels in the scan line -// the ImageWriter only does left margin optimization.    {      // Get the location for placing the set margin command       marginBuffer = (SetMarginsPtr) (buffer + (*bufferPos));      // Stuff in the set margin command       marginBuffer-&gt;cEscape  = ESCAPE;      marginBuffer-&gt;cCommand = kSetMarginsCommand;      // convert left margin into ASCII and place it at the start of the buffer       Long2Dec((**hGlobals).leftMargin + firstDirty, (Ptr)(marginBuffer-&gt;cIndentDistance));    }      // Send the last group command     if (repeatCount &lt; 14)    {    // Emit a normal group       EMITGROUP(pTheScanLine, kGraphicsCommand, lastDirtyCol);      numberBytesAdded += lastDirtyCol + kGroupSize;    }    else    {    // Don't stuff a final repeat group if it's blank space       if (tempColumn != 0)      {    // Emit a repeat group         EMITGROUP(pTheScanLine, kRepeatGroup, repeatCount);        numberBytesAdded += 1 + kGroupSize;      }    } // end of repeatCount &lt; 14          //  Increment the count of the buffer by bytes added for groups, plus  //  the header, if any, plus the set margins command     (*bufferPos) += numberBytesAdded + kScanLineSize + kSetMarginsSize;      // and put a &lt;cr&gt; at the end of the line    *(char*)(buffer + (*bufferPos)) = 0x010D;    (*bufferPos) += 1;      } // bandIsDirty  else  {// Band is not dirty, so don't output data as we didn't have any!    *bufferPos = originalBufferPos;    // restore original number of line feeds    pGlobals = *hGlobals;    pGlobals-&gt;lineFeeds = originalLineFeeds;  } // always return your errors!SendInitialLineFeeds:  return(anErr);} // SD_PackageBitmap//===================================================================//             Print dialog handling stuff //===================================================================// Dialog panel items constants#define kDitherRB   1#define kHalfToneRB 2#define k_Dth_DotPU 3#define k_HT_DotShapePU 4#define k_HT_AngleTE0   5#define k_HT_FreqTE0    6#define k_HT_AngleTE1   7#define k_HT_FreqTE1    8#define k_HT_AngleTE2   9#define k_HT_FreqTE2    10#define k_HT_AngleTE3   11#define k_HT_FreqTE3    12#define k_Dth_Box       20#define k_HT_Box        21//-------------------------------------------------------------------// SD_JobPrintDialog//// overides : GXJobPrintDialog//// Called by the system when the  print dialog is being created.// This gives us a chance to add out own panels. This done by// SetUpPrintPanel.//-------------------------------------------------------------------OSErr SD_JobPrintDialog(gxDialogResult *dlogResult ){  OSErr theErr = noErr;  theErr = SetUpPrintPanel( );     if (!theErr)    theErr = Forward_GXJobPrintDialog(dlogResult);  return theErr;}//-------------------------------------------------------------------// SD_HandlePanelEvent//// overides : HandlePanelEvent//// Messages are passed by the system to SD_HandlePanelEvent so it can// do any special processing while the print panel is up. We use this// to set up any custom items or gray fields, etc. Because we've // added two panels, we need to check from which panel the message// has been passed. This can be found in gxPanelInfoRecord.panelResId //-------------------------------------------------------------------OSErr SD_HandlePanelEvent( gxPanelInfoRecord *panelInfo ){  OSErr                   theErr = noErr;  GrafPtr                 oldPort;  DialogPtr               pDlg;  CMYKRenderCollection   planes;  Collection         jobCollection;  long          itemSize = sizeof(CMYKRenderCollection);  gxJob          theJob;  pDlg = panelInfo-&gt;pDlg;  GetPort(&amp;oldPort);  SetPort(pDlg);    switch (panelInfo-&gt;panelEvt)  {    case gxPanelOpenEvt:// Every time a panel is opened, set up any items on it that may need setting.      if (panelInfo-&gt;panelResId == kDitherPanelID)        OpenDitherPanel(pDlg, panelInfo-&gt;itemCount);      break;    case gxPanelHitEvt:  // If the user clicks the dither or half-tone buttons then we need to gray// out items appropriately. As We're using a gxExtendedDITLType resource// -'xdtl' to handle the collection, we don't need to worry about changing// the state of the dialog box then writting back the collection. We get the// collection so we can see if the state has changed, this saves on unneeded// setting of dialog items states and possible flicker.      if (panelInfo-&gt;panelResId == kDitherPanelID)      {        theJob = GXGetJob();        jobCollection = GXGetJobCollection(theJob);        theErr = GetCollectionItem( jobCollection,                       kCMYKRenderCollectionType, kCMYKRenderCollectionID,                       &amp;itemSize, &amp;planes);        if (!theErr)          switch (panelInfo-&gt;itemHit - panelInfo-&gt;itemCount)          {            case kDitherRB:            case kHalfToneRB:                GrayDitherDialog ( pDlg, panelInfo-&gt;itemCount,                          planes.renderMode == kDitherIt );            break;          }      }      break;  }    SetPort(oldPort);    return theErr;}//-------------------------------------------------------------------// SetUpPrintPanel//// This creates the render options collection and adds it to a print// job.Then it adds two extra panels to the print panel. //-------------------------------------------------------------------OSErr SetUpPrintPanel( void ){  OSErr                theErr = noErr;  gxPanelSetupRecord   panelSetupRec;  CMYKRenderCollection planesConfig;  Collection           jobCollection;  long                 itemSize = sizeof(CMYKRenderCollection);//  Get the job collection and then try to find the//  render collection item in there.    jobCollection = GXGetJobCollection(GXGetJob());  theErr = GetCollectionItem( jobCollection,                 kCMYKRenderCollectionType, kCMYKRenderCollectionID,                 &amp;itemSize, &amp;planesConfig);//  If the collection item doesn't yet exist, create a new//  item, set it up with default values, and add it to the//  job collection    if (theErr == collectionItemNotFoundErr)  {// Turn all planes on    planesConfig.cyanIsOn    = true;    planesConfig.magentaIsOn  = true;    planesConfig.yellowIsOn    = true;    planesConfig.blackIsOn    = true;// Print in half tone mode    planesConfig.renderMode = kHalfToneIt;// Put default values into the dither parameters    planesConfig.ditherLevel  = 4;// Put default values into the half tone parameters    planesConfig.dotType      = gxRoundDot;    planesConfig.angles   [kRenderOptsYellow] = 0x000F0000;    planesConfig.frequency[kRenderOptsYellow] = 0x002D0000;    planesConfig.angles   [kRenderOptsCyan] = 0x003C0000;    planesConfig.frequency[kRenderOptsCyan] = 0x002D0000;    planesConfig.angles   [kRenderOptsMagenta] = 0x00000000;    planesConfig.frequency[kRenderOptsMagenta] = 0x002D0000;    planesConfig.angles   [kRenderOptsBlack] = 0x002D0000;    planesConfig.frequency[kRenderOptsBlack] = 0x002D0000;// Add the new collection to the job    theErr = AddCollectionItem  (  jobCollection,                    kCMYKRenderCollectionType,                    kCMYKRenderCollectionID,                    sizeof(CMYKRenderCollection),                    &amp;planesConfig);  }  nrequire(theErr, GetSettings_Failed);//  Set up the two panels: store the ID of the panel resource to use,//  the resource file in which it is located, and the type of panel//  that is being stored.    panelSetupRec.panelResId     = kSeperationPanelID;  panelSetupRec.resourceRefNum = GXGetMessageHandlerResFile();  panelSetupRec.refCon         = 0;  panelSetupRec.panelKind      = gxDriverPanel;  theErr                       = GXSetupDialogPanel(&amp;panelSetupRec);  panelSetupRec.panelResId     = kDitherPanelID;  panelSetupRec.resourceRefNum = GXGetMessageHandlerResFile();  panelSetupRec.refCon         = 0;  panelSetupRec.panelKind      = gxDriverPanel;  theErr                       = GXSetupDialogPanel(&amp;panelSetupRec);GetSettings_Failed:  return theErr;}//-------------------------------------------------------------------// OpenDitherPanel//// Called by SD_HandlePanelEvent every time it is sent a // gxPanelOpenEvt for the kDitherPanelID. Need to get the collection// and gray out any items as appropriate. Also add the frame user// items.//-------------------------------------------------------------------OSErr OpenDitherPanel ( DialogPtr pDlg, short itemCount ){  CMYKRenderCollection planes;  OSErr                theErr = noErr;  long               itemSize = sizeof(CMYKRenderCollection);  Collection           jobCollection;  gxJob               theJob;  Handle               hItem;  Rect                 itemRect;  short                itemType;// Get the job  theJob = GXGetJob();// Get the collection  jobCollection = GXGetJobCollection(theJob);// Get the render options collection  theErr = GetCollectionItem( jobCollection,                 kCMYKRenderCollectionType, kCMYKRenderCollectionID,                 &amp;itemSize, &amp;planes);  nrequire(theErr, FailedGetCollectionItem);// Gray out the items depending on the render mode  GrayDitherDialog ( pDlg, itemCount,            planes.renderMode == kDitherIt );// Add the frame items  GetDItem(pDlg, itemCount + k_Dth_Box, &amp;itemType, &amp;hItem, &amp;itemRect);  SetDItem(pDlg, itemCount + k_Dth_Box, itemType, (Handle)DrawBoundBox, &amp;itemRect);  GetDItem(pDlg, itemCount + k_HT_Box, &amp;itemType, &amp;hItem, &amp;itemRect);  SetDItem(pDlg, itemCount + k_HT_Box, itemType, (Handle)DrawBoundBox, &amp;itemRect);FailedGetCollectionItem:  return theErr;}//-------------------------------------------------------------------// SetDialogCtrlGray//// Sets a control dialog item to gray.//-------------------------------------------------------------------void SetDialogCtrlGray ( DialogPtr pDlg, short theItem, Boolean isEnable){  Handle             hItem;  Rect               itemRect;  short              itemType;  GetDItem(pDlg, theItem, &amp;itemType, &amp;hItem, &amp;itemRect);  if (isEnable)    HiliteControl ((ControlHandle)hItem, 0);  else    HiliteControl ((ControlHandle)hItem, 255);}//-------------------------------------------------------------------// GrayDitherDialog//// Gray out unused items in the hilite control panel dependent on// whether the dialog is half-tonning or drawing in color.//-------------------------------------------------------------------void GrayDitherDialog ( DialogPtr pDlg, short itemCount, Boolean isDither){  if (isDither)  {    SetDialogCtrlGray ( pDlg, itemCount + k_Dth_DotPU,   true);    SetDialogCtrlGray ( pDlg, itemCount + k_HT_DotShapePU, false);  }  else  {    SetDialogCtrlGray ( pDlg, itemCount + k_Dth_DotPU,   false);    SetDialogCtrlGray ( pDlg, itemCount + k_HT_DotShapePU, true);  }}//-------------------------------------------------------------------// DrawBoundBox//// Draws a Rectangle user item in a dialog//-------------------------------------------------------------------pascal void DrawBoundBox( WindowPtr theWindow, short theItem ){  Handle hItem;  Rect   itemRect;  short  itemType;  GetDItem(theWindow, theItem, &amp;itemType, &amp;hItem, &amp;itemRect);  FrameRect ( &amp;itemRect );}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/IW-Half-Dither/listing11.html%3Fid%3DDTS10000151-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/IW-Half-Dither/listing11.html%3Fid%3DDTS10000151-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/IW-Half-Dither/listing11.html%3Fid%3DDTS10000151-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>