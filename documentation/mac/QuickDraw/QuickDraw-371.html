<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Cursor Utilities (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING371></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-370.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-372.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-369.html"><B>Chapter 8 - Cursor Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING371-0></A>
<H1>Using the Cursor Utilities</H1>
 This section describes how you can<P>
<UL>
<LI>create cursors
<LI>change the shape of the cursor
<LI>animate a cursor to indicate that a medium-length process is taking place<P>
</UL>
 To implement cursors, you need to<P>
<UL>
<LI>define black-and-white cursors as <CODE>'CURS'</CODE> resources in the resource file of your application
<LI>define color cursors in <CODE>'crsr'</CODE> resources--if you want to display color cursors--in the resource file of your application
<LI>define <CODE>'acur'</CODE> resources--if you want to display animated cursors--in the resource file of your application
<LI>initialize the Cursor Utilities by using the <CODE>InitCursor</CODE> and <CODE>InitCursorCtl</CODE> procedures when your application starts up
<LI>use the <CODE>SetCursor</CODE> or <CODE>SetCCursor</CODE> procedure to change the cursor shape as necessary
<LI>animate the cursor by using the <CODE>SpinCursor</CODE> or <CODE>RotateCursor</CODE> procedure<P>
</UL>
 You use <CODE>'CURS'</CODE> resources to create black-and-white cursors for display on black-and-white and color screens. You use <CODE>'crsr'</CODE> resources to create color cursors for display on systems supporting Color QuickDraw. Each <CODE>'crsr'</CODE> resource also contains a black-and-white image that Color QuickDraw displays on black-and-white screens.<P>
 Before using the routines that handle color cursors--namely, the <CODE>GetCCursor</CODE>, <CODE>SetCCursor</CODE>, and <CODE>DisposeCCursor</CODE> routines--you must test for the existence of Color QuickDraw by using the <CODE>Gestalt</CODE> function with the <CODE>GestaltQuickDrawVersion</CODE> selector. If the value returned in the <CODE>response</CODE> parameter is equal to or greater than the value of the constant <CODE>gestalt32BitQD</CODE>, then the system supports Color QuickDraw. Both basic and Color QuickDraw support all other routines described in this chapter. <P>
<A NAME=HEADING371-14></A>
<H2><A NAME=MARKER-9-12></A>Initializing the Cursor</H2>
 <A NAME=MARKER-2-422></A>When your application starts up, the Finder sets the cursor to a wristwatch; this indicates that an operation is in progress. When your application nears completion of its initialization tasks, it should call the <CODE>InitCursor</CODE> procedure to change the cursor from a wristwatch to an arrow, as shown in the application-defined procedure <CODE>DoInit</CODE> in <A HREF=#MARKER-9-14>Listing 8-1</A>.<P>
<B>Listing 8-1  <A NAME=MARKER-9-14></A>Initializing the Cursor Utilities</B><P>
<PRE>
PROCEDURE DoInit;
BEGIN
   DoSetUpHeap;       {perform Memory Manager initialization here}
   InitGraf(@thePort);{initialize basic QuickDraw}
   InitFonts;         {initialize Font Manager}
   InitWindows;       {initialize Window Manager &amp; other Toolbox }
                      { managers here}
                      {perform all other initializations here}
   InitCursor;        {set cursor to an arrow instead of a } 
                      { wristwatch}
   InitCursorCtl(NIL);{load resources for animated cursor with }
                      { resource ID 0}
END; {of DoInit}
</PRE>
 If your application uses an animated cursor to indicate that an operation of medium length is under way, it should also call the <CODE>InitCursorCtl</CODE> procedure to load its <CODE>'acur'</CODE> resource and associated <CODE>'CURS'</CODE> resources, as illustrated in <A HREF=#MARKER-9-14>Listing 8-1</A>.<A NAME=MARKER-9-423></A><P>
<A NAME=HEADING371-19></A>
<H2>Changing the Appearance of the Cursor</H2>
 <A NAME=MARKER-2-426></A>Whenever the user moves the mouse, the mouse driver, the Event Manager, and your application are responsible for providing feedback to the user. The mouse driver performs low-level functions, such as continually polling the mouse for its location and status and maintaining the current location of the mouse in a global variable. Whenever the user moves the mouse, a low-level interrupt routine of the mouse driver moves the cursor displayed on the screen and aligns the hot spot of the cursor with the new mouse location. This section describes how to use the <CODE>GetCursor</CODE> and <CODE>SetCursor</CODE> routines to change the appearance of a black-and-white cursor when it is in different areas of the screen. (To change the cursor to a color cursor, your application must use the <CODE>GetCCursor</CODE> function, described on <A HREF=QuickDraw-387.html#MARKER-9-136>page 8-24</A>, and the <CODE>SetCCursor</CODE> procedure, described on <A HREF=QuickDraw-388.html#MARKER-9-143>page 8-24</A>.)<P>
 Your application is responsible for setting the initial appearance of the cursor, for restoring the cursor after the Event Manager function <CODE>WaitNextEvent</CODE> returns, and for changing the appearance of the cursor as appropriate for your application. For example, most applications set the cursor to the I-beam when the cursor is inside a text-editing area of a document, and they change the cursor to an arrow when the cursor is inside a scroll bar of a document. Your application can achieve this effect by requesting that the Event Manager report mouse-moved events if the user moves the cursor out of a region you specify in the <CODE>mouseRgn</CODE> parameter to the <CODE>WaitNextEvent</CODE> function. <CODE>WaitNextEvent</CODE> is described in the chapter "Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>. <A NAME=MARKER-2-17></A><P>
 The mouse driver and your application control the shape and appearance of the cursor. A cursor can be any 256-pixel image, defined by a 16-by-16 pixel square. The mouse driver displays the current cursor, which your application can change by using the <CODE>SetCursor</CODE> or <CODE>SetCCursor</CODE> procedure. <P>
 <A NAME=MARKER-2-18></A><A HREF=#MARKER-9-19>Figure 8-2</A> shows the standard arrow cursor. You initialize the cursor to the standard arrow cursor when you use the <CODE>InitCursor</CODE> procedure, as shown in <A HREF=#MARKER-9-14>Listing 8-1</A>. As shown in <A HREF=#MARKER-9-19>Figure 8-2</A>, the hot spot for the arrow cursor is at location (1,1). <P>
<B>Figure 8-2  <A NAME=MARKER-9-19></A>The standard arrow cursor<A NAME=MARKER-2-20></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CGU-L-02.jpg"><BR>
 <A NAME=MARKER-2-21></A><A NAME=MARKER-2-16></A><A HREF=#MARKER-9-23>Figure 8-3</A> shows four other common cursors that are available to your application: the I-beam, crosshairs, plus sign, and wristwatch cursors. <P>
<B>Figure 8-3  <A NAME=MARKER-9-23></A>The I-beam, crosshairs, plus sign, and wristwatch cursors</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CGU-L-03.jpg"><BR>
 The I-beam, crosshairs, plus sign, and wristwatch cursors are defined as resources, <BR>and your application can get a handle to any of these cursors by specifying their corresponding resource IDs to the <CODE>GetCursor</CODE> function. These constants specify the resource IDs for these common cursors: <P>
<PRE>
CONST iBeamCursor = 1;  {used in text editing}
      crossCursor = 2;  {often used for manipulating graphics}
      plusCursor  = 3;  {often used for selecting fields in }
                        { an array}
      watchCursor = 4;  {used when a short operation is in } 
                        { progress}
</PRE>
 After you use the <CODE>GetCursor</CODE> function to obtain a handle to one of these cursors or to one defined by your own application in a <CODE>'CURS'</CODE> resource, you can change the appearance of the cursor by using the <CODE>SetCursor</CODE> procedure.<A NAME=MARKER-2-3></A><A NAME=MARKER-2-25></A><P>
 Your application usually needs to change the shape of the cursor as the user moves the cursor to different areas within a document. Your application can use mouse-moved events to help accomplish this. Your application also needs to adjust the cursor in response to resume events. Most applications adjust the cursor once through the event loop in response to almost all events.<P>
 You can request that the Event Manager report mouse-moved events whenever the cursor is outside of a specified region that you pass as a parameter to the <CODE>WaitNextEvent</CODE> function. (If you specify an empty region or a <CODE>NIL</CODE> handle to the <CODE>WaitNextEvent</CODE> function, <CODE>WaitNextEvent</CODE> does not report mouse-moved events.)<P>
 <A NAME=MARKER-2-26></A><A NAME=MARKER-2-27></A>If you specify a nonempty region in the <CODE>mouseRgn</CODE> parameter to the <CODE>WaitNextEvent</CODE> function, <CODE>WaitNextEvent</CODE> returns a mouse-moved event whenever the cursor is outside of that region. For example, <A HREF=#MARKER-9-29>Figure 8-4</A> shows a document window. Your application might define two regions: a region that encloses the text area of the window (the I-beam region), and a region that defines the scroll bars and all other areas outside the text area (the arrow region). If your application has specified the I-beam region to <CODE>WaitNextEvent</CODE>, the mouse driver continues to display the I-beam cursor until the user moves the cursor out of the region. <A NAME=MARKER-2-11></A><P>
<B>Figure 8-4  <A NAME=MARKER-9-29></A>A window and its arrow and I-beam regions</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CGU-L-04.jpg"><BR>
 When the user moves the cursor out of the I-beam region, <CODE>WaitNextEvent</CODE> reports a mouse-moved event. Your application can then change the I-beam cursor to the arrow cursor and change the <CODE>mouseRgn</CODE> parameter to the area defined by the scroll bars and <BR>all other areas outside of the I-beam region. The cursor remains an arrow until the user moves the cursor out of the arrow region, at which point your application receives a mouse-moved event. <P>
 <A HREF=#MARKER-9-30>Figure 8-5</A> shows how an application might change the cursor from the I-beam cursor to the arrow cursor after receiving a mouse-moved event.<P>
<B>Figure 8-5  <A NAME=MARKER-9-30></A>Changing the cursor from the I-beam cursor to the arrow cursor</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CGU-L-05.jpg"><BR>
 Note that your application should recalculate the <CODE>mouseRgn</CODE> parameter when it receives a mouse-moved event; otherwise, it will continue to receive mouse-moved events as long as the cursor position is outside the original region.<P>
 <A HREF=#MARKER-9-31>Listing 8-2</A> shows an application-defined routine called <CODE>MyAdjustCursor</CODE>. After receiving any event other than a high-level event, the application's event loop (described in the chapter "Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>) calls <CODE>MyAdjustCursor</CODE> to adjust the cursor.<P>
<B>Listing 8-2  <A NAME=MARKER-9-31></A>Changing the cursor<A NAME=MARKER-2-32></A></B><P>
<PRE>
PROCEDURE MyAdjustCursor (mouse: Point; VAR region: RgnHandle);
VAR
   window:        WindowPtr;
   arrowRgn:      RgnHandle;
   iBeamRgn:      RgnHandle;
   iBeamRect:     Rect;
   myData:        MyDocRecHnd;
   windowType:    Integer;
BEGIN
window := FrontWindow;
{Determine the type of window--document, modeless, etc.}
windowType := MyGetWindowType(window);
CASE windowType OF
   kMyDocWindow:
   BEGIN
      {initialize regions for arrow and I-beam}
      arrowRgn := NewRgn;
      ibeamRgn := NewRgn;
      {set arrow region to large region at first}
      SetRectRgn(arrowRgn, -32768, -32768, 32766, 32766);
      {calculate I-beam region}
      {first get the document's TextEdit view rectangle}
      myData := MyDocRecHnd(GetWRefCon(window));
      iBeamRect := myData^^.editRec^^.viewRect;
      SetPort(window);
      WITH iBeamRect DO
      BEGIN
         LocalToGlobal(topLeft);
         LocalToGlobal(botRight);
      END;
      RectRgn(iBeamRgn, iBeamRect);
      WITH window^.portBits.bounds DO
         SetOrigin(-left, -top); 
      {intersect I-beam region with window's visible region}
      SectRgn(iBeamRgn, window^.visRgn, iBeamRgn);
      SetOrigin(0,0);
      {calculate arrow region by subtracting I-beam region}
      DiffRgn(arrowRgn, iBeamRgn, arrowRgn);
      {change the cursor and region parameter as necessary}
      IF PtInRgn(mouse, iBeamRgn) THEN {cursor is in I-beam rgn}
      BEGIN                   
         SetCursor(GetCursor(iBeamCursor)^^);      {set to I-beam}
         CopyRgn(iBeamRgn, region);     {update the region param}
      END;
      {update cursor if in arrow region}
      IF PtInRgn(mouse, arrowRgn) THEN {cursor is in arrow rgn}
      BEGIN
         SetCursor(arrow);             {set cursor to the arrow}
         CopyRgn(arrowRgn, region);    {update the region param}
      END;
      DisposeRgn(iBeamRgn);
      DisposeRgn(arrowRgn);
   END; {of kMyDocWindow}
   kMyGlobalChangesID:
      MyCalcCursorRgnForModelessDialogBox(window, region);
   kNil:
   BEGIN
      MySetRegionNoWindows(kNil, region);
      SetCursor(arrow);
   END;
   END; {of CASE}
END;
</PRE>
 The <CODE>MyAdjustCursor</CODE> procedure sets the cursor appropriately, according to whether a document window or modeless dialog box is active. <P>
 For a document window, <CODE>MyAdjustCursor</CODE> defines two regions, specified by the <CODE>arrowRgn</CODE> and <CODE>iBeamRgn</CODE> variables. If the cursor is inside the region described by the <CODE>arrowRgn</CODE> variable, <CODE>MyAdjustCursor</CODE> sets the cursor to the arrow cursor and returns the region described by <CODE>arrowRgn</CODE>. Similarly, if the cursor is inside the region described by the <CODE>iBeamRgn</CODE> variable, <CODE>MyAdjustCursor</CODE> sets the cursor to the I-beam cursor and returns the region described by <CODE>iBeamRgn</CODE>. <P>
 The <CODE>MyAdjustCursor</CODE> procedure calculates the two regions by first setting the arrow region to the largest possible region. It then sets the I-beam region to the region described by the document's TextEdit view rectangle. This region typically corresponds to the content area of the window minus the scroll bars. (If your application doesn't use TextEdit for its document window, then set this region as appropriate to your application.) The <CODE>MyAdjustCursor</CODE> routine adjusts the I-beam region so that it includes only the part of the content area that is in the window's visible region (for example, to take into account any floating windows that might be over the window). The code in this listing sets the arrow region to include the entire screen except for the region occupied by the I-beam region. (TextEdit is described in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>.)<A NAME=MARKER-2-33></A><A NAME=MARKER-2-34></A><P>
 The <CODE>MyAdjustCursor</CODE> procedure then determines which region the cursor is in and sets the cursor and region parameter appropriately. <A NAME=MARKER-2-35></A><P>
 For modeless dialog boxes, <CODE>MyAdjustCursor</CODE> calls its own routine to appropriately adjust the cursor for the modeless dialog box. The <CODE>MyAdjustCursor</CODE> procedure also appropriately adjusts the cursor if no windows are currently open.<P>
 Your application should normally hide the cursor when the user is typing. You can remove the cursor image from the screen by using either the <CODE>HideCursor</CODE> or <CODE>Hide_Cursor</CODE> procedure. You can hide the cursor temporarily by using the <CODE>ObscureCursor</CODE> procedure, or you can hide the cursor in a given rectangle by using the <CODE>ShieldCursor</CODE> procedure. To display a hidden cursor, use the <CODE>ShowCursor</CODE> or <CODE>Show_Cursor</CODE> procedure. Note that you do not need to explicitly show the cursor after your application uses the <CODE>ObscureCursor</CODE> procedure; instead, the cursor automatically reappears when the user moves the mouse again. These procedures are described in <A HREF=QuickDraw-391.html#MARKER-9-161>"Hiding and Showing Cursors" beginning on page 8-26</A>.<A NAME=MARKER-2-253></A><P>
<A NAME=HEADING371-51></A>
<H2><A NAME=MARKER-9-37></A>Creating an Animated Cursor</H2>
 <A NAME=MARKER-2-286></A>Your application should display an animated cursor when performing a medium-length operation that might cause the user to think that the computer has stopped working. To create an animated cursor, you should<A NAME=MARKER-2-184></A><P>
<UL>
<LI>create a series of <CODE>'CURS'</CODE> resources that make up the "frames" of the animation<A NAME=MARKER-2-273></A>
<LI>create an <CODE>'acur'</CODE> resource with a resource ID of 0
<LI>pass the value <CODE>NIL</CODE> to the <CODE>InitCursorCtl</CODE> procedure once in your program code to load these resources
<LI>use either the <CODE>RotateCursor</CODE> or <CODE>SpinCursor</CODE> procedure when your application is busy with its task<P>
</UL>
<DL>
<DT><B>Note</B>
<DD>An alternate, but more code-intensive, method of creating and displaying an animated cursor is shown in the chapter "Vertical Retrace Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Typically, an animated cursor uses four to seven frames. For example, the seven <CODE>'CURS'</CODE> resources in <A HREF=#MARKER-9-41>Figure 8-6</A> constitute the seven frames of a globe cursor that spins. To create these resources, your application typically uses a high-level utility such as ResEdit, which is available from APDA.<P>
<B>Figure 8-6  <A NAME=MARKER-9-41></A>The <CODE>'CURS'</CODE> resources for an animated globe cursor</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CGU-L-09.jpg"><BR>
 To collect and order your <CODE>'CURS'</CODE> frames into a single animation, you must create an <CODE>'acur'</CODE> resource. This resource specifies the IDs of the <CODE>'CURS'</CODE> resources and the sequence for displaying them in your animation. If your application uses only one spinning cursor, give your <CODE>'acur'</CODE> resource a resource ID of 0. <A NAME=MARKER-2-278></A> <P>
 <A HREF=#MARKER-9-44>Figure 8-7</A> shows how the <CODE>'CURS'</CODE> resources for the spinning globe cursor are specified in an <CODE>'acur'</CODE> resource using ResEdit.<A NAME=MARKER-2-277></A><P>
<B>Figure 8-7  <A NAME=MARKER-9-44></A>An <CODE>'acur'</CODE> resource for an animated cursor</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CGU-S-10.jpg"><BR>
 To load the <CODE>'acur'</CODE> resource and its associated <CODE>'CURS'</CODE> resources, use the <CODE>InitCursorCtl</CODE> procedure once prior to calling the <CODE>RotateCursor</CODE> or <CODE>SpinCursor</CODE> procedure. If you pass <CODE>NIL</CODE> to <CODE>InitCursorCtl</CODE>, then it automatically loads the <CODE>'acur'</CODE> resource that has an ID of 0 in your application's resource file. If you wish to use multiple animated cursors, you must create multiple <CODE>'acur'</CODE> resources--that is, one for each series of <CODE>'CURS'</CODE> resources. Prior to displaying one of your animated cursors with <CODE>RotateCursor</CODE> or <CODE>SpinCursor</CODE>, you must call the Resource Manager function <CODE>GetResource</CODE> to return a handle to its <CODE>'acur'</CODE> resource. Your application must coerce that handle to one of type <CODE>acurHandle</CODE>, and then pass this handle to the <CODE>InitCursorCtl</CODE> procedure. See the chapter "Resource Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I> for more information about <CODE>GetResource</CODE>. <A NAME=MARKER-2-45></A><P>
 When you call <CODE>RotateCursor</CODE> or <CODE>SpinCursor</CODE>, one frame--that is, one <CODE>'CURS'</CODE> resource--is displayed. When you pass a positive value to the procedure the next time you call it, the next frame specified in the <CODE>'acur'</CODE> resource is displayed. A negative value passed to either procedure displays the previous frame listed in the <CODE>'acur'</CODE> resource. The distinction between <CODE>RotateCursor</CODE> and <CODE>SpinCursor</CODE> is that your application maintains an index for changing the cursor when calling <CODE>RotateCursor</CODE>, but your application does not maintain an index for changing the cursor when calling <CODE>SpinCursor</CODE>; instead, your application must determine the proper interval for calling <CODE>SpinCursor</CODE>.<P>
 <A HREF=#MARKER-9-46>Listing 8-3</A> shows an application-defined routine called <CODE>MyRotateCursor</CODE>. When the application calling <CODE>MyRotateCursor</CODE> starts on a medium-length operation and needs to indicate to the user that the operation is in progress, the application sets its global variable <CODE>gDone</CODE> to <CODE>FALSE</CODE> and repeatedly calls <CODE>MyRotateCursor</CODE> until the operation is complete and <CODE>gDone</CODE> becomes <CODE>TRUE</CODE>. <P>
<B>Listing 8-3  <A NAME=MARKER-9-46></A>Animating a cursor with the <CODE>RotateCursor</CODE> procedure</B><P>
<PRE>
PROCEDURE MyRotateCursor;
BEGIN
   IF NOT gDone THEN
   BEGIN
      RotateCursor(TickCount);
   END;
END;
</PRE>
 <A HREF=#MARKER-9-46>Listing 8-3</A> uses the Event Manager function <CODE>TickCount</CODE> to maintain an index for <CODE>RotateCursor</CODE> to use when displaying the frames for an animated cursor. (A tick is approximately 1/60 of a second; <CODE>TickCount</CODE> returns the number of ticks since the computer started up.) When the value passed as a parameter to <CODE>RotateCursor</CODE> is a multiple of 32, then <CODE>RotateCursor</CODE> displays the next frame in the animation.<P>
 <A HREF=#MARKER-9-47>Listing 8-4</A> shows an application-defined routine called <CODE>MySpinCursor</CODE>. As you see in <A HREF=#MARKER-9-47>Listing 8-4</A>, the application does not maintain an index for displaying the frames for an animated cursor. Instead, every time <CODE>SpinCursor</CODE> is called, the next frame in the animation is displayed.<P>
<B>Listing 8-4  <A NAME=MARKER-9-47></A>Animating a cursor with the <CODE>SpinCursor</CODE> procedure</B><P>
<PRE>
PROCEDURE MySpinCursor;
BEGIN
   IF NOT gDone THEN
      SpinCursor(0);
   END;
</PRE>
 If the operation takes less than a second or two, your application can simply use the <CODE>SetCursor</CODE> procedure to display the cursor with the resource ID represented by the <CODE>watchCursor</CODE> constant. If the operation will take longer than several seconds (a lengthy operation), your application should display a status indicator in a dialog box to show the user the estimated total time and the elapsing time of the operation. See the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for information about creating and displaying dialog boxes.<A NAME=MARKER-2-270></A> <A NAME=MARKER-2-49></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-370.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-372.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  

