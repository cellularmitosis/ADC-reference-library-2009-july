<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Printing Manager (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING408></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-407.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-409.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-406.html"><B>Chapter 9 - Printing Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING408-0></A>
<H1><A NAME=MARKER-9-127></A>Using the Printing Manager</H1>
 The Printing Manager defines routines that give your application device-independent control over the printing process. You can use these routines to print documents, to display and alter the print dialog boxes, and to handle printing errors. <P>
 To use the Printing Manager, you must first initialize QuickDraw, the Font Manager, the Window Manager, the Menu Manager, TextEdit, and the Dialog Manager. The first Printing Manager routine to call, when you are ready to print, is <CODE>PrOpen</CODE>; the last routine to call is <CODE>PrClose</CODE>.<A NAME=MARKER-2-129></A><P>
 All of the Printing Manager routines described in this chapter are available on both basic QuickDraw and Color QuickDraw systems using system software version 4.1 or later. However, not all printer drivers support all features provided by the <CODE>PrGeneral</CODE> procedure. (When you call the <CODE>PrGeneral</CODE> procedure, described in <A HREF=#MARKER-9-173>"Getting and Setting Printer Information" beginning on page 9-26</A>, it in turn calls the current printer driver to get or set the desired information.) After calling <CODE>PrGeneral</CODE> and passing it a particular opcode, you should call the <CODE>PrError</CODE> function and test whether it returns the <CODE>opNotImpl</CODE> result code, which indicates that the printer driver does not support that particular opcode.<A NAME=MARKER-2-130></A><P>
 All printable documents must have a <CODE>TPrint</CODE> record. Each <CODE>TPrint</CODE> record contains information about page size, number of copies requested, and the range of pages the user wants printed. Although only the information the user specifies through the style dialog box should be preserved each time the user prints the document, you can save the entire <CODE>TPrint</CODE> record when you save the document. The next time the user opens the document, you can retrieve the user's preferences as saved in the <CODE>TPrint</CODE> record and then use the <CODE>PrValidate</CODE> function to validate the fields of the <CODE>TPrint</CODE> record.<P>
 To print a user's document, you must first create or validate a <CODE>TPrint</CODE> record for the document. You can use the <CODE>PrintDefault</CODE> procedure to initialize the values in a <CODE>TPrint</CODE> record. You can use the <CODE>PrValidate</CODE> function to check that an existing <CODE>TPrint</CODE> record is compatible with the current printer and its driver. Your application should include a printing loop that handles printing and checks for printing errors at every step.   <P>
 You should never assume the type of printer that has been selected; your application should always be able to print to any type of printer. However, for some special features that are not supported by QuickDraw (notably rotated text and graphics, dashed lines, and hairlines), you may want to create two versions of your drawing code: one that uses picture comments to take advantage of the features, and another that provides QuickDraw-based implementations of these features. Using picture comments, your application can instruct printer drivers to perform operations that QuickDraw does not support. For more information, see Appendix B, "Using Picture Comments for Printing," in this book.<P>
 The rest of this section describes how you can<P>
<UL>
<LI>create and use a <CODE>TPrint</CODE> record
<LI>structure your printing loop to print a document 
<LI>use the <CODE>PrGeneral</CODE> procedure to determine printer characteristics
<LI>alter the style and job dialog boxes
<LI>write an idle procedure that runs during printing
<LI>handle printing errors<P>
</UL>
 Be aware that the burden of maintaining backward compatibility with early Apple printer models--as well as maintaining compatibility with over a hundred existing printer drivers--requires extra care on your part. When the Printing Manager was initially designed, it was intended to support ImageWriter printers directly attached to Macintosh computers with only a single floppy disk and 128 KB of RAM. Later, the Printing Manager was implemented on PostScript LaserWriter printer drivers for more powerful Macintosh computers sharing LaserWriter printers on networks. Since then, the Printing Manager has been implemented on a substantial--and unanticipated--number of additional Apple and third-party printer drivers, each in its own, slightly unique way. When you use Printing Manager routines and data structures, you should be especially wary of and defensive about possible error conditions. Because Apple has little control over the manner in which third parties support the Printing Manager in their printer drivers, you should test your application's printing code on as many printers as possible.<P>
<A NAME=HEADING408-15></A>
<H2><A NAME=MARKER-9-131></A>Creating and Using a TPrint Record</H2>
 To print a document, you need a valid <CODE>TPrint</CODE> record that is formatted for the current versions of the Printing Manager and the printer driver. <P>
 <A NAME=MARKER-2-132></A>To create a new <CODE>TPrint</CODE> record, you must first create a handle to it with a Memory Manager function such as <CODE>NewHandle</CODE> or <CODE>NewHandleClear</CODE>. You then must use the <CODE>PrintDefault</CODE> procedure to set the fields of the record to the default values for the current printer driver, as illustrated in the following code fragment. <P>
<PRE>
VAR
   prRecHdl:   THPrint;

   {allocate handle to a TPrint record}
   prRecHdl := THPrint(NewHandleClear(SizeOf(TPrint)));
   IF prRecHdl &lt;&gt; NIL THEN
      PrintDefault(prRecHdl) {sets appropriate default values }
                             { for current printer driver}
   ELSE
   ; {handle error here}
</PRE>
 You can also use an existing <CODE>TPrint</CODE> record (for instance, one saved with a document). If you use an existing <CODE>TPrint</CODE> record, be sure to call the <CODE>PrValidate</CODE> function before using the <CODE>TPrint</CODE> record to make sure it's valid for the current version of the Printing Manager and for the current printer driver. <A NAME=MARKER-2-133></A><P>
 <A NAME=MARKER-2-134></A><A HREF=#MARKER-9-135>Listing 9-1</A> shows an application-defined routine that reads a <CODE>TPrint</CODE> record that the application has saved as a resource of type <CODE>'SPRC'</CODE> with the document. (The Resource Manager routines <CODE>CurResFile</CODE>, <CODE>UseResFile</CODE>, <CODE>Get1Resource</CODE>, and <CODE>DetachResource</CODE> that are shown in this listing are described in the chapter "Resource Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>.)<P>
<B>Listing 9-1  <A NAME=MARKER-9-135></A>Reading a document's <CODE>TPrint</CODE> record</B><P>
<PRE>
FUNCTION MyGetPrintRecordForThisDoc (refNum: Integer;
                                     VAR prRecHdl: THPrint;
                                     VAR prRecChanged: Boolean):
                                     OSErr;
VAR
   saveResFile:   Integer;
BEGIN
   saveResFile := CurResFile; {save the resource file for the document}
   UseResFile(refNum);
   prRecHdl := THPrint(Get1Resource('SPRC', kDocPrintRec));
   IF prRecHdl &lt;&gt; NIL THEN 
   BEGIN
      DetachResource(Handle(prRecHdl));
      prRecChanged := PrValidate(prRecHdl);  {validate TPrint record}
      MyGetPrintRecordForThisDoc := PrError;
   END
   ELSE
      MyGetPrintRecordForThisDoc := kNILHandlePrintErr;
   UseResFile(saveResFile);
END;
</PRE>
 You should save the <CODE>TPrint</CODE> record when the user saves the document. By doing this, you can save any preferences that the user has selected for printing that document, such as orientation of the page or page size. See the chapter "Resource Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I> for information about saving data such as <CODE>TPrint</CODE> records in resources.<P>
 Every printer driver uses the fields of the <CODE>TPrint</CODE> record differently. To maintain compatibility with the Printing Manager, you should follow these guidelines:<P>
<UL>
<LI>Do not test for the contents of undocumented fields.
<LI>Do not set fields in the <CODE>TPrint</CODE> record directly.
<LI>Use the print dialog boxes provided by the printer drivers or, if you want to customize these dialog boxes, alter them only as recommended in <A HREF=#MARKER-9-203>"Altering the Style or Job Dialog Box" on page 9-32</A>.<A NAME=MARKER-2-136></A><P>
</UL>
<A NAME=HEADING408-28></A>
<H2><A NAME=MARKER-9-137></A>Printing a Document</H2>
 <A NAME=MARKER-2-138></A><A NAME=MARKER-2-139></A>When writing an application, the code you provide that handles printing is referred to as the <I>printing loop</I>. A printing loop calls all the Printing Manager routines necessary to print a document. In general, a printing loop must do the following tasks:<P>
<UL>
<LI>It must unload unused code segments to ensure that you have as much memory as possible in which to print.
<LI>It must open the Printing Manager and the current printer driver by using the <CODE>PrOpen</CODE> procedure.
<LI>It must set up a valid <CODE>TPrint</CODE> record for the document (using any values the user previously specified through the style dialog box) by using the <CODE>PrintDefault</CODE> procedure or the <CODE>PrValidate</CODE> function. (When the user is printing from the Finder, it is best not to display the style dialog box, but rather to use saved or default settings for the document.)
<LI>It must display the job dialog box as appropriate by using the <CODE>PrJobDialog</CODE> function or, for a customized job dialog box, the <CODE>PrDlgMain</CODE> function. (When the user is printing from the Finder, display the job dialog box only once, and then use the <CODE>PrJobMerge</CODE> procedure to apply the information from this dialog box to any other documents selected by the user.)
<LI>It must determine the number of pages required to print the requested range of pages by examining the fields of the <CODE>TPrint</CODE> record. (Depending on the page rectangle of the current printer, the amount of data you can fit on a physical page of paper may differ from that displayed on the screen, although it is usually the same.)<A NAME=MARKER-2-140></A>
<LI>It must determine the number of copies to print by examining the <CODE>TPrint</CODE> record.<A NAME=MARKER-2-141></A>
<LI>It may display a status dialog box indicating to the user the status of the current printing operation by using the Dialog Manager function <CODE>GetNewDialog</CODE> (described in the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>).
<LI>If it displays a status dialog box, it must install an idle procedure in the <CODE>pIdleProc</CODE> field of the <CODE>TPrJob</CODE> record (which is contained in the <CODE>TPrint</CODE> record) to update information in the status dialog box and to check whether the user wants to cancel the operation. (The default idle procedure also performs this check, but if you update information in your status dialog box you must provide your own idle procedure.) 
<LI><A NAME=MARKER-2-142></A><A NAME=MARKER-2-143></A>It must print the requested range of pages for each requested copy by <P>
<UL>
<LI>using the <CODE>PrOpenDoc</CODE> function to open a printing graphics port if the current page number is the first page or a multiple of the value represented by the constant <CODE>iPFMaxPgs</CODE><A NAME=MARKER-2-144></A><A NAME=MARKER-2-145></A>
<LI>opening a page for printing by using the <CODE>PrOpenPage</CODE> procedure
<LI>printing the page by drawing into the printing graphics port with the QuickDraw routines described in the rest of this book
<LI>closing the page by using the <CODE>PrClosePage</CODE> procedure
<LI>using the <CODE>PrCloseDoc</CODE> procedure to close the printing graphics port and begin printing the requested range of pages
<LI>checking whether the printer driver is using deferred printing and, if so, using the <CODE>PrPicFile</CODE> procedure to send the spool file to the printer<P>
</UL>
<LI>Finally, the printing loop must close the Printing Manager by using the <CODE>PrClose</CODE> procedure.<P>
</UL>
 <A HREF=#MARKER-9-146>Listing 9-2</A> shows an extremely broad example of a printing loop--the code does not optimize for the type of printer being used or for the material being printed (text, graphics, or a mixture of both). However, this sample routine, called <CODE>MyPrintLoop</CODE>, does cover the major aspects of a printing loop: how to balance calls to the open and close routines, how to determine page count, and how to provide support for documents exceeding the maximum page length specified by the constant <CODE>iPFMaxPgs</CODE>. <P>
<B>Listing 9-2  <A NAME=MARKER-9-146></A>A sample printing loop</B><P>
<PRE>
PROCEDURE MyPrintLoop(docToPrint: MyDocRecHnd; displayJob: Boolean);
VAR
   copies, numberOfCopies:    Integer;
   firstPage, lastPage:       Integer;
   pageNumber, numberOfPages: Integer;
   doPrint, changed:          Boolean;
   oldPort:                   GrafPtr;
   theStatus:                 TPrStatus;
   printError:                Integer;
BEGIN
   GetPort(oldPort);
   MyUnLoadTheWorld; {swap out those segments of code not needed to print}
   PrOpen;           {open Printing Manager and the current printer driver}
   IF (PrError = noErr) THEN
   BEGIN
      gPrintResFile := CurResFile;     {save the current resource file}
      gPrintRec := docToPrint^^.docPrintRecHdl; {set to this doc's print rec}
      changed := PrValidate(gPrintRec);   {verify TPrint record}
      IF (PrError = noErr) THEN
      BEGIN
         {determine the number of pages required to print the document}
         numberOfPages := MyDetermineNumOfPages(gPrintRec^^.prInfo.rPage);
         {display job dialog box if requested, else use previous settings}
         IF displayJob THEN
            doPrint := PrJobDialog(gPrintRec)
         ELSE
            doPrint := MyDoJobMerge(gPrintRec);
         IF doPrint THEN
         BEGIN
            numberOfCopies := gPrintRec^^.prJob.iCopies;
            firstPage := gPrintRec^^.prJob.iFstPage;{save first page number}
            lastPage := gPrintRec^^.prJob.iLstPage; {save last page number}
            gPrintRec^^.prJob.iFstPage := 1;        {reset to 1}
            gPrintRec^^.prJob.iLstPage := iPrPgMax; {reset to maximum}
            IF (numberOfPages &lt; lastPage) THEN 
               lastPage := numberOfPages;    {to prevent printing past last }
                                             { page}
            {display a &quot;Print Status&quot; dialog box (optional)-- }
            { first, deactivate front window}
            MyDoActivateFrontWindow(FALSE, oldPort); 
            gPrintStatusDlg := GetNewDialog(kPrintStatus, NIL, Pointer(-1));
            {set up dialog items (insert name of document being printed)}
            MySetUpDBoxItems(docToPrint);
            ShowWindow(gPrintStatusDlg);  {display the dialog box}
            {set up idle procedure (for later use)}
            gPrintRec^^.prJob.pIdleProc := @MyDoPrintIdle;
            {print the requested number of copies}
            FOR copies := 1 TO numberOfCopies DO
            BEGIN
               UseResFile(gPrintResFile);{restore driver's resource file}
               {print the requested range of pages of the document}
               FOR pageNumber := firstPage TO lastPage DO
               BEGIN
                  {check current page number against iPFMaxPgs}
                  IF (pageNumber - firstPage) MOD iPFMaxPgs = 0 THEN
                  BEGIN
                     IF pageNumber &lt;&gt; firstPage THEN
                     {if max size of spool file has been reached (and this }
                     { isn't the first page), then close the document, }
                     { initiate printing, then reopen the document}
                     BEGIN
                        PrCloseDoc(gPrinterPort);
                        {next line tests for deferred printing}
                        IF (gPrintRec^^.prJob.bJDocLoop = bSpoolLoop) 
                              AND (PrError = noErr) THEN
                           PrPicFile(gPrintRec, NIL, NIL, NIL, theStatus);
                     END;
                     {if this is the first page or a multiple of iPFMaxPgs, }
                     { then open the document for printing}
                     gPrinterPort := PrOpenDoc(gPrintRec, NIL, NIL);
                  END; {of check current page number}
                  IF (PrError = noErr) THEN
                  BEGIN {print a page}
                     PrOpenPage(gPrinterPort, NIL);
                     IF (PrError = noErr) THEN
                     {draw (print) a page in the printable area for the }
                     { current printer (indicated by the rPage field)}
                     MyDrawStuff (gPrintRec^^.prInfo.rPage, docToPrint,
                                  GrafPtr(gPrinterPort), pageNumber);
                     PrClosePage(gPrinterPort);
                  END;  {of print a page}
               END; {of print the requested range of pages}
               PrCloseDoc(gPrinterPort);
               IF (gPrintRec^^.prJob.bJDocLoop = bSpoolLoop) AND
                  (PrError = noErr) THEN
                  PrPicFile(gPrintRec, NIL, NIL, NIL, theStatus);
            END;
         END;
      END;
   END;
   printError := PrError;
   PrClose;
   IF (printError &lt;&gt; noErr) THEN 
      DoError(ePrint, printError);
   DisposeDialog(gPrintStatusDlg);
   SetPort(oldPort);
   MyDoActivateFrontWindow(TRUE, oldPort); {activate window}
END;
</PRE>
 The <CODE>MyPrintLoop</CODE> procedure starts by getting a pointer to the current graphics port. Then it calls an application-defined routine, <CODE>MyUnloadTheWorld</CODE>, that swaps out code segments not required during printing. Then it opens the Printing Manager and the current printer driver and its resource file by calling <CODE>PrOpen</CODE>.<P>
 The <CODE>MyPrintLoop</CODE> procedure saves the current resource file (after calling <CODE>PrOpen</CODE>, the current resource file is the driver's resource file) so that, if its idle procedure changes the resource chain in any way, it can restore the current resource file before returning; thus the driver does not lose access to its resources. The <CODE>MyPrintLoop</CODE> procedure then uses the <CODE>PrValidate</CODE> function to change any values in the <CODE>TPrint</CODE> record associated with the document to match those specified by the current printer driver; these values can be changed later by the printer driver as a result of your application's use of the <CODE>PrStlDialog</CODE> and <CODE>PrJobDialog</CODE> functions. (Your application passes a handle to a <CODE>TPrint</CODE> record to the <CODE>PrStlDialog</CODE> and <CODE>PrJobDialog</CODE> functions, and these procedures modify the <CODE>TPrint</CODE> record according to the user's interaction with the style and job dialog boxes.) The <CODE>MyPrintLoop</CODE> procedure calls <CODE>PrValidate</CODE> rather than <CODE>PrintDefault</CODE> to preserve any values that the user might have previously set through the style dialog box.<P>
 <A NAME=MARKER-2-147></A>To print a document, you must divide the data into sections that fit within the page rectangle dimensions stored in the <CODE>rPage</CODE> field of the <CODE>TPrJob</CODE> record, which is contained in the <CODE>TPrint</CODE> record. (This information is stored in the <CODE>rPage</CODE> field when you call the <CODE>PrintDefault</CODE>, <CODE>PrValidate</CODE>, or <CODE>PrStlDialog</CODE> routine.) The application-defined function <CODE>MyDetermineNumOfPages</CODE> is specific to the application, because the way the application divides up the data depends on the type of text and graphics in the document. The <CODE>MyDetermineNumOfPages</CODE> function determines the number of pages required to print the document by comparing the size of the document with the printable area for the current printer, which is specified by the value in the <CODE>rPage</CODE> field of the <CODE>TPrJob</CODE> record in the <CODE>TPrint</CODE> record. <P>
 After determining the number of pages required to print the document, <CODE>MyPrintLoop</CODE> displays the job dialog box if the calling routine requested it to do so. If the user prints multiple documents at once, the calling routine sets the <CODE>displayJob</CODE> parameter to <CODE>TRUE</CODE> for the first document and <CODE>FALSE</CODE> for subsequent documents. This allows the user to specify values in the job dialog box only once when printing multiple documents. It also provides an application with the ability to print documents in the background (for example, as the result of responding to the Apple event Print Documents) without requiring the application to display the job dialog box. <P>
 The user's responses in the job dialog box provide such information as the number of copies and the page numbers of the first and last pages requested. The <CODE>MyPrintLoop</CODE> procedure stores these values in the local variables <CODE>firstPage</CODE> and <CODE>lastPage</CODE>. It then resets the value of the first page in the <CODE>TPrJob</CODE> record as 1 and resets the value of the last page to the value represented by the constant <CODE>iPrPgMax</CODE>. <A NAME=MARKER-2-148></A><P>
 The <CODE>MyPrintLoop</CODE> procedure compares the values of the number of pages in the document with the last page the user requested and changes the last page number as necessary. For example, if the user asks to print page 50 of a two-page document, <CODE>MyPrintLoop</CODE> resets the value of the last page to 2.<A NAME=MARKER-2-149></A> <P>
 At this point, <CODE>MyPrintLoop</CODE> is about to begin the process of sending the pages off to be printed. So it displays its own status dialog box to inform the user of the current status of the printing operation. If your status dialog box provides a button or reports on the progress of the printing operation, you need to handle events in the dialog box by providing an idle procedure. Your idle procedure should update the items in your status dialog box to show the current progress of the printing operation, and it should determine whether the user has canceled the printing operation. The printer driver calls the idle procedure periodically during the printing process. For more information on idle procedures, see <A HREF=#MARKER-9-213>"Writing an Idle Procedure" on page 9-35</A>.<P>
 After installing its idle procedure, the <CODE>MyPrintLoop</CODE> procedure then begins the printing operation by performing a number of steps for each requested copy. First, <CODE>MyPrintLoop</CODE> restores the current resource file to the printer driver's resource file.<P>
 <CODE>MyPrintLoop</CODE> then begins the process of printing each page. The maximum number of pages that can be printed at a time is represented by the constant <CODE>iPFMaxPgs</CODE>. If the file is larger than the value represented by <CODE>iPFMaxPgs</CODE>, your application can print the number of pages represented by <CODE>iPFMaxPgs</CODE> and then begin the printing loop again with the next section of the document. In this way, you can print any number of pages. <P>
 Next, <CODE>MyPrintLoop</CODE> opens a page for printing and draws the page in the printing graphics port with the application-defined <CODE>MyDrawStuff</CODE> procedure, the details of which are specific to the application. The parameters to <CODE>MyDrawStuff</CODE> are the size of the page rectangle, the document containing the data to print, the printing graphics port in which to draw, and the page number to be printed. This allows the application to use the same code to print a page of a document as it uses to draw the same page on screen.<A NAME=MARKER-2-150></A> <A NAME=MARKER-2-151></A><A NAME=MARKER-2-152></A><P>
 <A NAME=MARKER-2-153></A>When <CODE>MyPrintLoop</CODE> is finished printing (or has printed a multiple of the value represented by the constant <CODE>iPFMaxPgs</CODE>), it closes the printing graphics port for the document. By testing for the <CODE>bSpoolLoop</CODE> constant in the <CODE>bJDocLoop</CODE> field of the <CODE>TPrJob</CODE> record, <CODE>MyPrintLoop</CODE> determines whether a printer driver is using deferred printing; if so, <CODE>MyPrintLoop</CODE> calls the <CODE>PrPicFile</CODE> procedure, which sends the spool file to the printer. <A NAME=MARKER-2-312></A><P>
 Some QuickDraw printer drivers (in particular, those for the ImageWriter and ImageWriter LQ printers) provide two methods of printing documents: deferred and draft-quality. Typically, the printer driver uses deferred printing when a user chooses Best in the job dialog box, and it uses draft-quality printing when the user chooses Draft. <P>
 Deferred printing was designed to allow ImageWriter printers to spool a page image to disk when printing under the low memory conditions of the original 128 KB Macintosh computer. With <B>deferred printing,</B> a printer driver records each page of the document's printed image in a structure similar to a QuickDraw picture, which the driver writes to a spool file. For compatibility with printer drivers that still support deferred printing, use the <CODE>PrPicFile</CODE> procedure to instruct these printer drivers to turn the QuickDraw pictures into bit images and send them to the printer. (<B>Draft-quality printing,</B> on the other hand, is a method by which a printer driver converts into drawing operations calls only to QuickDraw's text-drawing routines. The printer driver sends these routines directly to the printer instead of using deferred printing to capture the entire image for a page in a spool file.)<A NAME=MARKER-2-155></A><A NAME=MARKER-2-156></A><P>
<DL>
<DT><B>Note</B>
<DD>Do not confuse background printing with deferred printing. While printer drivers supporting background printing also create spool files, you do not need to use the <CODE>PrPicFile</CODE> procedure to send these spool files to the printer. In fact, there is no reliable way for you to determine whether a printer driver is using a spool file for background printing.<A NAME=MARKER-2-157></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The <CODE>MyPrintLoop</CODE> procedure concludes by closing the Printing Manager, reporting any Printing Manager errors, and resetting the current graphics port to the original port. <P>
 In your printing loop, you should balance all calls to Printing Manager open routines to the equivalent Printing Manager close routines. This is extremely important, even if you stop printing because of an error. Failure to call the matching close routines can cause the Printing Manager to perform incorrectly.<P>
 Note that <CODE>MyPrintLoop</CODE> calls <CODE>PrError</CODE> after each Printing Manager routine. If an error is found, the loop calls a close routine (<CODE>PrClose</CODE>, <CODE>PrClosePage</CODE>, or <CODE>PrCloseDoc</CODE>) for any Printing Manager open routines (<CODE>PrOpen</CODE>, <CODE>PrClosePage</CODE>, or <CODE>PrOpenDoc</CODE>) before informing the user of the error. You should use this approach in your own application to make sure the Printing Manager closes properly and all temporary memory is released. <P>
<DL>
<DT><B>WARNING</B>
<DD>Some applications use a method of printing that prints out each page of a spooled document as a separate print job in order to avoid running out of disk space while spooling the document. You should not use this method, known as "spool a page, print a page." It is appropriate only for a printer directly connected to the user's computer (that is, not to a network) and therefore creates device dependence--and also it's extremely slow. If the printer is a remote or shared device (such as a LaserWriter printer connected by an AppleTalk network), another application could print a document between the pages of your user's document. At worst, if both applications printing to the shared printer use the "spool a page, print a page" method, the printed documents could end up interleaved. The pages for one of the documents could be out of order, even when printed by itself on a shared, network printer.<A NAME=MARKER-2-158></A><EM></EM><A NAME=MARKER-2-159></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING408-67></A>
<H3><A NAME=MARKER-9-160></A>Printing From the Finder</H3>
 <A NAME=MARKER-2-161></A><A NAME=MARKER-2-162></A>Typically, users print documents that are open on the screen one at a time while the application that created the document is running. Alternatively, users can print one or more documents from the Finder. To print documents from the Finder, the user selects one or more document icons and chooses the Print command from the File menu. When the Print command is chosen, the Finder starts up the application and passes it an Apple event--the Print Documents event--indicating that the documents are to be printed rather than opened on the screen. <P>
 As explained in <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>, your application should support the required Apple events, which include the Print Documents event. In response to a Print Documents event, your application should do the following:<P>
<OL>
<LI>Your application should not open windows for the documents.
<LI>For style information, your application should use saved or default settings instead of displaying the style dialog box to ask this information from the user. 
<LI><A NAME=MARKER-2-163></A>Your application should use the <CODE>PrJobDialog</CODE> function (described on <A HREF=QuickDraw-432.html#MARKER-9-440>page 9-59</A>) or the <CODE>PrDlgMain</CODE> function (described on <A HREF=QuickDraw-433.html#MARKER-9-447>page 9-60</A>) to display the job dialog box only once. When the user clicks the OK button in the job dialog box, you can then use the <CODE>PrJobMerge</CODE> procedure (described on <A HREF=QuickDraw-436.html#MARKER-9-473>page 9-63</A>) to apply the information specified by the user to all of the documents selected from the Finder. <P>
For example, if the user has selected three documents to print, you can display the job dialog box only once and then apply the same information supplied by the user to all three documents. <A HREF=#MARKER-9-166>Figure 9-10</A> shows a situation where, through the job dialog box, the user has specified the number of copies and the range of pages to print. In this example, the application applies this job information to the <CODE>TPrint</CODE> record of the three documents by calling <CODE>PrJobMerge</CODE>. Note that <CODE>PrJobMerge</CODE> preserves the fields of the <CODE>TPrint</CODE> record that are specific to each document (that is, the fields that are set by the user through the style dialog box).<A NAME=MARKER-2-165></A>
<LI>Your application should remain open until the Finder sends your application a Quit event. If appropriate, the Finder sends your application this Apple event immediately after sending it the Print Documents event.<P>
</OL>
<B>Figure 9-10  <A NAME=MARKER-9-166></A>How the <CODE>PrJobMerge</CODE> procedure works</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/QPM-L-21.jpg"><BR>
 See <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I> for more information about how to handle the Print Documents and Quit events.<A NAME=MARKER-2-167></A><A NAME=MARKER-2-169></A><A NAME=MARKER-2-170></A><P>
<A NAME=HEADING408-78></A>
<H3>Providing Names of Documents Being Printed</H3>
 <A NAME=MARKER-2-171></A>Some printer drivers (usually those for printers such as LaserWriter printers that are shared among many users) provide the names of the users who are printing and the documents that are being printed to others interested in using the printer. Providing the names of users and documents is a courtesy to other users sharing the printer on a network. The printer driver gets the name of the document being printed from the title of the frontmost window on the user's screen. The <CODE>PrOpenDoc</CODE> and <CODE>PrValidate</CODE> functions call the Window Manager procedure <CODE>FrontWindow</CODE> to get the document's name.<P>
 Printer drivers can't get a document name if your application doesn't display windows while printing. For example, applications should not open windows for their documents when the user prints from the Finder. If there is no front window, or if the window's title is empty, the printer driver sets the document name to "Unspecified" or "Untitled."<P>
 You can ensure that the document name is available by displaying a printing status dialog box and setting the window's title to the document's name. If the dialog box is one that doesn't have a title bar (like that of type <CODE>dBoxProc</CODE>), this title is not displayed but the current printer driver can still use the title as the document's name. If you don't want to put up a visible window, you can create a tiny window (for instance, type <CODE>plainDBox</CODE>) and hide it behind the menu bar by giving it the global coordinates of (1,1,2,2). See the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for information about the <CODE>dBoxProc</CODE> and <CODE>plainDBox</CODE> window types. <P>
<DL>
<DT><B>Note</B>
<DD>Do not set the document name in the <CODE>TPrint</CODE> record directly. Not all printer drivers support this field, and Apple does not guarantee that internal fields of the Printing Manager's data structures will remain the same.<EM></EM> <A NAME=MARKER-2-172></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING408-83></A>
<H3>Printing Hints</H3>
 QuickDraw is the primary means you use to print, and in general you can use QuickDraw in the printing graphics port exactly as you would for a screen's graphics port. There are a few things to note when drawing to the printing graphics port: <P>
<UL>
<LI>Don't depend on values in a printing graphics port remaining identical from page to page. With each new page, you usually get reinitialized font information and other characteristics for the printing graphics port.
<LI>Don't make calls that don't do anything on the printer. For example, QuickDraw erase routines such as <CODE>EraseRect</CODE> are quite time-consuming and normally aren't needed on the printer. An erase routine takes time because every bit (90,000 bits per square inch on a 300 dpi LaserWriter) has to be cleared. Paper does not need to be erased the way the screen does. Also avoid using the <CODE>TextBox</CODE> procedure, which makes calls to the <CODE>EraseRect</CODE> procedure. You might want to use a different method of displaying text (for example, <CODE>DrawString</CODE> or <CODE>DrawText</CODE>) or write your own version of <CODE>TextBox</CODE>. See the chapter "QuickDraw Text" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>.
<LI>Don't use clipping to select text to be printed. There are a number of subtle differences between how text appears on the screen and how it appears on the printer; you can't count on knowing the exact dimensions of the rectangle occupied by the text.
<LI>Don't use fixed-width fonts to align columns. Because spacing is adjusted on the printer, you should explicitly move the pen to where you want it.
<LI>Don't use the outline font style to create white text on a black background.
<LI><B>Avoid changing fonts frequently. </B>
<LI>Because of the way rectangle intersections are determined, you slow printing substantially if your clipping region falls outside of the rectangle given by the <CODE>rPage</CODE> field of the <CODE>TPrInfo</CODE> record of the <CODE>TPrint</CODE> record.<P>
</UL>
<A NAME=HEADING408-92></A>
<H2><A NAME=MARKER-9-173></A>Getting and Setting Printer Information</H2>
 You can determine the resolution of the printer, set the resolution you want, find out if the user has selected landscape printing, or force enhanced draft-quality printing by using the <CODE>PrGeneral</CODE> procedure. You call the <CODE>PrGeneral</CODE> procedure with one of five opcodes: <CODE>getRslDataOp</CODE>, <CODE>setRslOp</CODE>, <CODE>getRotnOp</CODE>, <CODE>draftBitsOp</CODE>, or <CODE>noDraftBitsOp</CODE>. These opcodes have data structures associated with them.<P>
 When you call the <CODE>PrGeneral</CODE> procedure, it in turn calls the current printer driver to get or set the desired information. Not all printer drivers support all features provided by the <CODE>PrGeneral</CODE> procedure, however, so your application can't depend on its use. <P>
 <A HREF=#MARKER-9-175>Listing 9-3</A> shows an application-defined routine, <CODE>DoIsPrGeneralThere</CODE>, that checks whether the current printer driver supports the <CODE>PrGeneral</CODE> procedure. First, <CODE>DoIsPrGeneralThere</CODE> sets the <CODE>opcode</CODE> field of the <CODE>TGetRotnBlk</CODE> record to the <CODE>getRotnOp</CODE> opcode--the opcode used to determine whether the user has chosen landscape orientation. Then <CODE>DoIsPrGeneralThere</CODE> passes the address of the <CODE>TGetRotnBlk</CODE> record to the <CODE>PrGeneral</CODE> procedure. It then calls <CODE>PrError</CODE> to get any errors that result from calling <CODE>PrGeneral</CODE>. If the error is <CODE>resNotFound</CODE>, the printer driver does not support <CODE>PrGeneral</CODE>.<P>
<B>Listing 9-3  <A NAME=MARKER-9-175></A>Checking whether the current printer driver supports the <CODE>PrGeneral</CODE> procedure</B><P>
<PRE>
FUNCTION DoIsPrGeneralThere: Boolean;
VAR
   getRotRec:     TGetRotnBlk;
   myPrintErr:    OSErr;
BEGIN
   myPrintErr := 0;
   getRotRec.iOpCode := getRotnOp;  {set the opcode}
   getRotRec.hPrint := gMyPrRecHdl; {TPrint record this operation applies to}
   PrGeneral(@getRotRec);  
   myPrintErr := PrError;
   PrSetError(noErr);
   IF (myPrintErr = resNotFound) THEN  {the current driver doesn't support }
      DoIsPrGeneralThere := FALSE;     { PrGeneral}
   ELSE
      DoIsPrGeneralThere := TRUE;      {current driver supports PrGeneral}
END;
</PRE>
 After determining that the current printer driver supports <CODE>PrGeneral</CODE>, you can use <CODE>PrGeneral</CODE> to<P>
<UL>
<LI>determine and set the resolution of the current printer
<LI>determine the current page orientation
<LI>force enhanced draft-quality printing <P>
</UL>
 As an alternative to testing for <CODE>PrGeneral</CODE>, your application can call <CODE>PrGeneral</CODE> and then test whether <CODE>PrError</CODE> error returns the <CODE>opNotImpl</CODE> result code, which indicates that the printer driver either does not support <CODE>PrGeneral</CODE> or does not support that particular opcode.<P>
 These operations are discussed in the following sections.<P>
<A NAME=HEADING408-104></A>
<H3><A NAME=MARKER-9-176></A>Determining and Setting the Resolution of the Current Printer</H3>
 <A NAME=MARKER-2-177></A><A NAME=MARKER-2-178></A>Some printer drivers support only one of the two possible kinds of resolution: discrete or variable. You can use the <CODE>PrGeneral</CODE> procedure to determine the kind of resolution supported by the current printer and then use the highest resolution desired by your application or the user. <P>
 <A NAME=MARKER-2-179></A>Each printer has its own imaging capabilities. When you call <CODE>PrGeneral</CODE> with the value <CODE>getRslDataOp</CODE> in the <CODE>iOpCode</CODE> field of the <CODE>TGetRslBlk</CODE> record, <CODE>PrGeneral</CODE> returns the resolutions that the printer supports. <A HREF=#MARKER-9-181>Figure 9-11</A> shows <CODE>TGetRslBlk</CODE> records (described on <A HREF=QuickDraw-419.html#MARKER-9-341>page 9-50</A>) returned by the drivers for a 300-dpi LaserWriter PostScript printer and a QuickDraw ImageWriter printer. Because it supports variable resolutions, the <CODE>TGetRslBlk</CODE> record for the LaserWriter driver specifies minimum and maximum resolutions in the x and y directions. Because it uses discrete resolutions, the <CODE>TGetRslBlk</CODE> record for the ImageWriter driver specifies no minimum or maximum resolutions in the x and y directions, but instead specifies the four discrete resolutions it supports.<P>
<B>Figure 9-11  <A NAME=MARKER-9-181></A>Sample resolutions for a PostScript printer and a QuickDraw printer<A NAME=MARKER-2-182></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/QPM-L-09.jpg"><BR>
 A <CODE>TPrint</CODE> record contains the x and y resolutions that the printer uses in printing the data associated with the <CODE>TPrint</CODE> record. For each <CODE>TPrint</CODE> record you use, you can either use the default values or you can specify the particular imaging resolution that you want to use. To do this, you can call <CODE>PrGeneral</CODE>, specifying the value <CODE>setRslOp</CODE> in the <CODE>iOpCode</CODE> field and specifying the x and y resolutions in the <CODE>iXRsl</CODE> and <CODE>iYRsl</CODE> fields of the <CODE>TSetRslBlk</CODE> record (which is described on <A HREF=QuickDraw-420.html#MARKER-9-354>page 9-51</A>). The <CODE>PrGeneral</CODE> procedure returns the <CODE>noErr</CODE> result code if it has updated the <CODE>TPrint</CODE> record with this new resolution, or it returns the <CODE>noSuchRsl</CODE> result code if the current printer doesn't support this resolution.<P>
 <A HREF=#MARKER-9-184>Listing 9-4</A> illustrates how to use the <CODE>PrGeneral</CODE> procedure to determine the possible resolutions for the current printer and then set a <CODE>TPrint</CODE> record to the desired resolution.<P>
<B>Listing 9-4  <A NAME=MARKER-9-184></A>Using the <CODE>getRslDataOp</CODE> and <CODE>setRslOp</CODE> opcodes with the <CODE>PrGeneral</CODE> procedure</B><P>
<PRE>
FUNCTION DoSetMaxResolution (thePrRecHdl: THPrint): Integer;
VAR
   maxDPI:     Integer;
   resIndex:   Integer;
   getResRec:  TGetRslBlk;
   setResRec:  TSetRslBlk;
BEGIN
   maxDPI := 0;
   getResRec.iOpCode := getRslDataOp;{get printer resolution info}
   PrGeneral(@getResRec);
   IF (getResRec.iError = noErr) AND (PrError = noErr) THEN
   BEGIN
      {the TGetRslBlk record contains an array of possible resolutions-- }
      { so loop through each resolution range record looking for }
      { the highest resolution available where x and y are equal}
      FOR resIndex := 1 TO (getResRec.iRslRecCnt) DO
      BEGIN
         IF (getResRec.rgRslRec[resIndex].iXRsl =
               getResRec.rgRslRec[resIndex].iYRsl) AND
               (getResRec.rgRslRec[resIndex].iXRsl &gt; maxDPI) THEN
            maxDPI := getResRec.rgRslRec[resIndex].iYRsl;
      END;
      {set the resolution to the maximum supported resolution}
      IF maxDPI &lt;&gt; 0 THEN
      BEGIN
         WITH setResRec DO
         BEGIN
            iOpCode := setRslOp;
            hPrint := thePrRecHdl;
            iXRsl := maxDPI;
            iYRsl := maxDPI;
         END;
         PrGeneral(@setResRec);
      END; {end of maxDPI &lt;&gt; 0}
      IF (setResRec.iError = noErr) AND (PrError = noErr) AND
            (maxDPI &lt;&gt; 0) THEN 
         DoSetMaxResolution := maxDPI;
   END
   ELSE 
      DoSetMaxResolution := 0;
END;
</PRE>
 You can reset the original resolutions by calling the <CODE>PrGeneral</CODE> procedure with the <CODE>setRslOp</CODE> opcode a second time. To do so, you should save the values contained in the <CODE>iVRes</CODE> and <CODE>iHRes</CODE> fields of the <CODE>TPrInfo</CODE> record before making the first call to <CODE>PrGeneral</CODE>. You can also reset the original resolutions by calling the <CODE>PrintDefault</CODE> procedure with the <CODE>TPrint</CODE> record, which sets all of the fields of the <CODE>TPrint</CODE> record to the default values of the current printer resource file. However, if you use <CODE>PrintDefault</CODE> you lose all of the user's selections from the last style dialog box. (You may want to reset the original resolution because that may be the printer's best resolution, though not its highest.)<P>
 Based on the information you get with a call to <CODE>PrGeneral</CODE> using the <CODE>getRslDataOp</CODE> opcode, you may decide to change the resolution with a call to <CODE>PrGeneral</CODE> using the <CODE>setRslOp</CODE> opcode. If so, the printer driver may need to change the appearance of the style and job dialog boxes by disabling some items. Therefore, you should determine and set the resolution <I>before</I> you use the <CODE>PrStlDialog</CODE> and <CODE>PrJobDialog</CODE> functions (or the <CODE>PrDlgMain</CODE> function) to present the print dialog boxes to the user.<A NAME=MARKER-2-185></A> <A NAME=MARKER-2-186></A><P>
 Note that the style dialog boxes for some printers, such as the StyleWriter, may offer the user a choice of printing in Best or Normal modes, which sets the printing at 360 or 180 dpi, respectively. Your application has no control over this setting. The printer driver converts your drawing accordingly.<A NAME=MARKER-2-187></A><A NAME=MARKER-2-188></A><P>
<A NAME=HEADING408-116></A>
<H3><A NAME=MARKER-9-189></A>Determining Page Orientation</H3>
 <A NAME=MARKER-2-190></A><A NAME=MARKER-2-914></A>At times it can be useful for your application to determine which page orientation the user selects in the style dialog box. For instance, if an image fits on a page only if it is printed in landscape orientation (the <CODE>prInfo</CODE> field of the <CODE>TPrint</CODE> record defines a smaller horizontal value for the paper rectangle than for the image rectangle) and the user has not selected landscape orientation, your application can remind the user to select this orientation before printing. Otherwise, the user gets a clipped image. <P>
 <A NAME=MARKER-2-192></A>If you call the <CODE>PrGeneral</CODE> procedure with the <CODE>getRotnOp</CODE> opcode in the <CODE>TGetRotnBlk</CODE> record (described on <A HREF=QuickDraw-422.html#MARKER-9-382>page 9-53</A>), the printer driver returns in the <CODE>fLandscape</CODE> field of this record a Boolean variable that indicates whether or not the <CODE>TPrint</CODE> record specifies landscape orientation. The user selects the type of orientation through the style dialog box, and the printer driver updates the fields of the <CODE>TPrint</CODE> record accordingly. <P>
 <A HREF=#MARKER-9-193>Listing 9-5</A> shows an application-defined function, <CODE>DoIsLandscapeModeSet</CODE>, that returns a Boolean value indicating whether the user has selected landscape orientation for the current document.<P>
<B>Listing 9-5  <A NAME=MARKER-9-193></A>Using the <CODE>getRotnOp</CODE> opcode with the <CODE>PrGeneral</CODE> procedure to determine page orientation</B><P>
<PRE>
FUNCTION DoIsLandscapeModeSet (thePrRecHdl: THPrint): Boolean;
VAR
   getRotRec:  TGetRotnBlk;
BEGIN
   getRotRec.iOpCode := getRotnOp;  {set opcode}
   getRotRec.hPrint := thePrRecHdl; {specify TPrint record}
   PrGeneral(@getRotRec);           {get landscape orientation}
   IF (getRotRec.iError = noErr) AND (PrError = noErr) AND
      getRotRec.fLandscape THEN
      DoIsLandscapeModeSet := TRUE
   ELSE 
      DoIsLandscapeModeSet := FALSE;
END;
</PRE>
<A NAME=HEADING408-122></A>
<H3><A NAME=MARKER-9-194></A>Enhancing Draft-Quality Printing</H3>
 <A NAME=MARKER-2-195></A>When the user selects faster, draft-quality printing from a job dialog box from some printer drivers, the printer driver handles the printing operation appropriately.<P>
 <A NAME=MARKER-2-196></A>However, you can force users to use an enhanced form of draft-quality printing on ImageWriter printers (as well as on other printers that may support enhanced draft-quality printing) by calling the <CODE>PrGeneral</CODE> procedure, specifying the <CODE>draftBitsOp</CODE> opcode in a <CODE>TDftBitsBlk</CODE> record (described on <A HREF=QuickDraw-421.html#MARKER-9-367>page 9-52</A>), and specifying the <CODE>TPrint</CODE> record for the operation. If your application produces only text, bitmaps, or pixel maps, this can increase performance and save disk space, because the printer driver prints the document immediately, rather than spooling it to disk as with deferred printing. The <CODE>draftBitsOp</CODE> opcode has no effect if the printer driver does not support draft-quality printing or does not support deferred printing. If the driver does not support the <CODE>draftBitsOp</CODE> opcode, the <CODE>PrGeneral</CODE> procedure returns the <CODE>opNotImpl</CODE> result code.<P>
 With draft-quality printing, a printer driver like the ImageWriter printer driver converts into drawing operations calls only to QuickDraw's text-drawing routines. The printer driver sends these text-drawing routines directly to the printer instead of using deferred printing to capture the entire image for a page in a spool file. Draft-quality printing produces quick, low-quality drafts of text documents that are printed straight down the page, from top to bottom and left to right. <P>
 Using the <CODE>PrGeneral</CODE> procedure, it's possible to produce enhanced draft-quality printing on some printers--such as ImageWriter printers. Normally, draft-quality printing renders output consisting only of text. However, <B>enhanced draft-quality printing</B> prints the bitmaps and pixel maps that your application draws using the <CODE>CopyBits</CODE> procedure (described in the chapter "QuickDraw Drawing" in this book) without using deferred printing to write to and read from a spool file. <P>
 Because it's supported by so few printer drivers, and because it offers little in the way of extra capability, enhanced draft-quality printing has limited usefulness. <P>
 To use enhanced draft-quality printing, call <CODE>PrGeneral</CODE> with the <CODE>draftBitsOp</CODE> opcode before using the <CODE>PrStlDialog</CODE> and <CODE>PrJobDialog</CODE> functions or the <CODE>PrDlgMain</CODE> function to present the style dialog box and job dialog box to the user. The use of the <CODE>draftBitsOp</CODE> opcode may cause items in the print dialog boxes to become inactive. For the ImageWriter printer driver, for example, the use of the <CODE>draftBitsOp</CODE> opcode makes the landscape icon in the style dialog box and the Best and Faster options in the job dialog box inactive. <A NAME=MARKER-2-197></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>If you call <CODE>PrGeneral</CODE> with the <CODE>draftBitsOp</CODE> opcode after using the <CODE>PrJobDialog</CODE> or <CODE>PrDlgMain</CODE> function, and if the user chooses draft printing from the job dialog box, the ImageWriter printer does not print any bitmaps or pixel maps contained in the document.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-198>Listing 9-6</A> illustrates how to implement enhanced draft-quality printing.<P>
<A NAME=MARKER-9-198></A><B>Listing 9-6  Using the <CODE>draftBitsOp</CODE> opcode with the <CODE>PrGeneral</CODE> procedure for enhanced draft-quality printing</B><P>
<PRE>
FUNCTION DoDraftBits (thePrRecHdl: THPrint): Boolean;
VAR
   draftBitsBlk:  TDftBitsBlk;
BEGIN
   draftBitsBlk.iOpCode := draftBitsOp;{set the opcode}
   draftBitsBlk.hPrint := thePrRecHdl; {specify the TPrint record}
   PrGeneral(@draftBitsBlk);        {use enhanced draft quality}
   IF (draftBitsBlk.iError = noErr) AND (PrError = noErr) THEN
      DoDraftBits := TRUE     {this TPrint record specifies }
                              { enhanced draft printing}
   ELSE 
      DoDraftBits := FALSE;   {this TPrint record does not }
                              { specify enhanced draft printing}
END;
</PRE>
 You should keep one additional point in mind when using the <CODE>draftBitsOp</CODE> opcode: all of the data that is printed must be sorted along the y axis, because reverse paper motion is not possible on the ImageWriter printer when printing in draft-quality mode. This means that you cannot print two objects side by side; that is, the top boundary of an object cannot be higher than the bottom boundary of the previous object. To get around this restriction, you should sort your objects before print time.<P>
 You can call <CODE>PrGeneral</CODE> with the <CODE>noDraftBitsOp</CODE> opcode to use regular draft-quality printing again. If you call <CODE>PrGeneral</CODE> with <CODE>noDraftBitsOp</CODE> without first calling <CODE>draftBitsOp</CODE>, the procedure does nothing. As with the <CODE>draftBitsOp</CODE> opcode, you should call <CODE>PrGeneral</CODE> with the <CODE>noDraftBitsOp</CODE> opcode before you present the style and job dialog boxes to the user.<A NAME=MARKER-2-199></A> <A NAME=MARKER-2-200></A><A NAME=MARKER-2-480></A><P>
<A NAME=HEADING408-135></A>
<H2><A NAME=MARKER-9-203></A>Altering the Style or Job Dialog Box</H2>
 <A NAME=MARKER-2-204></A><A NAME=MARKER-2-205></A>Each printer resource file includes definitions of the standard style and job dialog boxes that are specific to the type of printer managed by its printer driver. The <CODE>PrStlDialog</CODE> and <CODE>PrJobDialog</CODE> functions display the style and job dialog boxes defined by the resource file of the current printer. <P>
 For example, the standard style and job dialog boxes for the LaserWriter printer driver are shown in <A HREF=QuickDraw-407.html#MARKER-9-69>Figure 9-3 on page 9-6</A> and <A HREF=QuickDraw-407.html#MARKER-9-77>Figure 9-5 on page 9-7</A>, respectively. The standard dialog boxes provided by the StyleWriter printer driver are shown in <A HREF=QuickDraw-407.html#MARKER-9-66>Figure 9-2 on page 9-6</A> and <A HREF=QuickDraw-407.html#MARKER-9-74>Figure 9-4 on page 9-6</A>. Each dialog box has options that the user can set. If you want to use the standard style or job dialog box provided by the printer driver for the current printer, call the <CODE>PrStlDialog</CODE> function or the <CODE>PrJobDialog</CODE> function. <P>
 You may wish to add some additional options to these dialog boxes so that the user can customize the printing process even further. For example, <A HREF=#MARKER-9-206>Figure 9-12</A> illustrates a print job dialog box with two additional checkboxes: Print Selection Only and Skip Blank Pages.<P>
<A NAME=MARKER-9-206></A><B>Figure 9-12  A print job dialog box with additional checkboxes</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/QPM-S-09.jpg"><BR>
 You must follow these guidelines if you alter the style or job dialog boxes:<P>
<UL>
<LI>Add additional options below the standard ones in the dialog box and don't change the standard ones--that is, don't delete, rearrange, or add new items in the existing list. 
<LI>Don't count on an item retaining its current position on the screen or in the dialog item list.
<LI>Don't use more than half the smallest screen height for your items. (The smallest screen height is the 9-inch Macintosh Classic screen.) Printer drivers are allowed to expand the items in the standard dialog boxes to fill the top half of a 9-inch screen.
<LI>If you want to add a lot of items to the dialog boxes, be aware this may confuse users. You should consider having your own separate dialog box in addition to the existing style and job dialog boxes. <P>
</UL>
 You can customize a style or job dialog box by undertaking the following steps:<P>
<UL>
<LI>Use the <CODE>PrOpen</CODE> procedure to open the Printing Manager.
<LI>Use the <CODE>PrStlInit</CODE> or <CODE>PrJobInit</CODE> function to initialize a <CODE>TPrDlg</CODE> record. This record, described on <A HREF=QuickDraw-416.html#MARKER-9-303>page 9-47</A>, contains the information needed to set up the style or job dialog box.
<LI>Define an initialization routine that appends items to the printer driver's style or job dialog box. Your initialization routine should<P>
<UL>
<LI>use the Dialog Manager procedure <CODE>AppendDITL</CODE> to add items to the dialog box whose <CODE>TPrDlg</CODE> record you initialized with <CODE>PrStlInit</CODE> or <CODE>PrJobInit</CODE>
<LI>install two functions in the <CODE>TPrDlg</CODE> record: one--in the <CODE>pFltrProc</CODE> field--for handling events (such as update events for background applications) that the Dialog Manager doesn't handle in a modal dialog box, and another--in the <CODE>pItemProc</CODE> field--for handling events in the items added to the dialog box (for example, when the user clicks a checkbox that your application adds)
<LI>return a pointer to the <CODE>TPrDlg</CODE> record<P>
</UL>
<LI>Pass the address of your initialization routine to the <CODE>PrDlgMain</CODE> function to display the dialog box.
<LI>Respond to the dialog box as appropriate.
<LI>Use the <CODE>PrClose</CODE> procedure when you are finished using the Printing Manager.<P>
</UL>
 The event filter function pointed to in the <CODE>pFltrProc</CODE> field of the <CODE>TPrDlg</CODE> record extends the Dialog Manager's ability to handle events. When your application displays the style or job dialog box, you can use an event filter function to handle events that the Dialog Manager doesn't handle for modal dialog boxes. The chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> describes how to write an event filter function for the Dialog Manager.<A NAME=MARKER-2-207></A><P>
 The routine you supply in the <CODE>pItemProc</CODE> field of the <CODE>TPrDlg</CODE> record should handle events in the items you add to the dialog box. Sometimes called a <I>dialog hook</I>, this routine typically responds to clicks in the radio buttons or checkboxes that you add to the dialog box. <A NAME=MARKER-2-208></A><P>
 <A HREF=#MARKER-9-209>Listing 9-7</A> shows an application-defined routine called <CODE>DoPrintDialog</CODE> that specifies its own initialization function, called <CODE>MyPrDialogAppend</CODE>.<P>
<B>Listing 9-7  <A NAME=MARKER-9-209></A>Installing an initialization function to alter the print job dialog box</B><P>
<PRE>
FUNCTION DoPrintDialog: OSErr;   {display print job dialog box}
BEGIN
   PrOpen;     {open the Printing Manager}
   gPrintRec := THPrint(NewHandle(sizeof(TPrint)));{create a TPrint record}
   PrintDefault(gPrintRec);   {use default values for the TPrint record}
   gPrJobDialogBox := PrJobInit(gPrintRec);  {get a pointer to the }
                                             { invisible job dialog box}
   {use PrDlgMain to display the altered job dialog box}
   IF (PrDlgMain(gPrintRec, @MyPrDialogAppend)) THEN
      MyPrintDoc;
   PrClose;    {close the Printing Manager}
END;
</PRE>
 The application-defined routine <CODE>MyPrDialogAppend</CODE> is shown in <A HREF=#MARKER-9-210>Listing 9-8</A>. It uses the Resource Manager function <CODE>GetResource</CODE> to get a handle to an item list (<CODE>'DITL'</CODE>) resource containing the two extra checkboxes shown in <A HREF=#MARKER-9-206>Figure 9-12 on page 9-33</A>. Using the Dialog Manager procedure <CODE>AppendDITL</CODE>, <CODE>MyPrDialogAppend</CODE> appends the items in this item list resource to the print job dialog box. Then <CODE>MyPrDialogAppend</CODE> <BR>installs the application's event filter function for modal dialog boxes. Finally, <CODE>MyPrDialogAppend</CODE> installs it own routine, called <CODE>HandleMyAppendedItems</CODE>, to handle clicks in the two newly installed checkboxes.<P>
<B>Listing 9-8  <A NAME=MARKER-9-210></A>Adding items to a print job dialog box</B><P>
<PRE>
FUNCTION MyPrDialogAppend (hPrint: THPrint): TPPrDlg;
VAR
  MyAppendDITLH: Handle;
BEGIN
   IF gDITLAppended = FALSE THEN
   BEGIN
      {first, get item list resource containing checkboxes}
      MyAppendDITLH := GetResource('DITL', kPrintingCheckBoxes);
{next, append this item list resource to job dialog box}
      AppendDITL(DialogPtr(gPrJobDialogBox), MyAppendDITLH,
                 appendDITLBottom);
      gDITLAppended := TRUE;
   END;
   gFltrItemProc := LongInt(gPrJobDialogBox^.pFltrProc);
   {put an event filter function (to handle events that Dialog }
   { Manager doesn't handle in modal dialog boxes) }
   { in the pFltrProc field of the TPrDlg record}
   gPrJobDialogBox^.pFltrProc := ProcPtr(@MyEventFilter);
   gPrItemProc := LongInt(gPrJobDialogBox^.pItemProc);
   {put a dialog hook to handle clicks in appended items }
   { in the pItemProc field of the TPrDlg record}
   gPrJobDialogBox^.pItemProc := ProcPtr(@HandleMyAppendedItems);
   MyPrDialogAppend := gPrJobDialogBox;
END;
</PRE>
 See the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for information about item list resources, event filter functions for modal dialog boxes, and the <CODE>AppendDITL</CODE> procedure. See the chapter "Resource Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I> for information about the <CODE>GetResource</CODE> function.<A NAME=MARKER-2-211></A><A NAME=MARKER-2-212></A><P>
<A NAME=HEADING408-166></A>
<H2><A NAME=MARKER-9-213></A>Writing an Idle Procedure</H2>
 <A NAME=MARKER-2-214></A><A NAME=MARKER-2-896></A><A NAME=MARKER-2-216></A>The printer driver for the current printer periodically calls an idle procedure while it sends a document to the printer. The <CODE>TPrJob</CODE> record contained in the <CODE>TPrint</CODE> record contains a pointer to an idle procedure in the <CODE>pIdleProc</CODE> field. If this field contains the value <CODE>NIL</CODE>, then the printer driver uses the Printing Manager's default idle procedure. The default idle procedure checks for Command-period keyboard events and sets the <CODE>iPrAbort</CODE> error code if one occurs, so that your application can cancel the print job at the user's request. However, the default idle procedure does not display a print status dialog box. It is up to the printer driver or your application to display a print status dialog box. <P>
 <A NAME=MARKER-2-217></A>Most printer drivers display their own status dialog boxes. However, your application can display its own status dialog box that reports the current status of the printing operation to the user. If it does, your status dialog box should allow the user to press Command-period to cancel the printing operation, and it may also provide a button allowing the user to cancel the printing operation. To handle update events in your status dialog box, Command-period keyboard events, and clicks in your Cancel button (if you provide one), you should provide your own idle procedure. (See <A HREF=QuickDraw-407.html#MARKER-9-117>Figure 9-9 on page 9-12</A> for an example of an application-defined status dialog box.)<P>
 Here are several guidelines you must follow when writing your own idle procedure.<P>
<UL>
<LI>If you designate an idle procedure, you must set the <CODE>pIdleProc</CODE> field of the <CODE>TPrJob</CODE> record <I>after</I> presenting the style and job dialog boxes, validating the <CODE>TPrint</CODE> record, and initializing the fields in the <CODE>TPrint</CODE> record (because the routines that perform these operations may reset the <CODE>pIdleProc</CODE> field to <CODE>NIL</CODE>). The <CODE>TPrJob</CODE> record is described on <A HREF=QuickDraw-413.html#MARKER-9-259>page 9-44</A>.
<LI>You must install your idle procedure in the <CODE>TPrint</CODE> record before calling the <CODE>PrOpenDoc</CODE> function. Otherwise, some printer drivers do not give the idle procedure any time to run. <A NAME=MARKER-2-218></A>
<LI>Do not attempt any printing from within the idle procedure, because the Printing Manager is <I>not</I> reentrant.
<LI>Do not reference global variables unless you set up your own A5 world (as described in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I>).
<LI>If you use a modal dialog box to display printing status information, you must call the Event Manager function <CODE>WaitNextEvent</CODE> (described in the chapter "Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>) to capture mouse events or the Command-period keyboard event that signals that the user wants to cancel printing. Do not call the <CODE>WaitNextEvent</CODE> function unless you display a modal dialog box.
<LI>So that your application doesn't draw into a printing port, don't call the QuickDraw <CODE>OpenPicture</CODE> function or the <CODE>DrawPicture</CODE> procedure from your idle procedure without changing the current graphics port.
<LI>Upon entry to the idle procedure, you must save the printing graphics port, and you must restore it upon exit if you draw anything within the idle procedure. If you don't save and restore the printing graphics port, upon return the printer driver draws into the graphics port of your dialog box instead of its own printing graphics port. To save the printer's printing graphics port, call the <CODE>GetPort</CODE> procedure when entering the idle procedure. Before you exit, call the <CODE>SetPort</CODE> procedure to set the port back to the printer driver's printing graphics port. (The <CODE>GetPort</CODE> and <CODE>SetPort</CODE> procedures are described in the chapter "Basic QuickDraw" in this book.)
<LI>If your idle procedure changes the resource chain, you should save the reference number of the printer driver's resource file by calling the <CODE>CurResFile</CODE> function at the beginning of your idle procedure. (Any routine that changes the value of the global variable <CODE>TopMapHdl</CODE>, such as the <CODE>OpenResFile</CODE> function or the <CODE>UseResFile</CODE> procedure, changes the resource chain. Some printer drivers assume the resource chain does not change, and you may get an error if you change it.) When you exit from the idle procedure, restore the resource chain using the <CODE>UseResFile</CODE> procedure. If you are not changing the resource chain, you do not need to save the resource chain. (The <CODE>CurResFile</CODE>, <CODE>OpenResFile</CODE>, and <CODE>UseResFile</CODE> routines are described in the chapter "Resource Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>.)<A NAME=MARKER-2-219></A>
<LI>Avoid calling the <CODE>PrError</CODE> function within the idle procedure. Errors that occur while it is executing are usually temporary and serve only as internal flags for communication within the printer driver, not for the application. If you absolutely must call <CODE>PrError</CODE> within your idle procedure and an error occurs, do not cancel printing. Wait until the last called printing procedure returns and then check to see if the error still remains. <P>
</UL>
 <A HREF=#MARKER-9-220>Listing 9-9</A> shows an application-defined idle procedure.<P>
<B>Listing 9-9  <A NAME=MARKER-9-220></A>An idle procedure</B><P>
<PRE>
PROCEDURE MyDoPrintIdle;
VAR
   oldPort:          GrafPtr;
   cursorRgn:        RgnHandle;
   event:            EventRecord;
   gotEvent:         Boolean;
   itemHIt:          Integer;
   handled, canceled:   Boolean;
BEGIN
   GetPort(oldPort);
   SetPort(gPrintStatusDlg);
   cursorRgn := NIL;
   gotEvent := WaitNextEvent(everyEvent, event, 15, cursorRgn);
   IF gotEvent THEN
   BEGIN
      handled := MyStatusHandleEvent(gPrintStatusDlg, event,
                                    itemHit);
      canceled := MyUserDidCancel;
      IF canceled THEN
         itemHit := kStopButton;
      handled := MyDoHandleHitsInStatusDBox(itemHit);
   END;
   MyUpdateStatusInformation(canceled);   {update status }
                               { information in dialog box}
   SetPort(oldPort);
END;
</PRE>
 The application displays a modal dialog box for its status dialog box, and then installs <CODE>MyDoPrintIdle</CODE>, which calls the Event Manager function <CODE>WaitNextEvent</CODE> to capture events while the modal dialog box is displayed.<P>
 The <CODE>MyDoPrintIdle</CODE> procedure first saves the current graphics port (so that it can later restore it) and then sets the current port to the graphics port of the status dialog box. Your idle procedure should save, set, and restore the graphics port in this manner to avoid accidentally drawing in the printing graphics port. <P>
 The <CODE>MyDoPrintIdle</CODE> procedure then calls <CODE>WaitNextEvent</CODE> to get the current event and then calls its own routine to handle the event. (For example, the <CODE>MyStatusHandleEvent</CODE> function handles update and activate events.) By calling <CODE>WaitNextEvent</CODE>, <CODE>MyDoPrintIdle</CODE> gives background applications a chance to handle update events in their windows while the application in this example displays a modal dialog box. (The Dialog Manager does not give background applications a chance to handle update events in their windows when a modal dialog box is displayed.)<P>
 <CODE>MyDoPrintIdle</CODE> then calls another application-defined procedure to determine whether the user wishes to cancel the printing operation. The <CODE>MyUserDidCancel</CODE> function scans the event queue for keyboard events and mouse events. If it finds a Command-period keyboard event, it returns <CODE>TRUE</CODE>. The <CODE>MyUserDidCancel</CODE> function also returns <CODE>TRUE</CODE> if it finds mouse events indicating that the user clicked the Stop Printing button (that is, it uses the Dialog Manager function <CODE>FindDialogItem</CODE> to determine whether the mouse location specified in a mouse event is in the Stop Printing button). If the user clicks the Stop Printing button, <CODE>MyUserDidCancel</CODE> highlights the button appropriately.<P>
 To handle hits in the status dialog box, the <CODE>MyDoHandleHitsInStatusDBox</CODE> function simply checks the item number passed to it. For the Stop Printing button, <CODE>MyDoHandleHitsInStatusDBox</CODE> calls <CODE>PrSetError</CODE>, specifying the error code <CODE>iPrAbort</CODE>. For all other items, <CODE>MyDoHandleHitsInStatusDBox</CODE> sets the cursor to a spinning wristwatch cursor.<A NAME=MARKER-2-898></A><P>
 Finally, the <CODE>MyDoPrintIdle</CODE> procedure updates the items in the status dialog box that report status to the user.<A NAME=MARKER-2-222></A><A NAME=MARKER-2-223></A><P>
<A NAME=HEADING408-188></A>
<H2><A NAME=MARKER-9-224></A>Handling Printing Errors</H2>
 <A NAME=MARKER-2-39></A><A NAME=MARKER-2-2></A>You should always check for error conditions while printing by calling the <CODE>PrError</CODE> function. Errors returned may include AppleTalk and Operating System errors in addition to Printing Manager errors.<P>
<DL>
<DT><B>Note</B>
<DD>Don't call <CODE>PrError</CODE> from within your idle procedure. See <A HREF=#MARKER-9-213>"Writing an Idle Procedure" on page 9-35</A> for more information.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 If you determine that an error has occurred after the completion of a printing routine, stop printing. Call the close routine that matches any open routine you have called. For example, if you call <CODE>PrOpenDoc</CODE> and receive an error, skip to the next call to <CODE>PrCloseDoc</CODE>; if you call <CODE>PrOpenPage</CODE> and get an error, skip to the next calls to <CODE>PrClosePage</CODE> and <CODE>PrCloseDoc</CODE>. Remember that, if you have called some open routine, you must call the corresponding close routine to ensure that the printer driver closes properly and that all temporary memory allocations are released and returned to the heap. <P>
 <A NAME=MARKER-2-3></A>If you are using the <CODE>PrError</CODE> function and the <CODE>PrGeneral</CODE> procedure (described in <A HREF=#MARKER-9-173>"Getting and Setting Printer Information" beginning on page 9-26</A>), be prepared to receive the following errors: <CODE>noSuchRsl</CODE>, <CODE>opNotImpl</CODE>, and <CODE>resNotFound</CODE>. In all three cases, your application should be prepared to continue to print without using the features of that particular opcode.<P>
 The <CODE>noSuchRsl</CODE> error means that the currently selected printer does not support the requested resolution. The <CODE>opNotImpl</CODE> error means that the currently selected printer does not support the particular <CODE>PrGeneral</CODE> opcode that you selected. The <CODE>resNotFound</CODE> error means the current printer driver does not support the <CODE>PrGeneral</CODE> procedure at all. This lack of support should not be a problem for your application, but you need to be prepared to deal with this error. If you receive a <CODE>resNotFound</CODE> result code from <CODE>PrError</CODE>, clear the error with a call to <CODE>PrSetError</CODE> with a value of <CODE>noErr</CODE> as the parameter; otherwise, <CODE>PrError</CODE> might still contain this error the next time you check it, which would prevent your application from printing.<A NAME=MARKER-11-77></A><P>
 Do not display any alert or dialog boxes to report an error until the end of the printing loop. Once at the end, check for the error again; if there is no error, assume that the printing completed normally. If the error is still present, then you can alert the user. This technique is important for two reasons. <P>
<UL>
<LI>First, if you display a dialog box in the middle of the printing loop, it could cause errors that might terminate an otherwise normal printing operation. For example, if the printer is connected to an AppleTalk network, the connection might be terminated abnormally because the printer driver would be unable to respond to AppleTalk requests received from the printer while the dialog box was waiting for input from the user. If the printer does not hear from the Macintosh Operating System within a short period of time (anywhere from 30 seconds to 2 minutes, depending on the driver), it assumes that the Macintosh computer is no longer connected to the printer and times out. The timeout results in a prematurely broken connection, causing another error, to which the application must respond.
<LI>Second, the printer driver may have already displayed its own dialog box in response to an error. In this instance, the printer driver posts an error to let the application know that something went wrong and it should cancel printing. For example, when a LaserWriter printer driver detects that the user has canceled printing, the driver posts an error to let the application know that it needs to cancel printing. Because the driver has already taken care of the error by displaying a dialog box, the error is reset to 0 before the printing loop is complete. The application should check for the error again at the end of the printing loop, and, if appropriate, the application can then display a dialog box.<A NAME=MARKER-2-47></A><A NAME=MARKER-2-50></A><P>
</UL>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="QuickDraw-408.html#HEADING408-15">Creating and Using a TPrint Record</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-28">Printing a Document</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-67">Printing From the Finder</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-78">Providing Names of Documents Being Printed</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-83">Printing Hints</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-92">Getting and Setting Printer Information</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-104">Determining and Setting the Resolution of the Current Printer</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-116">Determining Page Orientation</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-122">Enhancing Draft-Quality Printing</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-135">Altering the Style or Job Dialog Box</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-166">Writing an Idle Procedure</A>
<DD>
<DT><A HREF="QuickDraw-408.html#HEADING408-188">Handling Printing Errors</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-407.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-409.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
