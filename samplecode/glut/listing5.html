<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /gle/extrude.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/gle/extrude.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">
/*
 * MODULE: extrude.c
 *
 * FUNCTION:
 * Provides  code for the cylinder, cone and extrusion routines. 
 * The cylinders/cones/etc. are built on top of general purpose
 * extrusions. The code that handles the general purpose extrusions 
 * is in other modules.
 * 
 * AUTHOR:
 * written by Linas Vepstas August/September 1991
 * added polycone, February 1993
 */
#ifdef __APPLE__
#include &quot;gle_osx.h&quot;
#endif

#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;    /* for the memcpy() subroutine */
#include &lt;tube.h&gt;
#include &quot;gutil.h&quot;
#include &quot;vvector.h&quot;
#include &quot;tube_gc.h&quot;
#include &quot;extrude.h&quot;
#include &quot;intersect.h&quot;

/* ============================================================ */
/* The routine below  determines the type of join style that will be
 * used for tubing. */

void gleSetJoinStyle (int style) 
{
   INIT_GC();
   extrusion_join_style = style;
}

int gleGetJoinStyle (void)
{
   INIT_GC();
   return (extrusion_join_style);
}

/* ============================================================ */
/*
 * draw a general purpose extrusion 
 */

void gleSuperExtrusion (int ncp,               /* number of contour points */
                gleDouble contour[][2],    /* 2D contour */
                gleDouble cont_normal[][2], /* 2D contour normals */
                gleDouble up[3],           /* up vector for contour */
                int npoints,           /* numpoints in poly-line */
                gleDouble point_array[][3],        /* polyline */
                float color_array[][3],        /* color of polyline */
                gleDouble xform_array[][2][3])   /* 2D contour xforms */
{   
   INIT_GC();
   _gle_gc -&gt; ncp = ncp;
   _gle_gc -&gt; contour = contour;
   _gle_gc -&gt; cont_normal = cont_normal;
   _gle_gc -&gt; up = up;
   _gle_gc -&gt; npoints = npoints;
   _gle_gc -&gt; point_array = point_array;
   _gle_gc -&gt; color_array = color_array;
   _gle_gc -&gt; xform_array = xform_array;

   switch (__TUBE_STYLE) {
      case TUBE_JN_RAW:
         (void) extrusion_raw_join (ncp, contour, cont_normal, up,
                                    npoints,
                                    point_array, color_array,
                                    xform_array);
         break;

      case TUBE_JN_ANGLE:
         (void) extrusion_angle_join (ncp, contour, cont_normal, up,
                                    npoints,
                                    point_array, color_array,
                                    xform_array);
         break;

      case TUBE_JN_CUT:
      case TUBE_JN_ROUND:
         /* This routine used for both cut and round styles */
         (void) extrusion_round_or_cut_join (ncp, contour, cont_normal, up,
                                    npoints,
                                    point_array, color_array,
                                    xform_array);
         break;

      default:
         break;
   }
}

/* ============================================================ */

void gleExtrusion (int ncp,               /* number of contour points */
                gleDouble contour[][2],    /* 2D contour */
                gleDouble cont_normal[][2], /* 2D contour normals */
                gleDouble up[3],           /* up vector for contour */
                int npoints,           /* numpoints in poly-line */
                gleDouble point_array[][3],        /* polyline */
                float color_array[][3])        /* color of polyline */
{   
   gleSuperExtrusion (ncp, contour, cont_normal, up,
                    npoints,
                    point_array, color_array,
                    NULL);
}

/* ============================================================ */

/* should really make this an adaptive algorithm ... */
static int __gleSlices = 20;

int
gleGetNumSlices(void)
{
  return __gleSlices;
}

void
gleSetNumSlices(int slices)
{
  __gleSlices = slices;
}

void gen_polycone (int npoints,
               gleDouble point_array[][3],
               float color_array[][3],
               gleDouble radius,
               gleDouble xform_array[][2][3])
{
   int saved_style;
   glePoint *circle = (glePoint*) malloc(sizeof(glePoint)*2*__gleSlices);
   glePoint *norm = &amp;circle[__gleSlices];
   double c, s;
   int i;
   double v21[3];
   double len;
   gleDouble up[3];

   INIT_GC();

   /* this if statement forces this routine into double-duty for
    * both the polycone and the polycylinder routines */
   if (xform_array != NULL) radius = 1.0;

   s = sin (2.0*M_PI/ ((double) __gleSlices));
   c = cos (2.0*M_PI/ ((double) __gleSlices));

   norm [0][0] = 1.0;
   norm [0][1] = 0.0;
   circle [0][0] = radius;
   circle [0][1] = 0.0;

   /* draw a norm using recursion relations */
   for (i=1; i&lt;__gleSlices; i++) {
      norm [i][0] = norm[i-1][0] * c - norm[i-1][1] * s;
      norm [i][1] = norm[i-1][0] * s + norm[i-1][1] * c;
      circle [i][0] = radius * norm[i][0];
      circle [i][1] = radius * norm[i][1];
   }

   /* avoid degenerate vectors */
   /* first, find a non-zero length segment */
   i=0;
   FIND_NON_DEGENERATE_POINT(i,npoints,len,v21,point_array)
   if (i == npoints) return;

   /* next, check to see if this segment lies along x-axis */
   if ((v21[0] == 0.0) &amp;&amp; (v21[2] == 0.0)) {
      up[0] = up[1] = up[2] = 1.0;
   } else {
      up[0] = up[2] = 0.0;
      up[1] = 1.0;
   }

   /* save the current join style */
   saved_style = extrusion_join_style;
   extrusion_join_style |= TUBE_CONTOUR_CLOSED;

   /* if lighting is not turned on, don't send normals.  
    * MMODE is a good indicator of whether lighting is active */
   if (!__IS_LIGHTING_ON) {
       gleSuperExtrusion (__gleSlices, circle, NULL, up,
                     npoints, point_array, color_array,
                     xform_array);
   } else {
       gleSuperExtrusion (__gleSlices, circle, norm, up,
                     npoints, point_array, color_array,
                     xform_array);
   }
   
   /* restore the join style */
   extrusion_join_style = saved_style;

   free(circle);
}

/* ============================================================ */

void glePolyCylinder (int npoints,
                   gleDouble point_array[][3],
                   float color_array[][3],
                   gleDouble radius)
{
   gen_polycone (npoints, point_array, color_array, radius, NULL);
}

/* ============================================================ */

void glePolyCone (int npoints,
               gleDouble point_array[][3],
               float color_array[][3],
               gleDouble radius_array[])
{
   gleAffine * xforms;
   int j;

   /* build 2D affine matrices from radius array */
   xforms = (gleAffine *) malloc (npoints * sizeof(gleAffine));
   for (j=0; j&lt;npoints; j++) {
      AVAL(xforms,j,0,0) = radius_array[j];
      AVAL(xforms,j,0,1) = 0.0;
      AVAL(xforms,j,0,2) = 0.0;
      AVAL(xforms,j,1,0) = 0.0;
      AVAL(xforms,j,1,1) = radius_array[j];
      AVAL(xforms,j,1,2) = 0.0;
   }

   gen_polycone (npoints, point_array, color_array, 1.0, xforms);

   free (xforms);
}

/* ============================================================ */

void gleTwistExtrusion (int ncp,         /* number of contour points */
                gleDouble contour[][2],    /* 2D contour */
                gleDouble cont_normal[][2], /* 2D contour normals */
                gleDouble up[3],           /* up vector for contour */
                int npoints,           /* numpoints in poly-line */
                gleDouble point_array[][3],        /* polyline */
                float color_array[][3],        /* color of polyline */
                gleDouble twist_array[])   /* countour twists (in degrees) */

{
   int j;
   double angle;
   double si, co;

   gleAffine *xforms;

   /* build 2D affine matrices from radius array */
   xforms = (gleAffine *) malloc (npoints * sizeof(gleAffine));

   for (j=0; j&lt;npoints; j++) {
      angle = (M_PI/180.0) * twist_array[j];
      si = sin (angle);
      co = cos (angle);
      AVAL(xforms,j,0,0) = co;
      AVAL(xforms,j,0,1) = -si;
      AVAL(xforms,j,0,2) = 0.0;
      AVAL(xforms,j,1,0) = si;
      AVAL(xforms,j,1,1) = co;
      AVAL(xforms,j,1,2) = 0.0;
   }

   gleSuperExtrusion (ncp,               /* number of contour points */
                contour,    /* 2D contour */
                cont_normal, /* 2D contour normals */
                up,           /* up vector for contour */
                npoints,           /* numpoints in poly-line */
                point_array,        /* polyline */
                color_array,        /* color of polyline */
                xforms);

   free (xforms);
}

/* ============================================================ */
/* 
 * The spiral primitive forms the basis for the helicoid primitive.
 *
 * Note that this primitive sweeps a contour along a helical path.
 * The algorithm assumes that the path is embedded in Euclidean space,
 * and uses parallel transport along the path.  Parallel transport
 * provides the simplest mathematical model for moving a coordinate 
 * system along a curved path, but some of the effects of doing so 
 * may prove to be surprising to one uninitiated to the concept.
 *
 * Thus, we provide another, related, algorithm below, called &quot;lathe&quot;
 * which introduces a torsion component along the path, correcting for
 * the rotation induced by the helical path.
 *
 * If the above sounds like gobldy-gook to you, you may want to brush 
 * up on differential geometry. Recommend Spivak, Differential Geometry,
 * Volume 1, pages xx-xx.
 */

void gleSpiral (int ncp,               /* number of contour points */
             gleDouble contour[][2],    /* 2D contour */
             gleDouble cont_normal[][2], /* 2D contour normals */
             gleDouble up[3],           /* up vector for contour */
             gleDouble startRadius,
             gleDouble drdTheta,        /* change in radius per revolution */
             gleDouble startZ,
             gleDouble dzdTheta,        /* change in Z per revolution */
             gleDouble startXform[2][3],
             gleDouble dXformdTheta[2][3], /* tangent change xform per revolution */
             gleDouble startTheta,          /* start angle, in degrees */
             gleDouble sweepTheta)        /* sweep angle, in degrees */
{
   int npoints;
   gleDouble deltaAngle;
   char * mem_anchor;
   gleDouble *pts;
   gleAffine *xforms;
   double delta;

   int saved_style;
   double ccurr, scurr;
   double cprev, sprev;
   double cdelta, sdelta;
   double mA[2][2], mB[2][2];
   double run[2][2];
   double deltaTrans[2];
   double trans[2];
   int i;

   /* allocate sufficient memory to store path */
   npoints = (int) ((((double) __gleSlices) /360.0) * fabs(sweepTheta)) + 4;

   if (startXform == NULL) {
      mem_anchor = malloc (3*npoints * sizeof (gleDouble));
      pts = (gleDouble *) mem_anchor;
      xforms = NULL;
   } else {
      mem_anchor = malloc ((1+2)* 3*npoints * sizeof (gleDouble));
      pts = (gleDouble *) mem_anchor;
      xforms = (gleAffine *) (pts + 3*npoints);
   }

   /* compute delta angle based on number of points */
   deltaAngle = (M_PI / 180.0) * sweepTheta / ((gleDouble) (npoints-3));
   startTheta *= M_PI / 180.0;
   startTheta -= deltaAngle;

   /* initialize factors */
   cprev = cos ((double) startTheta);
   sprev = sin ((double) startTheta);

   cdelta = cos ((double) deltaAngle);
   sdelta = sin ((double) deltaAngle);

   /* renormalize differential factors */
   delta = deltaAngle / (2.0 * M_PI);
   dzdTheta *= delta;
   drdTheta *= delta;

   /* remember, the first point is hidden, so back-step */
   startZ -=  dzdTheta;
   startRadius -=  drdTheta;

   /* draw spiral path using recursion relations for sine, cosine */
   for (i=0; i&lt;npoints; i++) {
      pts [3*i] =  startRadius * cprev;
      pts [3*i+1] =  startRadius * sprev;
      pts [3*i+2] = (gleDouble) startZ;

      startZ +=  dzdTheta;
      startRadius +=  drdTheta;
      ccurr = cprev * cdelta - sprev * sdelta;
      scurr = cprev * sdelta + sprev * cdelta;
      cprev = ccurr;
      sprev = scurr;
   }

   /* If there is a deformation matrix specified, then a deformation
    * path must be generated also */
   if (startXform != NULL) {
      if (dXformdTheta == NULL) {
         for (i=0; i&lt;npoints; i++) {
            xforms[i][0][0] = startXform[0][0];
            xforms[i][0][1] = startXform[0][1];
            xforms[i][0][2] = startXform[0][2];
            xforms[i][1][0] = startXform[1][0];
            xforms[i][1][1] = startXform[1][1];
            xforms[i][1][2] = startXform[1][2];
         }
      } else {
         /* 
          * if there is a differential matrix specified, treat it a 
          * a tangent (algebraic, infinitessimal) matrix.  We need to
          * project it into the group of real 2x2 matricies.  (Note that
          * the specified matrix is affine.  We treat the translation 
          * components linearly, and only treat the 2x2 submatrix as an 
          * algebraic tangenet).
          *
          * For exponentiaition, we use the well known approx:
          * exp(x) = lim (N-&gt;inf) (1+x/N) ** N
          * and take N=32. 
          */

         /* initialize translation and delta translation */
         deltaTrans[0] = delta * dXformdTheta[0][2];
         deltaTrans[1] = delta * dXformdTheta[1][2];
         trans[0] = startXform[0][2];
         trans[1] = startXform[1][2];
   
         /* prepare the tangent matrix */
         delta /= 32.0;
         mA[0][0] = 1.0 + delta * dXformdTheta[0][0];
         mA[0][1] = delta * dXformdTheta[0][1];
         mA[1][0] = delta * dXformdTheta[1][0];
         mA[1][1] = 1.0 + delta * dXformdTheta[1][1];
   
         /* compute exponential of matrix */
         MATRIX_PRODUCT_2X2 (mB, mA, mA);  /* squared */
         MATRIX_PRODUCT_2X2 (mA, mB, mB);  /* 4th power */
         MATRIX_PRODUCT_2X2 (mB, mA, mA);  /* 8th power */
         MATRIX_PRODUCT_2X2 (mA, mB, mB);  /* 16th power */
         MATRIX_PRODUCT_2X2 (mB, mA, mA);  /* 32nd power */
   
         /* initialize running matrix */
         COPY_MATRIX_2X2 (run, startXform);
   
         /* remember, the first point is hidden -- load some, any 
          * xform for the first point */
         xforms[0][0][0] = startXform[0][0];
         xforms[0][0][1] = startXform[0][1];
         xforms[0][0][2] = startXform[0][2];
         xforms[0][1][0] = startXform[1][0];
         xforms[0][1][1] = startXform[1][1];
         xforms[0][1][2] = startXform[1][2];

         for (i=1; i&lt;npoints; i++) {
#ifdef FUNKY_C
            xforms[6*i] = run[0][0];
            xforms[6*i+1] = run[0][1];
            xforms[6*i+3] = run[1][0];
            xforms[6*i+4] = run[1][1];
#endif /* FUNKY_C */
            xforms[i][0][0] = run[0][0];
            xforms[i][0][1] = run[0][1];
            xforms[i][1][0] = run[1][0];
            xforms[i][1][1] = run[1][1];

            /* integrate to get exponential matrix */
            /* (Note that the group action is a left-action --
             * i.e. multiply on the left (not the right)) */
            MATRIX_PRODUCT_2X2 (mA, mB, run);
            COPY_MATRIX_2X2 (run, mA);
         
#ifdef FUNKY_C
            xforms[6*i+2] = trans [0];
            xforms[6*i+5] = trans [1];
#endif /* FUNKY_C */
            xforms[i][0][2] = trans [0];
            xforms[i][1][2] = trans [1];
            trans[0] += deltaTrans[0];
            trans[1] += deltaTrans[1];

         }
      }
   }

   /* save the current join style */
   saved_style = extrusion_join_style;

   /* Allow only angle joins (for performance reasons).
    * The idea is that if the tesselation is fine enough, then an angle
    * join should be sufficient to get the desired visual quality.  A 
    * raw join would look terrible, an cut join would leave garbage 
    * everywhere, and a round join will over-tesselate (and thus 
    * should be avoided for performance reasons). 
    */
   extrusion_join_style  &amp;= ~TUBE_JN_MASK; 
   extrusion_join_style  |= TUBE_JN_ANGLE;

   gleSuperExtrusion (ncp, contour, cont_normal, up,
                  npoints, (gleVector *) pts, NULL, xforms);

   /* restore the join style */
   extrusion_join_style = saved_style;

   free (mem_anchor);

}


/* ============================================================ */
/* 
 */

void gleLathe (int ncp,               /* number of contour points */
             gleDouble contour[][2],    /* 2D contour */
             gleDouble cont_normal[][2], /* 2D contour normals */
             gleDouble up[3],           /* up vector for contour */
             gleDouble startRadius,
             gleDouble drdTheta,        /* change in radius per revolution */
             gleDouble startZ,
             gleDouble dzdTheta,        /* change in Z per revolution */
             gleDouble startXform[2][3],
             gleDouble dXformdTheta[2][3], /* tangent change xform per revln */
             gleDouble startTheta,          /* start angle, in degrees */
             gleDouble sweepTheta)        /* sweep angle, in degrees */
{
   gleDouble localup[3];
   gleDouble len;
   gleDouble trans[2];
   gleDouble start[2][3], delt[2][3];

   /* Because the spiral always starts on the axis, and proceeds in the
    * positive y direction, we can see that valid up-vectors must lie 
    * in the x-z plane. Therefore, we make sure we have a valid up
    * vector by projecting it onto the x-z plane, and normalizing. */
   if (up[1] != 0.0) {
      localup[0] = up[0];
      localup[1] = 0.0;
      localup[2] = up[2];
      VEC_LENGTH (len, localup);
      if (len != 0.0) {
         len = 1.0/len;
         localup[0] *= len;
         localup[2] *= len;
         VEC_SCALE (localup, len, localup);
      } else {
         /* invalid up vector was passed in */
         localup[0] = 0.0;
         localup[2] = 1.0;
      }
   } else {
      VEC_COPY (localup, up);
   }

   /* the dzdtheta derivative and the drdtheta derivative form a vector
    * in the x-z plane.  dzdtheta is the z component, and drdtheta is 
    * the x component.  We need to convert this vector into the local 
    * coordinate system defined by the up vector.  We do this by 
    * applying a 2D rotation matrix. 
    */
   trans[0] = localup[2] * drdTheta - localup[0] * dzdTheta;
   trans[1] = localup[0] * drdTheta + localup[2] * dzdTheta;

   /* now, add this translation vector into the affine xform */
   if (startXform != NULL) {
      if (dXformdTheta != NULL) {
         COPY_MATRIX_2X3 (delt, dXformdTheta);
         delt[0][2] += trans[0];
         delt[1][2] += trans[1];
      } else {
         /*Hmm- the transforms don't exist */

         delt[0][0] = 0.0;
         delt[0][1] = 0.0;
         delt[0][2] = trans[0];
         delt[1][0] = 0.0;
         delt[1][1] = 0.0;
         delt[1][2] = trans[1];
      }
      gleSpiral (ncp, contour, cont_normal, up, 
              startRadius, 0.0, startZ, 0.0,
              startXform, delt,
              startTheta, sweepTheta);

   } else {
      /* Hmm- the transforms don't exist */
      start[0][0] = 1.0;
      start[0][1] = 0.0;
      start[0][2] = 0.0;
      start[1][0] = 0.0;
      start[1][1] = 1.0;
      start[1][2] = 0.0;

      delt[0][0] = 0.0;
      delt[0][1] = 0.0;
      delt[0][2] = trans[0];
      delt[1][0] = 0.0;
      delt[1][1] = 0.0;
      delt[1][2] = trans[1];
      gleSpiral (ncp, contour, cont_normal, up, 
              startRadius, 0.0, startZ, 0.0,
              start, delt,
              startTheta, sweepTheta);
   }
}


/* ============================================================ */
/*
 * Super-Helicoid primitive 
 */

typedef void (*HelixCallback) (
             int ncp,               
             gleDouble contour[][2],
             gleDouble cont_normal[][2],
             gleDouble up[3],
             gleDouble startRadius,
             gleDouble drdTheta,
             gleDouble startZ,
             gleDouble dzdTheta,
             gleDouble startXform[2][3],
             gleDouble dXformdTheta[2][3],
             gleDouble startTheta,
             gleDouble sweepTheta);

void super_helix (gleDouble rToroid,
             gleDouble startRadius,
             gleDouble drdTheta,        /* change in radius per revolution */
             gleDouble startZ,
             gleDouble dzdTheta,        /* change in Z per revolution */
             gleDouble startXform[2][3],
             gleDouble dXformdTheta[2][3], /* tangent change xform per revol */
             gleDouble startTheta,          /* start angle, in degrees */
             gleDouble sweepTheta,        /* sweep angle, in degrees */
         HelixCallback helix_callback)
{

   int saved_style;
   glePoint *circle = (glePoint*) malloc(sizeof(glePoint)*2*__gleSlices);
   glePoint *norm = &amp;circle[__gleSlices];
   double c, s;
   int i;
   gleDouble up[3];

   /* initialize sine and cosine for circle recusrion equations */
   s = sin (2.0*M_PI/ ((double) __gleSlices));
   c = cos (2.0*M_PI/ ((double) __gleSlices));

   norm [0][0] = 1.0;
   norm [0][1] = 0.0;
   circle [0][0] = rToroid;
   circle [0][1] = 0.0;

   /* draw a norm using recursion relations */
   for (i=1; i&lt;__gleSlices; i++) {
      norm [i][0] = norm[i-1][0] * c - norm[i-1][1] * s;
      norm [i][1] = norm[i-1][0] * s + norm[i-1][1] * c;
      circle [i][0] = rToroid * norm[i][0];
      circle [i][1] = rToroid * norm[i][1];
   }

   /* make up vector point along x axis */
   up[1] = up[2] = 0.0;
   up[0] = 1.0;

   /* save the current join style */
   saved_style = extrusion_join_style;
   extrusion_join_style |= TUBE_CONTOUR_CLOSED;
   extrusion_join_style |= TUBE_NORM_PATH_EDGE;

   /* if lighting is not turned on, don't send normals.  
    * MMODE is a good indicator of whether lighting is active */
   if (!__IS_LIGHTING_ON) {
      (*helix_callback) (__gleSlices, circle, NULL, up,
             startRadius,
             drdTheta,
             startZ,
             dzdTheta,
             startXform,
             dXformdTheta,
             startTheta,
             sweepTheta);
   } else {
      (*helix_callback) (__gleSlices, circle, norm, up,
             startRadius,
             drdTheta,
             startZ,
             dzdTheta,
             startXform,
             dXformdTheta,
             startTheta,
             sweepTheta);
   }
   
   /* restore the join style */
   extrusion_join_style = saved_style;

   free(circle);
}

/* ============================================================ */
/*
 * Helicoid primitive 
 * Uses Parallel Transport to take a circular contour along a helical
 * path.
 */

void gleHelicoid (gleDouble rToroid,
             gleDouble startRadius,
             gleDouble drdTheta,        /* change in radius per revolution */
             gleDouble startZ,
             gleDouble dzdTheta,        /* change in Z per revolution */
             gleDouble startXform[2][3],
             gleDouble dXformdTheta[2][3], /* tangent change xform per revol */
             gleDouble startTheta,          /* start angle, in degrees */
             gleDouble sweepTheta)        /* sweep angle, in degrees */
{
   super_helix (rToroid,
             startRadius,
             drdTheta,        /* change in radius per revolution */
             startZ,
             dzdTheta,        /* change in Z per revolution */
             startXform,
             dXformdTheta, /* tangent change xform per revolution */
             startTheta,          /* start angle, in degrees */
             sweepTheta,       /* sweep angle, in degrees */
             gleSpiral);
}


/* ============================================================ */
/*
 * Toroid primitive 
 * Uses a helical coordinate system dislocation to take a circular 
 * contour along a helical path.
 */

void gleToroid (gleDouble rToroid,
             gleDouble startRadius,
             gleDouble drdTheta,        /* change in radius per revolution */
             gleDouble startZ,
             gleDouble dzdTheta,        /* change in Z per revolution */
             gleDouble startXform[2][3],
             gleDouble dXformdTheta[2][3], /* tangent change xform per revol */
             gleDouble startTheta,          /* start angle, in degrees */
             gleDouble sweepTheta)        /* sweep angle, in degrees */
{
   super_helix (rToroid,
             startRadius,
             drdTheta,        /* change in radius per revolution */
             startZ,
             dzdTheta,        /* change in Z per revolution */
             startXform,
             dXformdTheta, /* tangent change xform per revolution */
             startTheta,          /* start angle, in degrees */
             sweepTheta,       /* sweep angle, in degrees */
             gleLathe);
}

/* ============================================================ */

void gleScrew (int ncp, 
               gleDouble contour[][2], 
               gleDouble cont_normal[][2], 
               gleDouble up[3],
               gleDouble startz,
               gleDouble endz,
               gleDouble twist) 
{
   int i, numsegs;
   gleVector * path; 
   gleDouble *twarr;
   gleDouble currz, delta; 
   gleDouble currang, delang; 

   /* no segment should rotate more than 18 degrees */
   numsegs = (int) fabs (twist / 18.0) + 4;

   /* malloc the extrusion array and the twist array */
   path = (gleVector *) malloc (numsegs * sizeof (gleVector));
   twarr = (gleDouble *) malloc (numsegs * sizeof (gleDouble));

   /* fill in the extrusion array and the twist array uniformly */
   delta = (endz-startz) / ((gleDouble) (numsegs-3));
   currz = startz-delta;
   delang = twist / ((gleDouble) (numsegs-3));
   currang = -delang;
   for (i=0; i&lt;numsegs; i++) {
      path [i][0] = 0.0;
      path [i][1] = 0.0;
      path [i][2] = currz;
      currz += delta;
      twarr[i] = currang;
      currang +=delang;
   }

   gleTwistExtrusion (ncp, contour, cont_normal, up, numsegs, path, NULL, twarr);

   free (path);
   free (twarr);
}

/* ============================================================ */
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing5.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing5.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing5.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>