/****************************************************//*													*//*	File:		menu.c								*//*													*//*	Program:	Imageer								*//*													*//*	By:			Jason Hodges-Harris					*//*													*//*	Created:	26/10/95  00:00:00 AM				*//*													*//*	Version:	1.0.0d3								*//*													*//*	Copyright:	© 1995-96 Apple Computer, Inc.,		*/ /*					all rights reserved.			*/		/*													*//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __DESK__#include <Desk.h>#endif#ifndef __ERRORS__#include <Errors.h>#endif#ifndef __GXENVIRONMENT__#include <GXEnvironment.h>#endif#ifndef __MEMORY__#include <Memory.h>#endif#ifndef __MENUS__#include <Menus.h>#endif#ifndef __QUICKDRAW__#include <QuickDraw.h>#endif#ifndef __TEXTUTILS__#include <TextUtils.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __WINDOWS__#include <Windows.h>#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include "Imageer.app.h"#endif#ifndef __IMAGEERPROTOSHEADER__#include "Imageer.protos.h"#endif/***** Global Variables *****/extern Boolean			gDone;					// program loop test conditionextern Boolean			gQDGXtrue;				// QuickDraw GX presentextern short			gNumOpenWindows;		//	number of open document windows// Initialise the application menubar.#pragma segment Menuvoid MenuBarInit (void){	SetMenuBar (GetNewMBar(rMenuBar));	AddResMenu (GetMHandle(mApple),'DRVR');	AddSubMenu(mBrightness);	AddSubMenu(mContrast);	AddSubMenu(mColor);	DrawMenuBar();}// Sets the menubar to the default settings during the application initialisation phase.#pragma segment Menuvoid	DoAdjustMenus(void){		DoAdjustFileMenu();		DoAdjustEditMenu();		DoAdjustWindowsMenu();		DoAdjustFilterMenu();		DoAdjustEffectsMenu();		DoAdjustModelMenu();		DrawMenuBar();	return;}// The DoMenuCommand() function performs all of the handling of // the user's interaction with the application#pragma segment Menuvoid	DoMenuCommand(long menuResult){	ImageDocHndl 		theWindDocHndl;	WindowPtr			oldPort,						window,						theNextWindow;	MenuHandle			theMenu;	Str255				daName,						theItemString,						theResString;	OSErr				error = noErr;	short				menuID,						menuItem,						daRefNum,						count;		menuID   = HiWord(menuResult);	menuItem = LoWord(menuResult);	switch (menuID) 	{		case mApple:				// Apple menubar items			switch (menuItem) 			{				/* Display the application about box.				   App name, copyright etc. */				case iAbout:							DisplayAlert (rAboutBox,0,0);				break;				// handle all menubar Desk Accessories.				default:								GetItem(GetMHandle(mApple), menuItem, daName);					daRefNum = OpenDeskAcc(daName);				break;			}		break;		case mFile:						// File menubar items			switch (menuItem) 			{				case iOpen:					theMenu = GetMHandle(mModel);					GetMenuItemText(theMenu,iUseQDGX,theItemString);						GetIndString (theResString,rImageModel,iUseQuickDrawGX);					if (!EqualString(theItemString,theResString,true,true))						SetMenuItemText (theMenu,iUseQDGX,theResString);	// reset menu item					/**** default to Color QD. QDGX file type not yet supported for file load ****/					error = LoadSupportedImage();					if (!error)					{						if (ColorWindowVisible())						{							window = FrontWindow();							theWindDocHndl = (ImageDocHndl)GetWRefCon(window);							UpdateColorsWindPalette(theWindDocHndl, window);						}						theMenu = GetMHandle(mFile);						if (((**theMenu).enableFlags & 4) == 0)	// test if Close menu item enabled						{							EnableItem(theMenu,iClose);							EnableItem(theMenu,iCloseAll);							EnableItem(theMenu,iSaveAs);							EnableItem(theMenu,iRevert);							EnableItem(GetMHandle(mWindow),iColors);							theMenu = GetMHandle(mFilters);							for (count = iSmoothFilter;count <= iHiPassFilter; ++count)								EnableItem(theMenu,count);							theMenu = GetMHandle(mEffects);							for (count = iInvert;count <= iRotate180; ++count)								EnableItem(theMenu,count);						}					}				break;				case iClose:					window = FrontWindow();					if (window)						DisposeImageWindow (window);				break;				case iCloseAll:					window = FrontWindow();					while (window)					{						theNextWindow = &((WindowPeek)window)->nextWindow->port;						DisposeImageWindow (window);						window = theNextWindow;					}				break;				case iSave:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							error = SaveSupportedImageFile(theWindDocHndl);					}				break;				case iSaveAs:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							error = SaveSupportedImageFile(theWindDocHndl);					}				break;				case iRevert:					window = FrontWindow();					theWindDocHndl = (ImageDocHndl)GetWRefCon(window);					if (!(*theWindDocHndl)->isColorsWindow)						error = RevertToSavedFile(theWindDocHndl, window);					if (error)						DisplayAlert(rGenWarning,rFileIOMessages,iRevertFileFail);					if (ColorWindowVisible())					{						if (!(*theWindDocHndl)->isUsingQDGX)							UpdateColorsWindPalette(theWindDocHndl, window);					}				break;				case iQuit:					window = FrontWindow();					while (window)					{						DisposeImageWindow (window);						window = FrontWindow();					}					gDone=true;				break;			}			break;		/*  Edit menubar options. */		case mEdit:					switch (menuItem) 			{				case iUndo:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow && (**theWindDocHndl).theUndoState)						{							if ((*theWindDocHndl)->isUsingQDGX)							{								RestoreOldTransformCopy(theWindDocHndl,true);							}							else							{								error = LoadTempImageFile(theWindDocHndl);								GetPort (&oldPort);								SetPort(window);								InvalRect(&window->portRect);								SetPort(oldPort);								if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}						}					}				break;								case iCut:				break;								case iCopy:				break;								case iPaste:				break;			}		break;				case mWindow:			switch (menuItem)			{				case iColors:				theMenu = GetMHandle(mWindow);					if (((**theMenu).enableFlags & 1) == 1)	// test for Window menu Colors item enabled					{						GetMenuItemText(theMenu,iColors,theItemString);							GetIndString (theResString,rMenuItems,iHideColors);						if (EqualString(theItemString,theResString,true,true))							DisposeColorsWindow();						else							CreateColorsWindow();					}				break;				default:					theMenu = GetMHandle(mWindow);					window = FrontWindow();					while (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (menuItem == (**theWindDocHndl).theMenuItem)						{							if (window != FrontWindow())								SetUndoItemText((*theWindDocHndl)->theUndoState);							if ((*theWindDocHndl)->isUsingQDGX)								SetMenuItemAvailable(true);							else								SetMenuItemAvailable(false);							SetItemMark(theMenu,(**theWindDocHndl).theMenuItem,0x12);							SelectWindow (window);						}						else							SetItemMark(theMenu,(**theWindDocHndl).theMenuItem,0x00);						theNextWindow = &((WindowPeek)window)->nextWindow->port;						window = theNextWindow;					}				break;			}		break;		case mFilters:			switch (menuItem)			{				case iSmoothFilter:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if (!(*theWindDocHndl)->isUsingQDGX)							{								SaveTempImageFile(theWindDocHndl, kPixMapOp);								SetUndoItemText(kCanUndo);								error = ImageSmoothFilter(theWindDocHndl, window);								if (error)								{									RemoveTempFile(theWindDocHndl, true, false);									SetUndoItemText(kCannotUndo);									(*theWindDocHndl)->theUndoState = kCannotUndo;								}									if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;				case iHiPassFilter:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if (!(*theWindDocHndl)->isUsingQDGX)							{								SaveTempImageFile(theWindDocHndl, kPixMapOp);								error = ImageHiPassFilter(theWindDocHndl, window);								if (error)								{									RemoveTempFile(theWindDocHndl, true, false);									SetUndoItemText(kCannotUndo);									(*theWindDocHndl)->theUndoState = kCannotUndo;								}									if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;			}		break;		case mEffects:			switch (menuItem)			{				case iInvert:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXinkTransform;								SaveTransformCopy(theWindDocHndl, true);								GxShapeInkInvert (theWindDocHndl, window);		// Use QDGX							}							else							{								error = ColorImageInverter (theWindDocHndl, window);	// Use Color QD								(*theWindDocHndl)->theUndoState = kCanUndo;								if (error)								{									RemoveTempFile(theWindDocHndl, true, false);									SetUndoItemText(kCannotUndo);									(*theWindDocHndl)->theUndoState = kCannotUndo;								}									if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;				case iMirrorXaxis:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXshapeTransform;								SaveTransformCopy(theWindDocHndl, true);								MirrorGxShape(theWindDocHndl, window, true);	// Use QDGX							}							else							{								SaveTempImageFile(theWindDocHndl, kPixMapOp);								error = MirrorImageHorizontal(theWindDocHndl, window);	// Use Color QD								if (error)								{									RemoveTempFile(theWindDocHndl, true, false);									SetUndoItemText(kCannotUndo);									(*theWindDocHndl)->theUndoState = kCannotUndo;								}								}					}				break;				case iMirrorYaxis:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXshapeTransform;								SaveTransformCopy(theWindDocHndl, true);								MirrorGxShape(theWindDocHndl, window, false);	// Use QDGX							}							else							{								SaveTempImageFile(theWindDocHndl, kPixMapOp);								error = MirrorImageVertical (theWindDocHndl, window);	// Use Color QD								if (error)								{									RemoveTempFile(theWindDocHndl, true, false);									SetUndoItemText(kCannotUndo);									(*theWindDocHndl)->theUndoState = kCannotUndo;								}								}					}				break;				case iRotate180:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXshapeTransform;								SaveTransformCopy(theWindDocHndl, true);								RotateGxShape(theWindDocHndl,window,ff(180)); // Use QDGX							}							else							{								SaveTempImageFile(theWindDocHndl, kPixMapOp);								error = RotateImage180 (theWindDocHndl, window);		// Use Color QD								if (error)								{									RemoveTempFile(theWindDocHndl, true, false);									SetUndoItemText(kCannotUndo);									(*theWindDocHndl)->theUndoState = kCannotUndo;								}								}					}				break;			}		break;		case mBrightness:		/****	Brightness sub menu	****/			switch (menuItem)			{				case iLighter:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXinkTransform;								SaveTransformCopy(theWindDocHndl, true);								GxShapeInkBrightness (theWindDocHndl, window, true); // Use QDGX							}							else							{								ImageBrightness(theWindDocHndl, window,true);		// Use Color QD								if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;				case iDarker:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXinkTransform;								SaveTransformCopy(theWindDocHndl, true);								GxShapeInkBrightness (theWindDocHndl, window, false); // Use QDGX							}							else							{								ImageBrightness(theWindDocHndl, window,false);		// Use Color QD								if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;			}		break;		case mContrast:		/****	Contrast sub menu	****/			switch (menuItem)			{				case iIncrease:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if	(!(**theWindDocHndl).isUsingQDGX)							{								ImageContrast(theWindDocHndl, window,true);								if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;				case iDecrease:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if	(!(**theWindDocHndl).isUsingQDGX)							{								ImageContrast(theWindDocHndl, window,false);								if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;			}		break;		case mColor:		/****	Color Component sub menu	****/			switch (menuItem)			{				case iRedColorComp:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXinkTransform;								SaveTransformCopy(theWindDocHndl, true);								RGBColorComponent (theWindDocHndl, window, kRedComp); // Use QDGX							}							else							{								RemoveColorComponent(theWindDocHndl, window, kRedComp);		// Use Color QD								if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;				case iGreenColorComp:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXinkTransform;								SaveTransformCopy(theWindDocHndl, true);								RGBColorComponent (theWindDocHndl, window, kGreenComp); // Use QDGX							}							else							{								RemoveColorComponent(theWindDocHndl, window, kGreenComp);		// Use Color QD								if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;				case iBlueColorComp:					window = FrontWindow();					if (window)					{						theWindDocHndl = (ImageDocHndl)GetWRefCon(window);						if (!(**theWindDocHndl).isColorsWindow)							if ((**theWindDocHndl).isUsingQDGX)							{								(*theWindDocHndl)->theGXUndoType = kGXinkTransform;								SaveTransformCopy(theWindDocHndl, true);								RGBColorComponent (theWindDocHndl, window, kBlueComp); // Use QDGX							}							else							{								RemoveColorComponent(theWindDocHndl, window, kBlueComp);		// Use Color QD								if (ColorWindowVisible())									UpdateColorsWindPalette(theWindDocHndl, window);							}					}				break;			}		break;		case mModel:			error = SetImagingModel();			switch (error)			{				case kCannotConvertToGX:					DisplayAlert(rGenWarning,rQDGXmessages,iCannotConvToGX);				break;				case kCannotConvertToQD:					DisplayAlert(rGenWarning,rQDGXmessages,iCannotSwitchGX);				break;			}		break;	}	HiliteMenu(0);		// Unhighlight what MenuSelect (or MenuKey) hilited.}/****	Adjust the file menubar items	****/#pragma segment Menuvoid	DoAdjustFileMenu(void){	MenuHandle			menu;	short				theItem;	menu = GetMHandle(mFile);	for (theItem = iClose;theItem<=iRevert;++theItem)		DisableItem (menu,theItem);	return;}/****	Adjust the Edit menu bar items. Currently as these items   are disabled as they're not supported.	****/#pragma segment Menuvoid	DoAdjustEditMenu(void){	MenuHandle		menu;	short			i;		menu = GetMHandle(mEdit);	for (i = iCut; i <= iPaste; ++i)		DisableItem(menu, i);	return;}#pragma segment Menuvoid	DoAdjustWindowsMenu(void){	DisableItem(GetMHandle(mWindow),iColors);	return;}#pragma segment Menuvoid	DoAdjustFilterMenu(void){	MenuHandle		menu;	short			i;		menu = GetMHandle(mFilters);	for (i = iSmoothFilter; i <= iHiPassFilter; ++i)		DisableItem(menu, i);	return;}#pragma segment Menuvoid	DoAdjustEffectsMenu(void){	MenuHandle		menu;	short			i;		menu = GetMHandle(mEffects);	for (i = iInvert; i <= iRotate180; ++i)		DisableItem(menu, i);	return;}#pragma segment Menuvoid	DoAdjustModelMenu(void){	MenuHandle		menu;		menu = GetMHandle(mModel);	/****	Disable the use QDGX menu option if not installed	****/	if (!gQDGXtrue)		DisableItem(menu,iUseQDGX);	return;}/****	Add Document Window to Window Menu list	****/#pragma segment MenuOSErr	AddDocNameToMenu (ImageDocHndl theWindDocHndl){	ImageDocHndl		theFoundDocHndl;	MenuHandle			theMenu;	WindowPtr			theWindow;	WindowRecord		*theNextWindow;	OSErr				error = noErr;		theMenu = GetMHandle(mWindow);	InsertMenuItem(theMenu,(**theWindDocHndl).theImageFileReply.sfFile.name,gNumOpenWindows+2); // place after 2 item offset	SetItemMark(theMenu,gNumOpenWindows+3,0x12);	// place tick mark against opened window menu item	if (gNumOpenWindows)	{		theWindow = FrontWindow();		theNextWindow = ((WindowPeek)theWindow)->nextWindow;		theFoundDocHndl = (ImageDocHndl)GetWRefCon(&(theNextWindow->port));		SetItemMark(theMenu,(**theFoundDocHndl).theMenuItem,0x00);	}	gNumOpenWindows++;	(**theWindDocHndl).theMenuItem = gNumOpenWindows+2; // 2 item offset as window list starts at item 3	DrawMenuBar();	return	error;}/****	Delete Document Window from Window Menu list	****/#pragma segment MenuOSErr	DeleteDocNameFromMenu (ImageDocHndl theWindDocHndl){	ImageDocHndl		theFoundDocHndl;	MenuHandle			theMenu;	WindowPtr			theWindow,						theNextWindow;	OSErr				error = noErr;		theMenu = GetMHandle(mWindow);	DeleteMenuItem(theMenu,(**theWindDocHndl).theMenuItem);	error = RearrangeMenuItems(theWindDocHndl);	gNumOpenWindows--;	if (gNumOpenWindows)	{		theWindow = FrontWindow();		theNextWindow = &((WindowPeek)theWindow)->nextWindow->port;		theFoundDocHndl = (ImageDocHndl)GetWRefCon(theNextWindow);		SetItemMark(theMenu,(**theFoundDocHndl).theMenuItem,0x12);	}	DrawMenuBar();	return	error;}/****	Rearrange items in Windows Menu list after document window closed	****/#pragma segment MenuOSErr	RearrangeMenuItems(ImageDocHndl theWindDocHndl){	ImageDocHndl		theDocRefCon;	WindowPtr			theWindow,						theNextWindow;	OSErr				error = noErr;	short				deletedItemValue;		deletedItemValue = (**theWindDocHndl).theMenuItem;	theWindow = FrontWindow();	while (theWindow)	{		theDocRefCon=(ImageDocHndl)GetWRefCon(theWindow);		if ((**theDocRefCon).theMenuItem > deletedItemValue)			(**theDocRefCon).theMenuItem--;			theNextWindow = &((WindowPeek)theWindow)->nextWindow->port;		theWindow = theNextWindow;	}	return	error;}/****	Update ticked item in Window menu list ****/#pragma segment MenuOSErr	SetCurrentWindowMark(WindowPtr	theWindow){	ImageDocHndl		theFoundDocHndl;	MenuHandle			theMenu;	WindowPtr			theFrontWindow;	OSErr				error = noErr;	theFrontWindow = FrontWindow();	if(theWindow != theFrontWindow)	{		theMenu = GetMHandle(mWindow);		if (gNumOpenWindows)		{			theFoundDocHndl = (ImageDocHndl)GetWRefCon(theFrontWindow);			SetItemMark(theMenu,(**theFoundDocHndl).theMenuItem,0x00);		}		theFoundDocHndl = (ImageDocHndl)GetWRefCon(theWindow);		SetItemMark(theMenu,(**theFoundDocHndl).theMenuItem,0x12);	// place tick mark against opened window menu item	}		return noErr;}/****	Place hierarchical sub menu into menu list	****/#pragma segment Menuvoid	AddSubMenu(short menuID){	MenuHandle		theSubMenu;		theSubMenu = GetMenu(menuID);	InsertMenu(theSubMenu,-1);}/****	Disable menu items for progress Dialog	****/#pragma segment Menuvoid	DisableAllMenus(Boolean	isDisabled){	if (isDisabled)	{		DisableItem(GetMHandle(mFile),0);		DisableItem(GetMHandle(mWindow),0);		DisableItem(GetMHandle(mFilters),0);		DisableItem(GetMHandle(mEffects),0);		DisableItem(GetMHandle(mModel),0);	}	else	{		EnableItem(GetMHandle(mFile),0);		EnableItem(GetMHandle(mWindow),0);		EnableItem(GetMHandle(mFilters),0);		EnableItem(GetMHandle(mEffects),0);		EnableItem(GetMHandle(mModel),0);	}	DrawMenuBar();}/****	Set imaging model	****/#pragma segment MenuOSErr	SetImagingModel(void){	ImageDocHndl 		theDocHndl;	MenuHandle			theMenu;	WindowPtr			theWindow;	Str255				theItemString,						theResString;	OSErr				error = noErr;	theWindow = FrontWindow();	theMenu = GetMHandle(mModel);	GetMenuItemText(theMenu,iUseQDGX,theItemString);		GetIndString (theResString,rImageModel,iUseQuickDrawGX);	if (theWindow)	{		theDocHndl = (ImageDocHndl)GetWRefCon(theWindow);		if (!(**theDocHndl).isColorsWindow)		{			if (!EqualString(theItemString,theResString,true,true))				return kCannotConvertToQD;			else			{				GetIndString (theItemString,rImageModel,iUseColorQD);				SetMenuItemText (theMenu,iUseQDGX,theItemString);								(**theDocHndl).isUsingQDGX = true;				/****	Code to Convert current window image to QDGX object	****/										/****	Create QDGX view objects	****/				error = CreateGXviewPorts(theDocHndl, theWindow);				if (!error)					error |= ConvPixMapToGXShape(theDocHndl, theWindow);				if (error)					error =  kCannotConvertToGX;				else				{					/****	Remove color Quickdraw information not required	****/					if ((*theDocHndl)->theImageWorld)						DisposeGWorld((*theDocHndl)->theImageWorld);					if ((*theDocHndl)->hasUndoTemp)						RemoveTempFile(theDocHndl, true, false);					if ((*theDocHndl)->hasRedoTemp)						RemoveTempFile(theDocHndl, false, true);					SetMenuItemAvailable(true);				}						}		}	}	else	{		if (EqualString(theItemString,theResString,true,true))		{			GetIndString (theItemString,rImageModel,iUseColorQD);			SetMenuItemText (theMenu,iUseQDGX,theItemString);							SetMenuItemAvailable(true);		}		else		{			GetIndString (theItemString,rImageModel,iUseQuickDrawGX);			SetMenuItemText (theMenu,iUseQDGX,theItemString);							SetMenuItemAvailable(false);		}	}	return error;}/****	Set state of Undo menu item	****/#pragma segment Menuvoid	SetUndoItemText(short canUndo){	MenuHandle		theMenu;	Str255			theString;		theMenu = GetMHandle(mEdit);	switch (canUndo)	{		case kCannotUndo:			GetIndString (theString,rMenuItems,iOpCantUndo);			SetMenuItemText (theMenu,iUndo,theString);		break;		case kCanUndo:			GetIndString (theString,rMenuItems,iOpUndo);			SetMenuItemText (theMenu,iUndo,theString);		break;		case kCanRedo:			GetIndString (theString,rMenuItems,iOpRedo);			SetMenuItemText (theMenu,iUndo,theString);		break;	}	DrawMenuBar();}/****	Set state of supported menu items for current image window / model ****/#pragma segment Menuvoid	SetMenuItemAvailable(Boolean isQDGX){	MenuHandle		theFilterMenu;		theFilterMenu = GetMHandle(mFilters);	if (isQDGX)	{		DisableItem(theFilterMenu, 0);	}	else	{		EnableItem(theFilterMenu, 0);	}		DrawMenuBar();}