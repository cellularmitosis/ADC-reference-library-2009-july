<html><head><title></title></head>
<body bgcolor="#ffffff">
 
 
<h1>
<FONT COLOR="#000066">
<a name="816">
 <a name="//apple_ref/java/cl/CustomObject"><a name="//apple_ref/java/cl/CustomObject"><a name="//apple_ref/java/cl/CustomObject">CustomObject</a></a></a>
</a>
</FONT>
</h1>
<p><B>Extends:</B><BR>  
next.util.NextObject

<p><B>Implements:</B><BR>
next.util.Coding, next.eo.EnterpriseObject

<p><p>
<a name="3288"></a>
<HR WIDTH=75% SIZE=4 ALIGN=LEFT>
<H3>
<FONT COLOR="#201040">
Class At A Glance
</FONT>
</H3>
<dl><a name="3289"></a>
<dt><h4>Purpose</h4>
<dl>
<dt>CustomObject defines basic functionality for enterprise object classes by implementing the EnterpriseObject interface. Create a subclass when you need a custom enterprise object class to perform business logic; otherwise use GenericRecords.
</dl>
<a name="3291"></a>
<dt><h4>Principal Attributes</h4>
</dl><ul><li>ClassDescription<br>
<li>EditingContext<br>
</ul><dl><a name="3293"></a>
<dt><h4>Initialization<p>
<Table Border="3">
<caption></caption>
<tr><td scope="row"><a href="#2846">awakeFromFetchInEditingContext</a>
</td><td>Performs additional initialization after the object is 
fetched.
</td></tr>
<tr><td scope="row"><a href="#2851">awakeFromInsertionInEditingContext</a>
</td><td>Performs additional initialization after the object is 
created in memory.
</td></tr>

</Table>

<Table>
<tr><td scope="row">
</Table>
</h4>
<a name="3307"></a>
<dt><h4>Commonly Used Methods<p>
<Table Border="3">
<caption></caption>
<tr><td><a href="#1807">willChange</a>
</td><td>Notifies observers of a change in state.
</td></tr>
<tr><td scope="row"><a href="#6131">willRead</a>
</td><td>Fills the receiver with values fetched from the database.
</td></tr>
<tr><td scope="row"><a href="#2924">editingContext</a>
</td><td>Returns the receiver's EditingContext.
</td></tr>
<tr><td scope="row"><a href="#2788">addObjectToPropertyWithKey</a>
</td><td>Adds an object to a relationship property.
</td></tr>
<tr><td scope="row"><a href="#3036">removeObjectFromPropertyWithKey</a>
</td><td>Removes an object from a relationship property.
</td></tr>
<tr><td scope="row"><a href="#2783">addObjectToBothSidesOfRelationshipWithKey</a>
</td><td>Adds an object to a relationship property and the 
receiver to the reciprocal relationship.
</td></tr>
<tr><td scope="row"><a href="#3031">removeObjectFromBothSidesOfRelationshipWithKey</a>
</td><td>Removes an object from a relationship property and the 
receiver from the reciprocal relationship.
</td></tr>

</Table>

<Table>
<tr><td scope="row">
</Table>
</h4>
<a name="3333"></a>
<dt><h4>Methods to Implement or Override</h4>
<dl>
<dt>The following methods are invoked by the Framework. <p>
<Table Border="3">
<caption></caption>
<tr><td>set<em>Key
</em></td><td>Sets the value for the property named <em>key</em>.
</td></tr>
<tr><td scope="row"><em>key
</em></td><td>Retrieves the value for the property named <em>key</em>.
</td></tr>
<tr><td scope="row">addTo<em>Key
</em></td><td>Adds an object to a relationship property named <em>key</em>.
</td></tr>
<tr><td scope="row">removeFrom<em>Key
</em></td><td>Removes an object from the property named <em>key</em>.
</td></tr>
<tr><td scope="row"><a href="#2967">handleTakeValue</a>
</td><td>Handles a failure of <code><a href="#3078">takeValueForKey</a></code> to find a property.
</td></tr>
<tr><td scope="row"><a href="#2962">handleQueryWithUnboundKey</a>
</td><td>Handles a failure of <code><a href="#1562">valueForKey</a></code> to find a property.
</td></tr>
<tr><td scope="row"><a href="#3123">unableToSetNullForKey</a>
</td><td>Handles an attempt to set a non-object property's value 
to <code>null</code>.
</td></tr>
<tr><td scope="row">validate<em>Key
</em></td><td>Validates a value for the property named <em>key</em>.
</td></tr>
<tr><td scope="row"><a href="#7260">validateForDelete</a>
</td><td>Validates all properties before deleting the receiver.
</td></tr>
<tr><td scope="row"><a href="#3138">validateForInsert</a>
</td><td>Validates all properties before inserting the receiver.
</td></tr>
<tr><td scope="row"><a href="#1095">validateForSave</a>
</td><td>Validates all properties before saving the receiver.
</td></tr>
<tr><td scope="row"><a href="#1287">validateForUpdate</a>
</td><td>Validates all properties before updating the receiver.
</td></tr>

</Table>

<Table>
<tr><td scope="row">
</Table>

</dl>
</dl><HR WIDTH=75% SIZE=4 ALIGN=LEFT>
<p><a name="3375"></a>
<a name="description"></a>
<H2>Class Description
</H2>
CustomObject supports operations common to all enterprise objects by implementing the EnterpriseObject interface. Some of its methods are for subclasses to implement or override, and some are meant to be used as defined by CustomObject. Many methods are used internally by the Framework and rarely invoked by application code.<p>
For a description of the major functional groups of the EnterpriseObject interface, see the following sections in the EnterpriseObject interface specification:<p>
<ul><li><a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top">Initialization Methods</a><br>
<li><a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top">Announcing Changes</a><br>
<li><a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top">Getting Object and Class Metadata</a><br>
<li><a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top">Key-Value Coding Methods</a><br>
<li><a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top">Relationship Accessor Methods</a><br>
<li><a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top">Snapshots</a><br>
<li><a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top">Validation</a><br>
</ul>The following sections parallel the corresponding EnterpriseObject interface specification sections, providing information on how CustomObject implements the functional groups and how you might override them.<p>
<h3>
<a name="3401">
 Getting Object and Class Metadata
</a>
</h3>
One of the larger groups of methods in CustomObject provides information about an object's properties:<p>
<ul><li><a href="#2836">allPropertyKeys</a><br>
<li><a href="#2841">attributeKeys</a><br>
<li><a href="#2861">classDescription</a><br>
<li><a href="#2899">classDescriptionForDestinationKey</a><br>
<li><a href="#2909">deleteRuleForRelationshipKey</a><br>
<li><a href="#886">entityName</a><br>
<li><a href="#2989">inverseForRelationshipKey</a><br>
<li><a href="#2994">isToManyKey</a><br>
<li><a href="#3004">ownsDestinationObjectsForRelationshipKey</a><br>
<li><a href="#4366">toOneRelationshipKeys</a><br>
<li><a href="#3103">toManyRelationshipKeys</a><br>
</ul>Most of these methods consult a ClassDescription to provide their answers. These methods are all properly implemented in terms of the receiver's ClassDescription, so unless your class doesn't have a ClassDescription, there's little need to override them. One method you might override in your enterprise object class, however, is <a href="#2989"><code>inverseForRelationshipKey</code></a>. Given the name of one of the receiver's relationships, this method finds the destination object's ClassDescription and determines the name of the relationship that points back at the receiver. The default implementation of this method looks for a relationship predicated on the same attributes in both the source and destination, which works correctly in most cases. If, however, you define a reciprocal pair of relationships on different attributes, you should override this method to take that into account. See the method description for an example.<p>
<h3>
<a name="3439">
 Key-Value Coding Methods
</a>
</h3>
A special set of methods form the Framework's main data transport mechanism, in which the properties of an enterprise object are accessed indirectly by name (or <em>key</em>), rather than directly through invocation of an accessor method or as instance variables. Thus, all of a CustomObject's attributes and relationships can be accessed in a consistent manner using these methods:<p>
<ul><li><a href="#3078">takeValueForKey</a><br>
<li><a href="#1562">valueForKey</a><br>
<li><a href="#3088">takeValuesFromDictionary</a><br>
<li><a href="#1674">valuesForKeys</a><br>
<li><a href="#3083">takeValueForKeyPath</a><br>
<li><a href="#1616">valueForKeyPath</a><br>
<li><a href="#2962">handleQueryWithUnboundKey</a><br>
<li><a href="#2967">handleTakeValue</a><br>
<li><a href="#3123">unableToSetNullForKey</a><br>
</ul>The basic methods for accessing an enterprise object's values are <code><a href="#3078">takeValueForKey</a></code> and <code><a href="#1562">valueForKey</a></code>. These two methods are defined by CustomObject to use the accessor methods normally implemented by objects (or to access instance variables directly if need be), so that you don't have to write special code simply to integrate your enterprise objects into the Framework.<p>
<h4>
<a name="3474">
 Default Implementations; Handling Access Errors
</a>
</h4>
The Framework provides default implementations of <code><a href="#3078">takeValueForKey</a></code> and <code><a href="#1562">valueForKey</a></code> that work for all objects. The other access methods are implemented in terms of these two. These implementations are general enough that your enterprise object classes should rarely need to override either key-value coding method. In accessing an object's property, the default CustomObject implementations of the key-value coding methods use the class definition as follows:<p>
<ol>
<a name="7381">
<li>The key-value coding method looks for an accessor method based on the key. For example, with a key of "lastName", <code>takeValueForKey</code> looks for a method named <code>setLastName</code> (note that the first letter of the property name is made uppercase), and <code>valueForKey</code> looks for a method of the form <code>lastName</code>.<p>
</a><a name="7388">
<li>If the key-value coding method doesn't find an accessor method, and the static method <code>accessInstanceVariablesDirectly</code> returns, <code>true</code>, it looks for an instance variable whose name is the same as the key and sets or retrieves its value directly. <p>
</a><a name="3496">
<li>If neither an accessor method nor an instance variable can be found, the default implementations invoke methods that your custom objects can override to handle failures. <a href="#2967"><code>handleTakeValue</code></a> is invoked from <code>takeValueForKey</code>, and <a href="#2962"><code>handleQueryWithUnboundKey</code></a> is invoked from <code>valueForKey</code>. Normally these methods throw an exception, but you can implement them to set or get a value in whatever way is needed.<p>
</a></ol>
<h4>
<a name="3561">
 Type Checking and Type Conversion
</a>
</h4>
The default implementations of the key-value coding methods accept any object as a value, and do no type checking or type conversion among object classes. It's possible, for example, to pass a java.lang.String to <code><a href="#3078">takeValueForKey</a></code> as the value for a property the receiver expects to be a next.util.Date. The sender of a key-value coding message is thus responsible for ensuring that a values is of the proper class, typically by using the <a href="#3148"><code>validateValueForKey</code></a> method to coerce it to the proper type. For more information on the <code>validateValueForKey</code> method, see the ClassDescription and next.eo.EntityClassDescription class specifications.<p>
The key-value coding methods handle one special case with regard to value types. For enterprise objects that access numeric values as scalar types, these methods automatically convert between the scalar types and java.lang.Number objects. For example, suppose your enterprise object defines these accessor methods:<p>
<blockquote><pre>public void setSalary(int salary)<br>public int salary()
</pre></blockquote><p>For the <code>setSalary</code> method, <code>takeValueForKey</code> converts the object value it receives as the argument for the "salary" key to an <code>int</code> and passes it as <em>salary</em> to <code>setSalary</code>. Similarly, <code>valueForKey</code> converts the return value of the <code>salary</code> method to a java.lang.Number and returns that.<p>
The default implementations support the scalar types <code>int</code>, <code>float</code>, and <code>double</code>. Object values are converted to these types with the standard messages <code>intValue</code>, <code>floatValue</code>, and so on. Note that the key-value coding methods don't check that an object value actually responds to these messages; this can result in a run-time error if the object doesn't respond to the appropriate message.<p>
One type of conversion these methods can't perform is that from <code>null</code> to a scalar value. Scalar values define no equivalent of a database system's NULL value, so these must be handled by the object itself. Upon encountering <code>null</code> while setting a scalar value, the <code>takeValueForKey</code> invokes <a href="#3123"><code>unableToSetNullForKey</code></a>, which by default simply throws an exception. Enterprise object classes that use scalar values which may be NULL in the database should override this method to substitute the appropriate scalar value for <code>null</code>, reinvoking <code>takeValueForKey</code> to set the substitute value. This method works in general to handle setting scalar properties to <code>null</code>.<p>
<h4>
<a name="3588">
 NullValue in Collections
</a>
</h4>
Because collection objects such as next.util.Vector and next.util.Hashtable can't contain <code>null</code> as a value, it must be represented by a special object, NullValue. NullValue provides a single instance that represents the NULL value for object attributes. The default implementations of <code><a href="#3088">takeValuesFromDictionary</a></code> and <code><a href="#1674">valuesForKeys</a></code> translate NullValue and <code>null</code> between Hashtables and enterprise objects, removing the need for your objects to explicitly test for NullValues. <p>
<h3>
<a name="3596">
 Relationship Accessor Methods
</a>
</h3>
Building on the key-value coding methods, another group of methods allows you to modify to-many relationship properties by adding and removing single objects and to modify relationships so that reciprocal relationships are automatically adjusted:<p>
<ul><li><a href="#2788">addObjectToPropertyWithKey</a><br>
<li><a href="#3036">removeObjectFromPropertyWithKey</a><br>
<li><a href="#2783">addObjectToBothSidesOfRelationshipWithKey</a><br>
<li><a href="#3031">removeObjectFromBothSidesOfRelationshipWithKey</a><br>
<li><a href="#3026">propagateDeleteWithEditingContext</a><br>
<li><a href="#2904">clearProperties</a><br>
</ul><a href="#2788"><code>addObjectToPropertyWithKey</code></a> and <a href="#3036"><code>removeObjectFromPropertyWithKey</code></a> operate on arrays for to-many relationships. They both check first for a method you might implement, <code>addTo</code><em>Key</em> or <code>removeFrom</code><em>Key</em>, invoking that method if it's implemented, otherwise using the basic key-value coding methods to do the work.<p>
The methods for handling reciprocal relationships, <a href="#2783"><code>addObjectToBothSidesOfRelationshipWithKey</code></a> and <a href="#3031"><code>removeObjectFromBothSidesOfRelationshipWithKey</code></a>, take care of tracing the inverse relationship and use <code>addObjectToPropertyWithKey</code> and <code>removeObjectFromPropertyWithKey</code> to alter both relationships, whether they're to-one or to-many.<p>
<h3>
<a name="3632">
 Validation
</a>
</h3>
Validating new values is a vital part of business logic. The most general method, <a href="#3148"><code>validateValueForKey</code></a>, does two things: coerce the value into an appropriate type for the object, and validate it according to the object's rules. Coercion is performed automatically for you, so all you need handle is validation itself.<p>
The default implementation of <code>validateValueForKey</code> consults the object's ClassDescription for basic errors, such as a <code>null</code> value when that isn't allowed. If no basic errors exist, this method then examines the object's class itself for a method of the form <code>validate</code><em>Key</em> and invokes that. These are the methods that your custom classes can implement to validate individual properties, such as <code>validateAge</code> to check that the value the user entered is within acceptable limits.<p>
The rest of the methods-<a href="#3138"><code>validateForInsert</code></a>, <a href="#1287"><code>validateForUpdate</code></a>, <a href="#1095"><code>validateForSave</code></a>, and <a href="#7260"><code>validateForDelete</code></a>-are invoked when the associated operation is performed. You can override these methods in your custom enterprise object classes to allow or refuse the operation based on property values. For example, a Fee object might refuse to be deleted if it hasn't been paid yet. Or you can override these methods to perform delayed validation of properties or to compare multiple properties against one another; for example, you might verify that a pair of dates is in the proper temporal order.<p>
If you override any of these operation-specific validation methods, be sure to invoke <code>super</code>'s implementation. This is important, as the default implementations of the <code>validateFor...</code> methods pass the check on to the object's ClassDescription, which performs basic checking among properties, including invoking <a href="#3148"><code>validateValueForKey</code></a> for each property. The access layer's next.eo.EntityClassDescription class verifies constraints based on a next.eo.Model, such as delete rules. For example, the delete rule for a Department object might state that it can't be deleted if it still contains Employee objects.<p>
<a href="#1095"><code>validateForSave</code></a> is the generic validation method for when an object is written to the external store. The default implementations of <a href="#3138"><code>validateForInsert</code></a> and <a href="#1287"><code>validateForUpdate</code></a> both invoke this method. If an object performs validation that isn't specific to insertion or to updating, it should go in <code>validateForSave</code>.<p>
<HR WIDTH=50% ALIGN=LEFT>
<h2>Interfaces Implemented</h2>  


next.util.Coding<p>
<dl><dl><dl><dl><dl>
<dt>encodeWithCoder</dl>
</dl></dl></dl></dl>next.eo.<a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top">EnterpriseObject</a><p>
<dl><dl><dl><dl><dl>
<dt>See "Method Types"</dl>
</dl></dl></dl></dl><a name="833">
<HR WIDTH=50% ALIGN=LEFT>
<h2>Method Types
</h2>
</a><dl>
<dt>Initializing enterprise objects<dl><dl><dl><dl>
<dt><a href="#2846">awakeFromFetchInEditingContext</a><dt><a href="#2851">awakeFromInsertionInEditingContext</a></dl>
</dl></dl></dl><dt>Announcing changes<dl><dl><dl><dl>
<dt><a href="#1807">willChange</a></dl>
</dl></dl></dl><dt>Getting an object's EditingContext<dl><dl><dl><dl>
<dt><a href="#2924">editingContext</a></dl>
</dl></dl></dl><dt>Getting class description information<dl><dl><dl><dl>
<dt><a href="#2836">allPropertyKeys</a><dt><a href="#2841">attributeKeys</a><dt><a href="#2861">classDescription</a><dt><a href="#2899">classDescriptionForDestinationKey</a><dt><a href="#2909">deleteRuleForRelationshipKey</a><dt><a href="#886">entityName</a><dt><a href="#2989">inverseForRelationshipKey</a><dt><a href="#2994">isToManyKey</a><dt><a href="#3004">ownsDestinationObjectsForRelationshipKey</a><dt><a href="#4366">toOneRelationshipKeys</a><dt><a href="#3103">toManyRelationshipKeys</a></dl>
</dl></dl></dl><dt>Firing faults<dl><dl><dl><dl>
<dt><a href="#6131">willRead</a></dl>
</dl></dl></dl><dt>Key-value coding<dl><dl><dl><dl>
<dt><a href="#3078">takeValueForKey</a><dt><a href="#1562">valueForKey</a><dt><a href="#3088">takeValuesFromDictionary</a><dt><a href="#1674">valuesForKeys</a><dt><a href="#3083">takeValueForKeyPath</a><dt><a href="#1616">valueForKeyPath</a><dt><a href="#2962">handleQueryWithUnboundKey</a><dt><a href="#2967">handleTakeValue</a><dt><a href="#3123">unableToSetNullForKey</a></dl>
</dl></dl></dl><dt>Modifying relationships<dl><dl><dl><dl>
<dt><a href="#2788">addObjectToPropertyWithKey</a><dt><a href="#3036">removeObjectFromPropertyWithKey</a><dt><a href="#2783">addObjectToBothSidesOfRelationshipWithKey</a><dt><a href="#3031">removeObjectFromBothSidesOfRelationshipWithKey</a><dt><a href="#3026">propagateDeleteWithEditingContext</a><dt><a href="#2904">clearProperties</a></dl>
</dl></dl></dl><dt>Working with snapshots<dl><dl><dl><dl>
<dt><a href="#3047">snapshot</a><dt><a href="#3113">updateFromSnapshot</a></dl>
</dl></dl></dl><dt>Validating values<dl><dl><dl><dl>
<dt><a href="#7260">validateForDelete</a><dt><a href="#3138">validateForInsert</a><dt><a href="#1095">validateForSave</a><dt><a href="#1287">validateForUpdate</a><dt><a href="#3148">validateValueForKey</a></dl>
</dl></dl></dl><dt>Getting descriptions<dl><dl><dl><dl>
<dt><a href="#2946">eoDescription</a><dt><a href="#2951">eoShallowDescription</a><dt><a href="#1074">userPresentableDescription</a></dl>
</dl></dl></dl></dl>
<HR WIDTH=50% ALIGN=LEFT>
<a name="instm"></a>
<h2>Instance Methods</h2>  


<a name="2783"></a>
<h3>
 <a name="//apple_ref/java/instm/CustomObject/addObjectToBothSidesOfRelationshipWithKey">addObjectToBothSidesOfRelationshipWithKey</a>
</h3>
public void <code>addObjectToBothSidesOfRelationshipWithKey</code>(java.lang.Object <em>anObject</em>, 
java.lang.String <em>key</em>)

<P>Sets or adds <em>anObject</em> as the destination for the receiver's relationship identified by <em>key</em>, and also sets or adds the receiver for <em>anObject</em>'s reciprocal relationship if there is one. For a to-one relationship, <em>anObject</em> is set using <code><a href="#3078">takeValueForKey</a></code>. For a to-many relationship, <em>anObject</em> is added using <code><a href="#2788">addObjectToPropertyWithKey</a></code>.<p>
This method also properly handles removing <code>this</code> and <em>anObject</em> from their previous relationship as needed. For example, if an Employee object belongs to the Research department, invoking this method with the Maintenance department removes the Employee from the Research department as well as setting the Employee's department to Maintenance.<p>
<B>See also: </B>  
<a href="#3031"><code>removeObjectFromBothSidesOfRelationshipWithKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2788"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/addObjectToPropertyWithKey">addObjectToPropertyWithKey</a></h3>
public void <code>addObjectToPropertyWithKey</code>(java.lang.Object <em>anObject</em>, java.lang.String <em>key</em>)

<P>Adds <em>anObject</em> to the receiver's to-many relationship identified by <em>key</em>, without setting a reciprocal relationship. Similar to the implementation of <a href="#3078"><code>takeValueForKey</code></a>, CustomObject's implementation of this method first attempts to invoke a method of the form <code>addTo</code><em>Key</em>. If the receiver doesn't have such a method, this method gets the property array using <a href="#1562"><code>valueForKey</code></a> and operates directly on that. If the array is mutable, this method simply adds <em>anObject</em> using <code>addElement</code>. Otherwise it constructs a new array containing any existing objects and <em>anObject</em>, then sets it using <code>takeValueForKey</code>.<p>
<B>See also: </B>  
<a href="#3036"><code>removeObjectFromPropertyWithKey</code></a>, <a href="#2783"><code>addObjectToBothSidesOfRelationshipWithKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2836"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/allPropertyKeys">allPropertyKeys</a></h3>
public next.util.ImmutableVector <code>allPropertyKeys</code>()

<P>Returns all of the receiver's property keys, as returned by <a href="#2841"><code>attributeKeys</code></a>, <a href="#4366"><code>toOneRelationshipKeys</code></a>, and <a href="#3103"><code>toManyRelationshipKeys</code></a>.<p>
<hr WIDTH=25% ALIGN=LEFT>
<a name="2841"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/attributeKeys">attributeKeys</a></h3>
public next.util.ImmutableVector <code>attributeKeys</code>()

<P>Returns the names of the receiver's attributes, as determined from the ClassDescription. You might wish to override this method to add keys for attributes not defined by the ClassDescription. The access layer's subclass of ClassDescription, next.eo.EntityClassDescription, returns the names of attributes designated as class properties.<p>
<B>See also: </B>  
<a href="#4366"><code>toOneRelationshipKeys</code></a>, <a href="#3103"><code>toManyRelationshipKeys</code></a>., <code>attributeKeys</code> (ClassDescription)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2846"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/awakeFromFetchInEditingContext">awakeFromFetchInEditingContext</a></h3>
public void <code>awakeFromFetchInEditingContext</code>(next.eo.EditingContext <em>anEditingContext</em>)

<P>Overridden by subclasses to perform additional initialization on the receiver upon its being fetched from the external repository into <em>anEditingContext</em>. CustomObject's implementation merely sends an <a href="../ClassDescription/Frameset.html#2120" target="_top"><code>awakeObjectFromFetch</code></a> to the receiver's ClassDescription. Subclasses should invoke <code>super</code>'s implementation before performing their own initialization.<p>
<B>See also: </B>  
<a href="#2851"><code>awakeFromInsertionInEditingContext</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2851"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/awakeFromInsertionInEditingContext">awakeFromInsertionInEditingContext</a></h3>
public void <code>awakeFromInsertionInEditingContext</code>(next.eo.EditingContext <em>anEditingContext</em>)

<P>Overridden by subclasses to perform additional initialization on the receiver upon its being inserted into <em>anEditingContext</em>. This is commonly used to assign default values or record the time of insertion. CustomObject's implementation merely sends an <a href="../ClassDescription/Frameset.html#2125" target="_top"><code>awakeObjectFromInsertion</code></a> to the receiver's ClassDescription. Subclasses should invoke <code>super</code>'s implementation before performing their own initialization.<p>
<B>See also: </B>  
<a href="#2846"><code>awakeFromFetchInEditingContext</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2861"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/classDescription">classDescription</a></h3>
public next.eo.ClassDescription <code>classDescription</code>()

<P>Returns the ClassDescription registered for the receiver's class. <p>
<hr WIDTH=25% ALIGN=LEFT>
<a name="2899"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/classDescriptionForDestinationKey">classDescriptionForDestinationKey</a></h3>
public next.eo.ClassDescription <code>classDescriptionForDestinationKey</code>(java.lang.String <em>key</em>)

<P>Returns the ClassDescription for the destination objects of the relationship identified by <em>key</em>. <p>
<B>See also: </B>  
<a href="../ClassDescription/Frameset.html#2154" target="_top"><code>classDescriptionForDestinationKey</code></a> (ClassDescription)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2904"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/clearProperties">clearProperties</a></h3>
public void <code>clearProperties</code>()

<P>Sets all of the receiver's to-one and to-many relationships to <code>null</code>. EditingContexts use this method to break circular references among objects when they're finalized. You should never need to invoke this method or override it.<p>
<B>See also: </B>  
<a href="#4366"><code>toOneRelationshipKeys</code></a>, <a href="#3103"><code>toManyRelationshipKeys</code></a>, <a href="#3078"><code>takeValueForKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2909"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/deleteRuleForRelationshipKey">deleteRuleForRelationshipKey</a></h3>
public int <code>deleteRuleForRelationshipKey</code>(java.lang.String <em>relationshipKey</em>)

<P>Returns a rule indicating how to handle the destination of the receiver's relationship named by <em>relationshipKey</em> when the receiver is deleted. The delete rule is one of:<p>
<ul><li>DeleteRuleNullify<br>
<li>DeleteRuleCascade<br>
<li>DeleteRuleDeny<br>
<li>DeleteRuleNoAction<br>
</ul>Which are defined in ClassDescription. For example, an Invoice object might return DeleteRuleCascade for the relationship named "lineItems", since when an invoice is deleted, its line items should be deleted as well.<p>
<B>See also: </B>  
<a href="#3026"><code>propagateDeleteWithEditingContext</code></a>, <a href="#7260"><code>validateForDelete</code></a>, 
<a href="../ClassDescription/Frameset.html#2222" target="_top"><code>deleteRuleForRelationshipKey</code></a> (ClassDescription)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2924"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/editingContext">editingContext</a></h3>
public next.eo.EditingContext <code>editingContext</code>()

<P>Returns the EditingContext that holds the receiver.<p>
<hr WIDTH=25% ALIGN=LEFT>
<a name="886"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/entityName">entityName</a></h3>
public java.lang.String <code>entityName</code>()

<P>Returns the name of the receiver's entity, or <code>null</code> if it doesn't have one.<p>
<B>See also: </B>  
<a href="../ClassDescription/Frameset.html#2252" target="_top"><code>entityName</code></a> (ClassDescription)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2946"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/eoDescription">eoDescription</a></h3>
public java.lang.String <code>eoDescription</code>()

<P>Returns a full description of the receiver's property values by extracting them using the key-value coding methods. An object referenced through relationships is listed with the results of an <a href="#2951"><code>eoShallowDescription</code></a> message (to avoid infinite recursion through cyclical relationships).<p>
This method is useful for debugging. You can implement a <code>description</code> method that invokes this one, and the debugger's print-object command (<code>po</code> on the command line) automatically displays this description. You can also invoke this method directly on the command line of the debugger.<p>
<B>See also: </B>  
<a href="#1074"><code>userPresentableDescription</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2951"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/eoShallowDescription">eoShallowDescription</a></h3>
public java.lang.String <code>eoShallowDescription</code>()

<P>Returns a string containing the receiver's class and entity names.<p>
<B>See also: </B>  
<a href="#2946"><code>eoDescription</code></a>, <a href="#1074"><code>userPresentableDescription</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2962"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/handleQueryWithUnboundKey">handleQueryWithUnboundKey</a></h3>
public java.lang.Object <code>handleQueryWithUnboundKey</code>(java.lang.String <em>key</em>)

<P>Invoked from <code><a href="#1562">valueForKey</a></code> when it finds no property binding for <em>key</em>. CustomObject's implementation throws an exception. Subclasses can override it to handle the query in some other way.<p>
<B>See also: </B>  
<a href="#2967"><code>handleTakeValue</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2967"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/handleTakeValue">handleTakeValue</a></h3>
public void <code>handleTakeValue</code>(java.lang.Object <em>value</em>, java.lang.String <em>key</em>)

<P>Invoked from <code><a href="#3078">takeValueForKey</a></code> when it finds no property binding for <em>key</em>. CustomObject's implementation throws an exception. Subclasses can override it to handle the request in some other way.<p>
<B>See also: </B>  
<a href="#2962"><code>handleQueryWithUnboundKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2989"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/inverseForRelationshipKey">inverseForRelationshipKey</a></h3>
public java.lang.String <code>inverseForRelationshipKey</code>(java.lang.String <em>relationshipKey</em>)

<P>Returns the name of the relationship pointing back to the receiver's class or entity from that named by <em>relationshipKey</em>, or <code>null</code> if there isn't one. With next.eo.Entity and next.eo.Relationship, for example, reciprocality is determined by the join attributes of the two Relationships.<p>
You might override this method for reciprocal relationships that aren't defined using the same join attributes. For example, if a Member object has a relationship to CreditCard based on the card number, but a CreditCard has a relationship to Member based on the Member's primary key, both classes need to override this method.<p>
<B>See also: </B>  
<a href="../ClassDescription/Frameset.html#2278" target="_top"><code>inverseForRelationshipKey</code></a> (ClassDescription)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2994"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/isToManyKey">isToManyKey</a></h3>
public boolean <code>isToManyKey</code>(java.lang.String <em>key</em>)

<P>Returns <code>true</code> if the receiver has a to-many relationship identified by <em>key</em>, <code>false</code> otherwise.<p>
<B>See also: </B>  
<a href="#3103"><code>toManyRelationshipKeys</code></a>, <a href="#4366"><code>toOneRelationshipKeys</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3004"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/ownsDestinationObjectsForRelationshipKey">ownsDestinationObjectsForRelationshipKey</a></h3>
public boolean <code>ownsDestinationObjectsForRelationshipKey</code>(java.lang.String <em>key</em>)

<P>Returns <code>true</code> if the receiver has a relationship identified by <em>key</em> that owns its destination, <code>false</code> otherwise. If an object owns the destination for a relationship, then when that destination object is removed from the relationship, it's automatically deleted. Ownership of a relationship thus contrasts with a delete rule, in that the first applies when the destination is removed and the second applies when the source is deleted.<p>
<B>See also: </B>  
<a href="#2909"><code>deleteRuleForRelationshipKey</code></a>, 
<a href="../ClassDescription/Frameset.html#2283" target="_top"><code>ownsDestinationObjectsForRelationshipKey</code></a> (ClassDescription), 
<code>ownsDestination</code> (next.eo.Relationship)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3026"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/propagateDeleteWithEditingContext">propagateDeleteWithEditingContext</a></h3>
public void <code>propagateDeleteWithEditingContext</code>(next.eo.EditingContext <em>anEditingContext</em>)

<P>Sends a <a href="../ClassDescription/Frameset.html#2293" target="_top"><code>propagateDeleteForObject</code></a> message to the receiver's ClassDescription. This causes the destination objects of the receiver's relationships to be deleted according to the delete rule for each relationship:<p>
<Table Border="3">
<caption></caption>
<tr><th><b>Delete Rule</b>
</th><th><b>Action</b>
</th></tr>
<tr><td colspan=1 rowspan=3 scope="row">DeleteRuleNullify
</td><td colspan=1 rowspan=3>The destination object is simply removed from the relationship, and the receiver 
is likewise removed from the destination's reciprocal relationship if there is one.
</td></tr>
<tr></tr>
<tr></tr>
<tr><td colspan=1 rowspan=2 scope="row">DeleteRuleCascade
</td><td colspan=1 rowspan=2>As above, but the destination object is also deleted and sent a 
<code>propagateDeleteWithEditingContext</code> message.
</td></tr>
<tr></tr>
<tr><td scope="row">DeleteRuleDeny
</td><td>Applied in <a href="#7260"><code>validateForDelete</code></a>, not in this method.
</td></tr>
<tr><td scope="row">DeleteRuleNoAction
</td><td>The relationship is ignored when the receiver is deleted. 
</td></tr>

</Table>

<Table>
<tr><td>
</Table>
<p>
The DeleteRuleNoAction option is useful for tuning performance. In order to perform a deletion, Enterprise Objects Framework fires all the faults of the deleted object and then fires any to-many faults that point back to the deleted object. For example, suppose you have a simple application based on the sample Movies database. Deleting a Movie object has the effect of firing a to-one fault for the Movie's <code>studio</code> relationship, and then firing the to-many <code>movies</code> fault for that studio. In this scenario, it would make sense to set the delete rule DeleteRuleNoAction for Movie's <code>studio</code> relationship. However, you should use this delete rule with great caution since it can result in dangling references in your object graph.<p>
<B>See also: </B>  
<a href="#2909"><code>deleteRuleForRelationshipKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3031"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/removeObjectFromBothSidesOfRelationshipWithKey">removeObjectFromBothSidesOfRelationshipWithKey</a></h3>
public void <code>removeObjectFromBothSidesOfRelationshipWithKey</code>(java.lang.Object <em>anObject</em>, 
java.lang.String <em>key</em>)

<P>Removes <em>anObject</em> from the receiver's relationship identified by <em>key</em>, and also removes the receiver from <em>anObject</em>'s reciprocal relationship if there is one. For a to-one relationship, <em>anObject</em> is removed using <code><a href="#3078">takeValueForKey</a></code> with <code>null</code> as the value. For a to-many relationship, <em>anObject</em> is removed using <code><a href="#3036">removeObjectFromPropertyWithKey</a></code>.<p>
<B>See also: </B>  
<a href="#2783"><code>addObjectToBothSidesOfRelationshipWithKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3036"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/removeObjectFromPropertyWithKey">removeObjectFromPropertyWithKey</a></h3>
public void <code>removeObjectFromPropertyWithKey</code>(java.lang.Object <em>anObject</em>, java.lang.String <em>key</em>)

<P>Removes <em>anObject</em> from the receiver's to-many relationship identified by <em>key</em>, without modifying a reciprocal relationship. Similar to the implementation of <a href="#3078"><code>takeValueForKey</code></a>, CustomObject's implementation of this method first attempts to invoke a method of the form <code>removeFrom</code><em>Key</em>. If the receiver doesn't have such a method, this method gets the property array using <a href="#1562"><code>valueForKey</code></a> and operates directly on that. If the array is mutable, this method simply locates <em>anObject</em> and removes it using <code>removeElementAt</code>. Otherwise it constructs a new array containing any existing objects minus <em>anObject</em>, then sets it using <code><a href="#3078">takeValueForKey</a></code>.<p>
<B>See also: </B>  
<a href="#2788"><code>addObjectToPropertyWithKey</code></a>, <a href="#3031"><code>removeObjectFromBothSidesOfRelationshipWithKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3047"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/snapshot">snapshot</a></h3>
public next.util.ImmutableHashtable <code>snapshot</code>()

<P>Returns a dictionary whose keys are those of the receiver's attributes, to-one relationships, and to-many relationships, and whose values are the values of those properties, with NullValue substituted for <code>null</code>. For to-many relationships, the dictionary contains shallow copies of the arrays.<p>
<B>See also: </B>  
<a href="#3113"><code>updateFromSnapshot</code></a>, <a href="#2836"><code>allPropertyKeys</code></a>, <a href="#1562"><code>valueForKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3078"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/takeValueForKey">takeValueForKey</a></h3>
public void <code>takeValueForKey</code>(java.lang.Object <em>value</em>, java.lang.String <em>key</em>)

<P>Sets the value for the property identified by <em>key</em> to <em>value</em>. CustomObject's implementation does so by first checking the receiver for a method of the form <code>set</code><em>Key</em>, invoking it if there is one. If there's no such method,  CustomObject's implementation checks for an instance variable named <em>key</em> and sets the value directly.<p>
If there's neither an accessor method nor an instance variable matching <em>key</em>, CustomObject's implementation invokes <code><a href="#2967">handleTakeValue</a></code> as a fallback mechanism. Subclasses can override <code>handleTakeValue</code> to handle the request in some other way. For more discussion of key-value coding, see the section <a href="#3439">"Key-Value Coding Methods"</a> in the class description.<p>
<B>See also: </B>  
<a href="#3083"><code>takeValueForKeyPath</code></a>, <a href="#3088"><code>takeValuesFromDictionary</code></a>, <a href="#1562"><code>valueForKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3083"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/takeValueForKeyPath">takeValueForKeyPath</a></h3>
public void <code>takeValueForKeyPath</code>(java.lang.Object <em>value</em>, java.lang.String <em>keyPath</em>)

<P>Sets the value for the derived property identified by <em>keyPath</em> to <em>value</em>. A key path has the form <em>relationship.property</em> (with one or more relationships); for example "department.name". CustomObject's implementation of this method gets the destination object for each relationship using <code><a href="#1562">valueForKey</a></code>, and sends the final object a <code><a href="#3078">takeValueForKey</a></code> message with <em>value</em> and <em>property</em>.<p>
<B>See also: </B>  
<a href="#3088"><code>takeValuesFromDictionary</code></a>, <a href="#1616"><code>valueForKeyPath</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3088"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/takeValuesFromDictionary">takeValuesFromDictionary</a></h3>
public void <code>takeValuesFromDictionary</code>(next.util.ImmutableHashtable <em>anImmutableHashtable</em>)

<P>Sets properties of the receiver with values from <em>anImmutableHashtable</em>, using the keys to identify the properties. CustomObject's implementation invokes <code><a href="#3078">takeValueForKey</a></code> for each key-value pair, substituting <code>null</code> for NullValues in <em>anImmutableHashtable</em>.<p>
<B>See also: </B>  
<a href="#3113"><code>updateFromSnapshot</code></a>, <a href="#3083"><code>takeValueForKeyPath</code></a>, <a href="#1674"><code>valuesForKeys</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3103"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/toManyRelationshipKeys">toManyRelationshipKeys</a></h3>
public next.util.ImmutableVector <code>toManyRelationshipKeys</code>()

<P>Returns the names of the receiver's to-many relationships, as determined from the ClassDescription. You might wish to override this method to add keys for relationships not defined by the ClassDescription. The access layer's subclass of ClassDescription, next.eo.EntityClassDescription, returns the names of to-many relationships designated as class properties.<p>
<B>See also: </B>  
<a href="#4366"><code>toOneRelationshipKeys</code></a>., <a href="#2841"><code>attributeKeys</code></a>, <a href="../ClassDescription/Frameset.html#2313" target="_top"><code>toManyRelationshipKeys</code></a> (ClassDescription)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="4366"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/toOneRelationshipKeys">toOneRelationshipKeys</a></h3>
public next.util.ImmutableVector <code>toOneRelationshipKeys</code>()

<P>Returns the names of the receiver's to-one relationships, as determined from the ClassDescription. You might wish to override this method to add keys for relationships not defined by the ClassDescription. The access layer's subclass of ClassDescription, next.eo.EntityClassDescription, returns the names of to-one relationships designated as class properties.<p>
<B>See also: </B>  
<a href="#3103"><code>toManyRelationshipKeys</code></a>., <a href="#2841"><code>attributeKeys</code></a>, <a href="../ClassDescription/Frameset.html#2323" target="_top"><code>toOneRelationshipKeys</code></a> (ClassDescription)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3123"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/unableToSetNullForKey">unableToSetNullForKey</a></h3>
public void <code>unableToSetNullForKey</code>(java.lang.String <em>key</em>)

<P>Invoked from <code><a href="#3078">takeValueForKey</a></code> when it's given a <code>null</code> value for a scalar property (such as an <code>int</code> or a <code>float</code>). CustomObject's implementation throws an exception. Subclasses can override it to handle the request in some other way, such as by substituting zero or a sentinel value and invoking <code>takeValueForKey</code> again.<p>
<hr WIDTH=25% ALIGN=LEFT>
<a name="3113"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/updateFromSnapshot">updateFromSnapshot</a></h3>
public void <code>updateFromSnapshot</code>(next.util.ImmutableHashtable <em>aSnapshot</em>)

<P>Takes the values from <em>aSnapshot</em>, setting each one according to its key using <code><a href="#3078">takeValueForKey</a></code>. In the process, NullValues are converted to <code>null</code>, and array values are set as shallow mutable copies.<p>
<B>See also: </B>  
<a href="#3088"><code>takeValuesFromDictionary</code></a>, <a href="#3047"><code>snapshot</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1074"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/userPresentableDescription">userPresentableDescription</a></h3>
public java.lang.String <code>userPresentableDescription</code>()

<P>Returns a short (no longer than 60 characters) description of an enterprise object based on its data. CustomObject's implementation first checks to see if the enterprise object has an attribute called "name" and if so, it returns its value. Otherwise, checks for an attribute called "title". If neither of those attributes exists, this method enumerates the object's <a href="#2841"><code>attributeKeys</code></a> and returns the values of all of its properties, separated by commas (applying the default formatter for numbers and dates).<p>
<B>See also: </B>  
<a href="#2946"><code>eoDescription</code></a>, <a href="#2951"><code>eoShallowDescription</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="7260"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/validateForDelete">validateForDelete</a></h3>
public java.lang.Throwable <code>validateForDelete</code>()

<P>Confirms that the receiver can be deleted in its current state, returning <code>null</code> if it can or an exception that the sender may throw if it can't. For example, an object can't be deleted if it has a relationship with a delete rule of DeleteRuleDeny and that relationship has a destination object.<p>
CustomObject's implementation sends the receiver's ClassDescription a <a href="../ClassDescription/Frameset.html#2343" target="_top"><code>validateObjectForDelete</code></a> message (which performs basic checking based on the presence or absence of values). Subclasses should invoke <code>super</code>'s implementation before performing their own validation, and should combine any exception returned by <code>super</code>'s implementation with their own.<p>
<B>See also: </B>  
<a href="#3138"><code>validateForInsert</code></a>, <a href="#1095"><code>validateForSave</code></a>, <a href="#1287"><code>validateForUpdate</code></a>, <a href="#3148"><code>validateValueForKey</code></a>, 
<a href="../ClassDescription/Frameset.html#4282" target="_top"><code>exceptionAddingEntriesToUserInfo</code></a> (Class Description), 
<a href="../ClassDescription/Frameset.html#4220" target="_top"><code>aggregateExceptionWithExceptions</code></a> (Class Description)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3138"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/validateForInsert">validateForInsert</a></h3>
public java.lang.Throwable <code>validateForInsert</code>()

<P>Confirms that the receiver can be inserted in its current state, returning <code>null</code> if it can or an exception that can be thrown if it can't. CustomObject's implementation simply invokes <code><a href="#1095">validateForSave</a></code>.<p>
<B>See also: </B>  
<a href="#7260"><code>validateForDelete</code></a>, <a href="#1287"><code>validateForUpdate</code></a>, <a href="#3148"><code>validateValueForKey</code></a>, 
<a href="../ClassDescription/Frameset.html#4282" target="_top"><code>exceptionAddingEntriesToUserInfo</code></a> (Class Description)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1095"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/validateForSave">validateForSave</a></h3>
public java.lang.Throwable <code>validateForSave</code>()

<P>Confirms that the receiver can be saved in its current state, returning <code>null</code> if it can or an exception that the sender may throw if it can't. CustomObject's implementation sends the receiver's ClassDescription a <a href="../ClassDescription/Frameset.html#2353" target="_top"><code>validateObjectForSave</code></a> message, then iterates through all of the receiver's properties, invoking <a href="#3148"><code>validateValueForKey</code></a> for each one. Subclasses should invoke <code>super</code>'s implementation before performing their own validation, and should combine any exception returned by <code>super</code>'s implementation with their own.<p>
Enterprise objects can implement this method to check that certain relations between properties hold; for example, that the end date of a vacation period follows the begin date. To validate an individual property, you can simply implement a method for it as described under <a href="#3148"><code>validateValueForKey</code></a>.<p>
<B>See also: </B>  
<a href="#7260"><code>validateForDelete</code></a>, <a href="#3138"><code>validateForInsert</code></a>, <a href="#1287"><code>validateForUpdate</code></a>, 
<a href="../ClassDescription/Frameset.html#4282" target="_top"><code>exceptionAddingEntriesToUserInfo</code></a> (Class Description), 
<a href="../ClassDescription/Frameset.html#4220" target="_top"><code>aggregateExceptionWithExceptions</code></a> (Class Description)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1287"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/validateForUpdate">validateForUpdate</a></h3>
public java.lang.Throwable <code>validateForUpdate</code>()

<P>Confirms that the receiver can be updated in its current state, returning <code>null</code> if it can or an exception that the sender may throw if it can't. CustomObject's implementation simply invokes <code><a href="#1095">validateForSave</a></code>.<p>
<B>See also: </B>  
<a href="#7260"><code>validateForDelete</code></a>, <a href="#3138"><code>validateForInsert</code></a>, <a href="#1095"><code>validateForSave</code></a>, <a href="#3148"><code>validateValueForKey</code></a>, 
<a href="../ClassDescription/Frameset.html#4282" target="_top"><code>exceptionAddingEntriesToUserInfo</code></a> (Class Description)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3148"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/validateValueForKey">validateValueForKey</a></h3>
public java.lang.Throwable <code>validateValueForKey</code>(next.util.MutableVector <em>value</em>, java.lang.String <em>key</em>)

<P>Confirms that <em>value</em> is legal for the receiver's property named by <em>key</em>, returning <code>null</code> if it can or an exception that the sender may throw if it can't. CustomObject's implementation sends a <a href="../ClassDescription/Frameset.html#2363" target="_top"><code>validateValueForKey</code></a> message to the receiver's ClassDescription. If that message doesn't return an exception, it checks for a method of the form <code>validate</code><em>Key</em> (for example, <code>validateBudget</code> for a <em>key</em> of "budget") and invokes it, returning the result.<p>
Enterprise objects can implement individual <code>validate</code><em>Key</em> methods to check limits, test for nonsense values, and otherwise confirm individual properties. To validate multiple properties based on relations among them, override the appropriate <code>validateFor...</code> method.<p>
<B>See also: </B>  
<a href="#7260"><code>validateForDelete</code></a>, <a href="#3138"><code>validateForInsert</code></a>, <a href="#1095"><code>validateForSave</code></a>, <a href="#1287"><code>validateForUpdate</code></a>, 
<a href="../ClassDescription/Frameset.html#4282" target="_top"><code>exceptionAddingEntriesToUserInfo</code></a> (Class Description)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1562"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/valueForKey">valueForKey</a></h3>
public java.lang.Object <code>valueForKey</code>(java.lang.String <em>key</em>)

<P>Returns the value for the property identified by <em>key</em>. CustomObject's implementation does so by first checking the receiver for a method named <em>key</em>, invoking it if there is one. If there's no such method, CustomObject's implementation checks for an instance variable named <em>key</em> and returns the instance variable. If there's neither an accessor method nor an instance variable matching <em>key</em>, CustomObject's implementation invokes <code><a href="#2962">handleQueryWithUnboundKey</a></code> as a fallback mechanism. Subclasses can override <code>handleQueryWithUnboundKey</code> to handle the request in some other way.<p>
<B>See also: </B>  
<a href="#1616"><code>valueForKeyPath</code></a>, <a href="#1674"><code>valuesForKeys</code></a>, <a href="#3078"><code>takeValueForKey</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1616"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/valueForKeyPath">valueForKeyPath</a></h3>
public java.lang.Object <code>valueForKeyPath</code>(java.lang.String <em>keyPath</em>)

<P>Returns the value for the derived property identified by <em>keyPath</em>. A key path has the form <em>relationship.property</em> (with one or more relationships); for example "department.name". CustomObject's implementation of this method gets the destination object for each relationship using <code><a href="#1562">valueForKey</a></code>, and returns the result of a <code>valueForKey</code> message to the final object.<p>
<B>See also: </B>  
<a href="#1674"><code>valuesForKeys</code></a>, <a href="#3083"><code>takeValueForKeyPath</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1674"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/valuesForKeys">valuesForKeys</a></h3>
public next.util.ImmutableHashtable <code>valuesForKeys</code>(next.util.ImmutableVector <em>keys</em>)

<P>Returns a dictionary containing the property values identified by each of <em>keys</em>. CustomObject's implementation invokes <a href="#1562"><code>valueForKey</code></a> for each key in <em>keys</em>, substituting NullValue in the dictionary for returned <code>null</code> values.<p>
<B>See also: </B>  
<a href="#1616"><code>valueForKeyPath</code></a>, <a href="#3088"><code>takeValuesFromDictionary</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1807"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/willChange">willChange</a></h3>
public void <code>willChange</code>()

<P>Notifies any observers that the receiver's state is about to change. A subclass should not override this method, but should invoke the it prior to altering their state, most typically in "set" methods such as the following:<p>
<blockquote><pre>public void setRoleName(String value) {<br>    willChange();<br>    roleName = value;<br>}
</pre></blockquote><p><B>See also: </B>  
<a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top"><code>willChange</code></a> (EnterpriseObject interface)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="6131"></a>
<h3> <a name="//apple_ref/java/instm/CustomObject/willRead">willRead</a></h3>
public void <code>willRead</code>()

<P>Fills the receiver with values fetched from the database. A subclass should not override this method but should invoke it prior to any attempt to access the object's state, most typically in "get" methods such as the following:<p>
<blockquote><pre>public String roleName() {<br>    willRead();<br>    return roleName;<br>}
</pre></blockquote><p><B>See also: </B>  
<a href="../../Interfaces/EnterpriseObject/Frameset.html#" target="_top"><code>willRead</code></a> (EnterpriseObject interface)
<p>
 
 


<i>Copyright &#169; 1998, Apple Computer, Inc.   All rights
reserved.</i>

<!-- Last updated: 01/21/98 14:05:29 -->

</body>
</html>
