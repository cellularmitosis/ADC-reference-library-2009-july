<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note DV515: Device Manager Q&amp;As</title><meta name="keywords" content="Mac OS 8 Device Manager drivers SCSI SetChooserAlert OpenDriver accRun"><meta name="Description" content="Technical Note DV515: This Technical Note contains a collectionof archived Q&amp;As relating to the Device Manager --questionssent the Developer Support Center (DSC) along with answersfrom the DSC engineers. Archived questions include: System7.0 and the SetChooserAlert bug; Sending asynchronous controlcalls to a driver (PBRead/PBWrite); how to check if a driveris already open; Determining if a file is read from CD-ROMor Hard Disk; accessing a driver resource fork at accRuntime; JMP or JSR when calling IODone; using a gdRefNum tofind the associated slot; and supporting locked and ejectableSCSI devices.">                                       <meta name="categories" content="Devices"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002417" title="Device Manager Q&As"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note DV515</div>
<div id="pageheadsub">Device Manager Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc --><p id="menutext"><A HREF="#Section1">System 7.0 and SetChooserAlert bug</a><BR><BR><A HREF="#Section2">PBRead/PBWrite instead of FSRead/FSWrite after asynchronous call</a><BR><BR><A HREF="#Section3">Ensuring that Macintosh driver isn't open already</a><BR><BR><A HREF="#Section4">Determining if a file is read from CD-ROM or hard disk</a><BR><BR><A HREF="#Section5">Accessing a Macintosh driver resource fork at <BR>accRun time</a><BR><BR><A HREF="#Section6">DAs in background under System 7.0 lack <BR>UnitTable entries</a><BR><BR><A HREF="#Section7">JMP or JSR When Calling IODone</a><BR><BR><A HREF="#Section8">New info on Macintosh Device Manager calls</a><BR><BR><A HREF="#Section9">Given a Macintosh gdRefNum, how can I find the <BR>associated slot?</a><BR><BR><A HREF="#Section10">Macintosh journaling mechanism</a><BR><BR><A HREF="#Section11">How do I support locked and ejectable <BR>SCSI devices?</a><BR><BR><A HREF="#downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id = "introtext">			This Technical Note contains a collection of archived Q&amp;As relating to a specific topic--questions sent the Developer Support Center (DSC) along withanswers from the DSC engineers. Current Q&amp;As can be found on the <a href="../../qa/index.html">Macintosh Technical Q&amp;As web site</a>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><A NAME=Section1></A><h2>System 7.0 and SetChooserAlert bug</h2><p>Date Written:  12/28/92</p><p>Last reviewed:  3/1/93</p><p>With System 7.0, <code>SetChooserAlert</code> doesn't seem to work as documented. It doeschange the state of bit 6 in <code>HiliteMode</code>, but the "Please change your page setup" message comes up in the Chooser regardless. Is there any workaround for this?</p><p>___</p><p>The problem you reported is indeed a bug with system software version 7.0 andlater. Correcting the system software is the only solution, though this fix maybe as simple as a tweak in a future Chooser release (which could come outsooner than a new system software release).  Until such a fix is made,<code>SetChooserAlert</code> will only work with system software prior to version 7.0.</p><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>PBRead/PBWrite instead of FSRead/FSWrite after asynchronous call</h2><p>Date Written:  11/24/92</p><p>Last reviewed:  6/14/93</p><p>I want to send an asynchronous Control command to my driver and while thecommand is being processed continue work. However, the continued work includessending <code>FSWrite</code> and <code>FSRead</code> commands to the driver. Is this possible?</p><p>___</p><p>When you send an asynchronous call to a driver, it gets added to the driver I/Oqueue. The driver deals with each request in a sequential order. Both <code>FSWrite</code>and <code>FSRead</code> are synchronous. This means that the I/O request is added to thedriver queue, and then the Device Manager loops in an internal routine named<code>SyncWait</code>, waiting for <code>ioResult</code> to be less than or equal to 0 (<code>noErr</code>). We assumethat you have an interrupt service routine or some other method of completingthe I/O request.</p><p>If you make a call to either <code>FSWrite</code> or <code>FSRead</code> after doing an asynchronouscall, you set up a race condition where the driver is waiting to complete theasynchronous Control call, while the <code>FSRead/Write</code> call is waiting for itscompletion flag to be marked as done. This won't work.</p><p>The solution is to use <code>PBWrite</code> and <code>PBRead</code> instead, and set the asynchronousflag in the call. This way, the driver can properly queue up the calls andhandle them in the order issued.</p><p>Note that the calls are queued up in a first-in-first-out order. Your controlcall will complete before your <code>PBRead</code> or <code>PBWrite</code> starts (that is, the Macintoshisn't truly asynchronous in this respect). For instance, if you did the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PBControl, PBWrite, PBRead, PBRead</pre>	</TD></TR></TABLE></CENTER><p>they'd be executed in precisely that fashion. The last <code>PBRead</code> won't be executeduntil all three previous calls have finished.</p><p>For more information about the way drivers work, you should look on the latest<i>Developer CD Series</i> disc for a preliminary copy of the new <i>InsideMacintosh</i> chapter on devices. The path to this volume is: TechnicalDocumentation: Inside Macintosh: Devices The new chapter is far better than theold <i>Inside Macintosh</i> chapters at explaining how device drivers work.This chapter also has a pretty good explanation of how asynchronous andimmediate calls work.</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>Ensuring that Macintosh driver isn't open already</h2><p>Date Written:  11/13/92</p><p>Last reviewed:  3/1/93</p><p>How do I ensure that my driver isn't open already?</p><p>___</p><p>Check the <code>dOpened</code> flag in your driver's <code>dCtlEntry</code>. This bit is setautomatically by the Device Manager when your driver is opened, then clearedwhen it's closed.  However, most drivers should be written so they can takesuperfluous open calls; many programmers use <code>Open</code> as a method of getting adriver's <code>refNum</code> and opening it at the same time; your driver should check tosee if it's already been opened, and if so, do nothing.</p><P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>Determining if a file is read from CD-ROM or hard disk</h2><p>Date Written:  8/23/91</p><p>Last reviewed:  9/24/91</p><p>How can we tell whether a particular Macintosh file is being read from a CD-ROMor a hard disk?</p><p>___</p><p>You can call the Device Manager routine OpenDriver using the ".AppleCD" stringto find a driver reference number of the AppleCD SC drive. If there is morethan one AppleCD SC drive hooked up, then additional ".AppleCD" driverreference numbers can be obtained by using the <code>PBControl</code> call with a csCode =97 (WhoIsThere). This command returns a mask of which SCSI devices are beingserviced by the ".AppleCD" driver (that is, which other drives are AppleCD SCs).</p><p>The following code returns the driver reference number for an ".AppleCD" driverinstance. The input parameter CDDrive specifies which logical AppleCD SC drivein the SCSI chain to open.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#define csWhoIsThere    97typedef unsigned short    Word;typedef    unsigned long    Long;typedef struct WhoIsThereRec {    ParamBlockHeader    short        ioRefNum;    short        csCode;    struct {        Byte    fill;        Byte    SCSIMask;    } csParam;} WhoIsThereRec;pascal    OSErr OpenCD(Byte CDDrive, short *ioRefNum) {    auto    OSErr            osErr;    auto    short            ioRefNumTemp,                            CDDriveCount,                            SCSIID;    auto    WhoIsThereRec    *pb;    pb = (WhoIsThereRec *) NewPtrClear(sizeof (*pb));    osErr = MemError();    if (0 != pb &amp;&amp; noErr == osErr) {        osErr = OpenDriver("\p.AppleCD", &amp;ioRefNumTemp);        if (noErr == osErr) {            (*pb).ioRefNum        = ioRefNumTemp;            (*pb).csCode        = csWhoIsThere;            osErr = PBStatus((ParmBlkPtr)pb, false);            if (noErr == osErr) {                CDDriveCount = 0;                for (SCSIID = 0; SCSIID &lt; 7; ++SCSIID) {                    if (BitTst(&amp;(*pb).csParam.SCSIMask, 7 - SCSIID)) {                        ++CDDriveCount;                        if (CDDrive == CDDriveCount) {                            *ioRefNum = -(32 + SCSIID) - 1;                            DisposPtr((Ptr) pb);                            return noErr;                        }                    }                }                osErr = paramErr;            }        }        DisposPtr((Ptr) pb);    }    return osErr;}</pre>	</TD></TR></TABLE></CENTER><p>You can modify <code>OpenCD</code> to do exactly what it is you need it to do. Or, you mightuse it to iterate over the logical CD drive numbers from 0 to 6 until <code>OpenCD</code>returns something other than <code>noErr</code>. If you modify the <code>OpenCD</code> routine, you'llneed the <i>AppleCD SC Developers Guide,</i> Revised Edition to be successful. Note also that all unused fields of a parameter block used with the ".AppleCD" driver must be set to zero before calling <code>PBControl</code>.</p><p>Iterating over the seven possibilities will result in a table of known".AppleCD" drive entries - perhaps something like the following structure:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    struct {     int count;     short cdDRefNum[7];    } knownCDDRefNum;</pre>	</TD></TR></TABLE></CENTER><p>With this table in hand, you can match the driver reference number for thevolume of any file. In most cases you know which volume the file was on whenyou opened it. Also, the routines <code>PBGetFCBInfo</code> and <code>PBGetCatInfo</code> both return thevolume reference number for a file.</p><p>Once you determine the volume reference numbers, either traverse the VCB tableor call <code>PBGetVInfo</code> to get the driver reference number. This driver referencenumber is the driver handling all requests made by the File System for your file!</p><p>If that driver reference number for the file is in our "knownCDDRefNum" table,then that file resides on an AppleCD SC drive. This technique works only forApple or Apple-compatible drivers. An alternate approach to the problem isstepping through the driver table and locating all entries with the name".AppleCD," noting their driver reference numbers, and then following theprocedure outlined above to determine if a file is on a volume owned by that driver.</p><p>The <code>csCode</code> method is far clearer than this one, and should be used wheneverpossible. The bottom line is that there is no guaranteed method of locating aCD-ROM drive due to the lack of a standardized driver model.</p><p>X-Ref:</p><p>Device Manager chapters of <i>Inside Macintosh</i> Volumes II, IV, and V</p><p>"Finding a Slot for a Driver" note on latest <i>Developer CD Series</i> disc</p><P><A HREF="#top">Back to top</A></P><a name="Section5"></a><h2>Accessing a Macintosh driver resource fork at accRun time</h2><p>Date Written:  6/20/91</p><p>Last reviewed:  8/13/91</p><p>How do I get Macintosh resources from a driver Init file at accRun time? I can't think of a way other that getting the full path name, which is discouraged.</p><p>___</p><p>Basically, you need to call <code>PBGetFCBInfo</code> at INIT time to grab the filename,directory ID and volume reference number for the INIT's resource fork. You canthen store these in your INIT and pull them out at accRun time. At <code>accRun</code>, justcall <code>HOpenResFile</code> to get to your resources. This method is _much_ better thanusing a full pathname, since this still works in the case where the userre-names the folder containing your INIT.</p><p>Here's some sample code that does what you need:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSErr GetCurResLocn(short *saveVRefNum,long *saveDirID,StringPtr saveFName){    FCBPBRec pb;    OSErr err;    short theFile;    Str255 fName;    theFile = CurResFile();    pb.ioFCBIndx = 0;    pb.ioVRefNum = 0;    pb.ioRefNum = theFile;    pb.ioNamePtr = saveFName;    err = PBGetFCBInfo (&amp;pb,false);    *saveVRefNum = pb.ioFCBVRefNum;    *saveDirID = pb.ioFCBParID;    return err;}OSErr SetCurResLocn(short saveVRefNum,long saveDirID,StringPtr saveFName,                    short *newResFile){    short resRef;    OSErr err;    HOpenResFile(saveVRefNum,saveDirID,saveFName,fsRdWrPerm);    err = ResError();    if (err!=noErr)        return err;    UseResFile(resRef); /* &lt;-- needed in case the res. file was prev. open */    *newResFile = resRef;    return ResError();}void main(){    OSErr err;    short saveVRefNum;    long saveDirID;    Str255 saveFName;    short newResFile;    err = GetCurResLocn(&amp;saveVRefNum,&amp;saveDirID,saveFName);    if (err!=noErr)        return;    /* ... pass control off to computer here (we're an app, so we fake it) ... */    err = SetCurResLocn(saveVRefNum,saveDirID,saveFName,&amp;newResFile);    if (err!=noErr)        DebugStr("\pfailed");}</pre>	</TD></TR></TABLE></CENTER><p>As you can see, this is an application, so you'll have to do some minormodifications (possibly convert to 680x0). It's pretty straightforward, and the<code>HOpenResFile</code> call is included in MPW glue for MPW 3.0 and is a built-in callfor System 7.</p><P><A HREF="#top">Back to top</A></P><a name="Section6"></a><h2>DAs in background under System 7.0 lack UnitTable entries</h2><p>Date Written:  3/14/91</p><p>Last reviewed:  6/17/91</p><p>Under System 6 my driver, which runs all the time, can send a control call tomy open DA (because it too is a driver). Under System 7.0 I get <code>badUnitErr</code>errors (-21) because evidently my DA resides in a different process that isinaccessible to my system-resident driver. How can I get around this?</p><p>___</p><p>DAs in System 7.0 do not actually have <code>UnitEntries</code> unless they are currentlyrunning, so your driver cannot call your DA unless the DA is frontmost. Whatyou might consider instead is having the DA periodically issue a call to thedriver, asking if there is anything for it at the moment. If you have an entitythat hands data to your resident driver, and the DA then requests the data fromthe resident driver from time to time, you should have a very robust mechanism,albeit a slightly slower one with greater latency.</p><P><A HREF="#top">Back to top</A></P><a name="Section7"></a><h2>JMP or JSR When Calling IODone</h2><p>Date Written:  12/12/90</p><p>Last reviewed:  6/14/93</p><p>After an I/O call to a Macintosh slot device driver, shouldn't the IODoneroutine be called by a JSR instead of a JMP instruction in order for a slotdevice to return to it with D0 set to an appropriate value depending on whetherthe interrupt was serviced?</p><p>___</p><p>Correct. You call IODone when the queued I/O request has been fully completed.If the interrupt handler is completing an asynchronous call, you need to call<code>IODone</code>. <code>IODone</code> returns via an RTS, so the sequence would be something like:</p><ol type="1">	<li>Program runs</li>	<li>The interrupt occurs</li>	<li>Primary interrupt handler code JSRs to secondary (such as VIA) interrupt handler</li>	<li>Secondary interrupt handler BSRs to slot handler code</li>	<li>Slot handler does a JSR to your Interrupt Service Routine (ISR)</li>	<li>The I/O request is complete, so your ISR sets result code in D0 and JSRs to IODone</li>	<li>IODone does an RTS, which returns to your ISR </li>	<li>Your ISR sets D0 to non-zero and does an RTS to slot handler</li>	<li>Slot handler does an RTS back to secondary handler</li>	<li>Secondary handler RTSes back to primary handler</li>	<li>Primary interrupt handler does an RTE back to the program</li>	<li>The program continues</li></ol><p>If you're just handling a hardware interrupt or the I/O isn't yet complete, don't call <code>IODone</code>. Do an RTS as in the source code example in Chapter 9 of <i>Designing Cards and Drivers for the Macintosh Family</i> (starting with the <code>BeginIH</code> label).</p><P><A HREF="#top">Back to top</A></P><a name="Section8"></a><h2>New info on Macintosh Device Manager calls</h2><p>Date Written:  12/5/90</p><p>Last reviewed:  6/14/93</p><p>Are Macintosh Device Manager status calls with <code>csCode</code>=1 calls filtered out?Also, are all high-level Device Manager routines always executed synchronously?If all the calls are synchronous, why is there a high level <code>KillIO</code> routine (toterminate current and pending processes)?</p><p>___</p><p>Yes, a Status call made with a <code>csCode</code> of 1 never calls your driver. Instead, itreturns (in the <code>csParam</code> field) the handle to your driver's Device Control Entryfrom the Unit Table.</p><p>High-level Device Manager calls are executed synchronously. Only the low-levelcalls can be specified to execute asynchronously. The high-level <code>KillIO</code> routineis useful for terminating I/O pending from a low-level call, which may havebeen initiated by someone else.</p><p>X-Refs:</p><p><i>Inside Macintosh</i> Volume II, Chapter 6</p><P><A HREF="#top">Back to top</A></P><a name="Section9"></a><h2>Given a Macintosh gdRefNum, how can I find the associated slot?</h2><p>Date Written:  3/9/90</p><p>Last reviewed:  12/17/90</p><p>Given a Macintosh gdRefNum, how can I find the associated slot?</p><p>___</p><p>Get the slot number from the auxiliary DCE. The following code snippet indexesthrough the <code>GDevices</code> (it's assumed the check showed the presence of ColorQuickDraw), and pulls the slot number from each <code>GDevice</code> record:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  gGDHandle := GetDeviceList; {get the first GDevice list handle}  repeat    if gGDHandle &lt;&gt; nil then      begin        gAuxDCEHandle := AuxDCEHandle(GetDCtlEntry(gGDHandle^^.gdRefNum));        { do whatever slot specific work is desired, now that the slot }        { number is known }        gGDHandle := GetNextDevice(gGDHandle);        { pass in present GDHandle; the next one is returned }      end;    until gGDHandle = nil;</pre>	</TD></TR></TABLE></CENTER><p>X-Refs:</p><p>"Device Manager," <i>Inside Macintosh</i> Volumes II and IV</p><p>"Graphics Devices," <i>Inside Macintosh</i> Volume V</p><P><A HREF="#top">Back to top</A></P><a name="Section10"></a><h2>Macintosh journaling mechanism</h2><p>Date Written:  5/3/89</p><p>Last reviewed:  12/17/90</p><p>How can I use the journaling mechanism described in <i>Inside Macintosh?</i></p><p>___</p><p>The old journaling mechanism isn't supported any more. It is no longernecessary because of MacroMaker and similar products. MacroMaker now "owns" theolder driver, and any future journaling will be done through MacroMaker.Currently there is no technical documentation available for MacroMaker. Thecurrent abilities of MacroMaker may not support what some developers will wantto do with journaling. Future versions of MacroMaker may add more features.</p><P><A HREF="#top">Back to top</A></P><a name="Section11"></a><h2>How do I support locked and ejectable SCSI devices?</h2><p>Date Written:  5/14/90</p><p>Last reviewed:  6/14/93</p><p>How do I support locked and ejectable SCSI devices?</p><p>___</p><p>The only things you should have to support are the <code>_DriveStatus</code> call and modifythe <code>DrvQEl</code> record. The rest will be handled by the Macintosh system. The <code>_DriveStatus</code> call gives the information for <code>srvStsCode</code>. This is how the system will know what your disk can support. It is typically only used by floppy (or removable) disk drives. The sample SCSI driver from Apple doesn't need to support it, because it doesn't support any of the information in the <code>_DriveStatus</code> call.</p><p>The <code>DrvSts</code> record contains some information of no concern here. The <code>diskInPlace</code>, <code>twoSideFmt</code>, and <code>needsFlush</code> are probably ignored for your device. It's best to zero them out. The <code>DrvSts</code> information is pretty much just the same information returned in the <code>DrvQEl</code> record.</p><p>Also, people sometimes get into trouble while developing a driver becausecurrent File Manager documentation about the drive queue element is vague.There are 4 bytes in front of a <code>DrvQEl</code> record. These determine the device'sabilities, but <i>these bytes are not allocated by the system.</i> Whencreating the <code>DrvQEl</code> record, you need to add these four bytes in front of therecord yourself. The pointer to a <code>DrvQEl</code> will be the actual record, which is<i>after</i> these 4 bytes. To read these bytes yourself, you'll have tosubtract 4 bytes from the <code>DrvQEl</code> pointer.</p><p>It is important to note that the Disk Switch error dialog is not an actualdialog, but the system error. It is handled by the same code as <code>SysError</code> whichshows the system bomb alert. While this window is present, <code>_SystemTask</code> is notbeing called. This means the driver will not get an <code>accRun</code> call. To work aroundthis, you will need a VBL task. When the VBL is called it checks the SCSI busfor being free and if so, tests for a new cartridge. Once found, posts a<code>diskInsertEvt</code>. This will be received by the driver.</p><p>While the media is inserted, the VBL should not be running until after the cartridge is ejected. Otherwise, the SCSI bus will continue to be accessed unnecessarily, which slows the bus. The VBL task could also slow the system while virtual memory is running.</p><P><A HREF="#top">Back to top</A></P>         <a name="downloads"></a>         <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center>                                    <img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (76K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/dv_515.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/dv/dv_515.html%3Fid%3DDTS10002417-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/dv/dv_515.html%3Fid%3DDTS10002417-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/dv/dv_515.html%3Fid%3DDTS10002417-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>