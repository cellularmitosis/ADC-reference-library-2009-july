<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Using Customized Dialog Boxes for Color Pickers</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING36></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="ACI-35.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-37.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="ACI-2.html"><B>Advanced Color Imaging on the Mac OS</B></A> / <BR><DD><A HREF="ACI-29.html"><B>Chapter 2 - Color Picker Manager</B></A> / <A HREF="ACI-34.html"><B>Using the Color Picker Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING36-0></A>
<H2><A NAME=MARKER-9-64></A>Using Customized Dialog Boxes for Color Pickers</H2>
 <A NAME=MARKER-2-65></A>Instead of using the <CODE>PickColor</CODE> function, your application can use the low-level Color Picker Manager functions to create a tighter integration between your application and the dialog box for color pickers. For example, your application can create a floating palette instead of a modal dialog box. When using the low-level Color Picker Manager functions, your application specifies the type of dialog box in which to put the color picker, and your application maintains tighter control over the event loop.<P>
 Your application can use the low-level calls to create three additional types of color picker dialog boxes: system-owned, application-owned, and color picker-owned.<P>
 A <B>system-owned dialog box </B>for color pickers has the same dialog box items as the dialog box created by <CODE>PickColor</CODE>--that is, it has OK, Cancel, and More Choices buttons. However, with the low-level calls, you can make the dialog box a movable modal or modeless dialog box.<P>
 <B><A NAME=MARKER-2-67></A>Application-owned dialog</B> <B>boxes</B> are supplied by applications. You can use this type of dialog box to integrate color pickers with other window features of your application or to extend the controls for color pickers. For example, you could add controls that allow the user to alter the style of an object as well as its color.<P>
 A <B><A NAME=MARKER-2-68></A>color picker-owned dialog box</B> is created by the color picker itself. Creating its own dialog box gives a color picker the flexibility of specifying the size and shape of the color picker (color pickers in system-owned and application-owned dialog boxes are always the same size). This is useful for implementing color pickers in floating palettes.<P>
 Once they're created, your application interacts with all three types of dialog boxes in the same way. The rest of this section describes how to create each type of dialog box and then discusses how your application interacts with the color picker displayed in the dialog box, no matter what type of dialog box you've used. <P>
<A NAME=HEADING36-7></A>
<H3>Creating Dialog Boxes for Color Pickers</H3>
 The following list describes common steps your application takes in creating each of the three types of color picker dialogs. Where page numbers are given for the structures and functions involved, see <I>Advanced Color Imaging Reference</I>. Your application<P>
<UL>
<LI>Creates a structure describing the dialog box and your application's Edit menu. For a system-owned dialog box, you use a <CODE>SystemDialogInfo</CODE> structure <A HREF=#nonexistent-marker>(page 2-23)</A>; for an application-owned dialog box, you use an <CODE>ApplicationDialogInfo</CODE> structure <A HREF=#nonexistent-marker>(page 2-25)</A>; for a color picker-owned dialog box, you use a <CODE>PickerDialogInfo</CODE> structure <A HREF=#nonexistent-marker>(page 2-24)</A>. 
<LI>Uses the <CODE>SetPickerColor</CODE> function <A HREF=#nonexistent-marker>(page 2-46)</A> to set the original and new colors for the color picker.
<LI>Uses the <CODE>SetPickerPrompt</CODE> function <A HREF=#nonexistent-marker>(page 2-41)</A> to specify a text string prompting the user to choose a color for a particular use (for example, "Choose a highlight color").<A NAME=MARKER-2-69></A>
<LI>Uses--for an application-owned dialog box--the <CODE>AddPickerToDialog</CODE> function <A HREF=#nonexistent-marker>(page 2-39)</A> to add a color picker to your application's dialog box.
<LI>Makes the dialog box visible (if your application initially created it as invisible) with the <CODE>SetPickerVisibility</CODE> function <A HREF=#nonexistent-marker>(page 2-40)</A> and, for an application-owned dialog box, with the Window Manager function <CODE>ShowWindow</CODE> (described in the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.)<P>
</UL>
 When creating a system-owned dialog box, your application uses combinations of the <CODE>DialogIsModal</CODE> and <CODE>DialogIsMoveable</CODE> flags in the <CODE>flags</CODE> field of a <CODE>SystemDialogInfo</CODE> structure <A HREF=#nonexistent-marker>(page 2-23)</A> to specify whether the dialog box is modal, movable modal, or modeless. (You should always set one or both flags, because your application should never display a nonmovable, modeless dialog.)<P>
 <A HREF=#MARKER-9-70>Listing 2-4</A> illustrates how to create the movable modal system-owned dialog box shown in <A HREF=ACI-31.html#MARKER-9-38>Figure 2-3</A>.<P>
<B>Listing 2-4  <A NAME=MARKER-9-70></A>Creating a movable modal <A NAME=MARKER-2-71></A>system-owned dialog box</B><P>
<PRE>
OSErr MyBuildMovableModalSysDialog(void)
{
   SystemDialogInfo  sInfo;
   OSErr             result;

   sInfo.flags = DialogIsMoveable + AppIsColorSyncAware + 
                  CanModifyPalette + CanAnimatePalette;
   sInfo.pickerType = 0L;
   sInfo.placeWhere = kDeepestColorScreen;
   sInfo.mInfo.editMenuID = kMyEditMenuID;
   sInfo.mInfo.cutItem = kMyCutItem;
   sInfo.mInfo.copyItem = kMyCopyItem;
   sInfo.mInfo.pasteItem = kMyPasteItem;
   sInfo.mInfo.clearItem = kMyClearItem;
   sInfo.mInfo.undoItem = kMyUndoItem;
   gMyPicker = nil;
   result = CreateColorDialog(&amp;sInfo, &amp;gMyPicker);
   if(result == noErr &amp;&amp; gMyPicker != nil)
   {
      PMColor myPMColor;
      myPMColor.color.rgb = gMyRGBColor;
      myPMColor.profile = 0L;
      SetPickerColor(gMyPicker, kOriginalColor, &amp;myPMColor);
      SetPickerColor(gMyPicker, kNewColor, &amp;myPMColor);
      SetPickerPrompt(gMyPicker, &quot;\pChoose a highlight color:&quot;);
      SetPickerVisibility(gMyPicker, true);
   }
   return result;
}
</PRE>
 Before displaying the dialog box, your application must use the <CODE>SetPickerColor</CODE> function to specify colors for the user to start with. Setting these <I>original</I> and <I>new</I> colors is described in <A HREF=#MARKER-9-79>"Setting Colors for and Getting Colors From the Color Picker" (page 2-18)</A>.<P>
 <A HREF=#MARKER-9-73>Listing 2-5</A> shows how to use the Dialog Manager function <CODE>GetNewDialog</CODE> to create an application-owned dialog box. (See the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for information on the <CODE>GetNewDialog</CODE> function.) To use this dialog box for a color picker, your application needs to create an <CODE>ApplicationDialogInfo</CODE> structure and then call the <CODE>AddPickerToDialog</CODE> function, as shown in this example.<P>
<B>Listing 2-5  Creating an <A NAME=MARKER-2-72></A>application-owned dialog box<A NAME=MARKER-9-73></A></B><P>
<PRE>
OSErr MyBuildAppDialog(void)
{
   ApplicationDialogInfo aInfo;
   OSErr             result;

   /* create the dialog box, but ensure it's color */
   gMyDialog = GetNewDialog(kMyDialogID, nil, (WindowPtr)-1);
   /* set up the ApplicationDialogInfo structure */
   aInfo.flags = DialogIsMoveable + AppIsColorSyncAware + 
                  CanModifyPalette + CanAnimatePalette;
   aInfo.pickerType = 0L;
   aInfo.theDialog = gMyDialog;
   /* put the color picker's origin at (0,0) in the dialog box */
   aInfo.pickerOrigin.h = 0;
   aInfo.pickerOrigin.v = 0;
   /* report Edit menu information */
   aInfo.mInfo.editMenuID = kMyEditMenuID;
   aInfo.mInfo.cutItem = kMyCutItem;
   aInfo.mInfo.copyItem = kMyCopyItem;
   aInfo.mInfo.pasteItem = kMyPasteItem;
   aInfo.mInfo.clearItem = kMyClearItem;
   aInfo.mInfo.undoItem = kMyUndoItem;
   /* add the color picker to the dialog box */
   result = AddPickerToDialog(&amp;aInfo, &amp;gMyPicker);
   if(result == noErr &amp;&amp; gMyPicker != nil)
   {
      PMColor myPMColor;
      myPMColor.color.rgb = gMyRGBColor;
      myPMColor.profile = 0L;
      SetPickerColor(gMyPicker, kOriginalColor, &amp;myPMColor);
      SetPickerColor(gMyPicker, kNewColor, &amp;myPMColor);
      SetPickerPrompt(gMyPicker, &quot;\pChoose a hightlight color&quot;);
      SetPickerVisibility(gMyPicker, true);
      ShowWindow(gMyDialog);
      DrawDialog(gMyDialog);
   }
   else
      MyDoError(result);
   return result;
}
</PRE>
 <A HREF=#MARKER-9-74>Figure 2-4</A> shows the application-owned dialog box created by <A HREF=#MARKER-9-73>Listing 2-5</A>. Notice the difference between the buttons in this dialog box and those in the system-owned dialog box shown in <A HREF=ACI-31.html#MARKER-9-38>Figure 2-3</A>.<P>
<B>Figure 2-4  <A NAME=MARKER-9-74></A>A movable modal application-owned dialog box<A NAME=MARKER-2-75></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CP-S-04_2.1.jpg">
 <A HREF=#MARKER-9-77>Listing 2-6</A> shows how use a <CODE>PickerDialogInfo</CODE> structure and the <CODE>CreatePickerDialog</CODE> function to create a <A NAME=MARKER-2-76></A>color picker-owned dialog box. <P>
<B>Listing 2-6  <A NAME=MARKER-9-77></A>Creating a color picker-owned dialog box</B><P>
<PRE>
OSErr BuildPickerDialog(void)
{
   PickerDialogInfo  pInfo;
   OSErr             result;

   pInfo.flags = DialogIsMoveable + AppIsColorSyncAware + 
                  CanModifyPalette + CanAnimatePalette;
   pInfo.pickerType = 0L;
   pInfo.mInfo.editMenuID = kMyEditMenuID;
   pInfo.mInfo.cutItem = kMyCutItem;
   pInfo.mInfo.copyItem = kMyCopyItem;
   pInfo.mInfo.pasteItem = kMyPasteItem;
   pInfo.mInfo.clearItem = kMyClearItem;
   pInfo.mInfo.undoItem = kMyUndoItem;
   gMyPicker = nil; 
   result = CreatePickerDialog(&amp;pInfo, &amp;gMyPicker);
   if(result == noErr &amp;&amp; gMyPicker != nil)
   {
      PMColor myPMColor;
      myPMColor.color.rgb = gMyRGBColor;
      myPMColor.profile = 0L;
      SetPickerColor(gMyPicker, kOriginalColor, &amp;myPMColor);
      SetPickerColor(gMyPicker, kNewColor, &amp;myPMColor);
      SetPickerPrompt(gMyPicker, &quot;\pChoose a highlight color:&quot;);
      SetPickerVisibility(gMyPicker, true);
   }
   else
      MyDoError(result);
   return result;
}
</PRE>
 As you can see from <A HREF=#MARKER-9-70>Listing 2-4</A>, <A HREF=#MARKER-9-73>Listing 2-5</A>, and <A HREF=#MARKER-9-77>Listing 2-6</A>, the code to create all three types of dialog boxes is very similar. As you will see in the next few sections, the code to manage them is also very similar.<A NAME=MARKER-2-78></A><P>
<A NAME=HEADING36-29></A>
<H3><A NAME=MARKER-9-79></A>Setting Colors for and Getting Colors From the Color Picker</H3>
 <A NAME=MARKER-2-80></A>Your application uses a color picker to present color choices to the user and to determine which color the user selects. <P>
 Most color pickers present controls that identify color choices. In any case, your application must initially set two default colors: an original color and a new color. The <A NAME=MARKER-2-81></A><B>original color</B> is the color that the user is about to change, and the <A NAME=MARKER-2-82></A><B>new color</B> is the color to which the user changes the original. For custom color picker dialog boxes, you use the <CODE>SetPickerColor</CODE> function to set both colors. (When your application uses the <CODE>PickColor</CODE> function to display the standard dialog box, your application supplies the original color in the field <CODE>theColor</CODE> of the color picker parameter block. This color is used as the initial value for both the original color and the new color.)<P>
 Although the new colors selected by the user may vary widely, the original color remains fixed for comparison. <A HREF=ACI-31.html#MARKER-9-38>Figure 2-3</A> shows how a system-owned dialog box displays both the original and the new colors.<P>
 Suppose, for example, that your paint program uses a floating palette for a color picker. When the user clicks an object, you want the floating palette to show the color of that object. You accomplish this by initially setting the object's current color as both the original color and the new color. As the user changes the color of the object, the original color remains the same while the new color changes. This provides feedback as to what would happen if the user were to undo the color change.<P>
 <A HREF=#MARKER-9-83>Listing 2-7</A> illustrates how to use the <CODE>SetPickerColor</CODE> function to set the original and new colors. <P>
<B>Listing 2-7  <A NAME=MARKER-9-83></A>Setting the original and new colors</B><P>
<PRE>
void MySetPickerToColor(RGBColor *rgb) 
{
   PMColor aColor;

   aColor.color.rgb = *rgb;
   aColor.profile = 0L;
   SetPickerColor(myPicker, kOriginalColor, &amp;aColor);
   SetPickerColor(myPicker, kNewColor, &amp;aColor);
}
</PRE>
 Whenever the user changes the current color, you need to be able to get the new color so that you can update your object accordingly. To determine what color the user is selecting, use the <CODE>GetPickerColor</CODE> function, as illustrated in <A HREF=#MARKER-9-84>Listing 2-8</A>. (Use the <CODE>GetPickerColor</CODE> function for getting colors from color pickers in custom dialog boxes. When your application uses the <CODE>PickColor</CODE> function to display the standard dialog box, and the user clicks the OK button, the Color Picker Manager returns the new color in the field <CODE>theColor</CODE> of the color picker parameter block.)<P>
<B>Listing 2-8  <A NAME=MARKER-9-84></A>Determining the selected color</B><P>
<PRE>
void MyGetCurrentColor(RGBColor *rgb) 
{
   PMColor aColor;

   GetPickerColor(myPicker, kNewColor, &amp;aColor);
   *rgb = aColor.color.rgb;
}
</PRE>
 As shown in <A HREF=ACI-35.html#MARKER-9-60>Listing 2-3 (page 2-11)</A>, you might want to use the colors provided by your color-changed function as temporary colors only. Accordingly, your application should not update its internal data until the user has actually chosen a color (or at least stopped dragging a control). Your application will know this happens when the <CODE>DoPickerEvent</CODE> function, which is described in <A HREF=#MARKER-9-86>"Handling Events in a Color Picker Dialog Box" (page 2-20)</A>, returns the <CODE>kColorChanged</CODE> constant. Your application should then update its internal data.<P>
 As you can see, setting colors for and getting colors from a color picker are simple tasks to perform; complexities arise only if you need to convert a color returned by the color picker from one color space to another. For example, a color picker might return a color using the CMYK color space; if your application uses only RGB colors, then your application must convert the color between the two spaces. See <A HREF=#nonexistent-marker>"Converting Colors Among Color Models" (page 2-52)</A> in <I>Advanced Color Imaging Reference</I> for information about converting between RGB colors and other color types.<P>
 When the <CODE>AppIsColorSyncAware</CODE> flag is not set in the <CODE>SystemDialogInfo</CODE>, <CODE>ApplicationDialogInfo</CODE>, or <CODE>PickerDialogInfo</CODE> structure used to create a dialog box, the Color Picker Manager automatically converts any color it gets back from a color picker into an RGB color.<A NAME=MARKER-2-85></A><P>
<A NAME=HEADING36-43></A>
<H3><A NAME=MARKER-9-86></A>Handling Events in a Color Picker Dialog Box</H3>
 <A NAME=MARKER-2-87></A>When your application receives an event for a color picker dialog box, you use the <CODE>DoPickerEvent</CODE> function to pass the event to the Color Picker Manager. The color picker or the Color Picker Manager either handles the event or returns it to your application for handling.<P>
 When your application uses the <CODE>DoPickerEvent</CODE> function to pass an event to a color picker or the Color Picker Manager for handling, you use an <CODE>EventData</CODE> structure to supply information about the event, and to receive information about how the color picker or the Color Picker Manager handled the event. (The <CODE>DoPickerEvent</CODE> function and the <CODE>EventData</CODE> structure are described in detail in <A HREF=#nonexistent-marker>"Color Picker Manager Reference" (page 2-5)</A> in <I>Advanced Color Imaging Reference</I>.)<P>
 When either the color picker or the Color Picker Manager handles the event, the <CODE>DoPickerEvent</CODE> function returns in the <CODE>action</CODE> field of the <CODE>EventData</CODE> structure one of the following constants describing the event. (These constants are described in <A HREF=#nonexistent-marker>"Picker Actions" (page 2-5)</A> in <I>Advanced Color Imaging Reference</I>.)<P>
<PRE>
enum PickerAction {
   kDidNothing,      /* no action worth reporting */
   kColorChanged,    /* user chose a different color */
   kOkHit,           /* user clicked OK */
   kCancelHit,       /* user clicked Cancel */
   kNewPickerChosen, /* user chose a new color picker */
   kApplItemHit      /* Dialog Manager returned an item in an 
                        application-owned dialog box */
};
typedef short PickerAction;
</PRE>
 Internally, the Color Picker Manager handles the event by calling the Dialog Manager function <CODE>DialogSelect</CODE> and then processing the event from there. If the color picker is in an application-owned dialog box and an application item is selected, the Color Picker Manager returns the <CODE>kApplItemHit</CODE> constant as well as the number of the selected item.<P>
 If your application creates a modeless dialog box for a color picker, you must handle events related to its menus before calling the <CODE>DoPickerEvent</CODE> function. If you've created a modal system-owned dialog box, the Color Picker Manager can handle the Edit menu events for you (as it does when you call <CODE>PickColor</CODE>). However, for other dialog boxes there may be menu items that the Color Picker Manager cannot handle. If you send events relating to these menu items to the Color Picker Manager, it will assume all Edit menu selections are meant for the color picker and will ignore every other menu selection. <A HREF=#MARKER-9-89>"Handling Events in the Edit Menu" (page 2-23)</A> describes how to handle the Edit menu.<P>
 <A HREF=#MARKER-9-88>Listing 2-9</A> illustrates an event loop. This example assumes that the application always handles events related to its menus.<P>
<B>Listing 2-9  <A NAME=MARKER-9-88></A>A sample event loop</B><P>
<PRE>
#define IsMenuKey(x) (x)-&gt;what == keyDown &amp;&amp; (x)-&gt;modifiers &amp; 
                                             cmdKey)
Boolean MySampleDoEvent(EventRecord *event) 
{
   Boolean     handled = false, isMenuEvent = false;
   EventData   pEvent;
   short       inWhere;
   WindowPtr   whichWindow;

   if (event-&gt;what == mouseDown) 
   {
      inWhere = FindWindow(event-&gt;where, &amp;whichWindow);
      if (inWhere == inMenuBar)
         isMenuEvent = true;
   }
   if (isMenuEvent || IsMenuKey(event)) 
   {
      DoMenu(event);
      handled = true;
   }
   /* if the event's not handled yet, pass it to the Color Picker 
      Manager */
   if (!handled) 
   {
      pEvent.event = event;
      pEvent.colorProc = MyColorChangedProc;
      pEvent.colorProcData = 0L;
      DoPickerEvent(myPicker, &amp;pEvent);
      handled = pEvent.handled;
      /* if the color picker handled it, do something with the 
         results */
      if (handled) 
      {
         switch (pEvent.action) {
            case kDidNothing:
               break;
            case kColorChanged:
               UseNewColor(myPicker);
               break;
            case kOKHit:
               UseNewColor(myPicker);
               DisposeColorPicker(myPicker);
               myPicker = nil;
               break;
            case kCancelHit:
               UseOriginalColor(myPicker);
               DisposeColorPicker(myPicker);
               myPicker = nil;
               break;
            case kNewPickerChosen:
               /* nothing to do for this case */
               break;
            case kApplItemHit:
               /* let my app handle the item */
               MyHandleAppItem(pEvent.itemHit);
               break;
      }
   }
   if (!handled) 
   {
      /* the event hasn't been handled; treat it like any normal 
         Macintosh event; if any other dialog boxes are present, 
         call DialogSelect here; if the event is a 
         mouseDown event, my app already called FindWindow */
   }
   return handled;
}
</PRE>
 As shown in this example, if you use a color-changed function (such as the one illustrated in <A HREF=ACI-35.html#MARKER-9-60>Listing 2-3</A>), you should supply it, along with any data it needs, in the <CODE>EventData</CODE> structure that your application passes to the <CODE>DoPickerEvent</CODE> function.<P>
<A NAME=HEADING36-54></A>
<H3><A NAME=MARKER-9-89></A>Handling Events in the Edit Menu</H3>
 Handling events in the Edit menu requires more work than standard menu processing. If an Edit menu choice is for the color picker, you need to set the state of the Edit menu items according to the color picker specifications and, if a menu item is chosen, send the appropriate message to the color picker. To do so, you use two functions, <CODE>GetPickerEditMenuState</CODE> and <CODE>DoPickerEdit</CODE>.<P>
 After you determine that there has been a mouse-down event in the Edit menu (or that the user pressed a keyboard equivalent), you need to determine who owns the Edit menu. <P>
 If the color picker is in a color picker-owned or system-owned dialog box and it's the frontmost window, the color picker owns it. If the color picker is in an application-owned dialog box and it's frontmost, ownership of the Edit menu depends on the current dialog item. The choice really depends on your application. As a general rule, whoever owns the current item owns the Edit menu. If your application uses the <CODE>DoPickerEdit</CODE> function while the current item belongs to your application, <CODE>DoPickerEdit</CODE> implements the standard cut, copy, paste, and clear features for your application. If your application needs to do more than this, it needs to handle the menu itself.<P>
 <A HREF=#MARKER-9-91>Listing 2-10</A> assumes that the owner of the current item owns the Edit menu. The item number for the application's last dialog item is represented by the constant <CODE>kMyLastItem</CODE>. If your application has a system-owned or color picker-owned dialog box, this constant should be set to 0. In an application-owned dialog box, the color picker's items will always be added after your application's, so your item numbers remain the same.<P>
<B>Listing 2-10  <A NAME=MARKER-9-91></A>Handling the Edit menu</B><P>
<PRE>
Boolean MyDoMenu(EventRecord *event) 
{
   long        mChoice;
   EditData    eData;
   EditOperation eOperation;

   /* if the picker is in front and the current edit item is the 
      picker's, set up the Edit menu as the picker wants it */
   if (FrontWindow() == gMyDialog &amp;&amp;
         ((DialogPeek)gMyDialog)-&gt;editField + 1 &gt; kMyLastItem) 
   {
      MenuState   mState;
      MenuHandle  theMenu;

      GetPickerEditMenuState(myPicker, &amp;mState);
      theMenu = GetMenu(kMyEditMenuID);
      if (mState.cutEnabled)
         EnableItem(theMenu, kMyCutItem);
      else
         DisableItem(theMenu, kMyCutItem);
      if (mState.copyEnabled)
         EnableItem(theMenu, kMyCopyItem);
      else
         DisableItem(theMenu, kMyCopyItem);
      if (mState.pasteEnabled)
         EnableItem(theMenu, kMyPasteItem);
      else
         DisableItem(theMenu, kMyPasteItem);
      if( mState.clearEnabled)
         EnableItem(theMenu, kMyClearItem);
      else
         DisableItem(theMenu, kMyClearItem);
      if (mState.undoEnabled) 
      {
         SetItem(theMenu, kMyUndoItem, mState.undoString);
         EnableItem(theMenu, kMyUndoItem);
      }
      else
         DisableItem(theMenu, kMyUndoItem);
   }
   /* pass the event to the Menu Manager */
   if (event-&gt;what == mouseDown)
      mChoice = MenuSelect(event-&gt;where);
   else if (event-&gt; == keyDown)
      mChoice = MenuKey(event-&gt;message);
   /* if not the Edit menu, handle normally */
   if (HiWord(mChoice) != kMyEditMenuID) 
   {
      HandleMenuChoice(mChoice);
      return true;
   }
   switch (LoWord(mChoice)) 
   {
      case kMyCutItem:
         eOperation = kCut;
         break;
      case kMyCopyItem:
         eOperation = kCopy;
         break;
      case kMyPasteItem:
         eOperation = kPaste;
         break;
      case kMyClearItem:
         eOperation = kClear;
         break;
      case kMyUndoItem:
         eOperation = kUndo;
         break;
      default:
         eOperation = -1;
         break;
   }
   if (eOperation &gt;= 0) 
   {
      eData.theEdit = eOperation;
      DoPickerEdit(myPicker, &amp;eData);
      /* this example is simply ignoring the results here */
   }
   HiliteMenu(0);
   return true;
}
</PRE>
 See the chapter "Menu Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for more information about managing menus in your application.<A NAME=MARKER-2-92></A><P>
<A NAME=HEADING36-62></A>
<H3><A NAME=MARKER-9-93></A>Sending Event Forecasters to the Color Picker</H3>
 <A NAME=MARKER-2-94></A>Your application may sometimes need to warn the color picker about a user action that might affect it. For example, if you display a color picker in an application-owned dialog box and the user closes that dialog box, your application might want to check whether the color picker is in a state that can handle this. If the user had just typed some numbers into the color picker that left it in an inconsistent state, it would be helpful if the color picker could warn the user before the user closes it.<P>
 Your application can warn the color picker about potential problems by sending it <B>event forecasters</B>. Event forecasters aren't events in themselves; instead, they are warnings to the color picker. To send event forecasters to the color picker, you use the same function as for regular events--<CODE>DoPickerEvent</CODE>--except that in the <CODE>EventData</CODE> structure that your application passes to <CODE>DoPickerEvent</CODE>, your application sets the <CODE>event</CODE> field to <CODE>nil</CODE> and sets the <CODE>forcast</CODE> field to an appropriate constant from the following list.<P>
<PRE>
enum EventForcasters {
   kNoForcast,    /* no forecast (e.g., an update event) */
   kMenuChoice,   /* this event causes a menu to be chosen */
   kDialogAccept, /* the dialog box will be accepted */
   kDialogCancel, /* the dialog box will be canceled */
   kLeaveFocus,   /* the focus will leave the color picker */
   kPickerSwitch, /* new color picker chosen in More Choices 
                     list */
   kNormalKeyDown,/* a normal key-down event in an edit field */
   kNormalMouseDown/* a normal click in color picker's focus */
};
typedef short EventForcaster;
</PRE>
 The color picker informs your application about whether the color picker is ready for the action to occur by setting the <CODE>handled</CODE> field of the <CODE>EventData</CODE> structure to <CODE>true</CODE> if it's not ready and <CODE>false</CODE> if it is.<P>
 Generally, the only time you need to use event forecasters is when the color picker's dialog box is about to close. If the Color Picker Manager affects the closing (as indicated when it sets the <CODE>action</CODE> field of the <CODE>EventData</CODE> structure to the <CODE>kOKHit</CODE> constant after your application calls <CODE>DoPickerEvent</CODE>), your application doesn't need to warn the color picker because the Color Picker Manager has already done so. However, if the user has just clicked the close box of a window containing an application-owned dialog box or has chosen Close from a menu, you should send an event forecaster to the color picker.<P>
 <A HREF=#MARKER-9-95>Listing 2-11</A> shows an application-defined function called <CODE>CheckIfPickerCanClose</CODE>. If this function returns true, then the color picker can close; otherwise, it can't close for some reason, and you can assume that the color picker has informed the user of the problem.<P>
<B>Listing 2-11  <A NAME=MARKER-9-95></A>Warning the color picker that it's about to be closed</B><P>
<PRE>
Boolean MyCheckIfPickerCanClose() 
{
   EventData pEvent;
   pEvent.event = 0L;   /* make it a forecast event */
   pEvent.forecast = kDialogAccept;
   DoPickerEvent(myPicker, &amp;pEvent);
   return !pEvent.handled;
}
</PRE>
<A NAME=HEADING36-71></A>
<H3>Setting the Destination Profile</H3>
 If you use a color picker to ask the user for a color intended for an output device, and the device has a color-matching profile, your application can hand this profile to the color picker so that it can communicate the profile's information to the user. You do this with the <CODE>SetPickerProfile</CODE> function, as illustrated in <A HREF=#MARKER-9-97>Listing 2-12</A>. Setting a destination profile is optional; the color picker assumes that there's no profile unless your application uses <CODE>SetPickerProfile</CODE> to set one. <P>
<B>Listing 2-12  <A NAME=MARKER-9-97></A>Using the <CODE>SetPickerProfile</CODE> function to set the destination profile</B><P>
<PRE>
void MySetDestinationProfile(CMProfileHandle profile) 
{
   if (SetPickerProfile(myPicker, profile) != noErr)
      MyHandleError();
}
</PRE>
 There's also a matching function, <CODE>GetPickerProfile</CODE>, illustrated in <A HREF=#MARKER-9-98>Listing 2-13</A>, to get the current destination profile from the color picker. <P>
<B>Listing 2-13  <A NAME=MARKER-9-98></A>Using the <CODE>GetPickerProfile</CODE> function to get the destination profile</B><P>
<PRE>
void MyGetDestinationProfile(CMProfileHandle profile) 
{
   if (GetPickerProfile(myPicker, profile) != noErr)
      MyHandleError();
}
</PRE>
 Your application owns the memory of any profiles it gives to or receives from the color picker. When your application sets the destination profile, the color picker makes a copy of the profile handle; when your application gets the destination profile, your application gives the color picker a handle into which it copies the profile data.<A NAME=MARKER-2-99></A><A NAME=MARKER-2-100></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="ACI-35.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-37.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="ACI-3.html">&copy; Apple Computer, Inc.</A><br>13 NOV 1996<P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML> 
