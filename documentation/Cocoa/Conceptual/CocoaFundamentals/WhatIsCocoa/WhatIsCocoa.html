<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Fundamentals Guide: What Is Cocoa?</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="What Is Cocoa?"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002974-CH3" title="What Is Cocoa?"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40002974-CH1-SW1">Cocoa Fundamentals Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CocoaObjects/CocoaObjects.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002974-CH3-SW16" title="What Is Cocoa?"></a><h1>What Is Cocoa?</h1><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_959"></a>Cocoa is an application environment for both the Mac OS X operating system and iPhone OS, the operating system used on multi-touch devices such as iPhone and iPod touch. It consists of a suite of object-oriented software libraries, a runtime, and an integrated development environment. </p><p>This chapter expands on this definition, describing the purpose, capabilities, and components of Cocoa on both platforms. Reading this functional description of Cocoa is an essential first step toward understanding Cocoa as a developer.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW27">The Cocoa Environment</a>
				
			<br/>
			
        
			
			
				<a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW6">Features of a Cocoa Application</a>
				
			<br/>
			
        
			
			
				<a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW30">The Development Environment</a>
				
			<br/>
			
        
			
			
				<a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW10">The Cocoa Frameworks</a>
				
			<br/>
			
        
			
			
				<a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW12">A Bit of History</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002974-CH3-SW27" title="The Cocoa Environment"></a><h2>The Cocoa Environment</h2><p>Cocoa is a set of object-oriented frameworks that provides a runtime environment for applications running on Mac OS X and iPhone OS. It is also part of a development environment that helps you efficiently bring these applications from design stage to deployment. Cocoa is the preeminent application environment for Mac OS X and the <em>only</em> application environment for iPhone OS. (Carbon is an alternative environment on Mac OS X, but it is a compatibility framework with procedural programmatic interface intended to support existing Mac OS X code bases.) Most of the applications you see on Mac OS X and iPhone OS, including Mail and Safari, are Cocoa applications. An integrated development environment called Xcode supports application development for both platforms. The combination of this development environment and Cocoa makes it easy to create a well-factored, full-featured application. </p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW28" title="Introducing Cocoa"></a><h3>Introducing Cocoa</h3><p>As with all application environments, Cocoa presents two faces; it has a runtime aspect and a development aspect. In its runtime aspect, Cocoa applications present the user interface and are tightly integrated with the other visible portions of the operating system; on Mac OS X, these include the Finder, the Dock, and other applications from all environments. </p><p>But it is the development aspect that is the more interesting one to programmers. Cocoa is an integrated suite of object-oriented software components—classes—that enables you to rapidly create robust, full-featured Mac OS X applications. These classes are reusable and adaptable software building blocks; you can use them as-is or extend them for your specific requirements. Cocoa classes exist for just about every conceivable development necessity, from user-interface objects to data formatting, and where a need hasn’t been anticipated, you can easily create a subclass of an existing class that answers that need. </p><p>Cocoa has one of the most distinguished pedigrees of any object-oriented development environment. From its introduction as NeXTSTEP in 1989 to the present day, it has been continually refined and tested (see <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW12">“A Bit of History”</a></span>). Its elegant and powerful design is ideally suited for the rapid development of software of all kinds, not only applications but command-line tools, plug-ins, and various types of bundles. Cocoa gives your application much of its behavior and appearance “for free,” freeing up more of your time to work on those features that are distinctive. (For details on what Cocoa offers, see <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW6">“Features of a Cocoa Application.”</a></span>)</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW58" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;Cocoa for iPhone OS supports only application development and not any other kind of executable.</p></div><p>You may use several <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_960"></a>programming languages when developing Cocoa software, but the essential, required language is <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_961"></a>Objective-C. Objective-C is a superset of <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_962"></a>ANSI C that has been extended with certain syntactical and semantic features (derived from Smalltalk) to support object-oriented programming. The few added conventions are simple and easy to learn and use. Because Objective-C rests on a foundation of ANSI C, you can freely intermix straight C code with Objective-C code. Moreover, your code can call functions defined in non-Cocoa programmatic interfaces, such as the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_963"></a>BSD library interfaces in <code>/usr/include</code>. You can even mix <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_964"></a>C++ code with your Cocoa code and link them into the same executable. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW59" title="Mac OS X Note"></a><p><strong>Mac OS X Note:</strong>&nbsp;On Mac OS X, you can also program in Cocoa using scripting bridges such as <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_965"></a>PyObjC (the Python–Objective-C bridge) and <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_966"></a>RubyCocoa (the Ruby–Cocoa bridge). Both bridged languages let you write Cocoa applications in the respective scripting languages, <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_967"></a>Python and <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_968"></a>Ruby. Both of these are interpreted, interactive, and object-oriented programming languages that make it possible for Python or Ruby objects to message Objective-C objects as if they're Python or Ruby objects, and also for Objective-C objects to message Python or Ruby objects. For more information, see <em><a href="../../RubyPythonCocoa/index.html#//apple_ref/doc/uid/TP40004936" target="_top">Ruby and Python Programming Topics for Mac OS X</a></em>.</p></div><p>The core Cocoa class libraries come packaged in two core frameworks for each platform: <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_969"></a>Foundation and <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_970"></a>Application Kit for Mac OS X and Foundation and UIKit for iPhone OS. As with all frameworks, these contain not only a dynamically sharable library (or sometimes several compatibility versions of libraries), but header files, API documentation, and related resources. The duo of both Application Kit and Foundation and UIKit and Foundation reflect the division of the Cocoa programmatic interfaces into those classes that have some bearing on a graphical user interface and those that don’t. For each platform, its two core frameworks are essential to any Cocoa project whose end product is an application. </p><p>Mac OS X also ships with several other frameworks that publish Cocoa programmatic interfaces, such as the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_971"></a>Core Data framework, the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_972"></a>Screen Saver and <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_973"></a>Address Book frameworks; more Cocoa frameworks will be added to the operating system over time. See <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW10">“The Cocoa Frameworks”</a></span> for further information.</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW21" title="How Cocoa Fits into Mac OS X"></a><h3>How Cocoa Fits into Mac OS X</h3><p><span class="content_text">Figure 1-1</span> shows a simplified diagram of the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_974"></a>Mac OS X system architecture. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW5" title="Figure 1-1Mac OS X architecture&acirc;&#128;&#148;simplified perspective"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Mac OS X architecture—simplified perspective</p><img src = "../Art/osx_functional_A.jpg" alt = "Mac OS X architecture—simplified perspective" ></div><br/><p>This diagram is simple for a purpose: to depict unambiguously to those unfamiliar with Mac OS X some of its major components and dependencies. But in its simplicity it omits important details and blurs others. These details fill in an important part of the picture showing how Cocoa fits into the rest of Mac OS X.</p><p><span class="content_text">Figure 1-2</span> situates Cocoa more accurately in an <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_975"></a><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_976"></a>architectural setting. This diagram shows Mac OS X as a series of software layers going from the foundation of Darwin to the various application environments; the intervening layers represent the system software contained in the two major umbrella frameworks, Core Services and Application Services. The diagram suggests that a component at one layer generally has dependencies on the layer beneath it. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW11" title="Figure 1-2Cocoa in the architecture of Mac OS X"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Cocoa in the architecture of Mac OS X</p><img src = "../Art/osxlayers_A.jpg" alt = "Cocoa in the architecture of Mac OS X" ></div><br/><p>In some ways, this diagram is similar to the previous diagram. For example, the system component that is largely responsible for rendering the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_977"></a>Aqua user interface, <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_978"></a>Quartz (implemented in the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_979"></a>Core Graphics framework), is part of the Application Services layer. And at the base of the architectural stack is Darwin; everything in Mac OS X, including Cocoa, ultimately depends on Darwin to function.</p><p>But if you look closer, at individual or groups of Cocoa classes and at the particular subframeworks of the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_980"></a>umbrella frameworks, you begin to see where Cocoa either has specific dependencies on other parts of Mac OS X or where it exposes underlying technology with its interfaces. <span class="content_text">Figure 1-3</span> charts a few of these dependencies or exposures.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW14" title="Figure 1-3Zooming in on the Cocoa architecture&acirc;&#128;&#148;some major dependencies"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Zooming in on the Cocoa architecture—some major dependencies</p><img src = "../Art/systemlayers3.jpg" alt = "Zooming in on the Cocoa architecture—some major dependencies" ></div><br/><p>Apple has carefully designed Cocoa so that some of its programmatic interfaces give access to the capabilities of underlying technologies that applications typically need. But if you require some capability that is not exposed through the programmatic interfaces of Cocoa, or if you need some finer control of what happens in your application, you may be able to use an underlying framework directly. (A prime example is Core Graphics; by calling its functions or those of <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_981"></a>OpenGL, your code can draw more complex and nuanced images than is possible with the Cocoa drawing methods.) Fortunately, using these lower-level frameworks is not a problem because the programmatic interfaces of most dependent frameworks are written in standard ANSI C, of which Objective-C language is a superset.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW60" title="Note"></a><p><strong>Note:</strong>&nbsp;The intent of this architectural overview is not to itemize every particular dependency or interface that Cocoa has on or to other parts of Mac OS X. Instead, it surveys the more interesting ones in order to give you a general idea of the architectural context of the framework.</p></div><p>The major underlying frameworks on which Cocoa depends or which it exposes through its classes and methods are Core Foundation, Carbon, Core Graphics (Quartz), Launch Services, and Print Core (the printing subsystem): </p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_982"></a>Core Foundation</strong>. Many classes of the Foundation framework are based on equivalent Core Foundation opaque types. This close relationship is what makes “toll-free bridging”—cast-conversion between compatible Core Foundation and Foundation types—possible. Some of the implementation of Core Foundation, in turn, is based on the BSD part of the Darwin layer. </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_983"></a>Carbon</strong>. Cocoa taps into Carbon for some of the services it provides. This is because various Carbon frameworks are situated as system-wide services in the Core Services and Application Services layer. Carbon Core is a particularly important one of these frameworks; for example, it has the File Manager, which Cocoa uses for conversions between various file-system representations.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_984"></a>Core Graphics</strong>. The Cocoa drawing and imaging classes are (quite naturally) closely based on the Core Graphics framework, which implements Quartz and the window server.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_985"></a>Launch Services</strong>. The NSWorkspace class exposes the underlying capabilities of Launch Services. Cocoa also uses the application-registration feature of Launch Services to get the icons associated with applications and documents.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_986"></a>Print Core</strong>. The Cocoa printing classes present an object-oriented interface to the printing subsystem.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW61" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;<em><a href="../../../../MacOSX/Conceptual/OSX_Technology_Overview/index.html#//apple_ref/doc/uid/TP40001067" target="_top">Mac OS X Technology Overview</a></em> gives an overview of the frameworks, services, technologies, and other components of Mac OS X. <em><a href="../../../../UserExperience/Conceptual/AppleHIGuidelines/index.html#//apple_ref/doc/uid/20000957" target="_top">Apple Human Interface Guidelines</a></em> specifies how the Aqua human interface should appear and behave.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW29" title="How Cocoa Fits into iPhone OS"></a><h3>How Cocoa Fits into iPhone OS</h3><p>Although the iPhone OS infrastructure on which Cocoa depends is similar to that for Mac OS X, there are some significant differences. Compare <span class="content_text">Figure 1-4</span>, which depicts the architectural setting of iPhone OS, to the diagram in <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW11">Figure 1-2</a></span>. The iPhone OS diagram also shows the software supporting its platform as a series of layers going from a Core OS foundation to a set of application frameworks, the most critical (for applications) being the UIKit framework. As in the Mac OS X diagram, the iPhone OS diagram has middle layers consisting of core-services frameworks and graphics and audio frameworks and libraries. Here also, a component at one layer often has dependencies on the layer beneath it. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW19" title="Figure 1-4Cocoa in the architecture of iPhone OS"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>Cocoa in the architecture of iPhone OS</p><img src = "../Art/architecture_stack.jpg" alt = "Cocoa in the architecture of Aspen" ></div><br/><p>Generally, the system libraries and frameworks of iPhone OS that ultimately support UIKit are a subset of the libraries and frameworks on Mac OS X. For example, there is no Carbon application environment on iPhone OS, there is no command-line access (the BSD environment), there are no printing frameworks and services, and QuickTime is absent from the platform. However, because of the nature of the devices supported by iPhone OS, there are some frameworks, both public and private, that are specific to iPhone OS. </p><p>The following summarizes some of the frameworks found at each layer of the iPhone OS stack, starting from the foundation layer.</p><ul class="spaceabove"><li class="li"><p><strong>Core OS</strong>—This level contains the kernel, the file system, networking infrastructure, security, power management, and a number of device drivers. It also has the libSystem library, which supports the POSIX/BSD 4.4/C99 API specifications and includes system-level APIs for many services.</p></li><li class="li"><p><strong>Core Services</strong>—The frameworks in this layer provide core services, such as string manipulation, collection management, networking, URL utilities, contact management, and preferences.</p><p>This layer includes Core Foundation, a framework that provides abstractions for common data types (such as strings and collections); they allow a large degree of integration between object-oriented and procedural code.</p></li><li class="li"><p><strong>Media</strong>—The frameworks and services in this layer depend on the Core Services layer and provide graphical and multimedia services to the Cocoa Touch layer. They include Core Graphics, OpenGL ES, Core Animation, Core Audio, and video playback.</p></li><li class="li"><p><strong>Cocoa Touch</strong>—The frameworks in this layer directly support applications based on iPhone OS. They include two Objective-C frameworks that are particularly important for developing applications for iPhone OS:</p><ul class="nested"><li class="nested li"><p>The UIKit framework provides the objects an application displays in its user interface and defines the structure for application behavior, including event handling and drawing. For a description of UIKit, see <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW22">“UIKit (iPhone OS).”</a></span> </p></li><li class="nested li"><p>The Foundation framework defines the basic behavior of objects, establishes mechanisms for their management, and provides objects for primitive data types, collections, and operating-system services. Foundation is essentially an object-oriented cover to the Core Foundation framework; see <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW20">“Foundation”</a></span> for a discussion of the Foundation framework.</p></li></ul></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW83" title="Note"></a><p><strong>Note:</strong>&nbsp;For detailed descriptions of the components in the layers of iPhone OS, see <em><!--a target="_top" -->iPhone OS Technology Overview<!--/a--></em>.</p></div><p>As with Cocoa on Mac OS X, the programmatic interfaces of Cocoa on iPhone OS give your applications access to the capabilities of underlying technologies. Usually there will be a Foundation or UIKit method or function that can tap into a lower-level framework to do what you want. But, as with Cocoa on Mac OS X, if you require some capability that is not exposed through API, or if you need some finer control of what happens in your application, you may choose to use an underlying framework directly. For example, UIKit uses the Web Kit to draw text; however, you may decide to use Core Graphics to draw text because that gives you the control you need for a particular task. Again, using these lower-level frameworks is not a problem because the programmatic interfaces of most dependent frameworks are written in standard ANSI C, of which Objective-C language is a superset.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW62" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To learn more about the frameworks, services, and other aspects of the iPhone OS platform, see <em><!--a target="_top" -->iPhone OS Technology Overview<!--/a--></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW6" title="Features of a Cocoa Application"></a><h2>Features of a Cocoa Application</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_987"></a>On Mac OS X it is possible to create a Cocoa application without adding a single line of code. Make a new Cocoa application project using Xcode and then build the project. That’s it. Of course, this application won’t do much, or at least much that’s interesting. But this extremely simple application still launches when double-clicked, displays its icon in the Dock, displays its main menu and window (entitled “Window”), hides itself on command, behaves nicely with other running applications, and quits on command. You can move, resize, minimize, and close the window. You can even print the emptiness contained by the window. </p><p>Imagine what you could do with a little code. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW63" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;The features and behavior of an application running on iPhone OS are considerably different from a Mac OS X application, largely because it runs in a more constrained environment. For discussions of application capabilities and constraints on iPhone OS, see <em><!--a target="_top" -->iPhone Application Programming Guide<!--/a--></em>.</p></div><p>In terms of programming effort, Cocoa gives you, the developer, much that is free and much that is low-cost. Of course, to become a productive Cocoa developer means becoming familiar with possibly new concepts, design patterns, programming interfaces, and development tools, and this effort is not negligible. But familiarity yields greater productivity. Programming becomes largely an exercise in assembling the programmatic components that Cocoa provides along with the custom objects and code that define your program’s particular logic, then fitting the whole assemblage together.</p><p>What follows is a short list of how Cocoa adds value to an application with only a little (and sometimes no) effort on your part:</p><ul class="ul"><li class="li"><p><strong>Basic application framework</strong>—Cocoa provides the infrastructure for event-driven behavior and for application-, window-, and (in the case of Mac OS X) workspace-management. In most cases, you won’t have to handle events directly or send any drawing commands to a rendering library.</p></li><li class="li"><p><strong>User-interface objects</strong>—Cocoa offers a rich collection of ready-made objects for your application’s user interface. Most of these objects are available on palettes of Interface Builder, a development application for creating user interfaces; you simply drag an object from a palette onto the surface of your interface, configure its attributes, and connect it to other objects. (And, of course, you can always instantiate, configure, and connect these objects programmatically.) Here is a sampling of Cocoa <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_988"></a>user-interface objects:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><td  scope="row"><p>windows</p></td><td ><p>text fields</p></td><td ><p>image views</p></td><td ><p>date pickers</p></td></tr><tr><td  scope="row"><p>sheets and dialogs</p></td><td ><p>segmented controls</p></td><td ><p>table views</p></td><td ><p>progress indicators</p></td></tr><tr><td  scope="row"><p>buttons</p></td><td ><p>sliders</p></td><td ><p>radio buttons (Mac OS X)</p></td><td ><p>color wells (Mac OS X)</p></td></tr><tr><td  scope="row"><p>drawers (Mac OS X)</p></td><td ><p>page controls (iPhone OS)</p></td><td ><p>navigation bars (iPhone OS)</p></td><td ><p>switch controls (iPhone OS)</p></td></tr></table></div><p>Cocoa on Mac OS X also features technologies that support user interfaces, including those that promote accessibility, perform validation, and facilitate the connections between objects in the user interface and custom objects. </p></li><li class="li"><p><strong>Drawing and imaging</strong>—Cocoa enables efficient <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_989"></a>drawing of custom views with a framework for locking graphical focus and marking views (or portions of views) as “dirty.” On Mac OS X, it includes programmatic tools for drawing Bezier paths, performing affine transforms, compositing images, and creating various representations of images.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW64" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;The UIKit framework provides rudimentary support for drawing rectangles and lines. For drawing of any greater complexity, applications must use the facilities of Core Graphics framework or the OpenGLES framework.</p></div></li><li class="li"><p><strong>System interaction</strong>—On Mac OS X, Cocoa gives your application ways to interact with (and use the services of) the file system, the workspace, and other applications. On iPhone OS, you can pass system applications URLs to have them handle the referenced resource (for example, email or websites).</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_990"></a>Performance</strong>—To enhance the performance of your application, Cocoa provides programmatic support for multithreading, idle-time processing, lazy loading of resources, memory management, and run-loop manipulation.</p></li><li class="li"><p><strong>Internationalization</strong>—Cocoa provides a rich architecture for <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_991"></a>internationalizing applications, making it possible for you to support localized resources such as text, images, and even user interfaces. The Cocoa approach is based on users’ lists of preferred languages and puts localized resources in bundles of the application. Based on the settings it finds, Cocoa automatically selects the localized resource that best matches the user’s preferences. It also provides tools and programmatic interfaces for generating and accessing localized strings. Moreover, text manipulation in Cocoa is based on Unicode by default, and is thus an asset for internationalization.</p></li><li class="li"><p><strong>Text</strong>—On Mac OS X, Cocoa provides a sophisticated <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_992"></a>text system that allows you to do things with text ranging from the simple (for example, displaying a text view with editable text) to the more complex, such as control of kerning and ligatures, spell checking, and embedding images. On iPhone OS, Cocoa has no native text system (it uses Web Kit for string drawing) and text capabilities are more limited.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_993"></a>Preferences</strong>—The <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_994"></a>user defaults system is based on a system-wide database in which you can store global and application-specific preferences. The procedure for specifying application preferences is different on the two platforms.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_995"></a>Networking</strong>—Cocoa also offers programmatic interfaces for communicating with servers using standard Internet protocols, communicating via sockets, and incorporating Bonjour capabilities in your application.</p><p>On Mac OS X, Cocoa includes a <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_996"></a>distributed objects architecture that allows one Cocoa process to communicate with another process on the same computer or on a different one.</p></li></ul><p>Cocoa on Mac OS X has several other additional features:</p><ul class="ul"><li class="li"><p><strong>Data exchange</strong>—Cocoa simplifies the exchange of data within an application and between applications using the copy-paste and drag-and-drop models and through the Services menu.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_997"></a>Document-based applications</strong>—Cocoa specifies an <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_998"></a>architecture for applications composed of a potentially unlimited number of documents, with each contained in its own window (a word processor, for example). Indeed, if you choose the “Document-based application” project type, many of the components of this sort of application are created for you.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_999"></a>Scripting</strong>— Through <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1000"></a>application scriptability information and a suite of supporting Cocoa classes, you can make your application scriptable; that is, it can respond to commands emitted by AppleScript scripts. Applications can also execute scripts or use individual Apple events to send commands to, and receive data from, other applications. As a result, every scriptable application can supply services to both users and other applications.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1001"></a>Undo management</strong>—You can register user actions that occur with an undo manager, and it will take care of undoing them (and redoing them) when users choose the appropriate menu items. The manager maintains undo and redo operations on separate stacks.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1002"></a>Printing</strong>—In a fashion similar to the text system, the printing architecture lets you print documents and other application content along a range of control and sophistication. At the simplest level, you can print the contents of any view by default. At a more complicated level, you can define the content and format of printed content, control how a print job is performed, and add an accessory view to the print panel.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1003"></a>Multimedia</strong>—On Mac OS X, Cocoa provides support for QuickTime video and basic audio capabilities.<a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1004"></a> </p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH3-SW30" title="The Development Environment"></a><h2>The Development Environment</h2><p>To say that Cocoa has its own <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1005"></a>development environment wouldn’t quite be an accurate statement. For one thing, programmers can use Apple’s major development applications, Xcode and Interface Builder, to develop software for Mac OS X applications based on Carbon. Moreover, it is possible to develop Cocoa applications without using Xcode and Interface Builder at all. For example, you could write code using a text editor such as Emacs, build the application from the command line using make files, and debug the application from the command line using the <code>gdb</code> debugger.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW65" title="Note"></a><p><strong>Note:</strong>&nbsp;"Xcode” is sometimes used to refer to the complete suite of development tools and frameworks, and other times specifically to the IDE application that allows you to manage projects and build executable code. </p></div><p>But Xcode and Interface Builder are the preferred applications to use for developing Cocoa software. Their origins coincide with the origins of Cocoa itself, and consequently there is a high degree of compatibility between tools and frameworks. Together, Xcode and Interface Builder make it extraordinarily easy to design, manage, build, and debug Cocoa software projects. </p><p>When you install the development tools and documentation, you may select the installation location. Traditionally that location has been <code>/Developer</code>, but it can be anywhere in the file system you wish. As a shorthand for designating this installation location, the documentation uses <code>&lt;Xcode></code>. Thus, the development applications are installed in <code>&lt;Xcode>/Applications</code>. </p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW31" title="Platform SDKs"></a><h3>Platform SDKs</h3><p>Beginning with Xcode 3.1 and the introduction of iPhone OS, when you create a software project you must choose a platform SDK. The SDK enables you to build an executable that is targeted for a particular release of a particular operating system, or platform: Mac OS X or iPhone OS. </p><p>The platform SDK contains everything that is required for developing software for a given platform and operating-system release. A Mac OS X SDK consists of frameworks, libraries, header files, and system tools. The SDK for iPhone OS has the same components, but includes a platform-specific compiler and other tools. There is also a separate SDK for the Simulator environment for iPhone OS (see <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW23">“The iPhone OS Simulator”</a></span>). All SDKs include build settings and project templates appropriate to their platform.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW66" title="Further reading"></a><p><strong>Further reading:</strong>&nbsp;For more on platform SDKs, see <em><a href="../../../../DeveloperTools/Conceptual/Xcode_Overview/Contents/Resources/en.lproj/index.html#//apple_ref/doc/uid/TP40007654" target="_top">Xcode Overview</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW32" title="Overview of Development Workflows"></a><h3>Overview of Development Workflows</h3><p>Application development differs for Mac OS X and iPhone OS, not only the tools used but in the development workflow. On Mac OS X, the typical development workflow is the following: </p><ol class="ol"><li class="li"><p>In Xcode, create a project using a template from the Mac OS X SDK.</p></li><li class="li"><p>Write code and, using Interface Builder, construct your application’s user interface.</p></li><li class="li"><p>Define the targets and executable environment for your project.</p></li><li class="li"><p>Test and debug the application using the Xcode debugging facilities.</p><p>As part of debugging, you can check the system logs in the Console window.</p></li><li class="li"><p>Measure application performance using one or more of the available performance tools.</p></li></ol><p>For iPhone OS development, the workflow when developing an application is a bit more complex. Before you can develop for iPhone OS, you must register as a developer for the platform. Thereafter, building an application that’s ready to deploy should go through the following steps:</p><ol class="ol"><li class="li"><p>Configure the remote device. This results in the required tools, frameworks, and other components being installed on the device.</p></li><li class="li"><p>In Xcode, create a project using a template from the iPhone OS SDK.</p></li><li class="li"><p>Write code, and construct your application’s user interface.</p></li><li class="li"><p>Define the targets and executable environment for the project.</p></li><li class="li"><p>Build the application (locally).</p></li><li class="li"><p>Test and debug the application, either in the iPhone OS Simulator or remotely in the device. (If remotely, your debug executable is downloaded to the device.)</p><p>As you debug, you can check the system logs for the device in the Console window.</p></li><li class="li"><p>Measure application performance using one or more of the available performance tools.</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW67" title="Further reading"></a><p><strong>Further reading:</strong>&nbsp;For more on the development workflow in iPhone OS, see <em><!--a target="_top" -->iPhone Development Guide<!--/a--></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW33" title="Xcode"></a><h3>Xcode</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1006"></a>Xcode is the engine that powers Apple’s integrated development environment (IDE) for Mac OS X and iPhone OS. It is also an application that takes care of most project details from inception to deployment. It allows you to</p><ul class="spaceabove"><li class="li"><p>Create and manage projects, including specifying platforms, target requirements, dependencies, and build configurations.</p></li><li class="li"><p>Write source code in editors with features such as syntax coloring and automatic indenting.</p></li><li class="li"><p>Navigate and search through the components of a project, including header files and documentation.</p></li><li class="li"><p>Build the project.</p></li><li class="li"><p>Debug the project locally, in the iPhone OS simulator, or remotely, in a graphical source-level debugger.</p></li></ul><p>Xcode builds projects from source code written in C, C++, Objective-C, and Objective-C++. It generates executables of all supported types on Mac OS X, including command-line tools, frameworks, plug-ins, kernel extensions, bundles, and applications. (For iPhone OS, only application executables are possible.) Xcode permits almost unlimited customization of build and debugging tools, executable packaging (including information property lists and localized bundles), build processes (including copy-file, script-file, and other build phases), and the user interface (including detached and multi-view code editors). It also supports several <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1007"></a>source-code management systems—namely CVS, Subversion and Perforce—allowing you to add files to a repository, commit changes, get updated versions, and compare versions.</p><p><span class="content_text">Figure 1-5</span> shows an example of a project in Xcode.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW2" title="Figure 1-5The TextEdit example project in Xcode"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>The TextEdit example project in Xcode</p><img src = "../Art/xcode.jpg" alt = "The TextEdit example project in Xcode" ></div><br/><p>Xcode is especially suited for Cocoa development. When you create a project, Xcode sets up your initial development environment using project templates corresponding to Cocoa project types: application, document-based application, Core Data application, tool, bundle, framework, and others. For compiling Cocoa software for Mac OS X, Xcode uses the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1008"></a>GNU C compiler (<code><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1009"></a>gcc</code>), and for debugging that software, it uses the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1010"></a>GNU source-level debugger (<code><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1011"></a>gdb</code>). Both <code>gcc</code> and <code>gdb</code> have been used in Cocoa development since Cocoa was NeXTSTEP (see <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW12">“A Bit of History”</a></span>), and over the years have been refined, extended, and tuned to support the compilation and debugging of Cocoa binaries. </p><p>Xcode is well integrated with the other major development application, Interface Builder. See <span class="content_text">“Interface Builder”</span> (below) for details.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW68" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;<em>Xcode Overview</em> gives an overview of Xcode and provides links to additional development-tools documentation.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW18" title="Interface Builder"></a><h3>Interface Builder</h3><p>The second major development application for Cocoa projects is <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1012"></a>Interface Builder. As its name suggests, Interface Builder is a graphical tool for creating user interfaces. Interface Builder has been around almost since the inception of Cocoa as <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1013"></a>NeXTSTEP. Not surprisingly, its integration with Cocoa is airtight. Moreover, you can also use it to create user interfaces for Carbon applications running on Mac OS X.</p><p>Interface Builder (version 3.0) is centered around four main design elements:</p><ul class="spaceabove"><li class="li"><p><strong>Nib files</strong>. A <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1014"></a>nib file is actually a file wrapper (an opaque directory) that contains the objects appearing on a user interface in an archived form. Essentially, this archive is an object graph that contains information on each object, including its size and location, on the connections between objects, and on proxy references for custom classes. When you create and save a user interface in Interface Builder, all information necessary to re-create the interface is stored in the nib file. </p><p>Nib files offer a way to easily localize user interfaces. Interface Builder stores a nib file in a localized directory inside a Cocoa project; when that project is built, the nib file is copied to a corresponding localized directory in the created bundle. </p><p>Interface Builder presents the contents of a nib file in a <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1015"></a>nib document window (also called a <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1016"></a>nib file window). The nib document window gives you access to the important objects in a nib file, especially top-level objects such as windows, menus, and controller objects that have no parent in their object graph. (Controller objects mediate between user-interface objects and the model objects that represent application data; they also provide overall management for an application.)</p><p><span class="content_text">Figure 1-6</span> shows a nib file opened in Interface Builder and displayed in a nib document window, along with supporting windows.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW4" title="Figure 1-6The TextEdit Document Properties window in Interface Builder"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>The TextEdit Document Properties window in Interface Builder</p><img src = "../Art/ib3_2.jpg" alt = "The TextEdit Document Properties window in Interface Builder" ></div></li><li class="li"><p><strong>Object library</strong>. The Library window of Interface Builder <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1017"></a> contains objects that you can place on a user interface. They range from typical UI objects—for example, windows, controls, menus, text views, and outline views—to controller objects, custom view objects, and framework-specific objects, such as the Image Kit browser view. The Library groups the objects by categories and lets you browse through them and search for specific objects. When an object is dragged from the Library onto an interface, Interface Builder instantiates a default instance of that object; You can resize, configure, and connect the object to other objects using the Inspector window (or, simply, the inspector). </p></li><li class="li"><p><strong>Inspector</strong>. Interface Builder has an <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1018"></a>Inspector window (or simply, the inspector) for objects on a user interface. The inspector has a number of selectable panes for setting the initial runtime configuration of objects (although size and some attributes can be set by direct manipulation). The inspector in <span class="content_text">Figure 1-6</span> shows the primary attributes for a text field; note that different collapsible slices of the pane reveal attributes at various levels of the inheritance hierarchy (text field, control, and view). In addition to primary attributes and size, the inspector features panes for animation effects, AppleScript event handlers, and bindings and target-action connections between objects</p></li><li class="li"><p><strong>Connections panel</strong> <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1019"></a>. The connections panel is a context-sensitive display that shows the current outlet and action connections for a selected object and lets you manage those connections. To get the connections panel to appear, right-click on the target object (Control-click on single-button mice). <span class="content_text">Figure 1-7</span> shows what the connections panel looks like.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW17" title="Figure 1-7The Interface Builder connections panel"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>The Interface Builder connections panel</p><img src = "../Art/outlets1.jpg" alt = "The Interface Builder connections panel" ></div></li></ul><p>Interface Builder uses momentary blue lines to show the compliance of each positioned object, when moved or resized, to the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1020"></a>Aqua human interface guidelines. This compliance includes recommended size, alignment, and position relative to other objects on the user interface and to the boundaries of the window.</p><p>Interface Builder is tightly integrated with Xcode. It “knows” about the outlets, actions, and bindable properties of your custom classes. When you add, remove, or modify any of these things, Interface Builder detects those changes and updates its presentation of them.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW69" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For further information on Interface Builder, see <em><a href="../../../../DeveloperTools/Conceptual/IB_UserGuide/index.html#//apple_ref/doc/uid/TP40005344" target="_top">Interface Builder User Guide</a></em>. In addition, <span class="content_text"><a href="../CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW46">“Nib Files”</a></span> gives more information about nib files and their use in an application. Also refer to <span class="content_text"><a href="../CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW15">“Communicating With Objects”</a></span> for overviews of outlets, the target-action mechanism, and the Cocoa bindings technology.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW23" title="The iPhone OS Simulator"></a><h3>The iPhone OS Simulator</h3><p>For iPhone OS projects, you can select the iPhone OS Simulator as the platform SDK for the project. When you build and run the project, Xcode runs the Simulator, which presents your application as it would appear on the device and allows you to manipulate parts of the user interface. You can use the Simulator to help you debug the application prior to loading it onto the device.</p><p>You should always perform the final phase of debugging on the device. The Simulator does not perfectly simulate the device. For example, you must use the mouse pointer instead of finger touches, and so manipulations of the interface required multiple fingers are not possible. In addition, the Simulator does not use versions of the OpenGL framework that are specific to iPhone OS, and it uses the Mac OS X versions of the Foundation, Core Foundation, and CFNetwork frameworks, as well as the Mac OS X version of libSystem.</p><p>More importantly, you should not assume that the performance of your application on the Simulator is the same as it would be on the device. The Simulator is essentially running your iPhone application as a "guest” Mac OS X application. As such, it has a 4GB memory partition and swap space available to it as it runs on a processor that is more powerful than the one on the device.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW70" title="Further reading"></a><p><strong>Further reading:</strong>&nbsp;For more on the Simulator, see <em><!--a target="_top" -->iPhone Development Guide<!--/a--></em>. </p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW34" title="Performance Applications and Tools"></a><h3>Performance Applications and Tools</h3><p>Although Xcode and Interface Builder are the major tools you use to develop Cocoa applications, there are dozens of other applications at your disposal. Many of these tools are performance applications.</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW35" title="Instruments"></a><h4>Instruments</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1021"></a>Instruments is an application introduced in Xcode 3.0 that lets you run multiple performance-testing tools simultaneously and view the results in a timeline-based graphical presentation.  It can show you CPU usage, disk reads and writes, memory statistics, thread activity, garbage collection, network statistics, directory and file usage, and other measurements—individually or in different combinations—in the form of graphs tied to time. This simultaneous presentation of instrumentation data helps you to discover the relationships between what is being measured.  It also displays the specific data behind the graphs. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW71" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;See the <em><a href="../../../../DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" target="_top">Instruments User Guide</a></em> for complete information about the Instruments application.</p></div><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW36" title="Figure 1-8The Instruments application"></a><p><strong>Figure 1-8&nbsp;&nbsp;</strong>The Instruments application</p><img src = "../Art/instruments_window.jpg" alt = "The Instruments application" ></div><br/><a name="//apple_ref/doc/uid/TP40002974-CH3-SW37" title="Shark"></a><h4>Shark</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1022"></a>Shark is a performance-analysis application that creates a time-based profile of your program’s execution; over a given period it traces function calls and graphs memory allocations. You can use Shark to track information for a single program or for the entire system, which on Mac OS X includes kernel components such as drivers and kernel extensions. Shark also monitors file-system calls, traces system calls and memory allocations, performs static analyses of your code, and gathers information about cache misses, page faults, and other system metrics. Shark supports the analysis of code written in C, Objective-C, C++, and other languages.</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW38" title="Other Performance Applications (Mac OS X)"></a><h4>Other Performance Applications (Mac OS X)</h4><p>Many <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1023"></a><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1024"></a>applications are used in measuring and analyzing aspects of a Mac OS X program’s performance. They are located in <code>&lt;Xcode>/Applications/Performance Tools</code>. </p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1025"></a>Thread Viewer</strong> displays activity among a process’s threads. It shows time lines of activity on each thread, which is color-coded with the action. By clicking a time line, you can get a sample backtrace of activity at that point.</p></li><li class="li"><p><strong>BigTop</strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1026"></a> graphs performance trends over time, providing a real-time display of memory usage, page faults, CPU usage, and other data.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1027"></a>Spin Control</strong> automatically samples unresponsive applications. You leave Spin Control running in the background while you launch and test your applications. If applications become unresponsive to the point where the spinning cursor appears, Spin Control automatically samples your application to gather information about what your application was doing during that time.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1028"></a>MallocDebug</strong> shows all currently allocated blocks of memory in your program, organized by the call stack at the time of allocation. At a glance you can see how much allocated memory your application consumes, where that memory was allocated from, and which functions allocated large amounts of memory. MallocDebug can also find allocated memory that is not referenced elsewhere in the program, thus helping you find leaks and track down exactly where the memory was allocated.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1029"></a>QuartzDebug</strong> is a tool to help you debug how your application displays itself. It is especially useful for applications that do significant amounts of drawing and imaging. QuartzDebug has several debugging options, including the following: </p><ul class="nested"><li class="nested li"><p>Auto-flush drawing, which flushes the contents of graphics contexts after each drawing operation)</p></li><li class="nested li"><p>A mode that paints regions of the screen in yellow just before they’re updated</p></li><li class="nested li"><p>An option that takes a static snapshot of the system-wide window list, giving the owner of each window and how much memory each window consumes. </p></li></ul></li></ul><p>For performance analysis, you can also use command-line tools such as:</p><ul class="spaceabove"><li class="li"><p><code>top</code>, which shows a periodically sampled set of statistics on currently running processes</p></li><li class="li"><p><code>gprof</code>, which produces an execution profile of a program</p></li><li class="li"><p><code>fs_usage</code>, which displays file-system access statistics</p></li></ul><p>Many other command-line tools for performance analysis and other development tasks are available. Some are located in <code>/usr/bin</code> and <code>/usr/sbin</code>, and some Apple-developed command-line tools are installed in <code>&lt;Xcode>/Tools</code>. For many of these tools you can consult their manual page for usage information. (To do this, either choose Help > Open man page in Xcode or type <code>man</code> followed by the name of the tool in a Terminal shell.)</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW72" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For more on the performance tools and applications you can use in Cocoa application development, as well as information on concepts, techniques, guidelines, and strategy related to performance, see <em><a href="../../../../Performance/Conceptual/PerformanceOverview/index.html#//apple_ref/doc/uid/TP40001410" target="_top">Performance Overview</a></em>. <em><a href="../../CocoaPerformance/index.html#//apple_ref/doc/uid/TP40001448" target="_top">Cocoa Performance Guidelines</a></em> covers the performance guidelines for Cocoa.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW39" title="AppleScript Studio (Mac OS X)"></a><h3>AppleScript Studio (Mac OS X)</h3><p>A defining feature of the Mac OS for years has been the capability for users to control applications with scripts written in the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1030"></a>AppleScript language. Many users find this feature indispensable, for it allows them to string together complicated series of related operations involving multiple applications. AppleScript capabilities have been carried forward into Mac OS X. AppleScript Studio is a development technology for creating Cocoa applications that use AppleScript scripts to control complex user interfaces. </p><p>AppleScript Studio combines elements from AppleScript, Xcode, Interface Builder, and Cocoa to provide a sophisticated environment for creating AppleScript solutions. It allows you to build applications that can do the following:</p><ul class="spaceabove"><li class="li"><p>Execute AppleScript scripts.</p></li><li class="li"><p>Control the user interface of the application.</p></li><li class="li"><p>Control scriptable applications or scriptable parts of the operating system.</p></li></ul><p>Because AppleScript Studio integrates AppleScript with Xcode, Interface Builder, and Cocoa, scripters can take advantage of their particular strengths and capabilities. They can drag a rich set of user-interface objects off Interface Builder palettes and customize them to their liking. They get built-in support for the Aqua human interface guidelines. And they are able to build and maintain complex projects with multiple targets and build steps. </p><p>The development environment makes possible scripting capabilities that go well beyond those available in the Script Editor application traditionally used for creating AppleScript scripts. These include:</p><ul class="spaceabove"><li class="li"><p>creation of arbitrarily large scripts</p></li><li class="li"><p>search and replace in scripts</p></li><li class="li"><p>single-step script debugging with variable execution</p></li><li class="li"><p>easy access to handlers and properties in scripts</p></li><li class="li"><p>a flexible dictionary viewer for working with application scripting terminologies</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW73" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For more information, see the <em><a href="../../../../AppleScript/Conceptual/StudioBuildingApps/index.html#//apple_ref/doc/uid/TP30000889" target="_top">AppleScript Studio Programming Guide</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW10" title="The Cocoa Frameworks"></a><h2>The Cocoa Frameworks</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1031"></a>What makes a program a Cocoa program? It’s not really the language, because you can use a variety of languages in Cocoa development. It’s not the development tools, because you could create a Cocoa application from the command line (although that would be a complex, time-consuming task). No, what all Cocoa programs have in common—what makes them distinctive—is that they are composed of objects that inherit ultimately from the root class, <code>NSObject</code>, and that are ultimately based upon the Objective-C runtime. This statement is also true of all Cocoa frameworks.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW74" title="Note"></a><p><strong>Note:</strong>&nbsp;That statement also needs to be qualified a bit. First, the Foundation framework supplies another root class, <code>NSProxy</code>; however, <code>NSProxy</code> is rarely used in Cocoa programming. Second, you could create your own root class, but this would be a lot of work (entailing the writing of code that interacts with the Objective-C runtime) and probably not worth your time.</p></div><p>On any system there are many Cocoa frameworks, and Apple and third-party vendors are releasing more frameworks all the time. Despite this abundance of Cocoa frameworks, two of them stand out on each platform as core frameworks: </p><ul class="ul"><li class="li"><p>On Mac OS X: Foundation and Application Kit</p></li><li class="li"><p>On iPhone OS: Foundation and UIKit</p></li></ul><p>The Foundation, Application Kit, and UIKit frameworks are essential to Cocoa application development, and all other frameworks are secondary and elective. You cannot develop a Cocoa application for Mac OS X unless you link against (and use the classes of) the Application Kit, and you cannot develop a Cocoa application for iPhone OS unless you link against (and use the classes of) UIKit. Moreover, you cannot develop Cocoa software of any kind unless you link against and use the classes of the Foundation framework. (Linking against the right frameworks on Mac OS X happens automatically when you link against the Cocoa umbrella framework.) Classes, functions, data types, and constants in Foundation and the Application Kit have a prefix of “NS”; classes, functions, data types, and constants in UIKit have a prefix of “UI”.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW75" title="Note"></a><p><strong>Note:</strong>&nbsp;In Mac OS X version 10.5 the Cocoa frameworks have been ported to support 64-bit addressing. iPhone OS also supports 64-bit addressing. As part of this effort, various general changes have been made to the Cocoa API, most significantly the introduction of the <code>NSInteger</code> and <code>NSUInteger</code> types (replacing <code>int</code> and <code>unsigned int</code> where appropriate) and the <code>CGFloat</code> type (replacing most instances of <code>float</code>). Most Cocoa applications have no immediate need to make the transition to 64-bit, but for those that do, porting tools and guidelines are available. <em><a href="../../Cocoa64BitGuide/index.html#//apple_ref/doc/uid/TP40004247" target="_top">64-Bit Transition Guide for Cocoa</a></em> discusses these matters in detail.</p></div><p>The Cocoa frameworks handle many low-level tasks for you. For example, classes that store and manipulate integer and floating-point values automatically handle the endianness of those values for you.</p><p>The following sections survey the features and classes of the three core Cocoa frameworks and briefly describe some of the secondary frameworks. To make these large frameworks more approachable, the introductions to the Foundation, Application Kit, and UIKit frameworks break down the dozens of classes in each hierarchy into functional groupings. Although these groupings have a strong logical basis, one can plausibly group classes in other ways. </p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW20" title="Foundation"></a><h3>Foundation</h3><p>The <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1032"></a>Foundation framework defines a base layer of classes that can be used for any type of Cocoa program. The criterion separating the classes in Foundation from those in the Application Kit is the user interface. If an object doesn’t either appear in a user interface or isn’t <em>exclusively</em> used to support a user interface, then its class belongs in Foundation. You can create Cocoa programs that use Foundation and no other framework; examples of these are command-line tools and Internet servers. </p><p>The Foundation framework was designed with certain goals in mind:</p><ul class="spaceabove"><li class="li"><p>Define basic object behavior and introduce consistent conventions for such things as <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1033"></a>memory management, object mutability, and notifications.</p></li><li class="li"><p>Support internationalization and localization with (among other things) bundle technology and Unicode strings.</p></li><li class="li"><p>Support object persistence.</p></li><li class="li"><p>Support object distribution.</p></li><li class="li"><p>Provide some measure of operating-system independence to support portability.</p></li><li class="li"><p>Provide object wrappers or equivalents for programmatic primitives, such as numeric values, strings, and collections. Also include utility classes for accessing underlying system entities and services, such as ports, threads, and file systems.</p></li></ul><p>Cocoa applications, which by definition link either against the Application Kit or the UIKit frameworks, invariably must link against the Foundation framework as well. The class hierarchies share the same root class, <code>NSObject</code>, and many if not most of the Application Kit and UIKit methods and functions have Foundation objects as parameters or return values. Some Foundation classes may seem designed for applications—<code>NSUndoManager</code> and <code>NSUserDefaults</code>, to name two—but they are included in Foundation because there can be uses for them that do not involve a user interface.</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW7" title="Foundation Paradigms and Policies"></a><h4>Foundation Paradigms and Policies</h4><p>Foundation introduces several <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1034"></a>paradigms and policies to Cocoa programming to ensure consistent behavior and expectations among the objects of a program in certain situations. These include: </p><ul class="spaceabove"><li class="li"><p><strong>Object retention and object disposal</strong>. The Objective-C runtime and Foundation give Cocoa programs two ways to ensure that objects persist when they’re needed and are freed when they are no longer needed. <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1035"></a>Garbage collection, which was introduced in Objective-C 2.0, automatically tracks and disposes of objects that your program no longer needs, thus freeing up memory. Foundation also still offers the traditional approach of <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1036"></a>memory management. It institutes a policy of <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1037"></a>object ownership that specifies that objects are responsible for releasing other objects that they have created, copied, or explicitly retained. <code>NSObject</code> (class and protocol) defines methods for retaining and releasing objects. <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1038"></a>Autorelease pools (defined in the <code>NSAutoreleasePool</code> class) implement a delayed-release mechanism and enable Cocoa programs to have a consistent convention for returning objects for which the caller is not responsible. For more about garbage collection and explicit memory management, see <span class="content_text"><a href="../CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW39">“Object Retention and Disposal.”</a></span> </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW76" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;For performance reasons, garbage collection is not allowed in Cocoa applications running on iPhone OS. </p></div></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1039"></a>Mutable class variants</strong>. Many value and container classes in Foundation have a mutable variant of an immutable class, with the mutable class always being a subclass of the immutable one. If you need to dynamically change the encapsulated value or membership of such an object, you create an instance of the mutable class. Because it inherits from the immutable class, you can pass the mutable instance in methods that take the immutable type. For more on object mutability, see <span class="content_text"><a href="../CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW33">“Object Mutability.”</a></span></p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1040"></a>Class clusters</strong>. A class cluster is an abstract class and a set of private concrete subclasses for which the abstract class acts as an umbrella interface. Depending on the context (particularly the method you use to create an object), an instance of the appropriate optimized class is returned to you. <code>NSString</code> and <code>NSMutableString</code>, for example, act as brokers for instances of various private subclasses optimized for different kinds of storage needs. Over the years the set of concrete classes has changed several times without breaking applications. For more on class clusters, see <span class="content_text"><a href="../CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW34">“Class Clusters.”</a></span></p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1041"></a>Notifications</strong>. Notification is a major design pattern in Cocoa. It is based on a broadcast mechanism that allows objects (called observers) to be kept informed of what another object is doing or is encountering in the way of user or system events. The object originating the notification can be unaware of the existence or identity of the observers of the notification. There are several types of notifications: synchronous, asynchronous, and distributed. The Foundation notification mechanism is implemented by the <code>NSNotification</code>, <code>NSNotificationCenter</code>, <code>NSNotificationQueue</code>, and <code>NSDistributedNotificationCenter</code> classes. For more on notifications, see <span class="content_text"><a href="../CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW7">“Notifications.”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH3-SW40" title="Foundation Classes"></a><h4>Foundation Classes</h4><p>The Foundation class hierarchy is rooted in the <code>NSObject</code> class, which (along with the <code>NSObject</code> and <code>NSCopying</code> protocols) define basic object attributes and behavior. For further information on <code>NSObject</code> and basic object behavior, see <span class="content_text"><a href="../CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW35">“The Root Class.”</a></span></p><p>The remainder of the Foundation framework consists of several related groups of classes as well as a few individual classes. There are classes representing basic data types such as strings and byte arrays, collection classes for storing other objects, classes representing system information such as dates, and classes representing system entities such as ports, threads, and processes. The <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1042"></a>class hierarchy charts in <span class="content_text">Figure 1-9</span> (for printing purposes, in three parts) depict the logical groups these classes form as well as their inheritance relationships. Classes in blue-shaded areas are present in both the Mac OS X and iPhone OS versions of Foundation; classes in gray-shaded areas are present only in the Mac OS X version.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW15" title="Figure 1-9The Foundation class hierarchy"></a><p><strong>Figure 1-9&nbsp;&nbsp;</strong>The Foundation class hierarchy</p><img src = "../Art/objc_foundation_A.jpg" alt = "The Foundation class hierarchy" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW13"></a><img src = "../Art/objc_foundation2_A.jpg" alt = "Foundation class hierarchy—Objective-C (part two)" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW3"></a><img src = "../Art/objc_foundation3_A.jpg" alt = "Foundation class hierarchy—Objective-C (part three)" ></div><br/><p>These diagrams logically group the classes of the Foundation framework in the following categories (with other associations pointed out):</p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1043"></a>Value objects</strong>. Value objects encapsulate data of various types, giving access to the data and offering various manipulations of it. Because they are objects, they (and their contained values) can be archived and distributed. <code>NSData</code> provides object-oriented storage for streams of bytes whereas <code>NSValue</code> and <code>NSNumber</code> provide object-oriented storage for arrays of simple scalar values. The <code>NSDate</code>, <code>NSCalendarDate</code>, <code>NSTimeZone</code>, <code>NSCalendar</code>, <code>NSDateComponents</code>, and <code>NSLocale</code> classes provide objects that represent times, dates, calendar, and locales. They offer methods for calculating date and time differences, for displaying dates and times in many formats, and for adjusting times and dates based on location in the world.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1044"></a>Strings</strong>. <code>NSString</code> is another type of value object that provides object-oriented storage for a null-terminated array of bytes in a particular encoding. It includes support for converting string encodings among UTF-16, UTF-8, and many other encodings. <code>NSString</code> also offers methods for searching, combining, and comparing strings and for manipulating file-system paths. You can use an <code>NSScanner</code> object to parse numbers and words from an <code>NSString</code> object. <code>NSCharacterSet</code> (shown as a collection class in the diagram) represents a set of characters that are used by various <code>NSString</code> and <code>NSScanner</code> methods.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1045"></a>Collections</strong>. Collections are objects that store and vend other (usually value) objects in a particular ordering scheme. <code>NSArray</code> uses zero-based indexing, <code>NSDictionary</code> uses key-value pairs, and <code>NSSet</code> provides unordered storage of objects (<code>NSCountedSet</code> “uniques” the collection). With an <code>NSEnumerator</code> object, you can access in sequence the elements of a collection. Collection objects are essential components of property lists and, like all objects, can be archived and distributed. </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1046"></a>Operating-system services</strong>. Many Foundation classes facilitate access of various lower-level services of the operating system and, at the same time, insulate you from operating-system idiosyncrasies. For example, <code>NSProcessInfo</code> lets you query the environment in which an application runs and <code>NSHost</code> yields the names and addresses of host systems on a network. You can use an <code>NSTimer</code> object to send a message to another object at specific intervals, and <code>NSRunLoop</code> lets you manage the input sources of an application or other type of program. <code>NSUserDefaults</code> provides a programmatic interface to a system database of global (per-host) and per-user default values (preferences). </p><ul class="nested"><li class="nested li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1047"></a><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1048"></a>File system and URL</strong>. <code>NSFileManager</code> provides a consistent interface for file operations such as creating, renaming, deleting, and moving files. <code>NSFileHandle</code> permits file operations at a lower level (for example, seeking within a file). <code>NSBundle</code> finds resources stored in bundles and can dynamically load some of them (for example, nib files and code). You use <code>NSURL</code> and related <code>NSURL...</code> classes to represent, access, and manage URL sources of data.</p></li><li class="nested li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1049"></a>Multithreading, operations, and subtasks</strong>. <code>NSThread</code> lets you create multithreaded programs, and various lock classes offer mechanisms for controlling access to process resources by competing threads. You can use <code>NSOperation</code> and <code>NSOperationQueue</code> to perform multiple operations (concurrent or non-concurrent) in priority and dependence order. With <code>NSTask</code>, your program can fork off a child process to perform work and monitor its progress. </p></li><li class="nested li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1050"></a>Interprocess communication</strong>. Most of the classes in this category represent various kinds of system ports, sockets, and name servers and are useful in implementing low-level IPC. <code>NSPipe</code> represents a BSD pipe, a unidirectional communications channel between processes. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW77" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;The name server classes are not present in the iPhone OS version of Foundation.</p></div></li><li class="nested li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1051"></a>Networking</strong>. The <code>NSNetService</code> and <code>NSNetServiceBrowser</code> classes support the zero-configuration networking architecture called Bonjour. Bonjour is a powerful system for publishing and browsing for services on an IP network.<a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1052"></a></p></li></ul></li><li class="li"><p><strong>Notifications</strong>. See the summary of the notification classes in <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW7">“Foundation Paradigms and Policies.”</a></span> </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1053"></a>Archiving and serialization</strong>. The classes in this category make object distribution and persistence possible. <code>NSCoder</code> and its subclasses, along with the <code>NSCoding</code> protocol, represent the data an object contains in an architecture-independent way by allowing class information to be stored along with the data. <code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code> offer methods for encoding objects and scalar values and decoding them in a way that is not dependent on the ordering of encoding messages. </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1054"></a>Objective-C language services</strong>. <code>NSException</code> and <code>NSAssertionHandler</code> provide an object-oriented way of making assertions and handling exceptions in code. An <code>NSInvocation</code> object is a static representation of an Objective-C message that your program can store and later use to invoke a message in another object; it is used by the undo manager (<code>NSUndoManager</code>) and by the Distributed Objects system. An <code>NSMethodSignature</code> object records the type information of a method and is used in message forwarding. <code>NSClassDescription</code> is an abstract class for defining and querying the relationships and properties of a class. </p></li></ul><p>The Foundation framework for iPhone OS has a subset of the classes for Mac OS X. The following categories of classes are present only in the Mac OS X version of Foundation:</p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1055"></a>XML processing</strong>. The NSXML classes of Foundation process XML data efficiently, either in an event-driven way or by representing an XML document as a hierarchical tree structure. The latter approach lets you to query this structure and manipulate its nodes. The NSXML classes support several XML-related technologies and standards, such as XQuery, XPath, XInclude, XSLT, DTD, and XHTML.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1056"></a>Expressions and predicates</strong>. The predicate classes—<code>NSPredicate</code>, <code>NSCompoundPredicate</code>, and <code>NSComparisonPredicate</code>—encapsulate the logical conditions to constrain a fetch or filter object. <code>NSExpression</code> objects represent expressions in a predicate.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1057"></a>Spotlight queries</strong>. The <code>NSMetadataItem</code>, <code>NSMetadataQuery</code> and related query classes encapsulate file-system metadata and make it possible to query that metadata.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1058"></a>Scripting</strong>. The classes in this category help to make your program responsive to AppleScript scripts and Apple event commands. </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1059"></a>Distributed objects</strong>. You use the distributed object classes for communication between processes on the same computer or on different computers on a network. Two of these classes, <code>NSDistantObject</code> and <code>NSProtocolChecker</code>, have a root class (<code>NSProxy</code>) different from the root class of the rest of Cocoa.</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH3-SW25" title="Application Kit (Mac OS X)"></a><h3>Application Kit (Mac OS X)</h3><p>The <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1060"></a>Application Kit (which is sometimes referred to as the AppKit) is a framework containing all the objects you need to implement your graphical, event-driven user interface on Mac OS X: windows, dialogs, buttons, menus, scrollers, text fields—the list goes on. The Application Kit handles all the details for you as it efficiently draws on the screen, communicates with hardware devices and screen buffers, clears areas of the screen before drawing, and clips views. The number of classes in the Application Kit may seem daunting at first. However, most Application Kit classes are support classes that you use indirectly. You also have the choice at which level you use the Application Kit:</p><ul class="spaceabove"><li class="li"><p>Use <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1061"></a>Interface Builder to create connections from user-interface objects to your application’s controller objects, which manage the user interface and coordinate the flow of data between the user interface and internal data structures. For this, you might use off-the-shelf controller objects (for Cocoa bindings) or you may need to  implement one or more custom controller classes—particularly the action and delegate methods of those classes. For example, you would need to implement a method that is invoked when the user chooses a menu item (unless it has a default implementation that is acceptable).</p></li><li class="li"><p>Control the user interface programmatically, which requires more familiarity with Application Kit classes and protocols. For example, allowing the user to drag an icon from one window to another requires some programming and familiarity with the <code>NSDragging...</code> protocols.</p></li><li class="li"><p>Implement your own objects by <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1062"></a>subclassing <code>NSView</code> or other classes. When subclassing <code>NSView</code>, you write your own drawing methods using graphics functions. Subclassing requires a deeper understanding of how the Application Kit works.</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH3-SW41" title="Overview of the Application Kit"></a><h4>Overview of the Application Kit</h4><p>The Application Kit consists of more than 125 classes and protocols. All classes ultimately inherit from the Foundation framework’s <code>NSObject</code> class. The diagrams in <span class="content_text">Figure 1-10</span> show the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1063"></a>inheritance relationships of the Application Kit classes. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW1" title="Figure 1-10Application Kit class hierarchy&acirc;&#128;&#148;Objective-C"></a><p><strong>Figure 1-10&nbsp;&nbsp;</strong>Application Kit class hierarchy—Objective-C</p><img src = "../Art/objc_appkit.jpg" alt = "Application Kit class hierarchy—Objective-C" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW9"></a><img src = "../Art/objc_appkit2.jpg" alt = "Application Kit class hierarchy (part two)" ></div><br/><p>As you can see, the hierarchy tree of the Application Kit is broad but fairly shallow; the classes deepest in the hierarchy are a mere five superclasses away from the root class and most classes are much closer than that. Some of the major branches in this hierarchy tree are particularly interesting. </p><p>At the root of the largest branch in the Application Kit is the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1064"></a><code>NSResponder</code> class. This class defines the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1065"></a>responder chain, an ordered list of objects that respond to user events. When the user clicks the mouse button or presses a key, an event is generated and passed up the responder chain in search of an object that can respond to it. Any object that handles events must inherit from the <code>NSResponder</code> class. The core Application Kit classes—<code>NSApplication</code>, <code>NSWindow</code>, and <code>NSView</code>—inherit from <code>NSResponder</code>. You can find out more about these responder classes by reading <span class="content_text"><a href="../CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW45">“The Core Application Architecture on Mac OS X.”</a></span></p><p>The second largest branch of classes in the Application Kit descend from <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1066"></a><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1067"></a><code>NSCell</code>. The noteworthy thing about this group of classes is that they roughly mirror the classes that inherit from <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1068"></a><code>NSControl</code>, which inherits from <code>NSView</code>. For its user-interface objects that respond to user actions, the Application Kit uses an architecture that divides the labor between control objects and cell objects. The <code>NSControl</code> and <code>NSCell</code> classes, and their subclasses, define a common set of user-interface objects such as buttons, sliders, and browsers that the user can manipulate graphically to control some aspect of your application. Most control objects are associated with one or more cell objects that implement the details of drawing and handling events. For example, a button comprises both an <code>NSButton</code> object and an <code>NSButtonCell</code> object. See <span class="content_text"><a href="../CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW47">“Control and Cell Architecture”</a></span> for further information</p><p>Controls and cells implement a mechanism that is based on an important design pattern of the Application Kit:. the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1069"></a>target-action mechanism. A cell can hold information that identifies the message that should be sent to a particular object when the user clicks (or otherwise acts upon) the cell. When a user manipulates a control (by, for example, clicking the mouse pointer over it), the control extracts the required information from its cell and sends an action message to the target object. Target-action allows you to give meaning to a user action by specifying what the target object and invoked method should be. You typically use <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1070"></a>Interface Builder to set these targets and actions by Control-dragging from the control object to your application or other object. You can also set targets and actions programmatically. </p><p>Another important design-pattern based mechanism of the Application Kit (and also UIKit) is <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1071"></a>delegation. Many objects in a user interface, such as text fields and table views, define a delegate. A delegate is an object that acts on behalf of, or in coordination with, the delegating object. It is thus able to impart application-specific logic to the operation of the user interface. For more on delegation, target–action, and other paradigms and mechanisms of the Application Kit, see <span class="content_text"><a href="../CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW15">“Communicating With Objects.”</a></span> For a discussion of the design patterns on which these paradigms and mechanisms are based, see <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6">“Cocoa Design Patterns.”</a></span></p><p>One of the general features of Mac OS X version 10.5  and later systems is resolution independence: the resolution of the screen is decoupled from the drawing done by code. The system automatically scales content for rendering on the screen. The Application Kit classes support resolution independence in its user-interface objects. However, for your own applications to take advantage of resolution independence, you might have to supply images at a higher resolution or make minor adjustments in your drawing code that take the current scaling factor into account. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW78" title="Note"></a><p><strong>Note:</strong>&nbsp;In Mac OS X version 10.5 resolution independence is a developer feature, and is not yet available to end users.</p></div><p>The following sections briefly describe some of the capabilities and architectural aspects of the Application Kit and its classes and protocols. It groups classes according to the class hierarchy diagrams shown in <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW1">Figure 1-10</a></span> and <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW9">“Application Kit class hierarchy—Objective-C (part two).”</a></span></p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW42" title="General User-Interface Classes"></a><h4>General User-Interface Classes</h4><p>For the overall functioning of a user interface, the Application Kit provides the following classes:</p><ul class="spaceabove"><li class="li"><p><strong>The <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1072"></a><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1073"></a>global application object</strong>. Every application uses a singleton instance of <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1074"></a><code>NSApplication</code> to control the main event loop, keep track of the application’s windows and menus, distribute events to the appropriate objects (that is, itself or one of its windows), set up top-level autorelease pools, and receive notification of application-level events. An <code>NSApplication</code> object has a delegate (an object that you assign) that is notified when the application starts or terminates, is hidden or activated, should open a file selected by the user, and so forth. By setting the <code>NSApplication</code> object’s delegate and implementing the delegate methods, you customize the behavior of your application without having to subclass <code>NSApplication</code>. <span class="content_text"><a href="../CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW45">“The Core Application Architecture on Mac OS X”</a></span> discusses this singleton application object in detail.</p></li><li class="li"><p><strong>Windows and views</strong>. The window and view classes, <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1075"></a><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1076"></a><code>NSWindow</code> and <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1077"></a><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1078"></a><code>NSView</code>, also inherit from <code>NSResponder</code>, and so are designed to respond to user actions. An <code>NSApplication</code> object maintains a list of <code>NSWindow</code> objects—one for each window belonging to the application—and each <code>NSWindow</code> object maintains a hierarchy of <code>NSView</code> objects. The view hierarchy is used for drawing and handling events within a window. An <code>NSWindow</code> object handles window-level events, distributes other events to its views, and provides a drawing area for its views. An <code>NSWindow</code> object also has a delegate allowing you to customize its behavior. </p><p>Beginning with Mac OS X version 10.5, the window and view classes of the Application Kit support enhanced animation features. </p><p><code>NSView</code> is the superclass for all objects displayed in a window. All subclasses implement a drawing method using graphics functions; <code>drawRect:</code> is the primary method you override when creating a new <code>NSView</code>.</p><p><span class="content_text"><a href="../CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW45">“The Core Application Architecture on Mac OS X”</a></span> describes <code>NSView</code> and <code>NSWindow</code> objects.</p></li><li class="li"><p><strong>Controller classes for Cocoa bindings</strong>. The abstract <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1079"></a><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1080"></a><code>NSController</code> class and its concrete subclasses <code>NSObjectController</code>, <code>NSArrayController</code>, <code>NSDictionaryController</code>, and <code>NSTreeController</code> are part of the implementation of Cocoa bindings. This technology automatically synchronizes the application data stored in objects and the presentation of that data in a user interface. See <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW1">“The Model-View-Controller Design Pattern”</a></span> for a description of these types of controller objects.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1081"></a>Panels (dialogs)</strong>. The <code>NSPanel</code> class is a subclass of <code>NSWindow</code> that you use to display transient, global, or pressing information. For example, you would use an instance of <code>NSPanel</code>, rather than an instance of <code>NSWindow</code>, to display error messages or to query the user for a response to remarkable or unusual circumstances. The Application Kit implements some common dialogs for you such as the Save, Open and Print dialogs, used to save, open, and print documents. Using these dialogs gives the user a consistent look and feel across applications for common operations.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1082"></a>Menus and cursors</strong>. The <code>NSMenu</code>, <code>NSMenuItem</code>, and <code>NSCursor</code> classes define the look and behavior of the menus and cursors that your application displays to the user.</p></li><li class="li"><p><strong>Grouping and scrolling views</strong>. The <code>NSBox</code>, <code>NSScrollView</code>, and <code>NSSplitView</code> classes provide graphic “accessories” to other view objects or collections of views in windows. With the <code>NSBox</code> class, you can group elements in windows and draw a border around the entire group. The <code>NSSplitView</code> class lets you append views vertically or horizontally, apportioning to each view some amount of a common territory; a sliding control bar lets the user redistribute the territory among views. The <code>NSScrollView</code> class and its helper class, <code>NSClipView</code>, provide a scrolling mechanism as well as the graphic objects that let the user initiate and control a scroll. The <code>NSRulerView</code> class allows you to add a ruler and markers to a scroll view.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1083"></a>Table views and <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1084"></a>outline views</strong>. The <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1085"></a><code>NSTableView</code> class displays data in rows and columns. <code>NSTableView</code> is ideal for, but not limited to, displaying database records, where rows correspond to each record and columns contain record attributes. The user can edit individual cells and rearrange the columns. You control the behavior and content of an <code>NSTableView</code> object by setting its delegate and data source objects. Outline views (instances of <code>NSOutlineView</code>, a subclass of <code>NSTableView</code>) offer another approach to displaying tabular data. With the <code>NSBrowser</code> class you can create an object with which users can display and navigate hierarchical data.</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH3-SW43" title="Text and Fonts"></a><h4>Text and Fonts</h4><p>The Cocoa text system is based on the Core Text framework, which was introduced in Mac OS X version 10.5. The Core Text framework provides a modern, low-level, high-performance technology for laying out text. If you use the Cocoa text system, you should rarely have reason to use Core Text directly.</p><p>The <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1086"></a><code>NSTextField</code> class implements a simple editable text-input field, and the <code>NSTextView</code> class provides more comprehensive editing features for larger text bodies. </p><p><code>NSTextView</code>, a subclass of the abstract <code>NSText</code> class, defines the interface to the extended text system. <code>NSTextView</code> supports rich text, attachments (graphics, file, and other), input management and key binding, and marked text attributes. <code>NSTextView</code> works with the Fonts window and Font menu, rulers and paragraph styles, the Services facility, and the pasteboard (Clipboard). <code>NSTextView</code> also allows customizing through delegation and notifications—you rarely need to subclass <code>NSTextView</code>. You rarely create instances of <code>NSTextView</code> programmatically either, since objects on Interface Builder’s palettes, such as <code>NSTextField</code>, <code>NSForm</code>, and <code>NSScrollView</code>, already contain <code>NSTextView</code> objects. </p><p>It is also possible to do more powerful and more creative text manipulation (such as displaying text in a circle) using <code>NSTextStorage</code>, <code>NSLayoutManager</code>, <code>NSTextContainer</code>, and related classes. The Cocoa text system also supports lists, tables, and non-contiguous selections.</p><p>The <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1087"></a><code>NSFont</code> and <code>NSFontManager</code> classes encapsulate and manage font families, sizes, and variations. The <code>NSFont</code> class defines a single object for each distinct font; for efficiency, these objects, which can represent a lot of data, are shared by all the objects in your application. The <code>NSFontPanel</code> class defines the Fonts window that’s presented to the user.</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW44" title="Graphics and Colors"></a><h4>Graphics and Colors</h4><p>The classes <code>NSImage</code> and <code>NSImageRep</code> encapsulate graphics data, allowing you to easily and efficiently access <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1088"></a>images stored in files on the disk and displayed on the screen. <code>NSImageRep</code> subclasses each know how to draw an image from a particular kind of source data. The <code>NSImage</code> class provides multiple representations of the same image, and also provides behaviors such as caching. The imaging and drawing capabilities of Cocoa are integrated with the Core Image framework.</p><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1089"></a>Color is supported by the classes <code>NSColor</code>, <code>NSColorSpace</code>, <code>NSColorPanel</code>, <code>NSColorList</code>, <code>NSColorPicker</code>, and <code>NSColorWell</code>. <code>NSColor</code> and <code>NSColorSpace</code> support a rich set of color formats and representations, including custom ones. The other classes are mostly interface classes: They define and present panels and views that allow the user to select and apply colors. For example, the user can drag colors from the Color window to any color well. </p><p>The <code>NSGraphicsContext</code>, <code>NSBezierPath</code>, and <code>NSAffineTransform</code> classes help you with <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1090"></a>vector drawing and support <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1091"></a>graphical transformations such as scaling, rotation, and translation.</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW45" title="Printing and Faxing"></a><h4>Printing and Faxing</h4><p>The <code>NSPrinter</code>, <code>NSPrintPanel</code>, <code>NSPageLayout</code>, and <code>NSPrintInfo</code> classes work together to provide the means for <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1092"></a>printing and <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1093"></a>faxing the information that your application displays in its windows and views. You can also create a PDF representation of an <code>NSView</code>. </p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW46" title="Document and File-System Support"></a><h4>Document and File-System Support</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1094"></a>Use the <code>NSFileWrapper</code> class to create objects that correspond to files or directories on disk. <code>NSFileWrapper</code> holds the contents of the file in memory so that it can be displayed, changed, or transmitted to another application. It also provides an icon for dragging the file or representing it as an attachment. Or use the <code>NSFileManager</code> class in the Foundation framework to access and enumerate file and directory contents. The <code>NSOpenPanel</code> and <code>NSSavePanel</code> classes also provide a convenient and familiar user interface to the file system.</p><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1095"></a>The <code>NSDocumentController</code>, <code>NSDocument</code>, and <code>NSWindowController</code> classes define an architecture for creating <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1096"></a>document-based applications. (The <code>NSWindowController</code> class is shown in the User Interface group of classes in the class hierarchy charts). Such applications can generate identically contained but uniquely composed sets of data that can be stored in files. They have built-in or easily acquired capabilities for saving, opening, reverting, closing, and managing these documents. </p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW47" title="Internationalization and Character Input Support"></a><h4>Internationalization and Character Input Support</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1097"></a>If an application is to be used in more than one part of the world, its resources may need to be customized, or localized, for language, country, or cultural region. For example, an application may need to have separate Japanese, English, French, and German versions of character strings, icons, nib files, or context help. Resource files specific to a particular language are grouped together in a subdirectory of the bundle directory (the directories with the <code>.lproj</code> extension). Usually you set up localization resource files using Interface Builder. See <span class="content_text"><a href="../CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW49">“Nib Files and Other Application Resources”</a></span> for more information on the Cocoa internationalization facilities.</p><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1098"></a>The <code>NSInputServer</code> and <code>NSInputManager</code> classes, along with the <code>NSTextInput</code> protocol, give your application access to the text input management system. This system interprets keystrokes generated by various international keyboards and delivers the appropriate text characters or Control-key events to text view objects. (Typically the text classes deal with these classes and you won’t have to.)</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW48" title="Operating-System Services"></a><h4>Operating-System Services</h4><p>The Application Kit provides operating-system support for your application through classes that implement the following features:</p><ul class="spaceabove"><li class="li"><p><strong>Sharing data with other applications</strong>. The <code>NSPasteboard</code> class defines the <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1099"></a>pasteboard, a repository for data that’s copied from your application, making this data available to any application that cares to use it. <code>NSPasteboard</code> implements the familiar <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1100"></a>cut-copy-paste operation. </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1101"></a>Dragging</strong>. With very little programming on your part, custom view objects can be dragged and dropped anywhere. Objects become part of this dragging mechanism by conforming to <code>NSDragging...</code> protocols; draggable objects conform to the <code>NSDraggingSource</code> protocol, and destination objects (receivers of a drop) conform to the <code>NSDraggingDestination</code> protocol. The Application Kit hides all the details of tracking the cursor and displaying the dragged image.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1102"></a>Spell checking</strong>. The <code>NSSpellServer</code> class lets you define a spell-checking service and provide it as a service to other applications. To connect your application to a spell-checking service, you use the <code>NSSpellChecker</code> class. The <code>NSIgnoreMisspelledWords</code> and <code>NSChangeSpelling</code> protocols support the spell-checking mechanism.</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH3-SW49" title="Interface Builder Support"></a><h4>Interface Builder Support</h4><p>The abstract <code>NSNibConnector</code> class and its two concrete subclasses, <code>NSNibControlConnector</code> and <code>NSNibOutletConnector</code>, represent connections in Interface Builder. <code>NSNibControlConnector</code> manages an action connection in Interface Builder and <code>NSNibOutletConnector</code> manages an outlet connection.<a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1103"></a></p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW22" title="UIKit (iPhone OS)"></a><h3>UIKit (iPhone OS)</h3><p>The UIKit framework on iPhone OS is the sister framework of the Application Kit on Mac OS X. Its purpose is essentially the same: to provide all the classes that an application needs to construct and manage its user interface. However, there are significant differences in how the frameworks realize this purpose.</p><p>One of the greatest differences is that, on iPhone OS, the objects that appear in the user interface of a Cocoa application look and behave differently from their counterparts in a Cocoa application running on Mac OS X. Some common examples are text views, table views, and buttons.  In addition, the event-handling and drawing models for Cocoa applications on the two platforms are significantly different. The following sections explain the reasons for these and other differences.</p><p>You can add UIKit objects to your application’s user interface in three ways: </p><ul class="spaceabove"><li class="li"><p>Use the Interface Builder development application to drag-and-drop windows, views, and other objects from an object library. </p></li><li class="li"><p>Create, position, and configure framework objects programmatically.  </p></li><li class="li"><p>Implement custom user-interface objects by subclassing <code>UIView</code> or classes that inherit from <code>UIView</code>.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW79" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To gain a thorough understanding of UIKit, read <em><!--a target="_top" -->UIKit Framework Reference<!--/a--></em> and  <em><!--a target="_top" -->iPhone Application Programming Guide<!--/a--></em>. </p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW50" title="Overview of UIKit Classes"></a><h4>Overview of UIKit Classes</h4><p>As with the Application Kit, the classes of the UIKit framework ultimately inherit from <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code>. <span class="content_text">Figure 1-11</span> presents the classes of the UIKit framework in their inheritance relationship.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW26" title="Figure 1-11UIKit class hierarchy"></a><p><strong>Figure 1-11&nbsp;&nbsp;</strong>UIKit class hierarchy</p><img src = "../Art/uikit_classes.jpg" alt = "UIKit class hierarchy" ></div><br/><p>As with the Application Kit a base responder class is at the root of the largest branch of UIKit classes. <code>UIResponder</code> also defines the interface and default behavior (if any) for event-handling methods and for the responder chain, which is a chain of objects that are potential event handlers. When the user scrolls a table view with his or her finger or types characters in a virtual keyboard, UIKit generates an event and that event is passed up the responder chain until an object handles it. The corresponding core objects—application (<code>UIApplication</code>), window (<code>UIWindow</code>), and view (<code>UIView</code>)—all directly or indirectly inherit from <code>UIResponder</code>.</p><p>Unlike the Application Kit, UIKit does not make use of cells. Controls in UIKit—that is, all objects that inherit from <code>UIControl</code>—do not require cells to carry out their primary role: sending action messages to a target object. Yet the way UIKit implements the target-action mechanism is different from the design in the Application Kit. The <code>UIControl</code> class defines a set of event types for controls; if, for example, you want a button (<code>UIButton</code>) to send an action message to a target object, you call <code>UIControl</code> methods to associate the action and target with one or more of the control event types. When one of those events happens, the control sends the action message. </p><p>The UIKit framework makes considerable use of delegation, another design pattern of the Application Kit. Yet the UIKit implementation of delegation is different. Instead of using informal protocols, UIKit uses formal protocols with possibly some protocol methods marked optional. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW80" title="Note"></a><p><strong>Note:</strong>&nbsp;For a complete description of the target-action mechanism in UIKit and the Application Kit, see <span class="content_text"><a href="../CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW14">“The Target-Action Mechanism.”</a></span> To learn more about delegation and protocols, both formal and informal, see <span class="content_text"><a href="../CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW18">“Delegates and Data Sources”</a></span> and <span class="content_text"><a href="../CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW41">“Protocols.”</a></span> </p></div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW51" title="Application Coordination"></a><h4>Application Coordination</h4><p>Each application running on iPhone OS is managed by a singleton application object, and this object has a job that is almost identical to that for the global <code>NSApplication</code> object. A <code>UIApplication</code> object controls the main event loop, keeps track of the applications windows and views, and dispatches incoming events to the appropriate responder objects. </p><p>The <code>UIApplication</code> object also receives notification of system-level and application-level events. Many of these it passes to its delegate, allowing it to inject application-specific behavior when the application launches and terminates, and to respond to low-memory warnings and changes in time.  </p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW52" title="Differences in Event and Drawing Models"></a><h4>Differences in Event and Drawing Models</h4><p>In Mac OS X, the mouse and keyboard generate most user events. The Application Kit uses <code>NSEvent</code> objects to encapsulate these events. On iPhone OS, however, a user’s finger movements on the screen are what originate events. UIKit also has a class, <code>UIEvent</code>, to represent these events. But finger touches are different in nature from mouse clicks; two or more touches occurring over a period could comprise a discrete event—a pinch gesture, for example. Thus a <code>UIEvent</code> object contains one or more objects representing finger touches (<code>UITouch</code>). The model for distributing and dispatching events to objects that can handle them on the two platforms is almost identical. However, to handle an event, an object must take into consideration the sequence of touches specific to that event.</p><p>The drawing models are very similar for the Application Kit and UIKit. In UIKit, however, a <code>UIView</code> object has an animation layer associated with it to enable the animation of changes within views and transitions between views. That said, the programmatic support that UIKit directly provides for drawing is limited (specifically, simple line and rectangle drawing through functions declared in <code>UIGraphics.h</code>). Therefore, for drawing of any sophistication, an application must use the Core Graphics or OpenGLES framework. You use <code>UIColor</code> objects to set colors in the current graphics context.</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW24" title="General User-Interface Classes"></a><h4>General User-Interface Classes</h4><p>Objects on an iPhone OS user interface are visibly different than objects on a Mac OS X user interface. Because of the nature of the device—specifically the smaller screen size and the use of fingers instead of the mouse and keyboard for input—user-interface objects on iPhone OS must typically be larger (to be an adequate target for touches) while at the same time make as efficient use of screen real estate as possible. These objects are sometimes based on visual and tactile analogues of an entirely different sort. As an example, consider the date picker object, which is instantiated from a class that both the UIKit and Application Kit frameworks define. On Mac OS X, the date picker looks like the following:</p><br/><div><img src = "../Art/datepicker_osx.jpg" alt = "A date picker in Cocoa on Mac OS X" ></div><br/><p>This style of date picker has a two tiny areas for incrementing date components, and thus is suited to manipulation by a mouse pointer. Contrast this with the date picker seen on iPhone applications:</p><br/><div><img src = "../Art/datepicker_a.jpg" alt = "A date picker in Aspen" ></div><br/><p>This style of date picker is more suited for finger touches as an input source; users can swipe a month, day, or year column to spin it to a new value.</p><p>As with the Application Kit, many of UIKit classes fall into functional groups:</p><ul class="spaceabove"><li class="li"><p><strong>Controls</strong>. The subclasses of <code>UIControl</code> instantiate objects that let users communicate their intent to an application. In addition to the standard button object (<code>UIButton</code>) and slider object (<code>UISlider</code>), there is a control that simulate off/on switches (<code>UISwitch</code>), a spinning-wheel control for selecting from multidimensional sets of values (<code>UIPickerView</code>), a control for paging through documents (<code>UIPageControl</code>), and other controls.</p></li><li class="li"><p><strong>Modal views</strong>. The two classes inheriting from <code>UIModalView</code> are for displaying messages to users either in the form of  “sheets” attached to specific views or windows (<code>UIActionSheet</code>) or as unattached alert dialogs (<code>UIAlertView</code>).</p></li><li class="li"><p><strong>Scroll views</strong>. The <code>UIScrollView</code> class enables instances of its subclasses to respond to touches for scrolling within large views. As users scroll, the scroll view displays transient indicators of position within the document. The subclasses of <code>UIScrollView</code> implement table views, text views, and web views.</p></li><li class="li"><p><strong>Toolbars, navigation bars, and view controllers</strong>. The <code>UIViewController</code> class is a base class for managing a view. A view controller provides methods for creating and observing views, overlaying views, handling view rotation, and responding to low-memory warnings. UIKit includes concrete subclasses of <code>UIViewController</code> for managing toolbars, navigation bars, and image pickers. </p><p>Applications use both toolbars and navigation bars to manage behavior related to the “main” view on the screen; typically, toolbars are placed beneath the main view and navigation bars above it. You use toolbar (<code>UIToolbar</code>) object to switch between modes or views of an application; you can also use them to display a set of functions that perform some action related to the current main view. You use navigation bars (<code>UINavigationBar</code>) to manage sequences of windows or views in an application and, in effect, to “drill down” a hierarchy of objects defined by the application; the Mail application for example, uses a navigation bar to navigate from accounts to mailbox folders and from there to individual email messages.</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH3-SW53" title="Text and Images"></a><h4>Text and Images</h4><p>Users can enter text in an iPhone application either through a text view (<code>UITextView</code>) or a text field (<code>UITextField</code>). These classes adopt the <code>UIInputTraits</code> protocol to specify the appearance and behavior of the virtual keyboard that is presented when users touch the text-entry object; any subclasses that enable entry of text should also conform to this protocol. Applications can draw text in views using <code>UIStringDrawing</code> methods, a category on the <code>NSString</code> class. And with the <code>UIFont</code> class you can specify the font characteristics of text in all objects that display text, including table cells, navigation bars, and labels.</p><p>UIKit uses <code>UIImage</code> objects to represent and encapsulate images.  </p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW55" title="Comparing Application Kit and UIKit Classes"></a><h3>Comparing Application Kit and UIKit Classes</h3><p>The Application Kit and UIKit are Cocoa application frameworks that are designed for different platforms, one for Mac OS X and the other for iPhone OS. Because of this affinity, it is not surprising that many of the classes in each framework have similar names; in most cases, the prefix (“NS” versus “UI”) is the only name difference. These similarly named classes fulfill mostly similar roles, but there are differences. These differences can be a matter of scope, of inheritance, or of design. Generally, UIKit classes have fewer methods than their Application Kit counterparts.</p><p><span class="content_text">Figure 1-12</span> shows UIKit classes with corresponding classes in the Application Kit. <span class="content_text"><a href="WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW56">Table 1-1</a></span> describes the differences between the major classes in each framework.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW57" title="Figure 1-12UIKit classes and their Application Kit counterparts"></a><p><strong>Figure 1-12&nbsp;&nbsp;</strong>UIKit classes and their Application Kit counterparts</p><img src = "../Art/uikit_appkit.jpg" alt = "UIKit classes and their Application Kit counterparts" ></div><br/><a name="//apple_ref/doc/uid/TP40002974-CH3-SW56" title="Table 1-1Major classes of the Application Kit and UIKit"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-1&nbsp;&nbsp;</strong>Major classes of the Application Kit and UIKit</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Classes</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Comparison</p></th></tr><tr><td  scope="row"><p><code>NSApplication</code></p><p><code>UIApplication</code></p></td><td ><p>The classes are strikingly similar in their primary roles. They provide a singleton object that sets up the application’s display environment and event loop, distributes events, and notifies a delegate when application-specific events occur (such as launch and termination). However, the <code>NSApplication</code> class performs functions (for example, managing application suspension, reactivation, and hiding) that are not available to an iPhone application.</p></td></tr><tr><td  scope="row"><p><code>NSResponder</code></p><p><code>UIResponder</code></p></td><td ><p>These classes also have nearly identical roles. They are abstract classes that define an interface for responding to events and managing the responder chain. The main differences is that the <code>NSResponder</code> event-handling methods are defined for the mouse and keyboard, while the <code>UIResponder</code> methods are defined for the Multi-Touch event model.</p></td></tr><tr><td  scope="row"><p><code>NSWindow</code></p><p><code>UIWindow</code></p></td><td ><p>The <code>UIWindow</code> class occupies a different place in the class hierarchy than does <code>NSWindow</code>; it is a subclass of <code>UIView</code>, whereas the Application Kit class inherits directly from <code>NSResponder</code>. <code>UIWindow</code> has a much more restricted role in an application than does <code>NSWindow</code>. It also provides an area for displaying views, dispatches events to those views, and converts between window and view coordinates.</p></td></tr><tr><td  scope="row"><p><code>NSView</code></p><p><code>UIView</code></p></td><td ><p>These classes are very similar in purpose and in their basic sets of methods. They allow you to move and resize views, manage the view hierarchy, draw view content, and convert view coordinates. The design of <code>UIView</code>, however, makes view objects inherently capable of animation. </p></td></tr><tr><td  scope="row"><p><code>NSControl</code></p><p><code>UIControl</code></p></td><td ><p>Both classes define a mechanism for objects such as buttons and sliders so that, when manipulated, the control object sends an action message to a target object. The classes implement the target-action mechanism in different ways, largely because of the difference between event models. See <span class="content_text"><a href="../CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW14">“The Target-Action Mechanism”</a></span> for information.</p></td></tr><tr><td  scope="row"><p><code>NSViewController</code></p><p><code>UIViewController</code></p></td><td ><p>The role of both of these classes is, as their names suggest, to manage views. How they accomplish this task is different. The management provided by an <code>NSViewController</code> object is dependent on bindings, which is a technology supported only on Mac OS X. <code>UIViewController</code> objects are used in the iPhone OS application model for modal and navigation user interfaces (for example, the views controlled by navigation bars).</p></td></tr><tr><td  scope="row"><p><code>NSTableView</code></p><p><code>UITableView</code></p></td><td ><p><code>NSTableView</code> inherits from <code>NSControl</code>, but <code>UITableView</code> does not inherit from <code>UIControl</code>. More importantly, <code>NSTableView</code> objects support multiple columns of data; <code>UITableView</code> objects display only a single column of data at a time, and thus function more as lists than presentations of tabular data.  </p></td></tr></table></div><p>Among the minor classes you can find some differences too. For example, UIKit has the <code>UITextField</code> and <code>UILabel</code> classes, the former for editable text fields and the latter for non-editable text fields used as labels; with the <code>NSTextField</code> class you can also create both kinds of objects simply by setting text-field attributes. Similarly, the <code>NSProgressIndicator</code> class can create objects in styles that correspond to instances of the <code>UIProgressIndicator</code> and <code>UIProgressBar</code> classes.</p><a name="//apple_ref/doc/uid/TP40002974-CH3-SW54" title="Other Frameworks With Cocoa API"></a><h3>Other Frameworks With Cocoa API</h3><p>As part of a standard installation, Apple includes, in addition to the core frameworks for both platforms, several frameworks that vend Cocoa programmatic interfaces. You can use these secondary frameworks to give your application capabilities that are desirable, if not essential. Some notable secondary frameworks include: </p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1104"></a>Core Data—(Mac OS X only) The Core Data framework helps a program to manage graphs of model objects through their life cycles, including the persistent storage of their data in relational databases or flat files. It includes features such as undo and redo management, automatic validation of values, change propagation, and integration with Cocoa bindings. See <span class="content_text"><a href="../OtherArchitectures/OtherArchitectures.html#//apple_ref/doc/uid/TP40002974-CH10-SW1">“Other Cocoa Architectures on Mac OS X”</a></span> and <em><a href="../../CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_top">Core Data Programming Guide</a></em> for more information.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1105"></a>Sync Services—(Mac OS X only) Using Sync Services you can sync existing contacts, calendars and bookmarks schemas as well as your own application data. You can also extend existing schemas. See <em><a href="../../SyncServices/index.html#//apple_ref/doc/uid/TP40001178" target="_top">Sync Services Programming Guide</a></em> for more information.  </p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1106"></a>Address Book—This framework implements a centralized database for contact and other personal information. Applications that use the Address Book framework can share this contact information with other applications, including Apple’s Mail and iChat. See <em><a href="../../../../UserExperience/Conceptual/AddressBook/index.html#//apple_ref/doc/uid/10000117i" target="_top">Address Book Programming Guide for Mac OS X</a></em> for more information. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH3-SW81" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;There are different versions of this framework on Mac OS X and iPhone OS. In addition, the Address Book framework on iPhone OS has only ANSI C (procedural) programmatic interfaces.</p></div></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1107"></a>Preference Panes—(Mac OS X only) With this framework you can create plug-ins that your application can dynamically load to obtain a user interface for recording user preferences, either for the application itself or system-wide. See <em><a href="../../../../UserExperience/Conceptual/PreferencePanes/index.html#//apple_ref/doc/uid/10000110i" target="_top">Preference Panes</a></em> for more information.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1108"></a>Screen Saver—(Mac OS X only) The Screen Saver framework helps you create Screen Effects modules, which can be loaded and run via System Preferences. See <em><a href="../../../../UserExperience/Reference/ScreenSaver/ObjC_classic/index.html#//apple_ref/doc/uid/20001822" target="_top">Screen Saver Framework Reference</a></em> for more information. </p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1109"></a>Web Kit—(not public on iPhone OS) The Web Kit framework provides a set of core classes to display web content in windows, and by default, implements features such as following links clicked by the user. See <em><a href="../../DisplayWebContent/index.html#//apple_ref/doc/uid/10000164i" target="_top">WebKit Objective-C Programming Guide</a></em> for more information<a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1110"></a>.</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH3-SW12" title="A Bit of History"></a><h2>A Bit of History</h2><p>Many years ago Cocoa was known as <a name="//apple_ref/doc/uid/TP40002974-CH3-DontLinkElementID_1111"></a>NeXTSTEP. NeXT Computer developed and released version 1.0 of NeXTSTEP in September of 1989, and versions 2.0 and 3.0 followed not far behind (in 1990 and 1992, respectively). In this early phase, NEXTSTEP was more than an application environment; the term referred to the entire operating system, including the windowing and imaging system (which was based on Display PostScript), the Mach kernel, device drivers, and so on. </p><p>Back then, there was no Foundation framework. Indeed, there were no frameworks; instead, the software libraries (dynamically shared) were known as kits, the most prominent of them being the Application Kit. Much of the role that Foundation now occupies was taken by an assortment of functions, structures, constants, and other types. The Application Kit itself had a much smaller set of classes than it does today. <span class="content_text">Figure 1-13</span> shows a class hierarchy chart of NeXTSTEP 0.9 (1988).</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH3-SW8" title="Figure 1-13Application Kit class hierarchy in 1988"></a><p><strong>Figure 1-13&nbsp;&nbsp;</strong>Application Kit class hierarchy in 1988</p><img src = "../Art/appkitc_88.gif" alt = "Application Kit class hierarchy in 1988" ></div><br/><p>In addition to the Application Kit, the early NeXTSTEP included the Sound Kit and the Music Kit, libraries containing a rich set of Objective-C classes that provided high-level access to the Display Postscript layer for audio and music synthesis. </p><p>In early 1993 NeXTSTEP 3.1 was ported to (and shipped on) Intel, Sparc, and Hewlett-Packard computers. NeXTSTEP 3.3 also marked a major new direction, for it included a preliminary version of Foundation. Around this time (1993), the OpenStep initiative also took form. OpenStep was a collaboration between Sun and NeXT to port the higher levels of NeXTSTEP (particularly the Application Kit and Display PostScript) to Solaris. The “Open” in the name referred to the open API specification that the companies would publish jointly. The official OpenStep API, published in September of 1994, were the first to split the API between Foundation and Application Kit and the first to use the “NS” prefix.</p><p>By June 1996 NeXT had ported and shipped versions of OpenStep 4.0 that could run Intel, Sparc, and Hewlett-Packard computers as well as an OpenStep runtime that could run on Windows systems. Sun also finished their port of OpenStep to Solaris and shipped it as part of their Network Object Computing Environment. OpenStep, however, never became a significant part of Sun’s overall strategy.</p><p>When Apple acquired NeXT Software (as it was then called) in 1997, OpenStep became the Yellow Box and was included with Mac OS X Server (also known as Rhapsody) and Windows. Then, with the evolution of the Mac OS X strategy, it was finally renamed to “Cocoa.”</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CocoaObjects/CocoaObjects.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-11-19<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/WhatIsCocoa/WhatIsCocoa.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/WhatIsCocoa/WhatIsCocoa.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/WhatIsCocoa/WhatIsCocoa.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>