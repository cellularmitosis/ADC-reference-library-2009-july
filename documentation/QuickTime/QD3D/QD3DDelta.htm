<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"><META NAME="Generator" CONTENT="Microsoft Word 97/98"><script language="JavaScript" src="frametest.js"></script><TITLE>BRIAN&#146;S QD3D MODIFICATIONS</TITLE><script language=javascript> window.parent.focus(); </script></HEAD><BODY bgcolor="#ffffff" LINK="#0000ff"><I><FONT FACE="Charcoal" SIZE=7 COLOR="#ff0000"><P ALIGN="CENTER">QuickDraw 3D 1.6</P></FONT><FONT FACE="Charcoal" SIZE=7 COLOR="#ff0000"><P ALIGN="CENTER"></P><P ALIGN="CENTER">New API Features and Improvements</P></I></FONT><FONT SIZE=2><P ALIGN="CENTER"></P></FONT><FONT FACE="Times"><P ALIGN="CENTER">V4.27.99</P><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="CENTER">QuickDraw 3D</P><P ALIGN="CENTER">Apple Computer, Inc.</P></FONT><FONT FACE="Times" SIZE=4><P ALIGN="CENTER"></P><P ALIGN="CENTER">Robert Dierkes (dierkes.r@apple.com)</P><P ALIGN="CENTER">Stephen Luce (sluce@apple.com)</P><P ALIGN="CENTER">Brian Greenstone</P></FONT><FONT FACE="Times" SIZE=6><P ALIGN="CENTER">TABLE OF CONTENTS</P></FONT><FONT FACE="Times"><P>&nbsp;</P></FONT><B><FONT FACE="Times" SIZE=2><P>FOG STYLES&#9;</B></FONT><A HREF="#_Toc438524087">*</A><FONT FACE="Times" SIZE=2><P>WORKING WITH FOG STYLES&#9;</FONT><A HREF="#_Toc438524088">*</A></P><FONT FACE="Times" SIZE=2><P>NEW API CALLS FOR FOG&#9;</FONT><A HREF="#_Toc438524089">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3FogStyle_New&#9;</I></FONT><A HREF="#_Toc438524090">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3FogStyle_Submit&#9;</I></FONT><A HREF="#_Toc438524091">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3FogStyle_GetData&#9;</I></FONT><A HREF="#_Toc438524092">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3FogStyle_SetData&#9;</I></FONT><A HREF="#_Toc438524093">*</A></P><FONT FACE="Times" SIZE=2><P>FOG SAMPLE CODE&#9;</FONT><A HREF="#_Toc438524094">*</A></P><B><FONT FACE="Times" SIZE=2><P>WORLD RAY PICKING&#9;</B></FONT><A HREF="#_Toc438524095">*</A></P><FONT FACE="Times" SIZE=2><P>CREATING A WORLD RAY PICK OBJECT&#9;</FONT><A HREF="#_Toc438524096">*</A></P><FONT FACE="Times" SIZE=2><P>THE PROCESS OF RAY PICKING&#9;</FONT><A HREF="#_Toc438524097">*</A></P><FONT FACE="Times" SIZE=2><P>MORE ABOUT TOLERANCES&#9;</FONT><A HREF="#_Toc438524098">*</A></P><FONT FACE="Times" SIZE=2><P>OTHER RAY PICKING GUIDELINES&#9;</FONT><A HREF="#_Toc438524099">*</A></P><FONT FACE="Times" SIZE=2><P>DATA STRUCTURES &amp; API FUNCTIONS&#9;</FONT><A HREF="#_Toc438524100">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3WorldRayPick_New&#9;</I></FONT><A HREF="#_Toc438524101">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3WorldRayPick_GetRay&#9;</I></FONT><A HREF="#_Toc438524102">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3WorldRayPick_SetRay&#9;</I></FONT><A HREF="#_Toc438524103">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3WorldRayPick_GetData&#9;</I></FONT><A HREF="#_Toc438524104">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3WorldRayPick_SetData&#9;</I></FONT><A HREF="#_Toc438524105">*</A></P><FONT FACE="Times" SIZE=2><P>WORLD RAY PICKING SAMPLE CODE&#9;</FONT><A HREF="#_Toc438524106">*</A></P><FONT FACE="Times" SIZE=2><P>RELATED API&#146;S&#9;</FONT><A HREF="#_Toc438524107">*</A></P><B><FONT FACE="Times" SIZE=2><P>DISPLAY GROUP CULLING&#9;</B></FONT><A HREF="#_Toc438524108">*</A></P><FONT FACE="Times" SIZE=2><P>API CALLS FOR DISPLAY GROUP CULLING&#9;</FONT><A HREF="#_Toc438524109">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3DisplayGroup_SetAndUseBoundingBox&#9;</I></FONT><A HREF="#_Toc438524110">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3DisplayGroup_CalcAndUseBoundingBox&#9;</I></FONT><A HREF="#_Toc438524111">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3DisplayGroup_GetBoundingBox&#9;</I></FONT><A HREF="#_Toc438524112">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3DisplayGroup_RemoveBoundingBox&#9;</I></FONT><A HREF="#_Toc438524113">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3View_AllowAllGroupCulling&#9;</I></FONT><A HREF="#_Toc438524114">*</A></P><FONT FACE="Times" SIZE=2><P>DISPLAY GROUP CULLING SAMPLE CODE&#9;</FONT><A HREF="#_Toc438524115">*</A></P><B><FONT FACE="Times" SIZE=2><P>COMPRESSED PIXMAP&#9;</B></FONT><A HREF="#_Toc438524116">*</A></P><FONT FACE="Times" SIZE=2><P>COMPRESSED PIXMAP SAMPLES&#9;</FONT><A HREF="#_Toc438524117">*</A></P><FONT FACE="Times" SIZE=2><P>STRUCTURES AND API FUNCTIONS&#9;</FONT><A HREF="#_Toc438524118">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3CompressedPixmapTexture_CompressImage&#9;</I></FONT><A HREF="#_Toc438524119">*</A></P><FONT FACE="Times" SIZE=2><P>COMPRESSED PIXMAP EXAMPLE&#9;</FONT><A HREF="#_Toc438524120">*</A></P><FONT FACE="Times" SIZE=2><P>COMPRESSED PIXMAPS IN 3DMF FILES&#9;</FONT><A HREF="#_Toc438524121">*</A></P><B><FONT FACE="Times" SIZE=2><P>GETTING THE RAVE DRAW CONTEXTS&#9;</B></FONT><A HREF="#_Toc438524122">*</A></P><FONT FACE="Times" SIZE=2><P>NEW API FUNCTIONS&#9;</FONT><A HREF="#_Toc438524123">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3InteractiveRenderer_CountRAVEDrawContexts&#9;</I></FONT><A HREF="#_Toc438524124">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3InteractiveRenderer_GetRAVEDrawContexts&#9;</I></FONT><A HREF="#_Toc438524125">*</A></P><B><FONT FACE="Times" SIZE=2><P>NEW VIEWER FUNCTIONS&#9;</B></FONT><A HREF="#_Toc438524126">*</A></P><FONT FACE="Times" SIZE=2><P>FLY-THRU MODE&#9;</FONT><A HREF="#_Toc438524127">*</A></P><FONT FACE="Times" SIZE=2><P>THE OPTIONS BUTTON&#9;</FONT><A HREF="#_Toc438524128">*</A></P><FONT FACE="Times" SIZE=2><P>RESIZING THE VIEWER PANE INSIDE THE  WINDOW&#9;</FONT><A HREF="#_Toc438524129">*</A></P><FONT FACE="Times" SIZE=2><P>NEW API FUNCTIONS&#9;</FONT><A HREF="#_Toc438524130">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerSetRendererType&#9;</I></FONT><A HREF="#_Toc438524131">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerGetRendererType&#9;</I></FONT><A HREF="#_Toc438524132">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerChangeBrightness&#9;</I></FONT><A HREF="#_Toc438524133">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerSetRemoveBackfaces&#9;</I></FONT><A HREF="#_Toc438524134">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerGetRemoveBackfaces&#9;</I></FONT><A HREF="#_Toc438524135">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerSetPhongShading&#9;</I></FONT><A HREF="#_Toc438524136">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerGetPhongShading&#9;</I></FONT><A HREF="#_Toc438524137">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerSetWindowResizeCallback&#9;</I></FONT><A HREF="#_Toc438524138">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerSetPaneResizeNotifyCallback&#9;</I></FONT><A HREF="#_Toc438524139">*</A></P><I><FONT FACE="Times" SIZE=2><P>Q3ViewerSetDrawingCallbackMethod&#9;</I></FONT><A HREF="#_Toc438524140">*</A></P><B><FONT FACE="Times" SIZE=2><P>MISCELLANEA&#9;</B></FONT><A HREF="#_Toc438524141">*</A></P><FONT FACE="Times" SIZE=2><P>INTERACTIVE RENDERER MODIFICATIONS&#9;</FONT><A HREF="#_Toc438524142">*</A></P><FONT FACE="Times" SIZE=2><P>QUICKDRAW 3D MODIFICATIONS&#9;</FONT><A HREF="#_Toc438524143">*</A></P><FONT FACE="Times"></P><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Helvetica" SIZE=6 COLOR="#000000"><P ALIGN="CENTER"><A NAME="_Toc438524087">FOG STYLES</A></P></B></FONT><FONT FACE="Times"><P>QuickDraw 3D 1.6 now has a Fog Style Objects which will allow you to do atmospheric effects in your 3D applications.  Most 3D accelerator cards will work with the new Fog Style once they update their drivers for RAVE 1.6, and even the RAVE 1.6 software rasterizer can now render fogged scenes.</P></FONT><FONT SIZE=2><P ALIGN="CENTER"><IMG SRC="Image15.gif" WIDTH=412 HEIGHT=328></P></FONT><FONT FACE="Times"><P ALIGN="CENTER">A single textured triangle rendered with white fog</P><P>&nbsp;</P><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524088"></P><P>WORKING WITH FOG STYLES</A></P></B></I></U></FONT><FONT FACE="Times"><P>Fog Style Objects are created like any other Style Object, but they take the </FONT><FONT FACE="Monaco" SIZE=1>TQ3FogStyleData</FONT><FONT FACE="Times"> as input.  The new fog types and structures can be found in </FONT><FONT FACE="Monaco" SIZE=1>QD3DStyle.h.</P></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>struct TQ3FogStyleData</P><P>{</P><P>TQ3Switch &#9;&#9;&#9;state;</P><P>&#9;&#9;TQ3FogMode &#9;&#9;mode;</P><P>&#9;float &#9;&#9;&#9;&#9;fogStart;</P><P>&#9;&#9;float &#9;&#9;&#9;&#9;fogEnd;</P><P>&#9;float &#9;&#9;&#9;&#9;density;</P><P>&#9;&#9;TQ3ColorARGB&#9; &#9;color;</P><P>}</P><P>enum TQ3FogMode</P><P>{</P><P>kQ3FogModeLinear&#9;&#9;&#9;&#9;&#9;&#9;= 0,</P><P>&#9;&#9;kQ3FogModeExponential&#9;&#9;&#9;&#9;&#9;= 1,</P><P>&#9;&#9;kQ3FogModeExponentialSquared &#9;&#9;= 2,</P><P>&#9;&#9;kQ3FogModeAlpha&#9;&#9;&#9;&#9;&#9;&#9;&#9;= 3</P><P>};</P></FONT><FONT FACE="Times"><P>The </FONT><FONT FACE="Monaco" SIZE=1>state</FONT><FONT FACE="Times"> field indicates whether the fog is on or off.  The </FONT><FONT FACE="Monaco" SIZE=1>mode</FONT><FONT FACE="Times"> field indicates how the fog increases in density as you look into the distance.</P></FONT><FONT FACE="Monaco" SIZE=1><P>kQ3FogModeLinear</FONT><FONT FACE="Times">&#9;&#9;&#9;&#9;&#9;&#9;&#9;fog = (end &#151; z) / (end &#151; start)</P></FONT><FONT FACE="Monaco" SIZE=1><P>kQ3FogModeExponential</FONT><FONT FACE="Times">&#9;&#9;&#9;&#9;&#9;&#9;fog = exp(- density * z)</P></FONT><FONT FACE="Monaco" SIZE=1><P>kQ3FogModeExponentialSquared</FONT><FONT FACE="Times">&#9;&#9;&#9;fog = exp(- density * z * density * z)</P></FONT><FONT FACE="Monaco" SIZE=1><P>kQ3FogModeAlpha</FONT><FONT FACE="Times">&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;fog = vertex alpha</P></FONT><I><FONT FACE="Monaco" SIZE=1><P>kQ3FogModeLinear</P></I></FONT><FONT FACE="Times"><P>The </FONT><FONT FACE="Monaco" SIZE=1>fogStart</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Monaco" SIZE=1>fogEnd</FONT><FONT FACE="Times"> values determine the starting and ending points for the fog.  Normally, you will want to set </FONT><FONT FACE="Monaco" SIZE=1>fogEnd</FONT><FONT FACE="Times"> to your camera&#146;s yon value, but the </FONT><FONT FACE="Monaco" SIZE=1>fogStart</FONT><FONT FACE="Times"> value can be any distance depending on the effect you want to achieve.  Most applications will start the fog from 1/3 to 1/2 the distance between the camera and the yon plane.  Most applications do not look too good if you set the </FONT><FONT FACE="Monaco" SIZE=1>fogStart</FONT><FONT FACE="Times"> to your hither value.  This causes too much fog and gives a &quot;smoky room&quot; appearance.</P></FONT><I><FONT FACE="Monaco" SIZE=1><P>kQ3FogModeExponential</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Monaco" SIZE=1>kQ3FogModeExponentialSquared</P></I></FONT><FONT FACE="Times"><P>The </FONT><FONT FACE="Monaco" SIZE=1>density</FONT><FONT FACE="Times"> field determines how dense the fog will get at the </FONT><FONT FACE="Monaco" SIZE=1>fogEnd</FONT><FONT FACE="Times"> distance for these fog modes.  To make a scene go completely to fog, you should set this to 1.0.  But if you only want a partial fog for a misty effect, then set it to something lower like 0.5 or 0.8.</P></FONT><I><FONT FACE="Monaco" SIZE=1><P>kQ3FogModeAlpha</FONT><FONT FACE="Times"> </P></I><P>This fog mode is a little different.  Normally, the &quot;fog&quot; to apply to a particular vertex of a triangle is determined by how far away that vertex is from the camera.  With </FONT><FONT FACE="Monaco" SIZE=1>kQ3FogModeAlpha</FONT><FONT FACE="Times">  the amount of fog to apply to the vertex is determined by the vertex&#146;s alpha value. So fog and alpha blending cannot be used with the alpha fog mode. This is mainly used to achieve special effects and not necessarily &quot;fog&quot;.  </P><P>In general, you will want to set your fog color to your clear color.  Remember that the fog only affects drawn triangles, therefore, any pixels on the screen which are not occupied by triangles will still show the background color.  If, for example, your clear color is black yet your fog is white, then your triangles will fog to white in the distance, but all the &quot;blank&quot; space around the triangles will still be black &#151; not a desirable effect.</P><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524089">NEW API CALLS FOR FOG</A></P></B></I></U></FONT><FONT FACE="Times"></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524090">Q3FogStyle_New</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3StyleObject&#9;Q3FogStyle_New (const TQ3FogStyleData&#9;*data);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">data&#9;</FONT><FONT FACE="Palatino">A pointer to a structure containing the fog parameters.</P></FONT><FONT FACE="Times"><P>&#9;&#9;</P><B><P>output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3StyleObject&#9;</FONT><FONT FACE="Palatino">A fog style object.</P></FONT><FONT FACE="Times"><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function returns a reference to a new fog style object based on the input parameters.</P></FONT><FONT FACE="Times"><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524091">Q3FogStyle_Submit</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status&#9;Q3FogStyle_Submit (</P><P>const TQ3FogStyleData&#9;*data</P><P>TQ3ViewObject&#9;&#9;view);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">data&#9;</FONT><FONT FACE="Palatino">A pointer to a structure containing the fog parameters.</P></FONT><FONT FACE="Times"><P>&#9;v</FONT><FONT FACE="Monaco">iew</FONT><FONT FACE="Times">&#9;A view Object to submit to.</P><P>&#9;&#9;</P><B><P>output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Palatino"> if submit was successful.</P></FONT><FONT FACE="Times"><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function submits Fog Style data to the input view.</P></FONT><FONT FACE="Times"><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524092">Q3FogStyle_GetData</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status&#9;Q3FogStyle_GetData (</P><P>TQ3StyleObject&#9;styleObject</P><P>TQ3FogStyleData&#9;*data);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">styleObject</FONT><FONT FACE="Times">&#9;The Fog Style Object who&#146;s data you wish to get.</P><P>&#9;</FONT><FONT FACE="Monaco">data&#9;</FONT><FONT FACE="Palatino">A pointer to a structure to get the fog parameters.</P></FONT><FONT FACE="Times"><P>&#9;&#9;</P><B><P>output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Palatino"> if data was retrieved.</P></FONT><FONT FACE="Times"><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function gets the data from a Fog Style Object.</P></FONT><FONT FACE="Times"><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524093">Q3FogStyle_SetData</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status&#9;Q3FogStyle_SetData (</P><P>TQ3StyleObject&#9;&#9;styleObject</P><P>const TQ3FogStyleData&#9;*data);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">styleObject</FONT><FONT FACE="Times">&#9;The Fog Style Object who&#146;s data you wish to set.</P><P>&#9;</FONT><FONT FACE="Monaco">data&#9;</FONT><FONT FACE="Palatino">A pointer to a structure containing the fog data.</P></FONT><FONT FACE="Times"><P>&#9;&#9;</P><B><P>output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Palatino"> if data was set successfully.</P></FONT><FONT FACE="Times"><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function sets the data in a Fog Style Object.</P></FONT><FONT FACE="Times"><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524094">FOG SAMPLE CODE</A></P></B></I></U></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3ColorARGB&#9;&#9;gClearColor = {1,1,1,1};&#9;// clear color is white</P><P>TQ3StyleObject CreateMyFogStyleObject(void)</P><P>{</P><P>&#9;TQ3FogStyleData&#9;&#9;fogData;</P><P>&#9;TQ3StyleObject&#9;&#9;fogObj;</P><P>&#9;&#9;&#9;/* SET MY PARAMETERS */</P><P>&#9;fogData.state &#9;&#9;= kQ3On;&#9;&#9;&#9;&#9;&#9;&#9;// fog is on</P><P>&#9;fogData.mode &#9;&#9;&#9;= kQ3FogModeLinear;&#9;&#9;// fog is linear</P><P>&#9;fogData.fogStart &#9;= MY_HITHER;&#9;&#9;&#9;&#9;&#9;// start in front</P><P>&#9;fogData.fogEnd&#9;&#9;= MY_YON;&#9;&#9;&#9;&#9;&#9;&#9;// end in back</P><P>&#9;fogData.density &#9;= 1.0;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// goes totally foggy at yon</P><P>&#9;fogData.color&#9;&#9;&#9;= gClearColor;&#9;&#9;&#9;&#9;// fog color = clear color</P><P>&nbsp;</P><P>&#9;&#9;&#9;/* MAKE NEW OBJECT */</P><P>&#9;&#9;&#9;</P><P>&#9;fogObj = Q3FogStyle_New(&amp;fogData);</P><P>&#9;return(fogObj);</P><P>}</P></FONT><FONT FACE="Times"><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Helvetica" SIZE=6 COLOR="#000000"><P ALIGN="CENTER"><A NAME="_Toc438524095">WORLD RAY PICKING</A></P></B></FONT><FONT FACE="Palatino"></FONT><FONT FACE="Times"><P>World ray picking is a new pick object type introduced with QuickDraw 3D 1.6 which helps applications detect which geometric objects are close to each other in world-space with respect to a ray vector.</P><P>To demonstrate a common use of world ray picking, imagine an interactive 3D application where an object, perhaps a character, moves through a scene amongst a number of other objects.  Here we need to know what objects are in the character&#146;s path so they can be avoided or just determine if something is close enough to be selected.  Not all of these other neighboring objects may be visible from the camera&#146;s point of view, which precludes us from using the familiar window point pick type in this scenario.  To address this a new kind of geometric entity is needed that can be placed anywhere in the scene, not just positioned at the camera&#146;s location.  World ray picking provides this and allows us to locate a ray anywhere in world-space, like at key points on the character&#146;s extremities, pointing in any direction.  When the ray pick object is submitted with the scene QuickDraw 3D computes which geometries intersect with the ray.  With this information the application can then decide how to reposition the character or have it interact with other surrounding objects.</P><P>As you make notice world ray picking differs from window point and window rectangle picking in that it does not perform hit testing from the camera&#146;s point of view.  Rather it uses an application controlled arbitrary ray which makes it a more generalized means of interacting with objects in a scene. </P><P>&nbsp;</P><P>World ray picking supports the following geometry types.</P><B><P>Linear</B>:&#9;Point, Line, PolyLine, and Ellipse</P><B><P>Polygonal</B>:&#9;Triangle, Box, Polygon, General Polygon, Polyhedron, Mesh, trimmest, and TriGrid</P><B><P>Quadrics/Conics</B>:&#9;Cone, Cylinder, Disk, Ellipsoid, and Torus</P><B><P>Parametric</B>:&#9;NURB Curve and NURB Patch</P><B><P>Unsupported</B>:&#9;Marker, Pixmap Marker <I>(ray picking doesn&#146;t make sense for these geometries)</P></I><P>&nbsp;</P><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524096">CREATING A WORLD RAY PICK OBJECT</A></P></B></I></U></FONT><FONT FACE="Palatino"></FONT><FONT FACE="Times"><P>The </FONT><FONT FACE="Monaco" SIZE=1>TQ3WorldRayPickData</FONT><FONT FACE="Times"> data structure is defined as:</P></FONT><FONT FACE="Monaco" SIZE=1><P>struct TQ3WorldRayPickData </P><P>{</P><P>&#9;&#9;TQ3PickData &#9;&#9;data;</P><P>&#9;&#9;TQ3Ray3D &#9;&#9;&#9;ray;</P><P>&#9;&#9;float &#9;&#9;&#9;&#9;vertexTolerance;</P><P>&#9;&#9;float &#9;&#9;&#9;&#9;edgeTolerance;</P><P>};</P><P>typedef struct TQ3WorldRayPickData&#9;&#9;TQ3WorldRayPickData;</P></FONT><FONT FACE="Palatino"></FONT><FONT FACE="Times"><P>The </FONT><FONT FACE="Monaco" SIZE=1>data</FONT><FONT FACE="Times"> field contains general picking information common to all pick types.  Essentially it describes in what order hits should be sorted, the kinds of information to be calculated when an intersection is found (known as the &quot;pick detail&quot;), and the maximum number of hits to be accumulated and returned in a pick object&#146;s hit list.</P><P>The </FONT><FONT FACE="Monaco" SIZE=1>ray</FONT><FONT FACE="Times"> field holds the pick&#146;s ray origin point in world-space coordinates and a direction vector.  An important thing to note about this ray direction vector is that it must be normalized before it&#146;s passed into the </FONT><FONT FACE="Monaco" SIZE=1>Q3WorldRayPick_New</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Monaco" SIZE=1>Q3WorldRayPick_SetRay</FONT><FONT FACE="Times"> functions.  The debug library will post a warning if the ray isn&#146;t normalized and return a failure status.  Note however the optimized library will accept the ray but possible undesirable hits or erroneous hits may result.  It is the responsibility of the application to ensure the ray is normalized before passing it to QuickDraw 3D.</P><P>The last fields, </FONT><FONT FACE="Monaco" SIZE=1>vertexTolerance</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Monaco" SIZE=1>edgeTolerance</FONT><FONT FACE="Times">, specify the maximum distance allowed between the projected pick ray and where it intersects the geometry.  These tolerance values are specified in world-space coordinates.</P></FONT><FONT FACE="Palatino"><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524097">THE PROCESS OF RAY PICKING</A></P></B></I></U></FONT><FONT FACE="Palatino"></FONT><FONT FACE="Times"><P>The process of ray picking is very similar to that of the other two pick types.  During this process scene objects are submitted in a picking loop to find those geometries which intersect the world ray.  The world ray is extended from its origin in the direction of the unit vector and geometries are tested to see if they fall with the given tolerance values or directly intersect the ray.</P><P>After submitting the scene an application gets the number of hits with </FONT><FONT FACE="Monaco" SIZE=1>Q3Pick_GetNumHits</FONT><FONT FACE="Times">, uses </FONT><FONT FACE="Monaco" SIZE=1>Q3Pick_GetPickDetailValidMask </FONT><FONT FACE="Times">to find which kinds of pick detail information are available for an individual hit, and then calls </FONT><FONT FACE="Monaco" SIZE=1>Q3Pick_GetPickDetailData</FONT><FONT FACE="Times"> to retrieve the pick detail data that was requested and is relevant for a given hit.</P><P>A special note: as is the case with all pick types requesting some kinds of pick detail hit information from </FONT><FONT FACE="Monaco" SIZE=1>Q3Pick_GetPickDetailData</FONT><FONT FACE="Times"> are objects that should be disposed by the application to avoid leaked objects.  Specifically, this applies to the hit path, the geometry object, and the shape part object.</P></FONT><P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=337><TR><TD WIDTH="55%" VALIGN="MIDDLE" HEIGHT=98><U><FONT FACE="Times"><P>TQ3PickDetailMasks</P></U></FONT><FONT FACE="Monaco" SIZE=1><P>kQ3PickDetailMaskPath</P><P>kQ3PickDetailMask Object</P><P>kQ3PickDetailMask ShapePart</FONT></TD><TD WIDTH="45%" VALIGN="MIDDLE" HEIGHT=98><U><FONT FACE="Times"><P>Means of disposing object</P></U></FONT><FONT FACE="Monaco" SIZE=1><P>Q3HitPath_EmptyData</P><P>Q3Object_Dispose</P><P>Q3Object_Dispose</FONT></TD></TR></TABLE></P><FONT FACE="Palatino"><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524098">MORE ABOUT TOLERANCES</A></P></B></I></U></FONT><FONT FACE="Palatino"></FONT><FONT FACE="Times"><P>As mentioned earlier, edge and vertex tolerance values for world ray picking are specified in positive world-space.  This coordinate space differs from window point picking and window rectangle picking, where vertex and edge tolerance values are measured in window space and correspond to screen pixels instead.</P><P>Vertex and edge tolerances apply to the geometry types shown below.  With mesh geometries these tolerances are only enabled when the mesh is submitted together with a pick part style, i.e. when the </FONT><FONT FACE="Monaco" SIZE=1>kQ3PickPartsMaskVertex</FONT><FONT FACE="Times"> and/or </FONT><FONT FACE="Monaco" SIZE=1>kQ3PickPartsMaskEdge</FONT><FONT FACE="Times"> parts settings are used.  Ray picking for all other geometries not shown in this table is done on a polygonal face basis.</P></FONT><P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=280><TR><TD WIDTH="31%" VALIGN="TOP" HEIGHT=140><FONT FACE="Times"><P>&nbsp;</P><U><P>Geometry</P></U><P>Point</P><P>Line</P><P>Ellipse</P><P>NURB Curve</P><P>Poly Line</P><P>Mesh</P><P>All other types</FONT></TD><TD WIDTH="23%" VALIGN="TOP" HEIGHT=140><FONT FACE="Times"><P ALIGN="RIGHT">Tolerance </P><U><P ALIGN="CENTER">Vertex</P></U><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</FONT></TD><TD WIDTH="23%" VALIGN="TOP" HEIGHT=140><FONT FACE="Times"><P>Used</P><U><P ALIGN="CENTER">Edge</P></U><P ALIGN="CENTER"></P><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</P><P ALIGN="CENTER">&#149;</FONT></TD><TD WIDTH="23%" VALIGN="TOP" HEIGHT=140><U><FONT FACE="Times"><P ALIGN="CENTER"></P><P ALIGN="CENTER">Face</U> </P><P ALIGN="CENTER"></P><P ALIGN="CENTER">&nbsp;</P><P ALIGN="CENTER">&nbsp;</P><P ALIGN="CENTER">&nbsp;</P><P ALIGN="CENTER">&nbsp;</P><P ALIGN="CENTER">&nbsp;</P><P ALIGN="CENTER">&#149;</FONT></TD></TR></TABLE></CENTER></P><FONT FACE="Times"><P>&nbsp;</P></FONT><FONT FACE="Palatino"><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524099">OTHER RAY PICKING GUIDELINES</A></P></B></I></U></FONT><FONT FACE="Palatino"></FONT><FONT FACE="Times"><P>When the </FONT><FONT FACE="Monaco" SIZE=1>TQ3PickDetail</FONT><FONT FACE="Times"> mask </FONT><FONT FACE="Monaco" SIZE=1>kQ3PickDetailMaskDistance</FONT><FONT FACE="Times"> is specified the distance returned is measured from the ray origin to the actual intersection on the geometry.</P><P>Generally the vertex tolerance should be larger than the edge tolerance if you wish hits on vertices to have precedence over edge hits.  Too many multiple hits may be returned if the pick tolerances are too large and the </FONT><FONT FACE="Monaco" SIZE=1>numHitsToReturn</FONT><FONT FACE="Times"> setting is equal to 0 (return all hits) or greater than 1.  This typically happens when:</P><P>&#149;&#9;2 or more geometries are close together and the tolerance(s) values are large enough to include several of these geometries.</P><P>&#149;&#9;2 or more separate line segments of the same geometry are close together or adjacent segments and the tolerance value(s) are large.  This is possible with polylines, ellipses, or NURB curves.</P><P>Therefore, it may be necessary for an application to use tolerance values appropriate for the size of a model&#146;s scale.</P></FONT><FONT FACE="Palatino"><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524100">DATA STRUCTURES &amp; API FUNCTIONS</A></P></B></I></U></FONT><FONT FACE="Palatino"><B><P>TQ3WorldRayPickData</P></B></FONT><FONT FACE="Monaco" SIZE=1><P>struct TQ3WorldRayPickData</P><P>{</P><P>TQ3PickData &#9;&#9;data;</P><P>&#9;TQ3Ray3D &#9;&#9;&#9;ray;</P><P>&#9;&#9;float &#9;&#9;&#9;&#9;vertexTolerance;</P><P>&#9;&#9;float &#9;&#9;&#9;&#9;edgeTolerance;</P><P>};</P><P>typedef struct TQ3WorldRayPickData&#9;TQ3WorldRayPickData;</P></FONT><FONT FACE="Palatino"><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524101">Q3WorldRayPick_New</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3PickObject&#9;&#9;Q3WorldRayPick_New (</P><P>const  TQ3WorldRayPickData  &#9;*data);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">data&#9;</FONT><FONT FACE="Palatino">A pointer to a structure containing general pick data to be calculated, the ray&#146;s origin and direction vector, and world vertex and edge tolerances.</P></FONT><FONT FACE="Times"><P>&#9;&#9;</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3PickObject&#9;</FONT><FONT FACE="Palatino">A world ray pick object is created and returned if the input data was valid.</P></FONT><FONT FACE="Times"><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function returns a reference to a new world pick ray object created from the given pick data, ray vector, and vertex and edge tolerances.  The passed ray origin is in world-space coordinates and the direction vector must be normalized.  The vertex and edge tolerance values are measured in world-space coordinates and should be positive values.  See the earlier section on tolerance values for more details.</P><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524102">Q3WorldRayPick_GetRay</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status&#9;Q3WorldRayPick_GetRay (</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TQ3PickObject &#9;&#9;pick,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TQ3Ray3D&#9;&#9;&#9;&#9;*ray);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">pick&#9;</FONT><FONT FACE="Palatino">A reference to a world ray pick object.</P></FONT><FONT FACE="Times"><P>&#9;&#9;</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Palatino">Returns </FONT><FONT FACE="Courier">kQ3Succcess</FONT><FONT FACE="Palatino"> if the ray was copied from the pick object.</P></FONT><FONT FACE="Courier"><P>&#9;</FONT><FONT FACE="Monaco">ray</FONT><FONT FACE="Palatino">&#9;A pointer for the returned ray data.</P></FONT><FONT FACE="Times"><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function copies and returns the ray&#146;s origin point and direction vector into the passed </FONT><FONT FACE="Monaco" SIZE=1>TQ3Ray3D</FONT><FONT FACE="Palatino"> structure from the pick object.</P><B><P>&nbsp;</P></FONT><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524103">Q3WorldRayPick_SetRay</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status&#9;Q3WorldRayPick_SetRay (</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TQ3PickObject &#9;&#9;&#9;pick,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const TQ3Ray3D&#9;&#9;&#9;*ray);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">pick&#9;</FONT><FONT FACE="Palatino">A reference to a world ray pick object.</P></FONT><FONT FACE="Courier"><P>&#9;ray</FONT><FONT FACE="Palatino">&#9;A pointer for the new ray data to be set on the pick object.</P></FONT><FONT FACE="Times"><P>&#9;&#9;</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Palatino">Returns </FONT><FONT FACE="Courier">kQ3Succcess</FONT><FONT FACE="Palatino"> if the passed ray was copied from the pick object.  With the debug library installed, </FONT><FONT FACE="Courier">kQ3Failure</FONT><FONT FACE="Palatino"> is returned if the ray passed in isn't normalized.</P></FONT><FONT FACE="Times"><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function replaces the ray&#146;s origin point and direction vector of the pick object with the given ray.  The ray origin is assumed to be in world-space coordinates and the direction must be normalized.</P><P>&nbsp;</P><B><P>&nbsp;</P></FONT><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524104">Q3WorldRayPick_GetData</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status&#9;Q3WorldRayPick_GetData (</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TQ3PickObject &#9;&#9;&#9;pick,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TQ3WorldRayPickData&#9;*rayPickData);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">pick&#9;</FONT><FONT FACE="Palatino">A reference to a world ray pick object.</P></FONT><FONT FACE="Times"><P>&#9;&#9;</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Palatino">Returns </FONT><FONT FACE="Courier">kQ3Succcess</FONT><FONT FACE="Palatino"> if the ray pick data was retrieved the pick object.</P></FONT><B><FONT FACE="Times"><P>&#9;</B></FONT><FONT FACE="Monaco">rayPickData</FONT><FONT FACE="Palatino">&#9;A pointer for the returned world ray pick data.</P></FONT><FONT FACE="Times"><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function copies all world ray pick data into the passed </FONT><FONT FACE="Monaco" SIZE=1>TQ3WorldRayPickData</FONT><FONT FACE="Palatino"> structure from the pick object.</P><P>&nbsp;</P><B><P>&nbsp;</P></FONT><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524105">Q3WorldRayPick_SetData</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status&#9;Q3WorldRayPick_SetData (</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TQ3PickObject &#9;&#9;&#9;&#9;&#9;&#9;pick,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const TQ3WorldRayPickData&#9;&#9;*rayPickData);</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">pick&#9;</FONT><FONT FACE="Palatino">A reference to a world ray pick object.</P></FONT><B><FONT FACE="Times"><P>&#9;</B></FONT><FONT FACE="Monaco">rayPickData</FONT><FONT FACE="Palatino">&#9;A pointer to world ray pick data.</P></FONT><FONT FACE="Times"><P>&#9;&#9;</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Palatino">Returns </FONT><FONT FACE="Courier">kQ3Succcess</FONT><FONT FACE="Palatino"> if the ray pick data was valid and set on the pick object.</P></FONT><FONT FACE="Times"><P>&nbsp;</P><P>&#9;</P><B><P>Info:</B>&#9;</FONT><FONT FACE="Palatino">This function replaces the data in the world ray pick object with the data from passed </FONT><FONT FACE="Monaco" SIZE=1>TQ3WorldRayPickData</FONT><FONT FACE="Palatino"> structure.  The passed ray origin is specified in world-space coordinates.  The data contained in the structure must be valid and the ray&#146;s direction must be normalized.</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P>&nbsp;</P><P><A NAME="_Toc438524106">WORLD RAY PICKING SAMPLE CODE</A></P></B></I></U></FONT><FONT FACE="Times"><P>The following example shows how to create a ray pick object and change the ray to move it through a scene.  Using the view and model group passed to the main function it repositions the ray pick at various locations along a circle to find objects that fall in this circular path.  In the HandleHit call the application could check if the object hit is at an acceptable distance by using the pick detail mask </FONT><FONT FACE="Monaco" SIZE=1>kQ3PickDetailMask Distance</FONT><FONT FACE="Times">. </P></FONT><FONT FACE="Courier" SIZE=2></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status RayPickingSample(</P><P>&#9;TQ3ViewObject&#9;&#9;&#9;view,</P><P>&#9;TQ3GroupObject&#9;&#9;model)</P><P>{</P><P>&#9;TQ3Status&#9;&#9;&#9;status = kQ3Failure;</P><P>&#9;TQ3Ray3D&#9;&#9;&#9;worldRay;</P><P>&#9;TQ3PickObject&#9;&#9;pick = NULL;</P><P>&#9;unsigned long &#9;numHits = 0;</P><P>&#9;float&#9;&#9;&#9;&#9;&#9;angle = 0.0;</P><P>&#9;#define&#9;&#9;kRadius&#9;&#9;10.0</P><P>&#9;#define&#9;&#9;kStep&#9;&#9;&#9;15.0</P><P>&#9;/* Set initial ray origin and direction */</P><P>&#9;Q3Point3D_Set(&amp;worldRay.origin, 0.0, 0.0, 0.0);</P><P>&#9;Q3Vector3D_Set(&amp;worldRay.direction, 1.0, 0.0, 0.0);</P><P> &#9;pick = CreateWorldRayPick(&amp;worldRay);</P><P> &#9;if (pick == NULL) {</P><P> &#9;&#9;return kQ3Failure;</P><P> &#9;}</P><P>&#9;/*</P><P>&#9; * Move the ray's origin in a circular path in the XZ-plane</P><P>&#9; * keeping the direction vector tangent to this circle.</P><P>&#9; */</P><P>&#9;for (angle = 0.0;</P><P>&#9;&#9; angle &lt;= Q3Math_DegreesToRadians(360.0);</P><P>&#9;&#9; angle += Q3Math_DegreesToRadians(kStep)) {</P><P>&#9;&#9;/* Position ray's origin */</P><P>&#9;&#9;Q3Point3D_Set(&amp;worldRay.origin,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;cos(angle) * kRadius,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;0.0,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;sin(angle) * kRadius);</P><P>&#9;&#9;/* Set a new ray direction as a tanget to the circle */</P><P>&#9;&#9;worldRay.direction.x =  -sin(angle);</P><P>&#9;&#9;worldRay.direction.z =   cos(angle);</P><P>&#9;&#9;/* Change ray in pick */</P><P>&#9;&#9;Q3Vector3D_Normalize(&amp;worldRay.direction, &amp;worldRay.direction);</P><P>&#9;&#9;status = Q3WorldRayPick_SetRay(pick, &amp;worldRay);</P><P>&#9;&#9;/* Test if any scene objects intersect the ray */</P><P>&#9;&#9;status = Pick_Model(view, model, pick, &amp;numHits);</P><P>&#9;&#9;if ((status == kQ3Success)  &amp;&amp;  (numHits &gt; 1)) {</P><P>&#9;&#9;&#9;HandleHit(pick, model);</P><P>&#9;&#9;}</P><P>&#9;}</P><P>&#9;if (pick != NULL) {</P><P>&#9;&#9;Q3Object_Dispose(pick);</P><P>&#9;&#9;pick = NULL;</P><P>&#9;}</P><P>&#9;return kQ3Success;</P><P>}</P><P>&nbsp;</P><P>/*</P><P> * Sets up and create a world ray pick object</P><P> */</P><P>TQ3PickObject CreateWorldRayPick(</P><P>&#9;TQ3Ray3D&#9;&#9;&#9;*pWorldRay)</P><P>{</P><P>&#9;TQ3WorldRayPickData&#9;&#9;rayPickData;</P><P>&#9;TQ3PickObject&#9;&#9;&#9;&#9;&#9;pickObject = NULL;</P><P>&#9;rayPickData.data.sort =&#9; kQ3PickSortNearToFar;</P><P>&#9;rayPickData.data.mask = &#9;kQ3PickDetailMaskObject&#9;&#9;&#9;|</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;kQ3PickDetailMaskXYZ&#9;&#9;&#9;&#9;|</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;kQ3PickDetailMaskDistance&#9;&#9;|</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;kQ3PickDetailMaskNormal;</P><P>&#9;rayPickData.data.numHitsToReturn = 1;</P><P>&#9;/* Make sure ray is normalized  */</P><P>&#9;Q3Vector3D_Normalize(&amp;pWorldRay-&gt;direction, &amp;pWorldRay-&gt;direction);</P><P>&#9;rayPickData.ray = *pWorldRay;</P><P>&#9;/* Tolerance values are measured in world space. */</P><P>&#9;rayPickData.vertexTolerance&#9;&#9;= 0.01;</P><P>&#9;rayPickData.edgeTolerance&#9;&#9;&#9;= 0.005;</P><P>&#9;/* Create the new world ray pick object */</P><P>&#9;pickObject = Q3WorldRayPick_New(&amp;rayPickData);</P><P>&#9;return pickObject;</P><P>}</P><P>&nbsp;</P><P>/*</P><P> * A basic picking submit loop</P><P> */</P><P>TQ3Status Pick_Model(</P><P>&#9;TQ3ViewObject&#9;&#9;&#9;viewObj,</P><P>&#9;TQ3GroupObject&#9;&#9;modelObj,</P><P>&#9;TQ3PickObject&#9;&#9;&#9;pickObj,</P><P>&#9;unsigned long &#9;&#9;*pNumHits)</P><P>{</P><P>&#9;TQ3Status&#9;&#9;&#9;status     = kQ3Failure;</P><P>&#9;TQ3ViewStatus&#9;&#9;viewStatus = kQ3ViewStatusError;</P><P>&#9;if (Q3View_StartPicking(viewObj, pickObj) == kQ3Success) {</P><P>&#9;&#9;do {</P><P>&#9;&#9;&#9;Q3DisplayGroup_Submit(modelObj, viewObj);</P><P>&#9;&#9;&#9;viewStatus = Q3View_EndPicking(viewObj);</P><P>&#9;&#9;} while (viewStatus == kQ3ViewStatusRetraverse);</P><P>&#9;&#9;if (viewStatus == kQ3ViewStatusDone) {</P><P>&#9;&#9;&#9;status = Q3Pick_GetNumHits(pickObj, pNumHits);</P><P>&#9;&#9;}</P><P>&#9;}</P><P>&#9;return status;</P><P>}</P></FONT><FONT FACE="Times"><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524107">RELATED API&#146;S</A></P></B></I></U></FONT><FONT FACE="Palatino"></FONT><FONT FACE="Monaco" SIZE=1><P>Q3Pick_GetType</P><P>Q3Pick_GetData</P><P>Q3Pick_SetData</P><P>Q3Pick_GetNumHits</P><P>Q3Pick_GetPickDetailValidMask</P><P>Q3Pick_GetPickDetailData</P><P>Q3HitPath_EmptyData</P><P>Q3Pick_GetVertexTolerance</P><P>Q3Pick_SetVertexTolerance</P><P>Q3Pick_GetEdgeTolerance</P><P>Q3Pick_SetVertexTolerance</P></FONT><FONT FACE="Times"><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Helvetica" SIZE=6 COLOR="#000000"><P ALIGN="CENTER"><A NAME="_Toc438524108">DISPLAY GROUP CULLING</A></P></B></FONT><FONT FACE="Times"><P>One performance bottleneck with QuickDraw 3D has always been that it culls geometry on an objet by object basis, and complex geometries such as Conics get culled very late in the pipeline which results in a tremendous amount of computation going into building a conic which might not even be visible.  Even simple geometries such as TriMeshes take a speed hit.  In the case of a model of a Jumbo Jet which is made up of 20 different TriMeshes, 20 different culling tests are performed on this single model.</P><P>So, the solution has always been for coders to write their own model culling function.  This is not a very friendly thing to ask a programmer to do when they&#146;re using a high level API like QD3D.  Therefore, new in QD3D 1.6 is the ability to assign a Bounding Box to a Display Group.  When the group is submitted for rendering, it will be cull tested and if it fails, then none of the geometry or other objects inside the group will be submitted for rendering.  The speed boost from this ranges from 30% to 3500% or even higher for some conditions.</P><P>Using Group culling is a very powerful feature, but it must be used carefully.  If you correctly assign a Bounding Box to a Group but then the geometry inside of the Group changes, the Group has no way to know that the Bounding Box may not be the right size anymore.  The worst thing that can happen is that Groups will be culled prematurely.  This happens when a Group&#146;s Bounding Box is smaller than it should be to encompass all of the geometry contained within the Group.  If the Bounding Box is too large, then the Group may not get culled when it should and the contained geometries will get processed.  Don&#146;t worry, however, because these geometries will then be cull-tested later down the pipeline when they would have been cull-tested anyway.  No crashes or other serious problems will result from an incorrect Bounding Box, but you need to be careful to avoid visual glitches.</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524109">API CALLS FOR DISPLAY GROUP CULLING</A></P></B></I></U></FONT><FONT FACE="Times"></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524110">Q3DisplayGroup_SetAndUseBoundingBox</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status &#9;Q3DisplayGroup_SetAndUseBoundingBox (</P><P>TQ3GroupObject &#9;group, </P><P>TQ3BoundingBox &#9;*bBox)</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">group&#9;</FONT><FONT FACE="Times">The Display Group to which you wish to assign a bounding box.</P><P>&#9;&#9;</P><P>&#9;</FONT><FONT FACE="Monaco">bBox</FONT><FONT FACE="Times">&#9;A pointer to the Bounding Box you want to assign to the group.</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Times"> if the input bounding box was assigned to the group.&#9;</P><P>&#9;</P><B><P>Info:</B>&#9;This function will assign the input Bounding Box to the input Display Group.  If the </FONT><FONT FACE="Monaco" SIZE=1>isEmpty</FONT><FONT FACE="Times"> field of the bounding box is </FONT><FONT FACE="Monaco" SIZE=1>kQ3True</FONT><FONT FACE="Times">, then this function will return </FONT><FONT FACE="Monaco" SIZE=1>kQ3Failure</FONT><FONT FACE="Times">.  Only non-empty bounding boxes may be assigned to the Display Group.</P><B></B><P>&#9;In addition to assigning the bounding box to the Display Group, this function also sets the Group&#146;s </FONT><FONT FACE="Monaco" SIZE=1>kQ3DisplayGroupStateMaskUseBoundingBox</FONT><FONT FACE="Times"> state flag which indicates that QuickDraw 3D should use the assigned bounding box to perform culling.  You can use </FONT><FONT FACE="Monaco" SIZE=1>Q3DisplayGroup_SetState</FONT><FONT FACE="Times"> to clear the </FONT><FONT FACE="Monaco" SIZE=1>kQ3DisplayGroupStateMaskUseBoundingBox</FONT><FONT FACE="Times"> state flag which will cause QuickDraw 3D to ignore the assigned bounding box.</P><P>&#9;<B>Note</B>:  in previous versions of QuickDraw 3D, the </FONT><FONT FACE="Monaco" SIZE=1>kQ3DisplayGroupStateMaskUseBoundingBox</FONT><FONT FACE="Times"> flag was always set by default on every new Group even though the flag did nothing.  This is no longer the case in 1.6.  Now,  the flag is clear by default.</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524111">Q3DisplayGroup_CalcAndUseBoundingBox</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status &#9;Q3DisplayGroup_CalcAndUse (</P><P>TQ3GroupObject &#9;group,</P><P>TQ3ComputeBounds &#9;computeBounds,</P><P>TQ3ViewObject &#9;view)</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">group&#9;</FONT><FONT FACE="Times">The Display Group who&#146;s Bounding Box you wish to calculate and use.</P><B></B></FONT><FONT FACE="Monaco"><P>&#9;computeBounds&#9;</FONT><FONT FACE="Times">Determines how accurate you would like your bounding box to be.  Use </FONT><FONT FACE="Monaco" SIZE=1>kQ3ComputeBoundsExact</FONT><FONT FACE="Times"> or </FONT><FONT FACE="Monaco" SIZE=1>kQ3ComputeBoundsApproximate</FONT><FONT FACE="Times">.</P><P>&#9;&#9;</P></FONT><FONT FACE="Monaco"><P>&#9;view&#9;</FONT><FONT FACE="Times">The view to associate with calculating the bounding box.</P><P>&#9;&#9;</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Times"> if the bounding box was successfully calculated and assigned to the group.</P><B><P>Info:</B>&#9;This function takes the input Display Group and calculates the Bounding Box which encloses all of the Group&#146;s geometries.  The bounding box is then assigned to the group and the group&#146;s </FONT><FONT FACE="Monaco" SIZE=1>kQ3DisplayGroupStateMaskUseBoundingBox</FONT><FONT FACE="Times"> state flag is set.</P><B></B><P>&#9;This function may not be called inside of a Submit loop.  It will correctly calculate the Bounding Box for the group in its current state, however, the programmer will still need to be aware that changes to the Group&#146;s contained objects may cause the bounding box to no longer be the correct size and thus Group culling may not function properly.</P><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524112">Q3DisplayGroup_GetBoundingBox</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status &#9;Q3DisplayGroup_GetBoundingBox (</P><P>TQ3GroupObject &#9;group, </P><P>TQ3BoundingBox &#9;*bBox)</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">group&#9;</FONT><FONT FACE="Times">The Display Group who&#146;s Bounding Box you wish to get.</P><P>&#9;&#9;</P><P>&#9;</FONT><FONT FACE="Monaco">bBox</FONT><FONT FACE="Times">&#9;A pointer to a Bounding Box structure to receive the groups bounding box data.</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Times">kQ3Success if the bounding box was successfully retrieved from the group.</P><P>&#9;</P><B><P>Info:</B>&#9;This function will return the Group&#146;s currently assigned Bounding Box.  If no Bounding Box is assigned to the Group, then the function returns </FONT><FONT FACE="Monaco" SIZE=1>kQ3Failure</FONT><FONT FACE="Times">.</P><B></B><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524113">Q3DisplayGroup_RemoveBoundingBox</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status &#9;Q3DisplayGroup_RemoveBoundingBox (TQ3GroupObject &#9;group)</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">group&#9;</FONT><FONT FACE="Times">The Display Group who&#146;s Bounding Box you wish to remove.</P><P>&#9;&#9;</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Times">kQ3Success if the bounding box was successfully removed from the group.</P><P>&#9;</P><B><P>Info:</B>&#9;This function removed any assigned Bounding Box from the input Group.  If there was no assigned Bounding Box, then the function does nothing and returns </FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Times">.  However, if there was a Bounding Box, then it is removed from the Group and the Group&#146;s </FONT><FONT FACE="Monaco" SIZE=1>kQ3DisplayGroupStateMaskUseBoundingBox</FONT><FONT FACE="Times"> state flag is cleared.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524114">Q3View_AllowAllGroupCulling</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status &#9;Q3View_AllowAllGroupCulling (</P><P>TQ3ViewObject &#9;view, </P><P>TQ3Boolean&#9; &#9;allowCulling)</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">view&#9;</FONT><FONT FACE="Times">A View Object.</P><P>&#9;&#9;</P><P>&#9;</FONT><FONT FACE="Monaco">allowCulling</FONT><FONT FACE="Times">&#9;A flag to turn group culling on or off.  kQ3True will allow Group culling, kQ3False will turn it off for all Groups rendered by the view.</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Times">kQ3Success if the flag was set.</P><P>&#9;</P><B><P>Info:</B>&#9;This function allows the application to deactivate Group Culling in the input View.  By default, Group Culling is active in a View, but passing kQ3False to this function will disable it for all Groups being submitted.  Passing </FONT><FONT FACE="Monaco" SIZE=1>kQ3True</FONT><FONT FACE="Times"> will re-enable Group culling.</P><B><P>&nbsp;</P></B><P>In addition to adding the above function calls, there are also changes to the 3DMF output files.  When a Display Group that has an assigned Bounding Box is written to a 3DMF file,  additional data is written to the BeginGroup() definition:</P></FONT><FONT FACE="Monaco" SIZE=1><P>&#9;BeginGroup (</P><P>&#9;&#9;DisplayGroup ( )</P><P>&#9;&#9;DisplayGroupState ( Inline </P><P>&#9;&#9;)</P><P>&#9;&#9;DisplayGroupBBox (</P><P>&#9;&#9;&#9;-91.52821 -135.8437 -77.85556 91.52821 135.8437 77.85556 )</P><P>&#9;)</P></FONT><FONT FACE="Times"><P>Previously, only the DisplayGroupState() data was written if any of the state flags were set. </P><P>&nbsp;</P><P>If you are creating a Culling Display Group and it only contains geometry data (no transforms or attribute objects), then you should set the Group&#146;s </FONT><FONT FACE="Monaco" SIZE=1>kQ3DisplayGroupStateMaskIsInline</FONT><FONT FACE="Times"> state flag so that processing of the Group will be much more efficient.  Any Group which is being used solely to contain data and not to define some hierarchical system should always have the inline state flag set.</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524115">DISPLAY GROUP CULLING SAMPLE CODE</A></P></B></I></U></FONT><FONT FACE="Times"><P>The following code takes a list of Geometry Objects, puts them into a new Display Group, and then calculates and assigns a bounding box to the Display Group.  When this Group is submitted, all of the enclosed geometries will be cull-tested up front which results in a huge performance boost.</P></FONT><FONT FACE="Monaco" SIZE=1><P>/*****************  OPTIMIZE SOME MODELS **********************/</P><P>//</P><P>// INPUT:&#9;numModels &#9;= # models to put into culling group</P><P>//&#9;&#9;models&#9;&#9;= array of models</P><P>//</P><P>TQ3DisplayGroupObject OptimizeSomeModels(long numModels, TQ3GeometryObject *models)</P><P>{</P><P>long&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;i;</P><P>TQ3DisplayGroupObject&#9;&#9;theGroup;&#9;</P><P>TQ3DisplayGroupState&#9;&#9;state;</P><P>&#9;</P><P>&#9;&#9;/* MAKE A NEW DISPLAY GROUP TO PUT MODELS INTO */</P><P>theGroup = Q3DisplayGroup_New();</P><P>if (theGroup == nil)</P><P>&#9;&#9;return(nil);</P><P>&nbsp;</P><P>&#9;&#9;/* PUT EACH MODEL INTO THE GROUP */</P><P>&#9;for (i = 0; i &lt; numModels; i++)</P><P>&#9;&#9;Q3Group_AddObject(theGroup , models[i]);</P><P>&nbsp;</P><P>&#9;&#9;/* CALCULATE AND ACTIVATE THE BBOX */</P><P>&#9;Q3DisplayGroup_CalcAndUseBoundingBox(theGroup,&#9;&#9;</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;kQ3ComputeBoundsExact,&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gMyViewObject);</P><P>&#9;/* MAKE GROUP INLINE SINCE IT DOENST CONTAIN ATTRIBUTES OR TRANSFORMS */</P><P>&#9;Q3DisplayGroup_GetState(theGroup ,&amp;state);&#9;&#9;</P><P>&#9;state |= kQ3DisplayGroupStateMaskIsInline;</P><P>&#9;Q3DisplayGroup_SetState(theGroup ,state);&#9;&#9;</P><P>&#9;return(theGroup);</P><P>}&#9;</P></FONT><FONT FACE="Times"><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Helvetica" SIZE=6 COLOR="#000000"><P ALIGN="CENTER"><A NAME="_Toc438524116">COMPRESSED PIXMAP</A></P></B></FONT><FONT FACE="Times"><P>New for 1.6 is the </FONT><FONT FACE="Monaco" SIZE=1>TQ3CompressedPixmap</FONT><FONT FACE="Times"> texture type.  This texture type works just like the </FONT><FONT FACE="Monaco" SIZE=1>Pixmap</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Monaco" SIZE=1>Mipmap</FONT><FONT FACE="Times"> types except that the texture pixel data is compressed with QuickTime.  This new texture was designed to be easy to use, and it gives the user the flexibility of supplying their own QuickTime compressed image data or if they desire, QD3D will do the compression for them.</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524117">COMPRESSED PIXMAP SAMPLES</A></P></B></I></U></FONT><FONT FACE="Times"><P>The following images show various types of compression applied to a texturemapped triangle.  Notice how good the compression ratio is for JPEG and Sorenson, yet the degradation of the quality of the texture is almost unnoticeable.  Sorenson compresses the texture to 2% of its original size, but you can barely tell any difference.  </P></FONT><FONT SIZE=2><P ALIGN="CENTER"><IMG SRC="Image16.gif" WIDTH=413 HEIGHT=329></P></FONT><FONT FACE="Times"><P ALIGN="CENTER">No Compression</P></FONT><FONT SIZE=2><P ALIGN="CENTER"><IMG SRC="Image17.gif" WIDTH=413 HEIGHT=329></P></FONT><FONT FACE="Times"><P ALIGN="CENTER">JPEG Low Quality</P><P>&nbsp;</P></FONT><FONT SIZE=2><P ALIGN="CENTER"><IMG SRC="Image18.gif" WIDTH=413 HEIGHT=329></P></FONT><FONT FACE="Times"><P ALIGN="CENTER">Sorenson Least Quality</P><P>&nbsp;</P><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524118">STRUCTURES AND API FUNCTIONS</A></P></B></I></U></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>typedef struct TQ3CompressedPixmap</P><P>{</P><P>&#9;TQ3StorageObject&#9;compressedImage;&#9;&#9;/* contains  compressed  image data */</P><P>&#9;TQ3Endian&#9;&#9;&#9;&#9;imageDescByteOrder;&#9;/* endianness of  data in the imageDesc */</P><P>&#9;TQ3StorageObject&#9;imageDesc;&#9;&#9;&#9;&#9;&#9;/* contains  QT image description */</P><P>&#9;TQ3Boolean&#9;&#9;&#9;&#9;makeMipmaps;&#9;&#9;&#9;&#9;/* kQ3True = will render with mipmaps */</P><P>&#9;unsigned long&#9;&#9;&#9;width;&#9;&#9;&#9;&#9;&#9;&#9;/* width of texture */</P><P>&#9;unsigned long&#9;&#9;&#9;height;&#9;&#9;&#9;&#9;&#9;&#9;/* height of texture */</P><P>&#9;unsigned long&#9;&#9;&#9;pixelSize;&#9;&#9;&#9;&#9;&#9;/* pixel size 16 or 32 bits */</P><P>&#9;TQ3PixelType&#9;&#9;&#9;pixelType;&#9;&#9;&#9;&#9;&#9;/* pixel type */</P><P>} TQ3CompressedPixmap;</P></FONT><FONT FACE="Times"><P>&nbsp;</P><P>Note that this structure does not contain much of the information (such as </FONT><FONT FACE="Monaco" SIZE=1>rowBytes</FONT><FONT FACE="Times">) that the normal Pixmap structure has.  Since the data is compressed, many parameters are simply not needed.  QuickTime stores all of the information it needs to decode the image in the image description handle.  The </FONT><FONT FACE="Monaco" SIZE=1>imageDesc</FONT><FONT FACE="Times"> record is not an Image Description handle, but rather a QuickDraw 3D container object which contains the QuickTime Image Description Handle&#146;s data.  In order to use this data in a QuickTime function call, you will need to convert this data into a real Handle to pass the QuickTime functions.  Faking it with fake handles (i.e.  &amp;buffer) will not work &#151; QuickTime will probably return an error.</P><P>The function calls for working with Compressed Pixmaps are identical to those for the other texture types.  However, there is one new function designed to assist in creating the compressed data:</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524119">Q3CompressedPixmapTexture_CompressImage</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status &#9;Q3CompressedPixmapTexture_CompressImage(</P><P>TQ3CompressedPixmap *compressedPixmap,</P><P>PixMapHandle &#9;&#9;&#9;sourcePixMap,</P><P>CodecQ &#9;&#9;&#9;&#9;&#9;codecQuality, </P><P>CodecType&#9;&#9;&#9;&#9;&#9;codecType,</P><P>CodecComponent &#9;&#9;codecComponent)</P></FONT><B><FONT FACE="Times"><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">compressedPixmap</FONT><FONT FACE="Times">&#9;Pointer to the TQ3CompressedPixmap structure to receive the compressed image.</P><P>&#9;&#9;</P><P>&#9;</FONT><FONT FACE="Monaco">SourcePixMap</FONT><FONT FACE="Times">&#9;</FONT><FONT FACE="Monaco" SIZE=1>PixMapHandle</FONT><FONT FACE="Times"> which contains the uncompressed image that you want to be compressed.</P><P>&#9;</FONT><FONT FACE="Monaco">CodecQuality</FONT><FONT FACE="Times">&#9;The QuickTime quality value to use to compress the image.</P><P>&#9;</FONT><FONT FACE="Monaco">CodecType</FONT><FONT FACE="Times">&#9;The QuickTime codec type to use to compress the image.</P><P>&#9;</FONT><FONT FACE="Monaco">CodecComponent</FONT><FONT FACE="Times">&#9;The QuickTime codec component to use to compress the image.</P><P>&nbsp;</P><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Times"> if compression was successful.&#9;</P><P>&#9;</FONT><FONT FACE="Monaco">CompressedPixmap</FONT><FONT FACE="Monaco" SIZE=1>&#9;</FONT><FONT FACE="Times">The </FONT><FONT FACE="Monaco" SIZE=1>compressedImage</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Monaco" SIZE=1>imageDesc</FONT><FONT FACE="Times"> fields will contain references to storage objects if compression was successful.</P><P>&#9;</P><B><P>Info:</B>&#9;This is a utility function for creating a Compressed Pixmap texture.  Given various QuickTime parameters and a PixMapHandle containing the uncompressed source image, this function will use QuickTime to compress the image and then create two new storage objects which contain the compressed image data and the QuickTime image description data.</P><B></B><P>&#9;If the function succeeds in compressing the texture image, it saves the reference to the storage objects in the </FONT><FONT FACE="Monaco" SIZE=1>compressedImage</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Monaco" SIZE=1>imageDesc</FONT><FONT FACE="Times"> fields of the </FONT><FONT FACE="Monaco" SIZE=1>TQ3CompressedPixmap</FONT><FONT FACE="Times"> structure.  You still need to fill out the other fields of this since this function will not do it for you.</P><P>&#9;The QuickTime constants for the various compression parameters are found in the header file </FONT><FONT FACE="Monaco" SIZE=1>ImageCompression.h</FONT><FONT FACE="Times">.  Note that not all compressor CODECs can be used to compress a texture.  Some compressors only decompress data.  If you attempt to use a CODEC which cannot do compression, </FONT><FONT FACE="Monaco" SIZE=1>Q3CompressedPixmapTexture_CompressImage </FONT><FONT FACE="Times">will return </FONT><FONT FACE="Monaco" SIZE=1>kQ3Failure</FONT><FONT FACE="Times">.  Your application may want to let the user select the compression parameters with the QuickTime function </FONT><FONT FACE="Monaco" SIZE=1>SCRequestSequenceSettings</FONT><FONT FACE="Times">.</P></FONT><FONT FACE="Charcoal"><P>&nbsp;</P></FONT><FONT FACE="Times"><P>The other new functions for the CompressedPixmap texture type should look very familiar:</P></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3TextureObject Q3CompressedPixmapTexture_New(</P><P>const TQ3CompressedPixmap *compressedPixmap)</P><P>TQ3Status Q3CompressedPixmapTexture_GetCompressedPixmap(</P><P>TQ3TextureObject texture,</P><P>TQ3CompressedPixmap *compressedPixmap)</P><P>TQ3Status Q3CompressedPixmapTexture_SetCompressedPixmap(</P><P>TQ3TextureObject texture,</P><P>const TQ3CompressedPixmap *compressedPixmap)</P></FONT><FONT FACE="Charcoal"><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524120">COMPRESSED PIXMAP EXAMPLE</A></P></B></I></U></FONT><FONT FACE="Charcoal"></FONT><FONT FACE="Monaco" SIZE=1><P>/***********  GWORLD TO COMPRESSED PIXMAP *******************/</P><P>TQ3TextureObject&#9;GworldToCompressedPixmap(GworldPtr theGWorld)</P><P>{</P><P>PixMapHandle &#9;&#9;&#9;&#9;&#9;hPixMap;</P><P>unsigned long &#9;&#9;&#9;&#9;pictMapAddr;</P><P>unsigned long &#9;&#9;&#9;&#9;pictRowBytes;</P><P>TQ3CompressedPixmap &#9;&#9;pixmap;</P><P>TQ3TextureObject&#9;&#9;&#9;texture;</P><P>TQ3Status&#9;&#9;&#9;&#9;&#9;&#9;status;</P><P>&#9;&#9;&#9;&#9;/* GET GWORLD ADDR &amp; ROWBYTES */</P><P>&#9;&#9;&#9;&#9;&#9;</P><P>&#9;hPixMap = GetGWorldPixMap(theGWorld);&#9;&#9;&#9;&#9;</P><P>&#9;pictMapAddr = (unsigned long )GetPixBaseAddr(hPixMap);</P><P>&#9;pictRowBytes = (unsigned long)(**hPixMap).rowBytes &amp; 0x3fff;</P><P>&nbsp;</P><P>&#9;&#9;&#9;/* FILL OUT COMPRESSED PIXMAP STRUCTURE */</P><P>&#9;pixmap.compressedImage &#9;&#9;= nil;</P><P>&#9;pixmap.imageDesc &#9;&#9;&#9;&#9;= nil;</P><P>&#9;pixmap.makeMipmaps &#9;&#9;&#9;= kQ3True;&#9;</P><P>&#9;pixmap.width &#9;&#9;&#9;&#9;&#9;&#9;= width;</P><P>&#9;pixmap.height&#9;&#9;&#9;&#9;&#9;&#9;= height;</P><P>&#9;if (gCodecDepth == 32)</P><P>&#9;{</P><P>&#9;&#9;pixmap.pixelSize&#9;&#9;&#9;= 32;</P><P>&#9;&#9;pixmap.pixelType&#9;&#9;&#9;= kQ3PixelTypeRGB32;</P><P>&#9;}</P><P>&#9;else</P><P>&#9;{</P><P>&#9;&#9;pixmap.pixelSize&#9;&#9;&#9;= 16;</P><P>&#9;&#9;pixmap.pixelType &#9;&#9;&#9;= kQ3PixelTypeRGB16;</P><P>&#9;}</P><P>&#9;&#9;&#9;/* COMPRESS IMAGE AND FILL OUT REMAINING RECORDS IN STRUCTURE */</P><P>&#9;&#9;&#9;//</P><P>&#9;&#9;&#9;// Note:  gCodecType, gCodecComponent, gCodecDepth, and </P><P>// &#9;&#9;&#9;gCodecQuality are global variables we got from a</P><P>//&#9;&#9;&#9;&#9;previous call to SCRequestImageSettings() and</P><P>//&#9;&#9;&#9;&#9;SCGetInfo().</P><P>&#9;&#9;&#9;//</P><P>&#9;&#9;&#9;</P><P>&#9;status = Q3CompressedPixmapTexture_CompressImage(&amp;pixmap,</P><P>hPixMap,</P><P>gCodecType,</P><P>gCodecComponent,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gCodecDepth,</P><P>gCodecQuality);</P><P>&#9;if (status == kQ3Failure)</P><P>&#9;&#9;DoError("\pQ3CompressedPixmapTexture_CompressImage Failed!");&#9;</P><P>&nbsp;</P><P>&#9;&#9;/* MAKE NEW COMPRESSED PIXMAP TEXTUE OBJECT */</P><P>&#9;&#9;&#9;&#9;</P><P>&#9;texture = Q3CompressedPixmapTexture_New (&amp;pixmap);</P><P>&#9;if (texture == nil)</P><P>&#9;&#9;DoError ("\pQ3CompressedPixmapTexture_New failed!");</P><P>&#9;</P><P>&#9;return(texture);</P><P>}&#9;</P><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524121">COMPRESSED PIXMAPS IN 3DMF FILES</A></P></B></I></U></FONT><FONT FACE="Times"><P>Compressed Pixmaps get written out to 3DMF files just like other texture types.  However, unlike other texture types who&#146;s texture data can be edited in a text 3DMF file, the Compressed Pixmap writes out compressed data to the 3DMF file and thus may appear as random patterns in the text 3DMF files.  Do not attempt to edit the compressed data in a 3DMF file.  This will likely lead to decompression corruption and possibly a crash in the QuickDraw 3D application attempting to view the file.</P><P>The Texture Shader for the above Jelly Bean texture which was compressed with Sorenson Least Quality looks like this:</P></FONT><FONT FACE="Monaco" SIZE=1><P>&#9;&#9;Container (</P><P>&#9;&#9;&#9;&#9;TextureShader ( )</P><P>&#9;&#9;&#9;&#9;compressedpixmaptexture5:</P><P>&#9;&#9;&#9;&#9;CompressedPixmapTexture (</P><P>&#9;&#9;&#9;&#9;&#9;86 BigEndian 4996 False 256 256 16 RGB16 </P><P>&#9;&#9;&#9;&#9;&#9;0x00000056535651310000000000000000</P><P>&#9;&#9;&#9;&#9;&#9;0x00020002535669730000000000000000</P><P>&#9;&#9;&#9;&#9;&#9;0x01000100004800000048000000001384</P><P>&#9;&#9;&#9;&#9;&#9;0x00010E536F72656E736F6E2056696465</P><P>&#9;&#9;&#9;&#9;&#9;0x6F000000000000000000000000000000</P><P>&#9;&#9;&#9;&#9;&#9;0x00000018FFFF</P><P>&#9;&#9;&#9;&#9;&#9;0x00008000171001003E0500000C6D528A</P><P>&#9;&#9;&#9;&#9;&#9;0x0A7BA210DE56AC87FE79D48CBC267317</P><P>&#9;&#9;&#9;&#9;&#9;0xFD148F92354B02AA37A0A11755909163</P><P>&#9;&#9;&#9;&#9;&#9;0x9903E8282A7AF37B8E2E31A0C33A681D</P><P>&#9;&#9;&#9;&#9;&#9;0xCC88A83F5A126CF430CF947E4A7C5532</P><P>&#9;&#9;&#9;&#9;&#9;0xE50740E468FA17DCE801CE465A5F4CB6</P><P>&#9;&#9;&#9;&#9;&#9;0xA84972F0D42479AA02D9E0B183F28B99</P><P>&#9;&#9;&#9;&#9;&#9;....</P><P>&#9;&#9;&#9;&#9;&#9;....</P></FONT><FONT FACE="Times"><P>Let&#146;s see what all of this means:</P><P>The &quot;86&quot; is the size of the QuickTime Image Description Data.  The next item &quot;BigEndian&quot; indicates the endianness of the Image Description Data.  Following that is the number &quot;4996&quot; which indicates the size of the compressed texture data.  &quot;False&quot; indicates no mipmapping.  If this were set to &quot;True&quot; then that would indicate that this texture should be mipmapped.  The next two numbers &quot;256&quot; and &quot;256&quot; are the width and height of the texture, and &quot;16&quot; and &quot;RGB16&quot; indicate the pixel size and type of the texture.</P><P>The next block of binary data is the actual QuickTime Image Description.  Notice it is 86 bytes long as indicated above.  Immediately following this data is the actual compressed texture itself.  This data is actually 4996 bytes long, but we&#146;ve truncated it above in an effort to save the rainforests.</P></FONT><B><FONT FACE="Helvetica" SIZE=6 COLOR="#000000"><P ALIGN="CENTER"><A NAME="_Toc438524122">GETTING THE RAVE DRAW CONTEXTS</A></P></B></FONT><FONT FACE="Times"><P>There is now a way to get access to the Interactive Renderer&#146;s RAVE Draw Contexts from QuickDraw 3D.  This gives you the ability to make RAVE calls directly to the 3D hardware or software rendering engine.</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524123">NEW API FUNCTIONS</A></P></B></I></U></FONT><FONT FACE="Times"></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524124">Q3InteractiveRenderer_CountRAVEDrawContexts</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status &#9;Q3InteractiveRenderer_CountRAVEDrawContexts(</P><P>TQ3RendererObject&#9;renderer,</P><P>unsigned long&#9; &#9;&#9;*numRAVEContexts)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;&#9;</FONT><FONT FACE="Monaco">renderer</FONT><FONT FACE="Times"> &#9;&#9;&#9;a reference to a QD3D Renderer Object</P><B><P>Output:</B>&#9;&#9;</FONT><FONT FACE="Monaco">numRAVEContext</FONT><FONT FACE="Times">&#9;the number of RAVE Draw Contexts owned by renderer.&#9;</P><B><P>Info:</B>&#9;This function returns in </FONT><FONT FACE="Monaco" SIZE=1>numRAVEContexts</FONT><FONT FACE="Times"> the total number of RAVE Draw Contexts which the input renderer object <I>currently</I> owns.  QuickDraw 3D&#146;s Interactive Renderer does not automatically create the RAVE Draw Contexts when the Renderer object is created or assigned to a View Object.   The RAVE Draw Contexts are created when </FONT><FONT FACE="Monaco" SIZE=1>Q3View_StartRendering</FONT><FONT FACE="Times"> is called.the first time.  Each time </FONT><FONT FACE="Monaco" SIZE=1>Q3View_StartRendering</FONT><FONT FACE="Times"> is called, QuickDraw 3D checks to see if the View has changed and if so, it deletes all of the RAVE Draw Contexts and recreates new ones.</P><B></B><P>&#9;To use this function before you have done any rendering, do the following:</P></FONT><FONT FACE="Monaco" SIZE=1><P>&#9;Q3View_StartRendering(viewObject);&#9;&#9;&#9;&#9;&#9;</P><P>&#9;Q3InteractiveRenderer_CountRAVEDrawContexts(rendererObject,&amp;num);</P><P>&#9;Q3View_Cancel(viewObject);</P></FONT><FONT FACE="Times"><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524125">Q3InteractiveRenderer_GetRAVEDrawContexts</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>TQ3Status &#9;Q3InteractiveRenderer_GetRAVEDrawContexts(</P><P>TQ3RendererObject&#9;renderer, </P><P>TQADrawContext &#9;**raveDrawContextList,</P><P>TQAEngine&#9; &#9;&#9;&#9;**raveDrawEngineList,</P><P>unsigned long&#9;*numRAVEContexts,</P><P>void&#9;(*raveDestroyCallback)(TQ3RendererObject))</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">renderer</FONT><FONT FACE="Times"> &#9;a reference to a QD3D Renderer Object.</P><B><P>&#9;</B></FONT><FONT FACE="Monaco">raveDestroyCallback</FONT><FONT FACE="Monaco" SIZE=1>&#9;the callback function to call when the RAVE Draw Contexts become invalid.</P></FONT><FONT FACE="Times"><B><P>Output:</B>&#9;</FONT><FONT FACE="Monaco">raveDrawContextList</FONT><FONT FACE="Times">&#9;pointer to array of RAVE Draw Context pointers.</P></FONT><FONT FACE="Monaco" SIZE=1><P>&#9;</FONT><FONT FACE="Monaco">RaveDrawEngineList&#9;</FONT><FONT FACE="Times">pointer to array of RAVE Draw Engines.</P><P>&#9;</FONT><FONT FACE="Monaco">numRAVEContexts&#9;</FONT><FONT FACE="Times">the number of RAVE Draw Contexts owned by renderer.&#9;</P><P>&#9;</P><B><P>Info:</B>&#9;This function returns a pointer to each RAVE Draw Context and Drawing Engine associated with the input Renderer Object.  It also indicates the number of RAVE Draw Contexts returned.</P><B></B><P>&#9;As with </FONT><FONT FACE="Monaco" SIZE=1>Q3InteractiveRenderer_CountRAVEDrawContexts, </FONT><FONT FACE="Times"> this function will return 0 draw contexts if </FONT><FONT FACE="Monaco" SIZE=1>Q3View_StartRendering</FONT><FONT FACE="Times"> was not called earlier.  QuickDraw 3D only creates the new RAVE Draw Contexts for the Renderer when </FONT><FONT FACE="Monaco" SIZE=1>Q3View_StartRendering</FONT><FONT FACE="Times"> is called.</P><P>&#9;Changing any parameters of the View associated with the renderer may result in the RAVE Draw Contexts being destroyed and recreated.  Because of this, it is very important to be careful when using the returned </FONT><FONT FACE="Monaco" SIZE=1>TQADrawContext</FONT><FONT FACE="Times"> pointers.  Some actions which will cause the RAVE Draw Contexts to be deleted and recreated are:</P><P>&#9;&#9;&#149;&#9;Moving or resizing the View</P><P>&#9;&#9;&#149;&#9;Changing the View&#146;s Clear Method</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#149;&#9;Changing z-buffer depth.</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#149;&#9;Changing the screen&#146;s color depth or resolution.</P><P>&#9;If you are simply creating a &quot;static&quot; View and never changing any View parameters, then you can be assured that the RAVE Draw Context pointers will remain valid. </P><P>&#9;The </FONT><FONT FACE="Monaco" SIZE=1>raveDestroyCallback</FONT><FONT FACE="Times"> parameter lets you assign a callback function to be called whenever the RAVE Draw Contexts become invalid.  This way you do not need to guess when QuickDraw 3D may have disposed of them.  The minimal callback function takes the following form:</P></FONT><FONT FACE="Monaco" SIZE=1><P>void MyRaveInvalidateCallback(TQ3RendererObject  rendererRef)</P><P>{</P><P>}</P></FONT><FONT FACE="Times"><P>&#9;** Note that your callback function must <B>not</B> dispose of the reference to the Renderer Object!  </P><P>&#9;Your callback function can immediately call </FONT><FONT FACE="Monaco" SIZE=1>Q3InteractiveRenderer_GetRAVEDrawContexts</FONT><FONT FACE="Times"> to get the new RAVE Draw Contexts if any have been created.  A callback function which does this should look like this:</P></FONT><FONT FACE="Monaco" SIZE=1><P>void MyRaveInvalidateCallback(TQ3RendererObject  rendererRef)</P><P>{</P><P>&#9;TQ3Status&#9;&#9;status;</P><P>&#9;&#9;status  = Q3View_StartRendering(gMyView);&#9;&#9;&#9;&#9;&#9;</P><P>&#9;&#9;gNumContexts  = Q3InteractiveRenderer_GetRAVEDrawContexts (</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;rendererRef,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gContextList,</P><P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gEngineList);</P><P>&#9;&#9;if (status == kQ3Success)</P><P>&#9;&#9;&#9;Q3View_Cancel(gMyView);</P><P>}</P></FONT><FONT FACE="Times"><P>&#9;This code does something a little different. Since </FONT><FONT FACE="Monaco" SIZE=1>Q3InteractiveRenderer_GetRAVEDrawContexts  </FONT><FONT FACE="Times">needs to be called inside a rendering loop to be certain that the Contexts are up to date, we call </FONT><FONT FACE="Monaco" SIZE=1>Q3View_StartRendering</FONT><FONT FACE="Times">.  But remember that our callback function might have been called from withing a render loop in which case </FONT><FONT FACE="Monaco" SIZE=1>Q3View_StartRendering</FONT><FONT FACE="Times">  would have already been called and active.  Therefore, calling </FONT><FONT FACE="Monaco" SIZE=1>Q3View_StartRendering</FONT><FONT FACE="Times"> in our callback will return </FONT><FONT FACE="Monaco" SIZE=1>kQ3Failure</FONT><FONT FACE="Times"> because the View is already in a rendering loop.  We do not want to call </FONT><FONT FACE="Monaco" SIZE=1>Q3View_Cancel</FONT><FONT FACE="Times"> if  this is the case, therefore, if </FONT><FONT FACE="Monaco" SIZE=1>Q3View_StartRendering</FONT><FONT FACE="Times"> fails, we do not call </FONT><FONT FACE="Monaco" SIZE=1>Q3View_Cancel</FONT><FONT FACE="Times">.</P><P>&#9;Be aware that there are cases when your callback will be invoked to notify you that the Draw Contexts have been invalidated, but there might not necessarily be any new RAVE Draw Contexts assigned to the Renderer yet.  Therefore, </FONT><FONT FACE="Monaco" SIZE=1>Q3InteractiveRenderer_GetRAVEDrawContexts </FONT><FONT FACE="Times">will return a count of 0.  This will occur when you dispose of the View or Renderer Objects entirely since the RAVE Draw Contexts will be invalidated and obviously no new ones will be created to replace them since you have nuked the View and/or Renderer.</P><P>&#9;If you do not wish to use a callback function to notify you when the RAVE Draw Contexts have become invalid, simply pass </FONT><FONT FACE="Monaco" SIZE=1>NULL</FONT><FONT FACE="Times"> for </FONT><FONT FACE="Monaco" SIZE=1>raveDestroyCallback</FONT><FONT FACE="Monaco">.</P></FONT><FONT FACE="Times"><P>&#9;As noted above, this function also returns the </FONT><FONT FACE="Monaco" SIZE=1>TQAEngine</FONT><FONT FACE="Times"> associated with each Draw Context.  Note that multiple Draw Contexts may share the same Drawing Engine.  Therefore, if you are going to make RAVE calls which take the </FONT><FONT FACE="Monaco" SIZE=1>TQAEngine</FONT><FONT FACE="Times"> as input such as </FONT><FONT FACE="Monaco" SIZE=1>QABitmapNew</FONT><FONT FACE="Times">, be careful not to upload the bitmap to the same Drawing Engine multiple times.  You may get two Draw Contexts which use the save Drawing Engine and the bitmap only needs to be uploaded to the Drawing Engine once for both Draw Context to use it.</P><P>&#9;If you are using the RAVE Draw Context to simply set &quot;global&quot; RAVE state variables like blending modes or whatever, then you should have no problems.  However, if you are planning on making RAVE calls which normally require you to be inside a RenderStart / RenderEnd function such as drawing triangles or textures, then you need to be very careful about something:</P><P>&#9;If your QD3D View has multiple RAVE Draw Contexts (because it crosses multiple monitors), then you need to know which Draw Context is the currently active context when you are inside the </FONT><FONT FACE="Monaco" SIZE=1>Q3RenderStart</FONT><FONT FACE="Times"> / </FONT><FONT FACE="Monaco" SIZE=1>Q3RenderEnd</FONT><FONT FACE="Times"> loop.  You will loop through your &quot;Submit&quot; loop once for each monitor that the View touches.  When you call Q3InteractiveRenderer_GetRAVEDrawContexts, it returns the RAVE Draw Contexts in the order that QuickDraw 3D processes them during rendering.</P><P>&#9;Therefore, if your View crosses 2 monitors then you will loop through your rendering loop two times.  The first time through the loop, the active RAVE Draw Context will be the first context returned by </FONT><FONT FACE="Monaco" SIZE=1>Q3InteractiveRenderer_GetRAVEDrawContexts</FONT><FONT FACE="Times">.  The second time through the loop, the active RAVE Draw Context will be the second context returned by </FONT><FONT FACE="Monaco" SIZE=1>Q3InteractiveRenderer_GetRAVEDrawContexts</FONT><FONT FACE="Times">.</P><P>&#9;You need to be careful to manage this correctly in your application because drawing a triangle with a RAVE Draw Context that is not currently active will cause an error to occur.</P><P>&#9;On a similar note, be careful not to submit textures, bitmaps, or triangles which are not clipped to the Draw Context&#146;s bounds.  For example, suppose you have a View which is 100 pixels wide but crosses two monitors and only 20 pixels are on the left monitor.  The other 80 pixels are on the right monitor.  If you then call </FONT><FONT FACE="Monaco" SIZE=1>QADrawBitmap</FONT><FONT FACE="Times"> using a bitmap which is 30 pixels wide into the left Draw Context, the RAVE Software Renderer will trash memory as it draws off the right side of that monitor.  Unlike QuickDraw 3D which internally handles clipping for you, RAVE does not and it is very easy to trash memory if you are not careful about these kinds of situations.</P><P>In general, if you don&#146;t really know much about RAVE or you just plain don&#146;t know what you are doing, then only use these RAVE Draw Context you acquired from QuickDraw 3D to set RAVE State Variables.  Do not use it to upload textures or draw triangles.  Only seasoned veterans of RAVE should attempt to do this.</P></FONT><B><FONT FACE="Helvetica" SIZE=6 COLOR="#000000"><P ALIGN="CENTER"><A NAME="_Toc438524126">NEW VIEWER FUNCTIONS</A></P></B></FONT><FONT FACE="Times"><P>The new Viewer in QuickDraw 3D 1.6 is much improved over the old Viewer.  User interaction of the 3D models is much more intuitive and has much better feedback.  The visual appearance of the models is also greatly improved.  Note that the default lighting in the Viewer is a standard studio lighting setup:  1 key light, 1 fill light, and 1 backlight.</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524127">FLY-THRU MODE</A></P></B></I></U></FONT><FONT FACE="Times"><P>In the new Viewer&#146;s Camera menu, the first item now says Enter Fly-Thru Mode.  When in this mode, the user&#146;s control of the camera changes.  Moving the mouse up and down will move the camera forward and backward.  Moving the mouse horizontally moves the camera sideways.</P><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524128">THE OPTIONS BUTTON</A></P></B></I></U></FONT><FONT FACE="Times"><P>A new Options control strip button has been added to the Viewer which allows the user to modify the appearance of the rendered image in the Viewer.</P></FONT><FONT SIZE=2><P ALIGN="CENTER"><IMG SRC="Image19.gif" WIDTH=298 HEIGHT=299></P></FONT><FONT FACE="Times"><P ALIGN="CENTER">The icon on the far right is the new Options button</P><P>&nbsp;</P><P>The Options button will pop open a sub-menu containing the following selections:</P><P>&#149; </FONT><B><FONT FACE="Palatino">Renderer</B></FONT><FONT FACE="Times">&#9;The user can select from any of the installed Interactive Renderers for displaying the model.</P><P>&#149; </FONT><B><FONT FACE="Palatino">Brightness</B></FONT><FONT FACE="Times">&#9;The user can change the brightness of the scene.</P><P>&#149; </FONT><B><FONT FACE="Palatino">Background Color</B></FONT><FONT FACE="Times">&#9;The user can change the background color of the Viewer.</P><P>&#149; </FONT><B><FONT FACE="Palatino">Remove Backfaces</B></FONT><FONT FACE="Times">&#9;Toggles backface removal on and off for better looking images and faster rendering.</P><P>&#149; </FONT><B><FONT FACE="Palatino">Phong Shading</B></FONT><FONT FACE="Times">&#9;Toggles phong shading on and off to alter the appearance of the model.</P><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524129">RESIZING THE VIEWER PANE INSIDE THE  WINDOW</A></P></B></I></U></FONT><FONT FACE="Times"><P>Prior to QuickDraw 3D 1.6 it was only possible to have a window with a grow box that resized the Viewer&#146;s dimensions and always fill the entire window.  This was done by setting the Viewer&#146;s </FONT><FONT FACE="Monaco" SIZE=1>kQ3ViewerDrawGrowBox</FONT><FONT FACE="Times"> flag.  Some applications still need a resizable window and a resizable Viewer but wish to resize them independently.  A new flag </FONT><FONT FACE="Monaco" SIZE=1>kQ3ViewerPaneGrowBox</FONT><FONT FACE="Times"> has been added so the Viewer can be resized in it&#146;s own pane.  Setting this flag draws a grow box inside the Viewer&#146;s control strip which accepts mouse clicks and resized the Viewer when the user click in it.  The diagram below show the appearance of the Viewer with this new flag.</P><P ALIGN="CENTER"><IMG SRC="Image20.gif" WIDTH=373 HEIGHT=299></P><P ALIGN="CENTER"></P><P ALIGN="CENTER">Viewer with </FONT><FONT FACE="Monaco" SIZE=1>kQ3ViewerPaneGrowBox </FONT><FONT FACE="Times">flag setting</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P>&nbsp;</P><P><A NAME="_Toc438524130">NEW API FUNCTIONS</A></P></B></I></U></FONT><FONT FACE="Times"><P>In addition to giving the user access to the rendering options listed above, the application using the Viewer also has access to the same things via new function calls:</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524131">Q3ViewerSetRendererType</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr &#9;&#9;Q3ViewerSetRendererType(</P><P>&#9;TQ3ViewerObject&#9; theViewer,</P><P>TQ3ObjectType&#9; rendererType)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;the viewer object who&#146;s renderer type you wish to change.</P><P>&#9;r</FONT><FONT FACE="Monaco">endererType</FONT><FONT FACE="Times">&#9;the renderer type you want the Viewer to use.</P><P>&#9;</P><B><P>Info:</B>&#9;Use this function to set the Renderer Type you want the Viewer to use when rendering an image.  You should only pass in Interactive Renderer types since other types of renderers may impede the user&#146;s ability to work with the Viewer.  The two types of Interactive Renderers built into QuickDraw 3D are </FONT><FONT FACE="Monaco" SIZE=1>kQ3RendererTypeInteractive</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Monaco" SIZE=1>kQ3RendererTypeWireFrame</FONT><FONT FACE="Times">.</P><P>&nbsp;</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524132">Q3ViewerGetRendererType</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr &#9;&#9;Q3ViewerGetRendererType(</P><P>&#9;&#9;TQ3ViewerObject&#9; &#9;theViewer,</P><P>TQ3ObjectType&#9;&#9;&#9;*rendererType)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;the viewer object who&#146;s renderer type you wish to set.</P><B><P>Output:</B>&#9;r</FONT><FONT FACE="Monaco">endererType</FONT><FONT FACE="Times">&#9;a pointer to a </FONT><FONT FACE="Monaco" SIZE=1>TQ3ObjectType</FONT><FONT FACE="Times"> that will contain the current Renderer Type assigned to the Viewer when the function completes.</P><P>&#9;</P><B><P>Info:</B>&#9;Use this function to get the Renderer Type currently being used by the Viewer to render images.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524133">Q3ViewerChangeBrightness</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr&#9;&#9; Q3ViewerChangeBrightness(</P><P>TQ3ViewerObject theViewer,</P><P> float&#9;&#9;&#9;&#9;brightness)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;a viewer object.</P><P>&#9;</FONT><FONT FACE="Monaco">brightness</FONT><FONT FACE="Times">&#9;the percentage of light dimming to apply.  The value 0 will dim all lights to 0%.  A value of 1.0 will set all lights to their original values.  A value of 2.0 will brighten all lights by 200%. </P><P>&#9;</P><B><P>Info:</B>&#9;This function lets you change the brightness of a scene by altering the brightness values of each light in the scene.  The brightness value is a scaling value that is multiplied against each light in the scene.  There is no upper limit to the brightness value, but it must be &gt;= 0.0.  Any value over 1.0 may cause some lights to oversaturate, but that might be the effect you want.  For example, if your View contains a light that already has a brightness of 0.9 and you apply a brightness value of 1.2, then the brightened light will have a brightness of 1.08 which is slightly oversaturated.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524134">Q3ViewerSetRemoveBackfaces</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr  &#9;Q3ViewerSetRemoveBackfaces(</P><P>TQ3ViewerObject &#9;theViewer,</P><P> TQ3Boolean&#9; &#9;&#9;remove)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;a viewer object.</P><P>&#9;</FONT><FONT FACE="Monaco">remove</FONT><FONT FACE="Times">&#9;a boolean where kQ3True indicates to remove backfaces, kQ3False indicates keep backfaces.</P><P>&#9;</P><B><P>Info:</B>&#9;Calling this function will allow you to turn backface removal in the Viewer on and off.  By default, backfaces are shown in the Viewer.  This may have detrimental effects on the appearance and rendering speed of many kinds of models, therefore, you may wish to turn backface removal on in your application.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524135">Q3ViewerGetRemoveBackfaces</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr&#9;&#9;Q3ViewerGetRemoveBackfaces(</P><P>TQ3ViewerObject&#9;theViewer,</P><P>TQ3Boolean&#9; &#9;&#9;*remove)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;a viewer object.</P><B><P>Output</B>:<B>&#9;</B>remove&#9;a pointer to a </FONT><FONT FACE="Monaco" SIZE=1>TQ3Boolean</FONT><FONT FACE="Times"> will contain kQ3True if backface removal is currently turned on.</P><P>&#9;</P><B><P>Info:</B>&#9;This function returns </FONT><FONT FACE="Monaco" SIZE=1>kQ3True</FONT><FONT FACE="Times"> if backface removal is currently active in the viewer.  Otherwise, it returns </FONT><FONT FACE="Monaco" SIZE=1>kQ3False</FONT><FONT FACE="Times">.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524136">Q3ViewerSetPhongShading</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr&#9; &#9;Q3ViewerSetPhongShading(</P><P>TQ3ViewerObject&#9;theViewer,</P><P> TQ3Boolean&#9; &#9;phong)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;a viewer object.</P><P>&#9;</FONT><FONT FACE="Monaco">phong</FONT><FONT FACE="Times">&#9;a boolean where kQ3True tells the Viewer to use phong shading, kQ3False tells the Viewer not to use phong shading.</P><P>&#9;</P><B><P>Info:</B>&#9;This function allows you to set Phong or Lambert shading in the Viewer.  Passing in </FONT><FONT FACE="Monaco" SIZE=1>kQ3True</FONT><FONT FACE="Times"> activates the Phong shader, or passing in </FONT><FONT FACE="Monaco" SIZE=1>kQ3False</FONT><FONT FACE="Times"> tells the Viewer to use Lambert shading instead.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524137">Q3ViewerGetPhongShading</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr&#9;&#9;Q3ViewerGetPhongShading(</P><P>TQ3ViewerObject&#9;theViewer,</P><P> TQ3Boolean&#9; &#9;*phong)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;a viewer object.</P><B><P>Output</B>:<B>&#9;</B></FONT><FONT FACE="Monaco">phong</FONT><FONT FACE="Times">&#9;a pointer to a </FONT><FONT FACE="Monaco" SIZE=1>TQ3Boolean</FONT><FONT FACE="Times"> which will contain kQ3True if Phong shading is currently turned on.</P><P>&#9;</P><B><P>Info:</B>&#9;This function returns </FONT><FONT FACE="Monaco" SIZE=1>kQ3True</FONT><FONT FACE="Times"> if Phong shading is currently being used by the Viewer to render scenes.  Otherwise, a value of </FONT><FONT FACE="Monaco" SIZE=1>kQ3False</FONT><FONT FACE="Times"> indicates that the Lambert shader is being used.</P><B></B><P>&#9;Phong shading is turned on by default in the Viewer, however, some models do not look very good with Phong&#146;s specular  highlight.  The Lambert shader does not render with a specular highlight and usually renders faster.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524138">Q3ViewerSetWindowResizeCallback</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr&#9;&#9;Q3ViewerSetWindowResizeCallback (</P><P>TQ3ViewerObject&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;theViewer,</P><P>TQ3ViewerWindowResizeCallbackMethod&#9;&#9;callbackMethod,</P><P>const void&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*data)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;a viewer object.</P><P>&#9;</FONT><FONT FACE="Monaco">callbackMethod</FONT><FONT FACE="Times">&#9;a pointer to an application defined window resize method.</P><P>&#9;</FONT><FONT FACE="Monaco">data</FONT><FONT FACE="Times">&#9;an optional pointer to any application specific data which is passed to the callback function.</P><B><P>Output</B>:<B>&#9;</B></FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Times"> if method was installed successfully.</P><P>&#9;</P><B><P>Info:</B>&#9;This function installs a callback method that gets invoked when the user clicks and drags in the window&#146;s grow box. Use this function if your application needs to resize the Viewer window differently than the default resizing functionality provided by the Viewer when the kQ3ViewerDrawGrowBox flag is set.  The callback should handle all mouse tracking and resizing and invalidating of the window.  The Viewer will redraw itself after the callback finishes.</P><B></B><P>&#9;The optional </FONT><FONT FACE="Monaco" SIZE=1>data</FONT><FONT FACE="Times"> parameter is used if an application needs to reference other information that can&#146;t be obtained from the Viewer object passed in the callback. If no extra data needed this parameter can be set to NULL.</P><B></B><P>&#9;To disable and remove the window resize callback function from your Viewer application, call </FONT><FONT FACE="Monaco" SIZE=1>Q3ViewerSetWindowResizeCallback</FONT><FONT FACE="Times">, with a value of </FONT><FONT FACE="Monaco" SIZE=1>NULL</FONT><FONT FACE="Times">.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524139">Q3ViewerSetPaneResizeNotifyCallback</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr&#9;&#9;Q3ViewerSetPaneResizeNotifyCallback (</P><P>TQ3ViewerObject&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;theViewer,</P><P>TQ3ViewerPaneResizeNotifyCallbackMethod&#9;&#9;&#9;callbackMethod,</P><P>const void&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*data)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;a viewer object.</P><P>&#9;</FONT><FONT FACE="Monaco">callbackMethod</FONT><FONT FACE="Times">&#9;a pointer to an application defined method for resizing the Viewer as a pane independently from it enclosing window.</P><P>&#9;</FONT><FONT FACE="Monaco">data</FONT><FONT FACE="Times">&#9;an optional pointer to any application specific data which is passed to the callback function.</P><B><P>Output</B>:<B>&#9;</B></FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Times"> if method was installed successfully.</P><P>&#9;</P><B><P>Info:</B>&#9;Calling this function installs a callback method that gets invoked when the user clicks and drags in the Viewer&#146;s pane grow box to resize the Viewer.  Use this function if your application needs to resize the Viewer&#146;s pane dimensions independently of the window.</P><B></B><P>&#9;This callback is only invoked when the </FONT><FONT FACE="Monaco" SIZE=1>kQ3ViewerPaneGrowBox</FONT><FONT FACE="Times"> flag is set and overrides the window resizing functionality of the </FONT><FONT FACE="Monaco" SIZE=1>kQ3ViewerDrawGrowBox</FONT><FONT FACE="Times"> flag.  After the user clicks in the pane grow box and the Viewer handles resizing the callback function should then erase and update any affected areas of the window and call Q3ViewerDraw to redraw the Viewer.  Use the Q3ViewerGetBounds call to find the Viewer&#146;s new pane dimensions.</P><B></B><P>&#9;The optional </FONT><FONT FACE="Monaco" SIZE=1>data</FONT><FONT FACE="Times"> parameter is used if an application needs to reference other information that can&#146;t be obtained from the Viewer object passed in the callback. If no extra data needed this parameter can be set to NULL.</P><B></B><P>&#9;To disable and remove the Viewer pane resize callback function in your Viewer application, call </FONT><FONT FACE="Monaco" SIZE=1>Q3ViewerSetWindowResizeCallback</FONT><FONT FACE="Times">, with a value of </FONT><FONT FACE="Monaco" SIZE=1>NULL</FONT><FONT FACE="Times">.</P><P>&nbsp;</P></FONT><B><FONT FACE="Geneva" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc438524140">Q3ViewerSetDrawingCallbackMethod</A></P></B></FONT><FONT FACE="Times"></FONT><FONT FACE="Monaco" SIZE=1><P>OSErr&#9;&#9;Q3ViewerSetDrawingCallbackMethod (</P><P>TQ3ViewerObject&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;theViewer,</P><P>TQ3ViewerDrawingCallbackMethod &#9;&#9;callbackMethod,</P><P>const void&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*data)</P></FONT><FONT FACE="Times"><B><P>Input:</B>&#9;</FONT><FONT FACE="Monaco">theViewer</FONT><FONT FACE="Times"> &#9;a viewer object.</P><P>&#9;</FONT><FONT FACE="Monaco">callbackMethod</FONT><FONT FACE="Times">&#9;a pointer to an application defined function.</P><P>&#9;</FONT><FONT FACE="Monaco">data</FONT><FONT FACE="Times">&#9;an optional pointer to any application specific data.</P><B><P>Output</B>:<B>&#9;</B></FONT><FONT FACE="Monaco">TQ3Status&#9;</FONT><FONT FACE="Monaco" SIZE=1>kQ3Success</FONT><FONT FACE="Times"> if method was installed successfully.</P><P>&#9;</P><B><P>Info:</B>&#9;This function sets a callback method called after the Viewer finishes rendering the model and drawing the control strip.  The callback function is called when the Viewer window is updated or when </FONT><FONT FACE="Monaco" SIZE=1>Q3ViewerDraw</FONT><FONT FACE="Times"> is called. The callback can so other things like draw over the rendered model or perform some other post operation.  (This API isn&#146;t actually new for 1.6 but it is documented here for comparison with the other new Viewer callback API&#146;s.)</P><B></B><P>&#9;The optional </FONT><FONT FACE="Monaco" SIZE=1>data</FONT><FONT FACE="Times"> parameter is used if an application needs to reference other information that can&#146;t be obtained from the Viewer object passed in the callback. If no extra data needed this parameter can be set to NULL. </P><B></B><P>&#9;To disable and remove the drawing callback function from your Viewer application, call </FONT><FONT FACE="Monaco" SIZE=1>Q3ViewerSetDrawingCallbackMethod</FONT><FONT FACE="Times">, with a value of </FONT><FONT FACE="Monaco" SIZE=1>NULL</FONT><FONT FACE="Times">.</P><P>&#9;</P><P>&nbsp;</P></FONT><B><FONT FACE="Helvetica" SIZE=6 COLOR="#000000"><P ALIGN="CENTER"><A NAME="_Toc438524141">MISCELLANEA</A> </P><P ALIGN="CENTER"></P></B></FONT><FONT FACE="Times"><P>&nbsp;</P></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524142">INTERACTIVE RENDERER MODIFICATIONS</A></P></B></I></U></FONT><FONT FACE="Times"><P>&nbsp;</P><P>1.&#9;TriMesh culling is faster.  TriMeshes of any number of vertices will be cull-tested now.  Previously, only TriMeshes of 40 or more vertices were cull tested which resulted in small models being transformed in a slower pipeline.</P><P>2</P><P>.&#9;The Interactive Renderer&#146;s memory management has been optimized.  </P><P>3.&#9;PowerMac&#146;s with the extended PowerPC floating point opcodes (the 603, 604, and G3 chips) now do some calculations faster.  Vector Normalizations are significantly faster.</P><OL START=4><LI>TriMesh transformation loops now specifically check for the Identity Matrix and if it exists, then no unnecesary transformation are calculated.  Instead, data is simply copied from local space to world space.  Therefore, it is more efficient to build your static geometries in world-space than to build them in local-space and use a transform to move them into world space.  Building them in world-space allows QuickDraw 3D to avoid the local to world transform.</LI><LI>Many general optimizations to the transformation, lighting, and clipping code.</LI><LI>Changed the NULL Illumination model to always include vertex colors for shading triangles.  It makes sense that the NULL shader would use vertex colors since it has no way of calculating it&#146;s own vertex color values.  Textured models can now also have vertex colors so you can essentially pre-light geometry for better performance.  The RAVE Software rasterizer has also been updated to be able to render these textured-colored triangles.</LI><LI>Transparency now works correctly with the NULL shader using TriMeshes.</LI></FONT><FONT SIZE=2><P ALIGN="CENTER"><IMG SRC="Image21.gif" WIDTH=322 HEIGHT=286></P></FONT><FONT FACE="Times"><P ALIGN="CENTER">A single textured triangle with red, green, and blue diffuse colors applied to the vertices.</P><P>&nbsp;</P><LI>Fixed a bug which prevented a change in the View&#146;s Clear Method from working.&#9;</LI></OL></FONT><B><I><U><FONT FACE="Palatino" SIZE=6><P><A NAME="_Toc438524143"></P><P>QUICKDRAW 3D MODIFICATIONS</A></P></B></I></U></FONT><FONT FACE="Times"><P>1.&#9;Improved performance of Matrix Inversion code.</P><P>2.&#9;Improved performance of lots of low-level floating point math code.</P><P>3.&#9;Improved performance of most geometries.  Conic decomposition is faster.  Mesh decomposition is also faster.</P><P>4.&#9;Fixed </FONT><FONT FACE="Monaco" SIZE=1>Q3InteractiveRenderer_SetRAVETextureFilter </FONT><FONT FACE="Times">so it actually works now.</P><P>5.&#9;The default diffuse color is now 1,1,1 instead of .5,.5,.5.  Since 1.6 now blends diffuse colors with textures when the NULL shader is used (see #6 above), this default color needed to be changed to white instead of gray, otherwise textures would be 50% dimmed when the NULL shader is used..  If you are not using the NULL shader in your app and you want the default diffuse to be gray instead of white, then you can use the </FONT><FONT FACE="Monaco" SIZE=1>Q3View_GetDefaultAttributeGet </FONT><FONT FACE="Times">and </FONT><FONT FACE="Monaco" SIZE=1>Q3View_GetDefaultAttributeSet</FONT><FONT FACE="Times"> calls to change the default diffuse RGB values.</P><P>6.&#9;Performance for window point picking has been improved for all geometries, notably trimesh, mesh, and trigrid.   Initial test show improvements are 20-50%, 10-25% and 30-85% respectively, depending on the triangle count.</P><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P></FONT><!-- start of footer --><!--#include virtual="/techpubs/footer-front" --><!-- end of footer --></body></HTML>