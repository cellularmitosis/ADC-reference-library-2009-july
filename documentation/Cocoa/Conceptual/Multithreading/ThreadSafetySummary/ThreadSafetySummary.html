<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Threading Programming Guide: Thread Safety Summary for Mac OS X</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Thread Safety Summary for Mac OS X"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000057i-CH12" title="Thread Safety Summary for Mac OS X"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ProcessManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000456" target="_top">Process Management</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1">Threading Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../RunLoopManagement/RunLoopManagement.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Glossary/Glossary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000057i-CH12-SW1" title="Thread Safety Summary for Mac OS X"></a><h1>Thread Safety Summary for Mac OS X</h1><p>This appendix describes the high-level thread safety of some key frameworks in Mac OS X. The information in this appendix is subject to change. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW4">Cocoa</a>
				
			<br/>
			
        
			
			
				<a href="ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW9">Core Foundation</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000057i-CH12-SW4" title="Cocoa"></a><h2>Cocoa</h2><p>Guidelines for using Cocoa from multiple threads include the following:</p><ul class="ul"><li class="li"><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_37"></a><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_38"></a>Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads. On the other hand, mutable objects are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize appropriately. For more information, see <span class="content_text"><a href="ThreadSafetySummary.html#//apple_ref/doc/uid/20000736-126010">“Mutable Versus Immutable.”</a></span> </p></li><li class="li"><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_39"></a>The main thread of the application is responsible for handling events. Although the Application Kit continues to work if other threads are involved in the event path, operations can occur out of sequence.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_40"></a><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_41"></a>If you want to use a thread to draw to a view, bracket all drawing code between the <code>lockFocusIfCanDraw</code> and <code>unlockFocus</code> methods of <code>NSView</code>.</p></li><li class="li"><p>To use POSIX threads with Cocoa, you must first put Cocoa into multithreaded mode. For more information, see <span class="content_text"><a href="../CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/20000738-125024">“Creating POSIX Threads in a Cocoa Application.”</a></span> </p></li></ul><a name="//apple_ref/doc/uid/20000736-122647" title="Foundation Framework Thread Safety"></a><a name="//apple_ref/doc/uid/10000057i-CH12-122647-BBCCEGFF" title="Foundation Framework Thread Safety"></a><h3>Foundation Framework Thread Safety</h3><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_42"></a>There is a misconception that the Foundation framework is thread-safe and the Application Kit framework is not. Unfortunately, this is a gross generalization and somewhat misleading. Each framework has areas that are thread-safe and areas that are not thread-safe. The following sections describe the general thread safety of the Foundation framework. </p><a name="//apple_ref/doc/uid/10000057i-CH12-125828" title="Thread-Safe Classes"></a><h4>Thread-Safe Classes</h4><p>The classes and functions in the following table are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock. </p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><td  scope="row"><p><code>NSArray</code></p></td><td ><p><code>NSNotification</code></p></td></tr><tr><td  scope="row"><p><code>NSAssertionHandler</code></p></td><td ><p><code>NSNotificationCenter</code></p></td></tr><tr><td  scope="row"><p><code>NSAttributedString</code></p></td><td ><p><code>NSNumber</code></p></td></tr><tr><td  scope="row"><p><code>NSCalendarDate</code></p></td><td ><p><code>NSObject</code></p></td></tr><tr><td  scope="row"><p><code>NSCharacterSet</code></p></td><td ><p><code>NSPortCoder</code></p></td></tr><tr><td  scope="row"><p><code>NSConditionLock</code></p></td><td ><p><code>NSPortMessage</code></p></td></tr><tr><td  scope="row"><p><code>NSConnection</code></p></td><td ><p><code>NSPortNameServer</code></p></td></tr><tr><td  scope="row"><p><code>NSData</code></p></td><td ><p><code>NSProtocolChecker</code></p></td></tr><tr><td  scope="row"><p><code>NSDate</code></p></td><td ><p><code>NSProxy</code></p></td></tr><tr><td  scope="row"><p><code>NSDecimal</code> functions</p></td><td ><p><code>NSRecursiveLock</code></p></td></tr><tr><td  scope="row"><p><code>NSDecimalNumber</code></p></td><td ><p><code>NSSet</code></p></td></tr><tr><td  scope="row"><p><code>NSDecimalNumberHandler</code></p></td><td ><p><code>NSString</code></p></td></tr><tr><td  scope="row"><p><code>NSDeserializer</code></p></td><td ><p><code>NSThread</code></p></td></tr><tr><td  scope="row"><p><code>NSDictionary</code></p></td><td ><p><code>NSTimeZone</code></p></td></tr><tr><td  scope="row"><p><code>NSDistantObject</code></p></td><td ><p><code>NSTimer</code></p></td></tr><tr><td  scope="row"><p><code>NSDistributedLock</code></p></td><td ><p><code>NSUserDefaults</code></p></td></tr><tr><td  scope="row"><p><code>NSDistributedNotificationCenter</code></p></td><td ><p><code>NSValue</code></p></td></tr><tr><td  scope="row"><p><code>NSException</code></p></td><td ><p>Object allocation and retain count functions</p></td></tr><tr><td  scope="row"><p><code>NSLock</code></p></td><td ><p>Zone and memory functions</p></td></tr><tr><td  scope="row"><p><code>NSLog</code>/<code>NSLogv</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><code>NSMethodSignature</code></p></td><td ><p></p></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH12-125664" title="Thread-Unsafe Classes"></a><h4>Thread-Unsafe Classes</h4><p>The classes and functions in the following table are generally not thread-safe. Check the class documentation for additional details.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><td  scope="row"><p><code>NSAppleScript</code></p></td><td ><p><code>NSMutableAttributedString</code></p></td></tr><tr><td  scope="row"><p><code>NSArchiver</code></p></td><td ><p><code>NSMutableCharacterSet</code></p></td></tr><tr><td  scope="row"><p><code>NSAutoreleasePool</code></p></td><td ><p><code>NSMutableData</code></p></td></tr><tr><td  scope="row"><p><code>NSBundle</code></p></td><td ><p><code>NSMutableDictionary</code></p></td></tr><tr><td  scope="row"><p><code>NSCoder</code></p></td><td ><p><code>NSMutableSet</code></p></td></tr><tr><td  scope="row"><p><code>NSCountedSet</code></p></td><td ><p><code>NSMutableString</code></p></td></tr><tr><td  scope="row"><p><code>NSDateFormatter</code></p></td><td ><p><code>NSNotificationQueue</code></p></td></tr><tr><td  scope="row"><p><code>NSEnumerator</code></p></td><td ><p><code>NSNumberFormatter</code></p></td></tr><tr><td  scope="row"><p><code>NSFileHandle</code></p></td><td ><p><code>NSPipe</code></p></td></tr><tr><td  scope="row"><p><code>NSFileManager</code></p></td><td ><p><code>NSPort</code></p></td></tr><tr><td  scope="row"><p><code>NSFormatter</code></p></td><td ><p><code>NSProcessInfo</code></p></td></tr><tr><td  scope="row"><p><code>NSHashTable</code> functions</p></td><td ><p><code>NSRunLoop</code></p></td></tr><tr><td  scope="row"><p><code>NSHost</code></p></td><td ><p><code>NSScanner</code></p></td></tr><tr><td  scope="row"><p><code>NSInvocation</code></p></td><td ><p><code>NSSerializer</code></p></td></tr><tr><td  scope="row"><p><code>NSJavaSetup</code> functions</p></td><td ><p><code>NSTask</code></p></td></tr><tr><td  scope="row"><p><code>NSMapTable</code> functions</p></td><td ><p><code>NSUnarchiver</code></p></td></tr><tr><td  scope="row"><p><code>NSMutableArray</code></p></td><td ><p><code>NSUndoManager</code></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>User name and home directory functions</p></td></tr></table></div><p>Note that although <code>NSSerializer</code>, <code>NSArchiver</code>, <code>NSCoder</code>, and <code>NSEnumerator</code> objects are themselves thread-safe, they are listed here because it is not safe to change the data objects wrapped by them while they are in use. For example, in the case of an archiver, it is not safe to change the object graph being archived. For an enumerator<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_43"></a>, it is not safe for any thread to change the enumerated collection. </p><a name="//apple_ref/doc/uid/20000736-126010" title="Mutable Versus Immutable"></a><a name="//apple_ref/doc/uid/10000057i-CH12-126010-BCICDFFI" title="Mutable Versus Immutable"></a><h4>Mutable Versus Immutable</h4><p>Immutable objects<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_44"></a> are generally thread-safe; once you create them, you can safely pass these objects to and from threads. Of course, when using immutable objects, you still need to remember to use reference counts correctly. If you inappropriately release an object you did not retain, you could cause an exception later. </p><p>Mutable objects<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_45"></a> are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize access to them using locks. (For more information, see <span class="content_text"><a href="../ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW2">“Atomic Operations”</a></span>). In general, the collection classes (for example, <code>NSMutableArray</code>, <code>NSMutableDictionary</code>) are not thread-safe when mutations are concerned. That is, if one or more threads are changing the same array, problems can occur. You must lock around spots where reads and writes occur to assure thread safety.</p><p>Even if a method claims to return an immutable object, you should never simply assume the returned object is immutable. Depending on the method implementation, the returned object might be mutable or immutable. For example, a method with the return type of <code>NSString</code> might actually return an <code>NSMutableString</code> due to its implementation. If you want to guarantee that the object you have is immutable, you should make an immutable copy. </p><a name="//apple_ref/doc/uid/10000057i-CH12-126101" title="Reentrancy"></a><h4>Reentrancy</h4><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_46"></a>Reentrancy is only possible where operations “call out” to other operations in the same object or on different objects. Retaining and releasing objects is one such “call out” that is sometimes overlooked.</p><p>The following table lists the portions of the Foundation framework that are explicitly reentrant. All other classes may or may not be reentrant, or they may be made reentrant in the future. A complete analysis for reentrancy has never been done and this list may not be exhaustive.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><td  scope="row"><p>Distributed Objects</p></td><td ><p><code>NSNotificationCenter</code></p></td></tr><tr><td  scope="row"><p><code>NSConditionLock</code></p></td><td ><p><code>NSRecursiveLock</code></p></td></tr><tr><td  scope="row"><p><code>NSDistributedLock</code></p></td><td ><p><code>NSRunLoop</code></p></td></tr><tr><td  scope="row"><p><code>NSLock</code></p></td><td ><p><code>NSUserDefaults</code></p></td></tr><tr><td  scope="row"><p><code>NSLog</code>/<code>NSLogv</code></p></td><td ><p></p></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH12-123234" title="Class Initialization"></a><h4>Class Initialization</h4><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_47"></a>The Objective-C runtime system sends an <code>initialize</code><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_48"></a> message to every class object before the class receives any other messages. This gives the class a chance to set up its runtime environment<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_49"></a> before it’s used. In a multithreaded application, the runtime guarantees that only one thread—the thread that happens to send the first message to the class—executes the <code>initialize</code> method. If a second thread tries to send messages to the class while the first thread is still in the <code>initialize</code> method, the second thread blocks until the <code>initialize</code> method finishes executing. Meanwhile, the first thread can continue to call other methods on the class. The <code>initialize</code> method should not rely on a second thread calling methods of the class; if it does, the two threads become deadlocked.</p><p>Due to a bug in Mac OS X version 10.1.x and earlier, a thread could send messages to a class before another thread finished executing that class’s <code>initialize</code> method. The thread could then access values that have not been fully initialized, perhaps crashing the application. If you encounter this problem, you need to either introduce locks to prevent access to the values until after they are initialized or force the class to initialize itself before becoming multithreaded.</p><a name="//apple_ref/doc/uid/10000057i-CH12-123281" title="Autorelease Pools"></a><h4>Autorelease Pools</h4><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_50"></a>Each thread maintains its own stack of <code>NSAutoreleasePool</code> objects<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_51"></a>. Cocoa expects there to be an autorelease pool always available on the current thread’s stack. If a pool is not available, objects do not get released and you leak memory<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_52"></a>. An <code>NSAutoreleasePool</code> object is automatically created and destroyed in the main thread of applications based on the Application Kit, but secondary threads (and Foundation-only applications) must create their own before using Cocoa. If your thread is long-lived and potentially generates a lot of autoreleased objects<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_53"></a>, you should periodically destroy and create autorelease pools (like the Application Kit does on the main thread); otherwise, autoreleased objects accumulate and your memory footprint grows. If your detached thread does not use Cocoa, you do not need to create an autorelease pool.</p><a name="//apple_ref/doc/uid/10000057i-CH12-123295" title="Run Loops"></a><h4>Run Loops</h4><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_54"></a>Every thread has one and only one run loop. Each run loop, and hence each thread, however, has its own set of input modes that determine which input sources are listened to when the run loop is run. The input modes defined in one run loop do not affect the input modes defined in another run loop, even though they may have the same name.</p><p>The run loop for the main thread is automatically run if your application is based on the Application Kit, but secondary threads (and Foundation-only applications) must run the run loop themselves. If a detached thread does not enter the run loop, the thread exits as soon as the detached method finishes executing.</p><p>Despite some outward appearances, the <code>NSRunLoop</code> class is not thread safe. You should call the instance methods of this class only from the thread that owns it. <a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_55"></a></p><a name="//apple_ref/doc/uid/20000736-123351" title="Application Kit Framework Thread Safety"></a><a name="//apple_ref/doc/uid/10000057i-CH12-123351-BBCFIIEB" title="Application Kit Framework Thread Safety"></a><h3>Application Kit Framework Thread Safety</h3><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_56"></a>The following sections describe the general thread safety of the Application Kit framework.</p><a name="//apple_ref/doc/uid/10000057i-CH12-123364" title="Windows"></a><h4>Windows</h4><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_57"></a>You can create a window on a secondary thread. The Application Kit ensures that the data structures associated with a window are deallocated on the main thread to avoid race conditions. There is some possibility that window objects may leak in an application that deals with a lot of windows concurrently. </p><p>You can create a modal window on a secondary thread. The Application Kit blocks the calling secondary thread while the main thread runs the modal loop.</p><a name="//apple_ref/doc/uid/10000057i-CH12-123383" title="Events"></a><h4>Events</h4><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_58"></a>The main thread of the application is responsible for handling events. The main thread is the one blocked in the <code>run</code> method of <code>NSApplication</code>, usually invoked in an application’s <code>main</code> function. While the Application Kit continues to work if other threads are involved in the event path, operations can occur out of sequence. For example, if two different threads are responding to key events, the keys could be received out of order. By letting the main thread process events, you achieve a more consistent user experience. Once received, events can be dispatched to secondary threads for further processing if desired.</p><p>You can call the <code>postEvent:atStart:</code> method of <code>NSApplication</code> from a secondary thread to post an event to the main thread’s event queue. Order is not guaranteed with respect to user input events, however. The main thread of the application is still responsible for handling events in the event queue.</p><a name="//apple_ref/doc/uid/10000057i-CH12-123414" title="Drawing"></a><h4>Drawing</h4><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_59"></a>The Application Kit is generally thread-safe when drawing with its graphics functions and classes, including the <code>NSBezierPath</code> and <code>NSString</code> classes. Details for using particular classes are described in the following sections. Additional information about drawing and threads is available in <em><a href="../../CocoaDrawingGuide/index.html#//apple_ref/doc/uid/TP40003290" target="_top">Cocoa Drawing Guide</a></em>. </p><a name="//apple_ref/doc/uid/10000057i-CH12-123427" title="NSView"></a><h5>NSView</h5><p>The <code>NSView</code> class<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_60"></a> is generally thread-safe, with a few exceptions. You should create, destroy, resize, move, and perform other operations on <code>NSView</code> objects only from the main thread of an application. Drawing from secondary threads is thread-safe as long as you bracket drawing calls with calls to <code>lockFocusIfCanDraw</code><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_61"></a> and <code>unlockFocus</code><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_62"></a>. </p><p>If a secondary thread of an application wants to cause portions of the view to be redrawn on the main thread, it must not do so using methods like <code>display</code>, <code>setNeedsDisplay:</code>, <code>setNeedsDisplayInRect:</code>, or <code>setViewsNeedDisplay:</code>. Instead, it should send a message to the main thread or call those methods using the <code>performSelectorOnMainThread:</code><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_63"></a> method instead. </p><p>The view system’s graphics states (gstates<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_64"></a>) are per-thread. Using graphics states used to be a way to achieve better drawing performance over a single-threaded application but that is no longer true. Incorrect use of graphics states can actually lead to drawing code that is less efficient than drawing in the main thread.</p><a name="//apple_ref/doc/uid/10000057i-CH12-126712" title="NSGraphicsContext"></a><h5>NSGraphicsContext</h5><p>The <code>NSGraphicsContext</code> class<a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_65"></a> represents the drawing context provided by the underlying graphics system. Each <code>NSGraphicsContext</code> instance holds its own independent graphics state: coordinate system, clipping, current font, and so on. An instance of the class is automatically created on the main thread for each <code>NSWindow</code> instance. If you do any drawing from a secondary thread, a new instance of <code>NSGraphicsContext</code> is created specifically for that thread.</p><p>If you do any drawing from a secondary thread, you must flush your drawing calls manually. Cocoa does not automatically update views with content drawn from secondary threads, so you need to call the <code>flushGraphics</code> method of <code>NSGraphicsContext</code> when you finish your drawing. If your application draws content from the main thread only, you do not need to flush your drawing calls.</p><a name="//apple_ref/doc/uid/10000057i-CH12-126728" title="NSImage"></a><h5>NSImage</h5><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_66"></a>One thread can create an <code>NSImage</code> object, draw to the image buffer, and pass it off to the main thread for drawing. The underlying image cache is shared among all threads. For more information about images and how caching works, see <em><a href="../../CocoaDrawingGuide/index.html#//apple_ref/doc/uid/TP40003290" target="_top">Cocoa Drawing Guide</a></em>. <a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_67"></a><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_68"></a></p><a name="//apple_ref/doc/uid/10000057i-CH12-SW7" title="Core Data Framework"></a><h3>Core Data Framework</h3><p>The Core Data framework generally supports threading, although there are some usage caveats that apply. For information on these caveats, see <span class="content_text"><a href="../../CoreData/Articles/cdMultiThreading.html#//apple_ref/doc/uid/TP40003385" target="_top">Multi-Threading with Core Data</a></span> in <em><a href="../../CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_top">Core Data Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/10000057i-CH12-SW9" title="Core Foundation"></a><h2>Core Foundation</h2><p><a name="//apple_ref/doc/uid/10000057i-CH12-DontLinkElementID_69"></a>Core Foundation is sufficiently thread-safe that, if you program with care, you should not run into any problems related to competing threads. It is thread-safe in the common cases, such as when you query, retain, release, and pass around immutable objects. Even central shared objects that might be queried from more than one thread are reliably thread-safe.</p><p>Like Cocoa, Core Foundation is not thread-safe when it comes to mutations to objects or their contents. For example, modifying a mutable data or mutable array object is not thread-safe, as you might expect, but neither is modifying an object inside of an immutable array. One reason for this is performance, which is critical in these situations. Moreover, it is usually not possible to achieve absolute thread safety at this level. You cannot rule out, for example, indeterminate behavior resulting from retaining an object obtained from a collection. The collection itself might be freed before the call to retain the contained object is made.</p><p>In those cases where Core Foundation objects are to be accessed from multiple threads and mutated, your code should protect against simultaneous access by using locks at the access points. For instance, the code that enumerates the objects of a Core Foundation array should use the appropriate locking calls around the enumerating block to protect against someone else mutating the array. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../RunLoopManagement/RunLoopManagement.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Glossary/Glossary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>