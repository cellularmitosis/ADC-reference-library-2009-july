<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Processing Events(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING38></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-37.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-39.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-28.html"><B>Chapter 2 - Event Manager</B></A> / <A HREF="Toolbox-36.html"><B>Using the Event Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING38-0></A>
<H2>Processing Events</H2>
 <A NAME=MARKER-2-90></A>Applications receive events one at a time by asking the Event Manager for the next available event. You use Event Manager routines to receive (or in the case of <CODE>EventAvail</CODE>, simply to look at) the next available event that is pending for your application. You supply an event record as a parameter to the Event Manager routines that retrieve events. The Event Manager fills out the event record with the relevant information about that event and returns it to your application.<A NAME=MARKER-2-117></A> <P>
 Your application can use the <CODE>WaitNextEvent</CODE> function to retrieve events from the Event Manager. If no events are pending for your application, the <CODE>WaitNextEvent</CODE> function may allocate processing time to other applications. If an event is pending for your application, the <CODE>WaitNextEvent</CODE> function returns the next available event of a specified type and removes the returned event from your application's event stream.<P>
 The <CODE>EventAvail</CODE> function gets the next available event of a specified type and returns it to your application, but does not remove the event from your application's event stream. <CODE>EventAvail</CODE> thus allows your application to look at an event in the event stream without actually processing the event.<A NAME=MARKER-2-8></A><A NAME=MARKER-2-93></A><P>
<DL>
<DT><B>Note</B>
<DD>You can also use the <CODE>GetNextEvent</CODE> function to retrieve and remove an event; however, you should use <CODE>WaitNextEvent</CODE> to provide greater support for multitasking.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING38-5></A>
<H3>Using the WaitNextEvent Function</H3>
 Your application typically calls <CODE>WaitNextEvent</CODE> repeatedly. The next section, "Writing an Event Loop," shows how to use <CODE>WaitNextEvent</CODE> with other routines to process events. This discussion focuses on the <CODE>WaitNextEvent</CODE> function itself.<A NAME=MARKER-2-94></A><P>
 The <CODE>WaitNextEvent</CODE> function requires four parameters: <P>
<UL>
<LI>an event mask (<CODE>eventMask</CODE>)
<LI>an event record (<CODE>theEvent</CODE>)
<LI>a sleep value (<CODE>sleep</CODE>)<A NAME=MARKER-2-157></A>
<LI>a mouse region (<CODE>mouseRgn</CODE>)<P>
</UL>
 When <CODE>WaitNextEvent</CODE> returns, the event record contains information about the retrieved event, if any. <P>
 The <CODE>eventMask</CODE> parameter specifies the events you are interested in receiving. <CODE>WaitNextEvent</CODE> returns events one at a time, in order of priority and at your application's request, according to the value you specify in the <CODE>eventMask</CODE> parameter. If your application specifies that it doesn't want to receive particular types of events, those events are not returned to your application when it makes a request for an event. However, those events are not removed from the event stream. (To remove events from the Operating System event queue, you can use the <CODE>FlushEvents</CODE> procedure with a mask specifying only those events you wish to remove from the queue.) See <A HREF=#MARKER-9-112>"Setting the Event Mask" beginning on page 2-26</A> for examples of how to use constants to set the value of the <CODE>eventMask</CODE> parameter.<A NAME=MARKER-2-347></A><P>
 The <CODE>sleep</CODE> parameter specifies the amount of time (in ticks) for which your application agrees to relinquish the processor if no events are pending for it. When that time expires or when an event becomes available for your application, the Process Manager schedules your application for execution. In general, you should specify a value greater than 0 in the <CODE>sleep</CODE> parameter so that other applications can receive processing time if they need it. If the user is editing text and your application needs to blink the caret at periodic intervals or uses TextEdit to blink the caret, your application should not specify a value greater than the value returned by the <CODE>GetCaretTime</CODE> function.<A NAME=MARKER-2-177></A><P>
 In the <CODE>mouseRgn</CODE> parameter you specify a screen region inside of which the Event Manager does <I>not</I> generate mouse-moved events. You should specify the region in <BR>global coordinates. If the user moves the cursor outside of this region and your application is the foreground process, the Event Manager reports mouse-moved events. Your application should recalculate the <CODE>mouseRgn</CODE> parameter when it receives a mouse-moved event; otherwise it will continue to receive mouse-moved events as long as the cursor is outside of the original region. If you pass an empty region or a <CODE>NIL</CODE> region handle, the Event Manager does not return mouse-moved events. You can use the <CODE>mouseRgn</CODE> parameter as a convenient way to change the shape of the cursor--for example, when the user moves the cursor from the content area of a window to the scroll bar. See <A HREF=Toolbox-41.html#MARKER-9-249>"Responding to Mouse-Moved Events" beginning on page 2-62</A> for information on how to set and change the <CODE>mouseRgn</CODE> parameter. <A NAME=MARKER-9-194></A><A NAME=MARKER-2-372></A><P>
 <A HREF=#MARKER-9-100>Listing 2-1</A> shows an example of using the <CODE>WaitNextEvent</CODE> function.<P>
<B>Listing 2-1  <A NAME=MARKER-9-100></A>Using the <CODE>WaitNextEvent</CODE> function</B><P>
<PRE>
VAR
   eventMask:     Integer;
   event:         EventRecord;
   cursorRgn:     RgnHandle;
   mySleep:       LongInt;
   gotEvent:      Boolean;

   eventMask := everyEvent;   {accept all events}
   mySleep := MyGetSleep;     {set an appropriate sleep value}
   cursorRgn := MyGetRgn;     {set the region as appropriate}
   gotEvent := WaitNextEvent(eventMask,event,mySleep,cursorRgn);
</PRE>
 The code in <A HREF=#MARKER-9-100>Listing 2-1</A> specifies that <CODE>WaitNextEvent</CODE> should return the next pending event of any kind, give up the processor if no events are pending, and return a mouse-moved event if the user moves the cursor out of the specified region.<P>
 The <CODE>WaitNextEvent</CODE> function returns after retrieving an event or after the time specified in the <CODE>sleep</CODE> parameter has expired. If there are no events of the types specified by the <CODE>eventMask</CODE> parameter (other than null events) pending for your application, and the time specified in the <CODE>sleep</CODE> parameter has not expired, <CODE>WaitNextEvent</CODE> may allocate processing time to background processes. Once an <BR>event for your application occurs or the time specified in the <CODE>sleep</CODE> parameter <BR>expires, your application receives processing time again.<P>
 <CODE>WaitNextEvent</CODE> returns a function result of <CODE>TRUE</CODE> if it has retrieved any event other than a null event. If there are no events of the types specified by the <CODE>eventMask</CODE> parameter (other than null events) pending for the application, <CODE>WaitNextEvent</CODE> <BR>returns <CODE>FALSE</CODE>.<P>
 Before returning an event to your application, <CODE>WaitNextEvent</CODE> performs other processing and may intercept the event. The <CODE>WaitNextEvent</CODE> function: <P>
<UL>
<LI>Calls the Operating System Event Manager function <CODE>SystemEvent</CODE> to determine whether the event should be handled by your application or the Operating System. For example, if the event is a Command-Shift-number key sequence, the Event Manager intercepts the event and calls the corresponding '<CODE>FKEY</CODE>' resource to perform the associated action.
<LI>Makes the alarm go off if the alarm is set and the current time is the alarm time. The user sets the alarm using the Alarm Clock desk accessory.
<LI>Calls the <CODE>SystemTask</CODE> procedure, which gives time to each open desk accessory or device driver to perform any periodic action defined for it. A desk accessory or device driver specifies how often the periodic action should occur, and <CODE>SystemTask</CODE> gives time to the desk accessory or device driver at the appropriate interval.<P>
</UL>
 In System 7, the <CODE>WaitNextEvent</CODE> function reports a suspend event to your <BR>application when<P>
<UL>
<LI>your application is in the foreground and the user opens a desk accessory or other item from the Apple menu,
<LI>the user clicks in the window belonging to a desk accessory or another application, or
<LI>the user chooses another process from the Application menu. <P>
</UL>
 After your application is switched out, the Event Manager directs events (other than events your application can receive in the background) to the newly activated process until the user switches back to your application or another application.<A NAME=MARKER-2-101></A><P>
<A NAME=HEADING38-31></A>
<H3>Writing an Event Loop</H3>
 In applications that are event-driven (that is, applications that decide what to do at any time by receiving and responding to events), you can obtain information about pending events by calling Event Manager routines. Since you call these routines repeatedly, the section of code in which you request events from the Event Manager usually takes the form of a loop; this section of code is called the event loop.<A NAME=MARKER-2-137></A><P>
 <A HREF=#MARKER-9-103>Listing 2-2</A> shows a simple event loop (an application-defined procedure called <CODE>MyEventLoop</CODE>) for an application running in System 7. <P>
<B>Listing 2-2  <A NAME=MARKER-9-103></A>An event loop<A NAME=MARKER-9-239></A></B><P>
<PRE>
PROCEDURE MyEventLoop;
VAR
   cursorRgn:     RgnHandle;
   gotEvent:      Boolean;
   event:         EventRecord;
BEGIN
   cursorRgn := NewRgn; {pass an empty region the first time thru}
   REPEAT
      gotEvent := WaitNextEvent(everyEvent, event, MyGetSleep,
                                 cursorRgn);
      IF (event.what &lt;&gt; kHighLevelEvent) AND (NOT gInBackground) 
         THEN MyAdjustCursor(event.where, cursorRgn);
      IF gotEvent THEN  {the event isn't a null event, }
         DoEvent(event) { so handle it}
      ELSE              {no event (other than null) to handle }
         DoIdle(event); { right now, so do idle processing}
   UNTIL gDone;         {loop until user quits}
END;
</PRE>
 The <CODE>MyEventLoop</CODE> procedure repeatedly uses <CODE>WaitNextEvent</CODE> to retrieve events. The <CODE>WaitNextEvent</CODE> function returns a Boolean value of <CODE>FALSE</CODE> if there are no events of the specified types other than null events pending for the application. <CODE>WaitNextEvent</CODE> returns <CODE>TRUE</CODE> if it has retrieved any event other than a null event.<P>
 After <CODE>WaitNextEvent</CODE> returns, the <CODE>MyEventLoop</CODE> procedure first calls an application- defined routine, <CODE>MyAdjustCursor</CODE>, to adjust the cursor as necessary. You usually adjust the cursor in response to mouse-moved events, and often in response to other events as well. This code adjusts the cursor once every time through the event loop, when the application receives any event other than a high-level event. The code does not adjust the cursor if the event is a high-level event, because the <CODE>where</CODE> field of a high-level event contains the event ID, not the location of the cursor. The code also does not adjust the cursor if this application is in the background, as the foreground process is responsible for setting the appearance of the cursor.<P>
 If <CODE>WaitNextEvent</CODE> retrieved any event other than a null event, the event loop calls <CODE>DoEvent</CODE>, an application-defined procedure, to process the event. Otherwise, the procedure calls an application-defined idling procedure, <CODE>DoIdle</CODE>. <P>
<DL>
<DT><B>Note</B>
<DD>If your application uses modeless dialog boxes, you need to appropriately handle events in them. You can choose to handle events for modeless dialog boxes using the same routines that you use to handle events in other windows; this is the approach used throughout this chapter. Alternatively, you can choose to call the <CODE>IsDialogEvent</CODE> function in your event loop. See <A HREF=#MARKER-9-122>"Handling Events in a Dialog Box" on page 2-29</A> for information on handling events in alert boxes, modal dialog boxes, movable modal dialog boxes, and modeless dialog boxes. For additional information on dialog boxes, see the chapter "Dialog Manager" in this book.<EM></EM><A NAME=MARKER-2-105></A>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 If you intend to design your application to run in either a single-application environment (such as System 6 without MultiFinder) or a multiple-application environment, <BR>the very beginning of your event loop should test to make sure the <CODE>WaitNextEvent</CODE> function is available. If <CODE>WaitNextEvent</CODE> is not available, your code should use <BR><CODE>GetNextEvent</CODE> to retrieve events. If your code uses <CODE>GetNextEvent</CODE>, it should also <BR>call <CODE>SystemTask</CODE> to allow desk accessories to perform periodic actions. However, <BR>your code should always use <CODE>WaitNextEvent</CODE> if it is available, rather than <BR><CODE>GetNextEvent</CODE>. If your application calls <CODE>WaitNextEvent</CODE>, it should not call the <BR><CODE>SystemTask</CODE> procedure. <A NAME=MARKER-2-388></A> <A NAME=MARKER-9-442></A><P>
 The event loop shown in <A HREF=#MARKER-9-103>Listing 2-2</A> calls an application-defined procedure, <CODE>DoEvent<DFN>, to </DFN></CODE>determine what kind of event the call to <CODE>WaitNextEvent</CODE> retrieved. <A HREF=#MARKER-9-110>Listing 2-3</A> defines a simple <CODE>DoEvent</CODE> procedure.<DFN> </DFN>The <CODE>DoEvent</CODE> procedure examines the value of the <CODE>what</CODE> field of the event record to determine the type of event received and then calls an appropriate application-defined routine to further process the event. <A NAME=MARKER-2-298></A><A NAME=MARKER-2-109></A><P>
<B>Listing 2-3  <A NAME=MARKER-9-110></A>Processing events <A NAME=MARKER-9-313></A></B><P>
<PRE>
PROCEDURE DoEvent (event: EventRecord);
VAR
   window:     WindowPtr;
   activate:   Boolean;
BEGIN
   CASE event.what OF
      mouseDown:
         DoMouseDown(event);
      mouseUp:
         DoMouseUp(event);
      keyDown, autoKey: 
         DoKeyDown(event);
      activateEvt:
         BEGIN
            window := WindowPtr(event.message);
            activate := BAnd(event.modifiers, activeFlag) &lt;&gt; 0;
            DoActivate(window, activate, event);
         END;
      updateEvt:
         DoUpdate(WindowPtr(event.message));
      diskEvt:
         DoDiskEvent(event);
      osEvt:
         DoOSEvent(event);
      kHighLevelEvent:
         DoHighLevelEvent(event);
   END; {of case}
END; 
</PRE>
 The next sections describe how to set the event mask, handle events in dialog boxes, <BR>and create your application's <CODE>'SIZE'</CODE> resource. Following sections show code that can handle each kind of event.<P>
<A NAME=HEADING38-45></A>
<H3><A NAME=MARKER-9-112></A>Setting the Event Mask</H3>
 <A NAME=MARKER-2-180></A>Several of the Event Manager routines can be restricted to operate on a specific event type or group of types. You do this by specifying the event types you want your application to receive, thereby disabling (or "masking out") the events you are not interested in receiving. To specify which event types an Event Manager routine governs, you supply a parameter known as an event mask. <A NAME=MARKER-2-114></A><P>
 The <B>event mask</B> is an integer with one bit position for each event type. If the bit representing a particular event type is set, then the Event Manager returns events of <BR>that type. If the bit is set to 0, the Event Manager does not return events of that type. To accept all types of events, set every bit of the event mask to 1. You can do this using the constant <CODE>everyEvent</CODE>.<P>
<PRE>
CONST everyEvent           =  -1;      {every event}
</PRE>
 <A HREF=#MARKER-9-115>Figure 2-6</A> shows the bits corresponding to each event type in the event mask.<P>
<B>Figure 2-6  <A NAME=MARKER-9-115></A>The event mask</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-6_EV-06.jpg"><P>
 You can use these constants when referring to the bits in the event mask that correspond to each individual event type:<A NAME=MARKER-2-116></A><P>
<PRE>
CONST mDownMask            =  2;       {mouse-down event       (bit 1)}    
      mUpMask              =  4;       {mouse-up event         (bit 2)}
      keyDownMask          =  8;       {key-down event         (bit 3)}
      keyUpMask            =  16;      {key-up event           (bit 4)}
      autoKeyMask          =  32;      {auto-key event         (bit 5)}
      updateMask           =  64;      {update event           (bit 6)}
      diskMask             =  128;     {disk-inserted event    (bit 7)}
      activMask            =  256;     {activate event         (bit 8)}
      highLevelEventMask   =  1024;    {high-level event       (bit 10)}
      osMask               =  -32768;  {operating-system event (bit 15)}
</PRE>
 You can select any subset of events by adding or subtracting these constants. For example, you can use this code to accept only high-level events and mouse-down events and mask out all other events: <P>
<PRE>
myErr := WaitNextEvent(highLevelEventMask + mDownMask, myEvent,
                         mySleep, myMRgnHnd);
</PRE>
 The <CODE>everyEvent</CODE> constant indicates that you wish to receive every type of event. To accept all events except mouse-up events, you can use the code:<P>
<PRE>
myErr := WaitNextEvent(everyEvent - mUpMask, myEvent, mySleep,
                         myMRgnHnd);
</PRE>
 Masking out specific types of events does not remove those events from the event stream. If a type of event is masked out, the Event Manager simply ignores it when reporting events from the event stream. Note that you cannot mask out null events by setting the event mask. The Event Manager always returns a null event if no other events are pending. However, if you do not want the Event Manager to report null events to your application when it is in the background, you can set the <CODE>cannotBackground</CODE> flag in your application's <CODE>'SIZE'</CODE> resource. <A NAME=MARKER-2-117></A><P>
 In most cases you should always use <CODE>everyEvent</CODE> as your event mask. The user expects most applications to respond to keyboard, mouse, update, and other events.<P>
 <A NAME=MARKER-2-193></A>The types of events returned to your application are also affected by the system event mask. The Event Manager maintains a system event mask for each application. The system event mask controls which low-level event types get posted in the Operating System event queue. The Event Manager uses the system event mask of the current process (the process that is currently executing and the process associated with the <CODE>CurrentA5</CODE> global variable) when determining which low-level events to post in the  Operating System event queue. The system event mask is an integer with 1 bit for <BR>each corresponding low-level event type. These constants refer to the bits that represent the corresponding low-level event types in the system event mask:<A NAME=MARKER-2-491></A><P>
<PRE>
CONST mDownMask            =  2;       {mouse-down    (bit 1)}
      mUpMask              =  4;       {mouse-up      (bit 2)}
      keyDownMask          =  8;       {key-down      (bit 3)}
      keyUpMask            =  16;      {key-up        (bit 4)}
      autoKeyMask          =  32;      {auto-key      (bit 5)}
      diskMask             =  128;     {disk-inserted (bit 7)}
</PRE>
 When a low-level event (other than an update or activate event) occurs, the Operating System Event Manager posts the low-level event in the Operating System event queue only if the bit corresponding to the low-level event type is set in the system event mask of the current process. When your application starts, the Operating System initializes the system event mask of your application to post mouse-up, mouse-down, key-down, auto-key, and disk-inserted events in the Operating System event queue. Thus, the system event mask has this initial setting:<P>
<PRE>
systemEventMask := everyEvent - keyUpMask;
</PRE>
 <A NAME=MARKER-2-495></A>Your application should not change the system event mask except to enable key-up events if your application needs to respond to key-up events. (Most applications ignore key-up events.) If your application needs to receive key-up events, you can change the system event mask using the Operating System Event Manager procedure <CODE>SetEventMask<DFN>. Note that your application cannot rely on receiving key-up events when it is not the current process. For example, if your application is the foreground (and current) process and a minor switch occurs, the Event Manager uses the system event mask of the background process (now the current process) when posting low-level event types. When your application becomes the current process again, the Event Manager uses the system event mask of your application when posting low-level events. <A NAME=MARKER-9-589></A></DFN></CODE><P>
<A NAME=HEADING38-65></A>
<H3><A NAME=MARKER-9-122></A>Handling Events in a Dialog Box</H3>
 <A NAME=MARKER-2-134></A>If your application uses alert boxes, modal dialog boxes, movable modal dialog boxes, <BR>or modeless dialog boxes, you need to make sure your application handles events for them appropriately. <P>
 To display and handle events in alert boxes, you use the Dialog Manager functions <CODE>Alert</CODE>, <CODE>NoteAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>StopAlert</CODE>. The Dialog Manager handles all of the events generated by the user until the user clicks a button (typically the OK or Cancel button). When the user clicks the OK or Cancel button, the alert box functions highlight the button that was clicked, close the alert box, and report the user's selection to your application. Your application is responsible for performing the appropriate action associated with that button. <P>
 For modal dialog boxes, you can use the Dialog Manager procedure <CODE>ModalDialog</CODE>. The Dialog Manager handles most of the user interaction until the user selects an item. The <CODE>ModalDialog</CODE> procedure then reports that the user selected an enabled item, and your application is responsible for performing the action associated with that item. Your application typically calls <CODE>ModalDialog</CODE> repeatedly, responding to clicks on enabled items as reported by <CODE>ModalDialog</CODE>, until the user selects OK or Cancel.<P>
 For alert boxes and modal dialog boxes, you should also supply an event filter function as one of the parameters to the alert box functions or <CODE>ModalDialog</CODE> procedure. As the user interacts with the alert or modal dialog box, these functions pass events to your event filter function before handling each event. Your event filter function can handle any events not handled by the Dialog Manager or, if necessary, can choose to handle events normally handled by the Dialog Manager. For more information on filter functions for alert and dialog boxes, see the chapter "Dialog Manager" in this book.<P>
 To handle events in movable modal dialog boxes, you can use the Dialog Manager functions <CODE>IsDialogEvent</CODE> and <CODE>DialogSelect</CODE> or you can use other Toolbox routines to handle events without using the Dialog Manager.<P>
 <A NAME=MARKER-2-124></A>For modeless dialog boxes, you can choose to handle events in them using an approach similar to the one you use to handle events in other windows; that is, when you receive an event, you first determine the type of event that occurred and then take the appropriate action based on the type of window that is in front. If a modeless dialog box is in front, you can provide code that takes any actions specific to that modeless dialog box and call the <CODE>DialogSelect</CODE> function to handle any events that your code doesn't handle. This is the approach used throughout this chapter. Alternatively, you can choose to call the <CODE>IsDialogEvent</CODE> function in your event loop. If you do this, you can use the <CODE>IsDialogEvent</CODE> function to determine whether the event involves a modeless dialog box that belongs to your application. If the event involves a modeless dialog box (including null events) and a modeless dialog box is active, <CODE>IsDialogEvent</CODE> returns <CODE>TRUE</CODE>. Otherwise, <CODE>IsDialogEvent</CODE> returns <CODE>FALSE</CODE>.<P>
 If <CODE>IsDialogEvent</CODE> returns <CODE>TRUE</CODE>, your application can check to see what type of event occurred and, depending on the type of event, it can choose to handle the event itself. <P>
 Regardless of the approach you use, if your application chooses not to handle the event, it should call <CODE>DialogSelect</CODE>. The <CODE>DialogSelect</CODE> function handles events for modeless dialog boxes (including null events). It also blinks the caret in editable text items when necessary. <P>
 For more information on the <CODE>DialogSelect</CODE> function and events in dialog boxes, see the chapter "Dialog Manager" in this book.<A NAME=MARKER-2-211></A><A NAME=MARKER-2-372></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-37.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-39.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
