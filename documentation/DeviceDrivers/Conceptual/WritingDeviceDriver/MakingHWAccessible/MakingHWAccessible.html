<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Device Driver Design Guidelines: Making Hardware Accessible to Applications</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Making Hardware Accessible to Applications"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000698" title="Making Hardware Accessible to Applications"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Intro.html#//apple_ref/doc/uid/TP40002799-TPXREF101">I/O Kit Device Driver Design Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../IOService/IOService.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../KernelUserNotification/KernelUserNotification.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000698-BBCCJDEH" title="Making Hardware Accessible to Applications"></a><h1>Making Hardware Accessible to Applications</h1><p>Let's assume you have written a driver for a device, have thoroughly tested it, and are ready to deploy it. Is your job done? Not necessarily, because there is the perennial problem for driver writers of making their service accessible to user processes. A driver without clients in user space is useless (unless all of its clients reside in the kernel).</p><p>This chapter does a few things to help you on this score. It describes the architectural aspects of Mac OS X and the Darwin kernel that underlie the transport of data across the boundary separating the kernel and user space. It describes the alternative APIs on Mac OS X for cross-boundary transport between a driver stack and an application. And it describes how to roll your own solution by writing a custom user client, finally taking you on a detailed tour through an example implementation.</p><p>To better understand the information presented in this section, it is recommended that you become familiar with the material in<em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top"> I/O Kit Fundamentals</a></em> and the relevant sections of <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-TPXREF101">Transferring Data Into and Out of the Kernel</a>
				
			<br/>
			
        
			
			
				<a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-TPXREF108">Writing a Custom User Client</a>
				
			<br/>
			
        
			
			
				<a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBJEBCB">A Guided Tour Through a User Client</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000698-TPXREF101" title="Transferring Data Into and Out of the Kernel"></a><h2>Transferring Data Into and Out of the Kernel</h2><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_561"></a>The Darwin kernel gives you several ways to let your kernel code communicate with application code. The specific kernel–user space transport API to use depends on the circumstances.</p><ul class="ul"><li class="li"><p>If you are writing code that resides in the BSD subsystem, you use the <code>syscall</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_562"></a> or (preferably) the <code>sysctl</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_563"></a> API. You should use the <code>syscall</code> API if you are writing a file-system or networking extension.</p></li><li class="li"><p>If your kernel code is not part of the BSD subsystem (and your code is not a driver), you probably want to use Mach messaging<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_564"></a> and Mach Inter-Process Communication<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_565"></a> (IPC<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_566"></a>). These APIs allow two Mach tasks (including the kernel) to communicate with each other. Mach Remote Process Communication<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_567"></a> (RPC<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_568"></a>), a procedural abstraction built on top of Mach IPC, is commonly used instead of Mach IPC.</p></li><li class="li"><p>You may use memory mapping (particularly the BSD <code><!--a-->copyin<!--/a--></code> and <code><!--a-->copyout<!--/a--></code> routines) and block copying in conjunction with one of the aforementioned APIs to move large or variably sized chunks of data between the kernel and user space.</p></li></ul><p>Finally, there are the I/O Kit transport mechanisms and APIs that enable driver code to communicate with application code. This section describes aspects of the kernel environment that give rise to these mechanisms and discusses the alternatives available to you.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_81" title="Note"></a><p><strong>Note:</strong>&nbsp;For more information on the other Darwin APIs for kernel–user space transport, see <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>.</p></div><a name="//apple_ref/doc/uid/TP30000698-BAJHDGJA" title="Issues With Cross-Boundary I/O"></a><h3>Issues With Cross-Boundary I/O</h3><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_569"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_570"></a>An important<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_571"></a> feature of the Mac OS X kernel is memory protection. Each process on the system, including the kernel, has its own address space which other processes are not free to access in an unrestricted manner. Memory protection is essential to system stability. It’s bad enough when a user process crashes because some other process trashed its memory. But it’s catastrophic—a system crash—when the kernel goes down for the same reason.</p><p>Largely (but not exclusively) because of memory protection, there are certain aspects of the kernel that affect how cross-boundary I/O takes place, or should take place: </p><ul class="spaceabove"><li class="li"><p><strong>The kernel is a slave to the application.</strong> Code in the kernel (such as in a driver) is passive in that it only reacts to requests from processes in user space. Drivers should not initiate any I/O activity on their own.</p></li><li class="li"><p><strong>Kernel resources are discouraged in user space.</strong> Application code cannot be trusted with kernel resources such as kernel memory buffers and kernel threads. This kind of exposure leaves the whole system vulnerable; an application can trash critical areas of physical memory or do something globally catastrophic with a kernel thread, crashing the entire system. To eliminate the need for passing kernel resources to user space, the system provides several kernel–user space transport mechanisms for a range of programmatic circumstances. </p></li><li class="li"><p><strong>User processes cannot take direct interrupts.</strong> As a corollary to the previous point, kernel interrupt threads cannot jump to user space. Instead, if your application must be made aware of interrupts, it should provide a thread on which to deliver a notification of them.</p></li><li class="li"><p><strong>Each kernel–user space transition incurs a performance hit.</strong> The kernel's transport mechanisms consume resources and thus exact a performance penalty. Each trip from the kernel to user space (or vice versa) involves the overhead of Mach RPC calls, the probable allocation of kernel resources, and perhaps other expensive operations. The goal is to use these mechanisms as efficiently as possible.</p></li><li class="li"><p><strong>The kernel should contain only code that must be there.</strong> Adding unnecessary code to the kernel—specifically code that would work just as well in a user process—bloats the kernel, potentially destabilizes it, unnecessarily wires down physical memory (making it unavailable to applications), and degrades overall system performance. See <em><a href="../../../../Darwin/Conceptual/ShouldYou.html#//apple_ref/doc/uid/TP30001137" target="_top">Coding in the Kernel</a></em> for a fuller explanation of why you should always seek to avoid putting code in the kernel.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_572"></a></p></li></ul><a name="//apple_ref/doc/uid/TP30000698-TPXREF102" title="Mac OS 9 Compared"></a><h4>Mac OS 9 Compared</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_573"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_574"></a>On Mac OS 9, applications access hardware in a way that is entirely different from the way it is done on Mac OS X. The difference in approach is largely due to differences in architecture, particularly in the relationship between an application and a driver.</p><p>Unlike Mac OS X, Mac OS 9 does not maintain an inviolable barrier between an application's address space and the address space of anything that would be found in the Mac OS X kernel. An application has access to the address of any other process in the system, including that of a driver.</p><p>This access affects how completion routines are invoked. The structure behind all I/O on a Mac OS 9 system is called a parameter block. The parameter block contains the fields typically required for a DMA transfer:</p><ul class="spaceabove"><li class="li"><p>Host address</p></li><li class="li"><p>Target address</p></li><li class="li"><p>Direction of transfer</p></li><li class="li"><p>Completion routine and associated data</p></li></ul><p>The completion routine is implemented by the application to handle any returned results. The driver maintains a linked list of parameter blocks as I/O requests or jobs for the DMA engine to perform. When a job completes, the hardware triggers an interrupt, prompting the driver to call the application’s completion routine. The application code implementing the completion routine runs at “interrupt time”—that is, in the context of the hardware interrupt. This leads to a greater likelihood that a programming error in the completion routine can crash or hang the entire system.</p><p>If the same thing with interrupts happened on Mac OS X, there would additionally be the overhead of crossing the kernel–user space boundary (with its performance implications) as well as the risk to system stability that comes with exporting kernel resources to user space.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_575"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_576"></a></p><a name="//apple_ref/doc/uid/TP30000698-TPXREF103" title="Programming Alternatives"></a><h3>Programming Alternatives</h3><p>The I/O Kit gives you several ready-made alternatives for performing cross-boundary I/O without having to add code to the kernel: </p><ul class="spaceabove"><li class="li"><p>I/O Kit family device interfaces</p></li><li class="li"><p>POSIX APIs</p></li><li class="li"><p>I/O Registry properties</p></li></ul><p>When facing the problem of communication between driver and application, you should first consider whether any of these options suits your particular needs. Each of them has its intended uses and each has limitations that might make it unsuitable. However, only after eliminating each of these alternatives as a possibility should you decide upon implementing your own driver–application transport, which is called a custom user client.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_82" title="Note"></a><p><strong>Note:</strong>&nbsp;This section summarizes information from the document <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em> that explains how to use device interfaces and how to get device paths for POSIX I/O routines. Refer to that document for comprehensive descriptions of these procedures.</p></div><a name="//apple_ref/doc/uid/TP30000698-TPXREF104" title="I/O Kit Family Device Interfaces"></a><h4>I/O Kit Family Device Interfaces</h4><p>A<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_577"></a> device interface is the flip side of what is known as a user client in the kernel. A device interface is a library or plug-in through whose interface an application can access a device. The application can call any of the functions defined by the interface to communicate with or control the device. In turn, the library or plug-in talks with a user-client object (an instance of a subclass of IOUserClient) in a driver stack in the kernel. (See <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCBGFHD">“The Architecture of User Clients”</a></span> for a full description of these types of driver objects.)</p><p>Several I/O Kit families provide device interfaces for applications and other user-space clients. These families include (but are not limited to) the SCSI, HID, USB, and FireWire families. (Check the header files in the I/O Kit framework to find out about the complete list of families providing device interfaces.) If your driver is a member of one of these families, your user-space clients need only use the device interface of the family to access the hardware controlled by your driver.</p><p>See <span class="content_text"><a href="../../AccessingHardware/AH_Finding_Devices/AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379" target="_top">Finding and Accessing Devices</a></span> in <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em> for a detailed presentation of the procedure for acquiring and using device interfaces. </p><a name="//apple_ref/doc/uid/TP30000698-TPXREF105" title="Using POSIX APIs"></a><h4>Using POSIX APIs</h4><p>For<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_578"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_579"></a> each storage, network, and serial device the I/O Kit dynamically creates a device file in the file system’s <code>/dev</code> directory when it discovers a device and finds a driver for it, either at system startup or as part of its ongoing matching process. If your device driver is a member of the I/O Kit’s Storage, Network, or Serial families, then your clients can access your driver’s services by using POSIX I/O routines. They can simply use the I/O Registry to discover the device file that is associated with the device your driver controls. Then, with that device file as a parameter, they call POSIX I/O functions to open and close the device and read and write data to it.</p><p>Because the I/O Kit dynamically generates the contents of the <code>/dev</code> directory as devices are attached and detached, you should never hard-code the name of a device file or expect it to remain the same whenever your application runs. To obtain the path to a device file, you must use device matching to obtain a device path from the I/O Registry. Once you have found the correct path, you can use POSIX functions to access the device. For information on using the I/O Registry to find device-file paths, see <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF106" title="Accessing Device Properties"></a><h4>Accessing Device Properties</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_580"></a>The I/O Registry is the dynamic database that the I/O Kit uses to store the current properties and relationships of driver objects in a Mac OS X system. APIs in the kernel and in user space give access to the I/O Registry, allowing code to get and set properties of objects in the Registry. This common access makes possible a limited form of communication between driver and application.</p><p>All driver objects in the kernel derive from IOService, which is in turn a subclass of the IORegistryEntry class. The methods of IORegistryEntry enable code in the kernel to search the I/O Registry for specific entries and to get and set the properties of those entries. A complementary set of functions (defined in <code>IOKitLib.h</code>) exist in the I/O Kit framework. Applications can use the functions to fetch data stored as properties of a driver object or to send data to a driver object.</p><p>This property-setting mechanism is suitable for situations where the following conditions are true: </p><ul class="spaceabove"><li class="li"><p>The driver does not have to allocate permanent resources to complete the transaction.</p></li><li class="li"><p>The application is transferring—by copy—a limited amount of data (under a page)</p><p>With the property-setting mechanism, the application can pass arbitrary amounts of data by reference (that is, using pointers). </p></li><li class="li"><p>The data sent causes no change in driver state or results in a single, permanent change of state.</p></li><li class="li"><p>You control the driver in the kernel (and thus can implement the <code>setProperties</code> method described below).</p></li></ul><p>The property-setting mechanism is thus suitable for some forms of device control and is ideal for one-shot downloads of data, such as for loading firmware. It is not suitable for connection-oriented tasks because such tasks usually require the allocation of memory or the acquisition of devices. Moreover, this mechanism does not allow the driver to track when its clients die. </p><p>The general procedure for sending data from an application to a driver object as a property starts with establishing a connection with the driver. The procedure for this, described in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCDBJII">“The Basic Connection and I/O Procedure,”</a></span> consists of three steps:</p><ol class="ol"><li class="li"><p>Getting the I/O Kit master port</p></li><li class="li"><p>Obtaining an instance of the driver</p></li><li class="li"><p>Creating a connection</p></li></ol><p>Once you have a connection, do the following steps:</p><ol class="ol"><li class="li"><p>Call the <code><!--a-->IOConnectSetCFProperties<!--/a--></code> function, passing in the connection and a Core Foundation container object, such as a CFDictionary.</p><p>The Core Foundation object contains the data you want to pass to the driver. Note that you can call <code><!--a-->IOConnectSetCFProperty<!--/a--></code> instead if you want to pass only a single, value-type Core Foundation object, such as a CFString or a CFNumber and that value’s key. Both function calls cause the invocation of the <code>IORegistryEntry::setProperties</code> method in the driver.</p></li><li class="li"><p>In the driver, implement the <code>setProperties</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_581"></a> method.</p><p>Before it invokes this method, the I/O Kit converts the Core Foundation object passed in by the user process to a corresponding libkern container object (such as OSDictionary). In its implementation of this method, the driver object extracts the data from the libkern container object and does with it what is expected.</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_83" title="Note"></a><p><strong>Note:</strong>&nbsp;Instead of calling <code><!--a-->IOConnectSetCFProperties<!--/a--></code> you can call <code><!--a-->IORegistryEntrySetCFProperties<!--/a--></code>. This latter function is more convenient in those instances where you have an <code>io_service_t</code> handle available, such as from calling <code><!--a-->IOIteratorNext<!--/a--></code>.</p></div><p>The Core Foundation object passed in by the user process must, of course, have a libkern equivalent. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCCJEJC">Table 4-1</a></span> shows the allowable Core Foundation types and their corresponding libkern objects.</p><a name="//apple_ref/doc/uid/TP30000698-BBCCJEJC" title="Table 4-1Corresponding Core Foundation and libkern container types"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4-1&nbsp;&nbsp;</strong>Corresponding Core Foundation and libkern container types</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Core Foundation</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>libkern</p></th></tr><tr><td  scope="row"><p>CFDictionary</p></td><td ><p>OSDictionary</p></td></tr><tr><td  scope="row"><p>CFArray</p></td><td ><p>OSArray</p></td></tr><tr><td  scope="row"><p>CFSet</p></td><td ><p>OSSet</p></td></tr><tr><td  scope="row"><p>CFString</p></td><td ><p>OSString</p></td></tr><tr><td  scope="row"><p>CFData</p></td><td ><p>OSData</p></td></tr><tr><td  scope="row"><p>CFNumber</p></td><td ><p>OSNumber</p></td></tr><tr><td  scope="row"><p>CFBoolean</p></td><td ><p>OSBoolean</p></td></tr></table></div><p>The following example (<span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCFICHI">Listing 4-1</a></span>) shows how the I/O Kit’s Serial family uses the I/O Registry property-setting mechanism to let a user process make a driver thread idle until a serial port is free to use (when there are devices, such as a modem and a fax, competing for the port).</p><a name="//apple_ref/doc/uid/TP30000698-BBCFICHI" title="Listing 4-1Controlling a serial device using setProperties"></a><p class="codesample"><strong>Listing 4-1&nbsp;&nbsp;</strong>Controlling a serial device using <code>setProperties</code></p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn IOSerialBSDClient::<span></span></pre></td></tr><tr><td scope="row"><pre>setOneProperty(const OSSymbol *key, OSObject *value)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (key == gIOTTYWaitForIdleKey) {<span></span></pre></td></tr><tr><td scope="row"><pre>        int error = waitForIdle();<span></span></pre></td></tr><tr><td scope="row"><pre>        if (ENXIO == error)<span></span></pre></td></tr><tr><td scope="row"><pre>            return kIOReturnOffline;<span></span></pre></td></tr><tr><td scope="row"><pre>        else if (error)<span></span></pre></td></tr><tr><td scope="row"><pre>            return kIOReturnAborted;<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnUnsupported;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn IOSerialBSDClient::<span></span></pre></td></tr><tr><td scope="row"><pre>setProperties(OSObject *properties)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn res = kIOReturnBadArgument;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (OSDynamicCast(OSString, properties)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        const OSSymbol *propSym =<span></span></pre></td></tr><tr><td scope="row"><pre>            OSSymbol::withString((OSString *) properties);<span></span></pre></td></tr><tr><td scope="row"><pre>        res = setOneProperty(propSym, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>        propSym->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else if (OSDynamicCast(OSDictionary, properties)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        const OSDictionary *dict = (const OSDictionary *) properties;<span></span></pre></td></tr><tr><td scope="row"><pre>        OSCollectionIterator *keysIter;<span></span></pre></td></tr><tr><td scope="row"><pre>        const OSSymbol *key;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        keysIter = OSCollectionIterator::withCollection(dict);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!keysIter) {<span></span></pre></td></tr><tr><td scope="row"><pre>            res = kIOReturnNoMemory;<span></span></pre></td></tr><tr><td scope="row"><pre>            goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        while ( (key = (const OSSymbol *) keysIter->getNextObject()) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            res = setOneProperty(key, dict->getObject(key));<span></span></pre></td></tr><tr><td scope="row"><pre>            if (res)<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        keysIter->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    return res;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000698-TPXREF107" title="Custom User Clients"></a><h4>Custom User Clients</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_582"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_583"></a>If you cannot make your hardware properly accessible to applications using I/O Kit’s off-the-shelf device interfaces, POSIX APIs, or I/O Registry properties, then you’ll probably have to write a custom user client. To reach this conclusion, you should first have answered “no” the following questions:</p><ul class="spaceabove"><li class="li"><p>If your device a member of an I/O Kit family, does that family provide a device interface?</p></li><li class="li"><p>Is your device a serial, networking, or storage device?</p></li><li class="li"><p>Are I/O Registry properties sufficient for the needs of the application? (If you need to move huge amounts of data, or if you don’t have control over the driver code, then they probably aren’t.)</p></li></ul><p>If you have determined that you need to write a custom user client for your hardware and its driver, read on for the information describing how to do this.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_584"></a></p><a name="//apple_ref/doc/uid/TP30000698-TPXREF108" title="Writing a Custom User Client"></a><h2>Writing a Custom User Client</h2><p>This section discusses the architecture of custom user clients, offers considerations for their design, and describes the API and procedures for implementing a custom user client. See the concluding section <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBJEBCB">“A Guided Tour Through a User Client”</a></span> for a guided tour through a fairly sophisticated user client.</p><a name="//apple_ref/doc/uid/TP30000698-BBCBGFHD" title="The Architecture of User Clients"></a><h3>The Architecture of User Clients</h3><p>A <a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_585"></a>user client provides a connection between a driver in the kernel and an application or other process in user space. It is a transport mechanism that tunnels through the kernel–user space boundary, enabling applications to control hardware and transfer data to and from hardware.</p><p>A user client actually consists of two parts, one part for each side of the boundary separating the kernel from user space (see <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em> for a detailed discussion of the kernel–user space boundary). These parts communicate with each other through interfaces conforming to an established protocol. For the purposes of this discussion, the kernel half of the connection is the user client proper; the part on the application side is called a device interface. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCHEGFF">Figure 4-1</a></span> illustrates this design</p><br/><div><a name="//apple_ref/doc/uid/TP30000698-BBCHEGFF" title="Figure 4-1Architecture of user clients"></a><p><strong>Figure 4-1&nbsp;&nbsp;</strong>Architecture of user clients</p><img src = "../Art/userclient_architecture.gif" alt = "Architecture of user clients" width="208" height="212"></div><br/><p>Although architecturally a user client (proper) and its device interface have a close, even binding relationship, they are quite different programmatically.</p><ul class="spaceabove"><li class="li"><p>A user client is a driver object (a category that includes nubs as well as drivers). A user client is thus a C++ object derived from IOService, the base class for I/O Kit driver objects, which itself ultimately derives from the libkern base class OSObject. </p><p>Because of its inheritance from IOService, a driver object such as a user client participates in the driver life cycle (initialization, starting, attaching, probing, and so on) and within a particular driver stack has client-provider relationships with other driver objects in the kernel. To a user client’s provider—the driver that is providing services to it, and the object with which the application is communicating—the user client looks just like another client within the kernel.</p></li><li class="li"><p>A device interface is a user-space library or other executable associated with an application or other user process. It is compiled from any code that can call the functions in the I/O Kit framework and is either linked directly into a Mach-O application or is indirectly loaded by the application via a dynamic shared library or a plug-in such as afforded by the Core Foundation types CFBundle<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_586"></a> and CFPlugIn<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_587"></a>. (See <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCHFHAJ">“Implementing the User Side of the Connection”</a></span> for further information.)</p></li></ul><p>Custom user-client classes typically inherit from the IOUserClient helper class. (They could also inherit from an I/O Kit family’s user-client class, which itself inherits from IOUserClient, but this is not a recommended approach; for an explanation why, see the introduction to the section <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BAJEHAAD">“Creating a User Client Subclass.”</a></span>) The device-interface side of the connection uses the C functions and types defined in the I/O Kit framework’s <code>IOKitLib.h</code>. </p><p>The actual transport layer enabling communication between user processes and device drivers is implemented using a private programming interface based on Mach RPC<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_588"></a>.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF109" title="Types of User-Client Transport"></a><h4>Types of User-Client Transport</h4><p>The<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_589"></a> I/O Kit’s APIs enable several different types of<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_590"></a> transport across the boundary between the kernel and user space:</p><ul class="spaceabove"><li class="li"><p><strong>Passing untyped data</strong>: This mechanism uses arrays of structures containing pointers to the methods to invoke in a driver object; the methods must conform to prototypes for primitive functions with parameters only indicating general type (scalar for a single, 32-bit value or structure for a group of values), number of scalar parameters, size of structures, and direction (input or output). The passing of untyped data using this mechanism can be synchronous or asynchronous. </p></li><li class="li"><p><strong>Sharing memory</strong>: This is a form of memory mapping in which one or more pages of memory are mapped into the address space of two tasks—in this case, the driver and the application process. Either process can then access or modify the data stored in those shared pages. The user-client mechanism for shared memory uses IOMemoryDescriptor<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_591"></a> objects on the kernel side and buffer pointers <code>vm_address_t</code> on the user side to map hardware registers to user space. This method of data transfer is intended for hardware that is not DMA-based and is ideal for moving large amounts of data between the hardware and the application. User processes can also map their memory into the kernel’s address space.</p></li><li class="li"><p><strong>Sending notifications<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_592"></a></strong>: This mechanism passes notification ports in and out of the kernel to send notifications between the kernel and user processes. These methods are used in asynchronous data-passing.</p></li></ul><p>An important point to keep in mind is that the implementation of a user client is not restricted to only one of the mechanisms listed above. It can use two or more of them; for example, it might used the synchronous untyped-data mechanism to program a DMA engine and shared memory for the actual data transfer.</p><a name="//apple_ref/doc/uid/TP30000698-CJBFGCFC" title="Synchronous Versus Asynchronous Data Transfer"></a><h4>Synchronous Versus Asynchronous Data Transfer</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_593"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_594"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_595"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_596"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_597"></a>Two styles of untyped-data passing are possible with the I/O Kit's user-client APIs: Synchronous and asynchronous. Each has its strengths and drawbacks, and each is more suitable to certain characteristics of hardware and user-space API. Although the asynchronous I/O model is somewhat comparable to the way Mac OS 9 applications access hardware, it is different in some respects. The most significant of these differences is an aspect of architecture shared with the synchronous model: In Mac OS X, the client provides the thread on which I/O completion routines are called, but the kernel controls the thread. I/O completion routines execute outside the context of the kernel.</p><p>The following discussion compares the synchronous (blocking) I/O and asynchronous (non-blocking, with completion) I/O models from an architectural perspective and without discussion of specific APIs. For an overview of those APIs, see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BAJEHAAD">“Creating a User Client Subclass.”</a></span></p><p>In synchronous I/O, the user process issues an I/O request on a thread that calls into the kernel and blocks until the I/O request has been processed (completed). The actual I/O work is completed on the work-loop thread of the driver. When the I/O completes, the user client wakes the user thread, gives it any results from the I/O operation, and returns control of the thread to the user process. After handling the result of the I/O, the thread delivers another I/O request to the user client, and the process starts again.</p><br/><div><a name="//apple_ref/doc/uid/TP30000698-TPXREF129" title="Figure 4-2Synchronous I/O between application and user client"></a><p><strong>Figure 4-2&nbsp;&nbsp;</strong>Synchronous I/O between application and user client</p><img src = "../Art/syncio.gif" alt = "Synchronous I/O between application and user client" width="369" height="171"></div><br/><p>The defining characteristic of the synchronous model is that the client makes a function call into the kernel that doesn't return until the I/O has completed. The major disadvantage of the synchronous approach is that the thread that issues the I/O request cannot do any more work until the I/O completes. However, it is possible to interrupt blocking synchronous routines by using signals, for example. In this case, the user client has to know that signals might be sent and how to handle them. It must be prepared to react appropriately in all possible situations, such as when an I/O operation is in progress when the signal is received. </p><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_598"></a>In asynchronous I/O, the user-process client has at least two threads involved in I/O transfers. One thread delivers an I/O request to the user client and returns immediately. The client also provides a thread to the user client for the delivery of notifications of I/O completions. The user client maintains a linked list of these notifications from prior I/O operations. If there are pending notifications, the user client invokes the notification thread's completion routine, passing in the results of an I/O operation. Otherwise, if there are no notifications in this list, the user client puts the notification thread to sleep.</p><br/><div><a name="//apple_ref/doc/uid/TP30000698-TPXREF130" title="Figure 4-3Asynchronous I/O between application and user client"></a><p><strong>Figure 4-3&nbsp;&nbsp;</strong>Asynchronous I/O between application and user client</p><img src = "../Art/asyncio.gif" alt = "Asynchronous I/O between application and user client" width="368" height="192"></div><br/><p>The user process should create and manage the extra threads in this model using some user-level facility such as BSD pthreads. This necessity points at the main drawback of the asynchronous model: The issue of thread management in a multithreaded environment. This is something that is difficult to do right. Another problem with asynchronous I/O is related to performance; with this type of I/O there are two kernel–user space round-trips per I/O. One way to mitigate this problem is to batch completion notifications and have the notification thread process several of them at once. For the asynchronous approach, you also might consider basing the client's I/O thread on a run-loop object (CFRunLoop); this object is an excellent multiplexor, allowing you to have different user-space event sources.</p><p>So which model for I/O is better, synchronous or asynchronous? As with many aspects of design, the answer is a definite “it depends.” It depends on any legacy application code you're working with, it depends on the sophistication of your thread programming, and it depends on the rate of I/O. The asynchronous approach is good when the number of I/O operations per second is limited (well under 1000 per second). Otherwise, consider the synchronous I/O model, which takes better advantage of the Mac OS X architecture.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_599"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_600"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_601"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_602"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_603"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_604"></a></p><a name="//apple_ref/doc/uid/TP30000698-TPXREF110" title="Factors in User Client Design"></a><h3>Factors in User Client Design</h3><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_605"></a>Before you start writing the code of your user client, take some time to think about its design. Think about what the user client is supposed to do, and what is the best programmatic interface for accomplishing this. Keeping some of the points raised in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BAJHDGJA">“Issues With Cross-Boundary I/O”</a></span> in mind, consider the following questions:</p><ul class="spaceabove"><li class="li"><p>What will be the effect of your design on performance, keeping in mind that each kernel–user space transition exacts a performance toll? </p><p>If your user client’s API is designed properly, you should need at most one boundary crossing for each I/O request. Ideally, you can batch multiple I/O requests in a single crossing.</p></li><li class="li"><p>Does your design put any code in the kernel that could work just as well in user space?</p><p>Remember that code in the kernel can be destabilizing and a drain on overall system resources.</p></li><li class="li"><p>Does the API of your device interface (the user-space side of the user client) expose hardware details to clients?</p><p>A main feature of the user-space API is to isolate applications from the underlying hardware and operating system.</p></li></ul><p>The following sections describe these and other issues in more detail.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF111" title="Range of Accessibility"></a><h4>Range of Accessibility</h4><p>The design<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_606"></a> of the user side of a user-client connection depends on the probable number and nature of the applications (and other user processes) that want to communicate with your driver. If you’re designing your user client for only one particular application, and that application is based on Mach-O object code, then you can incorporate the connection and I/O code into the application itself. See <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCDBJII">“The Basic Connection and I/O Procedure”</a></span> for the general procedure.</p><p>However, a driver writer often wants his driver accessible by more than one application. The driver could be intended for use by a family of applications made by a single software developer. Or any number of applications—even those you are currently unaware of—should be able to access the services of the driver. In these situations, you should put the code related to the user side of the user-client connection into a separate module, such as a shared library or plug-in. This module, known as a device interface, should abstract common connection and I/O functionality and present a friendly programmatic interface to application clients.</p><p>So<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_607"></a> let’s say you’ve decided to put your connection and I/O code into a device interface; you now must decide what form this device interface should take. The connection and I/O code must call functions defined in the I/O Kit framework, which contains a Mach-O dynamic shared library; consequently, all device interfaces should be built as executable code based on the Mach-O object-file format. The device interface can be packaged as a bundle<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_608"></a> containing a dynamic shared library or as a plug-in. In other words, the common API choice is between CFBundle<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_609"></a> (or Cocoa’s NSBundle) or CFPlugIn<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_610"></a>.</p><p>The decision between bundle and plug-in is conditioned by the nature of the applications that will be the clients of your user client. If there is a good chance that CFM-based applications will want to access your driver, you should use the CFBundle APIs because CFBundle provides cross-architecture capabilities. If you require a more powerful abstraction for device accessibility, and application clients are not likely to be CFM-based, you can use the CFPlugIn APIs. As an historical note, the families of the I/O Kit use CFPlugIns for their device interfaces because these types of plug-ins provide a greater range of accessibility by enabling third-party developers to create driver-like modules in user space.</p><p>If only one application is going to be the client of your custom user client, but that application is based on CFM-PEF object code, you should create a Mach-O bundle (using CFBundle or NSBundle APIs) as the device interface for the application. </p><p>In most cases, you can safely choose CFBundle (or NSBundle) for your device interface. In addition to their capability for cross-architecture calling, these bundle APIs make it easy to create a device interface.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF112" title="Design of Legacy Applications"></a><h4>Design of Legacy Applications</h4><p>A major<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_611"></a> factor in the design of your user client is the API of applications that currently access the hardware on other platforms, such as Mac OS 9 or Windows. Developers porting these applications to Mac OS X will (understandably) be concerned about how hard it will be to get their applications to work with a custom user client. They will probably want to move over as much of their application's hardware-related code as they can to Mac OS X, but this may not be easy to do.</p><p>For example, if the application API is based on interrupt-triggered asynchronous callbacks, such as on Mac OS 9, that API is not suitable for Mac OS X, where the primary-interrupt thread must remain in the kernel. Although the I/O Kit does have APIs for asynchronous I/O, these APIs are considerably different than those in Mac OS 9. Moreover, the preferred approach for Mac OS X is to use synchronous calls. So this might be a good opportunity for the application developer to revamp his hardware-API architecture. </p><p>If application developers decide to radically redesign their hardware API, the design of that API should influence the choices made for kernel–user space transport. For example, if the high-level API is asynchronous with callbacks, a logical choice would be to base the new application API on the I/O Kit's asynchronous untyped data–passing API. On the other hand, if the high-level API is already synchronous, than the I/O Kit's synchronous untyped data–passing API should clearly be used. The synchronous API is much easier and cleaner to implement, and if done properly does not suffer performance-wise in comparison with the asynchronous approach.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF113" title="Hardware"></a><h4>Hardware</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_612"></a>The design for your user client depends even more on the hardware your driver is controlling. Your user-client API needs to accommodate the underlying hardware. Two issues here are data throughput and interrupt frequency. If the data rates are quite large, such as with a video card, then try using mapped memory. If the hardware delivers just a few interrupts a second, you can consider handling those interrupts in user space using some asynchronous notification mechanism. But there are latency problems in such mechanisms, so if the hardware produces thousands of interrupts a second, you should handle them in the kernel code.</p><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_613"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_614"></a>Finally, there is the issue of hardware memory management. Perhaps the most important aspect of a device, in terms of user-client design, is its memory-management capabilities. These capabilities affect how applications can access hardware registers. The hardware can use either PIO<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_615"></a> (Programmed Input/Output<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_616"></a>) or DMA<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_617"></a> (Direct Memory Access<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_618"></a>). With PIO, the CPU itself moves data between a device and system (physical) memory; with DMA, a bus controller takes on this role, freeing up the microprocessor for other tasks. Almost all hardware now uses DMA, but some older devices still use PIO.</p><p>The simplest approach to application control of a device is to map device resources (such as hardware registers or frame buffers) into the address space of the application process. However, this approach poses a considerable security risk and should only be attempted with caution. Moreover, mapping registers into user space is not a feasible option with DMA hardware because the user process won’t have access to physical memory, which it needs. DMA hardware requires that the I/O work be performed inside the kernel where the virtual-memory APIs yield access to physical addresses. If your device uses DMA memory-management, it is incumbent upon you to find the most efficient way for your driver to do the I/O work.</p><p>Given these requirements, you can take one of four approaches in the design of your user client. The first two are options if your hardware memory management is accessed through PIO:</p><ul class="spaceabove"><li class="li"><p><strong>Full PIO memory management</strong>. Because you don’t require interrupts or physical-memory access, you can map the hardware registers into your application’s address space and control the device from there.</p></li><li class="li"><p><strong>PIO memory management with interrupts</strong>. If the PIO hardware uses interrupts, you must attempt a modified version of the previous approach. You can map the registers to user space, but the user process has to provide the thread to send interrupt notifications on. The drawback of this approach is that the memory management is not that good; it is suitable only for low data throughput.</p></li></ul><p>See <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCIJFDG">“Mapping Device Registers and RAM Into User Space”</a></span> for more information on these two memory-mapping approaches.</p><p>The next two design approaches are appropriate to hardware that uses DMA for memory management. With DMA, your code requires the physical addresses of the registers and must deal with the interrupts signalled by the hardware. If your hardware fits this description, you should use a design based on the untyped data–passing mechanism of the IOUserClient class and handle the I/O within your user client and driver. There are two types of such a design:</p><ul class="spaceabove"><li class="li"><p><strong>Function-based user client</strong>. This kind of user client defines complementary sets of functions on both sides of the kernel–user space boundary (for example, <code><!--a-->WriteBlockToDevice<!--/a--></code> or <code><!--a-->ScanImage<!--/a--></code>). Calling one function on the user side results in the invocation of the function on the kernel side. Unless the set of functions is small, you should not take this approach because it would put too much code in the kernel.</p></li><li class="li"><p><strong>Register-based task files</strong>. A task file is an array that batches a series of commands for getting and setting register values and addresses. The user client implements only four “primitive” functions that operate on the contents of the task file. Task files are fully explained in the following section, <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCIHCDC">“Task Files.”</a></span> </p></li></ul><p>User clients using register-based task files are the recommended design approach when you have DMA hardware. See <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCBAIBH">“Passing Untyped Data Synchronously”</a></span> for examples<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_619"></a>.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_620"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_621"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_622"></a></p><a name="//apple_ref/doc/uid/TP30000698-BBCIHCDC" title="Task Files"></a><h4>Task Files</h4><p>Task<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_623"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_624"></a> files give you an efficient way to send I/O requests from a user process to a driver object. A task file is an array containing a series of simple commands for the driver to perform on the hardware registers it controls. By batching multiple I/O requests in this fashion, task files mitigate the performance penalty for crossing the boundary between kernel and user space. You only need one crossing to issue multiple I/O requests.</p><p>On the kernel side, all you need are four “primitive” methods that perform the basic operations possible with hardware registers:</p><ul class="spaceabove"><li class="li"><p>Get value in register <em>x</em></p></li><li class="li"><p>Set register <em>x</em> to value <em>y</em></p></li><li class="li"><p>Get address in register <em>x</em></p></li><li class="li"><p>Set register <em>x</em> to address <em>y</em></p></li></ul><p>This small set of methods limits the amount of code in the kernel that is dedicated to I/O for the client and moves most of this code to the user-space side of the design. The device interface presents an interface to the application that is more functionally oriented. These functions are implemented, however, to “break down” functional requests into a series of register commands.</p><p>See <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCBAIBH">“Passing Untyped Data Synchronously”</a></span> for an example of task files.</p><a name="//apple_ref/doc/uid/TP30000698-BBCEBHCH" title="A Design Scenario"></a><h4>A Design Scenario</h4><p>The first step in determining the approach to take is to look at the overall architecture of the system and decide whether any existing solutions for kernel–user space I/O are appropriate. If you decide you need a custom user client, then analyze what is the design approach to take that is most appropriate to your user-space API and hardware.</p><p>As an example, say you have a PCI card with digital signal processing (DSP) capabilities. There is no I/O Kit family for devices of this type, so you know that there cannot be any family device interface that you can use. Now, let's say the card uses both DMA memory management and interrupts, so there must be code inside the kernel to handle these things; hence, a driver must be written to do this, and probably a user client. Because a large amount of DSP data must be moved to and from the card, I/O Registry properties are not an adequate solution. Thus a custom user client is necessary.</p><p>On another platform there is user-space code that hands off processing tasks to the DSP. This code works on both Mac OS 9 and Windows. Fortunately, the existing API is completely synchronous; there can be only one outstanding request per thread. This aspect of the API makes it a logical step to adapt the code to implement synchronous data passing in the user client and map the card memory into the application's address space for DMA transfers.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_625"></a></p><a name="//apple_ref/doc/uid/TP30000698-BBCHFHAJ" title="Implementing the User Side of the Connection"></a><h3>Implementing the User Side of the Connection</h3><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_626"></a>Of<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_627"></a> course, if you’re writing the code for the kernel side of the user-client connection, you’re probably going to write the complementary code on the user side. First, you should become familiar with the C functions in the I/O Kit framework, especially the ones in <code>IOKitLib.h</code>. These are the routines around which you’ll structure your code. But before setting hand to keyboard, take a few minutes to decide what your user-space code is going to look like, and how it’s going to be put together.</p><a name="//apple_ref/doc/uid/TP30000698-BBCDBJII" title="The Basic Connection and I/O Procedure"></a><h4>The Basic Connection and I/O Procedure</h4><p>You must complete certain tasks in the user-side code for a connection whether you are creating a library or incorporating the connection and I/O functionality in a single application client. This section summarizes those tasks, all of which involve calling functions defined in <code>IOKitLib.h</code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_84" title="Note"></a><p><strong>Note:</strong>&nbsp;This procedure is similar to the one described in <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em> for accessing a device interface.</p></div><a name="//apple_ref/doc/uid/TP30000698-BBCDBJEI" title="Defining Common Types"></a><h5>Defining Common Types</h5><p>The<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_628"></a> user client and the application or device interface must agree on the indexes into the array of method pointers. You typically define these indexes as <code>enum</code> constants. Code on the driver and the user side of a connection must also be aware of the data types that are involved in data transfers. For these reasons, you should create a header file containing definitions common to both the user and kernel side, and have both application and user-client code include this file.</p><p>As illustration, <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBGCCBF">Listing 4-2</a></span> shows the contents of the SimpleUserClient project’s common header file:</p><a name="//apple_ref/doc/uid/TP30000698-CJBGCCBF" title="Listing 4-2Common type definitions for SimpleUserClient"></a><p class="codesample"><strong>Listing 4-2&nbsp;&nbsp;</strong>Common type definitions for SimpleUserClient</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct MySampleStruct<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 int16;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 int32;<span></span></pre></td></tr><tr><td scope="row"><pre>} MySampleStruct;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>enum<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyUserClientOpen,<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyUserClientClose,<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyScalarIStructImethod,<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyScalarIStructOmethod,<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyScalarIScalarOmethod,<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyStructIStructOmethod,<span></span></pre></td></tr><tr><td scope="row"><pre>    kNumberOfMethods<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000698-BBCBAEII" title="Get the I/O Kit Master Port"></a><h5>Get the I/O Kit Master Port</h5><p>Start<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_629"></a> by calling the <code><!--a-->IOMasterPort<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_630"></a> function to get the “master” Mach port to use for communicating with the I/O Kit. In the current version of Mac OS X, you must request the default master port by passing the constant <code><!--a  -->MACH_PORT_NULL<!--/a--></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>kernResult = IOMasterPort(MACH_PORT_NULL, &amp;masterPort);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000698-CJBCHGGA" title="Obtain an Instance of the Driver"></a><h5>Obtain an Instance of the Driver</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_631"></a>Next, find an instance of the driver’s class in the I/O Registry. Start by calling the <code><!--a-->IOServiceMatching<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_632"></a> function to create a matching dictionary for matching against all devices that are instances of the specified class. All you need to do is supply the class name of the driver. The matching information used in the matching dictionary may vary depending on the class of service being looked up.</p><div class="codesample"><table><tr><td scope="row"><pre>classToMatch = IOServiceMatching(kMyDriversIOKitClassName);<span></span></pre></td></tr></table></div><p>Next call <code><!--a-->IOServiceGetMatchingServices<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_633"></a>, passing in the matching dictionary obtained in the previous step. This function returns an iterator object which you use in a call to <code><!--a-->IOIteratorNext<!--/a--></code> to get each succeeding instance in the list. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCGHGEJ">Listing 4-3</a></span> illustrates how you might do this.</p><a name="//apple_ref/doc/uid/TP30000698-BBCGHGEJ" title="Listing 4-3Iterating through the list of current driver instances"></a><p class="codesample"><strong>Listing 4-3&nbsp;&nbsp;</strong>Iterating through the list of current driver instances</p><div class="codesample"><table><tr><td scope="row"><pre>    kernResult = IOServiceGetMatchingServices(masterPort, classToMatch, &amp;iterator);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (kernResult != KERN_SUCCESS)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("IOServiceGetMatchingServices returned %d\n\n", kernResult);<span></span></pre></td></tr><tr><td scope="row"><pre>        return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    serviceObject = IOIteratorNext(iterator);<span></span></pre></td></tr><tr><td scope="row"><pre>    IOObjectRelease(iterator);<span></span></pre></td></tr></table></div><p>In this example, the library code grabs the first driver instance in the list. With the expandable buses in most computers nowadays, you might have to present users with the list of devices and have them choose. Be sure to release the iterator when you are done with it.</p><p>Note that instead of calling <code><!--a-->IOServiceMatching<!--/a--></code>, you can call <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code> and have it send notifications<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_634"></a> of new instances of the driver class as they load.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_635"></a></p><a name="//apple_ref/doc/uid/TP30000698-CJBCDCFB" title="Create a Connection"></a><h5>Create a Connection</h5><p>The<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_636"></a> final step is creating a connection to this driver instance or, more specifically, to the user-client object on the other side of the connection. A connection, which is represented by an object of type <code>io_connect_t</code>, is a necessary parameter for all further communication with the user client.</p><p>To create the connection, call <code><!--a-->IOServiceOpen<!--/a--></code>, passing in the driver instance obtained in the previous step along with the current Mach task. This call invokes <code>newUserClient</code> in the driver instance, which results in the instantiation, initialization, and attachment of the user client. If a driver specifies the <code>IOUserClientClass</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_637"></a> property in its information property list, the default <code>newUserClient</code> implementation does these things for the driver. In almost all cases, you should specify the <code>IOUserClientClass</code> property and rely on the default implementation. </p><p><span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCEFDBE">Listing 4-4</a></span> shows how the SimpleUserClient project gets a Mach port, obtains an instance of the driver, and creates a connection to the user client.</p><a name="//apple_ref/doc/uid/TP30000698-BBCEFDBE" title="Listing 4-4Opening a driver connection via a user client"></a><p class="codesample"><strong>Listing 4-4&nbsp;&nbsp;</strong>Opening a driver connection via a user client</p><div class="codesample"><table><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_port_t     masterPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_service_t    serviceObject;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_connect_t    dataPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_iterator_t   iterator;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionaryRef classToMatch;<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = IOMasterPort(MACH_PORT_NULL, &amp;masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (kernResult != KERN_SUCCESS)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf( "IOMasterPort returned %d\n", kernResult);<span></span></pre></td></tr><tr><td scope="row"><pre>        return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    classToMatch = IOServiceMatching(kMyDriversIOKitClassName);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (classToMatch == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf( "IOServiceMatching returned a NULL dictionary.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = IOServiceGetMatchingServices(masterPort, classToMatch,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            &amp;iterator);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (kernResult != KERN_SUCCESS)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("IOServiceGetMatchingServices returned %d\n\n", kernResult);<span></span></pre></td></tr><tr><td scope="row"><pre>        return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    serviceObject = IOIteratorNext(iterator);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOObjectRelease(iterator);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (serviceObject != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        kernResult = IOServiceOpen(serviceObject, mach_task_self(), 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    &amp;dataPort);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        IOObjectRelease(serviceObject);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (kernResult != KERN_SUCCESS)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("IOServiceOpen returned %d\n", kernResult);<span></span></pre></td></tr><tr><td scope="row"><pre>            return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000698-BBCGHHDH" title="Open the User Client"></a><h5>Open the User Client</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_638"></a>After you have created a connection to the user client, you should open it. The application or device interface should always give the commands to open and close the user client. This semantic is necessary to ensure that only one user-space client has access to a device of a type that permits only exclusive access.</p><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_639"></a>The basic procedure for requesting the user client to open is similar to an I/O request: The application or device interface calls an <code><!--a-->IOConnectMethod<!--/a--></code> function, passing in an index to the user client’s <code>IOExternalMethod</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_640"></a> array. The SimpleUserClient project defines <code>enum</code> constants for both the open and the complementary close commands that are used as indexes in the user client's <code>IOExternalMethod</code> array.</p><div class="codesample"><table><tr><td scope="row"><pre>enum{    kMyUserClientOpen,    kMyUserClientClose,    // ...};<span></span></pre></td></tr></table></div><p>Then the application (or device-interface library) calls one of the <code><!--a-->IOConnectMethod<!--/a--></code> functions; any of these functions can be used because no input data is passed in and no output data is expected. The SimpleUserClient project uses the <code><!--a-->IOConnectMethodScalarIScalarO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_641"></a> function (see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCCIDJJ">Listing 4-5</a></span>, which assumes the prior programmatic context shown in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCEFDBE">Listing 4-4</a></span>).</p><a name="//apple_ref/doc/uid/TP30000698-BBCCIDJJ" title="Listing 4-5Requesting the user client to open "></a><p class="codesample"><strong>Listing 4-5&nbsp;&nbsp;</strong>Requesting the user client to open </p><div class="codesample"><table><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = IOConnectMethodScalarIScalarO(dataPort, kMyUserClientOpen,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kernResult != KERN_SUCCESS)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            IOServiceClose(dataPort);<span></span></pre></td></tr><tr><td scope="row"><pre>            return kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr></table></div><p>As this example shows, if the result of the call is not <code>KERN_SUCCESS</code>, then the application knows that the device is being used by another application. The application (or device interface) then closes the connection to the user client and returns the call result to its caller. Note that calling <code><!--a-->IOServiceClose<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_642"></a> results in the invocation of <code>clientClose</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_643"></a> in the user-client object in the kernel.</p><p>For a full description of the open-close semantic for enforcing exclusive device access, see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCHHGFH">“Exclusive Device Access and the open Method.”</a></span><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_644"></a></p><a name="//apple_ref/doc/uid/TP30000698-BBCCEAFJ" title="Send and Receive Data"></a><h5>Send and Receive Data</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_645"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_646"></a>Once you have opened the user client, the user process can begin sending data to it and receiving data from it. The user process initiates all I/O activity, and the user client (and its provider, the driver) are “slaves” to it, responding to requests. For passing untyped data, the user process must use the <code><!--a-->IOConnectMethod<!--/a--></code> functions defined in <code>IOKitLib.h</code>. The names of these functions indicate the general types of the parameters (scalar and structure) and the direction of the transfer (input and output). <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCJCJJC">Table 4-2</a></span> lists these functions.</p><a name="//apple_ref/doc/uid/TP30000698-BBCJCJJC" title="Table 4-2IOConnectMethod functions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4-2&nbsp;&nbsp;</strong>IOConnectMethod functions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code><!--a-->IOConnectMethodScalarIScalarO<!--/a--></code></p></td><td ><p>One or more scalar input parameters, one or more scalar output parameters</p></td></tr><tr><td  scope="row"><p><code><!--a-->IOConnectMethodScalarIStructureO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_647"></a></p></td><td ><p>One or more scalar input parameters, one structure output parameter</p></td></tr><tr><td  scope="row"><p><code><!--a-->IOConnectMethodScalarIStructureI<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_648"></a></p></td><td ><p>One or more scalar input parameters, one structure input parameter</p></td></tr><tr><td  scope="row"><p><code><!--a-->IOConnectMethodStructureIStructureO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_649"></a></p></td><td ><p>One structure input parameter, one structure output parameter</p></td></tr></table></div><p>The parameters of these functions include the connection to the user client and the index into the array of method pointers maintained by the user client. Additionally, they specify the number of scalar values (if any) and the size of any structures as well as the values themselves, the pointers to the structures, and pointers to buffers for any returned values,. </p><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_650"></a>For instance, the <code><!--a-->IOConnectMethodScalarIStructureO<!--/a--></code> function is defined as:</p><div class="codesample"><table><tr><td scope="row"><pre>kern_return_t<span></span></pre></td></tr><tr><td scope="row"><pre>IOConnectMethodScalarIStructureO(<span></span></pre></td></tr><tr><td scope="row"><pre>    io_connect_t    connect,<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned int    index,<span></span></pre></td></tr><tr><td scope="row"><pre>    IOItemCount     scalarInputCount,<span></span></pre></td></tr><tr><td scope="row"><pre>    IOByteCount *   structureSize,<span></span></pre></td></tr><tr><td scope="row"><pre>    ... );<span></span></pre></td></tr></table></div><p>The parameters of this function are similar to those of the other <code>IOConnectMethod</code> functions.</p><ul class="spaceabove"><li class="li"><p>The <em>connect</em> parameter is the connection object obtained through the <code><!--a-->IOServiceOpen<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_651"></a> call (<code>dataPort</code> in the code snippet in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCEFDBE">Listing 4-4</a></span>).</p></li><li class="li"><p>The <em>index</em> parameter is the index into the user client’s <code>IOExternalMethod</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_652"></a> array.</p></li><li class="li"><p>The <em>scalarInputCount</em> parameter is the number of scalar input values.</p></li><li class="li"><p>The <em>structureSize</em> parameter is the size of the returned structure.</p></li></ul><p>Because these functions are defined as taking variable argument lists, following <em>structureSize</em> are, first, the scalar values and then a pointer to a buffer the size of <em>structureSize</em>. The application in the SimpleUserClient project uses the <code><!--a-->IOConnectMethodScalarIStructureO<!--/a--></code> function as shown in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCJDDID">Listing 4-6</a></span>.</p><a name="//apple_ref/doc/uid/TP30000698-BBCJDDID" title="Listing 4-6Requesting I/O with the IOConnectMethodScalarIStructureO function"></a><p class="codesample"><strong>Listing 4-6&nbsp;&nbsp;</strong>Requesting I/O with the <code>IOConnectMethodScalarIStructureO</code> function</p><div class="codesample"><table><tr><td scope="row"><pre>kern_return_t<span></span></pre></td></tr><tr><td scope="row"><pre>MyScalarIStructureOExample(io_connect_t dataPort)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    MySampleStruct  sampleStruct;<span></span></pre></td></tr><tr><td scope="row"><pre>    int             sampleNumber1 = 154;    // This number is random.<span></span></pre></td></tr><tr><td scope="row"><pre>    int             sampleNumber2 = 863;    // This number is random.<span></span></pre></td></tr><tr><td scope="row"><pre>    IOByteCount     structSize = sizeof(MySampleStruct);<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = IOConnectMethodScalarIStructureO(dataPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kMyScalarIStructOmethod, // method index<span></span></pre></td></tr><tr><td scope="row"><pre>                        2,  // number of scalar input values<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;structSize, // size of ouput struct<span></span></pre></td></tr><tr><td scope="row"><pre>                        sampleNumber1,  // scalar input value<span></span></pre></td></tr><tr><td scope="row"><pre>                        sampleNumber2,  // another scalar input value<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;sampleStruct   // pointer to output struct<span></span></pre></td></tr><tr><td scope="row"><pre>                        );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (kernResult == KERN_SUCCESS)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("kMyScalarIStructOmethod was successful.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("int16 = %d, int32 = %d\n\n", sampleStruct.int16,<span></span></pre></td></tr><tr><td scope="row"><pre>                (int)sampleStruct.int32);<span></span></pre></td></tr><tr><td scope="row"><pre>        fflush(stdout);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000698-TPXREF114" title="Close the Connection"></a><h5>Close the Connection</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_653"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_654"></a>When<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_655"></a> you have finished your I/O activity, first issue a close command to the user client to have it close its provider. The command takes a form similar to that used to issue the open command. Call an <code><!--a-->IOConnectMethod<!--/a--></code> function, passing in a constant to be used as an index into the user client’s <code>IOExternalMethod</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_656"></a> array. In the SimpleUserClient project, this call is the following:</p><div class="codesample"><table><tr><td scope="row"><pre>kernResult = IOConnectMethodScalarIScalarO(dataPort, kMyUserClientClose, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            0);<span></span></pre></td></tr></table></div><p>Finally, close the connection and free up any resources. To do so, simply call <code><!--a-->IOServiceClose<!--/a--></code> on your <code>io_connect_t</code> connection.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_657"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_658"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_659"></a></p><a name="//apple_ref/doc/uid/TP30000698-TPXREF115" title="Aspects of Design for Device Interfaces"></a><h4>Aspects of Design for Device Interfaces</h4><p>When<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_660"></a> you design your device interface<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_661"></a>, try to move as much code and logic into it as possible. Only put code in the kernel that absolutely has to be there. The user-interface code in the kernel should be tightly associated with the hardware, especially when the design is based on the task-file approach.</p><p>One reason for this has been stressed before: Code in the kernel can be a drain on performance and a source of instability. But another reason should be just as important to developers. User-space code is <em>much</em> easier to debug than kernel code.</p><a name="//apple_ref/doc/uid/TP30000698-BAJEHAAD" title="Creating a User Client Subclass"></a><h3>Creating a User Client Subclass</h3><p>When<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_662"></a> you create a user client for your driver, you must create a subclass of IOUserClient. In addition to completing certain tasks that all subclasses of IOUserClient must do, you must write code that is specific to <em>how</em> the user client transfers data:</p><ul class="spaceabove"><li class="li"><p>Using the untyped-data mechanism synchronously (blocking)</p></li><li class="li"><p>Using the untyped-data mechanism asynchronously (non-blocking, with invocation of completion routine)</p></li><li class="li"><p>Using the memory-mapping APIs (for PIO hardware)</p></li></ul><p>This section describes all three approaches, but only the first one is covered in detail because it is the most common case. It also discusses the synchronous untyped-data mechanism in the context of register task files because that is the recommended approach for user clients of this sort.</p><p>This section does not cover aspects of subclassing family user-client classes. Such classes tend to be complex and tightly integrated into other classes of the family. Of course, you could look at the open-source implementation code to understand how the are constructed and integrated, but still subclassing a family user client is not a recommended approach.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_85" title="Note"></a><p><strong>Note:</strong>&nbsp;Some of the sample code in this section is taken from the SimpleUserClient example project, which you can download from <span class="content_text"><a href="../../../../../samplecode/Darwin/index.html#//apple_ref/doc/uid/TP30000925-TP30000422" target="_top">Darwin Sample Code</a></span>.</p></div><a name="//apple_ref/doc/uid/TP30000698-TPXREF116" title="User-Client Project Basics"></a><h4>User-Client Project Basics</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_663"></a>A user client is, first and foremost, a driver object. It is at the “top” of a driver stack between its provider (the driver) and its client (the user process). As a driver object, it must participate in the driver life-cycle by implementing the appropriate methods: <code>start</code>, <code>open</code>, and so on (see <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em> for a description of the driver life cycle). It must communicate with its provider at the appropriate moments. And it must also maintain a connection with its client (the user process) along with any state related to that connection; additionally, it’s the user client’s responsibility to clean up when the client goes away.</p><p>Given the close relationship between a driver and its user client, it’s recommended that you include the source files for your user client in the project for your driver. If you want the I/O Kit, in response to <code><!--a-->IOServiceOpen<!--/a--></code> being called in user space, to automatically allocate, start, and attach an instance of your user-client subclass, specify the <code>IOUserClientClass</code> property in the information property list of your driver. The value of the property should be the full class name of your user client. Alternatively, your driver class can implement the IOService method <code>newUserClient</code> to create, attach, and start an instance of the your IOUserClient subclass.</p><p>In the user client’s header file, declare the life-cycle methods that you are overriding; these can include <code>start</code>, <code>message</code>, <code>terminate</code>, and <code>finalize</code>. These messages are propagated up the driver stack, from the driver object closest to the hardware to the user client. Also declare <code>open</code> and <code>close</code> methods; messages invoking these methods are propagated in the opposite direction, and are originated by the application or device interface itself. The <code>open</code> method, in which the user client opens its provider, is particularly important as the place where exclusive device access is enforced. For more on the user client’s <code>open</code> and <code>close</code> methods, see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCHHGFH">“Exclusive Device Access and the open Method”</a></span>; for the application’s role in this, see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCGHHDH">“Open the User Client.”</a></span></p><p>There is one particular thing to note about the <code>start</code> method. In your implementation of this method, verify that the passed-in provider object is an instance of your driver’s class (using <code><!--a-->OSDynamicCast<!--/a--></code>) and assign it to an instance variable. Your user client needs to send several messages to its provider during the time it’s loaded, so it’s helpful to keep a reference to the provider handy.</p><p>You’ll also have to declare and implement some methods specific to initialization of the user client and termination of the client process. The following sections discuss these methods.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF117" title="Initialization"></a><h5>Initialization</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_664"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_665"></a>The IOUserClient class defines the <code>initWithTask</code> method for the initialization of user-client instances. The default implementation simply calls the IOService <code>init</code> method, ignoring the parameters. The <code>initWithTask</code> method has four parameters:</p><ul class="spaceabove"><li class="li"><p>The Mach task of the client that opened the connection (type <code>task_t</code>)</p></li><li class="li"><p>A security token to be passed to the <code>clientHasPrivilege</code> method when you are trying to determine whether the client is allowed to do secure operations (for which they need an effective UID of zero)</p></li><li class="li"><p>A type to be passed to the <code>clientHasPrivilege</code> method when you are trying to determine whether the client is allowed to do secure operations (for which they need an effective UID of zero).</p></li><li class="li"><p>Optionally, an OSDictionary containing properties specifying how the user client is to be created (currently unused)</p></li></ul><p>The most significant of these parameters is the first, the user task. You probably should retain this reference as an instance variable so that you can easily handle connection-related activities related to the user process. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCFICIG">Listing 4-7</a></span> shows a simple implementation of <code>initWithTask</code>:</p><a name="//apple_ref/doc/uid/TP30000698-BBCFICIG" title="Listing 4-7An implementation of initWithTask"></a><p class="codesample"><strong>Listing 4-7&nbsp;&nbsp;</strong>An implementation of <code>initWithTask</code></p><div class="codesample"><table><tr><td scope="row"><pre>bool<span></span></pre></td></tr><tr><td scope="row"><pre>com_apple_dts_SimpleUserClient::initWithTask(task_t owningTask,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    void *security_id , UInt32 type)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("SimpleUserClient::initWithTask()\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!super::initWithTask(owningTask, security_id , type))<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!owningTask)<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fTask = owningTask;<span></span></pre></td></tr><tr><td scope="row"><pre>    fProvider = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    fDead = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return true;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000698-BBCHHGFH" title="Exclusive Device Access and the open Method"></a><h5>Exclusive Device Access and the open Method</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_666"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_667"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_668"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_669"></a>The user client must allow for device sharing or device exclusiveness, as required by the hardware. Many kinds of devices are designed to allow only one application at a time to access the device. For example, a device such as a scanner requires exclusive access. On the other hand, a device like a DSP PCI card (described in the scenario presented in<span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCEBHCH">“A Design Scenario”</a></span>) permits the sharing of its services among multiple application clients. </p><p>The ideal place for the user client to check and enforce exclusive access for devices is in the <code>open</code> method. At this point in the driver life cycle, the user client can ask its provider to open; if the provider’s <code>open</code> method fails, that means another application is accessing the services of the provider. The user client refuses access to the requesting application by returning the appropriate result code, <code><!--a  -->kIOReturnExclusiveAccess<!--/a--></code>.</p><p>As with all commands, the application issues the initial command to open. It treats the open command just as it does any command issued by calling an <code><!--a-->IOConnectMethod<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_670"></a> function. The SimpleUserClient project defines <code>enum</code> constants for both the open and the complementary close commands that are used as indexes in the user client's <code>IOExternalMethod</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_671"></a> array. Then the application (or device interface) calls one of the <code><!--a-->IOConnectMethod<!--/a--></code> functions to issue the open command. If the result of the call is not <code>KERN_SUCCESS</code>, then the application or device interface knows that the device is being used by another user process. See <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCGHHDH">“Open the User Client”</a></span> for more details.</p><p>For its part, the user-client subclass defines entries in the <code>IOExternalMethod</code> array for the open and close commands (<span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCDDFEI">Listing 4-8</a></span>).</p><a name="//apple_ref/doc/uid/TP30000698-BBCDDFEI" title="Listing 4-8IOExternalMethod entries for the open and close commands"></a><p class="codesample"><strong>Listing 4-8&nbsp;&nbsp;</strong><code>IOExternalMethod</code> entries for the open and close commands</p><div class="codesample"><table><tr><td scope="row"><pre> static const IOExternalMethod sMethods[kNumberOfMethods] =<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        {   // kMyUserClientOpen<span></span></pre></td></tr><tr><td scope="row"><pre>            NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>            (IOMethod) &amp;com_apple_dts_SimpleUserClient::open,<span></span></pre></td></tr><tr><td scope="row"><pre>            kIOUCScalarIScalarO,<span></span></pre></td></tr><tr><td scope="row"><pre>            0,<span></span></pre></td></tr><tr><td scope="row"><pre>            0<span></span></pre></td></tr><tr><td scope="row"><pre>        },<span></span></pre></td></tr><tr><td scope="row"><pre>        {   // kMyUserClientClose<span></span></pre></td></tr><tr><td scope="row"><pre>            NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>            (IOMethod) &amp;com_apple_dts_SimpleUserClient::close,<span></span></pre></td></tr><tr><td scope="row"><pre>            kIOUCScalarIScalarO,<span></span></pre></td></tr><tr><td scope="row"><pre>            0,<span></span></pre></td></tr><tr><td scope="row"><pre>            0<span></span></pre></td></tr><tr><td scope="row"><pre>        },<span></span></pre></td></tr><tr><td scope="row"><pre>      // ...<span></span></pre></td></tr><tr><td scope="row"><pre>   );<span></span></pre></td></tr></table></div><p>In its implementation of the <code>getTargetAndMethodForIndex</code> method, when the user client receives an index of <code><!--a  -->kMyUserClientOpen<!--/a--></code>, it returns both a pointer to the <code>open</code> method and the target object on which to invoke this method (the user client itself). The implementation of the <code>open</code> method in SimpleUserClient looks like the code in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCGCDAA">Listing 4-9</a></span>.</p><a name="//apple_ref/doc/uid/TP30000698-BBCGCDAA" title="Listing 4-9Implementation of a user-client open method"></a><p class="codesample"><strong>Listing 4-9&nbsp;&nbsp;</strong>Implementation of a user-client <code>open</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn<span></span></pre></td></tr><tr><td scope="row"><pre>com_apple_dts_SimpleUserClient::open(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (isInactive())<span></span></pre></td></tr><tr><td scope="row"><pre>        return kIOReturnNotAttached;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!fProvider->open(this))<span></span></pre></td></tr><tr><td scope="row"><pre>        return kIOReturnExclusiveAccess;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This implementation first checks for a provider by invoking the IOService method <code>isInactive</code>. The <code>isInactive</code> method returns <code>true</code> if the provider has been terminated and is thus prevented from attaching; in this case, the user client should return <code><!--a  -->kIOReturnNotAttached<!--/a--></code>. Otherwise, if the user client has its provider attached, it can call <code>open</code> on it. If the <code>open</code> call fails, then the user client returns <code><!--a  -->kIOReturnExclusiveAccess<!--/a--></code>; otherwise it returns <code><!--a  -->kIOReturnSuccess<!--/a--></code>.</p><p>The <code>close</code> method in SimpleUserClient is similar to the <code>open</code> method, except that the implementation checks if the provider is open before calling <code>close</code> on it <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBEJEFJ">Listing 4-10</a></span>). </p><a name="//apple_ref/doc/uid/TP30000698-CJBEJEFJ" title="Listing 4-10Implementation of a user-client close method"></a><p class="codesample"><strong>Listing 4-10&nbsp;&nbsp;</strong>Implementation of a user-client <code>close</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn<span></span></pre></td></tr><tr><td scope="row"><pre>com_apple_dts_SimpleUserClient::close(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("SimpleUserClient::close()\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!fProvider)<span></span></pre></td></tr><tr><td scope="row"><pre>        return kIOReturnNotAttached;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (fProvider->isOpen(this))<span></span></pre></td></tr><tr><td scope="row"><pre>        fProvider->close(this);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The user client’s <code>close</code> method can be invoked for a number of reasons in addition to the user-space code issuing a close command. The user process could gracefully end the connection to the user client by calling the <code><!--a-->IOServiceClose<!--/a--></code> function or the user process could die, in which case the <code>clientDied</code> method is invoked in the user client (see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBHHJHA">“Cleaning Up”</a></span>). If an unexpected event happens in a driver stack (for example, a device is removed), the user client receives a <code>didTerminate</code> message, to which it should respond by calling its <code>close</code> method. In its implementation of the <code>close</code> method, the user client should, after taking proper precautions, close its provider to unload it properly. </p><p>One consequence of this open-close design is that it’s up to the user client’s provider (in its <code>open</code> method) to determine when or whether another client is acceptable. For example, imagine that a DSP PCI card has a hardware limitation in that it can support only 256 clients. You could work around this limitation by multiplexing hardware access among the clients, but that would be a lot of work for an unlikely case. Instead you might choose to have the card’s driver (the user client’s provider) count the number of clients—incrementing the count in its <code>open</code> method and decrementing it in its <code>close</code> method—and return an error from <code>open</code> if the client limit has been exceeded.</p><p>The examples given above are greatly simplified and the exact implementation of <code>open</code> will depend on the nature of the application as well as the hardware. But the general open-close procedure as described here is highly recommended as it provides an enforced exclusive-access semantic that is usually appropriate for devices.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_672"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_673"></a></p><a name="//apple_ref/doc/uid/TP30000698-CJBHHJHA" title="Cleaning Up"></a><h5>Cleaning Up</h5><p>A user client cannot trust the user process that is its client. A user process can create and destroy a user client at any time. Moreover, there is no guarantee that the process will correctly close and release its user clients before quitting. The system tracks the user clients opened by each process and automatically closes and releases them if the process terminates, either gracefully or by crashing.</p><p>For these exigencies, the IOUserClient class has defined two methods, <code>clientClose</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_674"></a> and <code>clientDied</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_675"></a>. The <code>clientClose</code> method is called if the client process calls the <code><!--a-->IOServiceClose<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_676"></a> function. The <code>clientDied</code> method is called if the client process dies without calling <code><!--a-->IOServiceClose<!--/a--></code>. The typical response of a user client in either case is to call <code>close</code> on its provider. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCIABJI">Listing 4-11</a></span> shows how the SimpleUserClient class does it.</p><a name="//apple_ref/doc/uid/TP30000698-BBCIABJI" title="Listing 4-11Implementations of clientClose and clientDied"></a><p class="codesample"><strong>Listing 4-11&nbsp;&nbsp;</strong>Implementations of <code>clientClose</code> and <code>clientDied</code></p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn<span></span></pre></td></tr><tr><td scope="row"><pre>com_apple_dts_SimpleUserClient::clientClose(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // release my hold on my parent (if I have one).<span></span></pre></td></tr><tr><td scope="row"><pre>    close();<span></span></pre></td></tr><tr><td scope="row"><pre>    terminate();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (fTask)<span></span></pre></td></tr><tr><td scope="row"><pre>    fTask = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fProvider = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // DON'T call super::clientClose, which just returns notSupported<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn<span></span></pre></td></tr><tr><td scope="row"><pre>com_apple_dts_SimpleUserClient::clientDied(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn ret = kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("SimpleUserClient::clientDied()\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // do any special clean up here<span></span></pre></td></tr><tr><td scope="row"><pre>    ret = super::clientDied();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return ret;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000698-BBCBAIBH" title="Passing Untyped Data Synchronously"></a><h4>Passing Untyped Data Synchronously</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_677"></a>The primary IOUserClient mechanism for passing data between a driver and an application is, at its core, an array of pointers to member functions implemented in the driver or, in some cases, the user client. The user client and the user process agree upon a set of constants that act as indexes into the array. When the user process makes a call to read or write some data, it passes this index along with some input and output parameters. Using the index, the user client finds the desired method and invokes it, passing along the required parameters.</p><p>That’s the basic mechanism in a nutshell, but the description leaves out important details. These start with the fact that the data passed into or out of the kernel is essentially untyped. The kernel cannot know or predict data types in user space and so can only accept the most generalized types of data. The ensuing discussion describes how the I/O Kit’s user-client API (on both sides of the kernel boundary) accommodates this restriction and how your subclass of IOUserClient must implement its part of the untyped data–passing mechanism. As you read along, refer to <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCDHHCG">Figure 4-4</a></span>, which graphically shows the relationships among the pieces of the untyped data–passing API.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF118" title="Scalar and Structure"></a><h5>Scalar and Structure</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_678"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_679"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_680"></a>The user-client mechanism uses only two generalized types for parameters: scalar and structure. These are further qualified by the direction of data: input or output.</p><p>Methods invoked in a driver object through the untyped-data mechanism must conform to the <code>IOMethod</code> type, which is deliberately elastic in terms of allowable parameters:</p><div class="codesample"><table><tr><td scope="row"><pre>typedef IOReturn (IOService::*IOMethod)(void * p1, void * p2, void * p3,<span></span></pre></td></tr><tr><td scope="row"><pre>                                void * p4, void * p5, void * p6 );<span></span></pre></td></tr></table></div><p>However, the parameters of an <code>IOMethod</code> method must conform to one of four generalized prototypes identified by constants defined in <code>IOUserClient.h</code> :</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><td  scope="row"><p><code><!--a  -->kIOUCScalarIScalarO<!--/a--></code></p></td><td ><p>Scalar input, scalar output</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOUCScalarIStructO<!--/a--></code></p></td><td ><p>Scalar input, structure output</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOUCStructIStructO<!--/a--></code></p></td><td ><p>Structure input, structure output</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOUCScalarIStructI<!--/a--></code></p></td><td ><p>Scalar input, structure input</p></td></tr></table></div><p>On<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_681"></a> the user-process side of a connection, <code>IOKitLib.h</code> defines four functions corresponding to these constants:</p><ul class="simple"><li><p><code><!--a-->IOConnectMethodScalarIScalarO<!--/a--></code></p></li><li><p><code><!--a-->IOConnectMethodScalarIStructureO<!--/a--></code></p></li><li><p><code><!--a-->IOConnectMethodStructureIStructureO<!--/a--></code></p></li><li><p><code><!--a-->IOConnectMethodScalarIStructureI<!--/a--></code></p></li></ul><p>For further information, see section <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCCEAFJ">“Send and Receive Data”</a></span> which discusses how code in user space uses these functions.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_682"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_683"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_684"></a></p><a name="//apple_ref/doc/uid/TP30000698-TPXREF119" title="Including the Header File of Common Types"></a><h5>Including the Header File of Common Types</h5><p>Make<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_685"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_686"></a> sure your user-client subclass includes the header file that you have created to define data types common to both kernel and user-space code. The types would include the <code>enum</code> constants to use as indexes into the <code>IOExternalMethod</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_687"></a> array and any structures involved in I/O.</p><p>For more on these common type definitions, see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCDBJEI">“Defining Common Types.”</a></span></p><a name="//apple_ref/doc/uid/TP30000698-TPXREF120" title="Constructing the  IOExternalMethod Array"></a><h5>Constructing the  IOExternalMethod Array</h5><p>T<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_688"></a>he distinctive action that a subclass of IOUserClient must perform when implementing its part of the untyped-data mechanism is identifying the driver method that the user process wants invoked at a particular moment. An important part of this task is the construction of the array of pointers to the methods to invoke. However, the contents of this array are actually more than a simple table of method pointers; each element of the array is an <a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_689"></a><code>IOExternalMethod</code> structure, of which only one member is a method pointer. </p><p>The other members of the <code>IOExternalMethod</code> structure designate the object implementing the method to invoke (the target), identify the general types of the parameters (scalar or structure, input or output), and provide some information about the parameters. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCBCIHA">Table 4-3</a></span> describes the <code>IOExternalMethod</code> fields.</p><a name="//apple_ref/doc/uid/TP30000698-BBCBCIHA" title="Table 4-3Fields of the IOExternalMethod structure"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4-3&nbsp;&nbsp;</strong>Fields of the <code>IOExternalMethod</code> structure</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Field (with type)</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>IOService * object</code></p></td><td ><p>The driver object implementing the method, usually the user client’s provider (the “target”). Can be <code>NULL</code> if the target is to be dynamically determined at run time.</p></td></tr><tr><td  scope="row"><p><code>IOMethod func</code></p></td><td ><p>A pointer to the method to invoke in the target; include the class name (for example, “com_acme_driver_MyDriver::myMethod”)</p></td></tr><tr><td  scope="row"><p><code>IOOptionBits flags</code></p></td><td ><p>One of the <code>enum</code> constants defined in <code>IOUserClient.h</code> for specifying general parameter types</p></td></tr><tr><td  scope="row"><p><code>IOByteCount count0</code></p></td><td ><p>If first parameter designates scalar, the number of scalar values; if first parameter designates structure, the size of the structure</p></td></tr><tr><td  scope="row"><p><code>IOByteCount count1</code></p></td><td ><p>If second parameter designates scalar, the number of scalar values; if second parameter designates structure, the size of the structure</p></td></tr></table></div><p>You can initialize the <code>IOExternalMethod</code> array in any of the likely places in your code:</p><ul class="spaceabove"><li class="li"><p>In static scope</p></li><li class="li"><p>In the <code>start</code> method</p></li><li class="li"><p>In your implementation of the IOUserClient <code>getTargetAndMethodForIndex</code> method</p></li></ul><p>It is in this last method that the I/O Kit requests the <code>IOExternalMethod</code> structure to use. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCEHGBI">Listing 4-12</a></span> shows how the SimpleUserClient example project initializes the array.</p><a name="//apple_ref/doc/uid/TP30000698-BBCEHGBI" title="Listing 4-12Initializing the array of IOExternalMethod structures"></a><p class="codesample"><strong>Listing 4-12&nbsp;&nbsp;</strong>Initializing the array of <code>IOExternalMethod</code> structures</p><div class="codesample"><table><tr><td scope="row"><pre>static const IOExternalMethod sMethods[kNumberOfMethods] =<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    {   // kMyUserClientOpen<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL,                   // Target determined at runtime.<span></span></pre></td></tr><tr><td scope="row"><pre>        (IOMethod) &amp;com_apple_dts_SimpleUserClient::open,<span></span></pre></td></tr><tr><td scope="row"><pre>        kIOUCScalarIScalarO,    // Scalar Input, Scalar Output.<span></span></pre></td></tr><tr><td scope="row"><pre>        0,                      // No scalar input values.<span></span></pre></td></tr><tr><td scope="row"><pre>        0                       // No scalar output values.<span></span></pre></td></tr><tr><td scope="row"><pre>    },<span></span></pre></td></tr><tr><td scope="row"><pre>    {   // kMyUserClientClose<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL,                   // Target determined at runtime.<span></span></pre></td></tr><tr><td scope="row"><pre>        (IOMethod) &amp;com_apple_dts_SimpleUserClient::close,<span></span></pre></td></tr><tr><td scope="row"><pre>        kIOUCScalarIScalarO,    // Scalar Input, Scalar Output.<span></span></pre></td></tr><tr><td scope="row"><pre>        0,                      // No scalar input values.<span></span></pre></td></tr><tr><td scope="row"><pre>        0                       // No scalar output values.<span></span></pre></td></tr><tr><td scope="row"><pre>    },<span></span></pre></td></tr><tr><td scope="row"><pre>    {   // kMyScalarIStructImethod<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL,                   // Target determined at runtime.<span></span></pre></td></tr><tr><td scope="row"><pre>        (IOMethod) &amp;com_apple_dts_SimpleDriver::method1,<span></span></pre></td></tr><tr><td scope="row"><pre>        kIOUCScalarIStructI,    // Scalar Input, Struct Input.<span></span></pre></td></tr><tr><td scope="row"><pre>        1,                      // One scalar input value.<span></span></pre></td></tr><tr><td scope="row"><pre>        sizeof(MySampleStruct)  // The size of the input struct.<span></span></pre></td></tr><tr><td scope="row"><pre>    },<span></span></pre></td></tr><tr><td scope="row"><pre>    {   // kMyScalarIStructOmethod<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL,                   // Target determined at runtime.<span></span></pre></td></tr><tr><td scope="row"><pre>        (IOMethod) &amp;com_apple_dts_SimpleDriver::method2,<span></span></pre></td></tr><tr><td scope="row"><pre>        kIOUCScalarIStructO,    // Scalar Input, Struct Output.<span></span></pre></td></tr><tr><td scope="row"><pre>        2,                      // Two scalar input values.<span></span></pre></td></tr><tr><td scope="row"><pre>        sizeof(MySampleStruct)  // The size of the output struct.<span></span></pre></td></tr><tr><td scope="row"><pre>    },<span></span></pre></td></tr><tr><td scope="row"><pre>    {   // kMyScalarIScalarOmethod<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL,                   // Target determined at runtime.<span></span></pre></td></tr><tr><td scope="row"><pre>        (IOMethod) &amp;com_apple_dts_SimpleDriver::method3,<span></span></pre></td></tr><tr><td scope="row"><pre>        kIOUCScalarIScalarO,    // Scalar Input, Scalar Output.<span></span></pre></td></tr><tr><td scope="row"><pre>        2,                      // Two scalar input values.<span></span></pre></td></tr><tr><td scope="row"><pre>        1                       // One scalar output value.<span></span></pre></td></tr><tr><td scope="row"><pre>    },<span></span></pre></td></tr><tr><td scope="row"><pre>    {   // kMyStructIStructOmethod<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL,                   // Target determined at runtime.<span></span></pre></td></tr><tr><td scope="row"><pre>        (IOMethod) &amp;com_apple_dts_SimpleDriver::method4,<span></span></pre></td></tr><tr><td scope="row"><pre>        kIOUCStructIStructO,    // Struct Input, Struct Output.<span></span></pre></td></tr><tr><td scope="row"><pre>        sizeof(MySampleStruct), // The size of the input struct.<span></span></pre></td></tr><tr><td scope="row"><pre>        sizeof(MySampleStruct)  // The size of the output struct.<span></span></pre></td></tr><tr><td scope="row"><pre>    },<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000698-TPXREF121" title="Implementing getTargetAndMethodForIndex"></a><h5>Implementing getTargetAndMethodForIndex</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_690"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_691"></a>All subclasses of IOUserClient that use the untyped-data mechanism for data transfer between application and driver must implement the <code>getTargetAndMethodForIndex</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_692"></a> method (or, for asynchronous delivery, <code>getAsyncTargetAndMethodForIndex</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_693"></a>). A typical implementation of <code>getTargetAndMethodForIndex</code> has to do two things: </p><ul class="spaceabove"><li class="li"><p>Return directly a pointer to the appropriate <code>IOExternalMethod</code> structure identifying the method to invoke.</p></li><li class="li"><p>Return a reference to the object that implements the method (the target). </p></li></ul><p>You can either statically assign the target to the <code>IOExternalMethod</code> field when you initialize the structure, or you can dynamically determine the target at run time. Because the target is usually the user client’s provider, often all you need to do is return your reference to your provider (assuming you’ve stored it as an instance variable). <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-TPXREF131">Listing 4-13</a></span> shows one approach for doing this.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF131" title="Listing 4-13Implementing the getTargetAndMethodForIndex method"></a><p class="codesample"><strong>Listing 4-13&nbsp;&nbsp;</strong>Implementing the <code>getTargetAndMethodForIndex</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>IOExternalMethod *<span></span></pre></td></tr><tr><td scope="row"><pre>com_apple_dts_SimpleUserClient::getTargetAndMethodForIndex(IOService **<span></span></pre></td></tr><tr><td scope="row"><pre>                                                target, UInt32 index)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>     // Make sure IOExternalMethod method table has been constructed<span></span></pre></td></tr><tr><td scope="row"><pre>    // and that the index of the method to call exists<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (index &lt; (UInt32)kNumberOfMethods)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (index == kMyUserClientOpen || index == kMyUserClientClose)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // These methods exist in SimpleUserClient<span></span></pre></td></tr><tr><td scope="row"><pre>            *target = this;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // These methods exist in SimpleDriver<span></span></pre></td></tr><tr><td scope="row"><pre>            *target = fProvider;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        return (IOExternalMethod *) &amp;sMethods[index];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30000698-BBCDHHCG" title="Figure 4-4The essential code for passing untyped data"></a><p><strong>Figure 4-4&nbsp;&nbsp;</strong>The essential code for passing untyped data</p><img src = "../Art/untyped_data_passing.gif" alt = "The essential code for passing untyped data" width="524" height="507"></div><br/><a name="//apple_ref/doc/uid/TP30000698-TPXREF122" title="Validation"></a><h5>Validation</h5><p>A user client<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_694"></a> should thoroughly validate all data that it handles. It shouldn’t just blindly trust its client, the user process; the client could be malicious. Some of the validation checks might be internal consistency among input and output commands and buffers, spurious or poorly defined commands, and erroneous register bits. For long and complicated code, you might want to create a configurable validation engine.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_695"></a></p><a name="//apple_ref/doc/uid/TP30000698-TPXREF123" title="Passing Untyped Data Asynchronously"></a><h4>Passing Untyped Data Asynchronously</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_696"></a>The<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_697"></a> defining characteristic of the procedure described in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCBAIBH">“Passing Untyped Data Synchronously”</a></span> is the behavior of the user-space thread making an I/O request. When the client in user space requests an I/O transfer by calling one of the <code><!--a-->IOConnectMethod<!--/a--></code> functions, the thread bearing the request must block and wait for the user client to return when the I/O completes. This behavior is synchronous. However, the IOUserClient class also provides APIs for asynchronous data transfer between user process and user client. With these APIs, when the user process calls an <code><!--a-->IOConnectMethod<!--/a--></code> function, it can go on immediately to other tasks because it is not blocked in the function. Later, the user client invokes a callback in the client application, passing it the result and any resulting data.</p><p>Although you can dedicate a separate application thread for notifications of I/O completions (as described in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBFGCFC">“Synchronous Versus Asynchronous Data Transfer”</a></span>), a <a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_698"></a>notification thread is not necessary for asynchronous I/O. In fact, there is an alternative to a notification thread that is much easier to implement.</p><p>You can accomplish the same asynchronous behavior using the application’s run loop (CFRunLoop). Each application’s main thread has a run-loop object that has receive rights on a Mach port set on which all event sources pertinent to the application (mouse events, display events, user-space notifications, and so on) have send rights. Running in a tight loop, the CFRunLoop checks if any of the event sources in its Mach port set have pending events and, if they do, dispatches the event to the intended destination. </p><p>Because run loops are so ubiquitous in user space—every application has one—they offer an easy solution to the problem of posting completions of I/O from the kernel to user space. An I/O notification source for the user client just needs to be added to the run loop. Then the application (or device interface) just needs to pass this port to the user client as well as a pointer to a completion routine for the user client to invoke when the I/O completes.</p><p>This section describes the general procedures that the user client and the application should follow to implement asynchronous I/O using CFRunLoop and <em>some</em> of the APIs in the I/O Kit framework and the IOUserClient class. (Many of the APIs in the IOUserClient class that are tagged with “async” are not essential for implementing asynchronous I/O.) Although this section illustrates the procedure with only one CFRunLoop (associated with the application’s main thread) and one run-loop source, it is possible to have multiple run loops and multiple run-loop sources.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF124" title="Application Procedure Using CFRunLoop"></a><h5>Application Procedure Using CFRunLoop</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_699"></a>To implement its part of asynchronous untyped data-passing, the application or device interface must first obtain receive rights to a port on the application’s CFRunLoop port set, thereby becoming a run-loop source for that run loop. Then it passes this Mach port to its user client. It must also implement a callback function that the user client calls when an I/O completes.</p><p>The following procedure itemizes the steps that the application must complete to accomplish this; all APIs mentioned here are defined in <code>IOKitLib.h</code>, except for the CFRunLoop APIs which are defined in <code>CFRunLoop.h</code> in the Core Foundation framework:</p><ol class="ol"><li class="li"><p>Implement a function that conforms to the callback prototype <code>IOAsyncCallback</code> (or one of the related callback types; see <code>IOKitLib.h</code>).The initial parameter of this function (<code>void *refcon</code>) is an identifier of the I/O request; subsequent parameters are for result and return data (if any). Your implementation of the <code>IOAsyncCallback</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_700"></a> routine should properly handle the result and returned data for each particular I/O request.</p></li><li class="li"><p>Create a notification-port object (which is based on a Mach port).</p><p>Call <code><!--a-->IONotificationPortCreate<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_701"></a>, passing in the master port obtained from the earlier call to <code><!--a-->IOMasterPort<!--/a--></code>. This call returns an <code>IONotificationPortRef</code> object.</p></li><li class="li"><p>Obtain a run-loop source object from the notification-port object.</p><p>Call the <code><!--a-->IONotificationPortGetRunLoopSource<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_702"></a> function, passing in the <code>IONotificationPortRef</code> object. This call returns a <code>CFRunLoopSourceRef</code> object.</p></li><li class="li"><p>Register the run-loop source with the application’s run loop.</p><p>Call <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRunLoopAddSource" target="_top">CFRunLoopAddSource</a></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_703"></a>, specifying as parameters a reference to the application’s CFRunLoop, the <code>CFRunLoopSourceRef</code> object obtained in the previous step, and a run-loop mode of <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/doc/c_ref/kCFRunLoopDefaultMode" target="_top">kCFRunLoopDefaultMode</a></code>.</p></li><li class="li"><p>Get the Mach port backing the run-loop source for the I/O completion notifications.</p><p>Call the <code><!--a-->IONotificationPortGetMachPort<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_704"></a> function, passing in the <code>IONotificationPortRef</code> object again. This call returns a Mach port typed as <code>mach_port_t</code>.</p></li><li class="li"><p>Give the Mach notification port to the user client.</p><p>Call <code><!--a-->IOConnectSetNotificationPort<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_705"></a>, passing in the port and the connection to the user client; the two remaining parameters, type and reference, are defined per I/O Kit family and thus not needed in your case. Calling <code><!--a-->IOConnectSetNotificationPort<!--/a--></code> results in the invocation of <code>registerNotificationPort</code> in the user client.</p></li><li class="li"><p>When your application is ready for an I/O transfer, issue an I/O request by calling one of the <code><!--a-->IOConnectMethod<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_706"></a> functions. The parameter block (such as a task file) containing the I/O request should include as its first two fields a pointer to the <code>IOAsyncCallback</code> callback routine implemented in the application or device interface. It should also include a <code>(void *)</code> refcon field to provide context for the request. Otherwise, the procedure is exactly the same as for synchronous untyped data-passing except that the <code><!--a-->IOConnectMethod<!--/a--></code> function returns immediately.</p></li><li class="li"><p>When there are no more I/O transfers to make, the application or device interface should dispose of the port and remove the run-loop source it has created and registered. This involves completing the following steps:</p><ol class="ol"><li class="ol ol"><p>Remove the run-loop source (<code>CFRunLoopSourceRef</code>) from the run loop by calling <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRunLoopRemoveSource" target="_top">CFRunLoopRemoveSource</a></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_707"></a>.</p></li><li class="ol ol"><p>Destroy the notification-port object by calling <code><!--a-->IONotificationPortDestroy<!--/a--></code>. Note that this call also releases the run-loop source you obtained from the call to <code><!--a-->IONotificationPortGetRunLoopSource<!--/a--></code> in Step 3<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_708"></a>.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_709"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_710"></a></p></li></ol></li></ol><a name="//apple_ref/doc/uid/TP30000698-TPXREF125" title="User Client Procedure"></a><h5>User Client Procedure</h5><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_711"></a>The procedure the IOUserClient subclass must follow using the asynchronous I/O APIs and CFRunLoop is similar to the synchronous approach described in <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCBAIBH">“Passing Untyped Data Synchronously”</a></span> in that some of the same APIs are used. However, the asynchronous I/O procedure (using the application’s run loop) differs in many significant details from the synchronous approach.</p><ol class="ol"><li class="li"><p>Construct the <code>IOExternalMethod</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_712"></a> array and implement the <code>getTargetAndMethodForIndex</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_713"></a> method as you would in the synchronous approach.</p></li><li class="li"><p>Implement the IOUserClient method <code>registerNotificationPort</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_714"></a> to retain a reference to the Mach notification port that is passed in. Recall that this method is invoked as a result of the <code><!--a-->IOConnectSetNotificationPort<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_715"></a> call in user space, and the notification port is a run-loop source of the application’s CFRunLoop object.</p></li><li class="li"><p>In your implementation of the <code>IOMethod</code> method that is invoked, do the following:</p><ol class="ol"><li class="ol ol"><p>Check the <code>IOAsyncCallback</code> pointer field in the parameter block. If it is non-<code>NULL</code>, then you know this is an asynchronous I/O request. (If it is a <code>NULL</code> pointer, then process the request synchronously.)</p></li><li class="ol ol"><p>Call the IOUserClient <code>setAsyncReference</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_716"></a> method, passing in an empty <code>OSAsyncReference</code> array, the notification port on the application’s CFRunLoop, the pointer to the application’s callback routine, and the pointer to the refcon information. The <code>setAsyncReference</code> method initializes the <code>OSAsyncReference</code> array with the following constants (in this order): <code><!--a  -->kIOAsyncReservedIndex<!--/a--></code>, <code><!--a  -->kIOAsyncCalloutFuncIndex<!--/a--></code>, and <code><!--a  -->kIOAsyncCalloutRefconIndex<!--/a--></code>. (These types are defined in the header file <code>OSMessageNotification.h</code>.)</p></li><li class="ol ol"><p>Send off the I/O request for processing by lower objects in the driver stack and return.</p></li></ol></li><li class="li"><p>When the I/O operation completes on a driver work loop, the driver notifies the user client and gives it the result of the I/O operation and any resulting output. To notify the application, the user client calls <code>sendAsyncResult</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_717"></a>, passing in the result and data from the I/O operation. This call results in the invocation of the <code>IOAsyncCallback</code> callback routine in the user-space code.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_86" title="Note"></a><p><strong>Note:</strong>&nbsp;The first parameter of the <code>sendAsyncResult</code> method is the <code>OSAsyncReference</code> array. The last five slots in this array are reserved for the user client to pass data back to the user process.</p></div></li><li class="li"><p>When there are no more I/O transfers, the user client should, in its <code><!--a-->close<!--/a--></code> method, tear down its part of the asynchronous I/O infrastructure by calling <code><!--a-->mach_port_deallocate<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_718"></a> on the notification port.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_719"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_720"></a></p></li></ol><a name="//apple_ref/doc/uid/TP30000698-BBCIJFDG" title="Mapping Device Registers and RAM Into User Space"></a><h4>Mapping Device Registers and RAM Into User Space</h4><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_721"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_722"></a>If your driver has hardware with full PIO memory management, your user client may map the hardware registers into the address space of the user process. In this case, the user process does not require access to physical addresses. However, if the PIO hardware does require the use of interrupts, you will have to factor this requirement into your code. It is always possible, even with DMA hardware, to publish device RAM to user space.</p><p>The user process initiates a request for mapped memory by calling <code><!--a-->IOConnectMapMemory<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_723"></a>, passing in, among other parameters, a pointer to (what will become) the mapped memory in its own address space. The <code><!--a-->IOConnectMapMemory<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_724"></a> call results in the invocation of the <code>clientMemoryForType</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_725"></a> method in the user client. In its implementation of this method, the user client returns the IOMemoryDescriptor<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_726"></a> object it created in its <code>open</code> or <code>start</code> method that backs the mapping to the hardware registers. The user process receives back this mapping in terms of virtual-memory types of <code>vm_address_t</code> and <code>vm_size_t</code>. It is now free to read from and write to the hardware registers.</p><p>Instead of creating an IOMemoryDescriptor object, a user client can (in most cases) simply get the IODeviceMemory<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_727"></a> object created by its provider's nub. Then, in its <code>clientMemoryForType</code> method, it returns a pointer to the IODeviceMemory object. (IODeviceMemory is a subclass of IOMemoryDescriptor.) If it does this, it should ensure the no-caching flag is turned on (by OR-ing the appropriate flag in the <code>IOOptionBits</code> parameter). The nub of the providing driver uses the IODeviceMemory object to map the registers of the PCI device’s physical address space to the kernel’s virtual address space. Through this object, it can get at the kernel’s address space, which most drivers do when they want to talk to hardware registers. Returning the provider’s IODeviceMemory object in the <code>clientMemoryForType</code> method is also how you publish (PCI) device RAM out to user space. </p><p>Make sure you retain the IODeviceMemory or any other IOMemoryDescriptor object in your implementation of <code>clientMemoryForType</code> so a reference to it can be returned to the caller.</p><p>If the user client creates an IOMemoryDescriptor object in its <code>open</code> method,  it should release the object in its <code>close</code> method; if the user client creates an IOMemoryDescriptor object in its <code>start</code> method, it should release the object in its <code>stop</code> method. If the user client passes on an IODeviceMemory object created by its provider, it should not release it at all (the provider should release it appropriately). At the close of I/O, the device interface or application should call <code><!--a-->IOConnectUnmapMemory<!--/a--></code>.</p><p>For example implementations of <code><!--a-->IOConnectMapMemory<!--/a--></code> and <code>clientMemoryForType</code>, see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCEDHJB">Listing 4-18</a></span> and <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBFIAID">Listing 4-24</a></span>, respectively.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_728"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_729"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_730"></a></p><a name="//apple_ref/doc/uid/TP30000698-CJBJEBCB" title="A Guided Tour Through a User Client"></a><h2>A Guided Tour Through a User Client</h2><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_731"></a>Double X Technologies makes a number of products. (This is a fictional company, so don’t go searching for it on the Internet.) One product is a video-capture board. This hardware uses a DMA engine for data transfer at high rates and does not permit device sharing. The company has written a Mac OS X (Darwin) driver for it, and now wants to make device and driver accessible to as many user-space clients as possible. So they decide they need to write a user client and complementary user-space library—a device interface—for it.</p><p>The Double X engineers decide upon a design that is structured around register task files, and that uses a combination of synchronous untyped-data passing and shared memory. This section takes you on a guided tour through their design, illustrating the salient parts with code examples. The tour has three major stops corresponding to the three major parts of the design:</p><ul class="ul"><li class="li"><p>Definitions of types common to both the kernel and user-space code</p></li><li class="li"><p>The user-space library that functions as the device interface</p></li><li class="li"><p>The subclass of IOUserClient</p></li></ul><a name="//apple_ref/doc/uid/TP30000698-TPXREF126" title="Common Type Definitions"></a><h3>Common Type Definitions</h3><p>The project for the Double X Capture driver also includes the user-client header and source files. One of these header files contains the type definitions that are used by both the user client and the device interface. This file contains the <code>enum</code> constants used as indexes into the array of <code>IOExternalMethod</code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_732"></a> structures maintained by the user client. It also contains structures for the various types of task files, operation codes, and macro initializers for the task files.</p><p><span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCDCHGF">Listing 4-14</a></span> shows the definition of the <code>enum</code> constants used as method-array indexes.</p><a name="//apple_ref/doc/uid/TP30000698-BBCDCHGF" title="Listing 4-14The indexes into the IOExternalMethod array"></a><p class="codesample"><strong>Listing 4-14&nbsp;&nbsp;</strong>The indexes into the <code>IOExternalMethod</code> array</p><div class="codesample"><table><tr><td scope="row"><pre>typedef enum XXCaptureUCMethods {<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXCaptureUserClientActivate        // kIOUCScalarIScalarO,  3,  0<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXCaptureUserClientDeactivate      // kIOUCScalarIScalar0,  0,  0<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXCaptureUserClientExecuteCommand, // kIOUCStructIStructO, -1, -1<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXCaptureUserClientAbortCommand,   // kIOUCScalarIScalarO,  1,  0<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXCaptureLastUserClientMethod,<span></span></pre></td></tr><tr><td scope="row"><pre>} XXCaptureUCMethods;<span></span></pre></td></tr></table></div><p>As you can see, the methods invoked by the user client allocate (activate) and deallocate (deactivate) kernel and hardware resources, and execute and abort commands. The activate command also results in the invocation of the user client’s <code>open</code> method (for enforcing exclusive access) and the deactivate command causes the invocation of <code>close</code>. This walk-through focuses on the execute command (<code><!--a  -->kXXCaptureUserClientExecuteCommand<!--/a--></code>).</p><p>Each task file begins with an “op code” (or operation code) that indicates the type of task to perform with the task file. The Double X Capture user client defines about a dozen op codes as <code>enum</code> constants (see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCIAEIC">Listing 4-15</a></span>).</p><a name="//apple_ref/doc/uid/TP30000698-BBCIAEIC" title="Listing 4-15Operation codes for task files"></a><p class="codesample"><strong>Listing 4-15&nbsp;&nbsp;</strong>Operation codes for task files</p><div class="codesample"><table><tr><td scope="row"><pre>typedef enum XXCaptureOpCodes {<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXGetAddress = 0,                      //  0<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXGetRegister,                         //  1<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXSetAddress,                          //  2<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXSetRegister,                         //  3<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXClearRegister,                       //  4<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXSetToRegister,                       //  5<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // DMA control commands<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXDMATransferBlock,                    //  6<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXDMATransferNonBlock,                 //  7<span></span></pre></td></tr><tr><td scope="row"><pre>    kXXLastOpCode<span></span></pre></td></tr><tr><td scope="row"><pre>} XXCaptureOpCodes;<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_733"></a>The op codes cover a range of register-specific actions, from getting an address or register value to setting an address or register. There are also two op codes for two kinds of DMA transfers: blocking and non-blocking. This section focuses on task files with two op codes: atomic set register to value (<code><!--a  -->kXXSetToRegister<!--/a--></code>) and blocking DMA transfer (<code><!--a  -->kXXDMATransferBlock<!--/a--></code>).</p><p>The Double X user-client code defines a task file as a structure of type <code>XXUCCommandData</code>. The first few fields of this structure are reserved for status and configuration information; the last field (<code>fCmds</code>) is an array of <code>XXCaptureCommandBlock</code> structures. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCGHCFD">Listing 4-16</a></span> shows the definitions of these structures.</p><a name="//apple_ref/doc/uid/TP30000698-BBCGHCFD" title="Listing 4-16Task-file structures used in some operations"></a><p class="codesample"><strong>Listing 4-16&nbsp;&nbsp;</strong>Task-file structures used in some operations</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct XXUCCommandData {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn fErrorCode;    // Out:What type of error<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 fNumCmds;        // In:Number of commands, Out:Cmd in error<span></span></pre></td></tr><tr><td scope="row"><pre>    XXCaptureCommandBlock fCmds[0];<span></span></pre></td></tr><tr><td scope="row"><pre>} XXUCCommandData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct XXCaptureCommandBlock {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 fOp;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 fReg;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 fReserved[3];<span></span></pre></td></tr><tr><td scope="row"><pre>} XXCaptureCommandBlock;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct XXCaptureRegisterToValue {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 fOp;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 fReg;            // In, register address in BAR<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 fValue;          // In|Out, value of bits to be set<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 fMask;           // In|Out, mask of bits to be set<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 fReserved2;      // 0, Do not use<span></span></pre></td></tr><tr><td scope="row"><pre>} XXCaptureRegisterToValue;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct XXCaptureDMATransfer {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 fOp;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 fDirection;      // Direction of transfer<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8 *fUserBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8 fDevOffset;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 fLength;         // In, length in bytes to transfer<span></span></pre></td></tr><tr><td scope="row"><pre>} XXCaptureDMATransfer;<span></span></pre></td></tr></table></div><p>Also shown in this example are two types of structures specific to the kinds of commands we are tracing in this tour: Set register value and contiguous blocking DMA transfer. The structure types are, respectively, <code>XXCaptureRegisterToValue</code> and <code>XXCaptureDMATransfer</code>. When the device interface builds a task file containing these command structures, it puts them in the <code>XXCaptureCommandBlock</code> array even though they are not of that type. Note that <code>XXCaptureCommandBlock</code> ends with some padding (<code>fReserved</code>), guaranteeing it to be at least the same size as any other command-block structure. You just need to do the appropriate casting on an item in the <code>XXCaptureCommandBlock</code> array to get a structure of the correct type.</p><p>The common header file also defines macros that initialize commands and put them into a task file. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCCEFJE">Listing 4-17</a></span> shows the macro initializers for the <code>XXCaptureRegisterValue</code> and <code>XXCaptureDMATransfer</code> command structures.</p><a name="//apple_ref/doc/uid/TP30000698-BBCCEFJE" title="Listing 4-17Macro initializers for some task files"></a><p class="codesample"><strong>Listing 4-17&nbsp;&nbsp;</strong>Macro initializers for some task files</p><div class="codesample"><table><tr><td scope="row"><pre>#define cmdGetRegister(cmd, reg) do {                               \<span></span></pre></td></tr><tr><td scope="row"><pre>    XXCaptureCommandBlock *c = (XXCaptureCommandBlock *) (cmd);     \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fOp   = kXXCaptureGetRegister;                                       \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fReg  = (reg);                                               \<span></span></pre></td></tr><tr><td scope="row"><pre>    cmd++;                                                          \<span></span></pre></td></tr><tr><td scope="row"><pre>} while (0)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define cmdSetToRegister(cmd, reg, val) do {                        \<span></span></pre></td></tr><tr><td scope="row"><pre>    XXCaptureRegisterValue *c = (XXCaptureRegisterValue *) (cmd);       \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fOp    = kXXSetToRegister;                                   \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fReg   = (reg);                                              \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fValue = (val);                                              \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fMask  = (mask);                                             \<span></span></pre></td></tr><tr><td scope="row"><pre>    cmd++;                                                          \<span></span></pre></td></tr><tr><td scope="row"><pre>} while (0)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define cmdDMA(cmd, op, dir, u, d, len) do {                        \<span></span></pre></td></tr><tr><td scope="row"><pre>    XXCaptureDMATransfer *c = (XXCaptureDMATransfer *) (cmd);           \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fOp      = (op);                                             \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fDirection = (dir);                                          \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fUserBuf = (u);                                              \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fDevOffset = (d);                                            \<span></span></pre></td></tr><tr><td scope="row"><pre>    c->fLength  = (len);                                            \<span></span></pre></td></tr><tr><td scope="row"><pre>    cmd++;                                                          \<span></span></pre></td></tr><tr><td scope="row"><pre>} while (0)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define cmdDMABlock(cmd, dir, u, d, len)                            \<span></span></pre></td></tr><tr><td scope="row"><pre>        cmdDMA(cmd, kXXDMATransferBlock, dir, u, d, len)#define cmdDMANonBlock(cmd, dir, u, d, len)                         \<span></span></pre></td></tr><tr><td scope="row"><pre>        cmdDMA(cmd, kXXDMATransferNonBlock, dir, u, d, len)<span></span></pre></td></tr></table></div><p>The <code>#define</code> preprocessor statement was used to construct these macros because it enables the code to increment the index automatically to the next command in the <code>XXCaptureCommandBlock</code> array.</p><a name="//apple_ref/doc/uid/TP30000698-TPXREF127" title="The Device Interface Library"></a><h3>The Device Interface Library</h3><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_734"></a>The library implemented by Double X to function as the device interface for its video-capture hardware presents a functional programmatic interface to applications. (Application developers shouldn’t have to know low-level details of the hardware.) When it receives a functional request (equivalent to something like “write <em>n</em> blocks of data”), the device interface breaks it down into the required hardware-register commands, puts these commands in a task file, and sends this task file to the user client for execution. </p><p>First, the application requests the Double X device interface to establish a connection to the user client. The device interface defines function <code><!--a-->XXDeviceOpen<!--/a--></code> (not shown) for this purpose. This function completes the steps described earlier in the following sections:</p><ol class="ol"><li class="li"><p><span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCBAEII">“Get the I/O Kit Master Port”</a></span></p></li><li class="li"><p><span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBCHGGA">“Obtain an Instance of the Driver”</a></span></p></li><li class="li"><p><span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBCDCFB">“Create a Connection”</a></span></p></li></ol><p>Even though the device interface now has a connection to the user client, I/O transfers cannot yet occur. The user client must first open its provider and prepare for I/O by allocating the necessary kernel and hardware resources. The <code><!--a-->XXDeviceConnect<!--/a--></code> function, which the application calls after it has opened a connection, is defined for this purpose (see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCEDHJB">Listing 4-18</a></span>).</p><a name="//apple_ref/doc/uid/TP30000698-BBCEDHJB" title="Listing 4-18Invoking the user client&acirc;&#128;&#153;s activate method, mapping card memory"></a><p class="codesample"><strong>Listing 4-18&nbsp;&nbsp;</strong>Invoking the user client’s activate method, mapping card memory</p><div class="codesample"><table><tr><td scope="row"><pre>// knXXCaptureUserClientActivate, kIOUCScalarIScalarO,  3,  0<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t<span></span></pre></td></tr><tr><td scope="row"><pre>XXDeviceConnect(XXDeviceHandle handle,<span></span></pre></td></tr><tr><td scope="row"><pre>                 Boolean fieldMode, UInt32 storeSize)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    XXDeviceDataRef device = (XXDeviceDataRef) handle;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t ret;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ret = IOConnectMethodScalarIScalarO(device->fUCHandle,<span></span></pre></td></tr><tr><td scope="row"><pre>            kXXCaptureUserClientActivate, 3, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>            (int) &amp;device->fStatus, (int) fieldMode,<span></span></pre></td></tr><tr><td scope="row"><pre>            storeSize);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (KERN_SUCCESS != ret)<span></span></pre></td></tr><tr><td scope="row"><pre>        goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ret = IOConnectMapMemory(device->fUCHandle,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kXXCaptureUserClientCardRam0,<span></span></pre></td></tr><tr><td scope="row"><pre>                        mach_task_self(),<span></span></pre></td></tr><tr><td scope="row"><pre>                        (vm_address_t *) &amp;device->fCardRAM,<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;device->fCardSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kIOMapAnywhere);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    return ret;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The call to <code><!--a-->IOConnectMethodScalarIScalarO<!--/a--></code> in this example invokes the user client’s <code>activate</code> method. This method opens the provider, gets the provider’s DMA engine, adds a filter interrupt source to the work loop and maps a status block into shared memory.</p><p>The <code><!--a-->XXDeviceConnect<!--/a--></code> function also maps the capture card’s physical memory into the address space of the user process. It stores the returned addressing information in the <code>XXDeviceHandle</code> “global” structure. This step is necessary before any DMA transfers can take place.</p><p>For actual I/O transfers, the Double X device interface defines a number of functions that present themselves with names and signatures whose significance an application developer can easily grasp. This functional I/O interface might consist of functions with names such as <code><!--a-->XXCaptureWriteData<!--/a--></code>, <code><!--a-->XXCaptureReadData<!--/a--></code>, and (for hardware that understands blocks) <code><!--a-->XXCaptureWriteBlocks<!--/a--></code>. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBECEBA">Listing 4-19</a></span> shows how the device interface implements the <code><!--a-->XXCaptureWriteBlocks<!--/a--></code> function.</p><a name="//apple_ref/doc/uid/TP30000698-CJBECEBA" title="Listing 4-19The device interface&acirc;&#128;&#153;s function for writing blocks of data"></a><p class="codesample"><strong>Listing 4-19&nbsp;&nbsp;</strong>The device interface’s function for writing blocks of data</p><div class="codesample"><table><tr><td scope="row"><pre>#define writeCmdSize \<span></span></pre></td></tr><tr><td scope="row"><pre>    (sizeof(XXUCCommandData) + kMaxCommands* sizeof(XXCaptureCommandBlock))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int XXCaptureWriteBlocks(XXDeviceHandle device, int blockNo, void *addr,<span></span></pre></td></tr><tr><td scope="row"><pre>                            int *numBlocks)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int res;<span></span></pre></td></tr><tr><td scope="row"><pre>    int length;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8 buffer[writeCmdSize];<span></span></pre></td></tr><tr><td scope="row"><pre>    XXCaptureCommandBlock *cmd, *getCmd;<span></span></pre></td></tr><tr><td scope="row"><pre>    XXUCCommandData *cmds = (XXUCCommandData *) buffer;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    cmd = &amp;cmds->fCmds[0];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    cmdSetToRegister(cmd, kXXCaptureControlReg, -1, kXXCaptureDMAResetMask);<span></span></pre></td></tr><tr><td scope="row"><pre>    cmdDMABlock(cmd, kIODirectionOut, adddr, blockNo, *numBlocks);<span></span></pre></td></tr><tr><td scope="row"><pre>    getCmd = cmd;<span></span></pre></td></tr><tr><td scope="row"><pre>    cmdGetRegister(cmd, kXXCaptureDMATransferred);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    length = (UInt8 *) cmd - (UInt8 *) cmds;<span></span></pre></td></tr><tr><td scope="row"><pre>    res = (int) IOConnectMethodStructureIStructureO(device->fUCHandle,<span></span></pre></td></tr><tr><td scope="row"><pre>                kXXCaptureUserClientExecuteCommand,<span></span></pre></td></tr><tr><td scope="row"><pre>                length, length, cmds, cmds);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (res)<span></span></pre></td></tr><tr><td scope="row"><pre>        goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    res = cmds->fErrorCode;<span></span></pre></td></tr><tr><td scope="row"><pre>    *numBlocks = getCmd->fValue;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    return res;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This function basically takes a request to write a block of data (whose user-space address and size is supplied in the parameters) and constructs a task file composed of three register-based commands: </p><ul class="spaceabove"><li class="li"><p>The <code>cmdSetToRegister</code> macro constructs a command that tells the hardware to reset the DMA engine.</p></li><li class="li"><p>The <code>cmdDMABlock</code> macro puts together a command that programs the DMA engine for the I/O transfer using the passed-in parameters and specifying the direction of the transfer (<code><!--a  -->kIODirectionOut<!--/a--></code>).</p></li><li class="li"><p>The <code>cmdGetRegister</code> macro creates a command that reads a register containing the number of blocks that were transferred. </p></li></ul><p>The <code><!--a-->XXCaptureWriteBlocks<!--/a--></code> function next calls <code><!--a-->IOConnectMethodStructureIStructureO<!--/a--></code>, passing in a pointer to the <code>XXCaptureCommandBlock</code> task file just created. This function call results in the invocation of the user client’s <code>execute</code> method (see <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-TPXREF128">“The User Client”</a></span>). Finally, the function determines if there was an error in the execution of the task file; if there was, it extracts the information from the output <code>XXCaptureCommandBlock</code> structure (<code>getCmd</code>) and returns this information to the calling application<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_735"></a>.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_736"></a></p><a name="//apple_ref/doc/uid/TP30000698-TPXREF128" title="The User Client"></a><h3>The User Client</h3><p>Think back to the <code><!--a-->IOConnectMethodStructureIStructureO<!--/a--></code> call in the device interface’s <code><!--a-->XXCaptureWriteBlocks<!--/a--></code> function.Through the magic of Mach messaging and the I/O Kit, that call comes out on the kernel side as an invocation of the user client’s <code>getTargetAndMethodForIndex</code> method with an index argument of <code><!--a  -->kXXCaptureUserClientExecuteCommand<!--/a--></code>. The IOUserClient subclass for the Double X device implements the <code>getTargetAndMethodForIndex</code> to handle this as shown in<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_737"></a><span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCHGBDD">Listing 4-20</a></span>.</p><a name="//apple_ref/doc/uid/TP30000698-BBCHGBDD" title="Listing 4-20Returning a pointer to an IOExternalMethod structure"></a><p class="codesample"><strong>Listing 4-20&nbsp;&nbsp;</strong>Returning a pointer to an <code>IOExternalMethod</code> structure</p><div class="codesample"><table><tr><td scope="row"><pre>#define kAny ((IOByteCount) -1 )<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static IOExternalMethod sXXCaptureUserClientMethods[] =<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // kXXCaptureUserClientActivate,<span></span></pre></td></tr><tr><td scope="row"><pre>    { 0, Method(activate),   kIOUCScalarIScalarO,    3,    0 },<span></span></pre></td></tr><tr><td scope="row"><pre>    // kXXCaptureUserClientDeactivate,<span></span></pre></td></tr><tr><td scope="row"><pre>    { 0, Method(deactivate), kIOUCScalarIScalarO,    0,    0 },<span></span></pre></td></tr><tr><td scope="row"><pre>    // kXXCaptureUserClientExecuteCommand,<span></span></pre></td></tr><tr><td scope="row"><pre>    { 0, Method(execute),    kIOUCStructIStructO, kAny, kAny },<span></span></pre></td></tr><tr><td scope="row"><pre>    // kXXCaptureUserClientAbortCommand,<span></span></pre></td></tr><tr><td scope="row"><pre>    { 0, Method(abort),      kIOUCScalarIScalarO,    1,    0 },<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IOExternalMethod *XXCaptureUserClient::<span></span></pre></td></tr><tr><td scope="row"><pre>getTargetAndMethodForIndex(IOService **targetP, UInt32 index)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOExternalMethod *method = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (index &lt; kXXCaptureLastUserClientMethod)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        *targetP = this;<span></span></pre></td></tr><tr><td scope="row"><pre>        method = &amp;sXXCaptureUserClientMethods[index];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return method;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As a result of the returned index and target, the I/O Kit invokes the <code>execute</code> method in the user client, passing in pointers to the task-file buffers (<code>vInCmd</code> and <code>vOutCmd</code>). As you can see from <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCFGGII">Listing 4-21</a></span>, the <code>execute</code> method begins by declaring local variables and assigning the parameters to them.</p><a name="//apple_ref/doc/uid/TP30000698-BBCFGGII" title="Listing 4-21The execute method&acirc;&#128;&#148;preparing the data"></a><p class="codesample"><strong>Listing 4-21&nbsp;&nbsp;</strong>The <code>execute</code> method—preparing the data</p><div class="codesample"><table><tr><td scope="row"><pre>// kXXCaptureUserClientExecuteCommand, kIOUCStructIStructO, -1, -1<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn XXCaptureUserClient::<span></span></pre></td></tr><tr><td scope="row"><pre>execute(void *vInCmd,  void *vOutCmd,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *vInSize, void *vOutSizeP, void *, void *)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    XXCaptureCommandBlock *cmd;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 index, numCmds, cmdSize;<span></span></pre></td></tr><tr><td scope="row"><pre>    bool active;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    XXUCCommandData *inCmdBuf = (XXUCCommandData *) vInCmd;<span></span></pre></td></tr><tr><td scope="row"><pre>    XXUCCommandData *outCmdBuf = (XXUCCommandData *) vOutCmd;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 *outSizeP = (UInt32 *) vOutSizeP;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32  inSize = (UInt32) vInSize, outSize = *outSizeP;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn ret = kIOReturnInternalError;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 numOutCmd;<span></span></pre></td></tr></table></div><p>Before it does any I/O work, the <code>execute</code> method performs a series of validation checks on the parameters. It validates the sizes of input and output command blocks and ensures that they are internally consistent. It also checks for command blocks with spurious data, such as registers whose bits cannot be set. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCEDGJF">Listing 4-22</a></span> illustrates how the user client performs one such check on the <code><!--a  -->kXXSetToRegister<!--/a--></code> command.</p><a name="//apple_ref/doc/uid/TP30000698-BBCEDGJF" title="Listing 4-22A validation check on kXXSetToRegister command"></a><p class="codesample"><strong>Listing 4-22&nbsp;&nbsp;</strong>A validation check on <code>kXXSetToRegister</code> command</p><div class="codesample"><table><tr><td scope="row"><pre>        case kXXSetToRegister: {<span></span></pre></td></tr><tr><td scope="row"><pre>            XXCaptureRegisterToValue *regCmd;<span></span></pre></td></tr><tr><td scope="row"><pre>            regCmd = (XXCaptureRegisterToValue *) cmd;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            if ( !isValidBitsForRegister(cmd->fReg, regCmd->fMask)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                DebugLog(("%s(%x)::execute() "<span></span></pre></td></tr><tr><td scope="row"><pre>                          "can't set bit %x for reg(%d)\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                          getName(), (int) this,<span></span></pre></td></tr><tr><td scope="row"><pre>                          (int) regCmd->fValue, (int) cmd->fReg));<span></span></pre></td></tr><tr><td scope="row"><pre>                ret = kIOReturnBadArgument;<span></span></pre></td></tr><tr><td scope="row"><pre>                goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr></table></div><p>This section of code validates the register operation, determining if the register is valid and whether it’s permitted to modify the intended bits.</p><p><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_738"></a>After completing the validation phase, the user client carries out the I/O request. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCHGFHE">Listing 4-23</a></span> shows how the <code>execute</code> method handles the <code><!--a  -->kXXSetToRegister<!--/a--></code> and <code><!--a  -->kXXContTransferBlock<!--/a--></code> commands.</p><a name="//apple_ref/doc/uid/TP30000698-BBCHGFHE" title="Listing 4-23The execute method&acirc;&#128;&#148;executing the I/O command"></a><p class="codesample"><strong>Listing 4-23&nbsp;&nbsp;</strong>The <code>execute</code> method—executing the I/O command</p><div class="codesample"><table><tr><td scope="row"><pre>    cmd = inCmdBuf->fCmds;<span></span></pre></td></tr><tr><td scope="row"><pre>    for (index = 0; index &lt; numCmds; index += cmdSize, cmd += cmdSize)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        cmdSize = 1;            // Setup default command size<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        switch (cmd->fOp)<span></span></pre></td></tr><tr><td scope="row"><pre>        case kXXSetToRegister: {<span></span></pre></td></tr><tr><td scope="row"><pre>            XXCaptureRegisterToValue *regCmd =<span></span></pre></td></tr><tr><td scope="row"><pre>                (XXCaptureRegisterToValue *) &amp;inCmdBuf->fCmds[index];<span></span></pre></td></tr><tr><td scope="row"><pre>            fNub->toValueBitAtomic(cmd->fReg, regCmd->fValue, regCmd->fMask);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        case kXXGetRegister: {<span></span></pre></td></tr><tr><td scope="row"><pre>            XXCaptureRegisterValue *out =<span></span></pre></td></tr><tr><td scope="row"><pre>                (XXCaptureRegisterValue *) &amp;outCmdBuf->fCmds[index];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            out->fValue = fNub->getReg(regP);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        case kXXDMATransferBlock:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kXXDMATransferNonBlock: {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            XXCaptureDMATransfer *c =<span></span></pre></td></tr><tr><td scope="row"><pre>                (XXCaptureDMATransfer *) &amp;inCmdBuf->fCmds[index];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            DMARequest *req;<span></span></pre></td></tr><tr><td scope="row"><pre>            bool blocking = c->fOp == kXXDMATransferBlock;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            req = fProvider->createDMARequest(<span></span></pre></td></tr><tr><td scope="row"><pre>                        (vm_address_t) c->fUserBuf,<span></span></pre></td></tr><tr><td scope="row"><pre>                        fClient,<span></span></pre></td></tr><tr><td scope="row"><pre>                        c->fDevOffset,<span></span></pre></td></tr><tr><td scope="row"><pre>                        c->fDirection,<span></span></pre></td></tr><tr><td scope="row"><pre>                        c->fLength,<span></span></pre></td></tr><tr><td scope="row"><pre>                        this,<span></span></pre></td></tr><tr><td scope="row"><pre>                        (XXDMAEngine::Completion)<span></span></pre></td></tr><tr><td scope="row"><pre>                            &amp;XXCaptureUserClient::dmaCompleteGated,<span></span></pre></td></tr><tr><td scope="row"><pre>                        (void *) blocking);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (!req) {<span></span></pre></td></tr><tr><td scope="row"><pre>                ret = kIOReturnError;<span></span></pre></td></tr><tr><td scope="row"><pre>                goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            ret = fGate->runAction(gatedFunc(runDMAGated),<span></span></pre></td></tr><tr><td scope="row"><pre>                (void *) req, (void *) blocking);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // other code here ...<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    outCmdBuf->fErrorCode = ret;<span></span></pre></td></tr><tr><td scope="row"><pre>    outCmdBuf->fNumCmds = index;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If the command is “set register to value” (<code><!--a  -->kXXSetToRegister<!--/a--></code>), <code>execute</code> calls a method implemented by its provider called <code>toValueBitAtomic</code>. This method sets the specified register to the specified value in an atomic manner.</p><p>If the command is “get register value” (<code><!--a  -->kXXGetRegister<!--/a--></code>), <code>execute</code> calls its provider to get the value of the specified register (in this case, holding the number of blocks transferred). The code assigns this value to the appropriate field (<code>fValue</code>) of the <code><!--a  -->kXXGetRegister<!--/a--></code> command.</p><p>If the command is “program DMA engine for contiguous blocking I/O transfer” (<code><!--a  -->kXXDMATransferBlock<!--/a--></code>), the <code>execute</code> method programs the DMA engine by completing the following steps:</p><ol class="ol"><li class="li"><p>It creates a DMA request by calling the <code>createDMARequest</code> method, which is implemented by an object representing the DMA engine.</p></li><li class="li"><p>It programs the DMA engine by running the <code>runDMAGated</code> method in the command gate.</p></li><li class="li"><p>It puts the result of the I/O operation and the number of blocks transferred in the appropriate fields of the output task file; if an error has occurred, the <code>fNumCmds</code> field of this structure (<code>XXUCCommandData</code>) holds the index of the command causing the error.</p></li></ol><p>Before leaving this example, let’s look at the user client’s role in preparing shared memory for the DMA transfers. Recall how the device interface, in its <code><!--a-->XXDeviceConnect<!--/a--></code> function, called <code><!--a-->IOConnectMapMemory<!--/a--></code><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_739"></a> to map the hardware registers of the video-capture board into its address space. The <code><!--a-->IOConnectMapMemory<!--/a--></code> call causes the invocation of the <code>clientMemoryType</code> method in the user client. <span class="content_text"><a href="MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-CJBFIAID">Listing 4-24</a></span> shows how the Double X user client implements this method to return an IOMemoryDescriptor<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_740"></a>.</p><a name="//apple_ref/doc/uid/TP30000698-CJBFIAID" title="Listing 4-24Implementation of clientMemoryForType"></a><p class="codesample"><strong>Listing 4-24&nbsp;&nbsp;</strong>Implementation of <code>clientMemoryForType</code></p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn XXCaptureUserClient::<span></span></pre></td></tr><tr><td scope="row"><pre>clientMemoryForType(UInt32 type, UInt32 *flags,<span></span></pre></td></tr><tr><td scope="row"><pre>                    IOMemoryDescriptor **memory)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOMemoryDescriptor *mem;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn ret;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch(type)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>    case kXXCaptureUserClientCardRam0:<span></span></pre></td></tr><tr><td scope="row"><pre>        mem = fNub->getDeviceRAM();<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    default:<span></span></pre></td></tr><tr><td scope="row"><pre>        ret = kIOReturnUnsupported;<span></span></pre></td></tr><tr><td scope="row"><pre>        goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!mem)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ret = kIOReturnNoMemory;<span></span></pre></td></tr><tr><td scope="row"><pre>        goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    mem->retain();<span></span></pre></td></tr><tr><td scope="row"><pre>    *memory = mem;<span></span></pre></td></tr><tr><td scope="row"><pre>    ret = kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return ret;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In this method, the user client simply gets the memory descriptor of its provider if the type of the memory requested is <code><!--a  -->kXXCaptureUserClientCardRam0<!--/a--></code>. This memory-descriptor object is an instance of the IODeviceMemory<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_741"></a> class, which inherits from IOMemoryDescriptor. It represents the registers of a PCI device (the video-capture card, in this case) and, more particularly, the mapping of those physical addresses into the kernel’s virtual address space. Before returning the IODeviceMemory object, this implementation retains it. When the user client returns this IODeviceMemory object (by indirection), the I/O Kit converts it to the application’s address space in terms of <code>vm_address_t</code> memory pointer and length.<a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_742"></a><a name="//apple_ref/doc/uid/TP30000698-DontLinkElementID_743"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../IOService/IOService.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../KernelUserNotification/KernelUserNotification.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-03-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/MakingHWAccessible/MakingHWAccessible.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/MakingHWAccessible/MakingHWAccessible.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/MakingHWAccessible/MakingHWAccessible.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>