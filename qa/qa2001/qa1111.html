<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Q&amp;A QA1111: Calling an AppleScript and providing parameters from an Application</title><meta name="keywords" content="AppleScript parameter parameters"><meta name="Description" content="Technical Q&amp;A QA1111: This Q&amp;A presents a method for passingparameter values to a script called inside of an application."><meta name="categories" content="AppleScript"><meta name="week-posted" content="Mar 11, 2002 - Mar 15, 2002"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10001659" title="Calling an AppleScript and providing parameters from an Application"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/ScriptingAutomation/index.html">Scripting & Automation</a> &gt; <a href="../../technicalqas/ScriptingAutomation/idxCarbon-date.html">Carbon</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A QA1111</div>
<div id="pageheadsub">Calling an AppleScript and providing parameters from an Application</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600> <TR> <td align="left"><!-- begin_content --><hr width=500 align=center>                  <P id=p2>Q:      Is there a convenient way to pass parameters to an AppleScript running inside my application?</p>                  <P id=p4>A:      Yes there is. In simple terms, this can be accomplished by creating a script containing an       subroutine and then sending an appropriately formatted event to that handler from your      application. What follows are the exact steps that you can follow to accomplish this.</p><BR><BR><P id=p4><B>Creating a Script</B></P><P id=p4>The first step is to define a script containing a subroutine withpositional argumentsthat will do the operations you wish to perform.  <A HREF="#LISTING1">Listing 1</A> illustratesan adaptation of the script provided in Technical Q&amp;A<a href="qa1018.html">QA1018,"Using AppleScript to send an email with an attachment"</A> which includes ansubroutine with a number of arguments used in constructing the email message.</p><BR><BR><A NAME="LISTING1"></A><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>on send_email_message(targetAddress, targetName, &not;        subjectLine, messageText, fileAttachment)    tell application "Mail"        (* MAIL APPLICATION VERSION *)        set mailversion to version as string        (* SPECIFY DISPLAY OR SEND OPERATION - if displayForManualSend        is true, then the message is prepared and displayed in a window        for the user to send it.  if displayForManualSend is false, then        the message is sent right away.*)        set displayForManualSend to true        (* SPECIFY GENERAL CONTENT OF MESSAGE *)        set bodyvar to messageText        set addrVar to targetAddress        set addrNameVar to targetName        (* DEFINE THE SUBJECT LINE *)        set subjectvar to subjectLine        (* CREATE THE MESSAGE *)        set composeMessage to (a reference to (make new compose message &not;            at beginning of compose messages))        tell composeMessage            make new to recipient at beginning of to recipients &not;                with properties {address:addrVar, display name:addrNameVar}            set the subject to subjectvar            set the content to bodyvar           (* SPECIFY THE ATTACHMENT *)           tell content                make new text attachment &not;                    with properties {file name:fileAttachment} &not;                    at before the first word of the &not;                    first paragraph            end tell        end tell        (* SEND OR DISPLAY THE MESSAGE *)        if displayForManualSend then            set messageEditor to make new message editor &not;                at beginning of message editors            (* the following is a work around for a bug fixed in later            versions of the Mail application that was present in versions            1.0 and 1.1.  *)            if mailversion is "1.0" or mailversion is "1.1" then                set compose message of last message editor to composeMessage            else                set compose message of first message editor to composeMessage            end if        else            send composeMessage        end if    end tellend send_email_message</pre></TD></TR><TR><td align="left"><P><B>Listing 1</B>. A script containing an AppleScript subroutine with positional arguments.</P></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The script shown in <A HREF="#LISTING1">listing 1</A> illustrates how to attach a single fileto an email message.  It is possible to attach multiple files to a messageby way of an AppleScript script.  To see a sample showing how to do that, consultthe sample script in <a href="qa1018.html">QA1018,"Using AppleScript to send an email with an attachment"</A>.</P></TD></TR></TABLE></CENTER><BR><BR>                    <BR><BR><P id=p4><B>Executing Your Script</B></P><P id=p4>Once you have defined a script, there are a number of waysthat you can store it.  For maximum performance and Mac OS X compatibility,it is recommended that you store your script as a compiled data forkbased AppleScript in a <CODE>.scpt</CODE> file.</p><P id=p4>Once you have loaded your script into memory you cancall your event handler using the <CODE>OSAExecuteEvent</CODE>routine.  <A HREF="#LISTING2">listing 2</A> illustrates how an application can call a subroutinehandler in a script using the <CODE>OSAExecuteEvent</CODE>.  Of course,for this to work the event provided to <CODE>OSAExecuteEvent</CODE> mustbe formatted appropriately.</p><BR><BR><A NAME="LISTING2"></A><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static OSStatus ExecuteCompiledAppleScriptEvent(AEDesc *scriptData,                          AppleEvent *theEvent, AEDesc *resultData) {    ComponentInstance theComponent;    AEDesc scriptTextDesc;    OSStatus err;    OSAID contextID, resultID;        /* set up locals to a known state */    theComponent = NULL;    AECreateDesc(typeNull, NULL, 0, &amp;scriptTextDesc);    contextID = kOSANullScript;    resultID = kOSANullScript;        /* open the scripting component */    theComponent = OpenDefaultComponent(kOSAComponentType, typeAppleScript);    if (theComponent == NULL) { err = paramErr; goto bail; }        /* compile the script into a new context */    err = OSALoad(theComponent, scriptData,                    kOSAModeNull, &amp;contextID);    if (err != noErr) goto bail;        /* run the script */    err = OSAExecuteEvent( theComponent, theEvent,                    contextID, kOSAModeNull, &amp;resultID);        /* collect the results - if any */    if (resultData != NULL) {        AECreateDesc(typeNull, NULL, 0, resultData);        if (err == errOSAScriptError) {            OSAScriptError(theComponent, kOSAErrorMessage,                        typeChar, resultData);        } else if (err == noErr &amp;&amp; resultID != kOSANullScript) {            OSADisplay(theComponent, resultID, typeChar,                        kOSAModeNull, resultData);        }    }bail:    AEDisposeDesc(&amp;scriptTextDesc);    if (contextID != kOSANullScript) OSADispose(theComponent, contextID);    if (resultID != kOSANullScript) OSADispose(theComponent, resultID);    if (theComponent != NULL) CloseComponent(theComponent);    return err;}</pre></TD></TR><TR><td align="left"><P><B>Listing 2</B>. Executing a script containing an event handler.</P></TD></TR></TABLE></CENTER><BR><BR><P id=p4>Of course, there may be circumstances where it is desirableto compile a script on the fly and call <CODE>OSAExecuteEvent</CODE> to executethe event handler.  The techniques for doing so are very similar to thosepresented in <a href="qa1026.html">QA1026,"Calling AppleScript from an Application"</A>, but with two essentialchanges:  when compiling, you provide the <CODE>kOSAModeCompileIntoContext</CODE> flagso the subroutine handler is compiled into an AppleScript context, and youcall <CODE>OSAExecuteEvent</CODE> to run the script.  <A HREF="#LISTING3">listing 3</A> showsthe steps in the compile/execute process.</p><BR><BR><A NAME="LISTING3"></A><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static OSStatus ExecuteAppleScriptEvent(const void* text,          long textLength, AppleEvent *theEvent, AEDesc *resultData) {    ComponentInstance theComponent;    AEDesc scriptTextDesc;    OSStatus err;    OSAID contextID, resultID;        /* set up locals to a known state */    theComponent = NULL;    AECreateDesc(typeNull, NULL, 0, &amp;scriptTextDesc);    contextID = kOSANullScript;    resultID = kOSANullScript;        /* open the scripting component */    theComponent = OpenDefaultComponent(kOSAComponentType,                    typeAppleScript);    if (theComponent == NULL) { err = paramErr; goto bail; }        /* put the script text into a Apple event descriptor record */    err = AECreateDesc(typeChar, text, textLength, &amp;scriptTextDesc);    if (err != noErr) goto bail;        /* compile the script into a new context.  The flag        'kOSAModeCompileIntoContext' is used when compiling a        script containing a handler into a context.  */    err = OSACompile(theComponent, &amp;scriptTextDesc,                    kOSAModeCompileIntoContext, &amp;contextID);    if (err != noErr) goto bail;        /* run the script */    err = OSAExecuteEvent( theComponent, theEvent,                    contextID, kOSAModeNull, &amp;resultID);        /* collect the results - if any */    if (resultData != NULL) {        AECreateDesc(typeNull, NULL, 0, resultData);        if (err == errOSAScriptError) {            OSAScriptError(theComponent, kOSAErrorMessage,                        typeChar, resultData);        } else if (err == noErr &amp;&amp; resultID != kOSANullScript) {            OSADisplay(theComponent, resultID, typeChar,                        kOSAModeDisplayForHumans, resultData);        }    }bail:    AEDisposeDesc(&amp;scriptTextDesc);    if (contextID != kOSANullScript) OSADispose(theComponent, contextID);    if (resultID != kOSANullScript) OSADispose(theComponent, resultID);    if (theComponent != NULL) CloseComponent(theComponent);    return err;}</pre></TD></TR><TR><td align="left"><P><B>Listing 3</B>. Compiling and executing a script containing an event handler.</P></TD></TR></TABLE></CENTER><BR><BR><BR><BR><P id=p4><B>Okay, so what's in the event?</B></P><P id=p4>Well, it's a standard Apple event record formatted the same way as anyevent you would create and target at your own application.  There are two parametersto this event containing information required to execute the handler.  The subroutine argumentsare provided by position in a list stored in the direct parameter (<CODE>keyDirectObject</CODE>)and the name of the subroutine (converted to all lowercase letters) is stored in thesecond event parameter (<CODE>keyASSubroutineName</CODE>)as a string.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>The <CODE>keyASSubroutineName</CODE> (<CODE>'snam'</CODE>) parameter must containthe name of the subroutine that is being called with every letter convertedto lowercase.  For example, if name of the subroutine in your script is "GetDocumentSize",then the string provided in the <CODE>keyASSubroutineName</CODE> parameter should be"getdocumentsize".</P></TD></TR></TABLE></CENTER><BR><BR>                    <BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Events formatted as described in this section may also be sent (by way of <CODE>AESend</CODE>)to compiled and running AppleScript applet applications to call their subroutine handlers.</P></TD></TR></TABLE></CENTER><BR><BR><P id=p4>Putting together the Apple event containing this information is relativelysimple and consists of a sequence of <CODE>AECreateList</CODE>, <CODE>AEPutPtr</CODE>,and <CODE>AEPutDesc</CODE> calls.  <A HREF="#LISTING4">listing 4</A> shows one way you could create anApple event suitable for calling the handler defined in <A HREF="#LISTING1">listing 1</A>.</p><BR><BR><A NAME="LISTING4"></A><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus CreateEmailMessageEvent(AppleEvent *theEvent,        char* targetAddress, char* targetName, char* subjectLine,        char* messageText, AliasHandle fileAttachment) {    AEAddressDesc targetAddr;    AEDescList theParameters;    OSStatus err;    ProcessSerialNumber PSN = {0, kCurrentProcess};    char* handlerName = "send_email_message";    char theState;        /* set up a recoverable state */    AECreateDesc(typeNull, NULL, 0, theEvent);    AECreateDesc(typeNull, NULL, 0, &amp;theParameters);    AECreateDesc(typeNull, NULL, 0, &amp;targetAddr);        /* create self targeting address */    err = AECreateDesc(typeProcessSerialNumber, (Ptr) &amp;PSN,            sizeof(PSN), &amp;targetAddr);    if (err != noErr) goto bail;        /* create the apple event */    err = AECreateAppleEvent('ascr', kASSubroutineEvent,        &amp;targetAddr, kAutoGenerateReturnID,        kAnyTransactionID, theEvent);    if (err != noErr) goto bail;        /* create and add the list of arguments */            /* create the container list */        err = AECreateList(NULL, 0, false, &amp;theParameters);        if (err != noErr) goto bail;            /* add the strings */        err = AEPutPtr(&amp;theParameters, 0, typeText, targetAddress,            strlen(targetAddress));        if (err != noErr) goto bail;        err = AEPutPtr(&amp;theParameters, 0, typeText, targetName,            strlen(targetName));        if (err != noErr) goto bail;        err = AEPutPtr(&amp;theParameters, 0, typeText, subjectLine,            strlen(subjectLine));        if (err != noErr) goto bail;        err = AEPutPtr(&amp;theParameters, 0, typeText, messageText,            strlen(messageText));        if (err != noErr) goto bail;            /* add the alias handle */        theState = HGetState((Handle) fileAttachment);        HLock((Handle) fileAttachment);        err = AEPutPtr(&amp;theParameters, 0, typeAlias, *fileAttachment,                GetHandleSize((Handle) fileAttachment));        HSetState((Handle) fileAttachment, theState);        if (err != noErr) goto bail;        /* add the parameter list created above */    err = AEPutParamDesc(theEvent, keyDirectObject,        &amp;theParameters);        /* add the handler name */    err = AEPutParamPtr(theEvent, keyASSubroutineName,        typeText, handlerName, strlen(handlerName));    if (err != noErr) goto bail;        /* clean up and leave */bail:    AEDisposeDesc(&amp;targetAddr);    AEDisposeDesc(&amp;theParameters);    if (err != noErr) {        AEDisposeDesc(theEvent);    }    return err;}</pre></TD></TR><TR><td align="left"><P><B>Listing 4</B>. Creating an Apple event suitable for calling the AppleScript subroutine defined in <A HREF="#LISTING1">listing 1</A>.</P></TD></TR></TABLE></CENTER><BR><BR><P id=p4>But, there's a better and simpler way to construct such an event.  The new set of <CODE>AEBuild</CODE> routines provide facilities for constructing complex Apple eventsin a simplified way.  <A HREF="#LISTING5">Listing 5</A> illustrates how you can lump allof the calls from <A HREF="#LISTING4">listing 4</A> intoa single system call that constructs the event you would like to send.</p>      <BR><BR><A NAME="LISTING5"></A><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus CreateEmailMessageEvent(AppleEvent *theEvent,        char* targetAddress, char* targetName, char* subjectLine,        char* messageText, AliasHandle fileAttachment) {    OSStatus err;    ProcessSerialNumber PSN = {0, kCurrentProcess};        /* create the container list */    err = AEBuildAppleEvent(        'ascr', kASSubroutineEvent,        typeProcessSerialNumber, (Ptr) &amp;PSN, sizeof(PSN),        kAutoGenerateReturnID, kAnyTransactionID,        theEvent,        NULL,        "'----':[TEXT(@),TEXT(@),TEXT(@),TEXT(@),alis(@@)],"        "'snam':TEXT(@)",        targetAddress, targetName, subjectLine, messageText,        fileAttachment, "send_email_message");    return err;}</pre></TD></TR><TR><td align="left"><P><B>Listing 5</B>. Creating an Apple event suitable for executing an event handler in a script using the<CODE>AEBuildAppleEvent</CODE> routine.</P></TD></TR></TABLE></CENTER><BR><BR><BR><BR><P id=p4><B>Putting it all together</B></P><P>Combining all of the calls described in this document, calling a script with someparameter values would proceed as shown in <A HREF="#LISTING6">listing 6</A>.  Essentially, the steps areto load the compiled script into an <CODE>AEDesc</CODE> of type <CODE>typeOSAGenericStorage</CODE>,create the Apple event, and use the Apple event to call thescript's subroutine.</P><BR><BR><A NAME="LISTING6"></A><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>AppleEvent theAEventAEDesc scriptData;OSStatus err;AliasHandle theAlias;Ptr data;Size count;theAlias = GetAnAliasToSomeFile();err = LoadMyScriptData(&data, &count);if (err == noErr) {    err = AECreateDesc(typeOSAGenericStorage,                        data, count, &compiledScript);    if (err == noErr) {        err = CreateEmailMessageEvent(&amp;theAEvent,            "bogus@apple.com",            "bogus address",            "hello world subject",            "This is a test message\n\n",            theAlias);        if (err == noErr) {                err = ExecuteCompiledAppleScriptEvent(&amp;scriptData,                    &amp;theAEvent, NULL);                ...</pre></TD></TR><TR><td align="left"><P><B>Listing 6</B>. Ordering of calls provided in listings above.</P></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The Script Editor normally stores compiled script data in a resource of type<CODE>'scpt'</CODE> in the files it creates.  You can load this data by calling<CODE>Get1IndResource</CODE> to retrieve the first <CODE>'scpt'</CODE> resource in one ofthose files.In Mac OS X, the preferred convention is to save compiled script data to thedata fork of files with the '.scpt' file name extension.  To retrieve that data,simply read the entire data fork.  When compiling yourown scripts, you can use the <CODE>osacompile</CODE> command line tool withthe <CODE>'-d'</CODE> option to save the compiled script to the data forkof a file (see <CODE>osacompile</CODE>'s man page for more information).</P></TD></TR></TABLE></CENTER><BR><BR>                    <hr width=500 align=center> <!-- begin_date --><H4 ALIGN=center>[Mar 13 2002]</H4><!-- end_date --></TD> </TR> </TABLE></CENTER><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/qa2001/qa1111.html%3Fid%3DDTS10001659-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/qa2001/qa1111.html%3Fid%3DDTS10001659-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/qa2001/qa1111.html%3Fid%3DDTS10001659-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>