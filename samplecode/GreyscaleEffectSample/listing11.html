<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GreyscaleEffectSample - /GreyscaleEffect.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxVideoEffectsTransitions-date.html">Video Effects & Transitions</a> &gt; <A HREF="javascript:location.replace('index.html');">GreyscaleEffectSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GreyscaleEffectSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GreyscaleEffect.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ComponentIncludes/ComponentDispatchHelper.c</option>
<option value="listing2.html">/ComponentIncludes/ComponentIncludes.txt</option>
<option value="listing3.html">/ComponentIncludes/Components.k.h</option>
<option value="listing4.html">/ComponentIncludes/ImageCodec.k.h</option>
<option value="listing5.html">/ComponentIncludes/ImageCompression.k.h</option>
<option value="listing6.html">/ComponentIncludes/QuickTimeComponents.k.h</option>
<option value="listing7.html">/Effect.r</option>
<option value="listing8.html">/EffectDefinitions.h</option>
<option value="listing9.html">/EffectDispatch.h</option>
<option value="listing10.html">/EffectRezPB.r</option>
<option value="listing11.html">/GreyscaleEffect.c</option>
<option value="listing12.html">/PrefixIncludes/PrefixCarbon.h</option>
<option value="listing13.html">/PrefixIncludes/PrefixCarbonCFM.r</option>
<option value="listing14.html">/PrefixIncludes/PrefixCarbonMachO.r</option>
<option value="listing15.html">/PrefixIncludes/PrefixPPC.h</option>
<option value="listing16.html">/PrefixIncludes/PrefixPPC.r</option>
<option value="listing17.html">/README.txt</option></select>
				</p>
				</form>
				<p><strong><a href="GreyscaleEffectSample.zip">Download Sample</a></strong> (&#147;GreyscaleEffectSample.zip&#148;, 458.7K)<BR>
<strong><a href="GreyscaleEffectSample.dmg">Download Sample</a></strong> (&#147;GreyscaleEffectSample.dmg&#148;, 803.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    GreyscaleEffect.c    Description: Sample QuickTime effect component   Author:    era  Copyright:   &copy; Copyright 2002 Apple Computer, Inc. All rights reserved.    Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          Change History (most recent first):     &lt;1&gt;     05/18/02  era    first file*//*  Greyscale Filter Effect - a sample QuickTime video effect.    This effect uses a single source as input, and renders that source in  greyscale. It also allows for a brightness value which can range from  -100...0...100. A value of 0 signifies no change in brightness.    This is a very basic sample and a good place to start if you've never looked at  QuickTime effect code before.    This sample makes use of some code from the Dimmer2 Effect Framework. While Dimmer2 is  a recommended companion to this sample, it is more complex, using multiple sources,  multiple pixel formats, non-Macintosh support, tweens etc.    For developers who have asked for a quick and dirty single source filter sample, this one's  for you...enjoy.*/// --------------------------------------------------------------------------------------// INCLUDES// --------------------------------------------------------------------------------------#if (__APPLE_CC__ || __MACH__)    #include &lt;Carbon/Carbon.h&gt;    #include &lt;QuickTime/QuickTime.h&gt;#elif TARGET_API_MAC_CARBON  #include &lt;Carbon.h&gt;  #include &lt;QuickTime.h&gt;#else    #include &lt;ConditionalMacros.h&gt;  #include &lt;ImageCodec.h&gt;  #include &lt;QuickDraw.h&gt;#endif#include &quot;EffectDefinitions.h&quot;// --------------------------------------------------------------------------------------// INTERNAL TYPEDEFS// --------------------------------------------------------------------------------------// Structure used to store information about the sourcetypedef struct {              CDSequenceDataSourcePtr  src;  void          *srcBaseAddr;  long          srcRowBytes;} SourceRecord;// This is the structure used to store information for drawing a single frame of the effecttypedef struct {                SourceRecord source;        // inputs  void     *dstBaseAddr;      // output base address  long     dstRowBytes;      // output row bytes  long     height;        // output height  long     width;          // output width  OSType     dstPixelFormat;    // output pixel format  long     brightValue;      // brightness value, from -100 to 100} BlitGlobals;// global data per instance. This holds data for the entire effect as it runs its course.typedef struct {  ComponentInstance  self;    // us  ComponentInstance  target;    // top of the calling chain  ComponentInstance  delegate;  // if we can't handle an effect, this one can    BlitGlobals      blitter;  // information for drawing the data  OSType        **wantedDestinationPixelTypeH;    // parameter/source/dest seed tracking  long        initialized;  long        frameNumber;        long        virtualDuration;  long        majorSourceChangeSeed;} EffectGlobals;// --------------------------------------------------------------------------------------// DISPATCHER// --------------------------------------------------------------------------------------/************************************************************************************  *  This is the main dispatcher for our codec. All calls from the codec manager *  will come through here, with a unique selector and corresponding parameter block. * *  This routine must be first in the code segment of the codec component. * *  We use the normal dispatcher rather than the codec dispatcher as we need to *  implement the extra effects routines on top of the codec ones. *//************************************************************************************/// Begin Dispatch Stuff// Used by Component Dispatch Helper to call our routines#define CALLCOMPONENT_BASENAME()    GreyscaleFilter#define  CALLCOMPONENT_GLOBALS()      EffectGlobals * storage// Used by Type's .k.h to create prototypes for our routines#define  IMAGECODEC_BASENAME()      CALLCOMPONENT_BASENAME()#define  IMAGECODEC_GLOBALS()      CALLCOMPONENT_GLOBALS()// Used by SubType's .k.h to create prototypes for our routines#define  IMAGECODECEFFECT_BASENAME()    CALLCOMPONENT_BASENAME()#define  IMAGECODECEFFECT_GLOBALS()    CALLCOMPONENT_GLOBALS()// Other defines for Component Dispatch Helper#define COMPONENT_DISPATCH_FILE      &quot;EffectDispatch.h&quot;  // describes what to dispatch#define  GET_DELEGATE_COMPONENT()    (storage-&gt;delegate)  // how to find delegate component#define COMPONENT_UPP_SELECT_ROOT()    ImageCodec      // root for Type's UPP_PREFIX and SELECT_PREFIX    #include &quot;Components.k.h&quot;        // StdComponent's .k.h#include &quot;ImageCodec.k.h&quot;        // Type's .k.h#include &quot;ComponentDispatchHelper.c&quot;  // make our dispatcher and cando// End Dispatch Stuff/************************************************************************************/// --------------------------------------------------------------------------------------// EFFECT CODE - This is a &quot;basic&quot; sample so we only support one pixel format//         k32ARGBPixelFormat 32 bit argb (Mac). See Dimmer2 Effect for a more//         complete cross platform implementation.// --------------------------------------------------------------------------------------// --------------------------------------------------------------------------------------// INTERNAL ROUTINES// --------------------------------------------------------------------------------------#define Get32(x)   (*(long*)(x))#define Set32(x,y) (*(long*)(x)) = ((long)(y))// There are two versions of the EffectFilter32 function (the actual blitter code), they// do the exact same thing but the second one was happily optimized by geowar for fun.// Note, this code is intended as an example, yours will hopefully be cooler, faster, more bionic#define OPTIMIZED 1#if !OPTIMIZED// Code that draws our actual effect.static void EffectFilter32(BlitGlobals *glob){  long height  = glob-&gt;height;  long *src    = glob-&gt;source.srcBaseAddr;  long *dst    = glob-&gt;dstBaseAddr;  long srcBump = glob-&gt;source.srcRowBytes - (glob-&gt;width * 4);  long dstBump = glob-&gt;dstRowBytes - (glob-&gt;width * 4);    while (height--)  {    long width = glob-&gt;width;        while (width--)    {      UInt32 thePixelValue;      UInt8  theGrayValue;      SInt16 adjust;            thePixelValue = Get32(src);      src++;            // Grey scale filter, each pixel has a value ranging from 0 (black) to 255 (white)      // The transformation is based on the equation:      //                 //    grey value = 0.299*r + 0.587*g + 0.114*b  (see [Russ95], pp. 39)      //      // r, g, b indicate the red, green, blue color values of a pixel in the original image          theGrayValue = (0.299 * ((thePixelValue &gt;&gt; 16) &amp; 0xff)) +               (0.587 * ((thePixelValue &gt;&gt; 8) &amp; 0xff)) +               (0.114 * ((thePixelValue &gt;&gt; 0) &amp; 0xff));            // figrue out the brightness adjustment             if (glob-&gt;brightValue &lt; 0 )        adjust = glob-&gt;brightValue * theGrayValue / 100;      else        adjust = glob-&gt;brightValue * (255 - theGrayValue) / 100;        theGrayValue += adjust;      thePixelValue = (0xff000000) | (theGrayValue &lt;&lt; 16) | (theGrayValue &lt;&lt; 8) | (theGrayValue &lt;&lt; 0); // alpha (opaque)            Set32(dst,thePixelValue);      dst++;    }        src = (void *)(((Ptr)src) + srcBump);    dst = (void *)(((Ptr)dst) + dstBump);  }}#else// Optimized code that draws our actual effect.static void EffectFilter32(BlitGlobals *glob){    long height  = glob-&gt;height;    long *src    = glob-&gt;source.srcBaseAddr;    long *dst    = glob-&gt;dstBaseAddr;    long srcBump = glob-&gt;source.srcRowBytes - (glob-&gt;width * 4);    long dstBump = glob-&gt;dstRowBytes - (glob-&gt;width * 4);    // pre-compute the adjustment factors and convert the number to a power of two so     // the shift operator can be used instead of a divide when applying the adustment    SInt32 thePixelValue;    UInt8  theGrayValue;    SInt32 posAdj = 0,         negAdj = 0;    long   theBrightValue = 128 * glob-&gt;brightValue / 100;  // do we have a pos or neg adjustment to make?  (theBrightValue &lt; 0) ? (negAdj = theBrightValue) : (posAdj = theBrightValue);    while (height--)    {        long width = glob-&gt;width;                while (width--)        {                        thePixelValue = Get32(src);            src++;                        // Grey scale filter, each pixel has a value ranging from 0 (black) to 255 (white)            // The transformation is based on the equation:            //                                 //        grey value = 0.299*r + 0.587*g + 0.114*b    (see [Russ95], pp. 39)            //            // r, g, b indicate the red, green, blue color values of a pixel in the original image      // Compare this code to the original implemtation above            // 1. conversion between ints and floats is slow - avoid by using int fractions      //    (299*r / 1000) + (587*g / 1000)+ (114*b/1000)      // 2. combine all the divides      //    (299*r + 587*g + 114*b) / 1000            // 3. convert weighting factors to power of two so a shift can be used instead of a divide            //    299 / 1000 == 306 / 1024 == 306 &gt;&gt; 10            //    587 / 1000 == 601 / 1024 == 601 &gt;&gt; 10            //    114 / 1000 == 114 / 1024 == 114 &gt;&gt; 10            // Zippy!            theGrayValue = ((306 * ((thePixelValue &gt;&gt; 16) &amp; 0xff)) +                            (601 * ((thePixelValue &gt;&gt;  8) &amp; 0xff)) +                            (117 * ((thePixelValue &gt;&gt;  0) &amp; 0xff))) &gt;&gt; 10;             // do the brightness adjustment            // the branch statement is eliminated and replaced with the positive and            // negative adjustment variables, one of which should be zero            // pre-converted power of two values so a shift can be used instead of a divide            theGrayValue += ((theGrayValue * negAdj) + ((255 - theGrayValue) * posAdj)) &gt;&gt; 7;                        // alpha (opaque)            thePixelValue = (0xff000000) | (theGrayValue &lt;&lt; 16) | (theGrayValue &lt;&lt; 8) | (theGrayValue &lt;&lt; 0);                        Set32(dst,thePixelValue);            dst++;        }        src = (void *)(((Ptr) src) + srcBump);        dst = (void *)(((Ptr) dst) + dstBump);    }}#endif // OPTIMIZED// BlitterRenderFrame// --------------------------------------------------------------------------------------static long BlitterRenderFrame(BlitGlobals *blitGlob) // input: our globals{    // convert data into base/size  if (blitGlob-&gt;source.src) {    blitGlob-&gt;source.srcBaseAddr = blitGlob-&gt;source.src-&gt;dataPtr;    blitGlob-&gt;source.srcRowBytes = blitGlob-&gt;source.src-&gt;dataSize / blitGlob-&gt;height;  }    // do the actual render  switch (blitGlob-&gt;dstPixelFormat) {    case k32ARGBPixelFormat:      EffectFilter32(blitGlob);      break;  }    return noErr;}// RequestImageFormat//    If the data is already in the requested height and depth, return.//  Otherwise, calls decompression to get it into the format we can handle// --------------------------------------------------------------------------------------static OSErr RequestImageFormat(EffectGlobals  *glob,     // input: globals for rendering                EffectSourcePtr source,   // input: source to potentially convert                short      width,    // input: desired width                short      height,    // input: desired height                OSType      pixelFormat)// input: desired pixel format (depth &amp; format){  CDSequenceDataSourcePtr  sourceData = source-&gt;source.image;  ImageDescriptionHandle  curDesc = (ImageDescriptionHandle)sourceData-&gt;dataDescription;  ImageDescriptionHandle  newDesc = NULL;  ImageDescriptionPtr    dp;  OSErr          err = noErr;  dp = *curDesc;  if ((source-&gt;effectType == kEffectRawSource) &amp;&amp; (((dp-&gt;cType == kRawCodecType) &amp;&amp; (dp-&gt;depth == (short)pixelFormat)) ||     (dp-&gt;cType == pixelFormat)) &amp;&amp; (dp-&gt;width == width) &amp;&amp; (dp-&gt;height == height))  {    /* already got what we need */    return noErr;  }  // otherwise, call the ICM to convert to desired data format  newDesc = (ImageDescriptionHandle)NewHandleClear(sizeof(ImageDescription));  err = MemError();  if (noErr == err) {    short pixelSize = QTGetPixelSize(pixelFormat);    dp = *newDesc;    dp-&gt;cType = pixelFormat;    dp-&gt;depth = pixelSize;    dp-&gt;width  = width;    dp-&gt;height = height;    dp-&gt;clutID = -1;        /* the source is a stacked effect - or one in a format we can't handle. */    /* pass it off to the Generic Effect to convert */    /* it to a normal source */    err = ImageCodecEffectConvertEffectSourceToFormat(glob-&gt;target, source, newDesc);    if (newDesc) {      DisposeHandle((Handle)newDesc);    }  }  return err;}#pragma mark-// --------------------------------------------------------------------------------------// COMPONENT ENTRY POINTS - Standard Component Calls// --------------------------------------------------------------------------------------// The number of supported pixel formats#define kNumPixelFormatsSupported 1/* -- This Effect Component uses the Generic Effect Component --  The Generic Effect Component is an Apple-supplied component  that makes it easier for developers to create new Effects.  This component implements many of the &quot;housekeeping&quot; functions  that all components must perform. In most cases, these default  implementations are appropriate for your effect, and you simply  delegate these functions to the generic effect component.*/// Component Open Request - Required// This is called once per instance of our component.  Allocate our storage at// this point.  If we have any shared storage, we would check here to make sure// it exists, else create it.// input/output: our globals// input: reference to ourselfpascal ComponentResult GreyscaleFilterOpen(EffectGlobals    *glob,                        ComponentInstance  self){  ComponentResult  result;    result = noErr;      // first, allocate our local storage  if ((glob = (EffectGlobals *)NewPtrClear(sizeof(EffectGlobals))) == NULL)  {    result = MemError();    goto bail;  }    SetComponentInstanceStorage(self, (Handle) glob);    // we are ourselves, and the current top of chain is us  glob-&gt;self = self;  glob-&gt;target = self;  glob-&gt;wantedDestinationPixelTypeH = (OSType **)NewHandleClear(sizeof(OSType) * (kNumPixelFormatsSupported + 1));    // open the generic effect, this will handle effects we can't handle ourselves  result = OpenADefaultComponent(decompressorComponentType, kEffectGenericType, &amp;glob-&gt;delegate);  if (result) goto bail;      // set up the target for the components below us  ComponentSetTarget(glob-&gt;delegate, self);bail:  return result;}// Component Close Request - Required// Called each time an instance of our component is going away.  Toss anything we allocated.// input: our globals// input: reference to ourselfpascal ComponentResult GreyscaleFilterClose(EffectGlobals    *glob,                          ComponentInstance self){#pragma unused (self)  if (glob)  {    CloseComponent(glob-&gt;delegate);    DisposeHandle((Handle)glob-&gt;wantedDestinationPixelTypeH);    DisposePtr((Ptr)glob);  }    return noErr;}// Component Target Request//     Allows another component to &quot;target&quot; you i.e., you call another component whenever// you would call yourself (as a result of your component being used by another component).// input: our globals// input: reference to new top of chainpascal ComponentResult GreyscaleFilterTarget(EffectGlobals     *glob,                         ComponentInstance target){  // remember who is top of chain  glob-&gt;target = target;    // and tell folks below us, too.  ComponentSetTarget(glob-&gt;delegate, target);    return noErr;}// Component Version Request - Required//     Called to obtain the version of our component.//  input: our globalspascal ComponentResult GreyscaleFilterVersion(EffectGlobals  *glob){#pragma unused (glob)    return kEffectVersion;}#pragma mark-// --------------------------------------------------------------------------------------// COMPONENT ENTRY POINTS - Image Codec Calls// --------------------------------------------------------------------------------------// ImageCodecGetCodecInfo//    Your component receives the ImageCodecGetCodecInfo request whenever an application calls the//   Image Compression Manager's GetCodecInfo function. Your component should return a formatted compressor//   information structure defining its capabilities.//   The info is stored as a resource in our component.////    input: our globals//    output: our codec info// ----------------------------------------------------------------------------------------pascal ComponentResult GreyscaleFilterGetCodecInfo(EffectGlobals *glob,                           CodecInfo   *info){  OSErr err = noErr;  if (info == NULL)  {    err = paramErr;  }  else  {    CodecInfo **tempCodecInfo;    err = GetComponentResource((Component) glob-&gt;self,                   codecInfoResourceType,                   kEffect_cdci_ResID,                   (Handle *)&amp;tempCodecInfo);    if (err == noErr)    {      *info = **tempCodecInfo;      DisposeHandle((Handle)tempCodecInfo);    }  }  return err;}// ImageCodecGetParameterListHandle//    Returns a parameter description atom container, as described in the QuickTime Effect Documentaion//   section &quot;Supplying Parameter Description Information&quot;.//  http://developer.apple.com/techpubs/quicktime/qtdevdocs/REF/refEffects.28.htm//   This function can use the GetComponentResource function to retrieve an 'atms' resource that stores this//  information if you have provided one in your component.////    input: our globals//     output: the parameter description for this effect// ----------------------------------------------------------------------------------------pascal ComponentResult GreyscaleFilterGetParameterListHandle(EffectGlobals *glob,                                 Handle       *theHandle){  OSErr err = noErr;    err = GetComponentResource((Component)glob-&gt;self,                 kEffectAtomsResType,                 kEffect_atms_ResID,                 theHandle);  return err;}#pragma mark-// --------------------------------------------------------------------------------------// COMPONENT ENTRY POINTS - Effect Codec Calls// --------------------------------------------------------------------------------------// ImageCodecEffectSetup//     Called once before a sequence of frames are rendered. This gives your effect the chance// to set up variables that will alter their value during the execution of a sequence of frames.// Your component should examine the capabilities field of the decompressParams data structure to// ensure that it can meet the requirements for executing this sequence. In particular, it should// check the bit depth and pixel format requirements of the sequence. If the sequence requires a// bit depth and pixel format combination that your component does not support, this function should// return the nearest supported combination in the decompressParams-&gt;capabilities field.// In this case, QuickTime will redirect all source and destination bitmaps through offscreen graphics// worlds that have the bit depth and pixel format characteristics that you specify.// //    input: our globals//     input: information about the thing being decompressed////  Return in p-&gt;capabilities anything in particular your effect requires, such as //  limitations on bitdepth.// --------------------------------------------------------------------------------------pascal long GreyscaleFilterEffectSetup(EffectGlobals     *glob,                      CodecDecompressParams *p){  CodecCapabilities   *capabilities = p-&gt;capabilities;  OSType         *formats = *glob-&gt;wantedDestinationPixelTypeH;  long        wantedPixelSize = capabilities-&gt;wantedPixelSize;  OSType        dstPixelFormat;  OSErr        err = noErr;    dstPixelFormat = GETPIXMAPPIXELFORMAT(&amp;p-&gt;dstPixMap);  switch (dstPixelFormat) {  case k32ARGBPixelFormat:  // we know how to do these pixel formats    *formats++ = dstPixelFormat;    break;  default:          // we really need this!    *formats++ = k32ARGBPixelFormat;    break;  }    // end of the format list  *formats++ = 0;    /* set up our blitter */  glob-&gt;blitter.width  = (*p-&gt;imageDescription)-&gt;width;  glob-&gt;blitter.height = (*p-&gt;imageDescription)-&gt;height;      capabilities-&gt;wantedPixelSize = 0;  p-&gt;wantedDestinationPixelTypes = glob-&gt;wantedDestinationPixelTypeH;  return err;}// ImageCodecEffectBegin//    This function is called immediately before your EffectRenderFrame function.//  The EffectBegin function should ensure that the information it holds about the current source//  and destination buffers and the parameter values for the effect are valid. If any of these have//  changed since the last call to EffectBegin, the new values should be read from the appropriate//  data structures. This function is guaranteed to be called synchronously. In particular, this means//  you can allocate and move memory, and can call functions that allocate or move memory.////     input: our globals//     input: info about frame being drawn//     input: info about this effect frame// --------------------------------------------------------------------------------------pascal long GreyscaleFilterEffectBegin(EffectGlobals     *glob,                      CodecDecompressParams *p,                      EffectsFrameParamsPtr effect){  EffectSourcePtr  source;  OSErr      err = noErr;  long      offsetH, offsetV;  // we don't async  effect-&gt;doAsync = false;  // Destination:  // has the destination changed?   if (p-&gt;conditionFlags &amp; (codecConditionNewClut+codecConditionFirstFrame+               codecConditionNewDepth+codecConditionNewDestination+               codecConditionNewTransform))  {    // this will make us re-scan the sources    glob-&gt;majorSourceChangeSeed = 0;    // this will make us re-read the parameter values    glob-&gt;frameNumber = 0;    // set up the blitter globals for the destination    glob-&gt;blitter.dstPixelFormat = GETPIXMAPPIXELFORMAT(&amp;p-&gt;dstPixMap);        // adjust the destination baseaddress to be at the beginning of the desired rect    offsetH = (p-&gt;dstRect.left - p-&gt;dstPixMap.bounds.left);    if (p-&gt;dstPixMap.pixelSize == 32) {      offsetH &lt;&lt;= 2;          /* 1 pixel = 4 bytes */    } else {      err = codecConditionErr;    /* a data format we can't handle */      goto bail;    }        offsetV = (p-&gt;dstRect.top - p-&gt;dstPixMap.bounds.top) * QTGetPixMapPtrRowBytes(&amp;p-&gt;dstPixMap);    glob-&gt;blitter.dstBaseAddr = p-&gt;dstPixMap.baseAddr + offsetH + offsetV;    glob-&gt;blitter.dstRowBytes = QTGetPixMapPtrRowBytes(&amp;p-&gt;dstPixMap);  }  // Source:  // if it's a new source make note of it!  if (p-&gt;majorSourceChangeSeed != glob-&gt;majorSourceChangeSeed)  {    // grab start of input chain for this effect    source = effect-&gt;source;    // set the blitters source    // if it's a source we can handle, save it away, if not bail    err = RequestImageFormat(glob, source, glob-&gt;blitter.width, glob-&gt;blitter.height, glob-&gt;blitter.dstPixelFormat);    if (noErr == err) {      glob-&gt;blitter.source.src = source-&gt;source.image;    } else {      glob-&gt;blitter.source.src = NULL;      goto bail;    }        glob-&gt;majorSourceChangeSeed = p-&gt;majorSourceChangeSeed;  }    // If this is a new frame, or the same frame with a new length, get rid of our old parameters    if ((effect-&gt;frameTime.frameNumber != glob-&gt;frameNumber) || (effect-&gt;frameTime.virtualDuration != glob-&gt;virtualDuration))  {    glob-&gt;initialized = false;    glob-&gt;frameNumber = effect-&gt;frameTime.frameNumber;    glob-&gt;virtualDuration = effect-&gt;frameTime.virtualDuration;  }  // Read in effect parameters  if (!glob-&gt;initialized)  {    Ptr       data = p-&gt;data;    QTAtom          atom;      QTAtomID        atomID = 1;      long            actSize;        // Find the 'bryt' atom      atom = QTFindChildByID((QTAtomContainer)&amp;data,                             kParentAtomIsContainer,                             kEffectBrightnessCtrlAtom, // The name of the parameter                             atomID,                  // The ID of the parameter                             NULL);      // Copy the parameter value from the atom      if (QTCopyAtomDataToPtr((QTAtomContainer)&amp;data,                              atom,                            false,                            sizeof(long),                            &amp;((glob-&gt;blitter).brightValue),                            &amp;actSize) != noErr)      {          // If the copy failed, use a default value for this parameter          (glob-&gt;blitter).brightValue = 0;      }    glob-&gt;initialized = true;  }    // this effect only needs to run when the sources actually change  p-&gt;needUpdateOnTimeChange   = false;  p-&gt;needUpdateOnSourceChange = true;  bail:  return err;}// ImageCodecEffectRenderFrame//    Called to render a frame. Because this function can be called asynchronously, it is not safe//  to perform operations that may move memory during this call. This function contains the implementation//  of your effect.////    input: our global//     input: effect frame to be rendered// --------------------------------------------------------------------------------------pascal long GreyscaleFilterEffectRenderFrame(EffectGlobals        *glob,                         EffectsFrameParamsPtr effect){#pragma unused (effect)  // render the frame  BlitterRenderFrame(&amp;glob-&gt;blitter);    return noErr;}// ImageCodecEffectGetSpeed//    Returns the approximate number of frames per second that your effect is capable of transforming.//  This function should return a Fixed value in pFPS , which represents the rendering speed in frames-per-second//  of the effect. If your effect can render in real time, it should return a value of effectIsRealtime.//  Otherwise, you should return an estimate of the number of frames your effect can render per second.//  Because rendering speeds are hardware-dependent, effect authors can choose to measure actual rendering//  speeds in this function. Alternatively, effect authors can choose to return a single value for all hardware//  configurations, estimating the value for a reference hardware platform.//  Apple recommends that the values returned are rounded down to the nearest common frames-per-second value,//  such as 15, 24 or 30.////    input: our globals//    input: the current parameter values for this effect//     output: a Fixed value that will contain the rendering speed of this effect on exit// ----------------------------------------------------------------------------------------pascal long GreyscaleFilterEffectGetSpeed(EffectGlobals * glob,                        QTAtomContainer parameters,                        Fixed *pFPS){#pragma unused (glob, parameters)  if (pFPS) *pFPS = Long2Fix(30);      return noErr;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GreyscaleEffectSample/listing11.html%3Fid%3DDTS10000828-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GreyscaleEffectSample/listing11.html%3Fid%3DDTS10000828-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GreyscaleEffectSample/listing11.html%3Fid%3DDTS10000828-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>