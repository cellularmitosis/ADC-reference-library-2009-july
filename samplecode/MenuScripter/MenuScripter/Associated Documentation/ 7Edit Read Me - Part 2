Complex SpecifiersSo far we have dealt only with simple specifiers. These specifiers have been formName, formAbsolutePosition and formPropertyID.Now it's time to get onto the complex specifiers. These are formRelativePosition, formTest, formRange and formWhose. Luckily the Object Support Library will handle the formWhose for you aslong as you install a compare procedure and a count procedure with the routine AESetObjectCallbacks(), these routines are needed by formTest anyway. More on that later, first we'll get formRelativePosition and formRange out of the way.formRelativeForm Example7Edit does not implement formRelativeForm for all text types, only cInsertionPoint. Feel free to implement cWord, cParagraph etc.tell application "7Edit"    make new text at insertion point before first word Â                     of document 1 with data "Start Here"end tellWe have seen how OSL and our code resolves up to the formRelativeForm specifier. In this case we'll get a TextToken descriptor for 'first word of document 1'. On further resolution TextElemFromTextAccessor()  calls TextFormRelativePosition() with the typeMyText descriptor.OSErr	TextFormRelativePosition(TextToken* containerToken,          AEDesc* selectionData, DescType wantClass, AEDesc* result){   // Declare local variables		  aTextToken.tokenWindow = containerToken->tokenWindow;  	switch (wantClass)	  {		    case cInsertionPoint:		      	err = GetEnumeratedFromDescriptor(selectionData, &aPosition);						   switch (aPosition)			   {         case kAEPrevious:				     case kAEBefore:				     case kAEBeginning:					       // No change to offset - just 0 length now					       // containerToken.tokenOffset =            // containerToken.tokenOffset;					       aTextToken.tokenOffset = containerToken->tokenOffset;					       aTextToken.tokenLength = 0;				    	break;							     case kAENext:				     case kAEAfter:				     case kAEEnd:				    	   aTextToken.tokenOffset = containerToken->tokenOffset +                                         containerToken->tokenLength;					       aTextToken.tokenLength = 0;				    	break;									     default:					       err = errAEIllegalIndex;      }   break;					 default:			   err = errAEWrongDataType;	// Could do cChar, cWordÉ but   }                                // this is only a sample	   if (noErr != err) goto done;   err = AECreateDesc(typeMyText, (Ptr)&aTextToken,                              sizeof(aTextToken), result);done:	  return(err);}The routine then creates a token of zero length (for an insertion point) at either end of the token depending on the type of formRelative position. Admittedly the other types of text such as cWord and cParagraph would be a little more tricky. If you want to do it have a look at some of the routines GetTextTokenObjectSpecifier() uses in 'SVAETextUtils.c'. Not only will you get a greater understanding of creating object specifiers, you'll also find some routines that would be fairly useful.formRange ExampleHandling formRange is not too complicated in 7Edit. Consider the following script:tell application "7Edit"    select text from character 12 thru character 18 Â                                   of document "Untitled"end tellThe object specifier for 'text from character 12 thru character 18 of document "Untitled"' can be diagramatically presented in the way below.ÊWhen we resolve this through the TextElemFromTextAccessor() the document is coerced to a TextToken descriptor as we've seen before. The routine TextFormRange() is then called through the switch statement.OSErr	TextFormRange(TextToken* containerToken, AEDesc* selectionData,                                  DescType wantClass, AEDesc* result){   // Declare local variables		 // coerce the selection data into an AERecord  	err = AECoerceDesc(selectionData, typeAERecord,                                      &selectionRecord);	  if (noErr != err) goto done;			     // get the start object as a text token this will reenter		     // TextElemFromTextAccessor() but as formAbsolutePosition via 		     // our installed coercion handler CoerceObjToAnything()		     // because the keyAERangeStart parameter is actually an object specifier.	  err = AEGetKeyPtr(&selectionRecord, keyAERangeStart, typeMyText,                               &returnedType, (Ptr)&startToken,                                 sizeof(startToken), &actualSize);   if (noErr != err) goto done;	       // now do the same for the stop object   err = AEGetKeyPtr(&selectionRecord, keyAERangeStop, typeMyText,                               &returnedType, (Ptr)&stopToken,                                 sizeof(stopToken), &actualSize);   if (noErr != err) goto done;	   if (containerToken->tokenWindow != startToken.tokenWindow			   || containerToken->tokenWindow != stopToken.tokenWindow)   {      err = errAECorruptData;		// or whatever      goto done;   }		   // Use startToken to create result descriptor   startToken.tokenLength = stopToken.tokenOffset +               stopToken.tokenLength - startToken.tokenOffset;														    err = AECreateDesc(typeMyText, (Ptr)&startToken,                              sizeof(startToken), result);done:	  // Clean up	  return(err);}The routine takes the two range descriptors which are of formAbsolutePosition, and resolves them into an internal representation i.e. TextToken's. It then creates a TextToken which begins at the starting token and goes to the end of the ending token.formTest ExampleAs stated before, you need to install a compare procedure and a count procedure to support formTest. This is well worth doing as it makes your application much more powerful in scripting terms. In the sample code we install these procdures in the InstallObjectCallbacks() routine which is in 'SVAECompare.c'.err = AESetObjectCallbacks(NewOSLCompareProc(MyCompareProc),                           NewOSLCountProc(MyCountProc),                           NULL, NULL, NULL, NULL, NULL);Here is an example script that uses these installed procedures:tell application "7Edit"    delete every word of document 1 whose length > 5end tellThe first thing that the OSL does in this script is to resolve 'document 1'. As we've seen before this gives us a WindowToken descriptor. The OSL then calls the count procedure to count all the words in a container which is our WindowToken descriptor.pascal OSErr MyCountProc(DescType desiredType,     DescType containerClass, const AEDesc *container, long* result){      // Declare local variables		   // Resolve an object specifier if necessary	   *result = -1;			// easily recognized illegal value		   switch (desiredType)   {      case cDocument:	    	case cWindow:         if ((containerClass == typeNull)            || (containerClass == cApplication))				        *result = CountWindows();			      else				        err = errAEWrongDataType;      break;			      case cChar:		    case cWord:		    case cParagraph:			      err = AECoerceDesc(&tempDesc, typeMyText, &aDesc);			      if (typeNull == aDesc.descriptorType)				        err = errAENoSuchObject;			      if (noErr != err) break;			         GetRawDataFromDescriptor(&aDesc, (Ptr)&aTextToken,                                 sizeof(aTextToken), &actualSize);			      err = CountTextElements(TEHandleFromTextToken(&aTextToken),                     aTextToken.tokenOffset, aTextToken.tokenLength,                                         desiredType, &shortResult);			      if (noErr != err) break;			      *result = shortResult;		    break;					    default:			      err = errAECantHandleClass;   }	done:   // Clean up			  return(err);}	// MyCountProcWe can see that the MyCountProc() then switches on the desired class to count, which in our case is cWord. Here our WindowToken descriptor gets coerced into a TextToken descriptor and the words in this are counted.The OSL then goes through each word by creating a formAbsolutePosition object specifier for each and passing this along with a descriptor of the comparator and the operator to compare to our compare procedure.pascal OSErr	MyCompareProc(DescType oper, const AEDesc* obj1,                               const AEDesc* obj2, Boolean* result){	  // Declare local variables		  err = ExtractData(obj1, &desc1);	  if (err != noErr) goto done;	     err = ExtractData(obj2, &desc2);	  if (err != noErr) goto done;	  // Make sure the 2 data types are the same	  if (desc1.descriptorType != desc2.descriptorType)	  {	    	err = AEDuplicateDesc(&desc2, &tempDesc);	    	if (err != noErr) goto done;		    err = AEDisposeDesc(&desc2);	     err = AECoerceDesc(&tempDesc, desc1.descriptorType, &desc2);		    if (err != noErr)   // If we can't coerce one way, try		    {                   // the opposite way.                          // We disposed of desc2			       err = AEDuplicateDesc(&tempDesc, &desc2);		       	err = AEDisposeDesc(&tempDesc);		       	err = AEDuplicateDesc(&desc1, &tempDesc);	       		if (err != noErr) goto done;		       	err = AEDisposeDesc(&desc1);		       	err = AECoerceDesc(&tempDesc, desc2.descriptorType, &desc1);		       	if (err != noErr) goto done;		    }   }	   // Now that we know that the 2 types are the same,   // go ahead and run the compare   switch(desc1.descriptorType)   {		    case typeChar:         err = MyCompareText(oper, &desc1, &desc2, result);			   break;				    case typeShortInteger:		    case typeLongInteger:		      	err = MyCompareInteger(oper, &desc1, &desc2, result);			   break;      case typeBoolean:         err = MyCompareBoolean(oper, &desc1, &desc2, result);      break;						    default:      err = errAEWrongDataType;   }	done:   // Clean up	   return(err);}The MyCompareProc() then calls ExtractData() on both descriptors to get them into a form which can be compared.OSErr	ExtractData(const AEDesc *sourceDesc, AEDesc *theData){   // Declare local variables		  // This routine can receive: An Object specifier,   // an object token, a property token, or	  // some data (TEXT, Rectangle, etc.). It needs to   // convert whatever it's handed into data	  // and return that.	  	// If we don't have any data, complain  	if (sourceDesc->descriptorType == typeNull                 || sourceDesc->dataHandle == NULL)		    return(errAENoSuchObject);		  // If it's an object specifier, resolve into a token	  if (sourceDesc->descriptorType == typeObjectSpecifier)	    	err = AEResolve(sourceDesc, kAEIDoMinimum, &intermediateDesc);	  else	// Otherwise, just copy it		    err = AEDuplicateDesc(sourceDesc, &intermediateDesc);	  if (err != noErr) goto done;		  // Now that we have a token, read from it	  switch (intermediateDesc.descriptorType)	  {      case typeMyApplProp:		    case typeMyTextProp:		    case typeMyWindowProp:		    case typeMyText:			      err = HandleGetData(&intermediateDesc, theData);			   break;		    default:		      	// This is probably raw data , so pass it back up the line			      err = AEDuplicateDesc(&intermediateDesc, theData);   }done:   // Clean up	  return(err);}ExtractData() resolves any object specifiers then uses HandleGetData(), which we saw before in the Get Data Example, to get a descriptor of the actual value. If the descriptor isn't of one of our token types then we assume that it's already a descriptor of an actual value. This will be the case for the comparison descriptor in our example. It will be a descriptor holding an integer of value 5.The OSL creates a list and adds the formAbsolutePosition object specifier of every word that MyCompareProcedure() returns true to. This list forms the result for our example script.RecordingOne of the useful things about AppleScript is the ability to record your actions. Applications like Script Editor can record the actions of your application by intercepting all the Apple Events sent to your application. This means that things like Cut and Paste from the Edit menu need to cause an Apple Event to be sent. These events need to be of a similar form to what AppleScript would send your application. This involves creating object specifiers for elements affected.Another example, let's go through what happens when we select Cut from the Edit menu.Cut is handled by the DoCommand() routine in 'SVEditMain.c'. This calls a routine in 'SVAERecording.c' called IssueCutCommand().void	IssueCutCommand(DPtr theDocument){			   DoEditCommand(theDocument, editCutCommand);}The main business is done in DoEditCommand().void	DoEditCommand(DPtr theDocument, editCommandType whatCommand){   // Declare local variables	   err = SendSelectionEvent(theDocument);	  if (noErr != err) goto done;		 // Now create and send the appropriate cut,   // copy, paste or clear AppleEvent	   switch (whatCommand)   {      case  editCutCommand:         theEventID = kAECut;			      theEventClass = kAEMiscStandards;			   break;			      case  editCopyCommand:			      theEventID = kAECopy;         theEventClass = kAEMiscStandards;      break;      case  editPasteCommand:         theEventID = kAEPaste;			      theEventClass = kAEMiscStandards;      break;      case  editClearCommand:			      theEventID = kAEDelete;			      theEventClass = kAECoreSuite;      break;   }		  err = MakeSelfAddress(&ourAddress);	  if (noErr != err) goto done;				  err = AECreateAppleEvent(theEventClass, theEventID,                     &ourAddress, 0, 0, &editCommandEvent);		  if (noErr != err) goto done;					 // and now Send the message	  err = AESend(&editCommandEvent, &ignoreReply, kAENoReply,                   kAEHighPriority, kAEDefaultTimeout, NULL, NULL);		done:   // Clean up} // DoEditCommandFirst of all we send off an event to say what the selection is.OSErr	SendSelectionEvent(DPtr docPtr){	  // Declare local variables	  err = MakeSelfAddress(&ourAddress);	  if (noErr != err) goto done;			 // Build an object to represent the      // current document's selection		 // MakeSelectedTextObj	  err = MakeSelectedTextObj(docPtr->theWindow,                              docPtr->theText, &textObj);	  if (noErr != err) goto done;		  err = AECreateAppleEvent(kAEMiscStandards, kAESelect,                             &ourAddress, 0, 0, &selectEvent);		  if (noErr != err) goto done;			 // add parameter	  err = AEPutParamDesc(&selectEvent, keyDirectObject, &textObj);	  if (noErr != err) goto done;							 // and now send the message	  err = AESend(&selectEvent, &ignoreReply, kAENoReply,             kAEHighPriority, kAEDefaultTimeout, NULL, NULL);	  if (noErr != err) goto done;done:		  // Clean up	  return(err);}SendSelectionEvent() gets an object specifier for the current selection and sticks this into a select event and sends it to itself. DoEditCommand() then creates a cut event and also sends it to itself.Drag Manager SupportMost of the code that deals with the Drag Manager is in 'SVDrag.c'.  Although Gestalt is used to check if the Drag Manager is available, a number of situations can occur that may cause the DragLib shared library to fail to load. Because we're weak linking to the library, we need to check we really have a connection to the shared library. This can be done quite simply by checking any symbol against the constant kUnresolvedSymbolAddress. The following code snippet shown this, and is done after Gestalt has been used in the CheckEnvironment routine.#if GENERATINGCFM   if ( gHasDragManager )      gHasDragManager = (InstallTrackingHandler != (void*) kUnresolvedSymbolAddress);#endifSo what can cause a shared library to fail to link? Well, the most common cause is a low memory situation. Even if the code is already loaded, a shared library may still allocate a new copy of its global data section.Everything else is fairly well known, but I'll point out a few things just in case. It's important to draw a caret at the insertion point when tracking a drag operation which includes text. It can be very confusing for the user if this is not implemented. Also, intelligent Cut and Paste applies equally well to drag and drop operation. Quite simply, this involves handling the spaces at each end of a text selection. See ÒInside Macintosh: More Macintosh ToolboxÓ, Chapter 2 ÒScrap ManagerÓ, Page 10 ÒIntelligent Cut and PasteÓ for more information. Something to watch out for is dropping text on the original selection. This can be easily overlooked, and usually results in an unpleasant user experience. You should not draw a caret over the original selection, and zoom the dragged text back to the selection if a drop occurs. Lastly, don't forget to delete the text selection if it's dragged to the Finder's Trash.QuickDraw GX Printing SupportWhat it does	-Initializes and disposes the GX Managers	-Modifies and handles changes to the file menu	-Adds a gxJob to a 7Edit document	-Loads and saves a flattened version of the gxJob to a file	-Implements GX page setup and Print dialogs	-Implements GX print loopIt achieves much of the above by using the techniques described in the article "Adding QuickDraw GX Printing to QuickDraw Applications" by Dave Hersey (see Develop #19). I'd suggest you have a read of this to get the full story.In addition, it shows how to:	-Duplicate a styled text edit record	-Print a styled text edit record  -Pass job information to windows using Apple EventsIt's not intended to be a definitive 'document' on how to implement these features, but illustrates one way of doing it.  Most of the code for the GX printing is in the file 'SVEditGXPrinting.c'.How the interesting stuff worksDuplicating a styled text edit recordThis is done by "DuplicateStyleTERec":    void DuplicateStyleTERec( TEHandle  hSourceTE,                              TEHandle *hDestTE,                              Rect     *destRect,                              GrafPtr   destPort )hSourceTE  Handle to a TERec which contains the text edit you want to copy.hDestTE    Handle returned containing the duplicated TERec.destRect   Rect which is used for the duplicates view and dest Rects. destPort   The port that the duplicated text edit will be in. The reason a port is passed is that you may wish to put the text edit in a different window.First we set up the port to "destPort", then we use "TEStyleNew" to create a new styled TERec.      GetPort(&oldPort);      SetPort(destPort);	      *hDestTE = TEStyleNew(destRect, destRect);Next we must preserve the selected range of the source text edit record and the set the range selection range to include the entirety of the text.      oldSelStart = (*hSourceTE)->selStart;      oldSelEnd   = (*hSourceTE)->selEnd;      TESetSelect(0,(*hSourceTE)->teLength, hSourceTE);Now we can use "GetStylScrap" to get the style of the current selection - which is now the whole text. This being done we can reset the selection range.      printerTextStyles = GetStylScrap(hSourceTE);      TESetSelect(oldSelStart, oldSelEnd, hSourceTE);"TEStyleInsert" is used to insert the text and acquired style from the source into the destination text edit (remembering to lock the source's text before trying to insert it).       HLock((Handle)((*hSourceTE)->hText));      TEStyleInsert ( (Ptr)*((*hSourceTE)->hText),                      (*hSourceTE)->teLength,                      printerTextStyles,                      *hDestTE);		      HUnlock((Handle)((*hSourceTE)->hText));How to print a styled text edit record with QuickDraw GXThis is done in the function "GXPrintLoop". It uses a modified version of the print loop from Develop 19.  It creates a invisible window to draw the text edit record into. This is because "TEUpdate" is used to do the drawing and it will not only draw into the printer port, but will also draw in it's own port. Therefore we need to create an 'invisible' port to draw into. So we give the window an empty (0,0,0,0) rect for bounds and we set the visible flag to false.      imagingWind = NewWindow ( nil, &tempWindRect, "\p",                                false, documentProc,                                (WindowPtr)-1, false, 0);      SetPort((GrafPtr)imagingWind);Now we duplicate the Text Edit record in the document, to a temporary record. Then we use "GetPageEnds" to calculate how many pages are needed and where each page ends.      DuplicateStyleTERec( theDoc->theText, &tempTE, &printerPage, (GrafPtr)imagingWind );      GetPageEnds( printerPage.bottom-printerPage.top,                   tempTE,                   pageEnds,                   &numDocPages);Next it puts up the progress dialog then it steps through the pages. At each page, it  clips the text edit rec so it only draw lines of text on the page. It then uses TEUpdate to draw each page.      rectToClip = printerPage;      if (pageCounter == 1)        rectToClip.bottom = rectToClip.top + pageEnds[pageCounter-1];      else        rectToClip.bottom = rectToClip.top + pageEnds[pageCounter-1]                                           - pageEnds[pageCounter-2];      ClipRect(&rectToClip);      TEUpdate(&printerPage, tempTE);Now we can scroll the text edit rec ready for the next page.       if (pageCounter < lastPage)        TEScroll(0,rectToClip.top-rectToClip.bottom, tempTE);Once we've printed all the pages we finish the job and dispose of any structures we've created. 	How to pass job information to windows using Apple EventsThe GX printing code passes the job to and from the window using the Set/GetWindowProperty functions. It declares a new token property:      #define     pGXPageSetup    'TFGX'The GXJob is then passed in a flattened state using "GXFlattenJobToHdl()" to flatten it down to a handle, or "GXUnflattenJobFromHdl()" to extract it again.7Edit Background and Changes7Edit was originally written when the Object Support Library was still in it's early stages. This update hopefully makes the flow of events easier to follow, even if this means not doing things in the most clever way. Each Apple Event handler is now in it's own file, except for those in the Required Suite which are still in 'SVAppleEvents.c'. So if you want to look at the delete handler look in 'SVAEDelete.c'. The accessor routines have been moved into the 'SVAEAccessors.c' file and the coercion routines to 'SVAECoercions.c'. Alot of the extra routines that help the event handlers deal with windows and text have been moved to 'SVAEWindowUtils.c' and 'SVAETextUtils.c' respectively.Support for the Edition Manager has been taken out. The code had some bugs in it, and wasn't a major part of 7Edit. However, 7Edit now includes support for QuickDraw GX printing and the Drag Manager.We also removed and added items to make 7Edit closer to the Scriptable Text Editor. This included the line class which is in the Text Suite.AppleEvents and C++If you are thinking of writing a scriptable application it may be worth your while looking at Metrowerk's PowerPlant and the latest version of MacApp 3.3. Both of these frameworks support scripting.Known ProblemsYou may find that your machine will crash if you don't have a printer selected through the Chooser.Further Things That Could Be Done¥ Even though 7Edit supports drag and drop it is as yet unrecordable. This requires some thought because it has to be to handle dragging to and from other applications, including the Finder.¥ The Scriptable Text Editor allows you to specify text item delimiters. This allows you to say make the delimiter a fullstop hence giving the ability to pick up sentences.¥ 7Edit does not support the full Text Suite,  this could be done.¥ Tidying up more of the older code.The way we have implemented the scripting ability in 7Edit is not necessarily the best way. This example is here to give you an idea of what is needed to write a scriptable application. There are bound to be better ways, or ways that are more suited to your application.Happy scripting.Greg SuttonDeveloper Technical SupportNovember '95© 1995 by Apple Computer, Inc. All rights reserved.Referencesdevelop Issue 10  pg 8-32   'Apple Event Objects and You'develop Issue 21  pg 48-72 'Designing a Scripting Implementation'develop Issue 22  pg 81-82 'According to Script - Scripting Quandries'