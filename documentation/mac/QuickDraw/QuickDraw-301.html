<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of Graphics Devices (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING301></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-300.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-302.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-270.html"><B>Chapter 5 - Graphics Devices</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING301-0></A>
<H1>Summary of Graphics Devices</H1>
<A NAME=HEADING301-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING301-2></A>
<H3>Constants</H3>
<PRE>
CONST
   {flag bits for gdType field of GDevice record}
   clutType = 0;     {CLUT device--that is, one with colors mapped with a }
                     { color lookup table}
   fixedType = 1;    {fixed colors--that is, the color lookup table }
                     { can't be changed}
   directType = 2;   {direct RGB colors}
{flag bits for gdFlags field of GDevice record}
   gdDevType      = 0;  {if bit is set to 0, graphics device is black }
                        { and white; if bit is set to 1, graphics device }
                        { supports color}
   burstDevice    = 7;  {if bit is set to 1, graphics device supports block }
                        { transfer}
   ext32Device    = 8;  {if bit is set to 1, graphics device must be used }
                        { in 32-bit mode}
   ramInit        = 10; {if bit is set to 1, graphics device has been }
                        { initialized from RAM}
   mainScreen     = 11; {if bit is set to 1, graphics device is the main }
                        { screen}
   allInit        = 12; {if bit is set to 1, all graphics devices were }
                        { initialized from 'scrn' resource}
   screenDevice   = 13; {if bit is set to 1, graphics device is a screen}
   noDriver       = 14; {if bit is set to 1, GDevice record has no driver}
   screenActive   = 15; {if bit is set to 1, graphics device is current }
                        { device}
</PRE>
<A NAME=HEADING301-5></A>
<H3>Data Types</H3>
<PRE>
TYPE  
GDHandle    = ^GDPtr;
GDPtr       = ^GDevice;
GDevice     = 
RECORD
   gdRefNum:      Integer;       {reference number of screen driver}
   gdID:          Integer;       {reserved; set to 0}
   gdType:        Integer;       {type of device--indexed or direct}
   gdITable:      ITabHandle;    {handle to inverse table for Color Manager}
   gdResPref:     Integer;       {preferred resolution}
   gdSearchProc:  SProcHndl;     {handle to list of search functions}
   gdCompProc:    CProcHndl;     {handle to list of complement functions}
   gdFlags:       Integer;       {graphics device flags}
   gdPMap:        PixMapHandle;  {handle to PixMap record for displayed }
                                 { image}
   gdRefCon:      LongInt;       {reference value}
   gdNextGD:      GDHandle;      {handle to next graphics device}
   gdRect:        Rect;          {graphics device's boundary in global }
                                 { coordinates}
   gdMode:        LongInt;       {graphics device's current mode}
   gdCCBytes:     Integer;       {width of expanded cursor data}
   gdCCDepth:     Integer;       {depth of expanded cursor data}
   gdCCXData:     Handle;        {handle to cursor's expanded data}
   gdCCXMask:     Handle;        {handle to cursor's expanded mask}
   gdReserved:    LongInt;       {reserved for future use; must be 0}
END;
QDErr = Integer;
DeviceLoopDrawingProcPtr = ProcPtr;
DeviceLoopFlags = SET OF   {for flags parameter of DeviceLoop}
   (singleDevices,         {DeviceLoop doesn't group similar graphics }
                           { devices when calling drawing procedure}
   dontMatchSeeds,         {DeviceLoop doesn't consider ctSeed fields }
                           { of ColorTable records for graphics devices }
                           { when comparing them}
   allDevices);            {DeviceLoop ignores value of drawingRgn }
                           { parameter--instead, it calls drawing procedure }
                           { for every screen}
</PRE>
<A NAME=HEADING301-10></A>
<H3>Routines for Graphics Devices</H3>
<A NAME=HEADING301-11></A>
<H4>Creating, Setting, and Disposing of GDevice Records</H4>
<PRE>
{ DisposeGDevice is also spelled as DisposGDevice }
FUNCTION NewGDevice      (refNum: Integer; mode: LongInt): GDHandle;
PROCEDURE InitGDevice    (gdRefNum: Integer; mode: LongInt; 
                          gdh: GDHandle);
PROCEDURE SetDeviceAttribute
                         (gdh: GDHandle; attribute: Integer; 
                          value: Boolean);
PROCEDURE SetGDevice     (gdh: GDHandle);
PROCEDURE DisposeGDevice (gdh: GDHandle);
</PRE>
<A NAME=HEADING301-19></A>
<H4>Getting the Available Graphics Devices</H4>
<PRE>
FUNCTION GetGDevice      : GDHandle;
FUNCTION GetDeviceList   : GDHandle;
FUNCTION GetMainDevice   : GDHandle;
FUNCTION GetMaxDevice    (globalRect: Rect): GDHandle;
FUNCTION GetNextDevice   (curDevice: GDHandle): GDHandle;
</PRE>
<A NAME=HEADING301-25></A>
<H4>Determining the Characteristics of a Video Device</H4>
<PRE>
PROCEDURE DeviceLoop     (drawingRgn: RgnHandle; 
                          drawingProc: DeviceLoopDrawingProcPtr; 
                          userData: LongInt; flags: DeviceLoopFlags);
FUNCTION TestDeviceAttribute
                         (gdh: GDHandle; 
                          attribute: Integer): Boolean;
PROCEDURE ScreenRes      (VAR scrnHRes,scrnVRes: Integer);
</PRE>
<A NAME=HEADING301-30></A>
<H4>Changing the Pixel Depth for a Video Device</H4>
<PRE>
FUNCTION HasDepth        (aDevice: GDHandle; depth: Integer; 
                          whichFlags: Integer; flags: Integer): Integer;
FUNCTION SetDepth        (aDevice: GDHandle; depth: Integer; 
                          whichFlags: Integer; flags: Integer): OSErr;
</PRE>
<A NAME=HEADING301-33></A>
<H3>Application-Defined Routine</H3>
<PRE>
PROCEDURE MyDrawingProc  (depth: Integer; deviceFlags: Integer; 
                          targetDevice: GDHandle; userData: LongInt);
</PRE>
<A NAME=HEADING301-35></A>
<H2>C Summary</H2>
<A NAME=HEADING301-36></A>
<H3>Constants</H3>
<PRE>
enum {
   /* flag bits for gdType field of GDevice record */
   clutType       = 0;  /* CLUT device--that is, one with colors mapped with
                           a color lookup table */
   fixedType      = 1;  /* fixed colors--that is, the color lookup table 
                           can't be changed */
   directType     = 2;  /* direct RGB colors */
/* flag bits for gdFlags field of GDevice record */
   gdDevType      = 0,  /* if bit is set to 0, graphics device is black and
                           white; if set to 1, device is color */
   burstDevice    = 7,  /* if bit is set to 1, graphics device supports block 
                           transfer */
   ext32Device    = 8,  /* if bit is set to 1, graphics device must be used 
                           in 32-bit mode */
   ramInit        = 10, /* if bit is set to 1, graphics device was 
                           initialized from RAM */
   mainScreen     = 11, /* if bit is set to 1, graphics device is the main
                           screen */
   allInit        = 12, /* if bit is set to 1, all graphics devices were 
                           initialized from 'scrn' resource */
   screenDevice   = 13, /* if bit is set to 1, graphics device is a screen 
                           device */
   noDriver       = 14, /* if bit is set to 1, GDevice record has 
                           no driver */
   screenActive   = 15, /* if bit is set to 1, graphics device is current 
                           device */
};
</PRE>
<A NAME=HEADING301-39></A>
<H3>Data Types</H3>
<PRE>
struct GDevice {
   short          gdRefNum;      /* reference number of screen driver */
   short          gdID;          /* reserved; set to 0 */
   short          gdType;        /* type of device--indexed or direct */
   ITabHandle     gdITable;      /* handle to inverse table for Color  
                                    Manager */
   short          gdResPref;     /* preferred resolution */
   SProcHndl      gdSearchProc;  /* handle to list of search functions */
   CProcHndl      gdCompProc;    /* handle to list of complement functions */
   short          gdFlags;       /* graphics device flags */
   PixMapHandle   gdPMap;        /* handle to PixMap record for displayed  
                                    image */
   long           gdRefCon;      /* reference value */
   GDHandle       gdNextGD;      /* handle to next graphics device */
   Rect           gdRect;        /* graphics device's boundary in global 
                                    coordinates */
   long           gdMode;        /* graphics device's current mode */
   short          gdCCBytes;     /* width of expanded cursor data */
   short          gdCCDepth;     /* depth of expanded cursor data */
   Handle         gdCCXData;     /* handle to cursor's expanded data */
   Handle         gdCCXMask;     /* handle to cursor's expanded mask */
   long           gdReserved;    /* reserved for future use; must be 0 */
};
typedef struct GDevice GDevice;
typedef GDevice *GDPtr, **GDHandle;
typedef short QDErr;
typedef pascal void  (*DeviceLoopDrawingProcPtr)
                     (short depth, short deviceFlags, 
                      GDHandle targetDevice, long userData);
/* for flags parameter of DeviceLoop */
enum  {singleDevicesBit = 0,dontMatchSeedsBit = 1,allDevicesBit = 2};
enum  {singleDevices = 1 &lt;&lt; singleDevicesBit,   /* DeviceLoop doesn't group
                                                   similar graphics devices
                                                   when calling drawing
                                                   procedure */
      dontMatchSeeds = 1 &lt;&lt; dontMatchSeedsBit,  /* DeviceLoop doesn't 
                                                   consider ctSeed fields of 
                                                   ColorTable records for
                                                   graphics devices when 
                                                   comparing them */
      allDevices = 1 &lt;&lt; allDevicesBit};         /* DeviceLoop ignores value 
                                                   of drawingRgn parameter--
                                                   instead it calls drawing
                                                   procedure for every 
                                                   screen */
typedef unsigned long DeviceLoopFlags;
</PRE>
<A NAME=HEADING301-45></A>
<H3>Functions for Graphics Devices</H3>
<A NAME=HEADING301-46></A>
<H4>Creating, Setting, and Disposing of GDevice Records</H4>
<PRE>
/* DisposeGDevice is also spelled as DisposGDevice */
pascal GDHandle NewGDevice     (short refNum, long mode); 
pascal void InitGDevice        (short gdRefNum, long mode, GDHandle gdh); 
pascal void SetDeviceAttribute
                               (GDHandle gdh, short attribute, Boolean value); 
pascal void SetGDevice         (GDHandle gdh); 
pascal void DisposeGDevice     (GDHandle gdh); 
</PRE>
<A NAME=HEADING301-54></A>
<H4>Getting the Available Graphics Devices</H4>
<PRE>
pascal GDHandle GetGDevice     (void); 
pascal GDHandle GetDeviceList
                               (void); 
pascal GDHandle GetMainDevice
                               (void); 
pascal GDHandle GetMaxDevice
                               (const Rect *globalRect); 
pascal GDHandle GetNextDevice
                               (GDHandle curDevice); 
</PRE>
<A NAME=HEADING301-64></A>
<H4>Determining the Characteristics of a Video Device</H4>
<PRE>
pascal void DeviceLoop         (RgnHandle drawingRgn, 
                                DeviceLoopDrawingProcPtr drawingProc, 
                                long userData, DeviceLoopFlags flags);
pascal Boolean TestDeviceAttribute
                               (GDHandle gdh, short attribute);
pascal void ScreenRes          (short *scrnHRes, short *scrnVRes);
</PRE>
<A NAME=HEADING301-69></A>
<H4>Changing the Pixel Depth for a Video Device</H4>
<PRE>
pascal Integer HasDepth        (GDHandle aDevice, Integer depth, 
                                Integer whichFlags, Integer flags);
pascal OSErr SetDepth          (GDHandle aDevice, Integer depth, 
                                Integer whichFlags, Integer flags);
</PRE>
<A NAME=HEADING301-72></A>
<H3>Application-Defined Function</H3>
<PRE>
pascal void MyDrawingProc      (Integer depth, Integer deviceFlags, 
                                GDHandle targetDevice, LongInt userData);
</PRE>
<A NAME=HEADING301-74></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING301-75></A>
<H3>Data Structure</H3>
<A NAME=HEADING301-76></A>
<H4>GDevice Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>gdRefNum<TD>word<TD><CODE>refNum</CODE> of screen driver<TR>
<TD>2<TD>gdID<TD>word<TD>reserved; set to 0<TR>
<TD>4<TD>gdType<TD>word<TD>general type of graphics device<TR>
<TD>6<TD>gdITable<TD>long<TD>handle to inverse table<TR>
<TD>10<TD>gdResPref<TD>word<TD>preferred resolution for inverse tables<TR>
<TD>12<TD>gdSearchProc<TD>long<TD>search function pointer<TR>
<TD>16<TD>gdCompProc<TD>long<TD>complement function pointer<TR>
<TD>20<TD>gdFlags<TD>word<TD>graphics device flags word<TR>
<TD>22<TD>gdPMap<TD>long<TD>handle to pixel map describing graphics device<TR>
<TD>26<TD>gdRefCon<TD>long<TD>reference value<TR>
<TD>30<TD>gdNextGD<TD>long<TD>handle to next <CODE>GDevice record</CODE><TR>
<TD>34<TD>gdRect<TD>8 bytes<TD>graphics device's bounds in global coordinates<TR>
<TD>42<TD>gdMode<TD>long<TD>device's current mode<TR>
<TD>46<TD>gdCCBytes<TD>word<TD>width of expanded cursor data<TR>
<TD>48<TD>gdCCDepth<TD>word<TD>depth of expanded cursor data<TR>
<TD>50<TD>gdCCXData<TD>long<TD>handle to cursor's expanded data<TR>
<TD>54<TD>gdCCXMask<TD>long<TD>handle to cursor's expanded mask<TR>
<TD>58<TD>gdReserved<TD>long<TD>reserved; must be 0</TABLE>
</H4>
<A NAME=HEADING301-77></A>
<H3>Global Variables
<TABLE BORDER="0" CELLPADDING=3><TD>DeviceList<TD>Handle to the first <CODE>GDevice</CODE> record in the device list.<TR>
<TD>MainDevice<TD>Handle to the <CODE>GDevice</CODE> record for the main screen.<TR>
<TD>ScrHRes<TD>The horizontal resolution, in pixels per inch, for the current device.<TR>
<TD>ScrVRes<TD>The vertical resolution, in pixels per inch, for the current device.<TR>
<TD>TheGDevice<TD>Handle to the <CODE>GDevice</CODE> record for the current device.</TABLE>
</H3>
<PRE>
<A NAME=MARKER-2-192></A>
</PRE>


</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-300.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-302.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
