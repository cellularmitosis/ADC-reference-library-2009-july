	//	//	from 'ADB Key Spy' ¥ Pete Gontier	//	Macintosh Developer Technical Support	//	©Ê1995,1996,1998 Apple Computer, Inc.	//	//	Changes:	//	//		when		who		what	//		--------------------------------------------------------------	//		01/11/96	PG		copied from another project,	//							merged with various parts of old	//							ADB Key Spy	//#ifndef __DEVICES__#	include <Devices.h>#endif#ifndef __A4STUFF__#	include <A4Stuff.h>#endif#ifndef __SETUPA4__#	include <SetUpA4.h>#endif#include "ADBKS Common.h"#include "ADBKS csCodes.h"static tKeyboardInfo	*gKeyboardInfoList;static unsigned long	gOpenCount;static pascal Boolean IsKeyDownAnywhere (unsigned char keyCode){	//	//	Walks list of patched keyboards searching for one with the key	//	corresponding to the specified virtual key code held down.	//	Note this routine inspects arrays of virtual key codes	//	which were built elsewhere.	//	if (keyCode <= kMaxKeyCode)	{		tKeyboardInfo *scan = gKeyboardInfoList;		while (scan)		{			if (scan->virtualKeyMap [keyCode] > 0)				return true;				scan = scan->next;		}	}	return false;}static pascal OSErr myOpen (ParmBlkPtr, DCtlPtr){	//	//	We maintain a count of the number of times we have been	//	opened so that on closure we can bitch if we're closed	//	too many times. This is just to be defensive. We don't	//	really care whether we are open or closed.	//	++gOpenCount;	return noErr;}static pascal OSErr myPrime (ParmBlkPtr, DCtlPtr){	//	//	Silently does nothing in case somebody foolish decides to call it.	//	return noErr;}static pascal OSErr myControl (CntrlParamPtr pbp, DCtlPtr){	//	//	Sets the (global) root of the list of patched keyboard records.	//	The list can only be set once to a non-nil value, presumably	//	by the extension which loaded this driver.	//	OSErr result = controlErr;	switch (pbp->csCode)	{		case kControlCode_SetKeyboardInfoList :#if PARANOID			if (!gKeyboardInfoList)			{#endif				gKeyboardInfoList = *((tKeyboardInfo **) (pbp->csParam));				result = noErr;#if PARANOID			}#endif			break;	}	return result;}static pascal OSErr myStatus (CntrlParamPtr pbp, DCtlPtr){	//	//	Driver-level interface to IsKeyDownAnywhere.	//	On input, the first byte of csParam should be the virtual key code.	//	On output, the first byte of csParam is a boolean describing	//	whether the key is being held down.	//	OSErr result = statusErr;	switch (pbp->csCode)	{		case kStatusCode_IsKeyDownAnywhere :			{				unsigned char *csParam = (unsigned char *) pbp->csParam;				*csParam = IsKeyDownAnywhere (*csParam);				result = noErr;			}			break;	}	return result;}static pascal OSErr myClose (ParmBlkPtr, DCtlPtr){	//	//	We maintain a count of the number of times we have been	//	opened so that on closure we can bitch if we're closed	//	too many times. This is just to be defensive. We don't	//	really care whether we are open or closed.	//	if (!gOpenCount)		DebugStr ("\pPlease close .adb_key_spy only as many times as you open it.");	else		--gOpenCount;	return noErr;}OSErr main (ParmBlkPtr paramBlock, DCtlPtr devCtlEnt, short dispatch){	//	//	This is just glue for the rest of the driver. Pathetic that	//	compilers must also provide glue which will only call this glue.	//	Oh well, the Device Manager works the way it works.	//	OSErr err = noErr;	long oldA4 = SetCurrentA4 ( );	RememberA4 ( );	switch(dispatch)	{		case 0: err = myOpen	(paramBlock, devCtlEnt);					break;		case 1: err = myPrime	(paramBlock, devCtlEnt);					break;		case 2:	err = myControl	(&(paramBlock->cntrlParam), devCtlEnt);		break;		case 3: err = myStatus	(&(paramBlock->cntrlParam), devCtlEnt);		break;		case 4: err = myClose	(paramBlock, devCtlEnt);					break;	}	SetA4 (oldA4);	return err;}