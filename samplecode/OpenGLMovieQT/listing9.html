<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OpenGLMovieQT - /Carbon SetupGL/Carbon_SetupDSp.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">OpenGLMovieQT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxGraphicsImaging-date.html" target="_blank">QuickTime > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OpenGLMovieQT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Carbon SetupGL/Carbon_SetupDSp.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Carbon Include.h</option>
<option value="listing2.html">/Carbon Resource.r</option>
<option value="listing3.html">/Carbon SetupGL/aglString/aglString.c</option>
<option value="listing4.html">/Carbon SetupGL/aglString/aglString.h</option>
<option value="listing5.html">/Carbon SetupGL/Carbon_Error_Handler.c</option>
<option value="listing6.html">/Carbon SetupGL/Carbon_Error_Handler.h</option>
<option value="listing7.html">/Carbon SetupGL/Carbon_Include.h</option>
<option value="listing8.html">/Carbon SetupGL/Carbon_Resource.r</option>
<option value="listing9.html">/Carbon SetupGL/Carbon_SetupDSp.c</option>
<option value="listing10.html">/Carbon SetupGL/Carbon_SetupDSp.h</option>
<option value="listing11.html">/Carbon SetupGL/Carbon_SetupGL.c</option>
<option value="listing12.html">/Carbon SetupGL/Carbon_SetupGL.h</option>
<option value="listing13.html">/Carbon SetupGL/Carbon_SetupGL_Test.c</option>
<option value="listing14.html">/OpenGL Movie Controls.c</option>
<option value="listing15.html">/OpenGL Movie Main.c</option>
<option value="listing16.html">/OpenGL Movie.c</option>
<option value="listing17.html">/OpenGLMovie.h</option></select>
				</p>
				</form>
				<p><strong><a href="OpenGLMovieQT.zip">Download Sample</a></strong> (&#147;OpenGLMovieQT.zip&#148;, 139.4K)<BR>
<strong><a href="OpenGLMovieQT.dmg">Download Sample</a></strong> (&#147;OpenGLMovieQT.dmg&#148;, 197.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    SetupDSp.c

  Contains:  Functions to enable building and destorying a DSp fullscreen context

  Written by:  Geoff Stahl (ggs)

  Copyright:  Copyright &copy; 1999 Apple Computer, Inc., All Rights Reserved

  Change History (most recent first):

         &lt;3&gt;     3/26/01    ggs     Add DSp version check and other items for full screen on X
         &lt;2&gt;     3/26/01    ggs     Add new DSp functinality for Mac OS X
         &lt;1&gt;     1/19/01    ggs     Initial re-add
         &lt;7&gt;     3/21/00    ggs     Added windowed mode and clean up various implementation details
         &lt;6&gt;     2/22/00    ggs     fix fades
         &lt;5&gt;     1/26/00    ggs     Add fade code back in, ensure NULL pointer/context checks are in
         &lt;4&gt;     1/24/00    ggs     add new disclaimer, protection from NULL dispose, better
                                    software renderer handling
         &lt;3&gt;    12/18/99    ggs     Fixed err use before init
         &lt;2&gt;    12/18/99    ggs     Fix headers
         &lt;1&gt;    11/28/99    ggs     Initial add.  Split of just DSp handling functions.  Added total
                                    device RAM checks, better step downs using actual supported
                                    resolutions. Need to add user verify for contexts that require
                                    it, integration of this in context step down, and a freq bit
                                    field.
         &lt;1&gt;    11/11/99    ggs     Initial Add

  Disclaimer:  You may incorporate this sample code into your applications without
        restriction, though the sample code has been provided &quot;AS IS&quot; and the
        responsibility for its operation is 100% yours.  However, what you are
        not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;
        after having made changes. If you're going to re-distribute the source,
        we require that you make it clear in the source that the code was
        descended from Apple Sample Code, but that you've made changes.
*/


// Usage notes: 
// kUseFades enables gamma fades for activates and deactivates
#define kUseFades

//kUseRAMCheck enables estimated video card RAM checks
#define kUseRAMCheck


// system includes ----------------------------------------------------------

#ifdef __APPLE_CC__
    #include &lt;Carbon/Carbon.h&gt;
#else
    #include &lt;events.h&gt;
    #include &lt;sound.h&gt;

    #include &lt;fp.h&gt;
#endif

#include &lt;string.h&gt;

// project includes ---------------------------------------------------------

#include &quot;Carbon_Error_Handler.h&quot;
#include &quot;Carbon_SetupDSp.h&quot;

// globals (internal/private) -----------------------------------------------

enum 
{ 
  kMaxNumRes = 64, // max number of resolution slots
  kMaxRefreshFreq = 75 
}; 

Boolean gDSpStarted = false; // will never be true unless DSp is installed and start succeeds
Boolean gNeedFade = false;

// prototypes (internal/private) --------------------------------------------

DSpContextReference * ReserveUnusedDevices (GDHandle hGD);
OSStatus FreeUnusedDevices (GDHandle hGD, DSpContextReference ** ppContextRefUnused);
void BuildResolutionList (GDHandle hGD, Point * pResList, SInt32 * pFreqList);
OSStatus DoDeviceRAMCheck (pstructGLInfo pcontextInfo, Point * pResList, SInt32 * pFreqList, GLint depthSizeSupport);
Boolean DoContextStepDown (pstructGLInfo pcontextInfo, DSpContextAttributes * pContextAttributes, Point * pResList, SInt32 * pFreqList);


// functions (internal/private) ---------------------------------------------

// ReserveUnusedDevices

// reserves contexts on unused devices to vprevent their selection by DSp, returns list of these devices

DSpContextReference * ReserveUnusedDevices (GDHandle hGD)
{
  DSpContextAttributes theContextAttributes;
  DSpContextReference * pContextRefUnused = NULL;
  GDHandle hDevice = DMGetFirstScreenDevice (true); // check number of screens
  DisplayIDType displayID = 0;
  short numDevices = 0, indexDevice = 0;
  
  do
  {
    numDevices++;
    hDevice = DMGetNextScreenDevice (hDevice, true);
  }
  while (hDevice);
  numDevices--; // only count unused screens
  if (numDevices)
  {
    pContextRefUnused = (DSpContextReference *) NewPtr ((long) sizeof (DSpContextReference) * numDevices);
    hDevice = DMGetFirstScreenDevice (true); // check number of screens
    do
    {
      if (hDevice != hGD)  // if this device is not the one the user chose
      {
        if (noErr == DSpReportError (DMGetDisplayIDByGDevice (hDevice, &amp;displayID, false)))
          if (noErr == DSpReportError (DSpGetFirstContext (displayID, &amp;pContextRefUnused [indexDevice]))) // get a context and
            if (noErr == DSpReportError (DSpContext_GetAttributes (pContextRefUnused [indexDevice], &amp;theContextAttributes))) // find attributes
              DSpReportError (DSpContext_Reserve (pContextRefUnused [indexDevice], &amp;theContextAttributes)); // reserve it
        indexDevice++;
      }
      hDevice = DMGetNextScreenDevice (hDevice, true);
    }
    while (hDevice);
  }
  return pContextRefUnused;
}

// --------------------------------------------------------------------------

// FreeUnusedDevices

// frees screen that were previously reserved to prevent selection

OSStatus FreeUnusedDevices (GDHandle hGD, DSpContextReference ** ppContextRefUnused)
{
  OSStatus err = noErr;
  GDHandle hDevice = DMGetFirstScreenDevice (true); // check number of screens
  short indexDevice = 0;

  do
  {
    if (hDevice != hGD)  // if this device is not the one the user chose
    {
      err = DSpContext_Release (*ppContextRefUnused [indexDevice]); // release it
      DSpReportError (err);
      indexDevice++;
    }
    hDevice = DMGetNextScreenDevice (hDevice, true);
  }
  while (hDevice);
  
  if (*ppContextRefUnused)
    DisposePtr ((Ptr) *ppContextRefUnused);
  *ppContextRefUnused = NULL;
  return err;
}

// --------------------------------------------------------------------------

// BuildResolutionList

// builds a list of supported resolutions and frequencies for GDevice

void BuildResolutionList (GDHandle hGD, Point * pResList, SInt32 * pFreqList)
{
  DSpContextAttributes theContextAttributes;
  DSpContextReference currContext;
  OSStatus err;
  DisplayIDType displayID = 0;
  short i;
  
  for (i = 0; i &lt; kMaxNumRes; i++)  // clear resolution list
  {
    pResList [i].h = 0x7FFF;
    pResList [i].v = 0x7FFF;
    pFreqList [i] = 0;      // some context require certain frequencies find highest for each (not higher than 85
  }

  err = DMGetDisplayIDByGDevice (hGD, &amp;displayID, true);
  if (noErr != err)
    ReportErrorNum (&quot;DMGetDisplayIDByGDevice error&quot;, err);
  else
  {
    if (noErr == DSpReportError (DSpGetFirstContext (displayID, &amp;currContext)))
      do
      {  
        // insertion sort into resolution list
        if (noErr == DSpReportError (DSpContext_GetAttributes (currContext, &amp;theContextAttributes)))
        {
          Point pntTemp;
          Boolean fDone = false;
          short i = 0;
          while ((i &lt; kMaxNumRes) &amp;&amp; (!fDone))
          {
            if ((theContextAttributes.displayWidth == pResList [i].h) &amp;&amp; (theContextAttributes.displayHeight == pResList [i].v)) //skip
            {
              if ((pFreqList [i] == 0) || ((theContextAttributes.frequency &lt;= (kMaxRefreshFreq &lt;&lt; 16)) &amp;&amp; (theContextAttributes.frequency &gt; pFreqList [i])))
                pFreqList [i] = theContextAttributes.frequency;
              break;
            }
            if (theContextAttributes.displayWidth * theContextAttributes.displayHeight &lt; pResList [i].h * pResList [i].v) //insert
            {
              pntTemp = pResList [i];
              pResList [i].h = (short) theContextAttributes.displayWidth;
              pResList [i].v = (short) theContextAttributes.displayHeight;
              pFreqList [i] = theContextAttributes.frequency;
              fDone = true;
            }
            i++;
          }
          // i points to next element to switch; finish array swaps (if 
          while ((i &lt; kMaxNumRes) &amp;&amp; (fDone))
          {
            Point pntSwitch = pResList [i];
            pResList [i++] = pntTemp;
            pntTemp = pntSwitch;
          }
        }
        err = DSpGetNextContext (currContext, &amp;currContext);
        if (noErr != err)
        {
          if (kDSpContextNotFoundErr != err) 
            DSpReportError (err);
          currContext = 0;  // ensure we drop out
        }
      } 
      while (currContext);
    else
      ReportErrorNum (&quot;DSpGetFirstContext error&quot;, err);
  }  
  // zeroize unused elements
  for (i = 0; i &lt; kMaxNumRes; i++)
    if ((pResList [i].h == 0x7FFF) || (pResList [i].v == 0x7FFF))
    {
      pResList [i].h = 0;
      pResList [i].v = 0;
    }
}

// --------------------------------------------------------------------------

// DoDeviceRAMCheck

// checks requested allocation against device RAM
// Note: may modify pcontextInfo
// this should be equal or less strigent than OpenGL actual allocation to avoid failing on valid drawables

OSStatus DoDeviceRAMCheck (pstructGLInfo pcontextInfo, Point * pResList, SInt32 * pFreqList, GLint depthSizeSupport)
{
  float frontBufferFactor = 1.0f, backBufferFactor = 0.0f; // amount of screen(front) or request(back) sized buffers required, in bytes
  Point pntFrontBuffer; // size of front buffer that wil be allocated
  short i, indexFrontBuffer; 
  OSStatus err = noErr;

  // must take into account the entire front buffer, so figure out what screen resolution we are really going to use
  // find front buffer for request
  i = 0;
  while (((pResList [i].h &lt; pcontextInfo-&gt;width) || (pResList [i].v &lt; pcontextInfo-&gt;height)) &amp;&amp;
       ((pResList [i].h != 0) || (pResList [i].v != 0)) &amp;&amp;
       (i &lt; kMaxNumRes))
    i++;
  // save front buffer sizes
  pntFrontBuffer.h = pResList [i].h;
  pntFrontBuffer.v = pResList [i].v;
  // if we have a valid frequnecy for the context set it (to ensure a good selection
  pcontextInfo-&gt;freq = pFreqList [i] &gt;&gt; 16;
  indexFrontBuffer = i;
  
  // front buffers required
  if (16 == pcontextInfo-&gt;pixelDepth)
    frontBufferFactor *= 2.0;
  else if (32 == pcontextInfo-&gt;pixelDepth)
    frontBufferFactor *= 4.0;
    
  // back buffers required  
  backBufferFactor = 0.0f;
  i = 0;
  while (64 &gt; i)
    if (AGL_DOUBLEBUFFER == pcontextInfo-&gt;aglAttributes[i++])
    {
      if (16 == pcontextInfo-&gt;pixelDepth)
        backBufferFactor = 2.0f;
      else if (32 == pcontextInfo-&gt;pixelDepth)
        backBufferFactor = 4.0f;
      break;
    }
  i = 0;
  while (64 &gt; i)
    if (AGL_DEPTH_SIZE == pcontextInfo-&gt;aglAttributes[i++])
    {
      long requestDepth = pcontextInfo-&gt;aglAttributes[i];
      GLint bit = 0x00000001;
      short currDepth = 0, prevDepth = 0;
//      if (depthSizeSupport)
//      {
      do
      {
        if (bit &amp; depthSizeSupport)  // if the card supports the depth
        {
          prevDepth = currDepth;
          switch (bit)
          {
            case AGL_1_BIT:
              currDepth = 1;
              break;
            case AGL_2_BIT:
              currDepth = 2;
              break;
            case AGL_3_BIT:
              currDepth = 3;
              break;
            case AGL_4_BIT:
              currDepth = 4;
              break;
            case AGL_5_BIT:
              currDepth = 5;
              break;
            case AGL_6_BIT:
              currDepth = 6;
              break;
            case AGL_8_BIT:
              currDepth = 8;
              break;
            case AGL_10_BIT:
              currDepth = 10;
              break;
            case AGL_12_BIT:
              currDepth = 12;
              break;
            case AGL_16_BIT:
              currDepth = 16;
              break;
            case AGL_24_BIT:
              currDepth = 24;
              break;
            case AGL_32_BIT:
              currDepth = 32;
              break;
            case AGL_48_BIT:
              currDepth = 48;
              break;
            case AGL_64_BIT:
              currDepth = 64;
              break;
            case AGL_96_BIT:
              currDepth = 96;
              break;
            case AGL_128_BIT:
              currDepth = 128;
              break;
          }
        }
        bit *= 2;
      } while (!((requestDepth &gt; prevDepth) &amp;&amp; (requestDepth &lt;= currDepth)) &amp;&amp; (bit &lt; AGL_128_BIT + 1));
//      }
//      else // no card depth support info
//        currDepth = requestDepth;  // we don't have card info thus assume we can support exact depth requested (may fail later but will always be equal or less stringent)
      if ((AGL_128_BIT &gt;= bit) &amp;&amp; (0 != currDepth))
        backBufferFactor += (float) currDepth / 8.0;
      break;
    }
    
  // What we now have:
  //  pcontextInfo-&gt;width, height: request width and height
  //  pResList: sorted list of resolutions supported on this display
  //  pntFrontBuffer : size of front buffer that will currently be allocated
  //  indexFrontBuffer: position in array of current front buffer request
  //  frontBufferFactor: number of screen resolution size buffers that will be needed
  //  backBufferFactor: number of request size buffers that will be needed
  
  // if we see zero VRAM here we must be looking at the software renderer thus this check is moot.
  if (pcontextInfo-&gt;VRAM == 0)
  {
    // no changes required
    return noErr;
  }
  
  
  // find a context size that can support our texture requirements in the current total VRAM
  if ((pcontextInfo-&gt;VRAM - pcontextInfo-&gt;textureRAM) &lt; (pntFrontBuffer.h * pntFrontBuffer.v * frontBufferFactor + 
                               pcontextInfo-&gt;width * pcontextInfo-&gt;height * backBufferFactor))
  {
    if (pcontextInfo-&gt;fDepthMust &amp;&amp; pcontextInfo-&gt;fSizeMust)
    {
      // cannot accomdate request
      ReportError (&quot;Not enough total VRAM for drawable and textures (depth buffer and pixel size must be as requested)&quot;);
      return err;
    }
    else if (pcontextInfo-&gt;fSizeMust) // if we can adjust the size, try adjusting the 
    {
      // try 16 bit if must size is true
      if ((pcontextInfo-&gt;pixelDepth &gt; 16) &amp;&amp;
        (pcontextInfo-&gt;VRAM - pcontextInfo-&gt;textureRAM) &gt; (pntFrontBuffer.h * pntFrontBuffer.v * frontBufferFactor / 2.0 + 
                                      pcontextInfo-&gt;width * pcontextInfo-&gt;height * (backBufferFactor - 2.0)))
        pcontextInfo-&gt;pixelDepth = 16;
      else
      {
        // cannot accomdate request
        ReportError (&quot;Not enough total VRAM for drawable and textures&quot;);
        return err;
      }
    }
    else // can adjust size and might be able to adjust depth
    {  // make drawable fit
      Boolean fFound = false;
      // see if we can just adjust the pixel depth
      if ((pcontextInfo-&gt;pixelDepth &gt; 16) &amp;&amp;  // if we are requesting 32 bit
        (!pcontextInfo-&gt;fDepthMust) &amp;&amp;     // if we can adjust the pixel depth
        (pcontextInfo-&gt;VRAM - pcontextInfo-&gt;textureRAM) &gt; (pntFrontBuffer.h * pntFrontBuffer.v * frontBufferFactor / 2.0 + 
                                      pcontextInfo-&gt;width * pcontextInfo-&gt;height * (backBufferFactor - 2.0)))
      {
        fFound = true;
        pcontextInfo-&gt;pixelDepth = 16;
      }
      else // pixel depth alone wont do it
      {
        i = (short) (indexFrontBuffer - 1);
        while (i &gt;= 0)
        {
          //
          if ((pcontextInfo-&gt;VRAM - pcontextInfo-&gt;textureRAM) &gt; (pResList [i].h * pResList [i].v * frontBufferFactor + 
                                          pResList [i].h * pResList [i].v * backBufferFactor))
          {
            fFound = true;
            pcontextInfo-&gt;width = pResList [i].h;
            pcontextInfo-&gt;height = pResList [i].v;
            pcontextInfo-&gt;freq = pFreqList [i] &gt;&gt; 16;
            break;
          }
          else if ((pcontextInfo-&gt;pixelDepth &gt; 16) &amp;&amp;  // if we are requesting 32 bit
               (!pcontextInfo-&gt;fDepthMust) &amp;&amp;   // if we can adjust the pixel depth
               (pcontextInfo-&gt;VRAM - pcontextInfo-&gt;textureRAM) &gt; (pResList [i].h * pResList [i].v * frontBufferFactor / 2.0 + 
                                        pResList [i].h * pResList [i].v * (backBufferFactor - 2.0)))
          {
            fFound = true;
            pcontextInfo-&gt;width = pResList [i].h;
            pcontextInfo-&gt;height = pResList [i].v;
            pcontextInfo-&gt;freq = pFreqList [i] &gt;&gt; 16;
            pcontextInfo-&gt;pixelDepth = 16;
            break;
          }
          i--;
        }
        // we tried the smallest screen size and still need to use less VRAM, adjust backbuffer to what is available
        if ((!fFound) &amp;&amp; (((pcontextInfo-&gt;VRAM - pcontextInfo-&gt;textureRAM) - pResList [0].h * pResList [0].v * frontBufferFactor) &gt; 0))
        {
          float factor;
          fFound = true;
          factor = (float) sqrt((float) (pcontextInfo-&gt;width * pcontextInfo-&gt;height * backBufferFactor) / 
                  (float) ((pcontextInfo-&gt;VRAM - pcontextInfo-&gt;textureRAM) - pResList [0].h * pResList [0].v * frontBufferFactor));
          pcontextInfo-&gt;width /= factor;
          pcontextInfo-&gt;height /= factor;
          pcontextInfo-&gt;freq = pFreqList [0] &gt;&gt; 16;
        }
      }
      if (!fFound)
      {
        // cannot accomdate request
        ReportError (&quot;Not enough total VRAM for drawable and textures&quot;);
        return err;
      }

    }
  }
  return noErr;
}

// --------------------------------------------------------------------------

// DoContextStepDown

// steps down through frequencies, depths and sizes to try to find a valid context
// bounded by flags for SizeMust and DepthMust
// Note: may modify pcontextInfo

Boolean DoContextStepDown (pstructGLInfo pcontextInfo, DSpContextAttributes * pContextAttributes, Point * pResList, SInt32 * pFreqList)
{
  // find current resolution
  short i = 0; 
  while (((pResList [i].h &lt;= pContextAttributes-&gt;displayWidth) || (pResList [i].v &lt;= pContextAttributes-&gt;displayHeight)) &amp;&amp; 
      ((pResList [i].h != 0) || (pResList [i].v != 0)) &amp;&amp;
      (i &lt; kMaxNumRes))
    i++;
  i--; // i points to index of current resolution
  
  if (pcontextInfo-&gt;fSizeMust) // adjust depth only
  {
    if (pcontextInfo-&gt;pixelDepth &gt; 16)  // also try pixel depth step down
    {
      pContextAttributes-&gt;displayBestDepth = 16;
      pContextAttributes-&gt;backBufferBestDepth = 16;
    }
    else
      return false; // no more options to try
  }
  else if (pcontextInfo-&gt;fDepthMust) // adjust size only
  {
    if (i &gt; 0)
    {
      i--; // i was pointing at current resolution, now it is pointing at new resolution to try
      // set new resolution
      pContextAttributes-&gt;displayWidth = pResList [i].h;
      pContextAttributes-&gt;displayHeight = pResList [i].v;
      pcontextInfo-&gt;freq = pFreqList [i] &gt;&gt; 16;
    }
    else
      return false;
  }
  else // adjust size and depth
  {
    if (pContextAttributes-&gt;displayBestDepth &gt; 16)
    {
      pContextAttributes-&gt;displayBestDepth = 16;
      pContextAttributes-&gt;backBufferBestDepth = 16;
    }
    else if (i &gt; 0)
    {
      i--; // i was pointing at current resolution, now it is pointing at new resolution to try
      // reset pixel depth
      pContextAttributes-&gt;displayBestDepth = pcontextInfo-&gt;pixelDepth;
      pContextAttributes-&gt;backBufferBestDepth = pcontextInfo-&gt;pixelDepth;
      // set new resolution
      pContextAttributes-&gt;displayWidth = pResList [i].h;
      pContextAttributes-&gt;displayHeight = pResList [i].v;
      pcontextInfo-&gt;freq = pFreqList [i] &gt;&gt; 16;
    }
    else
      return false;
      
  }
  return true;
}

#pragma mark -
// functions (public) -------------------------------------------------------

// GetDSpVersion

// Gets the current version of DSp

NumVersion GetDSpVersion (void)
{
  NumVersion versionDSp = { 0, 0, 0, 0 };
  OSStatus err = noErr;
  if (!gDSpStarted)
    err = StartDSp ();
  if (noErr == err)
    versionDSp = DSpGetVersion ();
  return versionDSp;    
}

// --------------------------------------------------------------------------

// StartDSp

// handles starting up DrawSprocket

OSStatus StartDSp (void)
{
  OSStatus err = noErr;
  if (!gDSpStarted)
  {
    // check for DSp
    if ((Ptr) kUnresolvedCFragSymbolAddress == (Ptr) DSpStartup) 
    {
      ReportError (&quot;DSp not installed&quot;);
      return kDSpNotInitializedErr;
    }  
    else
    {
      err = DSpReportError (DSpStartup()); // start DSp
      if (noErr != err)
        return err;
      else
        gDSpStarted = true;
    }
  }
  return err;    
}

// --------------------------------------------------------------------------

// ShutdownDSpContext

// shuts down DrawSprocket

void ShutdownDSp (void)
{
  if (gDSpStarted)
  {
    DSpShutdown ();
    gDSpStarted = false;
  }
}

#pragma mark -
// --------------------------------------------------------------------------

// GetDSpDrawable

// Just returns the front buffer

// Inputs:   *pdspContext
//      pcontextInfo: request and requirements for cotext and drawable

// Outputs: returns CGrafPtr thaat is front buffer of context

// if error: will return NULL

CGrafPtr GetDSpDrawable (DSpContextReference dspContext)
{
  CGrafPtr pCGraf = NULL;
  if (noErr == DSpReportError (DSpContext_GetFrontBuffer (dspContext, &amp;pCGraf)))
    return pCGraf;
  else
    return NULL;
}

// --------------------------------------------------------------------------

// BuildDSpContext

// contextInfo and tries to allocate the corresponding DSp context

// Inputs:   hGD: GDHandle to device to look at
//      pcontextInfo: request and requirements for cotext and drawable

// Outputs: *pdspContext as allocated
//      pcontextInfo:  allocated parameters

// if fail to allocate: pdspContext will be NULL
// if error: will return error pdspContext will be NULL

OSStatus BuildDSpContext (DSpContextReference* pdspContext, GDHandle hGD, GLint depthSizeSupport, pstructGLInfo pcontextInfo)
{
  DSpContextAttributes theContextAttributes, foundAttributes;
  DSpContextReference * pContextRefUnused;
  SInt32 aFreqList [kMaxNumRes];
  Point aResList [kMaxNumRes]; // list for resolution information
  OSStatus err = noErr;
  
  *pdspContext = 0;

  // check for DSp
  if (noErr != StartDSp ()) 
  {
    ReportError (&quot;DSp startup failed&quot;);
    return noErr; // already reported
  }
  
  // reserve contexts on other screens to prevent their selection
  pContextRefUnused = ReserveUnusedDevices (hGD);
  
  // build resolution list
  BuildResolutionList (hGD, aResList, aFreqList);
  
  // handle default pixel depths
  if (pcontextInfo-&gt;pixelDepth == 0)  // default
  {
    pcontextInfo-&gt;pixelDepth = (**(**hGD).gdPMap).pixelSize;
    if (pcontextInfo-&gt;pixelDepth &lt; 16)
      pcontextInfo-&gt;pixelDepth = 16;
  }

#ifdef kUseRAMCheck
  if (noErr != DoDeviceRAMCheck (pcontextInfo, aResList, aFreqList, depthSizeSupport))
    return err;
#endif // kUseRAMCheck

  // Note: DSp &lt; 1.7.3 REQUIRES the back buffer attributes even if only one buffer is required
  BlockZero (&amp;theContextAttributes, sizeof (DSpContextAttributes));
//  memset(&amp;theContextAttributes, 0, sizeof (DSpContextAttributes));
  theContextAttributes.displayWidth        = pcontextInfo-&gt;width;
  theContextAttributes.displayHeight        = pcontextInfo-&gt;height;
  theContextAttributes.displayBestDepth      = pcontextInfo-&gt;pixelDepth;
  theContextAttributes.backBufferBestDepth    = pcontextInfo-&gt;pixelDepth;
  do
  {  
    theContextAttributes.frequency        = pcontextInfo-&gt;freq * 0x10000;
    theContextAttributes.colorNeeds        = kDSpColorNeeds_Require;
    theContextAttributes.displayDepthMask    = kDSpDepthMask_All;
    theContextAttributes.backBufferDepthMask  = kDSpDepthMask_All;
    theContextAttributes.pageCount        = 1; // only the front buffer is needed
    err = DSpFindBestContext(&amp;theContextAttributes, pdspContext);
    if (noErr != err)  // if we had any errors, reset for next try
      if (!DoContextStepDown (pcontextInfo, &amp;theContextAttributes, aResList, aFreqList))
        break; // have run out of options
  } while (err == kDSpContextNotFoundErr);

  // check find best context errors
  if (kDSpContextNotFoundErr == err)
  {  
    *pdspContext = 0;
    return noErr;
  }
  else if (noErr != err)
  {
    DSpReportError (err);
    *pdspContext = 0;
    return err;
  }
  
  err = DSpReportError (DSpContext_GetAttributes (*pdspContext, &amp;foundAttributes));
  if (noErr != err)
  {
    *pdspContext = 0;
    return err;
  }
  // reset width and height to full screen and handle our own centering
  // HWA will not correctly center less than full screen size contexts
  theContextAttributes.displayWidth     = foundAttributes.displayWidth;
  theContextAttributes.displayHeight     = foundAttributes.displayHeight;
  theContextAttributes.pageCount      = 1; // only the front buffer is needed
  theContextAttributes.contextOptions    = 0 | kDSpContextOption_DontSyncVBL; // no page flipping and no VBL sync needed

  err = DSpReportError (DSpContext_Reserve(*pdspContext, &amp;theContextAttributes )); // reserve our context
  if (noErr != err)
  {
    *pdspContext = 0;
    return err;
  }
  if (gNeedFade == true)
  {
    DSpReportError (DSpContext_CustomFadeGammaOut (NULL, NULL, fadeTicks));
    gNeedFade = false;
  }
  err = DSpReportError (DSpContext_SetState (*pdspContext, kDSpContextState_Active)); // activate our context
  if (noErr != err)
  {
    DSpContext_Release (*pdspContext);
    DSpReportError (DSpContext_CustomFadeGammaIn (NULL, NULL, fadeTicks));
    *pdspContext = 0;
    return err;
  }

  FreeUnusedDevices (hGD, &amp;pContextRefUnused);
  
  if (!pcontextInfo-&gt;fSizeMust)  // if we got whatever was available
  {
    // reset inputs to what was allocated (constrain aspect ratio)
    // unless we ask for smaller, then leave the same
    if ((pcontextInfo-&gt;width &gt; foundAttributes.displayWidth) || (pcontextInfo-&gt;height &gt; foundAttributes.displayHeight))
    {
      float hFactor = (float) pcontextInfo-&gt;width / (float) foundAttributes.displayWidth;
      float vFactor = (float) pcontextInfo-&gt;height / (float) foundAttributes.displayHeight;
      if (hFactor &gt; vFactor)
      {
        pcontextInfo-&gt;width = (short) foundAttributes.displayWidth;
        pcontextInfo-&gt;height /= hFactor;  
      }
      else
      {
        pcontextInfo-&gt;height = (short) foundAttributes.displayHeight;
        pcontextInfo-&gt;width /= vFactor;  
      }
    }
  }
  // else still use inputs to allocate drawable
  
  pcontextInfo-&gt;freq = foundAttributes.frequency / 0x10000;
  pcontextInfo-&gt;pixelDepth = foundAttributes.displayBestDepth;

  return noErr;
}

//-----------------------------------------------------------------------------------------------------------------------

// Deactivates and dumps context

void DestroyDSpContext (DSpContextReference* pdspContext)
{
  if (gDSpStarted)
  {
    if (*pdspContext)
    {
      DSpReportError (DSpContext_SetState(*pdspContext, kDSpContextState_Inactive));
      DSpReportError (DSpContext_CustomFadeGammaIn (NULL, NULL, fadeTicks));
      DSpReportError (DSpContext_Release (*pdspContext));
      *pdspContext = NULL;
    }
  }
}


#pragma mark -
//-----------------------------------------------------------------------------------------------------------------------

OSStatus DSpContext_CustomFadeGammaIn (DSpContextReference inContext, const RGBColor *fadeColor,  long fadeTicks) 
{
  OSStatus err = noErr;
#ifndef kUseFades
  #pragma unused (inContext, fadeColor, fadeTicks)
#else
  RGBColor inZeroIntensityColor;
  UInt32 currTick;
  UInt16 step = (UInt16) (800 / fadeTicks);
  long x, percent = 0;

  if (gDSpStarted)
  {
    if (fadeTicks == 0)
      fadeTicks = 1;
    if (fadeColor == NULL) 
    {
      inZeroIntensityColor.red = 0x0000;
      inZeroIntensityColor.green = 0x0000;
      inZeroIntensityColor.blue = 0x0000;
    }
    else 
      inZeroIntensityColor = *fadeColor;
    currTick = TickCount ();
    for (x = 1; x &lt;= fadeTicks; x++) 
    {
      percent = step * x / 8;
      err = DSpContext_FadeGamma(inContext, percent, &amp;inZeroIntensityColor);
      if (err != noErr) 
        break;
      while (currTick &gt;= TickCount ()) {}
//        SystemTask ();
      currTick = TickCount ();
    }
    if (err == noErr)
      err = DSpContext_FadeGamma(inContext, 100, &amp;inZeroIntensityColor);
  }
#endif // kUseFades
  return err;
}

//-----------------------------------------------------------------------------------------------------------------------

OSStatus DSpContext_CustomFadeGammaOut (DSpContextReference inContext, const RGBColor *fadeColor, long fadeTicks ) 
{
  
  OSStatus err = noErr;
#ifndef kUseFades
  #pragma unused (inContext, fadeColor, fadeTicks)
#else
  RGBColor inZeroIntensityColor;
  UInt32 currTick;
  UInt16 step = (UInt16) (800 / fadeTicks);
  long x, percent = 0;

  if (gDSpStarted)
  {
    if (fadeTicks == 0)
      fadeTicks = 1;                // ensure we do not have zero fade time
    if (fadeColor == NULL) 
    {
      inZeroIntensityColor.red = 0x0000;
      inZeroIntensityColor.green = 0x0000;
      inZeroIntensityColor.blue = 0x0000;
    }
    else 
      inZeroIntensityColor = *fadeColor;
    currTick = TickCount ();
    for (x = fadeTicks - 1; x &gt;= 0; x--) 
    {
      percent = step * x / 8;
      err = DSpContext_FadeGamma(inContext, percent, &amp;inZeroIntensityColor);
      if (err != noErr) 
        break;
      while (currTick &gt;= TickCount ()) {}
//        SystemTask ();
      currTick = TickCount ();
    }
  }
#endif // kUseFades
  return err;
}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OpenGLMovieQT/listing9.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OpenGLMovieQT/listing9.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OpenGLMovieQT/listing9.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>