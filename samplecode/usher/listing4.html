<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>usher - /sources/MovieSourcing.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">usher</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">usher</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/sources/MovieSourcing.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/notes/usingusher.htm</option>
<option value="listing2.html">/sources/AppSupport.c</option>
<option value="listing3.html">/sources/AppSupport.h</option>
<option value="listing4.html">/sources/MovieSourcing.c</option>
<option value="listing5.html">/sources/MovieSourcing.h</option>
<option value="listing6.html">/sources/PresInfoWindow.c</option>
<option value="listing7.html">/sources/PresInfoWindow.h</option>
<option value="listing8.html">/sources/PresinfoWindow.r</option>
<option value="listing9.html">/sources/QTSSampleCodeUtils.c</option>
<option value="listing10.html">/sources/QTSSampleCodeUtils.h</option>
<option value="listing11.html">/sources/SimplePres.c</option>
<option value="listing12.html">/sources/SimplePres.h</option>
<option value="listing13.html">/sources/SourcingSupport.c</option>
<option value="listing14.html">/sources/SourcingSupport.h</option>
<option value="listing15.html">/sources/usher.r</option>
<option value="listing16.html">/sources/UsherBroadcast.c</option>
<option value="listing17.html">/sources/UsherBroadcast.h</option>
<option value="listing18.html">/sources/UsherCarbon.r</option>
<option value="listing19.html">/sources/UsherCommands.h</option>
<option value="listing20.html">/sources/UsherMinWindow.c</option>
<option value="listing21.html">/sources/UsherMinWindow.h</option>
<option value="listing22.html">/sources/UsherMinWindow.r</option>
<option value="listing23.html">/sources/UsherNew.c</option>
<option value="listing24.html">/sources/UsherNew.h</option>
<option value="listing25.html">/sources/usherRezDefines.h</option>
<option value="listing26.html">/sources/WindowSupport.c</option>
<option value="listing27.html">/sources/WindowSupport.h</option>
<option value="listing28.html">/UsherReleaseNotes.txt</option></select>
				</p>
				</form>
				<p><strong><a href="usher.zip">Download Sample</a></strong> (&#147;usher.zip&#148;, 212.3K)<BR>
<strong><a href="usher.dmg">Download Sample</a></strong> (&#147;usher.dmg&#148;, 293.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MovieSourcing.c  Copyright:  &copy; 2000-2001 by Apple Computer, Inc., all rights reserved.*/#include &lt;ConditionalMacros.h&gt;#include &lt;string.h&gt;#include &lt;QuickTimeStreaming.h&gt;#include &lt;QTStreamingComponents.h&gt;#include &quot;AppSupport.h&quot;#include &quot;MovieSourcing.h&quot;#include &quot;QTSSampleCodeUtils.h&quot;#include &quot;UsherCommands.h&quot;  // ---------------------------------------------------------------------------//    D E F I N I T I O N S// ---------------------------------------------------------------------------// ---------------------------------------------------------------------------//    P R O T O T Y P E S// ---------------------------------------------------------------------------static OSErr MovieSourcing_GetNextMovie(MovieSourcing *inHandler);// flags for MovieSourcing_CloseCurrentMovieenum  {  kStoredMovieSupportCloseFlag_DontTellSourcers  = 0x00000001};static void MovieSourcing_CloseCurrentMovie(MovieSourcing *inHandler, SInt32 inFlags);static OSErr MovieSourcing_SourcerDone(MovieSourcing *inHandler,          QTSSourcerDoneParams *inParams, Boolean *outSendChangedMessage);static OSErr MovieSourcing_SkipToNext(MovieSourcing *inHandler);static OSErr MovieSourcing_SetupTrackSourcerForStream(MovieSourcing *inHandler, QTSStream inStream);static OSErr MovieSourcing_SetupNextMovie(MovieSourcing *inHandler);static Boolean MovieSourcing_FindAndSetupSourcer(MovieSourcing *inHandler,            Track inTrack, OSType inTrackType);static pascal ComponentResult MovieSourcing_CallbackProc(ComponentResult inErr,        OSType inSelector, void *ioParams, void *inRefCon);QTSNotificationUPP gMovieSourcingCallbackUPP = NULL;// ---------------------------------------------------------------------------//    MovieSourcing_New// ---------------------------------------------------------------------------OSErr MovieSourcing_New(QTSPresentation inPresentation, SourceMediaParams *inSourceMediaParams,        MovieSourcingSettings *inSettingsStuff, MovieSourcing **outHandler){#pragma unused(inSourceMediaParams)  OSErr      err = noErr;  MovieSourcing  *handler = NULL;  UInt32      numStreams;  UInt32      i;  QTSStream    stream;  UInt32      numSources;  *outHandler = NULL;  handler = (MovieSourcing*)QTSNewPtrClear(sizeof(MovieSourcing));  EXITIFERR( err = MemError() );  handler-&gt;standard.signature = kSignature_MovieSourcing;  handler-&gt;standard.standardSignature = kSignature_StandardSourceHandler;  handler-&gt;presentation = inPresentation;  if (inSettingsStuff != NULL)  {    CInfoPBRec    pb;    FSSpec      folderSpec;        memset(&amp;pb, 0, sizeof(pb));    handler-&gt;loop = inSettingsStuff-&gt;loop;    handler-&gt;selectRandomly = inSettingsStuff-&gt;selectRandomly;    if (inSettingsStuff-&gt;haveFileSpec)  {      BlockMoveData(&amp;inSettingsStuff-&gt;spec, &amp;handler-&gt;currentMovieSpec, sizeof(FSSpec));      handler-&gt;currentFileIndex = kMovieSourcingUseOneFixedFile;    }  else  {      if (inSettingsStuff-&gt;haveFolderSpec)  {        BlockMoveData(&amp;inSettingsStuff-&gt;spec, &amp;folderSpec, sizeof(FSSpec));      }  else  {#define kMovieFolderName    &quot;\pmovies&quot;              err = GetAppRelativeFolderSpec(kMovieFolderName, &amp;folderSpec);        if (err != noErr)  {          if (err == fnfErr)  {            ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,                  &quot;Couldn't find the Movies folder&quot;);          }  else  {            ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,                  &quot;Couldn't get the Movies folder spec (error %ld)&quot;, err);          }          EXITERR( err );        }      }            pb.dirInfo.ioNamePtr = folderSpec.name;      pb.dirInfo.ioVRefNum = folderSpec.vRefNum;      pb.dirInfo.ioDrDirID = folderSpec.parID;      pb.dirInfo.ioFDirIndex = 0;            err = PBGetCatInfoSync(&amp;pb);      if (err != noErr)  {        char    tempString[256];        CopyPToCStr(folderSpec.name, tempString);        ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,              &quot;Error (%ld) while PBGetCatInfoSync on the folder '%s'&quot;, err, tempString);        EXITERR( err );      }      handler-&gt;folderVRefNum = pb.dirInfo.ioVRefNum;      //handler-&gt;folderDirID = folderSpec.parID;      handler-&gt;folderDirID = pb.dirInfo.ioDrDirID;      handler-&gt;numFilesInFolder = pb.dirInfo.ioDrNmFls;    }  }    // for each stream, if there is no sourcer, make one  numStreams = QTSPresGetNumStreams(handler-&gt;presentation);  for (i=1; i&lt;=numStreams; ++i)  {    stream = QTSPresGetIndStream(handler-&gt;presentation, i);    if (stream != kQTSInvalidStream)  {      numSources = QTSPresGetNumSourcers(handler-&gt;presentation, stream);      if (numSources == 0)  {        EXITIFERR( err = MovieSourcing_SetupTrackSourcerForStream(handler, stream) );      }    }  }      if (handler-&gt;numTrackSourcers &gt; 0)  {    err = MovieSourcing_SetupNextMovie(handler);  }  *outHandler = handler;exit:  if (err != noErr)  {    if (handler != NULL)  {      MovieSourcing_Dispose(handler);      }  }  return err;}// ---------------------------------------------------------------------------//    MovieSourcing_Dispose// ---------------------------------------------------------------------------void MovieSourcing_Dispose(MovieSourcing *inHandler){  if (inHandler != NULL)  {    MovieSourcing_CloseCurrentMovie(inHandler, kStoredMovieSupportCloseFlag_DontTellSourcers);    DisposePtr((Ptr)inHandler);  }}// ---------------------------------------------------------------------------//    MovieSourcing_Reset// ---------------------------------------------------------------------------static void MovieSourcing_Reset(MovieSourcing *inHandler){  MovieSourcing_CloseCurrentMovie(inHandler, kStoredMovieSupportCloseFlag_DontTellSourcers);}// ---------------------------------------------------------------------------//    MovieSourcing_SetupTrackSourcerForStream// ---------------------------------------------------------------------------static OSErr MovieSourcing_SetupTrackSourcerForStream(MovieSourcing *inHandler, QTSStream inStream){  OSErr            err = noErr;  ComponentInstance      sourcer = 0;  OSType            trackType = SoundMediaType;  MovieSourcingSourcerInfo  *sourcerInfo;  QTSLoopParams        loopParams;  OSErr            tempErr;  ComponentDescription    cd;  Component          component;    if (inHandler-&gt;numTrackSourcers &gt;= kMovieSourcingMaxTrackSourcers)  {    ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,          &quot;Too many (&gt;%ld) folder movie tracks in this broadcast&quot;, kMovieSourcingMaxTrackSourcers);    EXITERR( err = qtsBadStateErr );  }  // ask the presentation if it already has a media type  tempErr = QTSPresGetInfo(inHandler-&gt;presentation, inStream, kQTSMediaTypeInfo, &amp;trackType);  if (tempErr != noErr)  {    trackType = SoundMediaType;  }  memset(&amp;cd, 0, sizeof(cd));  cd.componentType = kQTSSourcerType;  cd.componentSubType = kQTSMovieTrackSourcerType;  cd.componentManufacturer = trackType;  component = FindNextComponent(0, &amp;cd);  if (component == 0)  {    ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,          &quot;Couldn't open track sourcer of type '%.4s'&quot;, &amp;trackType);    EXITERR( err = paramErr );  }    EXITIFERR( err = OpenAComponent(component, &amp;sourcer) );  EXITIFERR( err = QTSSourcerInitialize(sourcer, NULL) );  if (inHandler-&gt;loop)  {    memset(&amp;loopParams, 0, sizeof(loopParams));    loopParams.loopFlags = kQTSLoopFlag_Loop;    loopParams.flagsMask = kQTSLoopFlag_Loop;    QTSSourcerSetInfo(sourcer, kQTSInfo_Loop, &amp;loopParams);  }  {    QTSSourcerCallbackProcParams  cParams;        memset(&amp;cParams, 0, sizeof(cParams));    cParams.version = kQTSSourcerCallbackProcParamsVersion1;    if (gMovieSourcingCallbackUPP == NULL)  {      gMovieSourcingCallbackUPP = NewQTSNotificationUPP(MovieSourcing_CallbackProc);    }    cParams.proc = gMovieSourcingCallbackUPP;    cParams.refCon = inHandler;      EXITIFERR( err = QTSSourcerSetInfo(sourcer, kQTSInfo_SourcerCallbackProc, &amp;cParams) );  }  // the presentation now owns the sourcer and will dispose of it unless you   // set the right flags  EXITIFERR( err = QTSPresAddSourcer(inHandler-&gt;presentation, inStream, sourcer, 0L) );  sourcerInfo = &amp;(inHandler-&gt;sourcerInfo[inHandler-&gt;numTrackSourcers]);  sourcerInfo-&gt;sourcer = sourcer;  sourcerInfo-&gt;stream = inStream;  sourcerInfo-&gt;trackType = trackType;  ++inHandler-&gt;numTrackSourcers;exit:  if (err != noErr)  {    DEBUGF((&quot;MovieSourcing_SetupTrackSourcerForStream $%.8x-err %ld&quot;, inHandler, err));    if (sourcer != 0)  {      CloseComponent(sourcer);    }  }  return err;}// ---------------------------------------------------------------------------//    MovieSourcing_SetupNextMovie// ---------------------------------------------------------------------------static OSErr MovieSourcing_SetupNextMovie(MovieSourcing *inHandler){  OSErr    err = noErr;  long    numMovieTracks;  long    i;  Track    track;  Media    media;  OSType    trackType;    if (inHandler-&gt;currentFileIndex == kMovieSourcingUseOneFixedFile)  {    if (inHandler-&gt;currentMovie == 0) {      EXITIFERR( err = MovieSourcing_GetNextMovie(inHandler) );    }  }  else  {    MovieSourcing_CloseCurrentMovie(inHandler, 0L);    EXITIFERR( err = MovieSourcing_GetNextMovie(inHandler) );  }  numMovieTracks = GetMovieTrackCount(inHandler-&gt;currentMovie);  for (i=1; i&lt;=numMovieTracks; ++i)  {    track = GetMovieIndTrack(inHandler-&gt;currentMovie, i);    if (!GetTrackEnabled(track))  {      // skip any disabled tracks      continue;    }    media = GetTrackMedia(track);    GetMediaHandlerDescription(media, &amp;trackType, NULL, NULL);    MovieSourcing_FindAndSetupSourcer(inHandler, track, trackType);  }exit:  return err;}// ---------------------------------------------------------------------------//    MovieSourcing_FindAndSetupSourcer// ---------------------------------------------------------------------------static Boolean MovieSourcing_FindAndSetupSourcer(MovieSourcing *inHandler,            Track inTrack, OSType inTrackType){  QTSTrackParams        trackParams;  MovieSourcingSourcerInfo  *sourcerInfo;  Boolean            found = false;  UInt32            i;  OSErr            err = noErr;    memset(&amp;trackParams, 0, sizeof(trackParams));  for (i=0; i&lt;inHandler-&gt;numTrackSourcers; ++i)  {    sourcerInfo = &amp;(inHandler-&gt;sourcerInfo[i]);    if (sourcerInfo-&gt;sourcer == 0)  {      // this should never happen      DEBUGF((&quot;MovieSourcing_FindAndSetupSourcer $%.8s-info $%.8x sourcer=0&quot;, inHandler, sourcerInfo));      break;    }        if ((sourcerInfo-&gt;track == 0)  &amp;&amp;  (sourcerInfo-&gt;trackType == inTrackType))  {      trackParams.track = inTrack;      EXITIFERR( err = QTSSourcerSetInfo(sourcerInfo-&gt;sourcer, kQTSInfo_Track, &amp;trackParams) );      sourcerInfo-&gt;track = inTrack;      found = true;      break;    }  }exit:  return found;}// ---------------------------------------------------------------------------//    MovieSourcing_GetNextMovie// ---------------------------------------------------------------------------static OSErr MovieSourcing_GetNextMovie(MovieSourcing *inHandler){  OSErr    err = noErr;  Movie    myMovie = 0;  FSSpec    mySpec;  short    refNum = kFileNotOpen;  UInt32    originalIndex;  Boolean    cycledAround = false;  Boolean    foundFile = false;  Boolean    foundMovie = false;  CInfoPBRec    pb;  OSErr      tempErr;    if (inHandler-&gt;currentFileIndex == kMovieSourcingUseOneFixedFile)  {    BlockMoveData(&amp;inHandler-&gt;currentMovieSpec, &amp;mySpec, sizeof(mySpec));    err = OpenMovieFile(&amp;mySpec, &amp;refNum, fsRdPerm);    if (err == noErr)  {      err = NewMovieFromFile(&amp;myMovie, refNum, NULL, NULL, 0L, NULL) ;    }    if (err != noErr)  {      if (err == fnfErr)  {        ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,            &quot;The file 'switch.mov' in the application directory could not be found&quot;);      } else  {        ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,            &quot;Error (%ld) trying to use the file switch.mov in the application directory&quot;, err);      }      EXITERR( err );    }  }  else  {    mySpec.vRefNum = inHandler-&gt;folderVRefNum;    mySpec.parID = inHandler-&gt;folderDirID;    originalIndex = inHandler-&gt;currentFileIndex;    while (!foundMovie)  {      memset(&amp;pb, 0, sizeof(pb));      while (!foundFile)  {        ++inHandler-&gt;currentFileIndex;        if (cycledAround)  {          DEBUGF((&quot;MovieSourcing_GetNextMovie $%.8x-no valid movies in folder?&quot;, inHandler));          EXITERR( err = fnfErr );        }        if (inHandler-&gt;currentFileIndex == originalIndex)  {          // we wrapped around without finding any movies          cycledAround = true;        }        mySpec.name[0] = 0;        pb.hFileInfo.ioNamePtr = mySpec.name;        pb.hFileInfo.ioVRefNum = mySpec.vRefNum;        pb.hFileInfo.ioDirID = mySpec.parID;        pb.hFileInfo.ioFDirIndex = inHandler-&gt;currentFileIndex;                tempErr = PBGetCatInfoSync(&amp;pb);                // @@@ need to stop if the folder contains only directories        if (tempErr == noErr)  {          long    length;          if (pb.dirInfo.ioFlAttrib &amp; kioFlAttribDirMask)  {            // this is a directory            continue;          }          // it has a /n at the end of the name, but MPW and CW interpret /n to be different          #define kIconFileNameBase    &quot;Icon&quot;          // skip the hidden icon file that seems to be made all the time          length = strlen(kIconFileNameBase);          if (mySpec.name[0] == (length+1))  {            if (EqualChars((char*)&amp;(mySpec.name[1]), mySpec.name[0], kIconFileNameBase, length))  {              if ((mySpec.name[length] == '\r')  ||  (mySpec.name[length] == '\n'))  {                continue;              }            }          }          foundFile = true;        }  else  {          if (tempErr == fnfErr)  {            if (inHandler-&gt;currentFileIndex &lt; 2)  {              ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,                  &quot;Warning - Couldn't find any valid movie files in the movie folder.&quot;);              EXITERR( err );            }            inHandler-&gt;currentFileIndex = 0;          }  else  {            ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,                  &quot;Error (%ld) getting info about the movie folder.&quot;, tempErr);            EXITERR( err );          }        }      }          // get the next file in the list and make a movie out of it      EXITIFERR( err = OpenMovieFile(&amp;mySpec, &amp;refNum, fsRdPerm) );      tempErr = NewMovieFromFile(&amp;myMovie, refNum, NULL, NULL, 0L, NULL);      if (tempErr == noErr)  {        foundMovie = true;      }  else  {        foundFile = false;        //EXITERR( err = tempErr );      }    }  }    BlockMoveData(&amp;mySpec, &amp;inHandler-&gt;currentMovieSpec, sizeof(mySpec));  inHandler-&gt;movieFileRefNum = refNum;  inHandler-&gt;currentMovie = myMovie;exit:  if (err != noErr)  {    DEBUGF((&quot;MovieSourcing_GetNextMovie $%.8x-err %ld&quot;, inHandler, err));    if (myMovie != 0)  {      DisposeMovie(myMovie);    }    if ((refNum != kFileNotOpen)  &amp;&amp;  (refNum != 0))  {      CloseMovieFile(refNum);    }  }  return err;}// ---------------------------------------------------------------------------//    MovieSourcing_CloseCurrentMovie// ---------------------------------------------------------------------------static void MovieSourcing_CloseCurrentMovie(MovieSourcing *inHandler, SInt32 inFlags){  // unset all the tracks in the sourcers      UInt32            i;  QTSTrackParams        trackParams;  MovieSourcingSourcerInfo  *sourcerInfo;    memset(&amp;trackParams, 0, sizeof(trackParams));  for (i=0; i&lt;inHandler-&gt;numTrackSourcers; ++i)  {    sourcerInfo = &amp;(inHandler-&gt;sourcerInfo[i]);    if (!(inFlags &amp; kStoredMovieSupportCloseFlag_DontTellSourcers))  {      if ((sourcerInfo-&gt;sourcer != 0)  &amp;&amp;  (sourcerInfo-&gt;track != 0))  {        QTSSourcerSetInfo(sourcerInfo-&gt;sourcer, kQTSInfo_Track, &amp;trackParams);      }  else  {        if (sourcerInfo-&gt;sourcer == 0)  {          DEBUGF((&quot;MovieSourcing_CloseCurrentMovie $%.8x-index %ld no sourcer&quot;, inHandler, i));        }      }    }    sourcerInfo-&gt;track = 0;  }  if (inHandler-&gt;currentMovie != 0)  {    DisposeMovie(inHandler-&gt;currentMovie);    inHandler-&gt;currentMovie = 0;  }  if ((inHandler-&gt;movieFileRefNum != kFileNotOpen)  &amp;&amp;  (inHandler-&gt;movieFileRefNum != 0))  {    CloseMovieFile(inHandler-&gt;movieFileRefNum);    inHandler-&gt;movieFileRefNum = kFileNotOpen;  }}// ---------------------------------------------------------------------------//    MovieSourcing_SkipToNext// ---------------------------------------------------------------------------static OSErr MovieSourcing_SkipToNext(MovieSourcing *inHandler){  return MovieSourcing_SetupNextMovie(inHandler);}// ---------------------------------------------------------------------------//    MovieSourcing_Idle// ---------------------------------------------------------------------------void MovieSourcing_Idle(MovieSourcing *inHandler, Boolean inPlaying){#pragma unused(inHandler, inPlaying)}// ---------------------------------------------------------------------------//    MovieSourcing_SetEnable// ---------------------------------------------------------------------------void MovieSourcing_SetEnable(MovieSourcing *inHandler, Boolean inEnable){  UInt32            i;  MovieSourcingSourcerInfo  *sourcerInfo;  for (i=0; i&lt;inHandler-&gt;numTrackSourcers; ++i)  {    sourcerInfo = &amp;(inHandler-&gt;sourcerInfo[i]);    if (sourcerInfo-&gt;sourcer != 0)  {      QTSSourcerSetEnable(sourcerInfo-&gt;sourcer, inEnable, 0);    }  }}// ---------------------------------------------------------------------------//    MovieSourcing_HasCharacteristic// ---------------------------------------------------------------------------void MovieSourcing_HasCharacteristic(MovieSourcing *inHandler, OSType inCharacteristic, Boolean *outHasIt){#pragma unused(inHandler)  switch (inCharacteristic)  {      default:      *outHasIt = false;      break;  }}#pragma mark -// ---------------------------------------------------------------------------//    MovieSourcing_HandleNotification// ---------------------------------------------------------------------------void MovieSourcing_HandleNotification(MovieSourcing *inHandler, OSType inNotification, void *inParams){#pragma unused(inHandler, inParams)  Boolean      changed = false;  switch (inNotification)  {      default:      break;  }}// ---------------------------------------------------------------------------//    MovieSourcing_CallbackProc// ---------------------------------------------------------------------------static pascal ComponentResult MovieSourcing_CallbackProc(ComponentResult inErr,        OSType inSelector, void *ioParams, void *inRefCon){  ComponentResult    err = noErr;  MovieSourcing    *handler = (MovieSourcing*)inRefCon;    if (inErr != noErr)  {    DEBUGF((&quot;MovieSourcing_CallbackProc $%.8x-err %ld&quot;, inRefCon, inErr));  }  switch (inSelector)  {    case kQTSSourcerCallback_Done:      MovieSourcing_SourcerDone(handler, (QTSSourcerDoneParams*)ioParams, NULL);      break;        default:      // ignore any selectors you don't know about      break;        }  return err;}// ---------------------------------------------------------------------------//    MovieSourcing_SourcerDone// ---------------------------------------------------------------------------static OSErr MovieSourcing_SourcerDone(MovieSourcing *inHandler,          QTSSourcerDoneParams *inParams, Boolean *outSendChangedMessage){  // find the right sourcer and mark it as done  // when all streams are done, go to the next movie  OSErr            err = noErr;  UInt32            i;  MovieSourcingSourcerInfo  *sourcerInfo;  Boolean            found = false;  Boolean            allDone = true;    for (i=0; i&lt;inHandler-&gt;numTrackSourcers; ++i)  {    sourcerInfo = &amp;(inHandler-&gt;sourcerInfo[i]);    if (sourcerInfo-&gt;sourcer == inParams-&gt;sourcer)  {      sourcerInfo-&gt;done = true;      found = true;      break;    }  else  {      if (!sourcerInfo-&gt;done)  {        allDone = false;      }    }  }    if (!found) {    goto exit;  }    if (allDone)  {    err = MovieSourcing_SetupNextMovie(inHandler);    if (err != noErr)  {      DEBUGF((&quot;MovieSourcing_SourcerDone $%.8x-err %ld starting next movie&quot;, inHandler, err));    }    if (outSendChangedMessage != NULL)  {      *outSendChangedMessage = true;    }  }exit:  return err;}// ---------------------------------------------------------------------------//    MovieSourcing_GetInfo// ---------------------------------------------------------------------------OSErr MovieSourcing_GetInfo(MovieSourcing *inHandler, OSType inSelector, void *ioParams){  OSErr            err = noErr;  UInt32            i;  MovieSourcingSourcerInfo  *sourcerInfo;  Boolean            found = false;    switch (inSelector)  {    case kQTSInfo_SourcerTiming:    {      // find the first sourcer and ask it      for (i=0; i&lt;inHandler-&gt;numTrackSourcers; ++i)  {        sourcerInfo = &amp;(inHandler-&gt;sourcerInfo[i]);        if (sourcerInfo-&gt;sourcer != 0)  {          err = QTSSourcerGetInfo(sourcerInfo-&gt;sourcer, kQTSInfo_SourcerTiming, ioParams);          found = true;          break;        }      }      if (!found)  {        err = qtsUnknownValueErr;      }      break;    }          default:      err = qtsBadSelectorErr;      break;  }  return err;}// ---------------------------------------------------------------------------//    MovieSourcing_SetInfo// ---------------------------------------------------------------------------OSErr MovieSourcing_SetInfo(MovieSourcing *inHandler, OSType inSelector, void *ioParams){#pragma unused(inHandler, ioParams)  OSErr        err = noErr;    switch (inSelector)  {          default:      err = qtsBadSelectorErr;      break;  }  return err;}// ---------------------------------------------------------------------------//    MovieSourcing_DoCommand// ---------------------------------------------------------------------------OSErr MovieSourcing_DoCommand(MovieSourcing *inHandler, OSType inCommand, void *ioCommandParams){#pragma unused(ioCommandParams)  OSErr            err = noErr;    switch (inCommand)  {    case kCommand_GetStoredMovieInfo:    {      UsherStoredMovieParams  *mParams = (UsherStoredMovieParams*)ioCommandParams;      memset(mParams, 0, sizeof(UsherStoredMovieParams));      mParams-&gt;doingStoredMovies = true;      BlockMoveData(&amp;inHandler-&gt;currentMovieSpec, &amp;mParams-&gt;currentMovieSpec, sizeof(FSSpec));      break;    }    case kCommand_SkipToNextMovie:      err = MovieSourcing_SkipToNext(inHandler);      break;          default:      err = kErr_AppUnhandledCommand;      break;  }  return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/usher/listing4.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/usher/listing4.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/usher/listing4.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>