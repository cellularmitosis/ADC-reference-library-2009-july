<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h1>

<FONT COLOR="#000066">

<a name="94">

 <a name="//apple_ref/occ/cl/NSUnarchiver">NSUnarchiver</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

NSCoder : NSObject



<p><B>Conforms To:</B><BR>

NSObject (NSObject) 



<p><B>Declared In:	</B><BR>

Foundation/NSArchiver.h



<p><a name="125"></a>

<a name="description"></a>

<H2>Class Description 

</H2>

NSUnarchiver, a concrete subclass of NSCoder, defines methods for decoding a set of Objective-C objects from an archive. Such archives are produced by objects of the NSArchiver class. See the NSCoder and NSArchiver specifications for an introduction to archiving.<p>

<h3>

<a name="127">

 General Exception Conditions

</a>

</h3>

While unarchiving, NSUnarchiver performs a variety of consistency checks on the incoming data stream. NSUnarchiver raises an NSInconsistentArchiveException when: <p>

<ul><li>A class name is missing where one is expected.<br>

<li>A class name is found that refers to an unknown class.<br>

<li><em></em>A type code is found that's different from the one expected.<br>

<li>An unknown type code is found.<br>

<li>Excess characters are found in a type code, or characters are missing.<br>

</ul>For a description of type codes, see the discussion of the <code>@encode()</code> compiler directive in <em>Object-Oriented Programming and the Objective-C Language</em>.<p>

Invoking inappropriate methods can also lead to errors. NSUnarchiver's superclass, NSCoder, provides methods for both encoding and decoding. However, only the decoding methods are applicable to NSUnarchiver; don't send an NSUnarchiver any <code>encode...</code> messages. <p>

<a name="136">

<HR WIDTH=50% ALIGN=LEFT>

<h2>Method Types

</h2>

</a><dl>

<dt>Initializing an NSUnarchiver<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSUnarchiver/initForReadingWithData:">- initForReadingWithData:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Decoding objects<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSUnarchiver/unarchiveObjectWithData:">+ unarchiveObjectWithData:</a><dt><a href="#//apple_ref/occ/clm/NSUnarchiver/unarchiveObjectWithFile:">+ unarchiveObjectWithFile:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Managing an NSUnarchiver<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSUnarchiver/isAtEnd">- isAtEnd</a><dt><a href="#//apple_ref/occ/instm/NSUnarchiver/objectZone">- objectZone</a><dt><a href="#//apple_ref/occ/instm/NSUnarchiver/setObjectZone:">- setObjectZone:</a><dt><a href="#//apple_ref/occ/instm/NSUnarchiver/systemVersion">- systemVersion</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Substituting classes or objects<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSUnarchiver/classNameDecodedForArchiveClassName:">+ classNameDecodedForArchiveClassName:</a><dt><a href="#//apple_ref/occ/clm/NSUnarchiver/decodeClassName:asClassName:">+ decodeClassName:asClassName:</a><dt><a href="#//apple_ref/occ/instm/NSUnarchiver/classNameDecodedForArchiveClassName:">- classNameDecodedForArchiveClassName:</a><dt><a href="#//apple_ref/occ/instm/NSUnarchiver/decodeClassName:asClassName:">- decodeClassName:asClassName:</a><dt><a href="#//apple_ref/occ/instm/NSUnarchiver/replaceObject:withObject:">- replaceObject:withObject:</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH=50% ALIGN=LEFT>

<a name="153"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  





<a name="154"></a>

<h3>

 <a name="//apple_ref/occ/clm/NSUnarchiver/classNameDecodedForArchiveClassName:">classNameDecodedForArchiveClassName:</a>

</h3>

+ (NSString *)<code>classNameDecodedForArchiveClassName:</code>(NSString *)<em>nameInArchive</em>

<P>Returns the name of the class used when instantiating objects whose ostensible class, according to the archived data, is <em>nameInArchive</em>. This method returns <em>nameInArchive</em> if no substitute name has been specified using the class method (not the instance method) <code>decodeClassName:asClassName:</code>.<p>

Note that individual instances of NSUnarchiver can each be given their own class name mappings by invoking the instance method <code>decodeClassName:asClassName:</code>. The NSUnarchiver class has no information about these instance-specific mappings, however, so they don't affect the return value of this class method (that is, <code>classNameDecodedForArchiveClassName:</code>).<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSUnarchiver/classNameDecodedForArchiveClassName:">- classNameDecodedForArchiveClassName:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="159"></a>

<h3> <a name="//apple_ref/occ/clm/NSUnarchiver/decodeClassName:asClassName:">decodeClassName:asClassName:</a></h3>

+ (void)<code>decodeClassName:</code>(NSString *)<em>nameInArchive</em><em> </em><code>asClassName:</code>(NSString *)<em>trueName</em>

<P>Instructs instances of NSUnarchiver to use the class named <em>trueName</em> when instantiating objects whose ostensible class, according to the archived data, is <em>nameInArchive</em>. This method enables easy conversion of unarchived data when the name of a class has changed since the archive was created.<p>

Note that there's also an instance method of the same name. An instance of NSUnarchiver can maintain its own mapping of class names. However, if both the class method and the instance method have been invoked using an identical value for <em>nameInArchive</em>, the class method takes precedence.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSUnarchiver/classNameDecodedForArchiveClassName:">+ classNameDecodedForArchiveClassName:</a></code>, <a href="#//apple_ref/occ/instm/NSUnarchiver/decodeClassName:asClassName:"><code>- decodeClassName:asClassName:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="164"></a>

<h3> <a name="//apple_ref/occ/clm/NSUnarchiver/unarchiveObjectWithData:">unarchiveObjectWithData:</a></h3>

+ (id)<code>unarchiveObjectWithData:</code>(NSData *)<em>data</em> 

<P>Decodes and returns the object archived in <em>data</em>. This method invokes <code>initForReadingWithData</code><code>:</code> and <code>decodeObject</code> to create a temporary NSUnarchiver that decodes the object. If the archived object is the root of a graph of objects, the entire graph is unarchived.<p>

<B>See also: </B>  

<code><a href="../NSArchiver/NSArchiver.html#//apple_ref/occ/instm/NSArchiver/encodeRootObject:" target="_top">encodeRootObject:</code> (NSArchiver)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="168"></a>

<h3> <a name="//apple_ref/occ/clm/NSUnarchiver/unarchiveObjectWithFile:">unarchiveObjectWithFile:</a></h3>

+ (id)<code>unarchiveObjectWithFile:</code>(NSString *)<em>path</em>

<P>Decodes and returns the object archived in the file <em>path</em>. This convenience method reads the file by invoking NSData's <code>dataWithContentsOfFile</code><code>:</code> method, and then invokes <code>unarchiveObjectWithData:</code>.<p>

<HR WIDTH=50% ALIGN=LEFT>

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="172"></a>

<h3>

 <a name="//apple_ref/occ/instm/NSUnarchiver/classNameDecodedForArchiveClassName:">classNameDecodedForArchiveClassName:</a>

</h3>

- (NSString *)<code>classNameDecodedForArchiveClassName:</code>(NSString *)<em>nameInArchive</em> 

<P>Returns the name of the class that will be used when instantiating objects whose ostensible class, according to the archived data, is <em>nameInArchive</em>. This method returns <em>nameInArchive</em> unless a substitute name has been specified using the instance method (not the class method) <code>decodeClassName:asClassName:</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSUnarchiver/classNameDecodedForArchiveClassName:">+ classNameDecodedForArchiveClassName:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="176"></a>

<h3> <a name="//apple_ref/occ/instm/NSUnarchiver/decodeClassName:asClassName:">decodeClassName:asClassName:</a></h3>

- (void)<code>decodeClassName:</code>(NSString *)<em>nameInArchive</em><em> </em><code>asClassName:</code>(NSString *)<em>trueName</em> 

<P>Instructs the receiver to use the class named <em>trueName</em> when instantiating objects whose ostensible class, according to the archived data, is <em>nameInArchive</em>. This method enables easy conversion of unarchived data when the name of a class has changed since the archive was created.<p>

Note that there's also a class method of the same name. The class method has precedence in case of conflicts.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSUnarchiver/classNameDecodedForArchiveClassName:">- classNameDecodedForArchiveClassName:</a></code>, <a href="#//apple_ref/occ/clm/NSUnarchiver/decodeClassName:asClassName:"><code>+ decodeClassName:asClassName:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="181"></a>

<h3> <a name="//apple_ref/occ/instm/NSUnarchiver/initForReadingWithData:">initForReadingWithData:</a></h3>

- (id)<code>initForReadingWithData:</code>(NSData *)<em>data</em> 

<P>Initializes an NSUnarchiver object from the data object <em>data</em>, decoding the system version number that was archived in <em>data</em> and preparing the NSUnarchiver for a subsequent invocation of <code>decodeObject</code>. Raises an NSInvalidArgumentException if <em>data</em> is<code> nil</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSUnarchiver/systemVersion">- systemVersion</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="185"></a>

<h3> <a name="//apple_ref/occ/instm/NSUnarchiver/isAtEnd">isAtEnd</a></h3>

- (BOOL)<code>isAtEnd</code> 

<P>Returns YES if the NSUnarchiver has reached the end of the encoded data while decoding, NO if more data follows. You can invoke this method after invoking <code>decodeObject </code>to discover whether the archive contains extra data following the encoded object graph. If it does, you can either ignore this anomaly or consider it an error.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="188"></a>

<h3> <a name="//apple_ref/occ/instm/NSUnarchiver/objectZone">objectZone</a></h3>

- (NSZone *)<code>objectZone</code> 

<P>Returns the memory zone used to allocate decoded objects.<p>

<B>See also: </B>  

<code> <a href="#//apple_ref/occ/instm/NSUnarchiver/setObjectZone:">- setObjectZone:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="192"></a>

<h3><a name="//apple_ref/occ/instm/NSUnarchiver/replaceObject:withObject:">replaceObject:withObject:</a></h3>

- (void)<code>replaceObject:</code>(id)<em>object</em> <code>withObject:</code>(id)<em>newObject</em>

<P>Causes the NSUnarchiver to substitute <em>newObject</em> for <em>object</em> whenever <em>object</em> is extracted from the archive. <em>newObject</em> can be of a different class from <em>object</em>, and the class mappings set by the two <code>decodeClassName:asClassName:</code> methods are ignored.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="195"></a>

<h3> <a name="//apple_ref/occ/instm/NSUnarchiver/setObjectZone:">setObjectZone:</a></h3>

- (void)<code>setObjectZone:</code>(NSZone *)<em>zone</em> 

<P>Set the memory zone used to allocate decoded objects. If <em>zone</em> is NULL, or if this method is never invoked, the default zone will be used, as given by <code>NSDefaultMallocZone()</code>.<p>

<B>See also: </B>  

<code> <a href="#//apple_ref/occ/instm/NSUnarchiver/objectZone">- objectZone</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="199"></a>

<h3> <a name="//apple_ref/occ/instm/NSUnarchiver/systemVersion">systemVersion</a></h3>

- (unsigned int)<code>systemVersion</code> 

<P>Returns the system version number that was in effect when the archive was created. This information is available as soon as the NSUnarchiver has been initialized. <p>

The version numbers aren't the usual release designations (such as 2.0 or 3.1). By convention, version numbers under 1000 refer to early versions of NEXTSTEP that didn't conform to the OpenStep specification. <p>

<p>



 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 06/17/97 16:53:37 -->



</body>

</html>

