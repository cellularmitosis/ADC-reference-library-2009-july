<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1085: Using the Drag Manager to Interact with and Manipulate File System Entities</title>       <meta name="keywords" content="Mac OS 8 Drag Manager flavorTypeHFS flavorTypePromisedHFS file system find">    <meta name="Description" content="Technical Note TN1085: This Technical Note discusses thetwo data flavors, flavorTypeHFS and flavorTypePromisedHFS,provided by Drag manager for interacting with and manipulatingfile system entities."><meta name="categories" content="Files and Human Interface Toolbox"><meta name="week-posted" content="Nov 25, 1996 - Dec 6, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002926" title="Using the Drag Manager to Interact with and Manipulate File System Entities"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxUserExperience-date.html">User Experience</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1085</div>
<div id="pageheadsub">Using the Drag Manager to Interact with and Manipulate File System Entities</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext">         <A HREF = "#Section1">Introducing <CODE>flavorType</CODE> and         <CODE>flavorTypeHFS</CODE></A><BR><BR>                  <A HREF = "#Section2">Using <CODE>flavorTypeHFS</CODE></A><BR><BR>                  <A HREF = "#Section3">Sending <CODE>flavorTypeHFS</CODE></A><BR><BR>                  <A HREF = "#Section4">Coping with Finder Bugs</A><BR><BR>                  <A HREF = "#Section5">Receiving <CODE>flavorTypeHFS</CODE></A><BR><BR>                  <A HREF = "#Section6">Using <CODE>flavorTypePromiseHFS</CODE></A><BR><BR>                  <A HREF = "#Section7">Sending <CODE>flavorTypePromiseHFS</CODE></A><BR><BR>                  <A HREF = "#Section8">Creating the File</A><BR><BR>                  <A HREF = "#Section9">Deferring Writing the File</A><BR><BR>                  <A HREF = "#Section10">Receiving <CODE>flavorTypePromiseHFS</CODE></A><BR><BR>                  <A HREF = "#Sidebar">The True Nature of Find File's Evil: A Sidebar</A><BR><BR>                           <A HREF = "#Section11">Working Around Find File</A><BR><BR>                  <A HREF = "#Summary">Summary</A><BR><BR>                  <A HREF = "#Appendices">Appendices</A><BR><BR>     <A HREF = "#References">References</a><BR><BR>    <A HREF="#Downloads">Downloadables</A></p>                  <!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text --><P id = "introtext">The Drag Manager         defines two data flavors for interacting with and         manipulating file system entities. While<I> The Drag Manager         Programmer's Guide</I> explains these flavors, it does not         provide sufficient detail for a complete understanding of         how to use them.</P>                  <P id = "introtext">Developers who are interested in "teaching" (or even         those who have already taught) their applications to         interact with and manipulate file system entities via the         Drag Manager should read this Technote.</P>                  <P id = "introtext">This Technote assumes you are familiar with the material         in the <I>Drag Manager Programmer's Guide</I> and that, in         particular, you have read pages 2-36 and 2-37 and understand         the operation of a <CODE>DragSendDataProc</CODE>, which is documented         starting on the bottom of page 2-72. Also, some familiarity         with the AppleEvent Manager data structure <CODE>AEDesc</CODE> is         assumed. (The AppleEvent Manager is documented in chapter 3 of <I>         <a href="http://developer.apple.com/documentation/mac/IAC/IAC-94.html">         Inside Macintosh: Interapplication Communication</A></I>.)          Finally, familiarity with the File Manager call         <CODE>PBGetCatInfo</CODE> is recommended.</P>                  <P id = "introtext">You can download a complete version of the code snippets         in this Technote, <A HREF = "http://developer.apple.com/samplecode/Sample_Code/Interapplication_Comm/FinderDragPro.htm">FinderDragPro Metrowerks Project</A>,          as well as the <A HREF = "pdf/dmpg.pdf">Drag Manager Programmer's Guide</A>,          by clicking on the item here         or by clicking on the appropriate icon         in the <A HREF = "#Downloads">Downloadables</A> section at the end of this Note.</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Feb 06 1997]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --> <BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content --><A NAME="Section1"></A>                  <H2>Introducing <CODE>flavorTypeHFS</CODE> and <CODE>         flavorTypePromiseHFS</CODE></H2>                  <P>There are two data flavors for interacting with and         manipulating file system entities:          <CODE>flavorTypeHFS</CODE> and         <CODE>flavorTypePromiseHFS</CODE>. Despite similar names,         their meanings are quite different. The key difference is         that for one, the file exists, while for the other the file         does not yet exist.</P>                  <P>Putting <CODE>flavorTypeHFS</CODE> data, which refers to         an existing file, into a <CODE>DragReference</CODE> is like saying "I         know of an existing file (which I may or may not have         created myself) in which drag receivers might be         interested." Putting <CODE>flavorTypePromiseHFS</CODE> data into a         <CODE>DragReference</CODE> is like saying "I'm willing to create a new         file as soon as somebody (a drag receiver) tells me where to put it."</P>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The Drag Manager has the concept of                     "promising" data to a <CODE>DragReference</CODE>. Do not                     confuse this with                     <CODE>flavorTypePromiseHFS</CODE>. The two kinds                     of promise are different, and promising                     <CODE>flavorTypeHFS</CODE> data to a <CODE>DragReference</CODE> has                     nothing to do with                     <CODE>flavorTypePromiseHFS</CODE>.</p>                                          <P>This can be especially confusing when an                     application promises <CODE>flavorTypePromiseHFS</CODE> data                     to a <CODE>DragReference</CODE>; the promised data is in turn                     a promise to the receiving application to                     provide data which refers to a newly created                     file - a triple indirection.</p>                                          <P>In this Technote, I make an effort to avoid                     using the word "promise" in more than one sense                     at a time; nevertheless, read carefully.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>The format of Drag Manager flavor data is only                     conventional. This means that nothing in the API                     forces senders and receivers to use it                     correctly. As always, you need to be careful to                     implement these flavors strictly by the book.</p>                                          <P>The situation may even be worse. This document                     came into existence several years after the                     release of the Drag Manager. As a result, it's                     been difficult for early adopters of the Drag                     Manager to implement these flavors properly. And                     there may be applications which aren't as                     conscientious as yours. You should be extra                     careful to check error return values and build                     assertions into your code, so that your app is                     ready to cope with other apps which unexpectedly                     deviate from the conventions documented in this Note.</p></TD></TR></TABLE></CENTER><BR>  <P><A HREF="#top">Back to top</A></P><A NAME="Section2"></A>                  <H2>Using <CODE>flavorTypeHFS</CODE></H2>                  <P>In theory, using<CODE>flavorTypeHFS</CODE> data appears         simple, but in practice there are a few tricks you need to         know. The following sections document a few of those tricks         for you. For quick reference, here's a copy of the <CODE>HFSFlavor</CODE>         declaration from &lt;<CODE>Drag.h</CODE>&gt;: </P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct HFSFlavor{    OSType          fileType;       // file type    OSType          fileCreator;    // file creator    unsigned short  fdFlags;        // Finder flags    FSSpec          fileSpec;       // file system specification};typedef struct HFSFlavor HFSFlavor;</pre>	</TD></TR></TABLE></CENTER>  <P><A HREF="#top">Back to top</A></P><A NAME="Section3"></A>                  <H2>Sending flavorTypeHFS</H2>                  <P>To originate a drag containing <CODE>flavorTypeHFS</CODE>         data, you must first declare an <CODE>HFSFlavor</CODE> record. This         record contains an <CODE>FSSpec</CODE> and a few other fields which allow         some potential drag receivers to avoid calling <CODE>FSpGetFInfo</CODE>.         </P>                  <P>The next step is to initialize the <CODE>fileSpec</CODE> field         appropriately, then decide whether the data refers to a         file. If so, simply set the <CODE>fileType</CODE>, <CODE>fileCreator</CODE>, and         <CODE>fdFlags</CODE> fields to match the appropriate information for the         file. If the <CODE>flavorTypeHFS</CODE> data refers to a directory or         volume, set the <CODE>fileType</CODE> and <CODE>fileCreator</CODE> fields in the         <CODE>HFSFlavor</CODE> record according to Table 1: </P>                  <P><B>Table 1.</B> <I>The <CODE>fileType</CODE> and <CODE>fileCreator</CODE> fields         for the <CODE>HFSFlavor</CODE> record</I></P>                  <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=275>            <TR>               <td align="left">                  <P ALIGN=CENTER><B>entity type</B></p>               </TD><td align="left">                  <P ALIGN=CENTER><B><CODE>fileCreator</CODE></B></p>               </TD><td align="left">                  <P ALIGN=CENTER><B><CODE>fileType</CODE></B></p>               </TD></TR>            <TR>               <td align="left">                  <P ALIGN=CENTER>directory (folder)</p>               </TD><td align="left">                  <P ALIGN=CENTER><CODE>MACS</CODE></p>               </TD><td align="left">                  <P ALIGN=CENTER><CODE>fold</CODE></p>               </TD></TR>            <TR>               <td align="left">                  <P ALIGN=CENTER>volume (disk)</p>               </TD><td align="left">                  <P ALIGN=CENTER><CODE>MACS</CODE></p>               </TD><td align="left">                  <P ALIGN=CENTER><CODE>disk</CODE></p>               </TD></TR>         </TABLE></CENTER>                  <P>These values are a hint to potential drag receivers that         they are dealing with something other than a file. They are         the same as the ones you would use in your application's         bundle resource to let Finder know your app will accept         folders and disks dropped onto your application's icon.</P><BR>                              <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr MakeHFSFlavor    (short vRefNum, long dirID, ConstStr255Param path,        HFSFlavor register *hfsFlavorP){    OSErr err = noErr;    if (!(err = FSMakeFSSpec        (vRefNum,dirID,path,&amp;(hfsFlavorP-&gt;fileSpec))))    {        CInfoPBPtr cipbp =            (CInfoPBPtr) NewPtrClear (sizeof (*cipbp));        if (!(err = MemError ( )))        {            cipbp-&gt;hFileInfo.ioVRefNum  =                hfsFlavorP-&gt;fileSpec.vRefNum;            cipbp-&gt;hFileInfo.ioDirID    =                hfsFlavorP-&gt;fileSpec.parID;            cipbp-&gt;hFileInfo.ioNamePtr  =                hfsFlavorP-&gt;fileSpec.name;            if (!(err = PBGetCatInfoSync (cipbp)))            {                hfsFlavorP-&gt;fdFlags =                    cipbp-&gt;hFileInfo.ioFlFndrInfo.fdFlags;                if (hfsFlavorP-&gt;fileSpec.parID == fsRtParID)                {                    hfsFlavorP-&gt;fileCreator     = 'MACS';                    hfsFlavorP-&gt;fileType        = 'disk';                }                else if (cipbp-&gt;hFileInfo.ioFlAttrib &amp; ioDirMask)                {                    hfsFlavorP-&gt;fileCreator     = 'MACS';                    hfsFlavorP-&gt;fileType        = 'fold';                }                else                {                    hfsFlavorP-&gt;fileCreator     =                        cipbp-&gt;hFileInfo.ioFlFndrInfo.fdCreator;                    hfsFlavorP-&gt;fileType        =                        cipbp-&gt;hFileInfo.ioFlFndrInfo.fdType;                }            }            DisposePtr ((Ptr) cipbp);            if (!err) err = MemError ( );        }    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 1.</b> Deciding how to set the <CODE>fileCreator</CODE> and         <CODE>fileType</CODE> fields</P>	</TD></TR></TABLE></CENTER>  <P><A HREF="#top">Back to top</A></P><A NAME="Section4"></A>                  <H2>Coping with Finder Bugs</H2>                  <P>Dragging <CODE>flavorTypeHFS</CODE> data from your         application to Finder has always supposed to have been         possible. However, Finder bugs have prevented most         applications from successfully using this feature.</P>                  <P>From Finder's perspective, there are two cases for         receiving <CODE>flavorTypeHFS</CODE> data. The second case         is more interesting.</P>                  <OL>            <LI>If the drop location is on the same volume as the            <CODE>flavorTypeHFS</CODE> data, Finder simply moves the            file to the drop location.</li>                        <LI>If the the drop location is on a different volume,            Finder needs to copy the file to the new volume.</li>         </OL>                  <P>Finder is AppleEvent-intensive. It sends itself         AppleEvents to order itself to do all sorts of things,         including displaying the progress window for copying files.         However, Finder's drag-receiving code mistakenly sends these         particular AppleEvents to the front process instead of the         current process. The front process is generally the         application which originated the drag. Since the application         does not have handlers for these events, AppleEvent Manager         returns an error to Finder's <CODE>AESend</CODE> call and Finder cancels         the entire operation.</P>                  <P>Until this bug is fixed, your application can work around         the problem by "handling" these AppleEvents. On systems         under which Finder has been fixed, the handler will simply         lie dormant in your app, because the AppleEvents will be         sent to Finder, not your app. Unfortunately, it doesn't do         any good to "reflect" these events back to the Finder; trust         us, we've tried. This means you'll have to do without the         progress dialog, but this is better than abject failure.         </P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr BogusFinderEventHandler    (const AppleEvent *, AppleEvent *, long){    return noErr; // just drop that bad boy on the floor}pascal OSErr InstallBogusFinderEventHandler (void){    OSErr err = noErr;    static AEEventHandlerUPP bogusFinderEventHandlerUPP;    if (!bogusFinderEventHandlerUPP)    {        bogusFinderEventHandlerUPP =            NewAEEventHandlerProc (BogusFinderEventHandler);        if (!bogusFinderEventHandlerUPP)            err = nilHandleErr;        else        {            err = AEInstallEventHandler                ('cwin','****',bogusFinderEventHandlerUPP,0,false);            if (err)            {                DisposeRoutineDescriptor (bogusFinderEventHandlerUPP);                bogusFinderEventHandlerUPP = nil;            }        }    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 2.</b> Receiving bogus AppleEvents from Finder</P>	</TD></TR></TABLE></CENTER>  <P><A HREF="#top">Back to top</A></P><A NAME="Section5"></A>                  <H2>Receiving <CODE>flavorTypeHFS</CODE></H2>                  <P>Receiving <CODE>flavorTypeHFS</CODE>, often from Finder,         is much like receiving any other flavor of data. However, be         aware that some applications will offer you a truncated         record; they do not provide the unused bytes at the end of         the name field of the <CODE>fileSpec</CODE> field of the <CODE>HFSFlavor</CODE>         record. (This is a bug in the sending application, but if         it's not your app, you probably don't have an opportunity to fix it.)</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal Size MinimumBytesForFSSpec (const FSSpec *fss){    // callers can and do assume this does not move memory    return sizeof (*fss) - sizeof (fss-&gt;name) + *(fss-&gt;name) + 1;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 3.</b> Calculating minimum bytes for         <CODE>FSSpec</CODE></P>                  <P><B>(called from snippets #4 , #6, and #14)</B>         </P>	</TD></TR></TABLE></CENTER><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr GetHFSFlavorFromDragReference    (DragReference dragRef, ItemReference itemRef,        HFSFlavor *hfsFlavor){    OSErr err = noErr;    Size size = sizeof (*hfsFlavor);    err = GetFlavorData        (dragRef,itemRef,flavorTypeHFS,hfsFlavor,&amp;size,0);    if (!err)    {        Size minSize = sizeof (*hfsFlavor) -            sizeof (hfsFlavor-&gt;fileSpec);        minSize += MinimumBytesForFSSpec (&amp;(hfsFlavor-&gt;fileSpec));            // see snippet 3 for MinimumBytesForFSSpec        if (size &lt; minSize)            err = cantGetFlavorErr;    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 4.</b> Extracting <CODE>flavorTypeHFS</CODE> data</P>	</TD></TR></TABLE></CENTER>  <P><A HREF="#top">Back to top</A></P><A NAME="Section6"></A>                  <H2>Using <CODE>flavorTypePromiseHFS</CODE></H2>                  <P>Using <CODE>flavorTypePromiseHFS</CODE> data is significantly more         complicated than using <CODE>flavorTypeHFS</CODE> data. The chief area of         confusion is centered on the multi-part nature of         <CODE>flavorTypePromiseHFS</CODE> data. For quick reference, here's a         copy of the <CODE>PromiseHFSFlavor</CODE> declaration from         &lt;<CODE>Drag.h</CODE>&gt;: </P>                 <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct PromiseHFSFlavor{    OSType          fileType;           // file type    OSType          fileCreator;        // file creator    unsigned short  fdFlags;            // Finder flags    FlavorType      promisedFlavor;     // promised flavor};typedef struct PromiseHFSFlavor PromiseHFSFlavor;</pre>	</TD></TR></TABLE></CENTER>  <P><A HREF="#top">Back to top</A></P><A NAME="Section7"></A>                  <H2>Sending <CODE>flavorTypePromiseHFS</CODE></H2>                  <H4>Promising to Create a File         </H4>                  <P>Before calling <CODE>TrackDrag</CODE>, your application         should call <CODE>AddDragItemFlavor</CODE> twice, passing         the same <CODE>ItemReference</CODE> value both times, once         for each part of the data.</P>                  <P>For the first call, declare a record of type         <CODE>PromiseHFSFlavor</CODE> and put <CODE>'fssP'</CODE>         (0x66737350) in the <CODE>promisedFlavor</CODE> field. The         <CITE>Drag Manager Programmer's Guide</CITE> tells you to         put any value you like into <CODE>promisedFlavor</CODE>, but         we're now recommending this specific value. (Details can be         found below; if your application already uses something         else, don't worry too much right now unless it's         <CODE>'rWm1'</CODE>.) Fill in the other fields of the         <CODE>PromiseHFSFlavor</CODE> record appropriately and add         the record to the <CODE>DragReference</CODE>, passing         <CODE>flavorTypePromiseHFS</CODE> for the         <CODE>FlavorType</CODE> parameter.</P>                  <P>With the second call to <CODE>AddDragItemFlavor</CODE>,         pass <CODE>'fssP'</CODE> for the <CODE>FlavorType</CODE>         parameter. Pass 0 for the <CODE>dataPtr</CODE> and         <CODE>dataSize</CODE> parameters to set up a promise to be         kept later.</P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr AddDragItemFlavorTypePromiseHFS    (DragReference dragRef, ItemReference itemRef,        OSType fileType, OSType fileCreator,            UInt16 fdFlags, FlavorType promisedFlavor){    OSErr err = noErr;    PromiseHFSFlavor phfs;    phfs.fileType           = fileType;    phfs.fileCreator        = fileCreator;    phfs.fdFlags            = fdFlags;    phfs.promisedFlavor     = promisedFlavor;    if (!(err = AddDragItemFlavor        (dragRef,itemRef,flavorTypePromiseHFS,            &amp;phfs,sizeof(phfs),flavorNotSaved)))    {        err = AddDragItemFlavor            (dragRef,itemRef,promisedFlavor,nil,0,flavorNotSaved);    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 5.</b> Adding <CODE>flavorTypePromiseHFS</CODE>         data</p>	</TD></TR></TABLE></CENTER>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>Due to a bug in some versions of Finder,                     your application should add <CODE>flavorTypePromiseHFS</CODE>                     flavor data before any other, followed                     immediately by the flavor data for the                     <CODE>promisedFlavor</CODE> field. If your application does                     not add these flavors in this order, Finder will                     position the file's icon incorrectly.</P></TD></TR></TABLE></CENTER><BR>                          <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If your application hasn't already attached                     a <CODE>DragSendDataProc</CODE> to the <CODE>DragReference</CODE> with a                     call to <CODE>SetDragSendDataProc</CODE>, you'll need to add                     this functionality.</p></TD></TR></TABLE></CENTER><BR>                                       <P>         Add any other flavors you might want to         provide in this <CODE>DragReference</CODE>, and you're ready         to call <CODE>TrackDrag</CODE>.         </P>                  <H4>Keeping the Promise</H4>                  <P>When Drag Manager requests a <CODE>FlavorType</CODE> equal to the         <CODE>promisedFlavor</CODE> field of your <CODE>flavorTypePromiseHFS</CODE> data, it's         your cue to keep your promise by delivering the          file. Keeping the promise involves finding out where the         drag receiver wants the file to end up, deciding where to         create the file, and creating the file. You'll do this in         your <CODE>DragSendDataProc</CODE> associated with the <CODE>DragReference</CODE>.         </P>                  <H4>Getting the Drop Location</H4>                  <P>First, your <CODE>DragSendDataProc</CODE> will need to find out where         the drag receiver wants the file. You'll need to call         <CODE>GetDropLocation</CODE>, which will produce an <CODE>AEDesc</CODE>         record. The type of the data found in this record is defined         by the drag receiver. Finder, for example, provides <CODE>typeAlias</CODE>         data. To convert this data to an         <CODE>FSSpec</CODE>, coerce its type to <CODE>typeFSS</CODE> and copy the <CODE>FSSpec</CODE> data         out of the resulting descriptor.</P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr GetDropDirectory (DragReference dragRef, FSSpecPtr fssOut){    OSErr err = noErr;    AEDesc dropLocAlias = { typeNull, nil };    if (!(err = GetDropLocation (dragRef,&amp;dropLocAlias)))    {        if (dropLocAlias.descriptorType != typeAlias)            err = paramErr;        else        {            AEDesc dropLocFSS = { typeNull, nil };            if (!(err = AECoerceDesc                (&amp;dropLocAlias,typeFSS,&amp;dropLocFSS)))            {                // assume MinimumBytesForFSSpec does not move memory                FSSpecPtr fss = (FSSpecPtr) *(dropLocFSS.dataHandle);                BlockMoveData (fss,fssOut,MinimumBytesForFSSpec(fss));                // see snippet 3 for MinimumBytesForFSSpec                err = AEDisposeDesc (&amp;dropLocFSS);            }        }        if (dropLocAlias.dataHandle)        {            OSErr err2 = AEDisposeDesc (&amp;dropLocAlias);            if (!err) err = err2;        }    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 6.</b> Extracting the drop folder</p>	</TD></TR></TABLE></CENTER>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The <CODE>FSSpec</CODE> data describes a directory; it is                     not an <CODE>FSSpec</CODE> you can use for creating your                     file. To get the directory ID for the file you                     want to create, use <CODE>PBGetCatInfo</CODE>, as is done in the                      function in Appendix C.</P></TD></TR></TABLE></CENTER><BR>                      <P>If the drop location data is not of <CODE>typeAlias</CODE>, the call to          <CODE>AECoerceDesc</CODE> will fail.          Your <CODE>DragSendDataProc</CODE> will probably want to provide no data         and return an error in this situation. However, be aware         that applications other than Finder are free to provide a         drop location of <CODE>typeAlias</CODE> (and some even do), so don't rely         on <CODE>typeAlias</CODE> signifying that Finder is the drop receiver.         </P>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Finder currently has a few bugs having to do                     with deciding where to allow                     <CODE>flavorTypePromiseHFS</CODE> drops. Aliases to folders,                     aliases to the Trash, and applications which                     accept the file type presented in the                     <CODE>PromiseHFSFlavor</CODE> record will highlight as if                     they are going to accept a drag. However, they                     reject the drag when the mouse button is                     released. In the latter case (applications), the                     drop location will be an alias to the                     application file itself. There is no good                     workaround for this problem.</P></TD></TR></TABLE></CENTER><BR>           <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Don't try to create the file on a volume                     other than the one specified by the drop                     location. Finder will not copy the file to the                     drop location.</P></TD></TR></TABLE></CENTER><BR>  <P><A HREF="#top">Back to top</A></P>         <P><A NAME="Section8"></A></P>                  <H2>Creating the File</H2>                  <P>Once you've decided where to put the file, you can create         it by calling a function like this one: </P>                        <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr CreatePromisedFileOrFolder   (const PromiseHFSFlavor *phfs, const FSSpec *fss,      ScriptCode scriptTag){   OSErr err = noErr;   if (phfs-&gt;promisedFlavor == kPromisedFlavorFindFile)      err = paramErr;   else if (phfs-&gt;fileType == 'disk')      err = paramErr;   else if (phfs-&gt;fileType == 'fold')      err = CreatePromisedFolder (phfs,fss,scriptTag); // see Snippet 9   else      err = CreatePromisedFile (phfs,fss,scriptTag); // see Snippet 8   return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 7.</b> Creating the promised file or         folder</p>	</TD></TR></TABLE></CENTER><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal CreatePromisedFile    (const PromiseHFSFlavor *phfs, const FSSpec *fss,        ScriptCode scriptTag){    OSErr err = noErr;    if (!(err = FSpCreate        (fss,phfs-&gt;fileCreator,phfs-&gt;fileType,scriptTag)))    {        if (phfs-&gt;fdFlags)        {            FInfo finderInfo;            if (!(err = FSpGetFInfo (fss,&amp;finderInfo)))            {                finderInfo.fdFlags = phfs-&gt;fdFlags;                err = FSpSetFInfo (fss,&amp;finderInfo);            }        }    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 8.</b> Called by snippet #7</p>	</TD></TR></TABLE></CENTER>                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal CreatePromisedFolder    (const PromiseHFSFlavor *phfs, const FSSpec *fss,        ScriptCode scriptTag){    OSErr err = noErr;    long newDirID; // scratch    if (!(err = FSpDirCreate (fss,scriptTag,&amp;newDirID)))    {        if (phfs-&gt;fdFlags)        {            DInfo finderInfo;            // see Appendix B for FSpGetDInfo and FSpSetDInfo            if (!(err = FSpGetDInfo (fss,&amp;finderInfo)))            {                finderInfo.frFlags = phfs-&gt;fdFlags;                err = FSpSetDInfo (fss,&amp;finderInfo);            }        }    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 9.</b> Called by Snippet #7</p>	</TD></TR></TABLE></CENTER>  <P><A HREF="#top">Back to top</A></P><A NAME="Section9"></A>                  <H2>Deferring Writing the File</H2>                  <P>Once the file is created, you may or may not want to         write its contents in your <CODE>DragSendDataProc</CODE>. If the file is         large or your app needs some time to generate the data that         will be in the file, you may want to defer writing the file.         Since Process Manager context switches are disabled during Drag         Manager callbacks, other applications would get no execution         time if you were to spend time writing the file, even if it         were safe to periodically call <CODE>WaitNextEvent</CODE>, which it is         not.</P>                  <P>In this situation, you'll want to open the file in your         <CODE>DragSendDataProc</CODE> and leave it open. In addition, set a          flag to tell another part of your         application it needs to write the file. After <CODE>TrackDrag</CODE>         returns, have that part of your app write the file with         periodic calls to <CODE>WaitNextEvent</CODE>.</P>                  <H3>Finishing the Drag</H3>                  <P>Once (and only if) the file has been successfully         created, you should let the drag receiver know what the         filename was and where the file was created. To do this,         call <CODE>SetItemFlavorData</CODE>. For the <CODE>FlavorType</CODE> parameter, pass         the value of the <CODE>promisedFlavor</CODE> field of the         <CODE>PromiseHFSFlavor</CODE> record. For the flavor data, pass an <CODE>FSSpec</CODE>         record describing the name and location of the file. The         <CODE>promisedFlavor</CODE> data should always be an <CODE>FSSpec</CODE>, not an         <CODE>HFSFlavor</CODE>. This snippet consists of simple glue which adds         the data correctly: </P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr SetPromisedHFSFlavorData    (DragReference dragRef, ItemReference itemRef,        const PromiseHFSFlavor *phfs, const FSSpec *fss){    return SetDragItemFlavorData        (dragRef,itemRef,phfs-&gt;promisedFlavor,fss,sizeof(*fss),0);}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 10.</b> Adding the promised <CODE>FSSpec</CODE></p>	</TD></TR></TABLE></CENTER>                  <H3>Impersonating Find File</H3>                  <P>If you need to provide a <CODE>DragReference</CODE> which refers to an         existing file or files, then if at all possible you should         be sending <CODE>flavorTypeHFS</CODE>. But if you discover a compelling         reason to send <CODE>flavorTypePromiseHFS</CODE> instead, make sure you:          </P>                  <UL>            <LI>Set the <CODE>promisedFlavor</CODE> field of your <CODE>PromiseHFSFlavor</CODE>            record to '<CODE>rWm1</CODE>' (0x72576D31).</li>                        <LI>When Drag Manager asks your <CODE>DragSendDataProc</CODE> for            <CODE>'rWm1'</CODE> data and <CODE>GetDropLocation</CODE> produces             an <CODE>AEDesc</CODE> whose            <CODE>descriptorType</CODE> field contains <CODE>typeNull</CODE>, provide the            original location of the file.</li>                        <LI>If <CODE>GetDropLocation</CODE> produces an <CODE>AEDesc</CODE> whose            <CODE>descriptorType</CODE> field contains <CODE>typeAlias</CODE>, copy the file            into the drop location. <CODE>'rWm1'</CODE> is only a hint to the drag            receiver, and the drag receiver may not take the hint.</li>         </UL>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>Perform these steps for all drag items or                     none; don't mix and match.</P></TD></TR></TABLE></CENTER><BR>                    <P>The section Coping with Find File elsewhere in this Note         details why these steps are necessary. The following snippet         implements a decision tree which tells its caller whether to         copy a file the caller is dropping: </P>                          <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr ShouldCopyToDropLoc    (DragReference dragRef, FlavorType promisedFlavor,        Boolean *shouldCopy){    OSErr err = noErr;    AEDesc dropLoc = { typeNull, nil };    *shouldCopy = false;    if (!(err = GetDropLocation (dragRef,&amp;dropLoc)))    {        if (dropLoc.descriptorType == typeAlias)        {            // no hint or receiver missed it            *shouldCopy = true;        }        else if (dropLoc.descriptorType != typeNull)        {            // unknown drop location descriptor type            err = paramErr;        }        else if (promisedFlavor != kPromisedFlavorFindFile)        {            // null descriptor but no hint intended (DragPeeker)            err = dirNFErr;        }        if (dropLoc.dataHandle)        {            OSErr err2 = AEDisposeDesc (&amp;dropLoc);            if (!err) err = err2;        }    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 11.</b> Deciding whether to copy a dropped file </p>	</TD></TR></TABLE></CENTER>  <P><A HREF="#top">Back to top</A></P><A NAME="Section10"></A>         <H2>Receiving <CODE>flavorTypePromiseHFS</CODE></H2>                  <P>Most applications have no need to receive         <CODE>flavorTypePromiseHFS</CODE> data; <CODE>flavorTypeHFS</CODE> should suffice for         most needs. More senders provide <CODE>flavorTypeHFS</CODE>, although         there is at least one important application (Find File)         which provides <CODE>flavorTypePromiseHFS</CODE>. In any case, seriously         consider <CODE>flavorTypeHFS</CODE> before investing effort in         <CODE>flavorTypePromiseHFS</CODE>.</P>                  <H4>Getting the Two Flavors</H4>                  <P>In your drag tracking handler, you may retrieve the         <CODE>flavorTypePromiseHFS</CODE> data, which is a <CODE>PromiseHFSFlavor</CODE>, but         don't try to retrieve the <CODE>promisedFlavor</CODE> data. Your drag         tracking handler can't know whether a given window in your         application will be the ultimate receiver of the data         - the ultimate receiver might be another window in         your app or one of the windows of another app. If your drag         tracking handler were to ask for the <CODE>promisedFlavor</CODE>         data, Drag Manager would call the sender's <CODE>SendDataProc</CODE>, and         the data would thereafter be cached in the <CODE>DragReference</CODE>.         Consequently, other potential receivers would get the         cached data and the sender would not have a chance to adjust         it according to the receiver's drop location.</P>                  <P>In your drag receive handler, it's safe to retrieve both         the <CODE>flavorTypePromiseHFS</CODE> data and the <CODE>promisedFlavor</CODE> data.         Before requesting the <CODE>promisedFlavor</CODE> data, however, make         sure to call <CODE>SetDropLocation</CODE>. The next snippet is a function         which administrates this process. Note that the folder         parameter can be <CODE>NIL</CODE>; this means the caller         supports Find File; we'll explain how this works and why         you'd want to do it a little later.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr ReceivePromisedFile    (DragReference dragRef, ItemReference itemRef,        HFSFlavor *hfsFlavor, const FSSpec *folder){    OSErr err = noErr;    if (folder)        // see Snippet 13 for SetDropFolder        err = SetDropFolder (dragRef,folder);    if (!err)    {        // we'll explain 'isSupposedlyFromFindFile' later        Boolean isSupposedlyFromFindFile = (folder == nil);        err = GetHFSFlavorFromPromise // see snippet 14            (dragRef, itemRef, hfsFlavor, isSupposedlyFromFindFile);    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 12.</b> Receiving <CODE>flavorTypeHFS</CODE></p>	</TD></TR></TABLE></CENTER>                  <H3>Setting the Drop Location         </H3>                  <P>This part of receiving <CODE>flavorTypePromiseHFS</CODE>         is relatively easy. First, create an alias to the drop         location, which for <CODE>flavorTypePromiseHFS</CODE> should         always be a directory. Next, copy the alias into an         <CODE>AEDesc</CODE>. Finally, call         <CODE>SetDropLocation</CODE>. This procedure is demonstrated         in the next snippet.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr SetDropFolder    (DragReference dragRef, const FSSpec *folder){    OSErr err = noErr;    AliasHandle aliasH;    if (!(err = NewAliasMinimal (folder,&amp;aliasH)))    {        HLockHi ((Handle) aliasH);        if (!(err = MemError ( )))        {            Size size = GetHandleSize ((Handle) aliasH);            if (!(err = MemError ( )))            {                AEDesc dropLoc;                if (!(err = AECreateDesc                    (typeAlias,*aliasH,size,&amp;dropLoc)))                {                    OSErr err2;                    err = SetDropLocation (dragRef,&amp;dropLoc);                    err2 = AEDisposeDesc (&amp;dropLoc);                    if (!err) err = err2;                }            }        }        DisposeHandle ((Handle) aliasH);        if (!err) err = MemError ( );    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 13.</b> Called by Snippet #12</p>	</TD></TR></TABLE></CENTER>                                 <H3>Coping with Find File</H3>                  <P>Many drag receivers would like to be able to receive data         dragged from a Find File results window. The first flavor         most developers would look for in the <CODE>DragReference</CODE> would be         <CODE>flavorTypeHFS</CODE>. However, Find File provides         <CODE>flavorTypePromiseHFS</CODE> instead, in an attempt to work around         Finder bugs mentioned elsewhere in this Technote.</P>           <P><A HREF="#top">Back to top</A></P>         <A NAME="Sidebar"></A>                  <H2>The True Nature of Find File's Evil: A Sidebar</H2>                                    <P>Find File's workaround works pretty well within                  the scope of Finder, but it doesn't work very well                  with many other applications which receive                  <CODE>flavorTypePromiseHFS</CODE>. You'll remember that                  <CODE>flavorTypePromiseHFS</CODE> is a promise to create a file                  which doesn't exist yet, but Find File's results                  window contains only existing files. Right away                  there's semantic conflict. Let's look at a concrete                  example to see how this conflict can cause                  problems: </P>                                    <P>If an email application were to accept                  <CODE>flavorTypePromiseHFS</CODE> as an enclosure to a message                  and assumed that the drag sender were honoring the                  semantics of <CODE>flavorTypePromiseHFS</CODE> as documented in                  this Technote, the email app would probably want to                  set the drop location to its outgoing spool folder                  and delete the file when the associated message                  were successfully sent. After all, the semantics of                  <CODE>flavorTypePromiseHFS</CODE> are to create a file expressly                  for the exclusive use of the receiving app.</P>                                    <P>However, if instead Find File were merely to                  move a pre-existing file into that spool folder,                  the email app might well be deleting the user's                  only copy of that data, and at the very least Find                  File would be moving a file to a place the user                  isn't likely to expect or understand. This is in                  fact what Find File does.</P>                                    <P>Why? Well, since Finder is buggy, Find File                  convinces Finder a drop has occurred and then                  proceeds to delete the dropped file and send                  AppleEvents to Finder to induce it to do what it                  should have done with <CODE>flavorTypeHFS</CODE> on its own.                   The only data Find                  File really wants from Finder is the drop location.                  </P>                                    <P>Regardless of any of the background information                  in this sidebar, your application should conform as                  strictly as possible to the rest of this Technote.</p>     <P><A HREF="#top">Back to top</A></P>                  <A NAME="Section11"></A>         <H2>Working Around Find File</H2>                  <P>The Find File engineers didn't just bludgeon the Finder         into working the way they wanted; they also provided a way         for other applications to receive HFS-related drags         sensibly. It just hasn't been documented until now.</P>                  <P>In your drag tracking handler, retrieve the         <CODE>flavorTypePromiseHFS</CODE> data and compare its <CODE>promisedFlavor</CODE>         field to <CODE>'rWm1'</CODE> (0x72576D31). This is the value which Find         File always uses. If <CODE>promisedFlavor</CODE> has this value, set a         flag to remind you not to call <CODE>SetDropLocation</CODE> later.</P>                  <P>In your drag receive handler, you'd normally call         <CODE>SetDropLocation</CODE> before asking for the <CODE>promisedFlavor</CODE> data.         However, if you're receiving <CODE>flavorTypePromiseHFS</CODE> data from         Find File, skip this step before asking the Drag Manager for         the <CODE>promisedFlavor</CODE> data (and, of course, in this case         <CODE>promisedFlavor</CODE> will always have the value <CODE>'rWm1'</CODE>).          This will         produce <CODE>FSSpec</CODE> data without inducing Find File to move or         copy the file.</P>         <P>And now we can see why the value of <CODE>promisedFlavor</CODE> is         important; if it's <CODE>'rWm1'</CODE>, the data comes from Find File,         and if the value is anything else (we've recommended <CODE>'fssP'</CODE>         [0x66737350]; but if your program already uses         something else, don't worry about it), the data comes from         some other application. Applications other than Find File         should conform to the semantics of         <CODE>flavorTypePromiseHFS</CODE> as documented in this Technote.</P>                  <P>The next snippet shows how to retrieve both flavors, with         some extra checking thrown in to make sure nobody is         confused about Find File.</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr GetHFSFlavorFromPromise    (DragReference dragRef, ItemReference itemRef,        HFSFlavor *hfs, Boolean isSupposedlyFromFindFile){    OSErr             err = noErr;    PromiseHFSFlavor  phfs;    Size              size = sizeof (phfs);    err = GetFlavorData        (dragRef,itemRef,flavorTypePromiseHFS,&amp;phfs,&amp;size,0);    if (!err)    {        if (size != sizeof (phfs))            err = cantGetFlavorErr;        else        {            Boolean isFromFindFile =                phfs.promisedFlavor == kPromisedFlavorFindFile;            if (isSupposedlyFromFindFile != isFromFindFile)                err = paramErr;            else            {                size = sizeof (hfs-&gt;fileSpec);                err = GetFlavorData                    (dragRef,itemRef,phfs.promisedFlavor,                        &amp;(hfs-&gt;fileSpec),&amp;size,0);                if (!err)                {                    Size minSize = MinimumBytesForFSSpec                        (&amp;(hfs-&gt;fileSpec));                    // see snippet 3 for MinimumBytesForFSSpec                    if (size &lt; minSize)                        err = cantGetFlavorErr;                    else                    {                        hfs-&gt;fileType     = phfs.fileType;                        hfs-&gt;fileCreator  = phfs.fileCreator;                        hfs-&gt;fdFlags      = phfs.fdFlags;                    }                }            }        }    }    return err;}</pre></TD></TR><TR>	<td align="left"><P><b>Snippet 14.</b> Called by Snippet #12</p>	</TD></TR></TABLE></CENTER>  <P><A HREF="#top">Back to top</A></P>         <A NAME="Summary"></A>                  <H2>Summary</H2>                  <P>There are two file system-oriented flavor types         associated with the Drag Manager. One,         <CODE>flavorTypeHFS</CODE>, is a relatively simple flavor         which can be handled like most others except for some simple         workarounds for bugs in Finder. The other,         <CODE>flavorTypePromiseHFS</CODE>, is probably the most         complex flavor type developers will encounter and requires a         high degree of care, attention to detail, and tolerance for         intrusive workarounds to implement correctly.</P>                  <P>Here are some important lessons worth repeating: </P>                  <UL>            <LI>For existing files, use <CODE>flavorTypeHFS</CODE>. For files            which don't yet exist but you're willing to create, use            <CODE>flavorTypePromiseHFS</CODE>.</li>                        <LI>Don't confuse the Drag Manager's concept of promising            flavor data with <CODE>flavorTypePromiseHFS</CODE>. They're both            promises, but they are significantly different kinds of promises.</li>                        <LI>Check all error codes and build assertions into your            code to avoid being surprised by applications which don't            conform to the behavior you expect.</li>                        <LI><CODE>GetDropLocation</CODE> and <CODE>SetDropLocation</CODE> are your friends.</li>                        <LI>When receiving <CODE>flavorTypePromiseHFS</CODE> for a file you            plan to delete, make sure you do the right thing with            Find File to avoid destroying data the user wanted to keep.</li>         </UL>        <P><A HREF="#top">Back to top</A></P><a name="References"></a><H2>References</H2>            <p><I>The Drag Manager Programmer's Guide</I>, available            on the Developer CD Series Mac OS SDK disc. In addition, you can             <A HREF = "pdf/dmpg.pdf"> download it here.</A></p>                        <p><CODE>AEDesc</CODE> is an AppleEvent Manager data            structure documented starting on page 3-12 of             <a href="http://developer.apple.com/documentation/mac/IAC/IAC-98.html">            <I>Inside Macintosh: Interapplication Communication</I></A>. </p>  <P><A HREF="#top">Back to top</A></P>        <A NAME="Appendices"></A>                  <H2>Appendices</H2>                  <P>The Appendices to this Technote contain code snippets         which are necessary for a full understanding of other         snippets in the Technote but would have obstructed the flow         of the main text stream.</P>                  <H3>Appendix A</H3>                  <P>This is a utility function called by the functions in         Appendices B and C. It allocates and populates a         <CODE>CInfoPBRec</CODE> so that it contains information on         the given directory. The caller is expected to dispose the         <CODE>CInfoPBRec</CODE> if the function does not return an error.</P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr FSpGetDirInfo    (const FSSpec *spec, CInfoPBPtr *cipbpp){    OSErr err = noErr;    CInfoPBPtr pbp = (CInfoPBPtr) NewPtrClear (sizeof (*pbp));    *cipbpp = nil;    if (!(err = MemError ( )))    {        pbp-&gt;dirInfo.ioVRefNum = spec-&gt;vRefNum;        pbp-&gt;dirInfo.ioDrDirID = spec-&gt;parID;        pbp-&gt;dirInfo.ioNamePtr = (StringPtr) spec-&gt;name;        err = PBGetCatInfoSync (pbp);        if (!err &amp;&amp; !(pbp-&gt;hFileInfo.ioFlAttrib &amp; ioDirMask))            err = dirNFErr;        if (err)            DisposePtr ((Ptr) pbp);        else            *cipbpp = pbp;    }    return err;}</pre>	</TD></TR></TABLE></CENTER>                                <H3>Appendix B</H3>                  <P>These functions are intended to follow the same API as         <CODE>FSpGetFinfo</CODE> and <CODE>FSpSetFInfo</CODE>. They both call         <CODE>FSpGetDirInfo</CODE>, which can be found in Appendix         A.</P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr FSpGetDInfo    (const FSSpec *spec, DInfo *fndrInfo){    OSErr err = noErr;    CInfoPBPtr cipbp;    if (!(err = FSpGetDirInfo (spec,&amp;cipbp)))    {        *fndrInfo = cipbp-&gt;dirInfo.ioDrUsrWds;        DisposePtr ((Ptr) cipbp);        if (!err) err = MemError ( );    }    return err;}static pascal OSErr FSpSetDInfo    (const FSSpec *spec, const DInfo *fndrInfo){    OSErr err = noErr;    CInfoPBPtr cipbp;    if (!(err = FSpGetDirInfo (spec,&amp;cipbp)))    {        cipbp-&gt;dirInfo.ioDrUsrWds    = *fndrInfo;        cipbp-&gt;dirInfo.ioDrDirID    = spec-&gt;parID;        err = PBSetCatInfoSync (cipbp);        DisposePtr ((Ptr) cipbp);        if (!err) err = MemError ( );    }    return err;}</pre>	</TD></TR></TABLE></CENTER>                        <H3>Appendix C</H3>                  <P>This function returns the directory ID of a given folder.         It calls <CODE>FSpGetDirInfo</CODE>, which can be found in Appendix A.         </P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr GetDirectoryID (const FSSpec *spec, long *dirID){    OSErr err = noErr;    CInfoPBPtr cipbp;    if (!(err = FSpGetDirInfo (spec,&amp;cipbp)))    {        *dirID = cipbp-&gt;dirInfo.ioDrDirID;        DisposePtr ((Ptr) cipbp);        if (!err) err = MemError ( );    }    return err;}</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p> <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (92K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1085.pdf">Download</A></P>               </TD>            </TR>   <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/bluebook.gif" width=22 height=23 align=bottom alt="Bluebook gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of Drag Manager Programmer's Guide (378K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/dmpg.pdf">Download</A></P>               </TD>            </TR>            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/redbook.gif" width=20 height=20 align=bottom alt="Redbook gif"></P>               </TD>               <td align="left">                  <P>Binhexed FinderDragPro Metrowerks Project (220K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="downloads/tn_1085.1.hqx">Download</A></P>               </TD>            </TR>  </table><BR>         <P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1085.html%3Fid%3DDTS10002926-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1085.html%3Fid%3DDTS10002926-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1085.html%3Fid%3DDTS10002926-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>