<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h1>

<FONT COLOR="#000066">

<a name="136">

 <a name="//apple_ref/occ/cl/NSObject">NSObject</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

none <em>(NSObject is a root class)

</em>

<p><B>Conforms To:</B><BR>

NSObject



<p><B>Declared In:	</B><BR>

Foundation/NSObject.h



<p><p>

<a name="164"></a>

<HR WIDTH=75% SIZE=4 ALIGN=LEFT>

<H3>

<FONT COLOR="#201040">

Class At A Glance

</FONT>

</H3>

<dl><a name="165"></a>

<dt><h4>Purpose</h4>

<dd><dl>

<dt>NSObject is the root class of most Objective-C class hierarchies. Through NSObject, objects inherit a basic interface to the run-time system and the ability to behave as Objective-C objects.

</dl></dd>

<a name="167"></a>

<dt><h4>Principal Attributes</h4>

</dl><ul><li><code>isa </code>pointer<br>

</ul><dl><a name="169"></a>

<dt><h4>Creation</h4>

<dd><dl>

<dt>+ alloc

<dt>+ allocWithZone:

<dt>- init	(designated initializer)

</dl></dd>

</dl><HR WIDTH=75% SIZE=4 ALIGN=LEFT>

<p><a name="174"></a>

<a name="description"></a>

<H2>Class Description

</H2>

NSObject is the root class of most Objective-C class hierarchies; it has no superclass. From NSObject, other classes inherit a basic interface to the run-time system for the Objective-C language, and its instances obtain their ability to behave as objects.<p>

NSObject adopts the NSObject protocol. The NSObject protocol allows for multiple root objects. For example, NSProxy is another root class-it does not inherit from NSObject but adopts the NSObject protocol so that it shares a common interface with other Objective-C objects. Some of the methods discussed below are declared by NSObject protocol, not this class.<p>

Among other things, the NSObject class provides inheriting classes with a framework for creating, initializing, deallocating, copying, comparing, archiving and distributing objects, for performing methods selected at run-time, for querying an object about its methods and its position in the inheritance hierarchy, and for forwarding messages to other objects. For example, to ask an object what class it belongs to, you'd send it a <code>class</code> message. To find out whether it implements a particular method, you'd send it a <code>respondsToSelector:</code> message.<p>

The NSObject class is mostly an abstract class; programs use instances of classes that inherit from NSObject, but rarely instances of NSObject itself.<p>

<h3>

<a name="179">

 Initializing an Object to Its Class

</a>

</h3>

Every object that inherits directly or indirectly from NSObject is connected to the run-time system through its <code>isa</code> instance variable. <code>isa</code> identifies the object's class; it references a structure that's compiled from the class definition. Through <code>isa</code>, an object can find whatever information it needs at run-time-such as its place in the inheritance hierarchy, the size and structure of its instance variables, and the location of the method implementations it can perform in response to messages.<p>

The installation of the class structure-the initialization of <code>isa</code>-is one of the responsibilities of class methods that create (allocate memory for) new instances: <code>alloc</code>, <code>allocWithZone:</code> and <code>new</code>. In other words, a small part of instance initialization is taken care of by these creation methods; it's not left to the methods, such as <code>init</code>, that initialize individual objects with their particular characteristics.<p>

<h3>

<a name="182">

 Instance and Class Methods

</a>

</h3>

The run-time system treats methods defined in the root class in a special way:<p>

<em>Instance methods defined in a root class can be performed both by instances and by class objects.</em> <p>

Therefore, all class objects have access to the instance methods defined in the root class. Any class object can perform any root instance method, provided it doesn't have a class method with the same name.<p>

For example, a class object could be sent messages to perform NSObject's <code>respondsToSelector:</code> and <code>performSelector:withObject:</code> instance methods:<p>

<blockquote><pre>SEL method = @selector(riskAll:);<br>    <br>if ( [MyClass respondsToSelector:method] )<br>    [MyClass performSelector:method withObject:self];

</pre></blockquote><p>Note that the only instance methods available to a class object are those defined in its root class. In the example above, if MyClass had reimplemented either <code>respondsToSelector:</code> or <code>performSelector:withObject:</code>, those new versions would be available only to instances. The class object for MyClass could perform only the versions defined in the NSObject class. (Of course, if MyClass had implemented <code>respondsToSelector:</code> or <code>performSelector:withObject:</code> as class methods rather than instance methods, the class would perform those new versions.)<p>

<h3>

<a name="189">

 Interface Conventions

</a>

</h3>

The NSObject class defines a number of methods that subclasses are expected to override. Often, NSObject's default implementation simply returns <code>self</code>. Putting these "empty" methods in the NSObject class serves two purposes:<p>

<ul><li>It means that every object can readily respond to certain standard messages, such as <code>init</code>, even if the response is to do nothing. It's not necessary to check (using <code>respondsToSelector:</code>) before sending the message.<p>

<li>It establishes conventions that, when followed by all classes, make object interactions more reliable. These conventions are explained in full under the method descriptions.<p>

</ul><HR WIDTH=50% ALIGN=LEFT>

<h2>Adopted Protocols</h2>  





<dl>

<dt>NSObject<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/autorelease" target="_top">- autorelease</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/class" target="_top">- class</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/conformsToProtocol:" target="_top">- conformsToProtocol:</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/description" target="_top">- description</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/hash" target="_top">- hash</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/isEqual:" target="_top">- isEqual:</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/isKindOfClass:" target="_top">- isKindOfClass:</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/isMemberOfClass:" target="_top">- isMemberOfClass:</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/isProxy" target="_top">- isProxy</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/performSelector:" target="_top">- performSelector:</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/performSelector:withObject:" target="_top">- performSelector:withObject:</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/performSelector:withObject:withObject:" target="_top">- performSelector:withObject:withObject:</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">- release</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">- respondsToSelector:</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/retain" target="_top">- retain</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/retainCount" target="_top">- retainCount</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/self" target="_top">- self</a><dt><a href="../NSObject.html#//apple_ref/occ/intfm/NSObject/superclass" target="_top">- superclass</a><dt><a href="../NSObject/NSObject.html#//apple_ref/occ/intfm/NSObject/zone" target="_top">- zone</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<a name="214">

<HR WIDTH=50% ALIGN=LEFT>

<h2>Method Types

</h2>

</a><dl>

<dt>Initializing the class<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSObject/initialize">+ initialize</a><dt><a href="#//apple_ref/occ/clm/NSObject/load">+ load</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Creating, copying, and deallocating objects	<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSObject/new">+ new</a><dt><a href="#//apple_ref/occ/clm/NSObject/alloc">+ alloc</a><dt><a href="#//apple_ref/occ/clm/NSObject/allocWithZone:">+ allocWithZone:</a><dt><a href="#//apple_ref/occ/instm/NSObject/init">- init</a><dt><a href="#//apple_ref/occ/instm/NSObject/copy">- copy</a><dt><a href="#//apple_ref/occ/clm/NSObject/copyWithZone:">+ copyWithZone:</a><dt><a href="#//apple_ref/occ/instm/NSObject/mutableCopy">- mutableCopy</a><dt><a href="#//apple_ref/occ/clm/NSObject/mutableCopyWithZone:">+ mutableCopyWithZone:</a><dt><a href="#//apple_ref/occ/instm/NSObject/dealloc">- dealloc</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Identifying classes<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSObject/class">+ class</a><dt><a href="#//apple_ref/occ/clm/NSObject/superclass">+ superclass</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Comparing objects<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSObject/isEqual:">- isEqual:</a><dt><a href="#//apple_ref/occ/instm/NSObject/hash">- hash</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Testing class functionality<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSObject/instancesRespondToSelector:">+ instancesRespondToSelector:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Testing protocol conformance<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSObject/conformsToProtocol:">+ conformsToProtocol:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Obtaining method information<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSObject/methodForSelector:">- methodForSelector:</a><dt><a href="#//apple_ref/occ/clm/NSObject/instanceMethodForSelector:">+ instanceMethodForSelector:</a><dt><a href="#//apple_ref/occ/clm/NSObject/instanceMethodSignatureForSelector:">+ instanceMethodSignatureForSelector:</a><dt><a href="#//apple_ref/occ/instm/NSObject/methodSignatureForSelector:">- methodSignatureForSelector:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Describing objects<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSObject/description">+ description</a><dt><a href="#//apple_ref/occ/instm/NSObject/description">- description</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Posing<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSObject/poseAsClass:">+ poseAsClass:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Sending messages<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSObject/performSelector:withObject:afterDelay:">- performSelector:withObject:afterDelay:</a><dt><a href="#//apple_ref/occ/instm/NSObject/performSelector:withObject:afterDelay:inModes:">- performSelector:withObject:afterDelay:inModes:</a><dt><a href="#//apple_ref/occ/clm/NSObject/cancelPreviousPerformRequestsWithTarget:selector:object:">+ cancelPreviousPerformRequestsWithTarget:<br>selector:object:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Forwarding messages<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSObject/forwardInvocation:">- forwardInvocation:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Error handling<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSObject/doesNotRecognizeSelector:">- doesNotRecognizeSelector:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Archiving<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSObject/awakeAfterUsingCoder:">- awakeAfterUsingCoder:</a><dt><a href="#//apple_ref/occ/instm/NSObject/classForArchiver">- classForArchiver</a><dt><a href="#//apple_ref/occ/instm/NSObject/classForCoder">- classForCoder</a><dt><a href="#//apple_ref/occ/instm/NSObject/classForPortCoder">- classForPortCoder</a><dt><a href="#//apple_ref/occ/instm/NSObject/replacementObjectForArchiver:">- replacementObjectForArchiver:</a><dt><a href="#//apple_ref/occ/instm/NSObject/replacementObjectForCoder:">- replacementObjectForCoder:</a><dt><a href="#//apple_ref/occ/instm/NSObject/replacementObjectForPortCoder:">- replacementObjectForPortCoder:</a><dt><a href="#//apple_ref/occ/clm/NSObject/setVersion:">+ setVersion:</a><dt><a href="#//apple_ref/occ/clm/NSObject/version">+ version</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH=50% ALIGN=LEFT>

<a name="266"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  





<a name="267"></a>

<h3>

 <a name="//apple_ref/occ/clm/NSObject/alloc">alloc</a>

</h3>

+ (id)<code>alloc

</code>

<P>Returns a new instance of the receiving class. The <code>isa</code> instance variable of the new instance is initialized to a data structure that describes the class; memory for all other instance variables is set to 0. The new instance will be allocated from the default zone-use <code>allocWithZone:</code> to specify a particular zone.<p>

An <code>ini</code><code>t...</code> method should be used to complete the initialization process. For example:<p>

<blockquote><pre>TheClass *newObject = [[TheClass alloc] init];

</pre></blockquote><p>Subclasses shouldn't override <code>alloc</code> to include initialization code. Instead, class-specific versions of <code>init</code><code>...</code> methods should be implemented for that purpose. Class methods can also be implemented to combine allocation and initialization, similar to the <code>new</code> class method.<p>

Note that it's your responsibility to release objects (with either <code>release</code> or <code>autorelease</code>) returned by <code>alloc...</code> methods.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/init">- init</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="275"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/allocWithZone:">allocWithZone:</a></h3>

+ <code>(id)allocWithZone:</code>(NSZone *)<em>zone

</em>

<P>Returns a new instance of the receiving class where memory for the new instance is allocated from <em>zone</em>. The <code>isa</code> instance variable of the new instance is initialized to a data structure that describes the class; memory for its other instance variables is set to 0.<em> If zone is NULL,</em> the new instance will be allocated from the default zone (as returned by <code>NSDefaultMallocZone()</code>).<p>

An <code>init</code><code>...</code> method should be used to complete the initialization process. For example:<p>

<blockquote><pre>TheClass *newObject = [[TheClass allocWithZone:someZone] init];

</pre></blockquote><p>Subclasses shouldn't override <code>allocWithZone:</code> to include any initialization code. Instead, class-specific versions of <code>init</code><code>...</code> methods should be implemented for that purpose.<p>

When one object creates another, it's often a good idea to make sure they're both allocated from the same region of memory. The <code>zone</code> method (declared in the NSObject protocol) can be used for this purpose; it returns the zone where the receiver is located. For example:<p>

<blockquote><pre>id myCompanion = [[TheClass allocWithZone:[self zone]] init];

</pre></blockquote><p>Note that it's your responsibility to release objects (with either <code>release</code> or <code>autorelease</code>) returned by <code>alloc...</code> methods.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSObject/alloc">+ alloc</a></code>, <a href="#//apple_ref/occ/instm/NSObject/init"><code>- init</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="285"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/cancelPreviousPerformRequestsWithTarget:selector:object:">cancelPreviousPerformRequestsWithTarget:selector:object:</a></h3>

+ (void)<code>cancelPreviousPerformRequestsWithTarget:</code>(id)<em>aTarget<br>

</em><code>selector:</code>(SEL)<em>aSelector<br>

</em><code>object:</code>(id)<em>anArgument

</em>

<P>Cancels perform requests previously registered with the <code>performSelector:withObject:afterDelay:</code> instance method. All perform requests having the same target <em>aTarget</em>, and argument <em>anArgument</em>, (determined using <code>isEqual:</code>), and the same selector <em>aSelector</em>, will be canceled. This method removes perform requests only in the current run loop, not all run loops.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="288"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/class">class</a></h3>

+ (Class)<code>class

</code>

<P>Returns the class object.<p>

Only refer to a class by name when it is the receiver of a message. In all other cases, the class object must be obtained through this, or a similar method. For example, here SomeClass is passed as an argument to the <code>isKindOfClass:</code> method (declared in the NSObject protocol):<p>

<blockquote><pre>BOOL test = [self isKindOfClass:[SomeClass class]];

</pre></blockquote><p><B>See also: </B>  

<code><a href="../NSObjectIsStillInvalid.HTML#//apple_ref/occ/instm/NSObject/class" target="_top">- clas</code><code>s</code> (NSObject protocol)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="294"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/conformsToProtocol:">conformsToProtocol:</a></h3>

+ (BOOL)<code>conformsToProtocol:</code>(Protocol *)<em>aProtocol

</em>

<P>Returns YES if the receiving class conforms to <em>aProtocol</em>, NO otherwise.<p>

A class is said to "conform to" a protocol if it adopts the protocol or inherits from another class that adopts it. Protocols are adopted by listing them within angle brackets after the interface declaration. For example, here MyClass adopts the fictitious AffiliationRequests and Normalization protocols:<p>

<blockquote><pre>@interface MyClass : NSObject &lt;AffiliationRequests, Normalization&gt;

</pre></blockquote><p>A class also conforms to any protocols that are incorporated in the protocols it adopts or inherits. Protocols incorporate other protocols in the same way that classes adopt them. For example, here the AffiliationRequests protocol incorporates the Joining protocol:<p>

<blockquote><pre>@protocol AffiliationRequests &lt;Joining&gt;

</pre></blockquote><p>If a class adopts a protocol that incorporates another protocol, it must also implement all the methods in the incorporated protocol or inherit those methods from a class that adopts it. <p>

This method determines conformance solely on the basis of the formal declarations in header files, as illustrated above. It doesn't check to see whether the methods declared in the protocol are actually implemented-that's the programmer's responsibility.<p>

The Protocol required as this method's argument can be specified using the <code>@protocol()</code> directive:<p>

<blockquote><pre>BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/conformsToProtocol:">- conformsToProtocol:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="306"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/copyWithZone:">copyWithZone:</a></h3>

+ (id)<code>copyWithZone:</code>(NSZone *)<em>zone

</em>

<P>Returns self. This method exists so that class objects can be used in situations where you need an object that conforms to the NSCopying protocol. For example, this method lets you use a class object as a key to an NSDictionary. You should not override this method.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/">- </a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="310"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/description">description</a></h3>

+ (NSString *)<code>description

</code>

<P>Returns an NSString that represents the contents of the receiving class. The debugger's <code>print-object</code> command invokes this method to produce a textual description of an object.<p>

NSObject's implementation of this method simply prints the name of the class.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/description">- description</a></code><code>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="315"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/initialize">initialize</a></h3>

+ (void)<code>initialize

</code>

<P>Initializes the class before it's used (before it receives its first message). The run-time system sends an <code>initialize</code> message to each class just before the class, or any class that inherits from it, is sent its first message from within the program. Each class receives the <code>initialize</code> message just once from the run-time system. Superclasses will receive this message before subclasses.<p>

For example, if the first message your program sends is this:<p>

<blockquote><pre>[NSApplication new]

</pre></blockquote><p>the run-time system invokes these three <code>initialize</code> messages:<p>

<blockquote><pre>[NSObject initialize];<br>[NSResponder initialize];<br>[NSApplication initialize];

</pre></blockquote><p>because NSApplication is a subclass of NSResponder and NSResponder is a subclass of NSObject. All the <code>initialize</code> messages precede the <code>new</code> message.<p>

If your program later begins to use the NSText class,<p>

<blockquote><pre>[NSText instancesRespondToSelector:someSelector]

</pre></blockquote><p>the run-time system invokes these additional <code>initialize</code> messages:<p>

<blockquote><pre>[NSView initialize];<br>[NSText initialize];

</pre></blockquote><p>because NSText inherits from NSObject, NSResponder, and NSView. The <code>instancesRespondToSelector:</code> message is sent only after all these classes are initialized. Note that the <code>initialize</code> messages to NSObject and NSResponder aren't repeated.<p>

You can implement your own versions of <code>initialize</code> to provide class-specific initialization as needed. <p>

Normally the run-time system sends a class just one <code>initialize</code> message. However, if for some reason an application or the run-time system generates additional <code>initialize</code> messages, it is a good idea to prevent code from being invoked more than once:<p>

<blockquote><pre>+ (void)initialize<br>{<br>    static BOOL tooLate = NO;<br>    if ( !tooLate ) {<br>        /* put initialization code here */<br>        tooLate = YES;<br>    }<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/init">- init</a></code>, <code><a href="../NSObjectIsStillInvalid.HTML#//apple_ref/occ/instm/NSObject/class" target="_top">- clas</code><code>s</code> (NSObject protocol)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="332"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/instanceMethodForSelector:">instanceMethodForSelector:</a></h3>

+ (IMP)<code>instanceMethodForSelector:</code>(SEL)<em>aSelector

</em>

<P>Locates and returns the address of the implementation for the <em>aSelector</em> instance method. An error is generated if instances of the receiver can't respond to <em>aSelector</em> messages.<p>

Use this method to ask the class object for the implementation of instance methods only. To ask the class for the implementation of a class methods, send the <code>methodForSelector:</code> instance method to the class instead.<p>

<code>instanceMethodForSelector:</code>, and the function pointer it returns, are subject to the same constraints as those described for <code>methodForSelector:</code>. See <code>methodForSelector:</code> for description of the IMP return value.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="337"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/instanceMethodSignatureForSelector:">instanceMethodSignatureForSelector:</a></h3>

+ (NSMethodSignature *)<code>instanceMethodSignatureForSelector:</code>(SEL)<em>aSelector

</em>

<P>Returns an NSMethodSignature object that contains a description of the <em>aSelector</em> class method, or <code>nil</code> if the <em>aSelector</em> class method can't be found.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/methodSignatureForSelector:">- methodSignatureForSelector:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="341"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/instancesRespondToSelector:">instancesRespondToSelector:</a></h3>

+ (BOOL)<code>instancesRespondToSelector:</code>(SEL)<em>aSelector

</em>

<P>Returns YES if instances of the class are capable of responding to <em>aSelector</em> messages, NO otherwise. To ask the class whether it, rather than its instances, can respond to a particular message, send the <code>respondsToSelector:</code> NSObject protocol instance method to the class instead.<p>

If<em> aSelector</em> messages are forwarded to other objects, instances of the class will be able to receive those messages without error even though this method returns NO.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/forwardInvocation:">- forwardInvocation:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="346"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/load">load</a></h3>

+(void)<code>load

</code>

<P>This method is invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading. It is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly-loaded class or category implements a method that can respond. As an example, when Interface Builder loads a palette, the <code>load</code> method is sent to each class and category in the palette.<p>

<code>load</code> is usually invoked before <code>initialize</code>. It is usually the very first method sent to the class, although this isn't guaranteed. The order in which classes are loaded is also not guaranteed, to the point that superclasses aren't even guaranteed to be loaded before all of their subclasses. Because you can't rely on other classes being loaded at the point when your class is sent a load message, you should be extremely careful when messaging other classes from within your <code>load</code> method.<p>

Due to the amount of uncertainty about the environment at the point that <code>load</code> is invoked, you should avoid using <code>load</code> whenever possible. All class-specific initialization should be done in the class's <code>initialize</code> method.<p>

Note that although <code>load</code> essentially replaces NEXTSTEP's <code>finishLoading:</code> method, the circumstances surrounding their invocation is slightly different. Consult your NEXTSTEP Developer documentation if you are porting code that uses <code>finishLoading:</code>.<p>

<B>See also: </B>  

<code><a href="../NSProxy/NSProxy.html#//apple_ref/occ/clm/NSProxy/load" target="_top">+ load</code> (NSProxy)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="353"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/mutableCopyWithZone:">mutableCopyWithZone:</a></h3>

+ (id)<code>mutableCopyWithZone:</code>(NSZone *)<em>zone

</em>

<P>Returns self. This method exists so that class objects can be used in situations where you need an object that conforms to the NSMutableCopying protocol. For example, this method lets you use a class object as a key to an NSDictionary. You should not override this method.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="356"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/new">new</a></h3>

+ (id)<code>new

</code>

<P>Allocates a new instance of the receiving class, sends it an <code>init</code> message, and returns the initialized object.<p>

This method is a combination of <code>alloc</code> and <code>init</code>. Like <code>alloc</code>, it initializes the <code>isa</code> instance variable of the new object so that it points to the class data structure. It then invokes the <code>init</code> method to complete the initialization process.<p>

Unlike <code>alloc</code>, <code>new</code> is sometimes reimplemented in subclasses to have it invoke a class-specific initialization method. If the <code>init</code><code>...</code> method includes arguments, they're typically reflected in a <code>new</code><code>...</code> method as well. For example:<p>

<blockquote><pre>+ newArg:(int)tag arg:(struct info *)data<br>{<br>    return [[self alloc] initArg:tag arg:data];<br>}

</pre></blockquote><p>However, there's little point in implementing a <code>new...</code> method if it's simply a shorthand for <code>alloc</code> and <code>init...</code>, as shown above. Often <code>new...</code> methods will do more than just allocation and initialization. In some classes, they manage a set of instances, returning the one with the requested properties if it already exists, allocating and initializing a new instance only if necessary. For example:<p>

<blockquote><pre>+ newArg:(int)tag arg:(struct info *)data<br>{<br>    MyClass *theInstance;<br><br>    if ( theInstance = findTheObjectWithTheTag(tag) )<br>        return theInstance;<br>    return [[self alloc] initArg:tag arg:data];<br>}

</pre></blockquote><p>Although it's appropriate to define new <code>new...</code> methods in this way, the <code>alloc</code> and <code>allocWithZone:</code> methods should never be augmented to include initialization code.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="365"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/poseAsClass:">poseAsClass:</a></h3>

+ (void)<code>poseAsClass:</code>(Class)<em>aClass

</em>

<P>Causes the receiving class to "pose as" its <em>aClass</em> superclass. The receiver takes the place of <em>aClass</em> in the inheritance hierarchy; all messages sent to <em>aClass</em> will actually be delivered to the receiver. The receiver must be defined as a subclass of <em>aClass</em>. It can't declare any new instance variables of its own, but it can define new methods and override methods defined in <em>aClass</em>. The <code>poseAsClass:</code> message should be sent before any messages are sent to <em>aClass</em> and before any instances of <em>aClass</em> are created.<p>

This facility allows you to add methods to an existing class by defining them in a subclass and having the subclass substitute for the existing class. The new method definitions will be inherited by all subclasses of the superclass. Care should be taken to ensure that this doesn't generate errors.<p>

A subclass that poses as its superclass still inherits from the superclass. Therefore, none of the functionality of the superclass is lost in the substitution. Posing doesn't alter the definition of either class.<p>

Posing is useful as a debugging tool, but category definitions are a less complicated and more efficient way of augmenting existing classes. Posing admits only two possibilities that are absent from categories:<p>

<ul><li>A method defined by a posing class can override any method defined by its superclass. Methods defined in categories can replace methods defined in the class proper, but they cannot reliably replace methods defined in other categories. If two categories define the same method, one of the definitions will prevail, but there's no guarantee which one.<p>

<li>A method defined by a posing class can, through a message to <code>super</code>, incorporate the superclass method it overrides. A method defined in a category can replace a method defined elsewhere by the class, but it can't incorporate the method it replaces.<p>

</ul><hr WIDTH=25% ALIGN=LEFT>

<a name="373"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/setVersion:">setVersion:</a></h3>

+ (void)<code>setVersion:</code>(int)<em>aVersion

</em>

<P>Sets the class version number to <em>aVersion</em>. The version number is helpful when instances of the class are to be archived and reused later. The default version is 0.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSObject/version">+ version</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="377"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/superclass">superclass</a></h3>

+ (Class)<code>superclass

</code>

<P>Returns the class object for the receiver's superclass.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSObject/class">+ class</a></code>, <code><a href="../NSObjectIsStillInvalid.HTML#//apple_ref/occ/instm/NSObject/superclass" target="_top">- superclas</code><code>s </code>(NSObject protocol)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="381"></a>

<h3> <a name="//apple_ref/occ/clm/NSObject/version">version</a></h3>

+ (int)<code>version

</code>

<P>Returns the version number assigned to the class. If no version has been set, the default is 0. <p>

Version numbers are needed for decoding or unarchiving, so that older versions of an object can be detected and decoded correctly. <p>

Caution should be taken when obtaining the version from within NSCoding protocol or other methods. Use the class name explicitly when getting a class version number:<p>

<blockquote><pre>version = [MyClass version];

</pre></blockquote><p>Don't simply send <code>version</code> to the return value of <code>class</code>-a subclass version number may be returned instead.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSObject/setVersion:">+ setVersion:</a></code><code>, </code><code><a href="../NSCoder/NSCoder.html#//apple_ref/occ/clm/NSCoder/versionForClassName:" target="_top">versionForClassName</code><code>: </code>(NSCoder)</a>

<p><HR WIDTH=50% ALIGN=LEFT>

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="390"></a>

<h3>

 <a name="//apple_ref/occ/instm/NSObject/awakeAfterUsingCoder:">awakeAfterUsingCoder:</a>

</h3>

- (id)<code>awakeAfterUsingCoder:</code>(NSCoder *)<em>aDecoder

</em>

<P>Overridden by subclasses to substitute another object in place of the object that was decoded and subsequently received this message. This method can be used to eliminate redundant objects created by the coder. For example, if after decoding an object you discover that an equivalent object already exists, you can return the existing object. If a replacement is returned, your overriding method is responsible for releasing the receiver. To prevent the accidental use of the receiver after its replacement has been returned, you should invoke the receiver's <code>release</code> method to release the object immediately. <p>

This method is invoked by NSCoder. NSObject's implementation simply returns <code>self</code>. <p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/classForCoder">- classForCoder</a></code>, <a href="#//apple_ref/occ/instm/NSObject/replacementObjectForCoder:"><code>- replacementObjectForCoder:</a></code>, <code><a href="../NSCoding/NSCoding.html#//apple_ref/occ/instm/NSCoding/initWithCoder:" target="_top">- initWithCode</code><code>r:</code>(NSCoding protocol)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="395"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/classForArchiver">classForArchiver</a></h3>

- (Class)<code>classForArchiver

</code>

<P>Overridden by subclasses to substitute a class other than its own during archiving. For example, the private subclasses of a class cluster substitute the name of their public superclass when being archived. This method allows specialized behavior for archiving-override <code>classForCoder</code> to add general coding behavior. This method is invoked by NSArchiver. NSObject's implementation returns the object returned by<code> </code><code>classForCoder</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/replacementObjectForArchiver:">- replacementObjectForArchiver:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="399"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/classForCoder">classForCoder</a></h3>

- (Class)<code>classForCoder

</code>

<P>Overridden by subclasses to substitute a class other than its own during coding. For example, the private subclasses of a class cluster substitute the name of their public superclass when being archived. This method is invoked by NSCoder. NSObject's implementation returns the receiver's class.<p>

<B>See also: </B>  

 <a href="#//apple_ref/occ/instm/NSObject/awakeAfterUsingCoder:"><code>- awakeAfterUsingCoder:</a></code>, <a href="#//apple_ref/occ/instm/NSObject/replacementObjectForCoder:"><code>- replacementObjectForCoder:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="403"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/classForPortCoder">classForPortCoder</a></h3>

- (Class)<code>classForPortCoder

</code>

<P>Overridden by subclasses to substitute a class other than its own for distribution encoding. This method allows specialized behavior for distributed objects-override <code>classForCoder</code> to add general coding behavior. This method is invoked by NSPortCoder. NSObject's implementation returns the class returned by <code>classForCoder</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/replacementObjectForPortCoder:">- replacementObjectForPortCoder:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="407"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/copy">copy</a></h3>

- (id)<code>copy

</code>

<P>Convenience method for classes that adopt the NSCopying protocol. This method returns the object returned by the NSCopying protocol method <code>copyWithZone:</code> where the zone is NULL. An exception is raised if there is no implementation for <code>copyWithZone:</code>.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="410"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/dealloc">dealloc</a></h3>

- (void)<code>dealloc

</code>

<P>Deallocates the memory occupied by the receiver. Subsequent messages to the object will generate an error indicating that a message was sent to a deallocated object (provided that the deallocated memory hasn't been reused yet).<p>

You never send a <code>dealloc</code> message directly. Instead, an object's <code>dealloc</code> method is invoked indirectly through the <code>release</code> NSObject protocol method. See the introduction to the Foundation Kit for more details on the use of these methods.<p>

Subclasses must implement their own versions of <code>dealloc</code> to allow the deallocation of any additional memory consumed by the object-such as dynamically allocated storage for data, or object instance variables that are owned by the deallocated object. After performing the class-specific deallocation, the subclass method should incorporate superclass versions of <code>dealloc</code> through a message to <code>super</code>:<p>

<blockquote><pre>- (void)dealloc {<br>    [companion release];<br>    NSZoneFree(private, [self zone])<br>    [super dealloc];<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="../NSObjectIsStillInvalid.HTML#//apple_ref/occ/instm/NSObject/autorelease" target="_top">- autoreleas</code><code>e</code> (NSObject protocol)</a>, <code><a href="../NSObjectIsStillInvalid.HTML#//apple_ref/occ/instm/NSObject/release" target="_top">- releas</code><code>e</code> (NSObject protocol)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="417"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/description">description</a></h3>

@protocol NSObject



<P>- (NSString *)<code>description

</code>

<P>Returns a NSString that represents the contents of the receiver. The debugger's <code>print-object</code> command indirectly invokes this method to produce a textual description of an object. NSObject's implementation of this method simply prints the name of the receiver's class and the hexadecimal value of its <code>id</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSObject/description">+ description</a></code><code>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="422"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/doesNotRecognizeSelector:">doesNotRecognizeSelector:</a></h3>

- (void)<code>doesNotRecognizeSelector:</code>(SEL)<em>aSelector

</em>

<P>Handles <em>aSelector</em> messages that the receiver doesn't recognize. The run-time system invokes this method whenever an object receives an <em>aSelector</em> message that it can't respond to or forward. This method, in turn, raises an NSInvalidArgumentException, and generates an error message.<p>

<code>doesNotRecognizeSelector:</code> messages are generally sent only by the run-time system. However, they can be used in program code to prevent a method from being inherited. For example, an NSObject subclass might renounce the <code>copy</code> or <code>init</code> method by reimplementing it to include a <code>doesNotRecognizeSelector:</code> message as follows:<p>

<blockquote><pre>- copy<br>{<br>    [self doesNotRecognizeSelector:_cmd];<br>}

</pre></blockquote><p>The <code>_cmd</code> variable identifies the current selector; in this example, it identifies the selector for the <code>copy</code> method. This code prevents instances of the subclass from responding to <code>copy</code> messages or superclasses from forwarding <code>copy</code> messages-although <code>respondsToSelector:</code> will still report that the receiver has access to a <code>copy</code> method.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/forwardInvocation:">- forwardInvocation:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="429"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/forwardInvocation:">forwardInvocation:</a></h3>

- (void)<code>forwardInvocation:</code>(NSInvocation *)<em>anInvocation

</em>

<P>Overridden by subclasses to forward messages to other objects. When an object is sent a message for which it has no corresponding method, the run-time system gives the receiver an opportunity to delegate the message to another receiver. It does this by creating an NSInvocation object representing the message and sending the receiver a <code>forwardInvocation:</code> message containing this NSInvocation as the argument. The receiver's <code>forwardInvocation:</code> method can then choose to forward the message to another object. (If that object can't respond to the message either, it too will be given a chance to forward it.)<p>

The <code>forwardInvocation:</code> message thus allows an object to establish relationships with other objects that will, for certain messages, act on its behalf. The forwarding object is, in a sense, able to "inherit" some of the characteristics of the object it forwards the message to.<p>

An implementation of the <code>forwardInvocation:</code> method has two tasks:<p>

<ul><li>To locate an object that can respond to the message encoded in <em>anInvocation</em>. This need not be the same object for all messages.<p>

<li>To send the message to that object using <em>anInvocation</em>. <em>anInvocation</em> will hold the result, and the run-time system will extract and deliver this result to the original sender.<p>

</ul>In the simple case, in which an object forwards messages to just one destination (such as the hypothetical <code>friend</code> instance variable in the example below), a <code>forwardInvocation:</code> method could be as simple as this:<p>

<blockquote><pre>- (void)forwardInvocation:(NSInvocation *)invocation<br>{<br>    if ([friend respondsToSelector:[invocation selector]])<br>        [invocation invokeWithTarget:friend];<br>    else<br>        [self doesNotRecognizeSelector:aSelector];<br>}

</pre></blockquote><p>The message that's forwarded must have a fixed number of arguments; variable numbers of arguments (in the style of printf()) are not supported.<p>

The return value of the message that's forwarded is returned to the original sender. All types of return values can be delivered to the sender: <code>id</code>s, structures, double-precision floating point numbers. <p>

Implementations of the <code>forwardInvocation:</code> method can do more than just forward messages. <code>forwardInvocation:</code> can, for example, be used to consolidate code that responds to a variety of different messages, thus avoiding the necessity of having to write a separate method for each selector. A <code>forwardInvocation:</code> method might also involve several other objects in the response to a given message, rather than forward it to just one.<p>

To respond to methods that your object does not itself recognize, you must override <code>methodSignatureFromSelector:</code> in addition to <code>forwardInvocation:</code>. The mechanism for forwarding messages uses information obtained from <code>methodSignatureFromSelector:</code> to create the NSInvocation object to be forwarded. Your overriding method must provide an appropriate method signature for the given selector, either by preformulating one or by asking another object for one.<p>

NSObject's implementation of <code>forwardInvocation:</code> simply invokes the <code>doesNotRecognizeSelector:</code> method; it doesn't forward any messages. Thus, if you choose not to implement <code>forwardInvocation:</code>, unrecognized messages will raise an exception. <p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="443"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/hash">hash</a></h3>

@protocol NSObject



<P>- (unsigned)<code>hash

</code>

<P>Returns an integer that can be used as a table address in a hash table structure. NSObject's implementation returns a value based on the object's<code> id</code>. If two objects are equal (as determined by the <code>isEqual:</code> method), they must return the same hash value. This last point is particularly important if you define <code>hash</code> in a subclass and intend to put instances of that subclass into a collection.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="447"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/init">init</a></h3>

- (id)<code>init

</code>

<P>Implemented by subclasses to initialize a new object (the receiver) immediately after memory for it has been allocated. An <code>init</code> message is generally coupled with an <code>alloc</code> or <code>allocWithZone:</code> message in the same line of code:<p>

<blockquote><pre>TheClass *newObject = [[TheClass alloc] init];

</pre></blockquote><p>An object isn't ready to be used until it has been initialized. The version of the <code>init</code> method defined in the NSObject class does no initialization; it simply returns <code>self</code>.<p>

Subclass versions of this method should return the new object (<code>self</code>) after it has been successfully initialized. If it can't be initialized, they should release the object and return <code>nil</code>. In some cases, an <code>init</code> method might release the new object and return a substitute. Programs should therefore always use the object returned by <code>init</code>, and not necessarily the one returned by <code>alloc</code> or <code>allocWithZone:</code>, in subsequent code.<p>

Every class must guarantee that the <code>init</code> method either returns a fully functional instance of the class or raises an exception. Typically this means overriding the method to add class-specific initialization code. Subclass versions of <code>init</code> need to incorporate the initialization code for the classes they inherit from, through a message to <code>super</code>:<p>

<blockquote><pre>- init<br>{<br>    if (self = [super init]) {<br>    /* class-specific initialization goes here */<br>    }<br>    return self;<br>}

</pre></blockquote><p>Note that the message to <code>super</code> precedes the initialization code added in the method. This ensures that initialization proceeds in the order of inheritance.<p>

Subclasses often define <code>init</code><code>...</code> methods with additional arguments to allow specific values to be set. The more arguments a method has, the more freedom it gives you to determine the character of initialized objects. Classes often have a set of <code>init...</code> methods, each with a different number of arguments. For example:<p>

<blockquote><pre>- init;<br>- initArg:(int)tag;<br>- initArg:(int)tag arg:(struct info *)data;

</pre></blockquote><p>The convention is that at least one of these methods, usually the one with the most arguments, includes a message to <code>super</code> to incorporate the initialization of classes higher up the hierarchy. This method is called the <em>designated initializer</em> for the class. The other <code>init...</code> methods defined in the class directly or indirectly invoke the designated initializer through messages to <code>self</code>. In this way, all <code>init...</code> methods are chained together. For example:<p>

<blockquote><pre>- init<br>{<br>    return [self initArg:-1];<br>}<br>    <br>- initArg:(int)tag<br>{<br>    return [self initArg:tag arg:NULL];<br>}<br>    <br>- initArg:(int)tag arg:(struct info *)data<br>{<br>    [super init. . .];<br>    /* class-specific initialization goes here */<br>}

</pre></blockquote><p>In this example, the <code>initArg:arg:</code> method is the designated initializer for the class.<p>

If a subclass does any initialization of its own, it must define its own designated initializer. This method should begin by sending a message to <code>super</code> to perform the designated initializer of its superclass. Suppose, for example, that the three methods illustrated above are defined in the B class. The C class, a subclass of B, might have this designated initializer:<p>

<blockquote><pre>- initArg:(int)tag arg:(struct info *)data arg:anObject<br>{<br>    [super initArg:tag arg:data];<br>    /* class-specific initialization goes here */<br>}

</pre></blockquote><p>If inherited <code>init...</code> methods are to successfully initialize instances of the subclass, they must all be made to (directly or indirectly) invoke the new designated initializer. To accomplish this, the subclass is obliged to cover (override) only the designated initializer of the superclass. For example, in addition to its designated initializer, the C class would also implement this method:<p>

<blockquote><pre>- initArg:(int)tag arg:(struct info *)data<br>{<br>    return [self initArg:tag arg:data arg:nil];<br>}

</pre></blockquote><p>This ensures that all three methods inherited from the B class also work for instances of the C class.<p>

Often the designated initializer of the subclass overrides the designated initializer of the superclass. If so, the subclass need only implement the one <code>init...</code> method.<p>

These conventions maintain a direct chain of <code>init...</code> links, and ensure that the <code>new</code> method and all inherited <code>init...</code> methods return usable, initialized objects. They also prevent the possibility of an infinite loop wherein a subclass method sends a message (to <code>super</code>) to perform a superclass method, which in turn sends a message (to <code>self</code>) to perform the subclass method.<p>

This <code>init</code> method is the designated initializer for the NSObject class. Subclasses that do their own initialization should override it, as described above.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="469"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/isEqual:">isEqual:</a></h3>

@protocol NSObject



<P>- (BOOL)<code>isEqual:</code>(id)<em>anObject

</em>

<P>Returns YES if the receiver and <em>anObject</em> are equal, NO otherwise. NSObject's implementation compares the <code>id</code> of <em>anObject</em> and the receiver to determine equality. Subclasses can override this method to redefine what it means for objects to be equal. For example, a container object might define two containers as equal if they contain the same contents. See the NSData, NSDictionary, NSArray, and NSString class specifications for examples of the use of this method. Note that equality as defined by this method is not necessarily reflexive. For example, A is equal to B, does not imply B is equal to A, especially if B is a subclass of A.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="473"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/methodForSelector:">methodForSelector:</a></h3>

- (IMP)<code>methodForSelector:</code>(SEL)<em>aSelector

</em>

<P>Locates and returns the address of the receiver's implementation for the <em>aSelector</em> method so that it can be called as a function. If the receiver is an instance, <em>aSelector</em> should refer to an instance method; if the receiver is a class, it should refer to a class method.<p>

<em>aSelector</em> must be a valid, non-NULL selector. If in doubt, use the <code>respondsToSelector:</code> method to check before passing the selector to <code>methodForSelector:</code>.<p>

IMP is defined as a pointer to a function that returns an <code>id</code> and takes a variable number of arguments (in addition to the two "hidden" arguments-<code>self</code> and <code>_cmd</code>-that are passed to every method implementation):<p>

<blockquote><pre>typedef id (*IMP)(id, SEL, ...);

</pre></blockquote><p>This definition serves as a prototype for the function pointer that <code>methodForSelector:</code> returns. It's sufficient for methods that return an object and take object arguments. However, if the <em>aSelector</em> method takes different argument types or returns anything but an <code>id</code>, its function counterpart will be inadequately prototyped. Lacking a prototype, the compiler will promote <code>float</code>s to <code>double</code>s and <code>char</code>s to <code>int</code>s, which the implementation won't expect. It will therefore behave differently (and erroneously) when performed as a method.<p>

To remedy this situation, it's necessary to provide your own prototype. In the example below, the declaration of the <code>test</code> variable serves to prototype the implementation of the <code>isEqual:</code> method. <code>test</code> is defined as a pointer to a function that returns a BOOL and takes an <code>id</code> argument (in addition to the two "hidden" arguments). The value returned by <code>methodForSelector:</code> is then similarly cast to be a pointer to this same function type:<p>

<blockquote><pre>BOOL (*test)(id, SEL, id);<br>test = (BOOL (*)(id, SEL, id))[target methodForSelector:@selector(isEqual:)];<br><br>while ( !test(target, @selector(isEqual:), someObject) ) { <br>    ...<br>}

</pre></blockquote><p>In some cases, it might be clearer to define a type (similar to IMP) that can be used both for declaring the variable and for casting the function pointer <code>methodForSelector:</code> returns. The example below defines the <code>EqualIMP</code> type for just this purpose:<p>

<blockquote><pre>typedef BOOL (*EqualIMP)(id, SEL, id);<br>EqualIMP test;<br>test = (EqualIMP)[target methodForSelector:@selector(isEqual:)];<br><br>while ( !test(target, @selector(isEqual:), someObject) ) { <br>    ...<br>}

</pre></blockquote><p>Either way, it's important to cast <code>the return value of methodForSelector:</code> to the appropriate function type. It's not sufficient to simply call the function returned by <code>methodForSelector:</code> and cast the result of that call to the desired type. This can result in errors.<p>

The advantage of obtaining a method's implementation and calling it as a function, is that you can invoke the implementation multiple times within a loop, or similar C construct, without the overhead of Objective-C messaging.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSObject/instanceMethodForSelector:">+ instanceMethodForSelector:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="487"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/methodSignatureForSelector:">methodSignatureForSelector:</a></h3>

- (NSMethodSignature *)<code>methodSignatureForSelector:</code>(SEL)<em>aSelector

</em>

<P>Returns an NSMethodSignature object that contains a description of the <em>aSelector</em> method, or <code>nil</code> if the <em>aSelector</em> method can't be found. When the receiver is an instance, <em>aSelector</em> should be an instance method; when the receiver is a class, it should be a class method. <p>

This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSObject/instanceMethodSignatureForSelector:">+ instanceMethodSignatureForSelector:</a>, <a href="#//apple_ref/occ/instm/NSObject/forwardInvocation:">- forwardInvocation:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="492"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/mutableCopy">mutableCopy</a></h3>

- (id)<code>mutableCopy

</code>

<P>Convenience method for classes that adopt the NSMutableCopying protocol. This method just calls the NSMutableCopying protocol method <code>mutableCopyWithZone:</code> with the zone as NULL. An exception is raised if there is no implementation for <code>mutableCopyWithZone:</code>.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="495"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/performSelector:withObject:afterDelay:">performSelector:withObject:afterDelay:</a></h3>

- (void)<code>performSelector:</code>(SEL)<em>aSelector</em> <br>

<code>withObject:</code>(id)<em>anArgument</em><code> <br>

afterDelay:</code>(NSTimeInterval)<em>delay

</em>

<P>Sends an <em>aSelector</em> message to the receiver sometime after <em>delay</em>. This method returns before the <em>aSelector</em> message is sent. The <em>aSelector</em> method should not have a significant return value and should take a single argument of type <code>id</code>; <em>anArgument</em> will be the argument passed in the message. Note that <code>self</code> and <em>anArgument</em> are retained until after the message is sent.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/cancelPreviousPerformRequestsWithTarget:selector:object:">- cancelPreviousPerformRequestsWithTarget:selector:object:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="499"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/performSelector:withObject:afterDelay:inModes:">performSelector:withObject:afterDelay:inModes:</a></h3>

- (void)<code>performSelector:</code>(SEL)<em>aSelector</em> <br>

<code>withObject:</code>(id)<em>anArgument</em><code> <br>

afterDelay:</code>(NSTimeInterval)<em>delay<br>

</em><code>inModes:</code>(NSArray *)<em>modes

</em>

<P>Sends an <em>aSelector</em> message to the receiver sometime after <em>delay</em>. This method returns before the <em>aSelector</em> message is sent. The <em>aSelector</em> method should not have a significant return value and should take a single argument of type <code>id</code>; <em>anArgument</em> will be the argument passed in the message. Note that <code>self</code> and <em>anArgument</em> are retained until after the message is sent. <p>

The <em>inModes</em> parameter contains an array of strings that identify the modes to associate with the timer performing the selector. This timer becomes associated with each of the given modes until its <code>invalidate</code> method is invoked.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/performSelector:withObject:afterDelay:">- performSelector:withObject:afterDelay:</a></code>, <code><a href="../NSRunLoop/NSRunLoop.html#//apple_ref/occ/instm/NSRunLoop/addTimer:forMode:" target="_top">- addTimer:forMode:</code> (NSRunLoop)</a>, 

<code><a href="../NSTimer/NSTimer.html#//apple_ref/occ/instm/NSTimer/invalidate" target="_top">- invalidate</code> (NSTimer)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="504"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/replacementObjectForArchiver:">replacementObjectForArchiver:</a></h3>

- (id)<code>replacementObjectForArchiver:</code>(NSArchiver *)<em>anArchiver

</em>

<P>Overridden by subclasses to substitute another object for itself during archiving. This method is invoked by NSArchiver. NSObject's implementation returns the object returned by <code>replacementObjectForCoder:</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/classForArchiver">- classForArchiver</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="508"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/replacementObjectForCoder:">replacementObjectForCoder:</a></h3>

- (id)<code>replacementObjectForCoder:</code>(NSCoder *)<em>aCoder

</em>

<P>Overridden by subclasses to substitute another object for itself during encoding. For example, an object might encode itself into an archive, but encode a proxy for itself if it's being encoded for distribution. This method is invoked by NSCoder. NSObject's implementation returns <code>self</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/classForCoder">- classForCoder</a></code>, <a href="#//apple_ref/occ/instm/NSObject/awakeAfterUsingCoder:"><code>- awakeAfterUsingCoder:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="512"></a>

<h3> <a name="//apple_ref/occ/instm/NSObject/replacementObjectForPortCoder:">replacementObjectForPortCoder:</a></h3>

- (id)<code>replacementObjectForPortCoder:</code>(NSPortCoder *)<em>aCoder

</em>

<P>Overridden by subclasses to substitute another object or a copy for itself during distribution encoding. This method is invoked by NSPortCoder. NSObject's implementation returns a NSDistantObject for the object returned by <code>replacementObjectForCoder:</code>, enabling all objects to be distributed by proxy as the default. However, if <code>replacementObjectForCoder:</code> returns <code>nil</code>, NSObject's implementation will also return <code>nil</code>.<p>

Subclasses that want to be passed by copy instead of by reference must override this method and return <code>self</code>. The following example shows how to to support object replacement both by copy and by reference:<p>

<blockquote><pre>- (id)replacementObjectForPortCoder:(NSPortCoder *)encoder {<br>    if ([encoder isByref])<br>        return [NSDistantObject proxyWithLocal:self connection:[encoder connection]];<br>    else<br>        return self;<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSObject/classForPortCoder">- classForPortCoder</a>

</code><p>

 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 08/12/97 15:18:20 -->



</body>

</html>

