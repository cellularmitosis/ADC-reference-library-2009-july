<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Event-Handling Guide: Event Objects and Types</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Event Objects and Types"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000060i-CH4" title="Event Objects and Types"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../EventsOtherInput-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000447" target="_top">Events &amp; Other Input</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000060i-CH1-SW1">Cocoa Event-Handling Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../EventArchitecture/EventArchitecture.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../EventHandlingBasics/EventHandlingBasics.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000060i-CH4-SW4" title="Event Objects and Types"></a><h1>Event Objects and Types</h1><p>Almost all events in a Cocoa application are represented by objects of the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> class. (Exceptions include Apple events, notifications, and similar items.) Each <code>NSEvent</code> object more narrowly represents a particular type of event, each with its own requirements for handling. The following sections describe the characteristics of an <code>NSEvent</code> object and the possible event types.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW7">NSEvent Objects</a>
				
			<br/>
			
        
			
			
				<a href="EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW2">Event Types</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000060i-CH4-SW7" title="NSEvent Objects"></a><h2>NSEvent Objects</h2><p>An <code>NSEvent</code> object—or, simply, an event object—contains pertinent information about an input action such as a mouse click or a key press. It stores such details as where the mouse was located or which character was typed. As described in <span class="content_text"><a href="../EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW1">“How an Event Enters a Cocoa Application,”</a></span> the window server associates each user action with a window and reports the event (in a lower-level form) to the application that created the window. The application temporarily places each event in a buffer called the event queue. When the application is ready to process an event, the application object (<code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/c/data/NSApp" target="_top">NSApp</a></code>) takes one from the queue (usually the topmost one in the queue) and converts it to an <code>NSEvent</code> object before dispatching it to the appropriate objects in an application.</p><p>Responder objects of an application receive the currently dispatched event object through the parameter of an event method declared by the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> class (such as <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code>).  In addition, other methods of the Application Kit let any object retrieve the current event or fetch the next event (or next event of a specific type) from the event queue. See <span class="content_text"><a href="EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW1">“Event Objects in Methods of Other Classes”</a></span> for more information about these methods.</p><a name="//apple_ref/doc/uid/10000060i-CH4-SW8" title="Attributes of an Event Object"></a><h3>Attributes of an Event Object</h3><p>An <code>NSEvent</code> object is largely a read-only repository of information related to a specific event. Most methods of the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> class are accessor methods for getting the values of event attributes. (<code>NSEvent</code> has no corresponding “setter” accessor methods, although you can specify certain attributes when creating an event object using various class factory methods.) An object such as a responder typically uses the accessor methods to get the details of an event and thus know how to handle it.</p><p>Some <code>NSEvent</code> attributes (and their corresponding accessor methods) are common to all types of events while others are specific to certain types of events. For example, the <code>clickCount</code> method pertains only to mouse events and the <code>characters</code> method pertains only to key events. Tablet events have a number of accessor methods that apply only to them. Some of the more important accessor methods of <code>NSEvent</code> are the following: </p><dl class="termdef">	<dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/type" target="_top">type</a></code></dt><dd><p>The type of event; see <span class="content_text"><a href="EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW2">“Event Types.”</a></span></p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/window" target="_top">window</a></code></dt><dd><p>The <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object representing the window in which the event occurred. With <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/windowNumber" target="_top">windowNumber</a></code> you can also obtain the number assigned by the window server to the window. Most but not all events are associated with a window; when no window is associated, <code>window</code> returns <code>nil</code>.</p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/locationInWindow" target="_top">locationInWindow</a></code></dt><dd><p>The location of the event within the window’s base coordinate system. </p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/modifierFlags" target="_top">modifierFlags</a></code></dt><dd><p>An indication of which modifier keys (Command, Control, Shift, and so on) the user held down while the event occurred.</p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/characters" target="_top">characters</a></code></dt><dd><p>The Unicode characters generated by a key event. You can also use <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/charactersIgnoringModifiers" target="_top">charactersIgnoringModifiers</a></code> to obtain the key-event characters minus those generated by modifier keys.</p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/timestamp" target="_top">timestamp</a></code></dt><dd><p>The time the event occurred (in seconds since system startup).</p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/clickCount" target="_top">clickCount</a></code></dt><dd><p>For mouse events within a certain time threshold, the number of clicks associated with a particular event. (This enables the detection of double- or triple-clicking.)</p></dd></dl><a name="//apple_ref/doc/uid/10000060i-CH4-SW9" title="NSEvent Class Methods"></a><h3>NSEvent Class Methods</h3><p>Though you rarely need do so, you can create an event object from scratch and either insert it into the event queue for distribution or  send it directly to its destination in an event message. The <code>NSEvent</code> class includes class methods for creating event objects of a specific type; for example, for creating a mouse-type event object, you can use the class method<code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/clm/NSEvent/mouseEventWithType:location:modifierFlags:timestamp:windowNumber:context:eventNumber:clickCount:pressure:" target="_top">mouseEventWithType:location:modifierFlags:timestamp:windowNumber:context:eventNumber:clickCount:pressure:</a></code>. You add event objects to the event queue by invoking the <code>NSWindow</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/postEvent:atStart:" target="_top">postEvent:atStart:</a></code> or the identically named method of the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code> class. </p><p>Another <code>NSEvent</code> class method, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/clm/NSEvent/mouseLocation" target="_top">mouseLocation</a></code>, returns the current location of the mouse. It differs in a few important respects from the instance method <code>locationInWindow</code>. Being a class method, it doesn’t require an event object to send the message to; it returns the location in screen coordinates rather than base (window) coordinates; and it returns the current mouse location, which might be different from that of the current or any pending mouse event.</p><a name="//apple_ref/doc/uid/10000060i-CH4-SW1" title="Event Objects in Methods of Other Classes"></a><h3>Event Objects in Methods of Other Classes</h3><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> objects are scattered throughout the Application Kit. For example, the classes <code><a href="../../../Reference/ApplicationKit/Classes/NSCell_Class/Reference/NSCell.html#//apple_ref/occ/cl/NSCell" target="_top">NSCell</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSCursor_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCursor" target="_top">NSCursor</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSClipView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSClipView" target="_top">NSClipView</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSMenu_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenu" target="_top">NSMenu</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSSlider_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSlider" target="_top">NSSlider</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSTableView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTableView" target="_top">NSTableView</a></code> all have methods with event objects as return values or parameters. However, a few Application Kit methods that deal with event objects are particularly important. </p><p>Although most events are distributed automatically through the responder chain, sometimes an object needs to retrieve events explicitly—for example, while mouse tracking. Both <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> and <code>NSApplication</code> define the method <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code>, which allows an object to retrieve events of specific types from the event queue. </p><p><code>NSApplication</code> and <code>NSWindow</code> also both define the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/currentEvent" target="_top">currentEvent</a></code> method, which fetches the last event object retrieved from the event queue. These methods are a great convenience because they enable any object in an application to learn about the event currently being handled in the main event loop.</p><p>Finally, both <code>NSWindow</code> and <code>NSApplication</code> define the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendEvent:" target="_top">sendEvent:</a></code> method. The implementations of these methods are critical for event dispatch. Because these methods are funnel points for events in an application, you may override them in certain circumstances to learn about events earlier in the event stream or to augment or modify the native event-dispatch behavior. <span class="content_text">“Event Dispatch”</span> talks about the role played by the <code>sendEvent:</code> methods.</p><a name="//apple_ref/doc/uid/10000060i-CH4-SW2" title="Event Types"></a><h2>Event Types</h2><p>The <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/type" target="_top">type</a></code> method of <code>NSEvent</code> returns an <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/tdef/NSEventType" target="_top">NSEventType</a></code> value that identifies the sort of event. The type of an event determines to a large extent how it is to be handled. The different types of events fall into six groups:</p><ul class="ul"><li class="li"><p>Mouse events</p></li><li class="li"><p>key events</p></li><li class="li"><p>Tracking-rectangle and cursor-update events</p></li><li class="li"><p>Tablet events</p></li><li class="li"><p>Periodic events</p></li><li class="li"><p>Other events</p></li></ul><p>Some of these groups comprise several <code>NSEventType</code> constants, others only one. Some event types might have subtypes, which are described in the following sections. <code>NSEventType</code> constants are declared in <code>NSEvent.h</code>.</p><p>The <code>NSApplication</code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> methods that allow you to selectively fetch and discard events from the event queue—<code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/discardEventsMatchingMask:beforeEvent:" target="_top">discardEventsMatchingMask:beforeEvent:</a></code>—take one or more event-type mask constants in the first parameter. These constants are also declared in <code>NSEvent.h</code>. </p><a name="//apple_ref/doc/uid/10000060i-CH4-SW10" title="Mouse Events"></a><h3>Mouse Events</h3><p>Mouse events are generated by changes in the state of the mouse buttons and by changes in the position of the mouse cursor on the screen. They fall into two subcategories, one related to mouse clicks and movements and the other related to mouse tracking and cursor updates.</p><a name="//apple_ref/doc/uid/10000060i-CH4-SW11" title="Events Related to Mouse Clicks and Movements"></a><h4>Events Related to Mouse Clicks and Movements</h4><p>The larger category of mouse events includes those where the mouse button is pressed or released and where the mouse is moved without being tracked. It consists of the following mouse-event types corresponding to the specified user actions:</p><dl class="termdef">	<dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseDown" target="_top">NSLeftMouseDown</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseUp" target="_top">NSLeftMouseUp</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSRightMouseDown" target="_top">NSRightMouseDown</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSRightMouseUp" target="_top">NSRightMouseUp</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSOtherMouseDown" target="_top">NSOtherMouseDown</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSOtherMouseUp" target="_top">NSOtherMouseUp</a></code></dt><dd><p>The user clicked a mouse button. Constants with “MouseDown” in their names mean the user pressed the button; “MouseUp” means the user released it. If the mouse has just one button, only left mouse events are generated. By sending a <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/clickCount" target="_top">clickCount</a></code> message to the event, you can determine whether the mouse event was a single click, double click, and so on. A mouse with more than two buttons can generate the “OtherMouse” events. </p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSLeftMouseDragged" target="_top">NSLeftMouseDragged</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSRightMouseDragged" target="_top">NSRightMouseDragged</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSOtherMouseDragged" target="_top">NSOtherMouseDragged</a></code></dt><dd><p>The user dragged the mouse. More specifically, the user moved the mouse while pressing one or more buttons. <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSLeftMouseDragged" target="_top">NSLeftMouseDragged</a></code> events are generated when the mouse is moved with its left mouse button down or with both buttons down, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSRightMouseDragged" target="_top">NSRightMouseDragged</a></code> events are generated when the mouse is moved with just the right button down, and <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSOtherMouseDragged" target="_top">NSOtherMouseDragged</a></code> when the device has more than two buttons. A mouse with a single button generates only left mouse-dragged events. A series of mouse-dragged events is always preceded by a mouse-down event and followed by a mouse-up event.</p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSMouseMoved" target="_top">NSMouseMoved</a></code></dt><dd><p>The user moved the mouse without holding down either mouse button. Mouse-moved events are normally not tracked, as they quickly flood the event queue; use the <code>NSWindow</code> method  <code>setAcceptsMouseMovedEvents:</code> to turn on tracking of mouse movements.</p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSScrollWheel" target="_top">NSScrollWheel</a></code></dt><dd><p>The user manipulated the mouse’s scroll wheel. Use the <code>NSEvent</code> methods <code>deltaX</code>, <code>deltaY</code>, and <code>deltaZ</code> to find out how much it moved. If the mouse has no scroll wheel, this event is never generated.</p><div class="noteboxdef"><a name="//apple_ref/doc/uid/10000060i-CH4-SW14" title="Note"></a><p><strong>Note:</strong>&nbsp;Beginning with Mac OS X v10.5, <code>NSScrollWheel</code> events are sent to the window under the mouse, whether the window is active or inactive. In earlier versions of the operating system, scroll-wheel events are sent to the window under the mouse only if that window has key focus (with the exception of utility windows, which receive those events even if they are inactive).</p></p></div></dd></dl><p>Mouse-dragged and mouse-moved events are generated repeatedly as long as the user keeps moving the mouse. If the mouse is stationary, neither type of event is generated until the mouse moves again.</p><div class="importantbox"><a name="//apple_ref/doc/uid/10000060i-CH4-DontLinkElementID_5" title="Important:"></a><p><strong>Important:</strong>&nbsp;The Application Kit does not provide any default handling of events generated by the third button of a three-button mouse (types <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSOtherMouseDown" target="_top">NSOtherMouseDown</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSOtherMouseDragged" target="_top">NSOtherMouseDragged</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSOtherMouseUp" target="_top">NSOtherMouseUp</a></code>).</p><p></p></div><p>See <span class="content_text"><a href="../HandlingMouseEvents/HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6-SW1">“Handling Mouse Events”</a></span>  for more information on mouse events.</p><a name="//apple_ref/doc/uid/10000060i-CH4-SW12" title="Mouse Tracking Events"></a><h4>Mouse Tracking Events</h4><p>Because following the mouse’s movements precisely is an expensive operation, the Application Kit provides a less intensive mechanism for tracking the location of the mouse. It does this by allowing the application to define regions of a window, called tracking rectangles, that generate events when the cursor enters or leaves them. The event types are <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSMouseEntered" target="_top">NSMouseEntered</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSMouseExited" target="_top">NSMouseExited</a></code> and they’re generated when the application has asked the window server to set a tracking rectangle in a window, typically by using <code><a href="../../../Reference/NSTrackingArea_class/Reference/Reference.html#//apple_ref/occ/cl/NSTrackingArea" target="_top">NSTrackingArea</a></code> objects or the <code>NSView</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/addTrackingRect:owner:userData:assumeInside:" target="_top">addTrackingRect:owner:userData:assumeInside:</a></code>. A window can have any number of tracking rectangles; the <code>NSEvent</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/trackingNumber" target="_top">trackingNumber</a></code> identifies the rectangle that triggered the event.</p><p>A special kind of tracking event is the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSCursorUpdate" target="_top">NSCursorUpdate</a></code> event. This type is used to implement the cursor-rectangle mechanism of the <code>NSView</code> class. An <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSCursorUpdate" target="_top">NSCursorUpdate</a></code> event is generated when the cursor has crossed the boundary of a predefined rectangular area. <code>NSApplication</code> typically handles <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSCursorUpdate" target="_top">NSCursorUpdate</a></code> events and does not dispatch them.</p><p>See <span class="content_text"><a href="../TrackingAreaObjects/TrackingAreaObjects.html#//apple_ref/doc/uid/10000060i-CH8-SW1">“Using Tracking-Area Objects”</a></span> for more information.</p><a name="//apple_ref/doc/uid/10000060i-CH4-SW5" title="Key Events"></a><h3>Key Events</h3><p>Among the most common events sent to an application are direct reports of the user’s keyboard actions, identified by these <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/tdef/NSEventType" target="_top">NSEventType</a></code> constants:</p><dl class="termdef">	<dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSKeyDown" target="_top">NSKeyDown</a></code></dt><dd><p>The user generated a character or characters by pressing a key.</p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSKeyUp" target="_top">NSKeyUp</a></code></dt><dd><p>The user released a key. This event is always preceded by a <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSKeyDown" target="_top">NSKeyDown</a></code> event.</p></dd><dt><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSFlagsChanged" target="_top">NSFlagsChanged</a></code></dt><dd><p>The user pressed or released a modifier key, or turned Caps Lock on or off. </p></dd></dl><p>Of these, key-down events are the most useful to an application. When the type of an event is  <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSKeyDown" target="_top">NSKeyDown</a></code>, the next step is typically to get the characters generated by the key-down using the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/characters" target="_top">characters</a></code> method.</p><p>Key-up events are used less frequently since they follow almost automatically when there’s been a key-down event. And because the NSEvent <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/modifierFlags" target="_top">modifierFlags</a></code> method returns the state of the modifier keys regardless of the type of event, applications normally don’t need to receive flags-changed events; they’re useful only for applications that have to keep track of the state of these keys at all times.</p><p>Some key presses generate key events that do not represent characters to be inserted as text. Instead they represent key equivalents, keyboard interface control commands, or keyboard actions. Key equivalents and keyboard interface control commands are typically handled by the application object and do not invoke the <code>NSResponder</code> method associated with <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSKeyDown" target="_top">NSKeyDown</a></code> events, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code>. See <span class="content_text"><a href="../EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW10">“The Path of Key Events”</a></span> for more information.</p><p>For more information on key events, see <span class="content_text"><a href="../HandlingKeyEvents/HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW1">“Handling Key Events.”</a></span></p><a name="//apple_ref/doc/uid/10000060i-CH4-SW3" title="Tablet Events"></a><h3>Tablet Events</h3><p>Tablet devices generate low-level events that a Cocoa application receives as <code>NSEvent</code> objects. The following sections describe tablet devices, the characteristics of tablet events, and how the Application Kit supports tablet events.</p><div class="importantbox"><a name="//apple_ref/doc/uid/10000060i-CH4-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;Tablet events are available in Mac OS X v10.4 and later versions of the operating system.</p><p></p></div><a name="//apple_ref/doc/uid/10000060i-CH4-97356" title="Overview of Tablet Devices"></a><h4>Overview of Tablet Devices</h4><p>A tablet with a stylus is an input device that generates more accurate and detailed data than does a mouse. It enables a user to draw, write, or make selections by manipulating the stylus over a surface (the tablet); an application can then capture and process those movements, reflecting them in its user interface. The tablet is generally a USB device connected to a computer system and the stylus is a wireless transducer. A signal is sent from the tablet to the transducer, which then sends a signal back to the tablet. The tablet uses this signal to determine the position of the transducer on the tablet. The stylus actually can be any pointing device, such as a pen, an airbrush, or even a puck.</p><p>In addition to the stylus location at any given moment, a stylus transducer can report many other pieces of data, such as the tilt of a pen, the rotation of a puck, and the pressure applied to the stylus. Pressure is particularly important because, with just this small piece of data, a user can tell an application to vary the thickness of a line being drawn, or its opacity, or its color. Some stylus devices also have buttons that can furnish an application with additional information.</p><p>Mac OS X supports tablet devices from several manufacturers. Some of these tablets can respond to multiple pointing devices on their surfaces at the same time.</p><a name="//apple_ref/doc/uid/TP40001834-96871" title="Types of Tablet Events"></a><a name="//apple_ref/doc/uid/10000060i-CH4-96871-BBCEBDIC" title="Types of Tablet Events"></a><h4>Types of Tablet Events</h4><p>There are two types of tablet events in the Application Kit: proximity events and pointer events. The following sections describe what they are, how they are related to each other, and the sequence of proximity and pointer events in a typical tablet session.</p><a name="//apple_ref/doc/uid/10000060i-CH4-96906" title="Proximity Events"></a><h5>Proximity Events</h5><p>A proximity event is an event that a tablet device generates when a pointing transducer (for example, a stylus) comes near or moves away from the tablet surface. It indicates the start or the end of a related series of pointer events (a session). A proximity event is an <code>NSEvent</code> object of type <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSTabletProximity" target="_top">NSTabletProximity</a></code>. An application can determine whether a tablet-pointer session is beginning or ending by sending <code>isEnteringProximity</code> to the event object.</p><p>The main purpose of a proximity event is to provide an application with a set of identifiers for associating items of tablet hardware—entire tablet devices or individual transducers—with the current pointing session. A proximity tablet event can also furnish an application with information about the capabilities of a specific device.</p><p>A proximity-type tablet event carries with it a set of identifiers and device attributes that an application can fetch with accessor methods. These include the following:</p><ul class="spaceabove"><li class="li"><p>Device ID—The main identifier of a tablet device, used to associate pointer-type events with proximity events. All tablet pointer events in a session have the same device ID.</p><p>Accessor: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/deviceID" target="_top">deviceID</a></code></p></li><li class="li"><p>Pointing devices—To help an application distinguish among pointing devices, you can ask a proximity event for the device’s serial number, its type (for example, pen or eraser), and, for tablets that support multiple concurrent pointing devices, its device ID.</p><p>Accessors: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/pointingDeviceSerialNumber" target="_top">pointingDeviceSerialNumber</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/pointingDeviceType" target="_top">pointingDeviceType</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/pointingDeviceID" target="_top">pointingDeviceID</a></code></p></li><li class="li"><p>Tablets—You can ask a proximity event for a tablet’s identifier (which is its USB model number) and, if there are multiple tablets connected to a system, its system tablet ID.</p><p>Accessors: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/tabletID" target="_top">tabletID</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/systemTabletID" target="_top">systemTabletID</a></code></p></li><li class="li"><p>Vendor information—An <code>NSEvent</code> object with a proximity type may contain an identifier of the vendor and an identifier of a pointing device within a vendor’s selection of devices. </p><p>Accessors: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/vendorID" target="_top">vendorID</a></code>, <code>vendorPointingDeviceType</code></p></li><li class="li"><p>Capabilities—A bit mask whose set bits indicate the capabilities of a tablet device. It is vendor-specific.</p><p>Accessor: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/capabilityMask" target="_top">capabilityMask</a></code></p></li></ul><p>Generally, when an application receives a proximity event, it stores the device ID and any other identifier that is needed to distinguish among various items of tablet hardware involved in the session. It then refers to these identifiers when handling pointer events to ensure it is processing the right events. An application can also extract device information from proximity events (for example, tablet capabilities or pointer type) and use this information to configure how it deals with pointer events.</p><a name="//apple_ref/doc/uid/10000060i-CH4-96932" title="Pointer Events"></a><h5>Pointer Events</h5><p>A pointer event is an event that a tablet device generates after a stylus has entered proximity of the tablet. It indicates a change in the state of the transducer. For example, if the user moves a stylus transducer over the surface of the tablet or increases pressure or tilts the pointing device, a pointer event is generated. A pointer event is an <code>NSEvent</code> object of type <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSTabletPoint" target="_top">NSTabletPoint</a></code> or an object representing a mouse-down, mouse-dragged, or mouse-up event with a subtype of <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSTabletPointEventSubtype" target="_top">NSTabletPointEventSubtype</a></code>.</p><p>Applications generally use pointer events for drawing or user-interface manipulation. Although you can obtain the absolute three-dimensional coordinates of the current pointer location, these coordinates are in full tablet resolution and require you to scale them to the screen location. It is much simpler to use the <code>NSEvent</code> instance method <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/locationInWindow" target="_top">locationInWindow</a></code> or the class method <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/clm/NSEvent/mouseLocation" target="_top">mouseLocation</a></code>.</p><p>In addition to pointer location, the information obtainable from pointer events include the following:</p><ul class="spaceabove"><li class="li"><p>Pressure, as a value between 0.0 and 1.0; you might use the pressure attribute to set the opacity of a color.</p><p>Accessor: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/pressure" target="_top">pressure</a></code></p></li><li class="li"><p>Rotation, in degrees; you might use the rotation attribute to simulate a calligraphy pen.</p><p>Accessor: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/rotation" target="_top">rotation</a></code></p></li><li class="li"><p>Tilt, an <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSPoint" target="_top">NSPoint</a></code> structure, with both axes ranging from -1 to 1; you might use the tilt attribute to supply different colors, depending on the angle and direction of tilt.</p><p>Accessor: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/tilt" target="_top">tilt</a></code></p></li><li class="li"><p>Tangential pressure, as a value between -1.0 and 1.0 (only on certain devices).</p><p>Accessor: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/tangentialPressure" target="_top">tangentialPressure</a></code></p></li><li class="li"><p>Button number of transducer pressed.</p><p>Accessor: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/buttonMask" target="_top">buttonMask</a></code></p></li><li class="li"><p>Vendor-defined data.</p><p>Accessor: <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/vendorDefined" target="_top">vendorDefined</a></code></p></li></ul><a name="//apple_ref/doc/uid/10000060i-CH4-96990" title="Sequence of Tablet Events"></a><h5>Sequence of Tablet Events</h5><p>A tablet proximity event signals the start of a series of related tablet pointer event and a subsequent proximity event signals the end of the series. These two proximity events thus provide a kind of frame for processing the pointer events in a session. The first proximity event is generated when a pointing device comes near a tablet surface; the second is generated when the same pointing device leaves the proximity of the tablet. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH4-SW13" title="Note"></a><p><strong>Note:</strong>&nbsp;You can determine whether a proximity event is for a pointing device entering proximity or leaving proximity by sending the event object an <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/isEnteringProximity" target="_top">isEnteringProximity</a></code> message.</p></div><p>The sequence of proximity and pointer events have special significance to the application handling the tablet events. A tablet event generated by a pointing device that comes near the tablet lets the tablet application know that it should store identifiers and set configuration variables for the upcoming tablet session. The application processes the pointer events until it receivers the second proximity event, which tells it that those identifiers and configurations are no longer operative. A tablet session is thus a sequence of pointer events that are associated with a specific pair of proximity events. </p><p>The relationship between proximity and pointer events is simple and clear as long as only one pointing device is in play. But there can be multiple pointing devices on a tablet surface at one time, or more than one tablet devices can be connected to a system. In this case the application must store the identifiers it receivers in all initial proximity events and use those identifiers to differentiate among various series of pointer events.</p><p>Take, for example, a tablet device that supports multiple pointing device on the tablet surface at one time. One pointing device might be a stylus for line drawing; another pointing device might apply an airbrush painting effect. As <span class="content_text">Figure 2-1</span> illustrates, a proximity event is generated with the drawing stylus comes close to the tablet surface.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH4-98272-CJBDEAGA" title="Figure 2-1Pointer A coming near the tablet, generating proximity event"></a><p><a name="//apple_ref/doc/uid/TP40001834-98272" title="Figure 2-1Pointer A coming near the tablet, generating proximity event"></a><strong>Figure 2-1&nbsp;&nbsp;</strong>Pointer A coming near the tablet, generating proximity event</p><img src = "../Art/tablet_events1.gif" alt = "Pointer A coming near the tablet, generating proximity event" width="410" height="175"></div><br/><p>When handling this proximity event, the application stores the device ID of the tablet device, the device ID of the pointing device, and perhaps also the serial number of the pointing device and its type. Until it receives the next proximity event with these same identifiers, it processes all pointer events it receives for the pointing device—in this case, drawing lines (<span class="content_text">Figure 2-2</span>).</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH4-98316-CJBGECDG" title="Figure 2-2Application receiving pointer events"></a><p><a name="//apple_ref/doc/uid/TP40001834-98316" title="Figure 2-2Application receiving pointer events"></a><strong>Figure 2-2&nbsp;&nbsp;</strong>Application receiving pointer events</p><img src = "../Art/tablet_events2.gif" alt = "Application receiving pointer events" width="352" height="174"></div><br/><p>Now the airbrush pointing device moves onto the surface of the tablet, generating another proximity event (<span class="content_text">Figure 2-3</span>). Because this event carries with it different identifiers, the application knows its not the terminating proximity event for the first tablet session. Instead it announces an impending series of pointer events for another pointing device. So the application stores the identifiers and configuration information for this session.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH4-98338-CJBGEJJF" title="Figure 2-3Pointer B coming near the tablet, generating proximity event"></a><p><a name="//apple_ref/doc/uid/TP40001834-98338" title="Figure 2-3Pointer B coming near the tablet, generating proximity event"></a><strong>Figure 2-3&nbsp;&nbsp;</strong>Pointer B coming near the tablet, generating proximity event</p><img src = "../Art/tablet_events3.gif" alt = "Pointer B coming near the tablet, generating proximity event" width="352" height="174"></div><br/><p>For a period, the tablet application is processing two different series of pointer events, using the stored identifiers to distinguish between the two. Then, as depicted in <span class="content_text">Figure 2-4</span>, the drawing pointing device moves away from the tablet surface. This action generates a proximity event. The application examines the event and sees that the identifiers for the pointing device are the same as what it initially stored for the line-drawing device. It nullifies the stored identifiers, bringing to a close the initial series of pointer events.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH4-98357-CJBDCFCI" title="Figure 2-4Pointer A leaving the tablet surface, generating proximity event"></a><p><a name="//apple_ref/doc/uid/TP40001834-98357" title="Figure 2-4Pointer A leaving the tablet surface, generating proximity event"></a><strong>Figure 2-4&nbsp;&nbsp;</strong>Pointer A leaving the tablet surface, generating proximity event</p><img src = "../Art/tablet_events4.gif" alt = "Pointer A leaving the tablet surface, generating proximity event" width="410" height="174"></div><br/><a name="//apple_ref/doc/uid/10000060i-CH4-SW6" title="Other Types of Events"></a><h3>Other Types of Events</h3><p>The Application Kit defines several minor event types. Some of these are rarely used, but they are available if you ever find need for them.</p><p>A periodic event (type <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSPeriodic" target="_top">NSPeriodic</a></code>) simply notifies an application that a certain time interval has elapsed. Periodic events are particularly useful in situations where input events aren’t generated but you want them to be. For example, when the user holds the mouse down over a scroll button but doesn’t move it, no events are generated after the mouse-down event. The Application Kit’s scrolling mechanism then starts and uses a stream of periodic events to keep the document scrolling at a reasonable pace until the user releases the mouse. When a mouse-up event occurs, the scrolling mechanism terminates the periodic event stream. </p><p>You use the <code>NSEvent</code> class method <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/clm/NSEvent/startPeriodicEventsAfterDelay:withPeriod:" target="_top">startPeriodicEventsAfterDelay:withPeriod:</a></code> to generate periodic events and have them placed in the event queue at a certain frequency. When you no longer need them, turn off the flow of periodic events by invoking <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/clm/NSEvent/stopPeriodicEvents" target="_top">stopPeriodicEvents</a></code>. Unlike key and mouse events, periodic events aren’t dispatched to a window object. The application must retrieve them explicitly using the <code>NSApplication</code> method  <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code>, typically in a modal loop. An application can have only one stream of periodic events active for each thread. You use periodic events instead of timers because <code>NSPeriodic</code> events are delivered along with other events; this makes for a responder object to look for periodic events along with mouse-up and mouse-dragged events. such as is done (for example) during scrolling.</p><p>The remaining event types—<code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSAppKitDefined" target="_top">NSAppKitDefined</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSSystemDefined" target="_top">NSSystemDefined</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSApplicationDefined" target="_top">NSApplicationDefined</a></code>—are less structured, containing only generic subtype and data fields. Of these three miscellaneous event types, only <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSApplicationDefined" target="_top">NSApplicationDefined</a></code> is of real use to application programs. It allows the application to generate custom events and insert them into the event queue. Each such event can have a subtype and two additional codes to differentiate it from others. The <code>NSEvent</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/clm/NSEvent/otherEventWithType:location:modifierFlags:timestamp:windowNumber:context:subtype:data1:data2:" target="_top">otherEventWithType:location:modifierFlags:timestamp:windowNumber:context:subtype:data1:data2:</a></code> creates one of these events, and the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/subtype" target="_top">subtype</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/data1" target="_top">data1</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/data2" target="_top">data2</a></code> methods return the information specific to these events.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../EventArchitecture/EventArchitecture.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../EventHandlingBasics/EventHandlingBasics.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/EventOverview/EventObjectsTypes/EventObjectsTypes.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/EventOverview/EventObjectsTypes/EventObjectsTypes.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/EventOverview/EventObjectsTypes/EventObjectsTypes.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>