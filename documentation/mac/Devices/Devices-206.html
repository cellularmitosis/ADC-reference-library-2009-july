<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the ADB Manager(IM: D)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING206></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="Devices-205.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-207.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Devices-2.html"><B>Devices</B></A> / <BR><DD><A HREF="Devices-203.html"><B>Chapter 5 - ADB Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING206-0></A>
<H1><A NAME=MARKER-9-148></A><A NAME=MARKER-9-149></A>Using the ADB Manager</H1>
 You can use the ADB Manager to communicate with and get information about devices attached to the Apple Desktop Bus. In general, applications interact with the ADB indirectly, by calling the Event Manager to retrieve information about user actions on the available input devices (keyboard, mouse, graphics tablet, and so forth). As a result, most applications do not need to know how to communicate directly with ADB devices, or even whether the ADB is present on the computer.<P>
 Some applications--such as diagnostic programs or other utilities--might want to report information about the ADB. Other software might even need to send commands directly to an ADB device (perhaps to query or modify device settings). This section shows how to<P>
<UL>
<LI>determine whether the ADB Manager is present on the current computer
<LI>get information about the devices attached to the ADB
<LI>send commands to an ADB device in order to determine or modify device settings<P>
</UL>
 For information on writing and installing ADB device handlers, see <A HREF=Devices-207.html#MARKER-9-166>"Writing an ADB Device Handler" on page 5-29</A>.<P>
<A NAME=HEADING206-7></A>
<H2>Checking for the ADB Manager</H2>
 The Apple Desktop Bus was introduced on the Macintosh II and Macintosh SE computers. To test for the availability of the ADB Manager on your system, use the <CODE>NGetTrapAddress</CODE> function to see if the <CODE>_CountADBs</CODE> trap macro is available. See the chapter "Trap Manager" in Inside Macintosh: Operating System Utilities for information about the <CODE>NGetTrapAddress</CODE> function.<A NAME=MARKER-2-142></A><CODE><A NAME=MARKER-2-151></A></CODE> <P>
<A NAME=HEADING206-9></A>
<H2>Getting Information About ADB Devices</H2>
 <A NAME=MARKER-2-152></A>You can use the ADB Manager to get several kinds of information about the ADB and about individual ADB devices on the bus. You can call <CODE>CountADBs</CODE> to determine how many devices are currently available on the Apple Desktop Bus. The <CODE>CountADBs</CODE> function simply counts the number of entries in the ADB device table.<P>
 You can call the <CODE>GetIndADB</CODE> function to get information about a device specified by its index in the ADB device table. The <CODE>GetIndADB</CODE> function returns as its function result the current ADB address of the device with the specified index and also returns additional information in a parameter block pointed to by one of its parameters. If you already know the address of an ADB device, you can call <CODE>GetADBInfo</CODE> to get that same information about the device.<P>
 Both <CODE>GetIndADB</CODE> and <CODE>GetADBInfo</CODE> return information about a particular device in an <B>ADB data block,</B> defined by the ADBDataBlock data type.<P>
<PRE>
TYPE ADBDataBlock = 
PACKED RECORD
   devType:          SignedByte;    {device handler ID}
   origADBAddr:      SignedByte;    {default ADB device address}
   dbServiceRtPtr:   Ptr;           {pointer to device handler}
   dbDataAreaAddr:   Ptr;           {pointer to data area}
END;
</PRE>
<DL>
<DT><B>Note</B>
<DD>The installation code for a device handler can set information (specifically the address of its device handler and optional data area) in its device's entry in the device table using the <A NAME=MARKER-9-143></A><CODE>SetADBInfo</CODE> function.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You can examine the <CODE>devType</CODE> and <CODE>origADBAddr</CODE> fields of the <CODE>ADBData</CODE> block to determine what kind of ADB device is located at a particular ADB address. (Remember that once the ADB Manager has set the initial values for an ADB device in the ADB device table, it updates the device table entry for the device to reflect changes only to the address of the device handle routine and data area pointer. Thus, <CODE>GetIndADB</CODE> and <CODE>GetADBInfo</CODE> return the device's original device handler ID and original (default) ADB device address.) For example, the Apple Extended keyboard has a device handler ID of $02 and a default address of $2. <A HREF=#MARKER-9-154>Listing 5-1</A> shows one way to determine whether an ADB device is an Apple Extended keyboard.<P>
<B>Listing 5-1  <A NAME=MARKER-9-154></A>Determining whether an ADB device is an Apple Extended keyboard</B><P>
<PRE>
FUNCTION IsExtendedKeyboard (myAddress: ADBAddress): Boolean;
VAR
   myInfo:        ADBDataBlock;
   myCommand:     Integer;
   myErr:         OSErr;
CONST
   kExtKeyboardAddr = 2;
   kExtKeyboardOrigHandlerID = 2;
BEGIN
   myErr := GetADBInfo(myInfo, myAddress);
   IsExtendedKeyboard := (myInfo.origADBAddr = kExtKeyboardAddr) 
                        AND (myInfo.devType = kExtKeyboardOrigHandlerID);
END;
</PRE>
 The <CODE>IsExtendedKeyboard</CODE> function defined in <A HREF=#MARKER-9-154>Listing 5-1</A> is used later in this chapter, in <A HREF=#MARKER-9-163>Listing 5-5</A> on <A HREF=#MARKER-9-163>page 5-28</A>.<A NAME=MARKER-2-155></A><P>
<A NAME=HEADING206-19></A>
<H2><A NAME=MARKER-9-156></A>Communicating With ADB Devices</H2>
 <A NAME=MARKER-2-149></A><A NAME=MARKER-2-150></A>You can use the ADB Manager to communicate directly with ADB devices by sending ADB commands to those devices. In general, however, you don't need to do this, because the ADB Manager automatically polls for input from the connected ADB devices and passes any data received from a device to the device's device handler. Most applications should never interact directly with ADB devices, and even ADB device handlers need to do so only occasionally (for instance, to read or set device parameters stored in the device registers).<P>
 If you do need to send ADB commands directly to a device, you can do so using the <CODE>ADBOp</CODE> function. The <CODE>ADBOp</CODE> function transmits over the bus a command byte, whose structure is shown in <A HREF=Devices-205.html#MARKER-9-54>Figure 5-2 on page 5-8</A> and <A HREF=Devices-205.html#MARKER-9-55>Figure 5-3 on page 5-8</A>. The command (Talk, Listen, Flush, and SendReset) and any register information are encoded into an integer that is passed to <CODE>ADBOp</CODE>. You also pass <CODE>ADBOp</CODE> three pointers:<P>
<UL>
<LI>A pointer to the optional data area used by the completion routine.
<LI>A pointer to a completion routine. This routine is executed once the command byte has been sent to the ADB device.
<LI>A pointer to a Pascal string (maximum 8 bytes data preceded by one length byte). The first byte specifies the length of the string and the remaining bytes (if any) contain data to be sent to the device or provide storage for the data to be received from the device.<P>
</UL>
 The <CODE>ADBOp</CODE> function is always executed asynchronously. If the bus is busy, the ADB command passed to <CODE>ADBOp</CODE> is held in a command queue until the bus is free. If your application requires synchronous behavior, you'll need to use a completion routine to determine when the ADB command itself has completed. <A HREF=#MARKER-9-159>Figure 5-11</A> shows the relationships between the <CODE>ADBOp</CODE> routine, the device to which it is directly communicating, the ADB Manager, and an ADB completion routine.<P>
<B>Figure 5-11  <A NAME=MARKER-9-159></A>The <CODE>ADBOp</CODE> routine and an ADB completion routine</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/ADB-L-11.jpg"><p>
 <A HREF=#MARKER-9-160>Listing 5-2</A> shows a way to send ADB commands synchronously.<P>
<B>Listing 5-2  <A NAME=MARKER-9-160></A>Sending an ADB command synchronously</B><P>
<PRE>
PROCEDURE MySetFlag;
{move a nonzero value into the word pointed to by register A2}
INLINE $34BC, $FFFF;       {MOVE.W #$FFFF, (A2)}

PROCEDURE MyCompletionRoutine;
BEGIN
   MySetFlag;              {set a flag to indicate done}
END;

FUNCTION MySendADBCommand (myBufferPtr: Ptr; myCommand: Integer): OSErr;
{send a command to an ADB device synchronously}
VAR
   myDone:     Integer;    {completion flag}
   myErr:      OSErr;
BEGIN
   myDone := 0;
   myErr := ADBOp(@myDone, @MyCompletionRoutine, myBufferPtr, myCommand);
   IF myErr = noErr THEN
      REPEAT
      UNTIL myDone &lt;&gt; 0;
   ELSE
      ; {ADB buffer overflowed -- retry command here}
   MySendADBCommand := myErr;
END;
</PRE>
 The <CODE>MySendADBCommand</CODE> function sets the completion flag <CODE>myDone</CODE> to zero and then calls <CODE>ADBOp</CODE>, passing the address of that completion flag and the address of a completion routine along with the two parameters passed to <CODE>MySendADBCommand</CODE>. The completion routine simply calls an inline assembly routine that moves a nonzero value into the word pointed to by register A2. (When the completion routine is called, register A2 points to the optional data area, in this case, to the <CODE>myDone</CODE> variable.) The <CODE>MySendADBCommand</CODE> function waits until the value of the <CODE>myDone</CODE> variable changes, and then returns.<P>
 Rather than provide a completion routine to verify that a Talk command has completed, you can initialize the first byte of the data buffer to 0 before sending the command. The first byte of the data buffer contains the length of the buffer (in the same manner that the first byte of a Pascal string contains the length of the string). The data buffer can include from 0 to 8 bytes of information. After sending the command with <CODE>ADBOp</CODE>, you can then test the first byte of the data buffer to determine whether the command has completed. Once the first byte of information contains a nonzero value, then the command has completed, and the first byte of the buffer indicates the number of bytes returned by the ADB device.<P>
 <A HREF=#MARKER-9-161>Listing 5-3</A>, <A HREF=#MARKER-9-162>Listing 5-4</A>, and <A HREF=#MARKER-9-163>Listing 5-5</A> illustrate how to use the <CODE>MySendADBCommand</CODE> function (defined in <A HREF=#MARKER-9-160>Listing 5-2</A>) to blink the LED lights on the Apple Extended keyboard. The Apple Extended keyboard maintains the current setting of the LED lights in the lower 3 bits of device register 2. You can read the current light setting by issuing a Talk command to the keyboard, as shown in <A HREF=#MARKER-9-161>Listing 5-3</A>.<P>
<B>Listing 5-3  <A NAME=MARKER-9-161></A>Reading the current state of the LED lights</B><P>
<PRE>
VAR
   gRegisterData:    PACKED ARRAY[0..8] of Byte;   {buffer for register data}
CONST
   kListenMask       = 8;     {masks for ADB commands}
   kTalkMask         = 12;
   kLEDRegister      = 2;     {register containing LED settings}
   kLEDValueMask     = 7;     {mask for bits containing current LED setting}

FUNCTION MyGetLEDValue (myAddress: ADBAddress; VAR myLEDValue: Integer)
                        : OSErr;
VAR
   myCommand:  Integer;
   myErr:      OSErr;


BEGIN
   {initialize length of buffer; on return, the ADB device sets }
   gRegisterData[0] := Byte(0);  { this byte to the number of bytes returned}
   {get existing register contents with a Talk command}
   myCommand := (myAddress * 16) + kTalkMask + kLEDRegister;
   myErr := MySendADBCommand(@gRegisterData, myCommand);
   IF myErr = noErr THEN            {make sure completed successfuly}
      {gRegisterData now contains the existing data in device register 2; }
      { the lower 3 bits of byte 2 contain the LED value}
      myLEDValue := Integer(BAND(gRegisterData[2], kLEDValueMask))
   ELSE
      myLEDValue := 0;
   MyGetLEDValue := myErr;
END;
</PRE>
 The MyGetLEDValue function constructs a Talk Register 2 command by adding the address value to command and register masks defined by the application. Then it calls the MySendADBCommand function to communicate with the device at the specified address. If MySendADBCommand completes successfully, then the gRegisterData variable contains (in array elements 1 and 2) the two-byte value in device register 2. Only the lower 3 bits of that value are used for the LED settings. If one of those bits is set, the corresponding light is off. Note that if <CODE>MyGetLedValue</CODE> returns an error, this generally indicates that the <CODE>ADBOp</CODE> buffer overflowed.<P>
 The MySetLEDValue function defined in <A HREF=#MARKER-9-162>Listing 5-4</A> sets the LED lights to a specific pattern.<P>
<B>Listing 5-4  <A NAME=MARKER-9-162></A>Setting the current state of the LED lights</B><P>
<PRE>
FUNCTION MySetLEDValue (myAddress: ADBAddress; myValue: Integer): OSErr;
VAR
   myCommand:  Integer;
   myByte:     Byte;                {existing byte 2 of device register 2}
   myErr:      OSErr;
BEGIN
   gRegisterData[0] := Byte(2);     {set length of buffer}
   {get existing register contents with a Talk command}
   myCommand := (myAddress * 16) + kTalkMask + kLEDRegister;
   myErr := MySendADBCommand(@gRegisterData, myCommand);
   MySetLEDValue := myErr;
   IF myErr &lt;&gt; noErr THEN           {make sure completed successfuly}
      EXIT(MySetLEDValue);
   {gRegisterData now contains the existing data in device register 2; }
   { reset the lower 3 bits of byte 2 to the desired value}
   myByte := gRegisterData[2];
   myByte := BAND(myByte, 255 - 7);          {mask off lower three bits}
   myByte := BOR(myByte, Byte(myValue));     {install desired value}
   gRegisterData[2] := myByte;
   myCommand := (myAddress * 16) + kListenMask + kLEDRegister;
   MySetLEDValue := MySendADBCommand(@gRegisterData, myCommand);
END;
</PRE>
 Notice that the MySetLEDValue function first reads the current value in device register 2. This is necessary to preserve the bits in that register that do not encode the LED state. Register 2 contains sixteen bits; be sure to change only the three bits that represent the three LED lights.<P>
 Finally, the MyCountWithLEDs procedure shown in <A HREF=#MARKER-9-163>Listing 5-5</A> uses the MyGetLEDValue and MySetLEDValue routines to "count" in binary.<P>
<B>Listing 5-5  <A NAME=MARKER-9-163></A>Counting in binary using a keyboard's LED lights</B><P>
<PRE>
PROCEDURE MyCountWithLEDs;
VAR
   myValue:    Integer;
   myIndex:    Integer;
   myAddress:  ADBAddress;
   myOrigLED:  Integer;
   myInfo:     ADBDataBlock;        {needed for GetIndADB; ignored here}
   myDelay:    LongInt;             {needed for Delay; ignored here}
   myErr:      OSErr;
BEGIN
   FOR myIndex := 1 TO CountADBs DO
   BEGIN
      myAddress := GetIndADB(myInfo, myIndex);
      IF IsExtendedKeyboard(myAddress) THEN
      BEGIN
         {save original state of LED lights}
         myErr := MyGetLEDValue(myAddress, myOrigLED);
         myValue := 7;                       {turn all the lights OFF}
         WHILE myValue &gt;= 0 DO
         BEGIN
            myErr := MySetLEDValue(myAddress, myValue);
            myValue := myValue - 1;
            Delay(30, myDelay);
         END;
         {restore original state of LED lights}
         myErr := MySetLEDValue(myAddress, myOrigLED);
      END; {IF}
   END; {FOR}
END;
</PRE>
 The MyCountWithLEDs procedure looks for Apple Extended keyboards on the ADB and counts from 0 to 7, in binary, on the LED lights of any such keyboard it finds.<P>
<DL>
<DT><B>Note</B>
<DD>The techniques shown in this section for reading and writing the LED state of an Apple Extended keyboard are provided for illustrative purposes only. Your application or other software should in general not modify the LED state of the user's keyboard<A NAME=MARKER-2-164></A><A NAME=MARKER-2-165></A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>

<HR>
<center>
<A HREF="Devices-205.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-207.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Devices-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML>  
