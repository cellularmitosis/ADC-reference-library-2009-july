<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Further Performance Improvement for Clipping By Using minclip and maxclip Parameters </TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><!-- QTnavbar start --><P><I>Inside Macintosh: QuickTime Reference</I><P>| <A HREF="refSlopeInt.8.htm">Previous</A> | <A HREF="refSlopeInt.1.htm">Chapter Contents</A> | <A HREF="refSlopeInt.htm">Chapter Top</A> | <A HREF="refSlopeInt.a.htm">Next</A> | <!-- QTnavbar end --><H1 CLASS="H3.Heading3"><A NAME="pgfId=1294"> </A>Further Performance Improvement for Clipping By Using minclip and maxclip Parameters </H1><P CLASS="T1.Text1"><A NAME="pgfId=1295"> </A>When converting floating point values back to integer values for playback or display, clipping is often a performance issue. You want to avoid the extra comparisons and branches if possible.</P><P CLASS="T1.Text1"><A NAME="pgfId=1296"> </A>This specification includes two parameters, <TT CLASS="cv">minclip</TT> and <TT CLASS="cv">maxclip</TT>, which provide a hint to downstream users of the audio data that no sample value is less than minclip, and no sample value is greater than maxclip. The hint is optional: if you set <TT CLASS="cv">minclip</TT> &gt; <TT CLASS="cv">maxclip</TT>, that means, in effect, no hint: the samples could have any value. But if you set <TT CLASS="cv">minclip</TT> &lt;= <TT CLASS="cv">maxclip</TT>, the samples must satisfy the invariants above.</P><P CLASS="T1.Text1"><A NAME="pgfId=1297"> </A>In many cases, it is trivial to determine minclip and maxclip. For example, if you are recording audio to a floating point file and you are capturing 16-bit two's complement integer samples and converting the integers directly into floats, you know that <TT CLASS="cv">minclip</TT> is -32768 and <TT CLASS="cv">maxclip</TT> is 32767, so you ought to set the parameters.</P><P CLASS="T1.Text1"><A NAME="pgfId=1298"> </A>The <TT CLASS="cv">minclip</TT> and <TT CLASS="cv">maxclip</TT> parameters are completely independent of <TT CLASS="cv">slope</TT> and <TT CLASS="cv">intercept</TT>. In the previous example, minclip and maxclip happened to be close to intercept+slope and intercept-slope, but this is not required. For example, if you know that all samples in the above example fall between -1000 and +1000, then go ahead and set <TT CLASS="cv">minclip</TT> and <TT CLASS="cv">maxclip</TT> to those values. The more constrained you can make the clip (without sacrificing performance), the better.</P><P CLASS="T1.Text1"><A NAME="pgfId=1299"> </A>Now let's say you are playing back a floating point file, so you need to convert floating point data back into 16-bit two's complement integers. The floating point data has a slope of 32767 and an intercept of 0. Do you need to perform clipping operations? The slope and intercept parameters do not tell you this.  Their purpose is to define the mapping between the data's zero amplitude value and full amplitude difference and that of an output device or on-screen waveform. From what we know so far, the data could still contain samples with the value -32768.0, or for that matter +1000000000!</P><P CLASS="T1.Text1"><A NAME="pgfId=1300"> </A>You should instead consult <TT CLASS="cv">minclip</TT> and <TT CLASS="cv">maxclip</TT> to see if clipping is necessary.  If the hint is present (<TT CLASS="cv">minclip</TT> &lt;= <TT CLASS="cv">maxclip</TT>), and <TT CLASS="cv">minclip</TT> and <TT CLASS="cv">maxclip</TT> are within your desired integral range, you can omit the clipping operations.</P><P CLASS="T1.Text1"><A NAME="pgfId=1301"> </A>This technique does the right thing even if the data is captured with one kind of integer (for example, 16 bit) and played back with another (for example, 24 bit). It also works if the data is synthesized in floating point.</P><P CLASS="T1.Text1"><A NAME="pgfId=1302"> </A>Another issue which enters the clipping picture is how to map effectively the symmetric range of floating point samples onto the non-symmetric range of integers. This is especially important when converting to or from 8-bit integers, where one step is quite audible. Using <TT CLASS="cv">slope</TT>, <TT CLASS="cv">intercept</TT>, <TT CLASS="cv">minclip</TT>, and <TT CLASS="cv">maxclip</TT>, you can use any conversion scheme you like, and all the right hints are present to perform the conversion correctly and efficiently.</P><hr>&#169; 1998 Apple Computer, Inc.<!-- QTnavbar start --><P><I>Inside Macintosh: QuickTime Reference</I><P>| <A HREF="refSlopeInt.8.htm">Previous</A> | <A HREF="refSlopeInt.1.htm">Chapter Contents</A> | <A HREF="refSlopeInt.htm">Chapter Top</A> | <A HREF="refSlopeInt.a.htm">Next</A> | <!-- QTnavbar end --></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>