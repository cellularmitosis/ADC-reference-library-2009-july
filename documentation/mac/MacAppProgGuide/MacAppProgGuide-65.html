<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Basic View Technology (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING65></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-64.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-66.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-63.html"><B>Chapter 8 - Displaying, Manipulating, and Printing Data</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING65-0></A>
<H1><A NAME=MARKER-2-21></A>Basic View Technology</H1>
 MacApp uses views to represent a Macintosh window and each of its parts, including the window frame (which may include a title bar, size box, zoom box, and close box) and the content area of the window. In addition, many windows feature scroll bars and other control view objects.<P>
 The sections that follow describe the major components of MacApp's view technology.<P>
<A NAME=HEADING65-3></A>
<H2>32-Bit Coordinate Space</H2>
 <A NAME=MARKER-2-22></A>MacApp supports very large views, using 32-bit coordinate values. Each view has its own coordinate system, with the point (0,0) representing the upper-left corner of the view.<P>
 <A HREF=#MARKER-9-23>Figure 8-1</A> shows the values in global and window coordinates that correspond to a line drawn from the point (5,5) to the point (20,30) in a view's local coordinates. These view coordinates correspond to drawing a line from (55,55) to (70,80) in window coordinates or from (75,75) to (90,100) in global coordinates.<P>
 All drawing in a view takes place in 16-bit QuickDraw coordinates. Before drawing, MacApp focuses on the view by setting the QuickDraw origin so that (0,0) is at the upper-left corner of the view. A view's drawing method doesn't usually need to worry about global coordinates--it just calls a view method to convert from view coordinates to QuickDraw coordinates before drawing.<P>
<B>Figure 8-1  <A NAME=MARKER-9-23></A>Local coordinate systems</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-019.gif"><P>
 MacApp supplies the following data types for working with view coordinates. The <CODE>V</CODE> in the names of these coordinate data types stands for "View".<P>
<DL>
<DT><CODE><A NAME=MARKER-2-24></A><A NAME=MARKER-2-25></A>VCoordinate</CODE>
<DD> A long integer (32 bits) that represents a coordinate value
<DT><CODE><A NAME=MARKER-2-26></A>VPoint</CODE>
<DD> A pair of <CODE>VCoordinate</CODE> values, one for the <I>x</I> component of the point, and one for the <I>y</I> component of the point
<DT><CODE><A NAME=MARKER-2-27></A>VRect</CODE>
<DD> A pair of <CODE>VPoint</CODE> values, one for the upper-left corner of the rectangle, and one for its lower-right corner
</DL>
 Since QuickDraw coordinates are 16-bit values, the <CODE>TView</CODE> class provides conversion methods. These methods may call the view's <CODE>UpdateCoordinates</CODE> method to calculate the offset between view and Quickdraw locations. This value is stored in the <A NAME=MARKER-2-28></A>View's <CODE>fViewToQDOffset</CODE> field.<P>
<DL>
<DT><CODE><A NAME=MARKER-2-29></A>QDToViewPt</CODE>
<DD> Converts a QuickDraw point into a <CODE>VPoint</CODE> value
<DT><CODE><A NAME=MARKER-2-30></A>QDTOViewRect</CODE>
<DD> Converts a QuickDraw rectangle into a <CODE>VRect</CODE> value
<DT><CODE><A NAME=MARKER-2-31></A>ViewToQDPt</CODE>
<DD> Converts a <CODE>VPoint</CODE> into a QuickDraw point
<DT><CODE><A NAME=MARKER-2-32></A>ViewToQDRect</CODE>
<DD> Converts a <CODE>VRect</CODE> into a QuickDraw rectangle
</DL>
 The <CODE>TView</CODE> class also provides a number of methods for converting between the coordinates of a view and those of its superview or its window (which may not be the immediate superview), and for converting to global screen coordinates. <P>
 These methods include:<P>
<DL>
<DT><CODE>LocalToSuper</CODE>
<DD> Converts a <CODE>VPoint</CODE> value from local view coordinates to superview coordinates
<DT><CODE>LocalToWindow</CODE>
<DD> Converts a <CODE>VPoint</CODE> value from local view coordinates to window coordinates
<DT><CODE>SuperToLocal</CODE>
<DD> Converts a <CODE>VPoint</CODE> value from superview coordinates to local view coordinates
<DT><CODE>WindowToLocal</CODE>
<DD> Converts a <CODE>VPoint</CODE> value from window coordinates to local view coordinates
</DL>
 Additional methods are available to perform conversions on <CODE>VRect</CODE> and <CODE>Region</CODE> data types.<A NAME=MARKER-2-33></A><P>
<A NAME=HEADING65-25></A>
<H2><A NAME=MARKER-2-34></A>Frame Size/Location</H2>
 A view's size is specified by its <CODE><A NAME=MARKER-2-35></A>fSize</CODE> field, a <CODE>VPoint</CODE> value, and the view's location within its superview is specified by its <CODE><A NAME=MARKER-2-36></A>fLocation</CODE> field, also a <CODE>VPoint</CODE> value. These values can be changed with the <CODE>Resize</CODE> method, which sets the view's size to the passed <CODE>VPoint</CODE> value, and the <CODE>Locate</CODE> method, which causes the view to be located at the passed <CODE>VPoint</CODE> location in the superview, or with <CODE>SetFrame</CODE>, which sets both the size and location.<P>
 The <CODE>TView</CODE> class also has an array field <CODE><A NAME=MARKER-2-37></A>fSizeDeterminer</CODE>, which contains two entries of type <CODE>SizeDeterminer</CODE>, one for the view's vertical dimension and one for the horizontal. The <CODE>SizeDeterminer</CODE> data type specifies a view's size in relationship to the size of its superview. The possible values are<P>
<DL>
<DT><CODE><A NAME=MARKER-2-38></A>sizeFixed</CODE>
<DD> The view doesn't change its own size.
<DT><CODE><A NAME=MARKER-2-39></A>sizeVariable</CODE>
<DD> The view computes its own size when the <CODE>AdjustFrame</CODE> method is called.
<DT><CODE><A NAME=MARKER-2-40></A>sizePage</CODE>
<DD> The view is the size of one page.
<DT><CODE><A NAME=MARKER-2-41></A>sizeFillPages</CODE>
<DD> Similar to <CODE>sizeVariable</CODE>, but rounded upward to fill an exact number of pages.
<DT><CODE><A NAME=MARKER-2-42></A>sizeSuperView</CODE>
<DD> The view is the same size as its superview.
<DT><CODE><A NAME=MARKER-2-43></A>sizeRelSuperView</CODE>
<DD> The view size is relative to the superview's size.
</DL>
 When an operation such as zooming a window causes a view's size to change, the new size of the view depends on the <CODE>fSizeDeterminer</CODE> field. The <CODE>TView</CODE> class contains several methods that may be called when the view's size changes, including <CODE><A NAME=MARKER-2-44></A>SetFrame</CODE>, <CODE><A NAME=MARKER-2-45></A>AdjustFrame</CODE>, and <CODE><A NAME=MARKER-2-46></A>CalcMinSize</CODE>. You can read more about these methods in the <I>MacApp Class and Method Reference</I>.<A NAME=MARKER-2-47></A><P>
<A NAME=HEADING65-35></A>
<H2><A NAME=MARKER-2-48></A><A NAME=MARKER-9-49></A>View Hierarchies</H2>
 The views in a window are linked into a hierarchy, with the window at the top. One view represents the window frame, another represents each scroll bar, another represents the main content area of the window, and so on. Each view can draw the part of the window it represents and can respond to events relating specifically to its part. Each view has a list of the subviews it contains.<P>
 <A HREF=#MARKER-9-50>Figure 8-2</A> shows a simple view hierarchy. In this hierarchy, the window is the superview. It contains three immediate subviews, a scroller view and two scroll-bar views. The scroller view contains a subview of its own, the main content view. More complex view hierarchies may contain multiple content views.<P>
 The view object for the window draws the title bar, close box, zoom box, size box, and the blank white background of the window. It responds to mouse clicks in the title bar, close box, zoom box, and size box, which may specify dragging, closing, zooming, or resizing the window. <P>
<B>Figure 8-2  <A NAME=MARKER-9-50></A>A view hierarchy in MacApp</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-022.gif"><P>
 Each view that represents a scroll bar is responsible for drawing the scroll bar, as well as for responding to mouse clicks in the scroll bar, which typically cause the scroll bar to redraw itself and tell the scroller view to scroll its visible area. That has the affect of scrolling the main content view, since it is a subview of the scroller view.<P>
 The main content view is responsible for drawing the document's content and may contain a number of subviews to aid in displaying the data. The behavior of content views varies widely from application to application. In the IconEdit sample application, the content view draws an icon at any level of magnification, and responds to mouse clicks by turning individual pixels on or off. In a word-processing program, the content view draws the current text-editing view and the visible part of its text.<P>
 A view hierarchy can be as simple as a window object with a single view, or as complex as a dialog box containing numerous nested views, including views that represent buttons, checkboxes, text fields, and other controls. View hierarchies have the following characteristics:<P>
<UL>
<LI>The window view (the view responsible for the window frame) is at the root of the view hierarchy and has no superview.
<LI>Each view may have one superview--the view that owns it--and any number of subviews--the views that are subordinate to it.<P>
</UL>
<B>Figure 8-3  <A NAME=MARKER-2-51></A><A NAME=MARKER-9-52></A>How a view is clipped to a window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-018.gif"><P>
<UL>
<LI>Each view displayed within a window is a subview of the window.
<LI>A view is drawn after its superview, so it appears to be layered on top of its superview. The window view, including the frame, is the first view drawn, followed by its subviews, then their subviews, and so on.
<LI>A view is drawn within the boundaries of--clipped to--its superview.<P>
<A HREF=#MARKER-9-52>Figure 8-3</A> shows how a view is clipped to a window.
<LI>Each view has its own coordinate system, described in the next section.<P>
</UL>
 Many applications require complex view hierarchies. The design and implementation of those view hierarchies can be greatly simplified by the use a view-editing application, a type of graphical user interface builder. A view-editing application allows you to specify view objects and hierarchies in an interactive, graphical environment. You can often edit views, run the application, and examine your changes, without modifying any code. For more information, see <A HREF=MacAppProgGuide-101.html#MARKER-9-58>"Specifying Views With View Resource Templates," beginning on page 217</A>.<A NAME=MARKER-2-53></A><P>
<A NAME=HEADING65-54></A>
<H2>The TDrawingEnvironment Class</H2>
 MacApp provides the <CODE><A NAME=MARKER-2-54></A>TDrawingEnvironment</CODE> class for storing characteristics of the graphics environment, including the pen size, pen pattern, pen mode, foreground color, and background color. You can associate an object of type <CODE>TDrawingEnvironment</CODE> with each view object. This makes it possible to customize the drawing environment of a view without having to define a view subclass. You can use a view-editing application to specify the drawing environment for a view in its <CODE>'View'</CODE> resource.<P>
<A NAME=HEADING65-56></A>
<H2><A NAME=MARKER-2-55></A><A NAME=MARKER-9-56></A>Drawing a View's Contents</H2>
 In a MacApp application, <I>drawing</I> can refer to either of two operations:<P>
<UL>
<LI>The application rendering its views on the screen.
<LI>A user operating a mouse, trackball, pen, or other input device to sketch in a view.<P>
</UL>
 This section describes how a MacApp application draws its views. For information on drawing with the mouse, see <A HREF=MacAppProgGuide-67.html#MARKER-9-168>page 226</A>.<P>
 MacApp calls the <CODE><A NAME=MARKER-2-57></A>Draw</CODE> method whenever a view needs to be redrawn. Redrawing is necessary not only when a change is made in the view but also when the view is first shown or when any part of the view is uncovered by a user action. Since the <CODE>Draw</CODE> method of <CODE>TView</CODE> does nothing, you must override <CODE>Draw</CODE> in your view subclass and provide code to draw your view's contents.<P>
 When MacApp calls the view's <CODE>Draw</CODE> method, it passes a parameter specifying the minimum rectangle that needs to be redrawn. You can use this information to optimize your <CODE>Draw</CODE> method to draw only the specified portion.<P>
 <A HREF=#MARKER-9-59>Figure 8-4</A> shows how MacApp calls your drawing routines to update the views in a window. The <CODE>Draw</CODE> method is called by the <CODE>HandleDraw</CODE> method of your view object (or by <CODE>gDrawAdorner</CODE>--see <A HREF=#MARKER-9-77>"MacApp's Adorner Classes," beginning on page 213</A>).<P>
<B>Figure 8-4  <A NAME=MARKER-9-59></A>How MacApp updates the views in a window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-021.gif"><P>
 MacApp calls <CODE>HandleDraw</CODE>, which calls the <CODE>Draw</CODE> method of the view and then the <CODE>HandleDraw</CODE> method of all subviews. <CODE>HandleDraw</CODE> also manages the drawing of adorners, described in <A HREF=#MARKER-9-74>"Adorners," beginning on page 213</A>. You rarely, if ever, call <CODE>Draw</CODE> yourself; instead, you call one of the view methods <CODE><A NAME=MARKER-2-60></A>InvalidateRect</CODE>, <CODE><A NAME=MARKER-2-61></A>InvalidateRegion</CODE>, or <CODE><A NAME=MARKER-2-62></A>InvalidateVRect</CODE> to invalidate the part of your view that has changed. You can also call <CODE>ForceRedraw</CODE> to invalidate the entire view extent.<P>
 In response to update events, MacApp calls the <CODE>Draw</CODE> method of any view that has an area that is both visible and invalid.<A NAME=MARKER-9-63></A> If you need to redraw a view immediately, you can call its <CODE>Update</CODE> method (after invalidating).<P>
 Your <CODE>Draw</CODE> method can do any kind of drawing it wants, using the Macintosh QuickDraw routines. When MacApp calls your <CODE>Draw</CODE> method, the view has already been focused, so that any QuickDraw calls you make are drawn in your view. (Focusing is described in the next section.) You use your view's local coordinate system, and the drawing takes place in the correct location. Drawing is clipped to the view's superview. <P>
 You can read more about Macintosh drawing in <I>Inside Macintosh: Imaging <BR>With QuickDraw</I>. <A NAME=MARKER-2-64></A><P>
<A NAME=HEADING65-70></A>
<H2><A NAME=MARKER-2-65></A><A NAME=MARKER-9-66></A>Focusing</H2>
 Before drawing can take place, a view must be prepared so that drawing will appear in the correct place on the screen. This is called <A NAME=MARKER-2-67></A><B>focusing</B> the view. Focusing includes setting the QuickDraw graphics port, setting the port's coordinate system to match the view's coordinates, and clipping the view's drawing to the margins of its superview (clipping is shown in <A HREF=#MARKER-9-52>Figure 8-3</A>).<P>
 To focus a view in MacApp, you call the <CODE>TView::<A NAME=MARKER-2-68></A>Focus</CODE> method. MacApp automatically calls <CODE>Focus</CODE> at many times, including when a view is activated, updated, zoomed, or drawn. The global variable <CODE><A NAME=MARKER-2-69></A>gFocusedView</CODE> is set to refer to the currently focused view. MacApp uses <CODE>gFocusedView</CODE> to avoid performing unnecessary calculations when <CODE>Focus</CODE> is called for a view that is already focused.<P>
 If necessary, the <CODE>TView::Focus</CODE> method sets the current port to the port of the window the view resides in, calls the Toolbox routine <CODE><A NAME=MARKER-2-70></A>SetOrigin</CODE> to set the port's origin to the origin of the view, and clips the view to the visible area of its superview.<P>
 The <CODE>Focus</CODE> method recursively calls <CODE><A NAME=MARKER-2-71></A>FocusOnSuperView</CODE>, which calls <CODE>Focus</CODE> for the view's superview if it has one. View hierarchies always have a window as the topmost view, and the <CODE>TWindow::Focus</CODE> method sets the clip region to the window's update region, if there is an update pending; otherwise, it sets the clip region to the window's visible region.<P>
 <CODE>Focus</CODE> returns <CODE>FALSE</CODE> if it is unable to focus. For example, <CODE>Focus</CODE> fails if no superview is able to supply a port--that is, if the view is not in a window and the application is not printing or drawing into a QuickDraw <CODE>Picture</CODE>.<P>
 <CODE>Focus</CODE> returns <CODE>TRUE</CODE>, however, if it is able to focus but none of the view is currently visible due to clipping or scrolling by a superview. This allows you to assemble a view hierarchy and focus its views without necessarily showing them to the user. After focusing, you can call the <CODE>TView</CODE> method <CODE>IsVisible</CODE> to determine whether the view is in fact visible. MacApp never asks a view to draw unless it is visible.<A NAME=MARKER-2-72></A><P>
<A NAME=HEADING65-77></A>
<H2><A NAME=MARKER-2-73></A><A NAME=MARKER-9-74></A><A NAME=MARKER-2-75></A>Adorners</H2>
 An adorner is a graphical object that knows how to draw in the view to which it is attached. Each view object contains a list of zero or more adorners. Whenever the view's <CODE>Draw</CODE> method is called, the <CODE>DrawAdorners</CODE> method is also called (if the view has any adorners). The <CODE><A NAME=MARKER-2-76></A>DrawAdorners</CODE> method iterates through the view's list of adorners, calling the <CODE>Draw</CODE> method for each adorner. <P>
 Adorners can be used to<P>
<UL>
<LI>adorn controls in dialog boxes (such as 3D control buttons)
<LI>draw borders in views
<LI>draw the publisher and subscriber borders for Edition Manager support
<LI>perform highlighting in views<P>
</UL>
 An adorner can be associated with multiple views, so you can create an adorner to perform a special kind of drawing and attach it to all the views that can benefit from that drawing. You can specify an adorner for a view in a <CODE>'View'</CODE> resource with a view-editing application, or you can add an adorner to a view object in your application by calling the view's <CODE>AddAdorner</CODE> method.<P>
<A NAME=HEADING65-85></A>
<H3><A NAME=MARKER-9-77></A>MacApp's Adorner Classes</H3>
 MacApp defines a number of adorner subclasses that you can instantiate in your application, each of which implements a specific kind of drawing or highlighting. These include frame adorners, line adorners, oval adorners, and rectangular adorners.<P>
 MacApp also provides global access to certain standard adorners it creates:<P>
<DL>
<DT><CODE>gDimAdorner<B></B></CODE>
<DD> The <CODE>Draw</CODE> method of <CODE>gDimAdorner</CODE> calls the <CODE><A NAME=MARKER-2-78></A>Dim</CODE> method of the view it is attached to.
<DT><CODE>gDrawAdorner<B></B></CODE>
<DD> The <CODE>Draw</CODE> method of <CODE>gDrawAdorner</CODE> calls the <CODE>Draw</CODE> method of the view. It is added to a view's adorner list automatically if the view has any other adorners, so you have control over when the view is drawn relative to the other adorners (as described in <A HREF=#MARKER-9-85>"Adorner Priorities," beginning on page 215</A>).
<DT><CODE>gEraseAdorner<B></B></CODE>
<DD> The <CODE>Draw</CODE> method of <CODE>gEraseAdorner</CODE> erases the area of the view that will be drawn. This adorner is automatically added to window objects.
<DT><CODE>gHiliteAdorner<B></B></CODE>
<DD> The <CODE>Draw</CODE> method of <CODE>gHiliteAdorner</CODE> calls the <CODE><A NAME=MARKER-2-79></A>Hilite</CODE> method of the view.
<DT><CODE>gPrintAdorner<B></B></CODE>
<DD> The <CODE>DoHighlightSelection</CODE> method of <CODE>gPrintAdorner</CODE> calls the <CODE>DoDrawPrintFeedback</CODE> method of the view. This adorner is added automatically by MacApp when a print handler is attached to the view.
<DT><CODE>gResizeIconAdorner</CODE>
<DD> The <CODE>DoHighlightSelection</CODE> method of <CODE>gResizeIconAdorner</CODE> calls the window's <CODE><A NAME=MARKER-2-81></A>DrawResizeIcon</CODE> method. This adorner is added automatically to any resizable window object.
<DT><CODE>gSelectionAdorner</CODE>
<DD> The <CODE>DoHighlightSelection</CODE> method of <CODE>gSelectionAdorner</CODE> calls the <CODE>DoHighlightSelection</CODE> method of the view.
<DT><B>Note</B>
<DD>The <CODE>TAdorner</CODE> class has an instance variable <CODE><A NAME=MARKER-2-82></A>fIdentifier</CODE>, of type <CODE>IDType</CODE>, that specifies the type of adorner object. MacApp defines identifier constants for its predefined adorner classes in the UAdorners unit.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING65-96></A>
<H3>How a View's Adorners Are Drawn</H3>
 A view is drawn through a call to its <CODE>HandleDraw</CODE> method, which behaves as follows:<P>
<OL>
<LI>If the view has any adorners, the view's <CODE>DrawAdorners</CODE> method is called to iterate over the list of adorners. If the view has no adorners, the view's <CODE>Draw</CODE> method is called instead.<P>
When a view <I>does</I> have adorners, MacApp automatically installs <CODE>gDrawAdorner</CODE> so that the view's own <CODE>Draw</CODE> method is always called, and so that you have control over when it gets drawn relative to the other adorners (as described in the next section).
<LI>Each behavior attached to the view is given an opportunity to draw.
<LI>The <CODE>HandleDraw</CODE> method is called for each subview of the view.
<LI>The <CODE>HighlightAdorners</CODE> method of the view is called to iterate through the list of highlighting adorners attached to the view and call the <CODE>DoHighlightSelection</CODE> method of each adorner that needs to perform highlighting.<P>
</OL>
<A NAME=HEADING65-103></A>
<H3><A NAME=MARKER-9-85></A>Adorner Priorities</H3>
 You use the <CODE>TView</CODE> method <CODE><A NAME=MARKER-2-86></A>AddAdorner</CODE> to add an adorner to a view's list of adorners. <CODE>AddAdorner</CODE> is defined as follows:<P>
<PRE>
virtual void AddAdorner ( TAdorner *anAdorner;
                     AdornPriority itsPriority,
                     Boolean invalidate );
</PRE>
 The <CODE>itsPriority</CODE> parameter specifies the drawing priority for the adorner in the list: the lower the priority value, the earlier the adorner is called to draw. MacApp defines several adornment priority constants:<P>
<PRE>
const short kAdornLast  = 127;
const short kAdornAfter  = kAdornLast - 32;
const short kDrawView  = 64;
const short kAdornBefore = kDrawView - 32;
const short kAdornFirst  = 0;
</PRE>
 The priority assigned to calling the view's own <CODE>Draw</CODE> method is <CODE>kDrawView</CODE>. If you add an adorner with a priority lower than <CODE>kDrawView</CODE>, it will be drawn before the view's <CODE>Draw</CODE> method; with a higher priority, it will be drawn after the view's <CODE>Draw</CODE> method. You never specify a priority value of <CODE>kDrawView</CODE> for an adorner that you add. Always use a value that is lower or higher than <CODE>kDrawView</CODE>.<A NAME=MARKER-2-87></A><A NAME=MARKER-2-88></A><P>
<A NAME=HEADING65-109></A>
<H2><A NAME=MARKER-9-89></A>Highlighting in a View<A NAME=MARKER-2-90></A></H2>
 Highlighting is performed whenever a view is drawn and whenever the view's highlight state changes (becoming active or inactive). Highlighting is not performed for printing or imaging for the Clipboard.<P>
 MacApp's highlighting mechanism works through the combined effort of view and adorner objects.  A view uses highlighting<P>
<UL>
<LI>to show that an item within the view has been selected by the user
<LI>to provide an outline of draggable data when a drag is initiated
<LI>to show that the view can accept data that is dragged over it
<LI>to show that the view is not currently active<P>
</UL>
 MacApp's designators provide a standard way to keep track of what is selected in a view. Designators are described in <A HREF=MacAppProgGuide-57.html#MARKER-9-23>Chapter 7, "Document Handling."</A> Visual feedback for drag and drop is described in <A HREF=MacAppProgGuide-72.html#MARKER-9-29>Chapter 9, "Drag and Drop."</A><P>
 When MacApp draws a view, it first focuses the view <A HREF=#MARKER-9-66>(page 212)</A>, then calls the view's <CODE>Draw</CODE> method <A HREF=#MARKER-9-56>(page 210)</A>, then calls the <CODE>HighlightAdorners</CODE> method. The <CODE>HighlightAdorners</CODE> method iterates over the view's adorners, giving each adorner a chance to draw its adornment in the view.<P>
<A NAME=HEADING65-118></A>
<H3><A NAME=MARKER-2-92></A>Highlighting and Selection Adorners</H3>
 MacApp supplies every application with a number of global adorner objects, including two that are useful for highlighting and selecting, <CODE>gHiliteAdorner</CODE> and <CODE>gSelectionAdorner</CODE>. <P>
<UL>
<LI>The <CODE>Draw</CODE> method of the <CODE><A NAME=MARKER-2-93></A>THiliteAdorner</CODE> class calls the <CODE>Hilite</CODE> method of its view. In <CODE>TView</CODE>, the <CODE>Hilite</CODE> method just inverts the view's QuickDraw extent. The <CODE>TControl</CODE> view class overrides the <CODE>Hilite</CODE> method to invert the control area when the user clicks the control.
<LI>The <CODE>Draw</CODE> method of <CODE><A NAME=MARKER-2-94></A>TSelectionAdorner</CODE> calls the <CODE>DoHighlightSelection</CODE> method of its view. In <CODE>TView</CODE>, the <CODE>DoHighlightSelection</CODE> method does nothing. A view class can override this method to highlight user selections in the view. MacApp's <CODE>TGridView</CODE> class provides an example of how the selection adorner is used--it adds <CODE>gSelectionAdorner</CODE> to its adorner list in its initialization method.<P>
</UL>
<A NAME=HEADING65-122></A>
<H3><A NAME=MARKER-2-96></A>Highlighting States</H3>
 MacApp defines the <CODE>HLState</CODE> type for storing a highlight state, along with constants for specifying the different states of highlighting in a view. These states apply to the view itself or to selected items in the view:<P>
<DL>
<DT><CODE><A NAME=MARKER-2-97></A>hlOff</CODE>
<DD> The view is unhighlighted.
<DT><CODE><A NAME=MARKER-2-98></A>hlDim</CODE>
<DD> The view is dimly highlighted (inactive).
<DT><CODE><A NAME=MARKER-2-99></A>hlOn</CODE>
<DD> The view is fully highlighted (active).
</DL>
 You pass these constants to view highlighting methods to indicate the previous state and the desired state of highlighting.<P>
 For example, the <CODE>DoHighlightSelection</CODE> method is defined as follows:<P>
<PRE>
void DoHighlightSelection(HLState fromHL, HLState toHL);
</PRE>
 A view must be focused before calling <CODE>DoHighlightSelection</CODE>; you can ensure this, as MacApp does, by calling the <CODE>Focus</CODE> method of the view object before calling <CODE>DoHighlightSelection</CODE>.<A NAME=MARKER-2-100></A><A NAME=MARKER-2-101></A><P>
<A NAME=HEADING65-131></A>
<H2><A NAME=MARKER-2-102></A><A NAME=MARKER-9-58></A>Specifying Views With View Resource Templates</H2>
 MacApp provides a useful tool for defining views and view hierarchies: view resource templates. A <B>view resource template</B> defines the resource format for a MacApp view class. View resource templates are defined as <CODE>'<A NAME=MARKER-2-104></A>View'</CODE> resource definitions in the file <CODE>ViewTypes.r</CODE>.<P>
 You can use a resource-editing application that knows about <CODE>'View'</CODE> resource templates, such as Ad Lib (available from Apple Computer), to create view resources that specify the user interface for your application. A view resource can define an entire window or view hierarchy, containing many MacApp view objects, such as views that represent checkboxes, radio buttons, and other controls. You can specify the initial settings for any window or view in the view hierarchy. And you can reuse a view resource whenever you need a view of the same type. For example, all documents of a given type can create their views using the same view resource.<P>
 By editing your view resources and rebuilding the application, you can change the appearance and initial settings of your windows without recompiling your application's code. This allows great flexibility in changing the appearance and behavior of your views, with fast turnaround. For more information, see <A HREF=MacAppProgGuide-101.html#MARKER-9-58>"Working With View Resource Templates," beginning on page 425</A>.<P>
 Your application uses MacApp's global view server object, <CODE>gViewServer</CODE> (described in the next section) to create windows and views based on the view resources you have defined.<P>
<A NAME=HEADING65-136></A>
<H3><A NAME=MARKER-2-105></A><A NAME=MARKER-9-50></A>The TViewServer Class</H3>
 The <CODE><A NAME=MARKER-2-107></A>TViewServer</CODE> class provides methods to manage the creation of views for your application. During initialization of the application, MacApp automatically creates a <CODE>TViewServer</CODE> object and stores a reference to it in the global variable <CODE><A NAME=MARKER-2-108></A>gViewServer</CODE>. You create views by calling on the methods of <CODE>gViewServer</CODE> listed here:<P>
<DL>
<DT><CODE><A NAME=MARKER-2-109></A>NewPaletteWindow</CODE>
<DD> Creates a window that has a main view which may or may not scroll, plus a nonscrolling palette along the left edge or a nonscrolling status area at the top of the window.
<DT><CODE><A NAME=MARKER-2-110></A>NewSimpleWindow</CODE>
<DD> Creates a simple window that contains one view, which may or may not scroll.
<DT><CODE><A NAME=MARKER-2-111></A>NewTemplateWindow</CODE>
<DD> Creates a window from a <CODE>'View'</CODE> resource. The window may have a view hierarchy of arbitrary complexity.
<DT><CODE><A NAME=MARKER-2-112></A>DoCreateViews</CODE>
<DD> Creates a view hierarchy of arbitrary complexity from a <CODE>'View'</CODE> resource, then calls the <CODE>DoPostCreate</CODE> method. The view hierarchy is not assumed to have a window at its root.
</DL>
 <A HREF=#MARKER-9-117>Figure 8-5</A> shows the process of creating a view hierarchy from a view resource. In this example, a document's <CODE>DoMakeViews</CODE> method calls the <CODE>NewTemplateWindow</CODE> method of the <CODE>gViewServer</CODE> object. <CODE>NewTemplateWindow</CODE> calls the <CODE>DoCreateViews</CODE> method, which uses MacApp's streaming mechanism to create the view objects specified by the view resource. After the whole view hierarchy has been created, the <CODE>DoCreateViews</CODE> method calls the <CODE>DoPostCreate</CODE> method for each view it creates, giving each view a chance to perform additional initialization that may depend on the existence of other views in the hierarchy.<A NAME=MARKER-2-114></A><A NAME=MARKER-2-115></A><A NAME=MARKER-2-116></A><P>
<B>Figure 8-5  <A NAME=MARKER-9-117></A>Creating a window from a resource template</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-020.gif"><P>
<A NAME=HEADING65-145></A>
<H3><A NAME=MARKER-2-118></A><A NAME=MARKER-9-119></A>Registering View Classes</H3>
 If your application uses resources to define view hierarchies, it must register its view classes so that the view server can create views based on class names stored in the view resource. To register your view classes, MacApp provides the <CODE>MA_REGISTER_CLASS</CODE> macro, which is invoked with a line like one of the following:<P>
<PRE>
MA_REGISTER_CLASS(TYourViewClass);
</PRE>
 or<P>
<PRE>
MA_REGISTER_SIGNATURE(TYourViewClass,KYourViewSignature);
</PRE>
 For more information on the <CODE>MA_REGISTER_CLASS</CODE> macro, see <A HREF=MacAppProgGuide-23.html#MARKER-9-37>"Registering Class Information," beginning on page 30</A>.<P>
<A NAME=HEADING65-151></A>
<H2><A NAME=MARKER-2-120></A><A NAME=MARKER-9-121></A>Scrolling</H2>
 Most windows that display data on the Macintosh feature scroll bars that allow the user to scroll through the data when it cannot all be displayed at once in its enclosing view. MacApp provides the <CODE>TScroller</CODE> subclass of <CODE>TView</CODE> to manage scrolling of the data displayed in views and the <CODE>TScrollerScrollBar</CODE> class to display a scroll bar that knows how to work with a <CODE><A NAME=MARKER-2-124></A>TScroller</CODE> object. <A HREF=#MARKER-9-50>Figure 8-2 on page 208</A> shows a view hierarchy with a scroller view and scroll bars.<P>
 Scrolling is implemented by adding a scroller view to the view hierarchy, beneath the view or views to be scrolled. The scroller view is invisible--it exists merely to impose a translation on the contents of the window. The scroller view shifts the coordinates of any view drawn on top of it by a translation amount. The translation amount may be specified by user manipulation of a scroll bar but is not limited to that source.<P>
 When a scroller scrolls, it offsets the visible region of the view or views to be scrolled by the translation amount. It then calls the Toolbox routine <CODE><A NAME=MARKER-2-125></A>ScrollRect</CODE>, which moves the specified data (up, down, left, or right) and returns a region showing the area that needs to be redrawn (the area that is scrolled into view). The scroller then invalidates that region, causing it to be redrawn. Using this mechanism, only the new area that was scrolled into view needs to be redrawn.<P>
 As with any view, drawing in a scroller is clipped to the superview.<P>
<A NAME=HEADING65-156></A>
<H3><A NAME=MARKER-2-126></A><A NAME=MARKER-9-127></A>Autoscrolling</H3>
 <B>Autoscrolling</B> is the process of scrolling automatically when a user moves the cursor to the boundaries of a view. MacApp supports autoscrolling in its tracker commands, which are described in more detail in <A HREF=MacAppProgGuide-67.html#MARKER-9-168>"Drawing With the Mouse," beginning on page 226</A>. One of the parameters of the <CODE>ITracker</CODE> initialization method of the <CODE>TTracker</CODE> command is<P>
<PRE>
TScroller* itsScroller
</PRE>
 If your drawing view contains a scroller subview, and if you supply a reference to that scroller when initializing a drawing command that descends from <CODE><A NAME=MARKER-2-128></A>TTracker</CODE>, the drawing command will automatically support autoscrolling in the view. You can use the <CODE>GetScroller</CODE> method of <CODE>TView</CODE> to obtain a reference to a view's enclosing scroller, if any. For more details, see <A HREF=MacAppProgGuide-96.html#MARKER-9-34>"Recipe--Implementing Autoscrolling" on page 396</A>.<P>
 MacApp also supports autoscrolling automatically for drag operations in its views that support drag and drop.<P>
<A NAME=HEADING65-161></A>
<H3><A NAME=MARKER-2-129></A>Synchronized Scrolling</H3>
 <B>Synchronized scrolling</B> refers to the simultaneous scrolling of more than one view. MacApp provides the <CODE><A NAME=MARKER-2-130></A>TPrimaryScroller</CODE> and <CODE><A NAME=MARKER-2-131></A>TSecondaryScroller</CODE> classes to implement synchronized scrolling. A <CODE>TPrimaryScroller</CODE> object has a list of secondary scrollers. If that list is not <CODE>NULL</CODE>, when the primary scroller scrolls, it makes the scrollers in the list scroll too.<P>
 Synchronized scrolling is demonstrated in the Calc sample application.<A NAME=MARKER-2-132></A><A NAME=MARKER-2-133></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-64.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-66.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
