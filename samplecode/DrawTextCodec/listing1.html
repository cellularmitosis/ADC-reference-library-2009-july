<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DrawTextCodec - /CodecTestMain.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxQuickTimeComponentCreation-date.html">QuickTime Component Creation</a> &gt; <A HREF="javascript:location.replace('index.html');">DrawTextCodec</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DrawTextCodec</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CodecTestMain.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CodecTestMain.c</option>
<option value="listing2.html">/DrawTextCodec.h</option>
<option value="listing3.html">/DrawTextComponent.c</option>
<option value="listing4.html">/DrawTextCompress.c</option>
<option value="listing5.html">/DrawTextDecompress.c</option></select>
				</p>
				</form>
				<p><strong><a href="DrawTextCodec.zip">Download Sample</a></strong> (&#147;DrawTextCodec.zip&#148;, 40.4K)<BR>
<strong><a href="DrawTextCodec.dmg">Download Sample</a></strong> (&#147;DrawTextCodec.dmg&#148;, 103.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    CodecTestMain.c  Contains:    Written by: Mark Krueger    Copyright:  Copyright &copy; 1992-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/29/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#ifdef  THINK_C//#define  OpenStdCompression  OPENSTDCOMPRESSION#endif#include  &lt;QuickTimeComponents.h&gt;#include  &lt;ImageCompression.h&gt;#include  &quot;DrawTextCodec.h&quot;#define  dangerousPattern//#define  DONT_SHOW_PICTURE//#define  DONT_DO_PREVIEW#include  &lt;Types.h&gt;#include  &lt;Files.h&gt;#include  &lt;Quickdraw.h&gt;#include  &lt;Packages.h&gt;#include  &lt;Memory.h&gt;#include  &lt;Fonts.h&gt;#include  &lt;Events.h&gt;#include  &lt;OSUtils.h&gt;#include  &lt;ToolUtils.h&gt;#include  &lt;Menus.h&gt;#include  &lt;Dialogs.h&gt;#include  &lt;stdio.h&gt;#include  &lt;Errors.h&gt;#include  &lt;Scrap.h&gt;#include  &lt;Desk.h&gt;#include  &lt;string.h&gt;#include  &lt;GestaltEqu.h&gt;#include  &lt;Resources.h&gt;#include  &lt;Finder.h&gt;#include  &lt;palettes.h&gt;#include  &lt;PictUtils.h&gt;#include  &lt;QDOffscreen.h&gt;#include  &lt;Windows.h&gt;#include  &lt;FixMath.h&gt;#include  &lt;ImageCodec.h&gt;#ifndef  THINK_C#include  &lt;Strings.h&gt;#endif#include  &lt;ImageCompression.h&gt;#define    appleMenuID    128#define    fileMenuID    129#define    editMenuID    130#define    M_OPEN      1#define    M_CLOSE      3#define    M_SAVE      4#define    M_COMP      6#define    M_QUIT      8#define    M_COPY      4#define    M_PASTE      5#define    M_FIT      10Boolean    gDitherFlag  = false;StandardFileReply  gOriginalSFR;  short      gOriginalFile;Cursor      **gWatch;short      gCompressedFile;Boolean      gExitFlag = false;MenuHandle    gMenus[3];      // our menusCWindowPtr    gActiveWindow = nil;CWindowPtr    gOrigWindow = nil;CWindowPtr    gCompWindow = nil;Rect      gOriginalPicFrame;Rect      gZoomedPictureFrame;Boolean      gZoomed = false;Boolean      gFitToWindow = true;Boolean      gHasNewStdFile = false;PicHandle    gOriginalPicture = nil;Boolean      gCompressed = false;Boolean      gSevenOh = false;short      gDepth = 1;ComponentInstance  gSCComponent;SCParams      gSCParams;Boolean      gDidError = false;GWorldPtr  gworld,compgworld;int Initialize();void Error(char *msg);pascal OSErrProgress(short progressMsg,Fixed progressPercent,long refcon);int DoCompression(CWindowPtr  window);void DoError();void FitRect(Rect *rect,short w,short h);void DoOpen(FSSpec *fsp);void DoClose(CWindowPtr w);void DoSave(CWindowPtr w) ;void FixMenus();void DoPaste();void DoCopy(CWindowPtr w);void DoUpdate(CWindowPtr w);void DoSizeWindow(CWindowPtr wind,short h,short v,Boolean fup);void DoZoom(WindowPtr wind);void DoGrow(WindowPtr wind,Point *where);void DoCommand(long  mResult);/************************************************ * *  Set up application environment. * ************************************************/int Initialize(){  Ptr  size;    size = GetApplLimit();  SetApplLimit(size - 32*1024);    /* make room on stack so Quickdraw can do big pictures */  MaxApplZone();  /*  initialize managers */  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  InitDialogs(nil);  InitCursor();  ErrorSound(nil);    /*  install menus */    if ( (gMenus[0] = GetMenu(appleMenuID)) == nil )    return(-1);  AppendResMenu(gMenus[0], (ResType) 'DRVR');  InsertMenu(gMenus[0], 0);  if ( (gMenus[1] = GetMenu(fileMenuID)) == nil )    return(-1);  InsertMenu(gMenus[1], 0);  if ( (gMenus[2] = GetMenu(editMenuID)) == nil )    return(-1);  InsertMenu(gMenus[2], 0);  DrawMenuBar();  if ( (gWatch =  GetCursor(watchCursor)) == nil )    return(-1);  HNoPurge((Handle)gWatch);  return(0);}/************************************************ * *  Report errors as needed. * ************************************************/void Error(char *msg){  SysBeep(1);  ParamText(&quot;\pError:&quot;,c2pstr(msg),nil,nil);  /* oops da baby */  Alert(128,nil);}/************************************************ * *  Progress proc called from the Image Compression manager. * ************************************************/pascal OSErrProgress(short progressMsg,Fixed progressPercent,long refcon){  OSErr  result = noErr;  short kind;  Handle h;  Rect r;  CGrafPtr savePort,wmgPort;  GDHandle saveGD;  static DialogPtr progressDialog = 0;  KeyMap  keys;  switch (progressMsg) {    case codecProgressOpen:      progressDialog = 0;    GetGWorld(&amp;savePort,&amp;saveGD);    GetCWMgrPort(&amp;wmgPort);    SetGWorld(wmgPort,nil);    if ( refcon != -1 &amp;&amp; (progressDialog = GetNewDialog(5002, 0, (WindowPtr)-1)) != nil ) {       ShowWindow((WindowPtr)progressDialog);      SetGWorld((CGrafPtr)progressDialog,nil);      DrawDialog(progressDialog);      GetDialogItem(progressDialog, 1, &amp;kind, &amp;h, &amp;r);      InsetRect(&amp;r, -1, -1);      FrameRect(&amp;r);      InsetRect(&amp;r, 1, 1);    }    SetGWorld(savePort,saveGD);    break;  case codecProgressUpdatePercent:      if ( progressDialog ) {      GetGWorld(&amp;savePort,&amp;saveGD);      SetGWorld((CGrafPtr)progressDialog,nil);      GetDialogItem(progressDialog, 1, &amp;kind, &amp;h, &amp;r);            FillRect(&amp;r,&amp;qd.gray);      r.right = r.left + FixRound( FixMul(progressPercent, FixRatio(r.right-r.left,1)));      PaintRect(&amp;r);      SetGWorld(savePort,saveGD);    }      /* check for command period - not the best way, but it works */    GetKeys(keys);    if ( (keys[1] &amp; 0x8000) &amp;&amp; ((0x800000 &amp; keys[1]) || (0x2000000 &amp; keys[1])  ) )      result = codecAbortErr;    break;    case codecProgressClose:      if ( progressDialog )      DisposeDialog(progressDialog);    progressDialog = 0;    break;  }  return(result);}  /************************************************ * *  Allow the user to specify compression and an output file, and then *  compress the picture and save the result in that file. * ************************************************/int DoCompression(CWindowPtr  window){  /* StdFile stuff */    CGrafPtr  savePort;  GDHandle  saveGD;  /* for sepecifying compression */    Rect    pictureFrame;  OSErr    result;  Point    where;  ImageDescriptionHandle desc = nil;  Ptr  data = nil;  long  cdsize;  ICMProgressProcRecord  *progP,progressRec;  Str255    buf;  GrafPtr    wmPort;    progressRec.progressProc = NewICMProgressProc(Progress);  progressRec.progressRefCon = 0;  progP = &amp;progressRec;      if ( window == nil )    return -1;  pictureFrame = ((CGrafPtr)window)-&gt;portRect;  /************************************************   *   *    Ask how the user wants to compress it.   *   ************************************************/    SetCursor(&amp;qd.arrow);  if (SCSetTestImagePixMap(gSCComponent,gworld-&gt;portPixMap,&amp;gworld-&gt;portRect,0))    goto done;  GetWMgrPort(&amp;wmPort);  SetPort(wmPort);  where.h = where.v = -2;    // position dialog on the best device  if (SCGetCompression(gSCComponent,&amp;gSCParams,where))    goto done;    /************************************************   *   *    Ask her for the name of the new file.   *   ************************************************/    SetCursor(*gWatch);  if ( (result=GetMaxCompressionSize(gworld-&gt;portPixMap,&amp;gworld-&gt;portRect,      gSCParams.depth,gSCParams.spatialQuality,gSCParams.theCodecType,      gSCParams.theCodec,&amp;cdsize)) != noErr ) {    Error(&quot;getting max comp size&quot;);    goto done;  }      if ( (data=NewPtr(cdsize)) == nil ) {    Error(&quot;no mem for picture&quot;);    goto done;  }      desc = (ImageDescriptionHandle)NewHandle(sizeof(ImageDescription));  if ( desc == nil ) {    DisposePtr(data);    Error(&quot;no mem for picture&quot;);    goto done;  }          if ( (result=FCompressImage(gworld-&gt;portPixMap,&amp;gworld-&gt;portRect,        gSCParams.depth,gSCParams.spatialQuality,gSCParams.theCodecType,        gSCParams.theCodec,nil,0,0,nil,progP,         desc,data)) != noErr   ) {     DisposePtr(data);     DisposeHandle((Handle)desc);     if ( result != codecAbortErr )       Error(&quot;compressing picture&quot;);    goto done;  }        NumToString((*desc)-&gt;dataSize,buf);  ParamText(&quot;\pCompressed to &quot;,buf,&quot;\pBytes&quot;,nil);  Alert(128,nil);  GetGWorld(&amp;savePort,&amp;saveGD);  SetGWorld(compgworld,nil);    if ( (result=DecompressImage(data,desc,compgworld-&gt;portPixMap,          &amp;gworld-&gt;portRect,&amp;compgworld-&gt;portRect,ditherCopy,nil)) != noErr ) {     DisposePtr(data);     DisposeHandle((Handle)desc);    Error(&quot;compressing picture&quot;);    goto done;  }     DisposePtr(data);   DisposeHandle((Handle)desc);   SetGWorld(gCompWindow,nil);   InvalRect(&amp;gCompWindow-&gt;portRect);  SetGWorld(savePort,saveGD);done:  gDidError = false;  SetCursor(&amp;qd.arrow);    return(result);}      void DoError(){  CGrafPtr  savePort;  GDHandle  saveGD;  RGBColor  opColor;      GetGWorld(&amp;savePort,&amp;saveGD);  SetGWorld(compgworld,nil);  if ( !gDidError ) {    gDidError = true;    opColor.red = opColor.green = opColor.blue = 0;    OpColor(&amp;opColor);    CopyBits((BitMap *)*gworld-&gt;portPixMap,(BitMap *)*((CGrafPtr)compgworld)-&gt;portPixMap,      &amp;gworld-&gt;portRect,&amp;compgworld-&gt;portRect,subPin,nil);  }  opColor.red = opColor.green = opColor.blue = 0xffff;  OpColor(&amp;opColor);  CopyBits((BitMap *)*compgworld-&gt;portPixMap,(BitMap *)*((CGrafPtr)compgworld)-&gt;portPixMap,    &amp;compgworld-&gt;portRect,&amp;compgworld-&gt;portRect,addPin,nil);   SetGWorld(gCompWindow,nil);   InvalRect(&amp;gCompWindow-&gt;portRect);  SetGWorld(savePort,saveGD);}  /************************************************ * *  Massage a rectangle to fit on a device's screen. * ************************************************/void FitRect(Rect *rect,short w,short h){  short   n;  Rect  dRect;  GDHandle  gd;  //  dRect = *rect;  gd = GetGDevice();  dRect =(*gd)-&gt;gdRect;  dRect.top += 40;                /* make way for title bar */  InsetRect(&amp;dRect,16,16);  if ( w &lt; (dRect.right-dRect.left) &amp;&amp;  h &lt; (dRect.bottom-dRect.top) ) {     dRect.right = dRect.left + w;     dRect.bottom = dRect.top + h;  } else if ( gFitToWindow ) {    n = dRect.top + ((dRect.right -dRect.left) * h)/w;    if ( n &gt; dRect.bottom )      dRect.right = dRect.left +((dRect.bottom -dRect.top) * w)/h;    else       dRect.bottom = n;  }  *rect = dRect;}  /************************************************ * *  Ask the user for a pict file to open and open it. * ************************************************/void DoOpen(FSSpec *fsp){  OpenCPicParams  originalPicHeader;  SFTypeList   types = { 'PICT',0 };  OSErr    result = noErr;  long    size;  CGrafPtr  savePort;  GDHandle  saveGD;  Rect    rect;      if ( fsp == nil ) {    if ( gHasNewStdFile )      StandardGetFile(nil,1,types,&amp;gOriginalSFR);    else {      SFReply    osfr;      Point  pt = {100,100};            SFGetFile(pt,(ConstStr255Param)&quot;&quot;,nil,1,types,nil,&amp;osfr);      gOriginalSFR.sfGood = osfr.good;      gOriginalSFR.sfReplacing = osfr.copy;      gOriginalSFR.sfType = osfr.fType;      if ( osfr.good )         FSMakeFSSpec(osfr.vRefNum,0L,osfr.fName,&amp;gOriginalSFR.sfFile);    }    if ( !gOriginalSFR.sfGood  ) {      return ;    }  } else {    gOriginalSFR.sfFile = *fsp;  }      SetCursor(*gWatch);  if ((result=FSpOpenDF(&amp;gOriginalSFR.sfFile,fsRdPerm,&amp;gOriginalFile)) != noErr ) {    goto done;  }      /************************************************   *   *  Get the picture frame, to see how big of a window to make.   *   ************************************************/  if ( (result=GetPictureFileHeader(gOriginalFile,&amp;gOriginalPicFrame,&amp;originalPicHeader)) != noErr ) {    FSClose(gOriginalFile);    goto done;  }  /************************************************   *   *  Figure out the best screen to show the picture on, and if   *  it doesn't fit, then scale it to fit while maintaining aspect ratio.   *   ************************************************/      SetRect(&amp;gZoomedPictureFrame,-32767,-32767,32767,32767);  FitRect(&amp;gZoomedPictureFrame,gOriginalPicFrame.right-gOriginalPicFrame.left,    gOriginalPicFrame.bottom-gOriginalPicFrame.top);  gZoomed = false;  /************************************************   *   *  Create a window for the picture, and set our port to it.   *   ************************************************/  if ( (gOrigWindow = (CWindowPtr)NewCWindow(nil,&amp;gZoomedPictureFrame,gOriginalSFR.sfFile.name,true,        zoomDocProc,(WindowPtr)-1,true,0)) == nil ) {    FSClose(gOriginalFile);    result = -1;    goto done;  }  rect = gZoomedPictureFrame;//  OffsetRect(&amp;rect,(rect.right-rect.left)+10,0);  OffsetRect(&amp;rect,50,50);  if ( (gCompWindow = (CWindowPtr)NewCWindow(nil,&amp;rect,&quot;\pCompressed&quot;,true,        zoomDocProc,(WindowPtr)-1,true,0)) == nil ) {    FSClose(gOriginalFile);    result = -1;    goto done;  }  SetPort((GrafPtr)gActiveWindow);  if ( GetEOF(gOriginalFile,&amp;size) == noErr ) {    size -= 512;    if ( gOriginalPicture = (PicHandle)NewHandle(size) ) {      HLock((Handle)gOriginalPicture);      SetFPos(gOriginalFile,fsFromStart,512);      FSRead(gOriginalFile,&amp;size,*(Handle)gOriginalPicture);      HUnlock((Handle)gOriginalPicture);      HPurge((Handle)gOriginalPicture);    }  }    rect = gZoomedPictureFrame;    OffsetRect(&amp;rect,-rect.left,-rect.top);    if ( (result=NewGWorld(&amp;gworld,gDepth,&amp;rect,nil,nil,0)) != 0 ) {    if ( (result=NewGWorld(&amp;gworld,gDepth,&amp;rect,nil,nil,8)) != 0 ) {      Error(&quot;No mem for gworld&quot;);      goto done;    }  }  if ( (result=NewGWorld(&amp;compgworld,gDepth,&amp;rect,nil,nil,0)) != 0 ) {    if ( (result=NewGWorld(&amp;compgworld,gDepth,&amp;rect,nil,nil,8)) != 0 ) {      Error(&quot;No mem for gworld&quot;);      DisposeGWorld(gworld);      gworld = nil;      goto done;    }  }  GetGWorld(&amp;savePort,&amp;saveGD);  SetGWorld(gworld,nil);  if ( gOriginalPicture &amp;&amp; *gOriginalPicture) {    HNoPurge((Handle)gOriginalPicture);    if ( (result=DrawTrimmedPicture(gOriginalPicture,&amp;rect,nil,gDitherFlag,nil)) != noErr  &amp;&amp; result != codecAbortErr) {      SysBeep(1);    }    HPurge((Handle)gOriginalPicture);  }else {    if ( (result=DrawTrimmedPictureFile(gOriginalFile,&amp;rect,nil,gDitherFlag,nil)) != noErr  &amp;&amp; result != codecAbortErr) {      SysBeep(1);    }  }    SetGWorld(compgworld,nil);  EraseRect(&amp;compgworld-&gt;portRect);  SetGWorld(savePort,saveGD);  SetWRefCon((WindowPtr)gCompWindow,(long)compgworld);  SetWRefCon((WindowPtr)gOrigWindow,(long)gworld);  FSClose(gOriginalFile);  if ( gOriginalPicture ) {    DisposeHandle((Handle)gOriginalPicture);    gOriginalPicture = nil;  }done:  SetCursor(&amp;qd.arrow);  if ( result ) {    SysBeep(1);  }}  /************************************************ * *  Close the window and the file and get rid of any temporary file we may have. * ************************************************/void DoClose(CWindowPtr w){  GWorldPtr  gw;    if ( w == nil )    return;      gw = (GWorldPtr)GetWRefCon((WindowPtr)w);  if ( gw ) {    DisposeGWorld(gw);  }  CloseWindow((WindowPtr)w);  if  ( w == gActiveWindow ) {    gActiveWindow = nil;  }  if ( w == gOrigWindow )      gOrigWindow = nil;  if ( w == gCompWindow )      gCompWindow = nil;  return;}void DoSave(CWindowPtr w) {  long  l,k;  OSErr  e = 0;  PicHandle  pict = nil;  long  i;  short  f = 0;  static Str255  name = &quot;\pPICT&quot;;  StandardFileReply   sfr;  CGrafPtr  savePort;  GDHandle  saveGD;  GWorldPtr  gw;  long zero = 0;        gw = (GWorldPtr)GetWRefCon((WindowPtr)w);  if ( gw == nil )    return;  StandardPutFile((ConstStr255Param)&quot;&quot;,name,&amp;sfr);  if ( sfr.sfGood ) {     GetGWorld(&amp;savePort,&amp;saveGD);    SetGWorld(gw,nil);    pict = OpenPicture(&amp;gw-&gt;portRect);    ClipRect(&amp;gw-&gt;portRect);    CopyBits((BitMap *)*gw-&gt;portPixMap,(BitMap *)*((CGrafPtr)gw)-&gt;portPixMap,      &amp;gw-&gt;portRect,&amp;gw-&gt;portRect,ditherCopy,nil);    ClosePicture();    SetGWorld(savePort,saveGD);    if ( (l=GetHandleSize((Handle)pict)) &lt;= 10 ) {      DisposeHandle((Handle)pict);      Error(&quot;Making Pict&quot;);      return;    }    FSpDelete(&amp;sfr.sfFile);    if ( (e=FSpCreate(&amp;sfr.sfFile,'ppxi','PICT',0)) != noErr  ) {      Error(&quot;Creating file&quot;);      return;    }    if ( (e=FSpOpenDF(&amp;sfr.sfFile,fsRdWrPerm,&amp;f)) != noErr ) {      Error(&quot;Opening file&quot;);      goto bail;    }    SetFPos(f,fsFromStart,0);    k = 4;    for ( i=0; i &lt; 512/4; i++ ) {      if ( (e=FSWrite(f,&amp;k,(char *)&amp;zero)) != noErr ) {        Error(&quot;Writing file&quot;);        goto bail;      }    }    HLock((Handle)pict);    if ( (e=FSWrite(f,&amp;l,(Ptr)*pict)) != noErr)  {      Error(&quot;Writing file&quot;);      goto bail;    }    SetEOF(f,l+512);bail:      if ( pict )        DisposeHandle((Handle)pict);    if ( f )       FSClose(f);    if ( e )      FSpDelete(&amp;sfr.sfFile);    FlushVol(nil,sfr.sfFile.vRefNum);  }}  /************************************************ * *  Fix the menu hiliting based on conditions. * ************************************************/void FixMenus(){    if ( gActiveWindow == nil ) {    EnableItem(gMenus[1],M_OPEN);    DisableItem(gMenus[1],M_CLOSE);    DisableItem(gMenus[1],M_SAVE);    DisableItem(gMenus[2],M_COPY);  } else  {     DisableItem(gMenus[1],M_OPEN);    EnableItem(gMenus[1],M_CLOSE);    EnableItem(gMenus[1],M_SAVE);//    EnableItem(gMenus[2],M_COPY);  }    if ( gOrigWindow != nil &amp;&amp; gCompWindow != nil )     EnableItem(gMenus[1],M_COMP);  else    DisableItem(gMenus[1],M_COMP);  EnableItem(gMenus[2],M_FIT);//  if ( GetScrap(nil,'PICT',&amp;offset) &gt; 0  ) //    EnableItem(gMenus[2],M_PASTE);//  else    DisableItem(gMenus[2],M_PASTE);}  /************************************************ * *  Paste the PICT from the clip board into a new window, making a temporary *  file for it. * ************************************************/void DoPaste(){}  /************************************************ * *  Copy the open PICT onto the clip board. * ************************************************/void DoCopy(CWindowPtr w){  #pragma unused(w)}  /************************************************ * *  Update the window from the PICT file. * ************************************************/void DoUpdate(CWindowPtr w){  CGrafPtr    savePort;  GDHandle    saveGD;  Rect    srcRect;  GWorldPtr  gw;  if ( w == nil )     return;  SetCursor(*gWatch);  GetGWorld(&amp;savePort,&amp;saveGD);  SetGWorld((CGrafPtr)w,nil);    gw = (GWorldPtr)GetWRefCon((WindowPtr)w);  if ( gw  ) {     srcRect = gw-&gt;portRect;    BeginUpdate((WindowPtr)w);    CopyBits((BitMap *)*gw-&gt;portPixMap,(BitMap *)*((CGrafPtr)w)-&gt;portPixMap,      &amp;srcRect,&amp;((CGrafPtr)w)-&gt;portRect,ditherCopy,nil);      EndUpdate((WindowPtr)w);  }  SetGWorld(savePort,saveGD);  SetCursor(&amp;qd.arrow);}  /************************************************ * *  Resize the window and remember the old size, and force it to update. * ************************************************/void DoSizeWindow(CWindowPtr wind,short h,short v,Boolean fup){  GrafPtr  savePort;  gZoomed = false;  GetPort(&amp;savePort);  SetPort((GrafPtr)wind);  SizeWindow((WindowPtr)wind,h,v,false);  gZoomedPictureFrame = ((CGrafPtr)wind)-&gt;portRect;  LocalToGlobal((Point *)&amp;gZoomedPictureFrame.top);  LocalToGlobal((Point *)&amp;gZoomedPictureFrame.bottom);  if ( fup )    InvalRect(&amp;((CWindowPtr)wind)-&gt;portRect);  SetPort(savePort);}  /************************************************ * *  Handle clicks in the window zoom box. * ************************************************/void DoZoom(WindowPtr wind){  Rect     rect;  Rect     saveRect;  GrafPtr    savePort;  KeyMap    keys;  Boolean    doOriginal;    GetPort(&amp;savePort);  SetPort((GrafPtr)wind);  GetKeys(keys);  doOriginal = (( keys[1] &amp; 4 ) != 0);    /* option key */  if ( doOriginal ) {    gZoomed = false;    FitRect(&amp;gZoomedPictureFrame,gOriginalPicFrame.right-gOriginalPicFrame.left,      gOriginalPicFrame.bottom-gOriginalPicFrame.top);  } else {    if ( gZoomed ) {      gZoomed = false;    } else {      rect = gZoomedPictureFrame;      rect.top += 16;            /* make way for title bar */      InsetRect(&amp;rect,16,16);      ShowHide(wind,0);      MoveWindow(wind,rect.left,rect.top,true);      saveRect = gZoomedPictureFrame;      DoSizeWindow((CWindowPtr)wind,rect.right-rect.left,rect.bottom-rect.top,true);      gZoomedPictureFrame = saveRect;      gZoomed = true;      goto done;    }  }  ShowHide(wind,0);  MoveWindow(wind,gZoomedPictureFrame.left,gZoomedPictureFrame.top,true);  DoSizeWindow((CWindowPtr)wind,gZoomedPictureFrame.right-gZoomedPictureFrame.left,    gZoomedPictureFrame.bottom-gZoomedPictureFrame.top,true);done:  ShowHide(wind,1);  SetPort(savePort);}/************************************************ * *  Grow the window (constrain aspect ratio if option key pressed. * ************************************************/void DoGrow(WindowPtr wind,Point *where){  unsigned long   size;  Rect      sizeRect;  GrafPtr      savePort;  short      h,v;  short      height = gOriginalPicFrame.bottom - gOriginalPicFrame.top;  short      width = gOriginalPicFrame.right - gOriginalPicFrame.left;  KeyMap      keys;  short      minH = 128,minV = 128,maxH = 4096,maxV = 4096;  Boolean      maintainAspect;  Rect      rect;      GetPort(&amp;savePort);  SetPort((GrafPtr)wind);  GetKeys(keys);  maintainAspect = (( keys[1] &amp; 4 ) != 0);  if ( maintainAspect ) {    Rect  oRect;        rect = ((CGrafPtr)wind)-&gt;portRect;    LocalToGlobal((Point *)&amp;rect.top);    LocalToGlobal((Point *)&amp;rect.bottom);    oRect = rect;    if ( width &gt; 2048 || height &gt; 2048 )      FitRect(&amp;rect,width,height);    else if ( width &lt; 1024 &amp;&amp; height &lt; 1024 )      FitRect(&amp;rect,width&lt;&lt;4,height&lt;&lt;4);    else      FitRect(&amp;rect,width&lt;&lt;2,height&lt;&lt;2);    maxH = (rect.right - rect.left);    maxV = (rect.bottom - rect.top);    if ( maxV &lt; minV || maxH &lt; minH ) {      minV = maxV;      minH = maxH;    }    maxV = (maxH * height)/width;    minV = (minH * height)/width;  }  SetRect(&amp;sizeRect,minH,minV,maxH,maxV);  if ( (size = GrowWindow(wind,*where,&amp;sizeRect))  != 0 ) {    h = size &amp; 0xffff;    v = size &gt;&gt; 16;    if ( maintainAspect )      v = (h * height)/width;    DoSizeWindow((CWindowPtr)wind,h,v,true);  }  SetPort(savePort);  FixMenus();}/************************************************ * *  Handle menu commands. * ************************************************/void DoCommand(long  mResult){  short     theMenu, theItem;  GrafPtr  savePort;  Str255    daName;  theItem = ((mResult) &amp; 0xFFFF);  theMenu = (((mResult) &gt;&gt; 16) &amp; 0xFFFF);    /* This is the resource ID */  switch (theMenu) {  case appleMenuID:    if ( theItem != 1 ) {      GetMenuItemText(gMenus[0], theItem, daName);      GetPort(&amp;savePort);      (void) OpenDeskAcc(daName);      SetPort(savePort);    }    break;  case fileMenuID:    {      switch (theItem) {      case M_OPEN:        DoOpen(nil);        break;      case M_CLOSE:        DoClose(gActiveWindow);        break;      case M_COMP:        DoCompression(gActiveWindow);        break;      case M_SAVE:        DoSave(gActiveWindow);        break;      case M_QUIT:        gExitFlag = true;      /* Request exit */        break;      }      FixMenus();    }    break;  case editMenuID:    if ( !SystemEdit(theItem-1) ) {      switch ( theItem ) {      case M_COPY:        DoCopy(gActiveWindow);        break;      case M_PASTE:        DoPaste();        break;      case M_FIT:        DoError();        break;      default:        break;      }    }    FixMenus();    break;  default:    break;  }  HiliteMenu(0);}extern pascal ComponentResult DRAWTEXTCODEC(ComponentParameters *params,Handle storage);/************************************************ * *  Our program. * ************************************************/void main(){  GrafPtr  savePort;  EventRecord myEvent;  Rect    dragRect;  WindowPtr  whichWindow;  long    resp;  if ( Initialize() ) {    SysBeep(1);    ExitToShell();  }    if ( Gestalt(gestaltSystemVersion, &amp;resp) != noErr || resp &lt; 0x700 ) {    gSevenOh = false;  } else {    gSevenOh = true;  }    /*  Check to make sure the image compression manager is installed. */  if ( Gestalt(gestaltCompressionMgr, &amp;resp) != noErr || resp &lt; 15 ) {    SysBeep(1);    ExitToShell();  }  /*  Check to see if new style standard file is around. */  gHasNewStdFile = ( Gestalt(gestaltStandardFileAttr,&amp;resp) == 0 );  /*  Install and open the standard compression component. */  gSCComponent = OpenDefaultComponent('scdi',0);  if (!gSCComponent) {    SysBeep(1);    ExitToShell();  }    /*  Set up the first defaults for compression dialog. */    gSCParams.flags = scListEveryCodec;  gSCParams.theCodecType = 'dtxt';  gSCParams.theCodec = anyCodec;  gSCParams.spatialQuality = codecNormalQuality;  gSCParams.temporalQuality = 0;  gSCParams.depth = 32;  /* install CoDec to test */   {    ComponentDescription td;      Handle  cname = NewHandle(sizeof(CODEC_NAME));    Handle  dname = NewHandle(sizeof(CODEC_NAME));      td.componentType = 'imco';    td.componentSubType = 'dtxt';    td.componentManufacturer = 'mark';    td.componentFlags = codecInfoDoes1;    td.componentFlagsMask = 0;            BlockMove(CODEC_NAME,*cname,sizeof(CODEC_NAME));    RegisterComponent(&amp;td,NewComponentRoutineProc(DRAWTEXTCODEC), 0,cname,nil, nil);          td.componentType = 'imdc';    td.componentFlags = codecInfoDoes1;    BlockMove(CODEC_NAME,*dname,sizeof(CODEC_NAME));    RegisterComponent(&amp;td,NewComponentRoutineProc(DRAWTEXTCODEC), 0,dname,nil, nil);  }  FixMenus();  DoOpen(nil);    while (!gExitFlag ) {        if ( WaitNextEvent( everyEvent, &amp;myEvent, 1, nil) == 0 )      continue;        switch (myEvent.what) {    case mouseDown:      switch ((short)FindWindow(myEvent.where, &amp;whichWindow)) {      case inSysWindow:        SystemClick(&amp;myEvent, whichWindow);        FixMenus();        break;      case inMenuBar:        DoCommand(MenuSelect(myEvent.where));        break;      case inDrag:        GetPort(&amp;savePort);        SetPort((GrafPtr)whichWindow);        SetRect(&amp;dragRect, 4, 20 + 4, qd.screenBits.bounds.right-4, qd.screenBits.bounds.bottom-4);        DragWindow(whichWindow, myEvent.where, &amp;dragRect);        gZoomedPictureFrame = ((CGrafPtr)whichWindow)-&gt;portRect;        LocalToGlobal((Point *)&amp;gZoomedPictureFrame.top);        LocalToGlobal((Point *)&amp;gZoomedPictureFrame.bottom);        SetPort(savePort);        break;      case inGrow:        DoGrow(whichWindow,&amp;myEvent.where);        break;      case inGoAway:        if ( TrackGoAway(whichWindow,myEvent.where)  )           DoClose((CWindowPtr)whichWindow);        FixMenus();        break;      case inZoomIn:        if ( TrackBox(whichWindow,myEvent.where,inZoomIn)  )           DoZoom(whichWindow);        break;      case inZoomOut:        if ( TrackBox(whichWindow,myEvent.where,inZoomOut)  )           DoZoom(whichWindow);        break;      case inContent:        if (whichWindow != FrontWindow())           SelectWindow(whichWindow);        break;            default:        break;      }      break;    case keyDown:      if ( ((myEvent.modifiers &amp; cmdKey) != 0) ) {        char key = myEvent.message &amp; charCodeMask;        DoCommand(MenuKey(key));      }      break;        case updateEvt :      DoUpdate((CWindowPtr)myEvent.message);      break;        case activateEvt:              whichWindow=(WindowPtr)myEvent.message;      if ( (myEvent.modifiers &amp; activeFlag) == 0 )         gActiveWindow = nil;       else         gActiveWindow = (CWindowPtr)whichWindow;      FixMenus();      break;      default:      break;          }  }  DoClose(gActiveWindow);  CloseComponent(gSCComponent);  ExitToShell();}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DrawTextCodec/listing1.html%3Fid%3DDTS10000815-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DrawTextCodec/listing1.html%3Fid%3DDTS10000815-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DrawTextCodec/listing1.html%3Fid%3DDTS10000815-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>