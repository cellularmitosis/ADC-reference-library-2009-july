<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Event-Handling Guide: Handling Mouse Events</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Handling Mouse Events"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000060i-CH6" title="Handling Mouse Events"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../EventsOtherInput-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000447" target="_top">Events &amp; Other Input</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000060i-CH1-SW1">Cocoa Event-Handling Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../EventHandlingBasics/EventHandlingBasics.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HandlingKeyEvents/HandlingKeyEvents.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000060i-CH6-SW1" title="Handling Mouse Events"></a><h1>Handling Mouse Events</h1><p>Mouse events are one of the two most frequent kinds of events handled by an application (the other kind being, of course, key events). Mouse clicks—which involve a user pressing and then releasing a mouse button—generally indicate selection, but what the selection means is left up to the object responding to the event. For example, a mouse click could tell the responding object to alter its appearance and then send an action message. Mouse drags generally indicate that the receiving view should move itself or a drawn object within its bounds. The following sections describe how you might handle mouse-down, mouse-up, and mouse-drag events. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH6-SW14" title="Note"></a><p><strong>Note:</strong>&nbsp;This chapter discusses those mouse events that an <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object delivers to its views through the event-dispatch mechanism: mouse-down, mouse-up, mouse-dragged, and (to a lesser degree) mouse-moved events. It does not describe how to handle mouse-entered and mouse-exited events, which (possibly along with mouse-moved events) are used in mouse tracking. See <span class="content_text"><a href="../TrackingAreaObjects/TrackingAreaObjects.html#//apple_ref/doc/uid/10000060i-CH8-SW1">“Using Tracking-Area Objects”</a></span> for information on this subject.</p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6-SW15">Overview of Mouse Events</a>
				
			<br/>
			
        
			
			
				<a href="HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6-SW17">Handling Mouse Clicks</a>
				
			<br/>
			
        
			
			
				<a href="HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6-SW18">Handling Mouse Dragging Operations</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000060i-CH6-SW15" title="Overview of Mouse Events"></a><h2>Overview of Mouse Events</h2><p>Before going into the “how to” of mouse-event handling, let’s review some central facts about mouse events discussed in <span class="content_text"><a href="../EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW11">“Event Architecture,”</a></span> <span class="content_text"><a href="../EventObjectsTypes/EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW4">“Event Objects and Types,”</a></span> and <span class="content_text"><a href="../EventHandlingBasics/EventHandlingBasics.html#//apple_ref/doc/uid/10000060i-CH5-SW11">“Event Handling Basics”</a></span>:</p><ul class="ul"><li class="li"><p>Mouse events are dispatched by an <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object to the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> object over which the event occurred.</p></li><li class="li"><p>Subsequent key events are dispatched to that view object if it accepts first responder status.</p></li><li class="li"><p>If the user clicks a view that isn’t in the key window, by default the window is brought forward and made key, but the mouse event is not dispatched. </p></li><li class="li"><p>Mouse events are of various event types related to the mouse button pressed (left, right, other) and the nature of the action on the mouse button. Each event type is, in turn, related to an <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> method, as <span class="content_text">Table 4-1</span> shows for left-button mouse events. </p><a name="//apple_ref/doc/uid/10000060i-CH6-SW8" title="Table 4-1Type constants and methods related to left-button mouse events"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4-1&nbsp;&nbsp;</strong>Type constants and methods related to left-button mouse events</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Action</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Event type (left mouse button)</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Mouse-event method invoked (left mouse button)</p></th></tr><tr><td  scope="row"><p>Press down the button</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseDown" target="_top">NSLeftMouseDown</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code></p></td></tr><tr><td  scope="row"><p>Move the mouse while pressing the button</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseDragged" target="_top">NSLeftMouseDragged</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDragged:" target="_top">mouseDragged:</a></code></p></td></tr><tr><td  scope="row"><p>Release the button</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseUp" target="_top">NSLeftMouseUp</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseUp:" target="_top">mouseUp:</a></code></p></td></tr><tr><td  scope="row"><p>Move the mouse without pressing any button</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSMouseMoved" target="_top">NSMouseMoved</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseMoved:" target="_top">mouseMoved:</a></code></p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH6-SW16" title="Note"></a><p><strong>Note:</strong>&nbsp;Because mouse-moved events occur so frequently that they can quickly flood the event-dispatch machinery, an <code>NSWindow</code> object by default does not receive them from the global <code>NSApplication</code> object. However, you can specifically request these events by sending the <code>NSWindow</code> object an <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/setAcceptsMouseMovedEvents:" target="_top">setAcceptsMouseMovedEvents:</a></code> message with an argument of <code>YES</code>.</p></div><p>Right-mouse events are defined by the Application Kit to open contextual menus, but you can override this behavior if necessary (in, for example, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/rightMouseDown:" target="_top">rightMouseDown:</a></code>). The Application Kit does not define any default behavior for third (“other”) mouse buttons.</p></li><li class="li"><p>The general sequence of mouse events is: mouse-down, mouse-dragged (multiple), mouse-up.</p><p>If dispatch of them is turned on, mouse-moved events may only occur between a mouse-up and the next mouse-down. They do not occur between a mouse-down and the subsequent mouse-up.</p></li><li class="li"><p>Mouse events (as <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> objects) can have subtypes. Currently, these subtypes are restricted to tablet events (particularly tablet-pointer events) but more subtypes could be added in the future. (See <span class="content_text"><a href="../EventObjectsTypes/EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW3">“Tablet Events”</a></span> for more information.)</p></li></ul><p></p><a name="//apple_ref/doc/uid/10000060i-CH6-SW17" title="Handling Mouse Clicks"></a><h2>Handling Mouse Clicks</h2><p>One of the earliest things to consider in handling mouse-down events is whether the receiving <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> object should become the first responder, which means that it will be the first candidate for subsequent key events and action messages. Views that handle graphic elements that the user can select—drawing shapes or text, for example—should typically accept first responder status on a mouse-down event by overriding the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code> method to return <code>YES</code>, as discussed in <span class="content_text"><a href="../EventHandlingBasics/EventHandlingBasics.html#//apple_ref/doc/uid/10000060i-CH5-SW14">“Preparing a Custom View for Receiving Events.”</a></span> </p><p>By default, a mouse-down event in a window that isn’t the key window simply brings the window forward and makes it key; the event isn’t sent to the <code>NSView</code> object over which the mouse click occurs. The <code>NSView</code> can claim an initial mouse-down event, however, by overriding <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/acceptsFirstMouse:" target="_top">acceptsFirstMouse:</a></code> to return <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/YES" target="_top">YES</a></code>. The argument of this method is the mouse-down event that occurred in the non-key window, which the view object can examine to determine whether it wants to receive the mouse event and potentially become first responder. You want the default behavior of this method in, for example, a control that affects the selected object in a window. However, in certain cases it’s appropriate to override this behavior, such as for controls that should receive <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code> messages even when the window is inactive. Examples of controls that support this click-through behavior are the title-bar buttons of a window. </p><p>In your implementation of an <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> mouse-event method, often the first thing you might do is examine the passed-in <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> object to decide <em>if</em> this is an event you want to handle. If it is an event that you handle, then you may need to extract information from the <code>NSEvent</code> object to help you handle it. Specifically, you can get the following information from the <code>NSEvent</code> object:</p><ul class="ul"><li class="li"><p>Get the location of the mouse event in base coordinates (<code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/locationInWindow" target="_top">locationInWindow</a></code>) and then convert this location to the receiving view’s coordinate system; see <span class="content_text"><a href="../EventHandlingBasics/EventHandlingBasics.html#//apple_ref/doc/uid/10000060i-CH5-SW15">“Getting the Location of an Event”</a></span> for details.</p></li><li class="li"><p>See if any modifier keys were pressed when the mouse button was clicked (<code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/modifierFlags" target="_top">modifierFlags</a></code>); this procedure is described in <span class="content_text"><a href="../EventHandlingBasics/EventHandlingBasics.html#//apple_ref/doc/uid/10000060i-CH5-SW16">“Testing for Event Type and Modifier Flags.”</a></span> An application may define modifier keys to change the significance of a mouse event.</p></li><li class="li"><p>Find out how many mouse clicks occurred in quick succession (<code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/clickCount" target="_top">clickCount</a></code>); multiple mouse clicks are conceptually treated as a single mouse-down event within a narrow time threshold (although they arrive in a series of <code>mouseDown:</code> messages). As with modifier keys, a double- or triple-click can change the significance of a mouse event for an application. (See <span class="content_text"><a href="HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6-SW2">Listing 4-3</a></span> for an example.)</p></li><li class="li"><p>If the interval between mouse clicks is important, you can send <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/timestamp" target="_top">timestamp</a></code> to the <code>NSEvent</code> object and record the moment each event occurred.</p></li><li class="li"><p>If the change in position of the mouse between subsequent events is important, you can find out the delta values for the x-coordinate and y-coordinate using, respectively,  <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/deltaX" target="_top">deltaX</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/deltaY" target="_top">deltaY</a></code>.</p></li></ul><p>Many view objects in the Application Kit (such as controls and menu items) change their appearance in response to mouse-down events, sometimes only until the subsequent mouse-up event. Doing this provides visual confirmation to the user that their action is effective or that the clicked object is now selected.  <span class="content_text">Listing 4-1</span> shows a simple example of this.</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW10" title="Listing 4-1Simple handling of mouse click&acirc;&#128;&#148;changing view&acirc;&#128;&#153;s appearance"></a><p class="codesample"><strong>Listing 4-1&nbsp;&nbsp;</strong>Simple handling of mouse click—changing view’s appearance</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setFrameColor:[NSColor redColor]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplay:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseUp:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setFrameColor:[NSColor greenColor]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplay:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)drawRect:(NSRect)rect {<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self frameColor] set];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRectFill(rect);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>But many view objects, particularly controls and cells, do more than simply change their appearance in response to mouse clicks. One common paradigm is for the clicked view to send an action message to a target object (where both action and target are settable properties of the view). As shown in <span class="content_text">Listing 4-2</span>, the view typically sends the message on <code>mouseUp:</code> rather than <code>mouseDown:</code>, thus giving users an opportunity to change their minds mid-click. </p><a name="//apple_ref/doc/uid/10000060i-CH6-SW5" title="Listing 4-2Simple handling of mouse click&acirc;&#128;&#148;sending an action message"></a><p class="codesample"><strong>Listing 4-2&nbsp;&nbsp;</strong>Simple handling of mouse click—sending an action message</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setFrameColor:[NSColor redColor]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplay:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseUp:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setFrameColor:[NSColor greenColor]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplay:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSApp sendAction:[self action] to:[self target] from:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (SEL)action {return action; }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setAction:(SEL)newAction {<span></span></pre></td></tr><tr><td scope="row"><pre>    action = newAction;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)target { return target; }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setTarget:(id)newTarget {<span></span></pre></td></tr><tr><td scope="row"><pre>    target = newTarget;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 4-3</span> gives a more complex, real-world example. (It’s from the example project for the Sketch application.) This implementation of <code>mouseDown:</code> determines if users double-clicked a graphical object and, if they did, enables the editing of that object. Otherwise, if a palette object is selected, it creates an instance of that object at the location of the mouse click. </p><a name="//apple_ref/doc/uid/10000060i-CH6-SW2" title="Listing 4-3Handling a mouse-down event&acirc;&#128;&#148;Sketch application"></a><p class="codesample"><strong>Listing 4-3&nbsp;&nbsp;</strong>Handling a mouse-down event—Sketch application</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    Class theClass = [[SKTToolPaletteController sharedToolPaletteController] currentGraphicClass];<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([self editingGraphic]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self endEditing];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([theEvent clickCount] > 1) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSPoint curPoint = [self convertPoint:[theEvent locationInWindow] fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        SKTGraphic *graphic = [self graphicUnderPoint:curPoint];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (graphic &amp;&amp; [graphic isEditable]) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self startEditingGraphic:graphic withEvent:theEvent];<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theClass) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self clearSelection];<span></span></pre></td></tr><tr><td scope="row"><pre>        [self createGraphicOfClass:theClass withEvent:theEvent];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self selectAndTrackMouseWithEvent:theEvent];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The classes of the Application Kit that implement controls manage this target-action behavior for you.</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW18" title="Handling Mouse Dragging Operations"></a><h2>Handling Mouse Dragging Operations</h2><p>Mouse-down and mouse-up events, which are the events associated with mouse clicks, are not the only types of mouse events dispatched in an application. Views can also receive mouse-dragged events when a user moves a mouse while pressing down a mouse button. A view typically interprets mouse-dragged events as commands to move itself by altering its frame location or to move a region within its bounds by redrawing it. However, other interpretations of mouse-dragged events are possible; for example, a view could respond to mouse-dragged events by magnifying the region that the mouse pointer is dragged over.</p><p>With the Application Kit you can take one of two general approaches when handling mouse-dragged events. The first approach is overriding the three <code>NSResponder</code> methods <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDragged:" target="_top">mouseDragged:</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseUp:" target="_top">mouseUp:</a></code> (for left mouse-button operations). For each dragging sequence, the Application Kit sends a <code>mouseDown:</code> message to a responder object, then sends one or more <code>mouseDragged:</code> messages, and ends the sequence with a <code>mouseUp:</code> message. <span class="content_text"><a href="HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6-SW3">“The Three-Method Approach”</a></span> describes this approach.</p><p>The other approach treats the mouse events in a dragging sequence as a single event, from mouse down, through dragging, to mouse up. To do this, the responder object must usually short-circuit the application’s normal event loop by entering a event-tracking loop to filter and process only mouse events of interest. For example, an <code><a href="../../../Reference/ApplicationKit/Classes/NSButton_Class/Reference/Reference.html#//apple_ref/occ/cl/NSButton" target="_top">NSButton</a></code> object highlights itself upon a mouse-down event, then follows the mouse location during dragging, highlighting when the mouse is inside and unhighlighting when the mouse is outside. If the mouse is inside on the mouse-up event, the button object sends its action message. This approach is described in <span class="content_text"><a href="HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6-SW4">“The Mouse-Tracking Loop Approach.”</a></span> </p><p>Both of these approaches have their advantages and drawbacks. Establishing a event-tracking loop gives you greater control over the way other events interact with your application during a dragging operation. However, the application’s main thread is unable to process any other requests during an event-tracking loop and timers might not fire as expected. The mouse-tracking approach is more efficient because it typically requires less code and allows all dragging variables to be local. However, the class implementing it becomes more difficult to extend without the subclass reimplementing all the dragging code. </p><p>Implementing the individual <code>mouseDown:</code>, <code>mouseDragged:</code>, and <code>mouseUp:</code> methods is often a better design choice when writing an event-driven application. Each of the methods have a clearly defined scope, which often leads to clearer code. This approach also makes it much easier for subclasses to override behavior for handling mouse-down, mouse-dragged, and mouse-up events. However, this technique can require more code and instance variables.</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW3" title="The Three-Method Approach"></a><h3>The Three-Method Approach</h3><p>To handle a mouse-dragging operation, you can override the three <code>NSResponder</code> methods that mark the discrete stages of a mouse-dragging operation: <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDragged:" target="_top">mouseDragged:</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseUp:" target="_top">mouseUp:</a></code> (or, for right-mouse dragging, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/rightMouseDown:" target="_top">rightMouseDown:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/rightMouseDragged:" target="_top">rightMouseDragged:</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/rightMouseUp:" target="_top">rightMouseUp:</a></code>). A mouse-dragging sequence consists of one <code>mouseDown:</code> message, followed by (typically) multiple <code>mouseDragged:</code> messages, and a concluding <code>mouseUp:</code> message. </p><p>The subclass implementing these methods often has to declare instance variables to hold the changing values or states of various things between successive events. These things could be geometric entities such as rectangles or points (corresponding to view frames or regions within views) or they could be simple Boolean values indicating, for example, that an object is selected.  In the <code>mouseDown:</code> method, the view generally initializes any dragging-related instance variables; in the <code>mouseDragged:</code> method it might update those instance variables or check them prior to performing an action; and in the <code>mouseUp:</code> method, it often resets those instance variables to their initial values.</p><p>Because mouse-dragging operations often redraw an object in the incrementally changing locations where users drag that object, implementations of the three mouse-dragging methods usually need to find the location of each mouse event in the view’s coordinate system. As explained in <span class="content_text"><a href="../EventHandlingBasics/EventHandlingBasics.html#//apple_ref/doc/uid/10000060i-CH5-SW15">“Getting the Location of an Event,”</a></span> this requires the view to send <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/locationInWindow" target="_top">locationInWindow</a></code> to the passed-in <code>NSEvent</code> object and then use the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertPoint:fromView:" target="_top">convertPoint:fromView:</a></code> method to convert the resulting location to the local coordinate system. When changes in location or geometry require the view to redraw itself or a portion of itself, the view marks the areas needing display using the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNeedsDisplay:" target="_top">setNeedsDisplay:</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNeedsDisplayInRect:" target="_top">setNeedsDisplayInRect:</a></code> method and the view is later asked to redraw itself (in <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/drawRect:" target="_top">drawRect:</a></code>) through the auto-display mechanism (assuming that mechanism is not turned off). </p><p><span class="content_text">Listing 4-4</span> illustrates the use of dragging-related instance variables, getting the mouse location in local coordinates (and testing whether that location is in a specific region), and marking that region of the receiving view for redisplay.</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW6" title="Listing 4-4Handling a mouse-dragging operation&acirc;&#128;&#148;three-method approach"></a><p class="codesample"><strong>Listing 4-4&nbsp;&nbsp;</strong>Handling a mouse-dragging operation—three-method approach</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    // mouseInCloseBox and trackingCloseBoxHit are instance variables<span></span></pre></td></tr><tr><td scope="row"><pre>    if (mouseInCloseBox = NSPointInRect([self convertPoint:[theEvent locationInWindow] fromView:nil], closeBox)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        trackingCloseBoxHit = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setNeedsDisplayInRect:closeBox];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else if ([theEvent clickCount] > 1) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [[self window] miniaturize:self];<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseDragged:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint windowOrigin;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSWindow *window = [self window];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (trackingCloseBoxHit) {<span></span></pre></td></tr><tr><td scope="row"><pre>        mouseInCloseBox = NSPointInRect([self convertPoint:[theEvent locationInWindow] fromView:nil], closeBox);<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setNeedsDisplayInRect:closeBox];<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    windowOrigin = [window frame].origin;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [window setFrameOrigin:NSMakePoint(windowOrigin.x + [theEvent deltaX], windowOrigin.y - [theEvent deltaY])];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseUp:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (NSPointInRect([self convertPoint:[theEvent locationInWindow] fromView:nil], closeBox)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self tryToCloseWindow];<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    trackingCloseBoxHit = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplayInRect:closeBox];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000060i-CH6-SW4" title="The Mouse-Tracking Loop Approach"></a><h3>The Mouse-Tracking Loop Approach</h3><p>The mouse-tracking technique for handling mouse-dragging operations is applied in a single method, usually (but not not necessarily) in <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code>. The implementing responder object first declares and possibly initializes one or more local variables to use within the loop. Often one of these variables holds a value, often Boolean, that is used to control the loop.  When some condition is met, typically the receipt of a mouse-up event, the variable value is changed; when this variable is tested next time through the loop, control exits the loop.</p><p>The central method of a mouse-tracking loop is the <code>NSApplication</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code> and the <code>NSWindow</code> method of the same name. These methods fetch events from the event queue that are of the types specified by one or more type-mask constants; for mouse-dragging, these constants are typically <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseDraggedMask" target="_top">NSLeftMouseDraggedMask</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseUpMask" target="_top">NSLeftMouseUpMask</a></code>. Events of other types are left in the queue. (The run-loop mode parameter of both <code>nextEventMatchingMask:untilDate:inMode:dequeue:</code> methods should be <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSEventTrackingRunLoopMode" target="_top">NSEventTrackingRunLoopMode</a></code>.)</p><p>After receiving a mouse-down event, fetch subsequent mouse events within the loop using <code>nextEventMatchingMask:untilDate:inMode:dequeue:</code>. Process <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseDragged" target="_top">NSLeftMouseDragged</a></code> events as you would process them in the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDragged:" target="_top">mouseDragged:</a></code> method (described in <span class="content_text"><a href="HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6-SW3">“The Three-Method Approach”</a></span>); similarly, handle <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSLeftMouseUp" target="_top">NSLeftMouseUp</a></code> events as you would handle them in <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseUp:" target="_top">mouseUp:</a></code>. Usually mouse-up events indicate that execution control should break out of the loop.</p><p>The <code>mouseDown:</code> method template in <span class="content_text">Listing 4-5</span> shows one possible kind of modal event loop.</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW7" title="Listing 4-5Handling mouse-dragging in a mouse-tracking loop&acirc;&#128;&#148;simple example"></a><p class="codesample"><strong>Listing 4-5&nbsp;&nbsp;</strong>Handling mouse-dragging in a mouse-tracking loop—simple example</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL keepOn = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL isInside = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint mouseLoc;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (keepOn) {<span></span></pre></td></tr><tr><td scope="row"><pre>        theEvent = [[self window] nextEventMatchingMask: NSLeftMouseUpMask |<span></span></pre></td></tr><tr><td scope="row"><pre>                NSLeftMouseDraggedMask];<span></span></pre></td></tr><tr><td scope="row"><pre>        mouseLoc = [self convertPoint:[theEvent locationInWindow] fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        isInside = [self mouse:mouseLoc inRect:[self bounds]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        switch ([theEvent type]) {<span></span></pre></td></tr><tr><td scope="row"><pre>            case NSLeftMouseDragged:<span></span></pre></td></tr><tr><td scope="row"><pre>                    [self highlight:isInside];<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case NSLeftMouseUp:<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (isInside) [self doSomethingSignificant];<span></span></pre></td></tr><tr><td scope="row"><pre>                    [self highlight:NO];<span></span></pre></td></tr><tr><td scope="row"><pre>                    keepOn = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            default:<span></span></pre></td></tr><tr><td scope="row"><pre>                    /* Ignore any other kind of event. */<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This loop converts the mouse location and checks whether it’s inside the receiver. It highlights itself using the fictional <code>highlight:</code> method and, on receiving a mouse-up event, it invokes <code>doSomethingSignificant</code> to perform an important action. Instead of merely highlighting, a custom <code>NSView</code> object might move a selected object, draw a graphic image according to the mouse’s location, and so on.</p><p><span class="content_text">Listing 4-6</span> is a slightly more complicated example that includes the use of an autorelease pool and testing for a modifier key.</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW9" title="Listing 4-6Handling mouse-dragging in a mouse-tracking loop&acirc;&#128;&#148;complex example"></a><p class="codesample"><strong>Listing 4-6&nbsp;&nbsp;</strong>Handling mouse-dragging in a mouse-tracking loop—complex example</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([theEvent modifierFlags] &amp; NSAlternateKeyMask)  {<span></span></pre></td></tr><tr><td scope="row"><pre>        BOOL                dragActive = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>        NSPoint             location = [renderView convertPoint:[theEvent locationInWindow] fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSAutoreleasePool   *myPool = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        NSEvent*            event = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>        NSWindow            *targetWindow = [renderView window];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        myPool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>        while (dragActive) {<span></span></pre></td></tr><tr><td scope="row"><pre>            event = [targetWindow nextEventMatchingMask:(NSLeftMouseDraggedMask | NSLeftMouseUpMask)<span></span></pre></td></tr><tr><td scope="row"><pre>                                untilDate:[NSDate distantFuture]<span></span></pre></td></tr><tr><td scope="row"><pre>                                inMode:NSEventTrackingRunLoopMode<span></span></pre></td></tr><tr><td scope="row"><pre>                                dequeue:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>            if(!event)<span></span></pre></td></tr><tr><td scope="row"><pre>                continue;<span></span></pre></td></tr><tr><td scope="row"><pre>            location = [renderView convertPoint:[event locationInWindow] fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ([event type]) {<span></span></pre></td></tr><tr><td scope="row"><pre>                case NSLeftMouseDragged:<span></span></pre></td></tr><tr><td scope="row"><pre>                    annotationPeel = (location.x * 2.0 / [renderView bounds].size.width);<span></span></pre></td></tr><tr><td scope="row"><pre>                    [imageLayer showLens:(annotationPeel &lt;= 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>                    [peelOffFilter setValue:[NSNumber numberWithFloat:annotationPeel] forKey:@"inputTime"];<span></span></pre></td></tr><tr><td scope="row"><pre>                    [self refresh];<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case NSLeftMouseUp:<span></span></pre></td></tr><tr><td scope="row"><pre>                    dragActive = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                default:<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        [myPool release];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        // other tasks handled here......<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>A mouse-tracking loop is driven only as long as the user actually moves the mouse. It won’t work, for example, to cause continual scrolling if the user presses the mouse button but never moves the mouse itself. For this, your loop should start a periodic event stream using the <code>NSEvent</code> class method <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/clm/NSEvent/startPeriodicEventsAfterDelay:withPeriod:" target="_top">startPeriodicEventsAfterDelay:withPeriod:</a></code>, and add <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSPeriodicMask" target="_top">NSPeriodicMask</a></code> to the mask bit-field passed to <code>nextEventMatchingMask:</code>. In the <code>switch</code> statement the implementing view object can then check for events of type <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSPeriodic" target="_top">NSPeriodic</a></code> and take whatever action it needs to—scrolling a document view or moving a step in an animation, for example. If you need to check the mouse location during a periodic event, you can use the <code>NSWindow</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/mouseLocationOutsideOfEventStream" target="_top">mouseLocationOutsideOfEventStream</a></code>.</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW19" title="Filtering Out Key Events During Mouse-Tracking Operations"></a><h3>Filtering Out Key Events During Mouse-Tracking Operations</h3><p>A potential problem with mouse-tracking code is the user pressing a key combination that is a command, such as Command-z (undo), while a tracking operation is underway. Because your mouse-tracking code (either in the three-method approach or a mouse-tracking loop) isn’t looking for that key event, the code might not know how to handle that key command or could handle it wrongly, with unwelcome consequences. </p><p>The problem here with a mouse-tracking loop might not be readily apparent because, after all, the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code> loop ensures only mouse-tracking events are delivered. Why would key events be a problem? Consider the code in <span class="content_text">Listing 4-7</span>. While this mouse-tracking loop is active, let’s say the user issues some key-equivalent commands.</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW11" title="Listing 4-7Typical mouse-tracking loop"></a><p class="codesample"><strong>Listing 4-7&nbsp;&nbsp;</strong>Typical mouse-tracking loop</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>  NSPoint pos;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>  while ((theEvent = [[self window] nextEventMatchingMask:<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLeftMouseUpMask | NSLeftMouseDraggedMask])) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint pos = [self convertPoint:[theEvent locationInWindow]<span></span></pre></td></tr><tr><td scope="row"><pre>                            fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ([theEvent type] == NSLeftMouseUp)<span></span></pre></td></tr><tr><td scope="row"><pre>      break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Do some other processing...<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>What happens after the mouse-tracking loop concludes? After the user lets go of the mouse button, the application handles all of the pending commands corresponding to the mnemonics the user pressed during the loop. The effects of this delayed handling are are probably undesirable. You can guard against this by filtering the event stream for key events and then explicitly ignoring them. <span class="content_text">Listing 4-8</span> shows how you can modify the code above to accomplish this (new code in italics).</p><a name="//apple_ref/doc/uid/10000060i-CH6-SW12" title="Listing 4-8Typical mouse-tracking loop&acirc;&#128;&#148;with key events negated"></a><p class="codesample"><strong>Listing 4-8&nbsp;&nbsp;</strong>Typical mouse-tracking loop—with key events negated</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>  NSPoint pos;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>  while ((theEvent = [[self window] nextEventMatchingMask:<span></span></pre></td></tr><tr><td scope="row"><pre>      NSLeftMouseUpMask | NSLeftMouseDraggedMask | <em>NSKeyDownMask</em>])) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint pos = [self convertPoint:[theEvent locationInWindow]<span></span></pre></td></tr><tr><td scope="row"><pre>                            fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ([theEvent type] == NSLeftMouseUp)<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>    <em>     else if ([theEvent type] == NSKeyDown) {</em><span></span></pre></td></tr><tr><td scope="row"><pre>        <em>        NSBeep();</em><span></span></pre></td></tr><tr><td scope="row"><pre>        <em>        continue;</em><span></span></pre></td></tr><tr><td scope="row"><pre>    <em>}</em><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Do some other processing...<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For dragging operations handled with the three-method approach, the situation with simultaneous mouse and key events is a bit different. In this case, the AppKit processes keyboard events as it normally does during tracking. If the user presses a command mnemonic, even while a tracking operation is going on, the application object dispatches the corresponding messages to its targets. So if, for example, in a drawing application the user drags a blue circle they just created and then (perhaps accidentally) presses Command-x (cut) while the mouse button is still down, the code handling the cut operation is going to run, deleting the object the user was dragging.</p><p>The solution to this problem involves a few steps:</p><ul class="spaceabove"><li class="li"><p>Declare a Boolean instance variable that reflects when a dragging operation is underway.</p></li><li class="li"><p>Set this variable to <code>YES</code> in <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code> and reset it to <code>NO</code> in <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseUp:" target="_top">mouseUp:</a></code>.</p></li><li class="li"><p>Override <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/performKeyEquivalent:" target="_top">performKeyEquivalent:</a></code> to check the value of the instance variable and, if a dragging operation is occurring, to discard the key event.</p></li></ul><p><span class="content_text">Listing 4-9</span> shows the implementation code for this (<code>isBeingManipulated</code> is the Boolean instance variable). </p><a name="//apple_ref/doc/uid/10000060i-CH6-SW13" title="Listing 4-9Discarding key events during a dragging operation with the three-method approach"></a><p class="codesample"><strong>Listing 4-9&nbsp;&nbsp;</strong>Discarding key events during a dragging operation with the three-method approach</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation MyView<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)performKeyEquivalent:(NSEvent *)anEvent<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  if (isBeingManipulated) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([anEvent type] == NSKeyDown) // Can get NSKeyUp here too<span></span></pre></td></tr><tr><td scope="row"><pre>      NSBeep ();<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES; // Claim we handled it<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>  return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)anEvent<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  isBeingManipulated = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>  // other code goes  here...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseUp:(NSEvent *)anEvent<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  isBeingManipulated = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>  // other code goes here ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>This solution to the problem is simplified and is intended for general illustration. In a real application you might want to check the event type, conditionally set the <code>isBeingManipulated</code> variable, and selectively handle key equivalents.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../EventHandlingBasics/EventHandlingBasics.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HandlingKeyEvents/HandlingKeyEvents.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/EventOverview/HandlingMouseEvents/HandlingMouseEvents.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/EventOverview/HandlingMouseEvents/HandlingMouseEvents.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/EventOverview/HandlingMouseEvents/HandlingMouseEvents.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>