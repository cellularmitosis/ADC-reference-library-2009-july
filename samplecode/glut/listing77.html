<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /GLUTPreferencesController.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GLUTPreferencesController.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#import &quot;macx_glut.h&quot;
#import &quot;GLUTPreferencesController.h&quot;

// preferences dictionary keys
NSString *GLUTUseMacOSXCoordsKey = @&quot;GLUTUseMacOSXCoordsKey&quot;;
NSString *GLUTUseCurrWDKey = @&quot;GLUTUseCurrWDKey&quot;;
NSString *GLUTUseExtendedDesktopKey = @&quot;GLUTUseExtendedDesktopKey&quot;;
NSString *GLUTIconicKey = @&quot;GLUTIconicKey&quot;;
NSString *GLUTDebugModeKey = @&quot;GLUTDebugModeKey&quot;;
NSString *GLUTInitWidthKey = @&quot;GLUTInitWidthKey&quot;;
NSString *GLUTInitHeightKey = @&quot;GLUTInitHeightKey&quot;;
NSString *GLUTInitXKey = @&quot;GLUTInitXKey&quot;;
NSString *GLUTInitYKey = @&quot;GLUTInitYKey&quot;;
NSString *GLUTIdleTimeIntervalKey = @&quot;GLUTIdleTimeIntervalKey&quot;;
NSString *GLUTGameModeFadeIntervalKey = @&quot;GLUTGameModeFadeIntervalKey&quot;;
NSString *GLUTGamemodeCaptureSingleKey = @&quot;GLUTGamemodeCaptureSingleKey&quot;;
NSString *GLUTSyncToVBLKey = @&quot;GLUTSyncToVBLKey&quot;;
NSString *GLUTEmulateMouseButtonsKey = @&quot;GLUTEmulateMouseButtonsKey&quot;;
NSString *GLUTMouseFirstModifiersKey = @&quot;GLUTMouseFirstModifiersKey&quot;;
NSString *GLUTMouseSecondModifiersKey = @&quot;GLUTMouseSecondModifiersKey&quot;;
NSString *GLUTDeviceActionKey = @&quot;GLUTDeviceActionKey&quot;;
NSString *GLUTDeviceVendorIDKey = @&quot;GLUTDeviceVendorIDKey&quot;;
NSString *GLUTDeviceProductIDKey = @&quot;GLUTDeviceProductIDKey&quot;;
NSString *GLUTDeviceLocIDKey = @&quot;GLUTDeviceLocIDKey&quot;;
NSString *GLUTDeviceUsageKey = @&quot;GLUTDeviceUsageKey&quot;;
NSString *GLUTDeviceUsagePageKey = @&quot;GLUTDeviceUsagePageKey&quot;;
NSString *GLUTDeviceUsageEKey = @&quot;GLUTDeviceUsageEKey&quot;;
NSString *GLUTDeviceUsagePageEKey = @&quot;GLUTDeviceUsagePageEKey&quot;;
NSString *GLUTDeviceCookieKey = @&quot;GLUTDeviceCookieKey&quot;;
NSString *GLUTDeviceMinReportKey = @&quot;GLUTDeviceMinReportKey&quot;;
NSString *GLUTDeviceMaxReportKey = @&quot;GLUTDeviceMaxReportKey&quot;;
NSString *GLUTDeviceInvertMulKey = @&quot;GLUTDeviceInvertMulKey&quot;;
NSString *GLUTJoystickDeviceKey = @&quot;GLUTJoystickDeviceKey&quot;;
NSString *GLUTSpaceballDeviceKey = @&quot;GLUTSpaceballDeviceKey&quot;;
NSString *GLUTPreferencesName = @&quot;com.apple.glut&quot;;

enum {
   kGLUTAlternateTag,
   kGLUTControlTag,
   kGLUTShiftTag,
   kGLUTCommandTag
};


NSDictionary *    defaults;
int hidDevicesMatchedFlag = 0;

// utility routine to load prefs at start
void __glutLoadPrefs (void)
{
     defaults = [[NSUserDefaults standardUserDefaults] persistentDomainForName: GLUTPreferencesName];
     
     [defaults retain];
    
    // set values and re-init (ensure to check to see if keyed object exists)
    if ([defaults objectForKey: GLUTUseMacOSXCoordsKey])
        __glutUseMacOSCoords = [[defaults objectForKey: GLUTUseMacOSXCoordsKey] boolValue];
    if ([defaults objectForKey: GLUTUseCurrWDKey])
        __glutUseInitWD = [[defaults objectForKey: GLUTUseCurrWDKey] boolValue];
    if ([defaults objectForKey: GLUTUseExtendedDesktopKey])
        __glutUseExtendedDesktop = [[defaults objectForKey: GLUTUseExtendedDesktopKey] boolValue];
    if ([defaults objectForKey: GLUTIconicKey])
        __glutIconic = [[defaults objectForKey: GLUTIconicKey] boolValue];
    if ([defaults objectForKey: GLUTDebugModeKey])
        __glutDebug = [[defaults objectForKey: GLUTDebugModeKey] boolValue];
    if ([defaults objectForKey: GLUTInitWidthKey])
        __glutInitWidth = [[defaults objectForKey: GLUTInitWidthKey] intValue];
    if ([defaults objectForKey: GLUTInitHeightKey])
        __glutInitHeight = [[defaults objectForKey: GLUTInitHeightKey] intValue];
    if ([defaults objectForKey: GLUTInitXKey])
        __glutInitX = [[defaults objectForKey: GLUTInitXKey] intValue];
    if ([defaults objectForKey: GLUTInitYKey])
        __glutInitY = [[defaults objectForKey: GLUTInitYKey] intValue];
    if ([defaults objectForKey: GLUTIdleTimeIntervalKey])
        __glutIdleTimeInterval = [[defaults objectForKey: GLUTIdleTimeIntervalKey] floatValue];
    if ([defaults objectForKey: GLUTGameModeFadeIntervalKey])
        __glutGameModeFadeInterval = [[defaults objectForKey: GLUTGameModeFadeIntervalKey] floatValue];
    if ([defaults objectForKey: GLUTGamemodeCaptureSingleKey])
        __glutCaptureAllDisplays = 1 - [[defaults objectForKey: GLUTGamemodeCaptureSingleKey] boolValue];
    if ([defaults objectForKey: GLUTSyncToVBLKey])
        __glutSyncToVBL = [[defaults objectForKey: GLUTSyncToVBLKey] boolValue];
    
    if ([defaults objectForKey: GLUTEmulateMouseButtonsKey])
        __glutEmulateMouseButtons = [[defaults objectForKey: GLUTEmulateMouseButtonsKey] boolValue];
    if ([defaults objectForKey: GLUTMouseFirstModifiersKey])
        __glutMouseFirstModifiers = [[defaults objectForKey: GLUTMouseFirstModifiersKey] intValue];
    if ([defaults objectForKey: GLUTMouseSecondModifiersKey])
        __glutMouseSecondModifiers = [[defaults objectForKey: GLUTMouseSecondModifiersKey] intValue];
}


// This function looks for the devices specified in the preferences file.  If it finds them, it uses them,
// otherwise those preferences are ignored, but not deleted.

void __glutMatchHIDPrefsToDevices (void)
{
    if (hidDevicesMatchedFlag == 1)
    {
        return;
    }
    
    hidDevicesMatchedFlag = 1;
    
    // read pref array
    // note: this modifies glut settings directly (we do not dup settings for cancel for joystick and spaceball yet.
    if ([defaults objectForKey: GLUTJoystickDeviceKey]) {
        id actionDict = nil;
        pRecDevice pFirstDevice = NULL;
        NSEnumerator * enumer = [[defaults objectForKey: GLUTJoystickDeviceKey] objectEnumerator];
        // while array entries
        while (nil != (actionDict = [enumer nextObject])) {
            pRecElement pElement = NULL;
            pRecDevice pDevice = NULL;
            int action = 0;
            recSaveHID configRec;
            
            if ([actionDict objectForKey: GLUTDeviceActionKey])
                configRec.actionCookie = [[actionDict objectForKey: GLUTDeviceActionKey] longValue];
            else 
                configRec.actionCookie = 0;
            if ([actionDict objectForKey: GLUTDeviceActionKey])
                configRec.vendorID = [[actionDict objectForKey: GLUTDeviceVendorIDKey] longValue];
            else 
                configRec.vendorID = 0;
            if ([actionDict objectForKey: GLUTDeviceProductIDKey])
                configRec.productID = [[actionDict objectForKey: GLUTDeviceProductIDKey] longValue];
            else 
                configRec.productID = 0;
            if ([actionDict objectForKey: GLUTDeviceLocIDKey])
                configRec.locID = [[actionDict objectForKey: GLUTDeviceLocIDKey] longValue];
            else 
                configRec.locID = 0;
            if ([actionDict objectForKey: GLUTDeviceUsageKey])
                configRec.usage = [[actionDict objectForKey: GLUTDeviceUsageKey] longValue];
            else 
                configRec.usage = 0;
            if ([actionDict objectForKey: GLUTDeviceUsagePageKey])
                configRec.usagePage = [[actionDict objectForKey: GLUTDeviceUsagePageKey] longValue];
            else 
                configRec.usagePage = 0;
            if ([actionDict objectForKey: GLUTDeviceUsageEKey])
                configRec.usageE = [[actionDict objectForKey: GLUTDeviceUsageEKey] longValue];
            else 
                configRec.usageE = 0;
            if ([actionDict objectForKey: GLUTDeviceUsagePageEKey])
                configRec.usagePageE = [[actionDict objectForKey: GLUTDeviceUsagePageEKey] longValue];
            else 
                configRec.usagePageE = 0;
            if ([actionDict objectForKey: GLUTDeviceMinReportKey])
                configRec.minReport = [[actionDict objectForKey: GLUTDeviceMinReportKey] longValue];
            else 
                configRec.minReport = 0;
            if ([actionDict objectForKey: GLUTDeviceMaxReportKey])
                configRec.maxReport = [[actionDict objectForKey: GLUTDeviceMaxReportKey] longValue];
            else 
                configRec.maxReport = 0;
            if ([actionDict objectForKey: GLUTDeviceCookieKey])
                configRec.cookie = (IOHIDElementCookie)[[actionDict objectForKey: GLUTDeviceCookieKey] unsignedLongValue];
            else 
                configRec.cookie = 0;

            // find device and element for configRec and find controlling action
            action = HIDGetElementConfig (&amp;configRec, &amp;pDevice, &amp;pElement);
            struct _GLUTinputActionRec * inputARec = __glutGetJoystickDeviceElement (action);
            if (NULL == pFirstDevice)
                pFirstDevice = pDevice;
            if (pDevice &amp;&amp; pElement &amp;&amp; (pFirstDevice == pDevice)) { // valid device and element  and we match the same device
                // fill information in
                inputARec-&gt;pDevice = pDevice;
                inputARec-&gt;pElement = pElement;
                if ([actionDict objectForKey: GLUTDeviceInvertMulKey])
                    inputARec-&gt;invertMul = [[actionDict objectForKey: GLUTDeviceInvertMulKey] longValue];
                else 
                    inputARec-&gt;invertMul = 1;
            } else { // device for action not found so blank current device
                inputARec-&gt;pDevice = NULL;
                inputARec-&gt;pElement = NULL;
                inputARec-&gt;invertMul = 1;
            }
        }
    }
    if ([defaults objectForKey: GLUTSpaceballDeviceKey]) {
        id actionDict = nil;
        pRecDevice pFirstDevice = NULL;
        NSEnumerator * enumer = [[defaults objectForKey: GLUTSpaceballDeviceKey] objectEnumerator];
        // while array entries
        while (nil != (actionDict = [enumer nextObject])) {
            pRecElement pElement = NULL;
            pRecDevice pDevice = NULL;
            int action = 0;
            recSaveHID configRec;
            
            if ([actionDict objectForKey: GLUTDeviceActionKey])
                configRec.actionCookie = [[actionDict objectForKey: GLUTDeviceActionKey] longValue];
            else 
                configRec.actionCookie = 0;
            if ([actionDict objectForKey: GLUTDeviceActionKey])
                configRec.vendorID = [[actionDict objectForKey: GLUTDeviceVendorIDKey] longValue];
            else 
                configRec.vendorID = 0;
            if ([actionDict objectForKey: GLUTDeviceProductIDKey])
                configRec.productID = [[actionDict objectForKey: GLUTDeviceProductIDKey] longValue];
            else 
                configRec.productID = 0;
            if ([actionDict objectForKey: GLUTDeviceLocIDKey])
                configRec.locID = [[actionDict objectForKey: GLUTDeviceLocIDKey] longValue];
            else 
                configRec.locID = 0;
            if ([actionDict objectForKey: GLUTDeviceUsageKey])
                configRec.usage = [[actionDict objectForKey: GLUTDeviceUsageKey] longValue];
            else 
                configRec.usage = 0;
            if ([actionDict objectForKey: GLUTDeviceUsagePageKey])
                configRec.usagePage = [[actionDict objectForKey: GLUTDeviceUsagePageKey] longValue];
            else 
                configRec.usagePage = 0;
            if ([actionDict objectForKey: GLUTDeviceUsageEKey])
                configRec.usageE = [[actionDict objectForKey: GLUTDeviceUsageEKey] longValue];
            else 
                configRec.usageE = 0;
            if ([actionDict objectForKey: GLUTDeviceUsagePageEKey])
                configRec.usagePageE = [[actionDict objectForKey: GLUTDeviceUsagePageEKey] longValue];
            else 
                configRec.usagePageE = 0;
            if ([actionDict objectForKey: GLUTDeviceMinReportKey])
                configRec.minReport = [[actionDict objectForKey: GLUTDeviceMinReportKey] longValue];
            else 
                configRec.minReport = 0;
            if ([actionDict objectForKey: GLUTDeviceMaxReportKey])
                configRec.maxReport = [[actionDict objectForKey: GLUTDeviceMaxReportKey] longValue];
            else 
                configRec.maxReport = 0;
            if ([actionDict objectForKey: GLUTDeviceCookieKey])
                configRec.cookie = (IOHIDElementCookie)[[actionDict objectForKey: GLUTDeviceCookieKey] unsignedLongValue];
            else 
                configRec.cookie = 0;

            // find device and element for configRec and find controling action
            action = HIDGetElementConfig (&amp;configRec, &amp;pDevice, &amp;pElement);
            struct _GLUTinputActionRec * inputARec = __glutGetSpaceballDeviceElement (action); // get pointer to record
            if (NULL == pFirstDevice)
                pFirstDevice = pDevice;
            if (pDevice &amp;&amp; pElement &amp;&amp; (pFirstDevice == pDevice)) { // valid device and element  and we match the same device
                // fill information in
                inputARec-&gt;pDevice = pDevice;
                inputARec-&gt;pElement = pElement;
                if ([actionDict objectForKey: GLUTDeviceInvertMulKey])
                    inputARec-&gt;invertMul = [[actionDict objectForKey: GLUTDeviceInvertMulKey] longValue];
                else 
                    inputARec-&gt;invertMul = 1;
            } else { // device for action not found so blank current device
                inputARec-&gt;pDevice = NULL;
                inputARec-&gt;pElement = NULL;
                inputARec-&gt;invertMul = 1;
            }
        }
    }
    
    // we have done our matching, and no longer need the prefs dictionary
    [defaults release];
    
    // do not save prefs here so if a device is missing and on a later run returned their saved prefs are not hosed...
}

@interface GLUTPreferencesController(GLUTPrivate)
- (void)updateLaunchUI:(NSDictionary *)defaults;
- (void)updateDevicesUI:(NSDictionary *)defaults;
- (void)updateUI:(NSDictionary *)defaults;
        
- (void)updateObjectState;
- (void)updateLaunchState;
- (void)updateMouseState;
- (int) modifierToIndex:(unsigned int)modifier; // converts a key modifier to the index of the menu item
- (unsigned int) indexToModifier:(int)index; // does the opposite

- (void)updateDevicesThread:(id)object;
- (void)waitForDevicesThread;
@end


/////////////////////////////////////////////
#pragma mark -


@implementation GLUTPreferencesController

- (id)init
{
    if((self = [self initWithWindowNibName: @&quot;GLUTPreferences&quot;]) != nil) {
        [self setWindowFrameAutosaveName: @&quot;&quot;];
        [self setShouldCascadeWindows: NO];
        updatingDevices = NO;
        return self;
    }
    return nil;
}

- (void)dealloc
{
   [self waitForDevicesThread];
   [mouseAssignWarningIcon release];
   [joyAssignWarningIcon release];
   [spaceAssignWarningIcon release];
   [super dealloc];
}

- (void)finalize
{
   [self waitForDevicesThread];
   [super finalize];
}

- (void)windowDidLoad
{
    NSImage *    cautionIcon;
    NSString *    path;

    [[self window] center];
    [super windowDidLoad];

    // fix for default button
    NSEnumerator * enumer = [[[[self window] contentView] subviews] objectEnumerator];
    id object = nil;
    while (nil != (object = [enumer nextObject]))
        if (([object isKindOfClass:[NSButton class]]) &amp;&amp;
            ([[object title] isEqual:@&quot;Set Defaults&quot;])) {
            [object setAction: @selector(setDefault:)];
            [object setTarget: self];
        }

    // launch
    [launchUseMacOSXCoords setState: __glutUseMacOSCoords];
    [launchUseCurrWD setState: __glutUseInitWD];
    [launchUseExtendedDesktop setState: __glutUseExtendedDesktop];
    [launchIconic setState: __glutIconic];
    [launchDebugMode setState: __glutDebug];
    [launchInitWidth setIntValue: __glutInitWidth];
    [launchInitHeight setIntValue: __glutInitHeight];
    [launchInitX setIntValue: __glutInitX];
    [launchInitY setIntValue: __glutInitY];
    [launchMenuIdle setFloatValue: __glutIdleTimeInterval];
    [launchFadeTime setFloatValue: __glutGameModeFadeInterval];
    [launchGamemodeCaptureSingle setState: (1 - __glutCaptureAllDisplays)];
    [launchSyncToVBL setState: __glutSyncToVBL];
    
    /* Mouse */
    [mouseDetected setStringValue:[NSString stringWithFormat:@&quot;%d %@&quot;, __glutGetNumberOfMouseButtons(),
                                   NSLocalizedStringFromTableInBundle(@&quot; button mouse detected.&quot;, @&quot;GLUTUI&quot;, __glutGetFrameworkBundle(), @&quot; button mouse detected.&quot;)]];
    [mouseAssignWarningText setStringValue: @&quot;&quot;];
    [mouseEmulation setState: __glutEmulateMouseButtons];
    [mouseRightConfigMenu selectItemAtIndex:[self modifierToIndex:__glutMouseFirstModifiers]];
    [mouseMiddleConfigMenu selectItemAtIndex:[self modifierToIndex:__glutMouseSecondModifiers]];
    
    
    /* Joystick */
    // joyInputMenu will be left as it is in the nib
    struct _GLUTinputActionRec * inputARec = __glutGetJoystickDeviceElement ([joyInputMenu indexOfSelectedItem]);
    [joyInverted setState:inputARec-&gt;invertMul];
    if (inputARec-&gt;pElement &amp;&amp; inputARec-&gt;pElement-&gt;name)
        [joyElement setStringValue:[NSString stringWithFormat:@&quot;%s&quot;, inputARec-&gt;pElement-&gt;name]];
    else
        [joyElement setStringValue:NSLocalizedStringFromTableInBundle(@&quot;Not assigned.&quot;, @&quot;GLUTUI&quot;, __glutGetFrameworkBundle(), @&quot;Not assigned.&quot;)];
    [joyAssignNote setStringValue: @&quot;&quot;];
    
    /* Spaceball */
    // spaceInputMenu will be left as it is in the nib
    inputARec = __glutGetSpaceballDeviceElement ([joyInputMenu indexOfSelectedItem]);
    [spaceInverted setState:inputARec-&gt;invertMul];
    if (inputARec-&gt;pElement &amp;&amp; inputARec-&gt;pElement-&gt;name)
        [spaceElement setStringValue:[NSString stringWithFormat:@&quot;%s&quot;, inputARec-&gt;pElement-&gt;name]];
    else
        [spaceElement setStringValue:NSLocalizedStringFromTableInBundle(@&quot;Not assigned.&quot;, @&quot;GLUTUI&quot;, __glutGetFrameworkBundle(), @&quot;Not assigned.&quot;)];
    [spaceAssignNote setStringValue: @&quot;&quot;];
    
    mouseTabItemView = [mouseAssignWarningIcon superview];
    joyTabItemView = [joyAssignWarningIcon superview];
    spaceTabItemView = [spaceAssignWarningIcon superview];
    path = [__glutGetFrameworkBundle() pathForImageResource: @&quot;Caution.tiff&quot;];
    cautionIcon = [[[NSImage alloc] initWithContentsOfFile: path] autorelease];
    [mouseAssignWarningIcon setImage: cautionIcon];
    [mouseAssignWarningIcon retain];
    [mouseAssignWarningIcon removeFromSuperview];
    [joyAssignWarningIcon setImage: cautionIcon];
    [joyAssignWarningIcon retain];
    [joyAssignWarningIcon removeFromSuperview];
    [spaceAssignWarningIcon setImage: cautionIcon];
    [spaceAssignWarningIcon retain];
    [spaceAssignWarningIcon removeFromSuperview];
}

- (void)tabView:(NSTabView *)tabView willSelectTabViewItem:(NSTabViewItem *)tabViewItem
{
    // Make sure that the threads are synced up before switching off first tab
    if([tabView indexOfTabViewItem:tabViewItem] &gt; 0)
        [self waitForDevicesThread];

    [self joyElement:self];
    [self spaceElement:self];
    [self mouseEanbleEmulation:self]; // update display
}


- (IBAction)setDefault:(id)sender
{
   [self waitForDevicesThread];
   NSDictionary * prefsDefaults = [NSDictionary dictionaryWithObjectsAndKeys:
                     [NSNumber numberWithBool: kUseMacOSCoords], GLUTUseMacOSXCoordsKey,
                     [NSNumber numberWithBool: kUseInitWD], GLUTUseCurrWDKey,
                     [NSNumber numberWithBool: kUseExtendedDesktop], GLUTUseExtendedDesktopKey,
                     [NSNumber numberWithBool: kIconic], GLUTIconicKey,
                     [NSNumber numberWithBool: kDebug], GLUTDebugModeKey,
                     [NSNumber numberWithInt: kInitWidth], GLUTInitWidthKey,
                     [NSNumber numberWithInt: kInitHeight], GLUTInitHeightKey,
                     [NSNumber numberWithInt: kInitX], GLUTInitXKey,
                     [NSNumber numberWithInt: kInitY], GLUTInitYKey,
                     [NSNumber numberWithFloat: GLUT_DEFAULT_IDLE_INTERVAL], GLUTIdleTimeIntervalKey,
                     [NSNumber numberWithFloat: GLUT_DEFAULT_FADE_INTERVAL], GLUTGameModeFadeIntervalKey,
                     [NSNumber numberWithBool: (1 - kCaptureAllDisplays)], GLUTGamemodeCaptureSingleKey,
                     [NSNumber numberWithBool: kSyncToVBL], GLUTSyncToVBLKey,
                     [NSNumber numberWithBool: kEmulateMouseButtons], GLUTEmulateMouseButtonsKey,
                     [NSNumber numberWithInt: kMouseFirstModifiers], GLUTMouseFirstModifiersKey,
                     [NSNumber numberWithInt: kMouseSecondModifiers], GLUTMouseSecondModifiersKey,
                     nil];

    // no joystick or spaceball defaults
    __glutInitJoystickInput(NULL); // reset to default
    __glutInitSpaceballInput(NULL);
    [self updateUI:prefsDefaults];
}

- (IBAction)showWindow:(id)sender
{
   (void) [self window];    // make sure that the window is loaded

#if GLUT_DEFER_PREFS_DEVICE_QUERY
    // Select the first tab (launch tab) each time the prefs window is opened.
    // This allows for the device information to be gathered via a seperate thread.
    [prefsTabView selectTabViewItemAtIndex:0];
#endif
    [self updateLaunchUI:[[NSUserDefaults standardUserDefaults] persistentDomainForName: GLUTPreferencesName]];

    // update HID list on every show
    if( !updatingDevices )
    {
        updatingDevices = YES;
        [NSThread detachNewThreadSelector:@selector(updateDevicesThread:)
                  toTarget:self withObject:nil];
    }

#if !GLUT_DEFER_PREFS_DEVICE_QUERY
    // We have to wait for this to finish when we can't guarantee
    // that the prefs tab opens up to the launch tab.
    [self waitForDevicesThread];
#endif

    [super showWindow:sender];
}

- (IBAction)ok:(id)sender
{
    int i;
    struct _GLUTinputActionRec * inputARec = NULL;
    recSaveHID configRec;

    [self waitForDevicesThread];

    NSMutableArray * JoyActionArray = [NSMutableArray arrayWithCapacity: kNumJoystickActions];
    NSMutableArray * SBActionArray = [NSMutableArray arrayWithCapacity: kNumSpaceballActions];

    NSMutableDictionary * prefsDefaults = [NSMutableDictionary dictionaryWithObjectsAndKeys:
                     [NSNumber numberWithBool: [launchUseMacOSXCoords state]], GLUTUseMacOSXCoordsKey,
                     [NSNumber numberWithBool: [launchUseCurrWD state]], GLUTUseCurrWDKey,
                     [NSNumber numberWithBool: [launchUseExtendedDesktop state]], GLUTUseExtendedDesktopKey,
                     [NSNumber numberWithBool: [launchIconic state]], GLUTIconicKey,
                     [NSNumber numberWithBool: [launchDebugMode state]], GLUTDebugModeKey,
                     [NSNumber numberWithInt: [launchInitWidth intValue]], GLUTInitWidthKey,
                     [NSNumber numberWithInt: [launchInitHeight intValue]], GLUTInitHeightKey,
                     [NSNumber numberWithInt: [launchInitX intValue]], GLUTInitXKey,
                     [NSNumber numberWithInt: [launchInitY intValue]], GLUTInitYKey,
                     [NSNumber numberWithFloat: [launchMenuIdle floatValue]], GLUTIdleTimeIntervalKey,
                     [NSNumber numberWithFloat: [launchFadeTime floatValue]], GLUTGameModeFadeIntervalKey,
                     [NSNumber numberWithBool: [launchGamemodeCaptureSingle state]], GLUTGamemodeCaptureSingleKey,
                     [NSNumber numberWithBool: [launchSyncToVBL state]], GLUTSyncToVBLKey,
                     [NSNumber numberWithBool: [mouseEmulation state]], GLUTEmulateMouseButtonsKey,
                     [NSNumber numberWithInt: [self indexToModifier:[mouseRightConfigMenu indexOfSelectedItem]]], GLUTMouseFirstModifiersKey,
                     [NSNumber numberWithInt: [self indexToModifier:[mouseMiddleConfigMenu indexOfSelectedItem]]], GLUTMouseSecondModifiersKey,
                     nil];

    for (i = 0; i &lt; kNumJoystickActions; i++) {
        inputARec = __glutGetJoystickDeviceElement (i);
        HIDSetElementConfig (&amp;configRec, inputARec-&gt;pDevice, inputARec-&gt;pElement, i);
        NSDictionary * deviceDict = [NSDictionary dictionaryWithObjectsAndKeys:
            [NSNumber numberWithInt: configRec.actionCookie], GLUTDeviceActionKey,
            [NSNumber numberWithInt: configRec.vendorID], GLUTDeviceVendorIDKey,
            [NSNumber numberWithInt: configRec.productID], GLUTDeviceProductIDKey,
            [NSNumber numberWithInt: configRec.locID], GLUTDeviceLocIDKey,
            [NSNumber numberWithInt: configRec.usage], GLUTDeviceUsageKey,
            [NSNumber numberWithInt: configRec.usagePage], GLUTDeviceUsagePageKey,
            [NSNumber numberWithInt: configRec.usageE], GLUTDeviceUsageEKey,
            [NSNumber numberWithInt: configRec.usagePageE], GLUTDeviceUsagePageEKey,
            [NSNumber numberWithInt: configRec.minReport], GLUTDeviceMinReportKey,
            [NSNumber numberWithInt: configRec.maxReport], GLUTDeviceMaxReportKey,
            [NSNumber numberWithUnsignedInt: (unsigned int)((long)configRec.cookie)], GLUTDeviceCookieKey,
            [NSNumber numberWithInt: inputARec-&gt;invertMul], GLUTDeviceInvertMulKey,
            nil];
        [JoyActionArray addObject:deviceDict];
    }
    [prefsDefaults setObject:JoyActionArray forKey:GLUTJoystickDeviceKey];
    
    for (i = 0; i &lt; kNumSpaceballActions; i++) {
        inputARec = __glutGetSpaceballDeviceElement (i);
        HIDSetElementConfig (&amp;configRec, inputARec-&gt;pDevice, inputARec-&gt;pElement, i);
        NSDictionary * deviceDict = [NSDictionary dictionaryWithObjectsAndKeys:
            [NSNumber numberWithInt: configRec.actionCookie], GLUTDeviceActionKey,
            [NSNumber numberWithInt: configRec.vendorID], GLUTDeviceVendorIDKey,
            [NSNumber numberWithInt: configRec.productID], GLUTDeviceProductIDKey,
            [NSNumber numberWithInt: configRec.locID], GLUTDeviceLocIDKey,
            [NSNumber numberWithInt: configRec.usage], GLUTDeviceUsageKey,
            [NSNumber numberWithInt: configRec.usagePage], GLUTDeviceUsagePageKey,
            [NSNumber numberWithInt: configRec.usageE], GLUTDeviceUsageEKey,
            [NSNumber numberWithInt: configRec.usagePageE], GLUTDeviceUsagePageEKey,
            [NSNumber numberWithUnsignedInt: configRec.minReport], GLUTDeviceMinReportKey,
            [NSNumber numberWithUnsignedInt: configRec.maxReport], GLUTDeviceMaxReportKey,
            [NSNumber numberWithUnsignedInt: (unsigned int)((long)configRec.cookie)], GLUTDeviceCookieKey,
            [NSNumber numberWithUnsignedInt: inputARec-&gt;invertMul], GLUTDeviceInvertMulKey,
            nil];
        [SBActionArray addObject:deviceDict];
    }
    [prefsDefaults setObject:SBActionArray forKey:GLUTSpaceballDeviceKey];
    
    [[NSUserDefaults standardUserDefaults] setPersistentDomain: prefsDefaults forName: GLUTPreferencesName];

    [self updateObjectState]; // update all glut objects from window
    [super close];
}

- (IBAction)cancel:(id)sender
{
    [super close];
}

- (void)updateLaunchUI: (NSDictionary *)prefsDefaults
{
    if ([prefsDefaults objectForKey: GLUTUseMacOSXCoordsKey])
        [launchUseMacOSXCoords setState: [[prefsDefaults objectForKey: GLUTUseMacOSXCoordsKey] boolValue]];
    if ([prefsDefaults objectForKey: GLUTUseCurrWDKey])
        [launchUseCurrWD setState: [[prefsDefaults objectForKey: GLUTUseCurrWDKey] boolValue]];
    if ([prefsDefaults objectForKey: GLUTUseExtendedDesktopKey])
        [launchUseExtendedDesktop setState: [[prefsDefaults objectForKey: GLUTUseExtendedDesktopKey] boolValue]];
    if ([prefsDefaults objectForKey: GLUTIconicKey])
        [launchIconic setState: [[prefsDefaults objectForKey: GLUTIconicKey] boolValue]];
    if ([prefsDefaults objectForKey: GLUTDebugModeKey])
        [launchDebugMode setState: [[prefsDefaults objectForKey: GLUTDebugModeKey] boolValue]];
    if ([prefsDefaults objectForKey: GLUTInitWidthKey])
        [launchInitWidth setIntValue: [[prefsDefaults objectForKey: GLUTInitWidthKey] intValue]];
    if ([prefsDefaults objectForKey: GLUTInitHeightKey])
        [launchInitHeight setIntValue: [[prefsDefaults objectForKey: GLUTInitHeightKey] intValue]];
    if ([prefsDefaults objectForKey: GLUTInitXKey])
        [launchInitX setIntValue: [[prefsDefaults objectForKey: GLUTInitXKey] intValue]];
    if ([prefsDefaults objectForKey: GLUTInitYKey])
        [launchInitY setIntValue: [[prefsDefaults objectForKey: GLUTInitYKey] intValue]];
    if ([prefsDefaults objectForKey: GLUTIdleTimeIntervalKey])
        [launchMenuIdle setFloatValue: [[prefsDefaults objectForKey: GLUTIdleTimeIntervalKey] floatValue]];
    if ([prefsDefaults objectForKey: GLUTGameModeFadeIntervalKey])
        [launchFadeTime setFloatValue: [[prefsDefaults objectForKey: GLUTGameModeFadeIntervalKey] floatValue]];
    if ([prefsDefaults objectForKey: GLUTGamemodeCaptureSingleKey])
        [launchGamemodeCaptureSingle setState: [[prefsDefaults objectForKey: GLUTGamemodeCaptureSingleKey] boolValue]];
    if ([prefsDefaults objectForKey: GLUTSyncToVBLKey])
        [launchSyncToVBL setState: [[prefsDefaults objectForKey: GLUTSyncToVBLKey] boolValue]];

    // force view/control update
    [launchInitWidth setNeedsDisplay];
    [launchInitHeight setNeedsDisplay];
    [launchInitX setNeedsDisplay];
    [launchInitY setNeedsDisplay];
    [launchMenuIdle setNeedsDisplay];
    [launchFadeTime setNeedsDisplay];
}

- (void)updateDevicesUI: (NSDictionary *)prefsDefaults
{
    if ([prefsDefaults objectForKey: GLUTEmulateMouseButtonsKey])
        [mouseEmulation setState: [[prefsDefaults objectForKey: GLUTEmulateMouseButtonsKey] boolValue]];
    if ([prefsDefaults objectForKey: GLUTMouseFirstModifiersKey])
        [mouseRightConfigMenu selectItemAtIndex: [self modifierToIndex:[[prefsDefaults objectForKey: GLUTMouseFirstModifiersKey] intValue]]];
    if ([prefsDefaults objectForKey: GLUTMouseSecondModifiersKey])
        [mouseMiddleConfigMenu selectItemAtIndex: [self modifierToIndex:[[prefsDefaults objectForKey: GLUTMouseSecondModifiersKey] intValue]]];

    // read pref array
    // note: this modifies glut settings directly (we do not dup settings for cancel for joystick and spaceball yet.
    if ([prefsDefaults objectForKey: GLUTJoystickDeviceKey]) {
        id actionDict = nil;
        pRecDevice pFirstDevice = NULL;
        NSEnumerator * enumer = [[prefsDefaults objectForKey: GLUTJoystickDeviceKey] objectEnumerator];
        // while array entries
        while (nil != (actionDict = [enumer nextObject])) {
            pRecElement pElement = NULL;
            pRecDevice pDevice = NULL;
            int action = 0;
            recSaveHID configRec;
            
            if ([actionDict objectForKey: GLUTDeviceActionKey])
                configRec.actionCookie = [[actionDict objectForKey: GLUTDeviceActionKey] longValue];
            else 
                configRec.actionCookie = 0;
            if ([actionDict objectForKey: GLUTDeviceActionKey])
                configRec.vendorID = [[actionDict objectForKey: GLUTDeviceVendorIDKey] longValue];
            else 
                configRec.vendorID = 0;
            if ([actionDict objectForKey: GLUTDeviceProductIDKey])
                configRec.productID = [[actionDict objectForKey: GLUTDeviceProductIDKey] longValue];
            else 
                configRec.productID = 0;
            if ([actionDict objectForKey: GLUTDeviceLocIDKey])
                configRec.locID = [[actionDict objectForKey: GLUTDeviceLocIDKey] longValue];
            else 
                configRec.locID = 0;
            if ([actionDict objectForKey: GLUTDeviceUsageKey])
                configRec.usage = [[actionDict objectForKey: GLUTDeviceUsageKey] longValue];
            else 
                configRec.usage = 0;
            if ([actionDict objectForKey: GLUTDeviceUsagePageKey])
                configRec.usagePage = [[actionDict objectForKey: GLUTDeviceUsagePageKey] longValue];
            else 
                configRec.usagePage = 0;
            if ([actionDict objectForKey: GLUTDeviceUsageEKey])
                configRec.usageE = [[actionDict objectForKey: GLUTDeviceUsageEKey] longValue];
            else 
                configRec.usageE = 0;
            if ([actionDict objectForKey: GLUTDeviceUsagePageEKey])
                configRec.usagePageE = [[actionDict objectForKey: GLUTDeviceUsagePageEKey] longValue];
            else 
                configRec.usagePageE = 0;
            if ([actionDict objectForKey: GLUTDeviceMinReportKey])
                configRec.minReport = [[actionDict objectForKey: GLUTDeviceMinReportKey] longValue];
            else 
                configRec.minReport = 0;
            if ([actionDict objectForKey: GLUTDeviceMaxReportKey])
                configRec.maxReport = [[actionDict objectForKey: GLUTDeviceMaxReportKey] longValue];
            else 
                configRec.maxReport = 0;
            if ([actionDict objectForKey: GLUTDeviceCookieKey])
                configRec.cookie = (IOHIDElementCookie)[[actionDict objectForKey: GLUTDeviceCookieKey] unsignedLongValue];
            else 
                configRec.cookie = 0;

            // find device and element for configRec and find controling action
            action = HIDGetElementConfig (&amp;configRec, &amp;pDevice, &amp;pElement);
            struct _GLUTinputActionRec * inputARec = __glutGetJoystickDeviceElement (action);
            if (NULL == pFirstDevice)
                pFirstDevice = pDevice;
            if (pDevice &amp;&amp; pElement &amp;&amp; (pFirstDevice == pDevice)) { // valid device and element  and we match the same device
                // fill information in
                inputARec-&gt;pDevice = pDevice;
                inputARec-&gt;pElement = pElement;
                if ([actionDict objectForKey: GLUTDeviceInvertMulKey])
                    inputARec-&gt;invertMul = [[actionDict objectForKey: GLUTDeviceInvertMulKey] longValue];
                else 
                    inputARec-&gt;invertMul = 1;
            } else { // device for action not found so blank current device
                inputARec-&gt;pDevice = NULL;
                inputARec-&gt;pElement = NULL;
                inputARec-&gt;invertMul = 1;
            }
        }
    }
    if ([prefsDefaults objectForKey: GLUTSpaceballDeviceKey]) {
        id actionDict = nil;
        pRecDevice pFirstDevice = NULL;
        NSEnumerator * enumer = [[prefsDefaults objectForKey: GLUTSpaceballDeviceKey] objectEnumerator];
        // while array entries
        while (nil != (actionDict = [enumer nextObject])) {
            pRecElement pElement = NULL;
            pRecDevice pDevice = NULL;
            int action = 0;
            recSaveHID configRec;
            
            if ([actionDict objectForKey: GLUTDeviceActionKey])
                configRec.actionCookie = [[actionDict objectForKey: GLUTDeviceActionKey] longValue];
            else 
                configRec.actionCookie = 0;
            if ([actionDict objectForKey: GLUTDeviceActionKey])
                configRec.vendorID = [[actionDict objectForKey: GLUTDeviceVendorIDKey] longValue];
            else 
                configRec.vendorID = 0;
            if ([actionDict objectForKey: GLUTDeviceProductIDKey])
                configRec.productID = [[actionDict objectForKey: GLUTDeviceProductIDKey] longValue];
            else 
                configRec.productID = 0;
            if ([actionDict objectForKey: GLUTDeviceLocIDKey])
                configRec.locID = [[actionDict objectForKey: GLUTDeviceLocIDKey] longValue];
            else 
                configRec.locID = 0;
            if ([actionDict objectForKey: GLUTDeviceUsageKey])
                configRec.usage = [[actionDict objectForKey: GLUTDeviceUsageKey] longValue];
            else 
                configRec.usage = 0;
            if ([actionDict objectForKey: GLUTDeviceUsagePageKey])
                configRec.usagePage = [[actionDict objectForKey: GLUTDeviceUsagePageKey] longValue];
            else 
                configRec.usagePage = 0;
            if ([actionDict objectForKey: GLUTDeviceUsageEKey])
                configRec.usageE = [[actionDict objectForKey: GLUTDeviceUsageEKey] longValue];
            else 
                configRec.usageE = 0;
            if ([actionDict objectForKey: GLUTDeviceUsagePageEKey])
                configRec.usagePageE = [[actionDict objectForKey: GLUTDeviceUsagePageEKey] longValue];
            else 
                configRec.usagePageE = 0;
            if ([actionDict objectForKey: GLUTDeviceMinReportKey])
                configRec.minReport = [[actionDict objectForKey: GLUTDeviceMinReportKey] longValue];
            else 
                configRec.minReport = 0;
            if ([actionDict objectForKey: GLUTDeviceMaxReportKey])
                configRec.maxReport = [[actionDict objectForKey: GLUTDeviceMaxReportKey] longValue];
            else 
                configRec.maxReport = 0;
            if ([actionDict objectForKey: GLUTDeviceCookieKey])
                configRec.cookie = (IOHIDElementCookie)[[actionDict objectForKey: GLUTDeviceCookieKey] unsignedLongValue];
            else 
                configRec.cookie = 0;

            // find device and element for configRec and find controling action
            action = HIDGetElementConfig (&amp;configRec, &amp;pDevice, &amp;pElement);
            struct _GLUTinputActionRec * inputARec = __glutGetSpaceballDeviceElement (action);
            if (NULL == pFirstDevice)
                pFirstDevice = pDevice;
            if (pDevice &amp;&amp; pElement &amp;&amp; (pFirstDevice == pDevice)) { // valid device and element  and we match the same device
                // fill information in
                inputARec-&gt;pDevice = pDevice;
                inputARec-&gt;pElement = pElement;
                if ([actionDict objectForKey: GLUTDeviceInvertMulKey])
                    inputARec-&gt;invertMul = [[actionDict objectForKey: GLUTDeviceInvertMulKey] longValue];
                else 
                    inputARec-&gt;invertMul = 1;
            } else { // device for action not found so blank current device
                inputARec-&gt;pDevice = NULL;
                inputARec-&gt;pElement = NULL;
                inputARec-&gt;invertMul = 1;
            }
        }
    }

    // ensure joystick and spaceball displays are set up
    [self joyElement:self];
    [self spaceElement:self];
    [self mouseEanbleEmulation:self]; // update display
}

- (void)updateUI: (NSDictionary *)prefsDefaults
{
    // read dictionanary and set as appropriate
    // set values and re-init (ensure to check to see if keyed object exists)
    [self updateLaunchUI:prefsDefaults];
    [self updateDevicesUI:prefsDefaults];
}

- (void)updateDevicesThread:(id)object
{
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    GLUTDeviceEnumerator enumer;

    __glutCollectInputDevices();

    // update joystick menu
    [joyDeviceMenu removeAllItems];
    __glutGetInputDeviceEnumeratorOfClass (GLUT_JOYSTICK_DEVICE, &amp;enumer);
    pRecDevice pDevice = __glutGetNextInputDevice (&amp;enumer);
    while (pDevice) {
        [joyDeviceMenu addItemWithTitle:[NSString stringWithFormat:@&quot;%s %s&quot;,pDevice-&gt;manufacturer, pDevice-&gt;product]];
        pDevice = __glutGetNextInputDevice (&amp;enumer);
    }
    if (0 == [joyDeviceMenu numberOfItems]) // no devices found
        [joyDeviceMenu addItemWithTitle:NSLocalizedStringFromTableInBundle(@&quot;No devices with 2+ axis found.&quot;, @&quot;GLUTUI&quot;, __glutGetFrameworkBundle(), @&quot;No devices with 2+ axis found.&quot;)];

    // update spaceball menu
    [spaceDeviceMenu removeAllItems];
    __glutGetInputDeviceEnumeratorOfClass (GLUT_SPACEBALL_DEVICE, &amp;enumer);
    pDevice = __glutGetNextInputDevice (&amp;enumer);
    while (pDevice) {
        [spaceDeviceMenu addItemWithTitle:[NSString stringWithFormat:@&quot;%s %s&quot;,pDevice-&gt;manufacturer, pDevice-&gt;product]];
        pDevice = __glutGetNextInputDevice (&amp;enumer);
    }
    if (0 == [spaceDeviceMenu numberOfItems]) // no devices found
        [spaceDeviceMenu addItemWithTitle:NSLocalizedStringFromTableInBundle(@&quot;No devices with 6+ axis found.&quot;, @&quot;GLUTUI&quot;, __glutGetFrameworkBundle(), @&quot;No devices with 6+ axis found.&quot;)];
        
    // ensure the device list and assignments are up to date
    [self updateDevicesUI:[[NSUserDefaults standardUserDefaults] persistentDomainForName: GLUTPreferencesName]];
    __glutUpdateJoystickInput (); 
    pDevice = __glutGetJoystickDevice ();
    if (pDevice)
        [joyDeviceMenu selectItemWithTitle:[NSString stringWithFormat:@&quot;%s %s&quot;,pDevice-&gt;manufacturer, pDevice-&gt;product]];

    __glutUpdateSpaceballInput (); 
    pDevice = __glutGetSpaceballDevice ();
    if (pDevice)
        [spaceDeviceMenu selectItemWithTitle:[NSString stringWithFormat:@&quot;%s %s&quot;,pDevice-&gt;manufacturer, pDevice-&gt;product]];

    updatingDevices = NO;
    [pool drain];
}

- (void)waitForDevicesThread
{
    while( YES == updatingDevices )
        [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.05f]];
}

- (void)updateObjectState // after OK
{
    // everything joystick related is already set  //ggs: fix me
    [self updateLaunchState];
    [self updateMouseState];
}

/////////////////////////////////////////////
#pragma mark -
#pragma mark Launch Section
#pragma mark -

- (IBAction)launchUseMacOSCoords:(id)sender
{
// no action required
}

- (IBAction)launchUseCurrWD:(id)sender
{
// no action required
}

- (IBAction)launchUseExtDesktop:(id)sender
{
// no action required
}

- (IBAction)launchIconic:(id)sender
{
// no action required
}

- (IBAction)launchDebugMode:(id)sender
{
// no action required
}

- (IBAction)launchGamemodeCaptureSingle:(id)sender
{
// no action required
}

- (void)updateLaunchState // after OK
{
    // set values and re-init
    __glutUseMacOSCoords = [launchUseMacOSXCoords state];
    __glutUseInitWD = [launchUseCurrWD state];
    __glutUseExtendedDesktop = [launchUseExtendedDesktop state];
    // reset width and height in __glutEngineInit below
    __glutIconic = [launchIconic state];
    __glutDebug = [launchDebugMode state];
    if ([launchInitWidth intValue] &gt; 0)
        __glutInitWidth = [launchInitWidth intValue];
    if ([launchInitHeight intValue] &gt; 0)
        __glutInitHeight = [launchInitHeight intValue];
    if (NO == __glutUseMacOSCoords) {
        if([launchInitX intValue] &gt;= 0)
            __glutInitX = [launchInitX intValue];
    } else
        __glutInitX = [launchInitX intValue];
    if (NO == __glutUseMacOSCoords) {
        if([launchInitY intValue] &gt;= 0)
            __glutInitY = [launchInitY intValue];
    } else
        __glutInitY = [launchInitY intValue];
    __glutIdleTimeInterval = [launchMenuIdle floatValue];
    __glutGameModeFadeInterval = [launchFadeTime floatValue];
    __glutCaptureAllDisplays = 1 - [launchGamemodeCaptureSingle state];
    __glutSyncToVBL = [launchSyncToVBL state];
    
    __glutEngineInit (); // handles any set up glut engine needs
}

/////////////////////////////////////////////
#pragma mark -
#pragma mark Joystick Section
#pragma mark -

- (IBAction)joyDevice:(id)sender
{
    [joyAssignNote setStringValue:@&quot; &quot;];
    [joyAssignNote display];
    [joyAssignWarningIcon removeFromSuperview];

    // reset all inputs for new device put up warning
    // find name and compare to current
    // if found slect and reset inputs
    // if not found post error and reset to default
    
    GLUTDeviceEnumerator enumer;
    NSString * title = [joyDeviceMenu titleOfSelectedItem];
    __glutGetInputDeviceEnumeratorOfClass (GLUT_JOYSTICK_DEVICE, &amp;enumer);
    pRecDevice pCurrentDevice = __glutGetJoystickDevice(), pFoundDevice = NULL, pDevice = __glutGetNextInputDevice (&amp;enumer);
    while (pDevice &amp;&amp; !pFoundDevice) {
        if (NSOrderedSame == [title compare:[NSString stringWithFormat:@&quot;%s %s&quot;,pDevice-&gt;manufacturer, pDevice-&gt;product]])
            pFoundDevice = pDevice;
        pDevice = __glutGetNextInputDevice (&amp;enumer);
    }
    if (pCurrentDevice != pFoundDevice) {
        if (pFoundDevice) {
            __glutInitJoystickInput (pFoundDevice);
            [joyInputMenu selectItemAtIndex:0]; // reset position 
            [self joyElement:self]; // force assigment update
            [joyDeviceMenu selectItemWithTitle:[NSString stringWithFormat:@&quot;%s %s&quot;,pFoundDevice-&gt;manufacturer, pFoundDevice-&gt;product]];
            [joyAssignNote setStringValue: NSLocalizedStringFromTableInBundle(@&quot;New device select, all inputs reset.&quot;, @&quot;GLUTUI&quot;,
                                        __glutGetFrameworkBundle(),
                                        @&quot;New device select, all inputs reset.&quot;)];
            
        } else { // reset
            __glutInitJoystickInput (NULL);
            [joyInputMenu selectItemAtIndex:0]; // reset position 
            [self joyElement:self]; // force assigment update
            pDevice = __glutGetJoystickDevice ();
            if (pDevice)
                [joyDeviceMenu selectItemWithTitle:[NSString stringWithFormat:@&quot;%s %s&quot;,pDevice-&gt;manufacturer, pDevice-&gt;product]];
                [joyAssignNote setStringValue: NSLocalizedStringFromTableInBundle(@&quot;Selected device not found.&quot;, @&quot;GLUTUI&quot;,
                                            __glutGetFrameworkBundle(),
                                            @&quot;Selected device not found.&quot;)];
        }
        [joyAssignNote display];
        [joyTabItemView addSubview: joyAssignWarningIcon];
    }
}

- (IBAction)joyAssign:(id)sender
{
    [joyAssignNote setStringValue:@&quot; &quot;];
    [joyAssignNote display];
    [joyAssignWarningIcon removeFromSuperview];

    pRecDevice pDevice = NULL;
    pRecElement pElement = NULL;
    struct _GLUTinputActionRec * inputARec = __glutGetJoystickDeviceElement ([joyInputMenu indexOfSelectedItem]);
    if (inputARec &amp;&amp; inputARec-&gt;pDevice)
        pDevice = inputARec-&gt;pDevice;
    else
        pDevice = __glutGetJoystickDevice ();
    // this currently does not accunt for restricting the input to axis or buttons
    if ([joyInputMenu indexOfSelectedItem] &lt; kActionButton1) {
        [joyAssignNote setStringValue: [NSString stringWithFormat:@&quot;%@ %s %@&quot;, 
                                                NSLocalizedStringFromTableInBundle(@&quot;Move&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;Move&quot;), 
                                                pDevice-&gt;product, 
                                                NSLocalizedStringFromTableInBundle(@&quot;axis to assign.&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;axis to assign.&quot;)]];
    } else {
        [joyAssignNote setStringValue: [NSString stringWithFormat:@&quot;%@ %s %@&quot;, 
                                                NSLocalizedStringFromTableInBundle(@&quot;Press&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;Press&quot;), 
                                                pDevice-&gt;product, 
                                                NSLocalizedStringFromTableInBundle(@&quot;button to assign.&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;button to assign.&quot;)]];
    }
    [joyAssignNote display];
    [joyAssignWarningIcon removeFromSuperview];
    [joyElement setStringValue:NSLocalizedStringFromTableInBundle(@&quot;Unassigned&quot;, @&quot;GLUTUI&quot;,
                              __glutGetFrameworkBundle(),
                              @&quot;Unassigned&quot;)];
    [joyElement display];
    // assign to next input that moves on chosen device
    if (HIDConfigureSingleDeviceAction (pDevice, &amp;pElement, 5.0)) {
        if (pElement) {
            inputARec-&gt;pDevice = pDevice; // ensure device is set
            inputARec-&gt;pElement = pElement;
            if ([joyInputMenu indexOfSelectedItem] &lt; kActionButton1) {
                pElement-&gt;userMin = -1000;
                pElement-&gt;userMax = 1000;
            } else {
                pElement-&gt;userMin = 0;
                pElement-&gt;userMax = 1;
            }
        }
        [self joyElement:self]; // force assigment update
    } else {
        [self joyElement:self]; // force assigment update
        [joyAssignNote setStringValue: [NSString stringWithFormat:@&quot;%@ %s&quot;, 
                                                NSLocalizedStringFromTableInBundle(@&quot;Please choose input on&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;Please choose input on&quot;), 
                                                pDevice-&gt;product]];
        [joyAssignNote display];
        [joyTabItemView addSubview: joyAssignWarningIcon];
    }
}

- (IBAction)joyElement:(id)sender
{
    [joyAssignNote setStringValue:@&quot; &quot;];
    [joyAssignNote display];
    [joyAssignWarningIcon removeFromSuperview];

    // get menu item and update string
    NSString * outString;
    struct _GLUTinputActionRec * inputARec = __glutGetJoystickDeviceElement ([joyInputMenu indexOfSelectedItem]);
    if (inputARec &amp;&amp; inputARec-&gt;pDevice) {
        [joyInverted setEnabled:YES];
        [joyElement setEnabled:YES];
        [joyInputMenu setEnabled:YES];
        [joyAssign setEnabled:YES];
        if (inputARec-&gt;pElement) {
            outString = [[NSString alloc] initWithFormat: @&quot;%s&quot;,inputARec-&gt;pElement-&gt;name];
            // this is normally supplied by the device and cannot be simply localized
            // set inverted check
            [joyInverted setIntValue: ((-inputARec-&gt;invertMul + 1) / 2)]; // so -1 = checked and 1 = not checked
        } else {
            outString = [[NSString alloc] initWithFormat:NSLocalizedStringFromTableInBundle(@&quot;No device input assigned.&quot;, @&quot;GLUTUI&quot;,
                                __glutGetFrameworkBundle(),
                                @&quot;No device input assigned.&quot;)];
        }
    } else {
        outString = [[NSString alloc] initWithFormat:NSLocalizedStringFromTableInBundle(@&quot;No device.&quot;, @&quot;GLUTUI&quot;,
                              __glutGetFrameworkBundle(),
                              @&quot;No device.&quot;)];
        [joyInverted setEnabled:NO];
        [joyElement setEnabled:NO];
        [joyInputMenu setEnabled:NO];
        [joyAssign setEnabled:NO];
    }
    [joyElement setStringValue:outString];
}

- (IBAction)joyInvert:(id)sender
{
    struct _GLUTinputActionRec * inputARec = __glutGetJoystickDeviceElement ([joyInputMenu indexOfSelectedItem]);
    inputARec-&gt;invertMul = -[joyInverted intValue] * 2 + 1; // so checked = -1 and not checked = 1
}

/////////////////////////////////////////////
#pragma mark -
#pragma mark Spaceball Section
#pragma mark -

- (IBAction)spaceDevice:(id)sender
{
    [spaceAssignNote setStringValue:@&quot; &quot;];
    [spaceAssignNote display];
    [spaceAssignWarningIcon removeFromSuperview];

    // reset all inputs for new device put up warning
    // find name and compare to current
    // if found slect and reset inputs
    // if not found post error and reset to default
    
    GLUTDeviceEnumerator enumer;
    NSString * title = [spaceDeviceMenu titleOfSelectedItem];
    __glutGetInputDeviceEnumeratorOfClass (GLUT_SPACEBALL_DEVICE, &amp;enumer);
    pRecDevice pCurrentDevice = __glutGetSpaceballDevice(), pFoundDevice = NULL, pDevice = __glutGetNextInputDevice (&amp;enumer);
    while (pDevice &amp;&amp; !pFoundDevice) {
        if (NSOrderedSame == [title compare:[NSString stringWithFormat:@&quot;%s %s&quot;,pDevice-&gt;manufacturer, pDevice-&gt;product]])
            pFoundDevice = pDevice;
        pDevice = __glutGetNextInputDevice (&amp;enumer);
    }
    if (pCurrentDevice != pFoundDevice) {
        if (pFoundDevice) {
            __glutInitSpaceballInput (pFoundDevice);
            [spaceInputMenu selectItemAtIndex:0]; // reset position 
            [self spaceElement:self]; // force assigment update
            [spaceDeviceMenu selectItemWithTitle:[NSString stringWithFormat:@&quot;%s %s&quot;,pFoundDevice-&gt;manufacturer, pFoundDevice-&gt;product]];
            [spaceAssignNote setStringValue: NSLocalizedStringFromTableInBundle(@&quot;New device select, all inputs reset.&quot;, @&quot;GLUTUI&quot;,
                                        __glutGetFrameworkBundle(),
                                        @&quot;New device select, all inputs reset.&quot;)];
            
        } else { // reset
            __glutInitSpaceballInput (NULL);
            [spaceInputMenu selectItemAtIndex:0]; // reset position 
            [self spaceElement:self]; // force assigment update
            pDevice = __glutGetSpaceballDevice ();
            if (pDevice)
                [spaceDeviceMenu selectItemWithTitle:[NSString stringWithFormat:@&quot;%s %s&quot;,pDevice-&gt;manufacturer, pDevice-&gt;product]];
                [spaceAssignNote setStringValue: NSLocalizedStringFromTableInBundle(@&quot;Selected device not found.&quot;, @&quot;GLUTUI&quot;,
                                            __glutGetFrameworkBundle(),
                                            @&quot;Selected device not found.&quot;)];
        }
        [spaceAssignNote display];
        [spaceTabItemView addSubview: spaceAssignWarningIcon];
    }
}


- (IBAction)spaceAssign:(id)sender
{
    [spaceAssignNote setStringValue:@&quot; &quot;];
    [spaceAssignNote display];
    [spaceAssignWarningIcon removeFromSuperview];

    pRecDevice pDevice = NULL;
    pRecElement pElement = NULL;
    struct _GLUTinputActionRec * inputARec = __glutGetSpaceballDeviceElement ([spaceInputMenu indexOfSelectedItem]);
    if (inputARec &amp;&amp; inputARec-&gt;pDevice)
        pDevice = inputARec-&gt;pDevice;
    else
        pDevice = __glutGetSpaceballDevice ();
    // this currently does not accunt for restricting the input to axis or buttons
    if ([spaceInputMenu indexOfSelectedItem] &lt; kActionButton1) {
        [spaceAssignNote setStringValue: [NSString stringWithFormat:@&quot;%@ %s %@&quot;, 
                                                NSLocalizedStringFromTableInBundle(@&quot;Move&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;Move&quot;), 
                                                pDevice-&gt;product, 
                                                NSLocalizedStringFromTableInBundle(@&quot;axis to assign.&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;axis to assign.&quot;)]];
    } else {
        [spaceAssignNote setStringValue: [NSString stringWithFormat:@&quot;%@ %s %@&quot;, 
                                                NSLocalizedStringFromTableInBundle(@&quot;Press&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;Press&quot;), 
                                                pDevice-&gt;product, 
                                                NSLocalizedStringFromTableInBundle(@&quot;button to assign.&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;button to assign.&quot;)]];
    }
    [spaceAssignNote display];
    [spaceAssignWarningIcon removeFromSuperview];
    [spaceElement setStringValue:NSLocalizedStringFromTableInBundle(@&quot;Unassigned&quot;, @&quot;GLUTUI&quot;,
                              __glutGetFrameworkBundle(),
                              @&quot;Unassigned&quot;)];
    [spaceElement display];
    // assign to next input that moves on chosen device
    if (HIDConfigureSingleDeviceAction (pDevice, &amp;pElement, 5.0)) {
        if (pElement) {
            inputARec-&gt;pDevice = pDevice; // ensure device is set
            inputARec-&gt;pElement = pElement;
            if ([spaceInputMenu indexOfSelectedItem] &lt; kSBActionXRotation) {
                pElement-&gt;userMin = -1000;
                pElement-&gt;userMax = 1000;
            } else if ([spaceInputMenu indexOfSelectedItem] &lt; kSBActionButton1) {
                pElement-&gt;userMin = -1800;
                pElement-&gt;userMax = 1800;
            } else {
                pElement-&gt;userMin = 0;
                pElement-&gt;userMax = 1;
            }
        }
        [self spaceElement:self]; // force assigment update
    } else {
        [self spaceElement:self]; // force assigment update
        [spaceAssignNote setStringValue: [NSString stringWithFormat:@&quot;%@ %s&quot;, 
                                                NSLocalizedStringFromTableInBundle(@&quot;Please choose input on&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;Please choose input on&quot;), 
                                                pDevice-&gt;product]];
        [spaceAssignNote display];
        [spaceTabItemView addSubview: spaceAssignWarningIcon];
    }
    
}

- (IBAction)spaceElement:(id)sender
{
    [spaceAssignNote setStringValue:@&quot; &quot;];
    [spaceAssignNote display];
    [spaceAssignWarningIcon removeFromSuperview];

    // get menu item and update string
    NSString * outString;
    struct _GLUTinputActionRec * inputARec = __glutGetSpaceballDeviceElement ([spaceInputMenu indexOfSelectedItem]);
    if (inputARec &amp;&amp; inputARec-&gt;pDevice) {
        [spaceInverted setEnabled:YES];
        [spaceElement setEnabled:YES];
        [spaceInputMenu setEnabled:YES];
        [spaceAssign setEnabled:YES];
        if (inputARec-&gt;pElement) {
            outString = [[NSString alloc] initWithFormat: @&quot;%s&quot;,inputARec-&gt;pElement-&gt;name];
            // this is normally supplied by the device and cannot be simply localized
            // set inverted check
            [spaceInverted setIntValue: ((-inputARec-&gt;invertMul + 1) / 2)]; // so -1 = checked and 1 = not checked
        } else {
            outString = [[NSString alloc] initWithFormat:NSLocalizedStringFromTableInBundle(@&quot;No device input assigned.&quot;, @&quot;GLUTUI&quot;,
                                __glutGetFrameworkBundle(),
                                @&quot;No device input assigned.&quot;)];
        }
    } else {
        outString = [[NSString alloc] initWithFormat:NSLocalizedStringFromTableInBundle(@&quot;No device.&quot;, @&quot;GLUTUI&quot;,
                              __glutGetFrameworkBundle(),
                              @&quot;No device.&quot;)];
        [spaceInverted setEnabled:NO];
        [spaceElement setEnabled:NO];
        [spaceInputMenu setEnabled:NO];
        [spaceAssign setEnabled:NO];
    }
    [spaceElement setStringValue:outString];
}

- (IBAction)spaceInvert:(id)sender
{
    struct _GLUTinputActionRec * inputARec = __glutGetSpaceballDeviceElement ([spaceInputMenu indexOfSelectedItem]);
    if (inputARec)
        inputARec-&gt;invertMul = -[spaceInverted intValue] * 2 + 1; // so checked = -1 and not checked = 1
}


/////////////////////////////////////////////
#pragma mark -
#pragma mark Mouse Section
#pragma mark -

- (IBAction)mouseEanbleEmulation:(id)sender
{
    [mouseAssignWarningText setStringValue: @&quot; &quot;];
    [mouseAssignWarningText display];
    [mouseAssignWarningIcon removeFromSuperview];
    if ([mouseEmulation state]) {
        [mouseRightConfigMenu setEnabled:YES];
        [mouseMiddleConfigMenu setEnabled:YES];
    } else {
        [mouseRightConfigMenu setEnabled:NO];
        [mouseMiddleConfigMenu setEnabled:NO];
    }
}

- (IBAction)mouseMiddleMenu:(id)sender
{
    [mouseAssignWarningText setStringValue: @&quot; &quot;];
    [mouseAssignWarningText display];
    [mouseAssignWarningIcon removeFromSuperview];
    if ([mouseRightConfigMenu indexOfSelectedItem] == [mouseMiddleConfigMenu indexOfSelectedItem]) {
        // can't be the same
        [mouseAssignWarningText setStringValue: [NSString stringWithFormat:@&quot;%@&quot;, 
                                                NSLocalizedStringFromTableInBundle(@&quot;Button modifiers must not be the same.&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;Button modifiers must not be the same.&quot;)]];
        [mouseAssignWarningText display];
        [mouseTabItemView addSubview: mouseAssignWarningIcon];
        [mouseMiddleConfigMenu selectItemAtIndex: (([mouseRightConfigMenu indexOfSelectedItem] + 1) % 4)];
    }
}

- (IBAction)mouseRightMenu:(id)sender
{
    [mouseAssignWarningText setStringValue: @&quot; &quot;];
    [mouseAssignWarningText display];
    [mouseAssignWarningIcon removeFromSuperview];
    if ([mouseRightConfigMenu indexOfSelectedItem] == [mouseMiddleConfigMenu indexOfSelectedItem]) {
        // can't be the same
        [mouseAssignWarningText setStringValue: [NSString stringWithFormat:@&quot;%@&quot;, 
                                                NSLocalizedStringFromTableInBundle(@&quot;Button modifiers must not be the same.&quot;, @&quot;GLUTUI&quot;,
                                                __glutGetFrameworkBundle(),
                                                @&quot;Button modifiers must not be the same.&quot;)]];
        [mouseAssignWarningText display];
        [mouseTabItemView addSubview: mouseAssignWarningIcon];
        [mouseRightConfigMenu selectItemAtIndex: (([mouseMiddleConfigMenu indexOfSelectedItem] + 1) % 4)];
    }
}

- (void)updateMouseState
{
    __glutEmulateMouseButtons = [mouseEmulation state];
    __glutMouseFirstModifiers = [self indexToModifier:[mouseRightConfigMenu indexOfSelectedItem]];
    __glutMouseSecondModifiers = [self indexToModifier:[mouseMiddleConfigMenu indexOfSelectedItem]];
}

- (int) modifierToIndex:(unsigned int)modifier
{
// dialog order Control Option Command Shift
    switch (modifier) {
        case NSControlKeyMask:
            return 0;
            break;
        case NSAlternateKeyMask:
            return 1;
            break;
        case NSCommandKeyMask:
            return 2;
            break;
        case NSShiftKeyMask:
            return 3;
            break;
        default:
            return 0;
    }
}

- (unsigned int) indexToModifier:(int)buttonIndex
{
// dialog order Control Option Command Shift
    switch (buttonIndex) {
        case 0:
            return NSControlKeyMask;
            break;
        case 1:
            return NSAlternateKeyMask;
            break;
        case 2:
            return NSCommandKeyMask;
            break;
        case 3:
            return NSShiftKeyMask;
            break;
        default:
            return 0;
    }
}

@end
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing77.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing77.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing77.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>