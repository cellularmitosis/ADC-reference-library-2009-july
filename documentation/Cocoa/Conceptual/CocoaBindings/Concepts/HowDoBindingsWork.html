<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Bindings Programming Topics: How Do Bindings Work?</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="How Do Bindings Work?"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20002373" title="How Do Bindings Work?"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Cocoa Bindings Programming Topics</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="WhatAreBindings.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="CntrlContent.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20002373-CJBEJBHH" title="How Do Bindings Work?"></a><hr /><H1>How Do Bindings Work?</H1><p>This article provides a conceptual explanation of how Cocoa bindings work. It describes:</p><ul class="ul"><li class="li"><p>How connections between model and controller, and controller and view, are established using key-value binding</p></li><li class="li"><p>Unbinding</p></li><li class="li"><p>The NSEditor and NSEditorRegistration protocols</p></li><li class="li"><p>The technologies that Cocoa bindings use to support communication between the model, view, and controller, namely key-value coding, and key-value observing</p></li><li class="li"><p>How the various technologies interact</p></li></ul><p>You should already be familiar with the concepts presented in <span class="content_text"><a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-CJBEJBHH">“What Are Cocoa Bindings?.”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="HowDoBindingsWork.html#//apple_ref/doc/uid/20002373-174515">Overview of the Supporting Technologies</a>
				
			<br/>
			
        
			
			
				<a href="HowDoBindingsWork.html#//apple_ref/doc/uid/20002373-187546-BAJGAEAG">The Supporting Technologies in Detail</a>
				
			<br/>
			
        
			
			
				<a href="HowDoBindingsWork.html#//apple_ref/doc/uid/20002373-194182">Bindings in More Detail</a>
				
			<br/>
			
        
			
			
				<a href="HowDoBindingsWork.html#//apple_ref/doc/uid/20002373-196748">Responding to Changes</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20002373-174515" title="Overview of the Supporting Technologies"></a><h2>Overview of the Supporting Technologies</h2><p>This section presents an overview of the technologies that make Cocoa bindings work and how they interact. They are discussed in greater detail in the following sections.</p><p>Cocoa bindings rely on other technologies—key-value coding (KVC) and key-value observing (KVO)—to communicate changes between objects, and on key-value binding (KVB) to bind a value in one object to a property in another. Cocoa bindings also use two protocols—NSEditor and NSEditorRegistration—that help to ensure that any pending edits are either discarded or committed before user interface elements are disposed of.</p><p>To understand how these technologies work together, consider a drawing application that allows the user to draw graphic objects such as circles and rectangles on screen. Among other properties, a graphic object has a shadow that may be offset a variable distance from the center of the graphic at an arbitrary angle. An inspector displays the offset and angle of the selected graphic object’s shadow in a pair of text fields and a custom view—a joystick—as shown in <span class="content_text">Figure 1</span>. </p><br/><div><a name="//apple_ref/doc/uid/20002373-205446-BCIHDBID" title="Figure 1Example drawing application"></a><p><a name="//apple_ref/doc/uid/20002373-205446" title="Figure 1Example drawing application"></a><strong>Figure 1&nbsp;&nbsp;</strong>Example drawing application</p><img src = "../art/joystick_example.gif" alt = "" width="478" height="275"></div><br/><p>The implementation of the inspector is illustrated in <span class="content_text">Figure 2</span>. Both the text fields and the joystick are bound to the <code>selection</code> of an NSArrayController. The controller’s <code>contentArray</code> is bound to an array of Graphic objects. A Graphic has instance variables to represent its shadow’s angle in radians and its offset from its center.</p><br/><div><a name="//apple_ref/doc/uid/20002373-201563-BAJBEHAB" title="Figure 2Bindings for example graphics application"></a><p><a name="//apple_ref/doc/uid/20002373-201563" title="Figure 2Bindings for example graphics application"></a><strong>Figure 2&nbsp;&nbsp;</strong>Bindings for example graphics application</p><img src = "../art/joystick_setup.gif" alt = "" width="484" height="230"></div><br/><p>The text fields’ values are bound to the angle and offset of the graphic object’s shadow; the joystick provides a graphical representation of angle and offset. The angle in the text field is displayed in degrees, and the angle used internally by the joystick is specified in radians. The bindings for both of these specify a reversible value transformer that converts between radians and degrees. </p><p>The complete sequence of events that occurs when a user edits a value in the angle text field is illustrated in <span class="content_text"><a href="HowDoBindingsWork.html#//apple_ref/doc/uid/20002373-201086-BAJIDEBE">Figure 3</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/20002373-201086-BAJIDEBE" title="Figure 3The complete edit cycle"></a><p><a name="//apple_ref/doc/uid/20002373-201086" title="Figure 3The complete edit cycle"></a><strong>Figure 3&nbsp;&nbsp;</strong>The complete edit cycle</p><img src = "../art/joystick_cycle.gif" alt = "" width="446" height="220"></div><br/><ol class="ol"><li class="li"><p>The user enters a new value in the Angle text field. The text field uses the NSEditorRegistration protocol to indicate that an edit has begun, and when it is complete.  The text field’s binding specifies a reversible radians-to-degrees value transformer, so the new value is converted to radians.</p></li><li class="li"><p>Using KVC, through the controller the view updates the model object’s <code>shadowAngle</code> variable.</p></li><li class="li"><p>Through KVO, the model informs the controller that an update has been made to its <code>shadowAngle</code> variable.</p></li><li class="li"><p>Through KVO, the controller informs the joystick and the angle text field that an update has been made to its content’s <code>shadowAngle</code> variable.</p></li></ol><p>Notice that the Offset text field was not involved in the cycle in any way. Cocoa bindings impose no more overhead than is necessary.</p><p>The next sections explain in greater detail how bindings are established and how the underlying technologies operate.</p><a name="//apple_ref/doc/uid/20002373-187546" title="The Supporting Technologies in Detail"></a><a name="//apple_ref/doc/uid/20002373-187546-BAJGAEAG" title="The Supporting Technologies in Detail"></a><h2>The Supporting Technologies in Detail</h2><p>This section first describes the technologies that support bindings and shows how they play their parts. It also explains what steps you must take in order to take advantage of these technologies.</p><a name="//apple_ref/doc/uid/20002373-204628" title="Establishing Bindings with Key-Value Binding"></a><h3>Establishing Bindings with Key-Value Binding</h3><p>Key-value binding is used to establish bindings. The NSKeyValueBindingCreation informal protocol declares methods to establish and remove bindings between objects. In addition, it provides a means for a class to advertise the bindings that it exposes.</p><p>In most cases you need to use <code>bind:toObject:withKeyPath:options:</code>, and then only when you establish bindings programatically. Use of the <code>unbind:</code> is discussed in <span class="content_text">“Unbinding.”</span> The other methods—the class method <code>exposeBinding:</code> and the instance methods <code>exposedBindings</code> and <code>valueClassForBinding:</code>—are useful only in an Interface Builder palette.</p><a name="//apple_ref/doc/uid/20002373-200965" title="NSEditor/NSEditorRegistration"></a><h3>NSEditor/NSEditorRegistration</h3><p>Together the NSEditorRegistration and NSEditor protocols allow views to notify a controller that an edit is underway and to ensure that any pending edits are committed as and when necessary.</p><p>The NSEditorRegistration informal protocol is implemented by controllers to provide an interface for a view—the editor—to inform the controller when it has uncommitted changes. When an edit is initiated, the view sends the controller an <code>objectDidBeginEditing:</code> message. When the edit is complete (for example when the user presses Return) the view sends an <code>objectDidEndEditing:</code> message.</p><p>The controller is responsible for tracking which editors have uncommitted changes and requesting that they commit or discard any pending edits when appropriate—for example, if the user closes the window or quits the application. The request takes the form of a <code>commitEditing</code> or <code>discardEditing</code> message, defined by the NSEditor informal protocol. NSController provides an implementation of this protocol, as do the Application Kit user interface elements that support binding.</p><a name="//apple_ref/doc/uid/20002373-193029" title="Key-Value Coding"></a><h3>Key-Value Coding</h3><p>Key-value coding (KVC) provides a unified way to access an object’s properties by name (key) without requiring use of custom accessor methods. The NSKeyValueCoding protocol specifies among others two methods, <code>valueForKey:</code> and <code>setValue:forKey:</code>, that give access to an object’s property with a specified name. In addition, the methods <code>setValue:forKeyPath:</code> and <code>valueForKeyPath:</code> give access to properties across relationships using key paths of the form <em>relationship.property</em>, for example, <code>content.lastName</code>.</p><p>A binding for a given property specifies an object and a key path to a property of that object. Given this information, the bound object can use key-value coding—specifically <code>setValue:forKeyPath:</code>—to update the object to which it is bound without having to hard-code an accessor method, as illustrated in <span class="content_text">Figure 4</span>.</p><br/><div><a name="//apple_ref/doc/uid/20002373-193510-BAJFEAAJ" title="Figure 4Key-value coding in Cocoa bindings"></a><p><a name="//apple_ref/doc/uid/20002373-193510" title="Figure 4Key-value coding in Cocoa bindings"></a><strong>Figure 4&nbsp;&nbsp;</strong>Key-value coding in Cocoa bindings</p><img src = "../art/joystick_kvc_update.gif" alt = "" width="507" height="220"></div><br/><p>Since Cocoa bindings rely on KVC, your model and controller objects must be KVC-compliant for other objects to be able to bind to them. To support KVC you simply have to follow a set of conventions for naming your accessor methods, briefly summarized here:</p><ul class="spaceabove"><li class="li"><p>For an attribute or to-one relationship named <code>&lt;key></code>, implement methods named <code>&lt;key></code> and, if the attribute is read-write, <code>set&lt;Key></code>:—the case is important.</p></li><li class="li"><p>For a to-many relationship implement either a method named <code>&lt;key></code> or both <code>countOf&lt;Key></code> and <code>objectIn&lt;Key>AtIndex:</code>. The latter pair is useful if the related objects are not stored in an array. It is up to you to retrieve an appropriate value for the specified index—it does not matter how the value is derived. For a mutable to-many relationship, you should also implement either <code>set&lt;Key></code> (if you implemented <code>&lt;key></code>) or <code>insertObject:in&lt;Key>AtIndex:</code> and <code>removeObjectFrom&lt;Key>AtIndex:</code>.</p></li></ul><p>For full details of all the methods declared by the NSKeyValueCoding protocol, see <em><a href="../../KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_top">Key-Value Coding Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/20002373-193146" title="Key-Value Observing"></a><h3>Key-Value Observing</h3><p>KVO is a mechanism that allows an object to register to receive notifications of changes to values in other objects.  To register, an observer sends the object it wants to observe an <code>addObserver:forKeyPath:options:context:</code> message that specifies:</p><ul class="spaceabove"><li class="li"><p>The object that is observing (very often <code>self</code>)</p></li><li class="li"><p>The key path to observe (for example, <code>selection.name</code>)</p></li><li class="li"><p>What information will be sent on notification (for example, old value and new value)</p></li><li class="li"><p>Optionally, contextual information to be sent back on notification (for example, a flag to indicate what binding is being affected)</p></li></ul><p>An observed object communicates changes directly to observers by sending them an <code>observeValueForKeyPath:ofObject:change:context:</code> message (defined by the NSKeyValueObserving informal protocol)—there is no independent notifier object akin to NSNotificationCenter.  <span class="content_text">Figure 5</span> illustrates how a change to a model value (the shadow angle) is communicated to views using KVO.</p><br/><div><a name="//apple_ref/doc/uid/20002373-193556-BAJBJJGC" title="Figure 5Key-value observing in Cocoa bindings"></a><p><a name="//apple_ref/doc/uid/20002373-193556" title="Figure 5Key-value observing in Cocoa bindings"></a><strong>Figure 5&nbsp;&nbsp;</strong>Key-value observing in Cocoa bindings</p><img src = "../art/joystick_kvo_update.gif" alt = "" width="525" height="213"></div><br/><p>The message is sent to observers for every change to an observed property, independently of how the change was triggered. (Note that the protocol itself makes no assumptions about what the observer actually does with the information.)</p><p>One other important aspect of KVO is that you can register the value of a key as being dependent on the value of one or more others. A change in the value associated with one of the “master” keys triggers a change notification for the dependent key’s value. For example, the drawing bounds of a graphic object may be dependent on the offset and angle of the associated shadow. If either of those values changes, any objects observing the drawing bounds must be notified.</p><p>The main requirement to make use of KVO is that your model objects be KVO-compliant. In most cases this actually  requires no effort—the runtime system adds support automatically. By default, all invocations of KVC methods result in observer notifications. You can also implement manual support—see <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em> for more details.</p><a name="//apple_ref/doc/uid/20002373-205973" title="Unbinding"></a><a name="//apple_ref/doc/uid/20002373-205973-BCIFDBIC" title="Unbinding"></a><h3>Unbinding</h3><p>Typically the only reason you would explicitly unbind an object is if you modify the user interface programatically and want to remove a binding. If you change an objects binding’s values it should first clear any preexisting values.</p><p>If you implement a custom view or controller with custom bindings, you should ensure that it clears any bindings before it is deallocated—in particular it should release any objects that were retained for the specified binding in the <code>bind:toObject:withKeyPath:options:</code> method and should deregister as an observer of any objects for which it registered as an observer. It may be convenient to implement this logic in an <code>unbind:</code> method that you then call as the first step in <code>dealloc</code>.</p><a name="//apple_ref/doc/uid/20002373-194182" title="Bindings in More Detail"></a><h2>Bindings in More Detail</h2><p>This section examines bindings in more detail. It decomposes—from the perspective of a custom view, a joystick—what happens when a binding is established. This serves two purposes: it makes explicit what code is involved in establishing a binding and responding to changes, and it gives a conceptual overview of how to create your own bindings-enabled views.</p><p>A binding specifies what aspect of one object should be bound to what property in another, such that a change in either is reflected in the other. For a given binding, an object therefore records the target object for the binding, the associated key path, and any options that were specified.</p><p>You can establish bindings easily in Interface Builder using the Bindings pane of the Info window. In Interface Builder, the <code>angle</code> binding for a joystick that displays the offset and angle of graphics object’s shadow might look like <span class="content_text">Figure 6</span>.</p><br/><div><a name="//apple_ref/doc/uid/20002373-196684-BAJBBGFE" title="Figure 6Bindings for a joystick&acirc;&#128;&#153;s angle in Interface Builder"></a><p><a name="//apple_ref/doc/uid/20002373-196684" title="Figure 6Bindings for a joystick&acirc;&#128;&#153;s angle in Interface Builder"></a><strong>Figure 6&nbsp;&nbsp;</strong>Bindings for a joystick’s angle in Interface Builder</p><img src = "../art/joystick_ib_inspector.gif" alt = "" width="349" height="267"></div><br/><p>Establishing this binding in Interface Builder is equivalent to programatically sending this message to the joystick:</p><div class="codesample"><table><tr><td scope="row"><pre>[joystick bind:@"angle" toObject:GraphicController withKeyPath:@"selection.shadowAngle" options:options];<span></span></pre></td></tr></table></div><p>The arguments have the following meanings:</p><dl class="termdef">	<dl class="content_text"><b><i class="mono"></em><code>@"angle"</code></b><dd><p>Identifies an attribute whose value can be bound to the value of a property in another object. Note that the binding name need not necessarily correspond to the name of an actual instance variable.</p></dd></dl><dl class="content_text"><b><i class="mono"></em><code>GraphicController</code></b><dd><p>The object containing the bound-to property.</p></dd></dl><dl class="content_text"><b><i class="mono"></em><code>@"selection.shadowAngle"</code></b><dd><p>The key path that identifies the bound-to property.</p></dd></dl><dl class="content_text"><b><i class="mono"></em><code>options</code></b><dd><p>A dictionary that specifies any options such as placeholders, or in this case, a value transformer.</p></dd></dl></dl><p>The information defined by the arguments can be stored in the bound object (in this case the joystick) as instance variables, as discussed next.</p><p>This example, and those that follow, assume that the joystick is represented by the class Joystick with instance variables as defined in the interface shown in <span class="content_text">Listing 1</span>.</p><a name="//apple_ref/doc/uid/20002373-197511-BAJDEICI" title="Listing 1Interface for the Joystick class"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002373-197511" title="Listing 1Interface for the Joystick class"></a><strong>Listing 1&nbsp;&nbsp;</strong>Interface for the Joystick class</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Joystick : NSView<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float angle;<span></span></pre></td></tr><tr><td scope="row"><pre>    id observedObjectForAngle;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *observedKeyPathForAngle;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSValueTransformer *angleValueTransformer;<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In its <code>bind:toObject:withKeyPath:options:</code> method an object must as a minimum do the following:</p><ul class="ul"><li class="li"><p>Determine which binding is being set</p></li><li class="li"><p>Record what object it is being bound to using what keypath and with what options</p></li><li class="li"><p>Register as an observer of the keypath of the object to which it is bound so that it receives notification of changes</p></li></ul><p>The code sample in <span class="content_text">Listing 2</span> shows a partial implementation of Joystick’s <code>bind:toObject:withKeyPath:options:</code> method dealing with just the <code>angle</code> binding. </p><a name="//apple_ref/doc/uid/20002373-197206-BAJBBGFD" title="Listing 2Partial implementation of the bind:toObject:withKeyPath:options method for the Joystick class"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002373-197206" title="Listing 2Partial implementation of the bind:toObject:withKeyPath:options method for the Joystick class"></a><strong>Listing 2&nbsp;&nbsp;</strong>Partial implementation of the bind:toObject:withKeyPath:options method for the Joystick class</p><div class="codesample"><table><tr><td scope="row"><pre>static void *AngleBindingContext = (void *)@"JoystickAngle";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)bind:(NSString *)binding<span></span></pre></td></tr><tr><td scope="row"><pre> toObject:(id)observableObject<span></span></pre></td></tr><tr><td scope="row"><pre> withKeyPath:(NSString *)keyPath<span></span></pre></td></tr><tr><td scope="row"><pre> options:(NSDictionary *)options<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> // Observe the observableObject for changes -- note, pass binding identifier<span></span></pre></td></tr><tr><td scope="row"><pre> // as the context, so you get that back in observeValueForKeyPath:...<span></span></pre></td></tr><tr><td scope="row"><pre> // This way you can easily determine what needs to be updated.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ([binding isEqualToString:@"angle"])<span></span></pre></td></tr><tr><td scope="row"><pre> {<span></span></pre></td></tr><tr><td scope="row"><pre>    [observableObject addObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                   forKeyPath:keyPath<span></span></pre></td></tr><tr><td scope="row"><pre>                  options:0<span></span></pre></td></tr><tr><td scope="row"><pre>                  context:AngleBindingContext];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Register what object and what keypath are<span></span></pre></td></tr><tr><td scope="row"><pre>    // associated with this binding<span></span></pre></td></tr><tr><td scope="row"><pre>    observedObjectForAngle = [observableObject retain];<span></span></pre></td></tr><tr><td scope="row"><pre>    observedKeyPathForAngle = [keyPath copy];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Record the value transformer, if there is one<span></span></pre></td></tr><tr><td scope="row"><pre>    angleValueTransformer = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *vtName = [options objectForKey:@"NSValueTransformerName"];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (vtName != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        angleValueTransformer = [NSValueTransformer<span></span></pre></td></tr><tr><td scope="row"><pre>            valueTransformerForName:vtName];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> }<span></span></pre></td></tr><tr><td scope="row"><pre> // Implementation continues...<span></span></pre></td></tr></table></div><p>This partial implementation does not record binding options other than a value transformer (although it may simply be that the binding does not allow for them). It nevertheless illustrates the basic principles of establishing a binding. Notice in particular the contextual information passed in the <code>addObserver:forKeyPath:options:context:</code> message; this is returned in the <code>observeValueForKeyPath:ofObject:change:context:</code> method and can be used to determine which binding is affected by the value update.</p><a name="//apple_ref/doc/uid/20002373-196748" title="Responding to Changes"></a><h2>Responding to Changes</h2><p>As noted earlier, there are two aspects to change management—responding to view-initiated changes that must be propagated ultimately to the model, and responding to model-initiated changes that must be reflected in the view. This section illustrates both, and shows how KVC and KVO play their parts.</p><a name="//apple_ref/doc/uid/20002373-196757" title="View-Initiated Updates"></a><h3>View-Initiated Updates</h3><p>Recall that the joystick was bound to the controller with the following method:</p><div class="codesample"><table><tr><td scope="row"><pre>[joystick bind:@"angle" toObject:GraphicController withKeyPath:@"selection.shadowAngle" options:options];<span></span></pre></td></tr></table></div><p>From the perspective of view-initiated updates the method can be interpreted as follows:</p><dl class="termdef">	<dl class="content_text"><b><code>bind: @"angle"</code></b><dd><p>If whatever is associated with <code>angle</code> changes,</p></dd></dl></dl><dl class="termdef">	<dl class="content_text"><b><code>toObject: GraphicController</code></b><dd><p>tell the specified object (GraphicController) that</p></dd></dl></dl><dl class="termdef">	<dl class="content_text"><b><code>withKeyPath: @"selection.shadowAngle"</code></b><dd><p>the value of its (the GraphicController’s) <code>selection.shadowAngle</code> has changed</p></dd></dl></dl><dl class="termdef">	<dl class="content_text"><b><code>options: options</code></b><dd><p>using any of these options that may be appropriate.</p></dd></dl></dl><p>If the value associated with <code>angle</code> changes—typically when a user clicks or drags the mouse within the view—the joystick should pass the new value to the controller using KVC, as illustrated in <span class="content_text">Figure 4</span>. The joystick should therefore respond to user input as follows:</p><ul class="spaceabove"><li class="li"><p>Determine new values for angle and offset</p></li><li class="li"><p>Update its own display as appropriate</p></li><li class="li"><p>Communicate new values to the controller to which it is bound</p></li></ul><p><span class="content_text">Listing 3</span> shows a partial implementation of an update method for the Joystick class. The excerpt deals just with the <code>angle</code> binding. It illustrates the use of key-value coding to communicate the new value (transformed by the value transformer if appropriate) to the observed object.</p><a name="//apple_ref/doc/uid/20002373-196846-BCIGBEAD" title="Listing 3Update method for the Joystick class"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002373-196846" title="Listing 3Update method for the Joystick class"></a><strong>Listing 3&nbsp;&nbsp;</strong>Update method for the Joystick class</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)updateForMouseEvent:(NSEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float newAngleDegrees;<span></span></pre></td></tr><tr><td scope="row"><pre>    // calculate newAngleDegrees...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self setAngle:newAngleDegrees];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (observedObjectForAngle != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSNumber *newControllerAngle = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (angleValueTransformer != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            newControllerAngle =<span></span></pre></td></tr><tr><td scope="row"><pre>                [angleValueTransformer reverseTransformedValue:<span></span></pre></td></tr><tr><td scope="row"><pre>                    [NSNumber numberWithFloat:newAngleDegrees]];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            newControllerAngle = [NSNumber numberWithFloat:newAngleDegrees];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        [observedObjectForAngle setValue: newControllerAngle<span></span></pre></td></tr><tr><td scope="row"><pre>                  forKeyPath: observedKeyPathForAngle];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that this example omits several important details, such as editor registration and checking that the value transformer allows reverse transformations.</p><a name="//apple_ref/doc/uid/20002373-204283" title="Model-Initiated Updates"></a><h3>Model-Initiated Updates</h3><p>Recall again that the joystick was bound to the controller with the following method:</p><div class="codesample"><table><tr><td scope="row"><pre>[joystick bind:@"angle" toObject:GraphicController withKeyPath:@"selection.shadowAngle" options:options];<span></span></pre></td></tr></table></div><p>From the perspective of model-initiated updates the method can be interpreted as follows:</p><dl class="termdef">	<dl class="content_text"><b><code>toObject: GraphicController</code></b><dd><p>If the GraphicController’s</p></dd></dl><dl class="content_text"><b><code>withKeyPath:@"selection.shadowAngle"</code></b><dd><p><code>selection.shadowAngle</code> changes</p></dd></dl><dl class="content_text"><b><code>bind:@"angle"</code></b><dd><p>update whatever is associated with the exposed <code>angle</code> key</p></dd></dl><dl class="content_text"><b><code>options:options</code></b><dd><p>using the options specified (for example, using a value transformer).</p></dd></dl></dl><p>The receiver therefore registered as an observer of the specified object’s key path (<code>selection.shadowAngle</code>) in its <code>bind:toObject:withKeyPath:options:</code> method, as was shown in <span class="content_text">Listing 2</span>. Observed objects notify their observers by sending them an <code>observeValueForKeyPath:ofObject:change:context:</code> message. <span class="content_text">Listing 4</span> shows a partial implementation for the Joystick class for handling the observer notifications that result. </p><p>The fundamental requirement of the <code>observeValueForKeyPath:ofObject:change:context:</code> method is that the value associated with the relevant attribute is updated. This excerpt also shows how it can capture placeholder information that might be used in the display method to give visual feedback to the user, in this case using an instance variable that indicates that for some reason the angle is “bad.”</p><a name="//apple_ref/doc/uid/20002373-205923-BCIEDFFG" title="Listing 4Observing method for the Joystick class"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002373-205923" title="Listing 4Observing method for the Joystick class"></a><strong>Listing 4&nbsp;&nbsp;</strong>Observing method for the Joystick class</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)observeValueForKeyPath:(NSString *)keyPath<span></span></pre></td></tr><tr><td scope="row"><pre>              ofObject:(id)object<span></span></pre></td></tr><tr><td scope="row"><pre>            change:(NSDictionary *)change<span></span></pre></td></tr><tr><td scope="row"><pre>               context:(void *)context<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // You passed the binding identifier as the context when registering<span></span></pre></td></tr><tr><td scope="row"><pre>    // as an observer--use that to decide what to update...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (context == AngleObservationContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        id newAngle = [observedObjectForAngle<span></span></pre></td></tr><tr><td scope="row"><pre>            valueForKeyPath:observedKeyPathForAngle];<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((newAngle == NSNoSelectionMarker) ||<span></span></pre></td></tr><tr><td scope="row"><pre>            (newAngle == NSNotApplicableMarker) ||<span></span></pre></td></tr><tr><td scope="row"><pre>            (newAngle == NSMultipleValuesMarker))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            badSelectionForAngle = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            badSelectionForAngle = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>            if (angleValueTransformer != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                newAngle = [angleValueTransformer<span></span></pre></td></tr><tr><td scope="row"><pre>                    transformedValue:newAngle];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            [self setValue:newAngle forKey:@"angle"];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplay:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In most controls the display method alters the visual representation depending on the current selection.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="WhatAreBindings.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="CntrlContent.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaBindings/Concepts/HowDoBindingsWork.html%3Fid%3D10000167i-5.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaBindings/Concepts/HowDoBindingsWork.html%3Fid%3D10000167i-5.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaBindings/Concepts/HowDoBindingsWork.html%3Fid%3D10000167i-5.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
