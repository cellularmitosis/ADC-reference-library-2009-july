<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Secure Coding Guide: Elevating Privileges Safely</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Elevating Privileges Safely"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002589" title="Elevating Privileges Safely"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000434" target="_top">Security</a> &gt; <a href="../index.html" target="_top">Secure Coding Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="RaceConditions.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="AppInterfaces.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002589-SW1" title="Elevating Privileges Safely"></a><hr /><H1>Elevating Privileges Safely</H1><p> Running code with root or administrative <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_15"></a>privileges can intensify the dangers posed by security vulnerabilities. This article explains why that is so, suggests techniques you can use to avoid elevating privileges, and describes the safest techniques for elevating privileges when it can't be avoided.  </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW11">Circumstances Requiring Elevated Privileges</a>
				
			<br/>
			
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW6">The Hostile Environment and the Principle of Least Privilege</a>
				
			<br/>
			
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW9">Avoiding Elevated Privileges</a>
				
			<br/>
			
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW18">Running With Elevated Privileges</a>
				
			<br/>
			
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW3">Calls to Change Privilege Level</a>
				
			<br/>
			
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW19">Avoiding Forking Off a Privileged Process</a>
				
			<br/>
			
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW2">Factoring Applications</a>
				
			<br/>
			
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW22">Authorization and Trust Policies</a>
				
			<br/>
			
        
			
			
				<a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW23">Security in a KEXT</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002589-SW11" title="Circumstances Requiring Elevated Privileges"></a><h2>Circumstances Requiring Elevated Privileges</h2><p>Regardless of whether a user is logged in as an administrator, a program might have to obtain administrative or root privileges in order to accomplish a task. Examples of tasks that require <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_16"></a>elevated <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_17"></a>privileges include:</p><ul class="ul"><li class="li"><p>manipulating file permissions, ownership</p></li><li class="li"><p>creating, reading, updating, or deleting system and user files</p></li><li class="li"><p>opening privileged ports (those with port numbers less than 1024) for TCP and UDP connections</p></li><li class="li"><p>opening raw sockets</p></li><li class="li"><p>managing processes</p></li><li class="li"><p>reading the contents of virtual memory</p></li><li class="li"><p>changing system settings </p></li><li class="li"><p>loading kernel extensions</p></li></ul><p>If you have to perform a task that requires elevated privileges, you must be aware of the fact that running with elevated privileges means that if there are any security vulnerabilities in your program, an attacker can obtain elevated privileges as well, and would then be able to perform any of the operations listed above.</p><a name="//apple_ref/doc/uid/TP40002589-SW6" title="The Hostile Environment and the Principle of Least Privilege"></a><h2>The Hostile Environment and the Principle of Least Privilege</h2><p>As discussed in <span class="content_text"><a href="SecLandscape.html#//apple_ref/doc/uid/TP40002489-SW3">“The Security Landscape,”</a></span> any program can come under attack, and probably will. By default, every process runs with the privileges of the user or process that started it. Therefore, if a user has logged on with restricted <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_18"></a><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_19"></a>privileges, your program should run with those restricted privileges. This effectively limits the amount of damage an attacker can do, even if he successfully hijacks your program into running malicious code. Do not assume that the user is logged in with administrator privileges; you should be prepared to run a helper application with elevated privileges if you need them to accomplish a task. However, keep in mind that, if you elevate your process' privileges to run as root, an attacker can gain those elevated privileges and potentially take over control of the whole system. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002589-SW12" title="Note"></a><p><strong>Note:</strong>&nbsp;Although in certain circumstances it’s possible to mount a remote attack over a network, for the most part the vulnerabilities discussed here involve malicious code running locally on the target computer. </p></div><p>If an attacker uses a buffer overflow or other security vulnerability (see <span class="content_text"><a href="TypesSecVuln.html#//apple_ref/doc/uid/TP40002529-SW2">“Types of Security Vulnerabilities”</a></span>) to execute code on someone else's computer, they can generally run their code with whatever privileges the logged-in user has. If an attacker can gain administrator privileges, they can elevate to root privileges and gain access to any data on the user's computer. Therefore, it is good security practice to log in as an administrator only when performing the rare tasks that require admin privileges. Because the default setting for Mac OS X is to make the computer's owner an administrator, you should encourage your users to create a separate non-admin login and to use that for their everyday work. In addition, if possible, you should not require admin privileges to install your software.</p><p>The idea of limiting risk by limiting access goes back to the "need to know" policy followed by government security agencies (no matter what your security clearance, you are not given access to information unless you have a specific need to know that information). In software security, this policy is often termed "the principle of least privilege," first formally stated in 1975: “Every program and every user of the system should operate using the least set of privileges necessary to complete the job.” (Saltzer, J.H. AND Schroeder, M.D., "The Protection of Information in Computer Systems," <em>Proceedings of the IEEE</em>, vol. 63, no. 9, Sept 1975.) </p><p>In practical terms, the principle of least privilege means you should avoid running as root, or—if you absolutely must run as root to perform some task—you should run a separate helper application to perform the privileged task (see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW2">“Factoring Applications”</a></span>). By running with the least privilege possible, you:</p><ul class="ul"><li class="li"><p>Limit damage from accidents and errors, including maliciously introduced accidents and errors</p></li><li class="li"><p>Reduce interactions of privileged components, and therefore reduce unintentional, unwanted, and improper uses of privilege (side effects)</p></li></ul><p>Keep in mind that, even if your code is free of errors, vulnerabilities in any libraries your code links in can be used to attack your program. For example, no program with a graphical user interface should run with privileges because the large number of libraries used in any GUI application makes it virtually impossible to guarantee that the application has no security vulnerabilities.</p><p>There are a number of ways an attacker can take advantage of your program if you run as root. Some possible approaches are described in the following sections.</p><a name="//apple_ref/doc/uid/TP40002589-SW13" title="Launching a New Process"></a><h3>Launching a New Process</h3><p>Because any new process runs with the privileges of the process that launched it, if an attacker can trick your process into launching his code, the malicious code runs with the privileges of your process. Therefore, if your process is running with root privileges and is vulnerable to attack, the attacker can gain control of the system. There are many ways an attacker can trick your code into launching malicious code, including buffer overflows, race conditions, and social engineering attacks (see <span class="content_text"><a href="TypesSecVuln.html#//apple_ref/doc/uid/TP40002529-SW2">“Types of Security Vulnerabilities”</a></span>).</p><a name="//apple_ref/doc/uid/TP40002589-SW14" title="Executing Command-Line Arguments"></a><h3>Executing Command-Line Arguments</h3><p>Because all <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_20"></a>command-line <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_21"></a>arguments, including the program name (<code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_22"></a>argv(0)</code>), are under the control of the user, you should not use the command line to execute any program without validating every parameter, including the name. If you use the command line to re-execute your own code or execute a helper program, for example, a malicious user might have substituted his own code with that program name, which you are now executing with your privileges.</p><a name="//apple_ref/doc/uid/TP40002589-SW10" title="Inheriting File Descriptors"></a><h3>Inheriting File Descriptors</h3><p>When you create a new process, the child process inherits its own copy of the parent process' <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_23"></a>file descriptors (see the manual page for <code>fork(2)</code>). Therefore, if you have a handle on a file, network socket, shared memory, or other resource that's pointed to by a file descriptor and you fork off a child process, you must be careful to either close the file descriptor or you must make sure that the child process cannot be tampered with. Otherwise, a malicious user can use the subprocess to tamper with the resources referenced by the file descriptors. </p><p>For example, if you open a password file and don’t close it before forking a process, the new subprocess has access to the password file. </p><p>To set a file descriptor so that it closes automatically when you execute a new process (such as by using the <code>execve</code> system call), use the <code>fcntl(2)</code> command to set the close-on-exec flag. You must set this flag individually for each file descriptor; there’s no way to set it for all.</p><a name="//apple_ref/doc/uid/TP40002589-SW15" title="Abusing Environmental Variables"></a><h3>Abusing Environmental Variables</h3><p>Most libraries and utilities use <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_24"></a>environmental variables. Sometimes environmental variables can be attacked with buffer overflows or by inserting inappropriate values. If your program links in any libraries or calls any utilities, your program is vulnerable to attacks through any such problematic environmental variables. If your program is running as root, the attacker might be able to bring down or gain control of the whole system in this way. Examples of environmental variables in utilities and libraries that have been attacked in the past include:</p><ol class="ol"><li class="li"><p>The dynamic loader: <code>LD_LIBRARY_PATH</code>, <code>DYLD_LIBRARY_PATH</code> are often misused, causing unwanted side effects.</p></li><li class="li"><p>libc: <code>MallocLogFile</code> ); </p></li><li class="li"><p>Core Foundation: <code>CF_CHARSET_PATH</code> </p></li><li class="li"><p>perl: <code>PERLLIB</code>,<code>PERL5LIB</code>, <code>PERL5OPT</code></p><p>[<sup>2</sup>CVE-2005-2748 (corrected in Apple Security Update 2005-008) <sup>3</sup>CVE-2005-0716 (corrected in Apple Security Update 2005-003) <sup>4</sup>CVE-2005-4158]</p></li></ol><p>Environmental variables are also inherited by child processes. If you fork off a child process, your parent process should validate the values of all environmental variables before it uses them in case they were altered by the child process (whether inadvertently or through an attack by a malicious user).</p><a name="//apple_ref/doc/uid/TP40002589-SW16" title="Modifying Process Limits"></a><h3>Modifying Process Limits</h3><p>You can use the <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_25"></a>setrlimit</code> call to limit the consumption of system resources by a process. For example, you can set the largest size of file the process can create, the maximum amount of CPU time the process can consume, and the maximum amount of physical memory a process may use. These <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_26"></a>process limits are inherited by child processes.</p><p>In order to prevent an attacker from taking advantage of open file descriptors, programs that run with elevated privileges often close all open file descriptors when they start up. However, if an attacker can use <code>setrlimit</code> to alter the file descriptor limit, he can fool the program into leaving some of the files open. Those files are then vulnerable.</p><p>Similarly, a vulnerability was reported for a version of Linux that made it possible for an attacker, by decreasing the maximum file size, to limit the size of the <code>/etc/passwd</code> and <code>/etc/shadow</code> files. Then, the next time a utility accessed one of these files, it truncated the file, resulting in a loss of data and denial of service. [CVE-2002-0762]</p><a name="//apple_ref/doc/uid/TP40002589-SW17" title="File Operation Interference"></a><h3>File Operation Interference</h3><p>If you’re running with elevated privileges in order to write or read files in a world-writable directory or a user’s directory, you must be aware of time-of-check–time-of-use problems; see <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW2">“Time Of Check–Time Of Use.”</a></span></p><a name="//apple_ref/doc/uid/TP40002589-SW9" title="Avoiding Elevated Privileges"></a><h2>Avoiding Elevated Privileges</h2><p>In many cases, you can accomplish your task without needing elevated privileges. For example, suppose you need to configure the environment (add a configuration file to the user's home directory or modify a configuration file in the user's home directory) for your application. You can do this from an <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_27"></a>installer running as root (the <code>installer</code> command requires administrative privileges; see the manual page for <code>installer(8)</code>). However, if you have the application configure itself, or check whether configuration is needed when it starts up, then you don't need to run as root at all.</p><p>An example of using an alternate design in order to avoid running with elevated privileges is given by the BSD <code>ps</code> command, which displays information about processes that have controlling terminals. Originally, BSD used the <code>setgid</code> bit to run the <code>ps</code> command with a group ID of <code>kmem</code>, which gave it privileges to read kernel memory. More recent implementations of the <code>ps</code> command use the <code>sysctl</code> utility to read the information it needs, removing the requirement that <code>ps</code> run with any special privileges.</p><a name="//apple_ref/doc/uid/TP40002589-SW18" title="Running With Elevated Privileges"></a><h2>Running With Elevated Privileges</h2><p>If you do need to run code with elevated privileges, there are several approaches you can take:</p><ul class="ul"><li class="li"><p>You can use a BSD system call to change privilege level (see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW3">“Calls to Change Privilege Level”</a></span>). These commands have confusing semantics. You must be careful to use them correctly, and it's very important to check the return values of these calls to make sure they succeeded.</p></li><li class="li"><p>You can run a daemon with elevated privileges that you call on when you need to perform a privileged task. The preferred method of launching a daemon is to use the <code>launchd</code> daemon (see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW4">“launchd”</a></span>). It is easier to use <code>launchd</code> to launch a daemon and easier to communicate with a daemon than it is to fork your own privileged process.  </p></li><li class="li"><p>You can use the <code>authopen</code> command to read, create, or update a file (see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW5">“authopen”</a></span>).</p></li><li class="li"><p>You can set the <code>setuid</code> and <code>setgid</code> bits for the executable file of your code, and set the owner and group of the file to the privilege level you need; for example, you can set the owner to <code>root</code> and the group to <code>wheel</code>. Then when the code is executed, it runs with the elevated privileges of its owner and group rather than with the privileges of the process that executed it. (See the "Permissions" section in the <span class="content_text"><a href="../../Security_Overview/Concepts/Concepts.html#//apple_ref/doc/uid/TP30000976-CH203" target="_top">Security Concepts</a></span> chapter in <em><a href="../../Security_Overview/index.html#//apple_ref/doc/uid/TP30000976" target="_top">Security Overview</a></em>.)This technique is often used to execute the privileged code in a factored application (see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW2">“Factoring Applications”</a></span>). As with other privileged code, you must be very sure that there are no vulnerabilities in your code and that you don't link in any libraries or call any utilities that have vulnerabilities.</p><p>If you fork off a privileged process, you should terminate it as soon as it has accomplished its task (see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW2">“Factoring Applications”</a></span>). Although architecturally this is often the best solution, it is very difficult to do correctly, especially the first time you try. Unless you have a lot of experience with forking off privileged processes, you might want to try one of the other solutions first.</p></li></ul><a name="//apple_ref/doc/uid/TP40002589-SW3" title="Calls to Change Privilege Level"></a><h2>Calls to Change Privilege Level</h2><p>There are several commands you can use to change the <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_28"></a>privilege level of a program. The semantics of these commands are tricky, and vary depending on the operating system on which they're used.  </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_7" title="Important:"></a><p><strong>Important:</strong>&nbsp;If you are running with both a <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_29"></a>group ID (<a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_30"></a>GID) and <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_31"></a>user ID (<a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_32"></a>UID) that are different from those of the user, you have to drop the GID before dropping the UID. Once you've changed the UID, you may no longer have sufficient privileges to change the GID. </p><p></p></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_8" title="Important:"></a><p><strong>Important:</strong>&nbsp;As with every security-related operation, you must check the return values of your calls to <code>setuid</code>, <code>setgid</code>, and related routines to make sure they succeeded. Otherwise you might still be running with elevated privileges when you think you have dropped privileges.</p><p></p></div><p>For more information on permissions, see the "Permissions" section in the <span class="content_text"><a href="../../Security_Overview/Concepts/Concepts.html#//apple_ref/doc/uid/TP30000976-CH203" target="_top">Security Concepts</a></span> chapter in <em><a href="../../Security_Overview/index.html#//apple_ref/doc/uid/TP30000976" target="_top">Security Overview</a></em>. For information on <code>setuid</code> and related commands, see <em>Setuid Demystified</em> by Chen, Wagner, and Dean (Proceedings of the 11th USENIX Security Symposium, 2002), available at <span class="content_text"><a href="http://www.usenix.org/publications/library/proceedings/sec02/full_papers/chen/chen.pdf" target="_blank">http://www.usenix.org/publications/library/proceedings/sec02/full_papers/chen/chen.pdf</a></span> and the manual pages for <code>setuid(2)</code>, <code>setreuid(2)</code>, <code>setregid(2)</code>, and <code>setgroups(2)</code>. (The <code>setuid(2)</code> manual page includes information about <code>seteuid</code>, <code>setgid</code>, and <code>setegid</code> as well.</p><p>Here are some notes on the most commonly used system calls for changing privilege level:</p><ul class="ul"><li class="li"><p>The <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_33"></a>setuid</code> function sets the real and effective user IDs and the saved user ID of the current process to a specified value. The <code>setuid</code> function is the most confusing of the UID-setting system calls. Not only does the permission required to use this call differ among different UNIX-based systems, but the action of the call differs among different operating systems and even between privileged and unprivileged processes.  If you are trying to set the effective UID, you should use the <code>seteuid</code> function instead.</p></li><li class="li"><p>The <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_34"></a>setreuid</code> function modifies the real UID and effective UID, and in some cases, the saved UID. The permission required to use this call differs among different UNIX-based systems, and the rule by which the saved UID is modified is complicated. For this function as well, if your intent is to set the effective UID, you should use the <code>seteuid</code> function instead.</p></li><li class="li"><p>The <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_35"></a>seteuid</code> function sets the effective UID, leaving the real UID and saved UID unchanged. In Mac OS X, the effective user ID may be set to the value of the real user ID or of the saved set-user-ID. (In some UNIX-based systems, this function allows you to set the EUID to any of the real UID, saved UID, or EUID.) Of the functions available on Mac OS X that set the effective UID, the <code>seteuid</code> function is the least confusing and the least likely to be misused.</p></li><li class="li"><p>The <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_36"></a>setgid</code> function acts similarly to the <code>setuid</code> function, except that it sets group IDs rather than user IDs. It suffers from the same shortcomings as the <em>setuid</em> function; use the <code>setegid</code> function instead.  </p></li><li class="li"><p>The <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_37"></a>setregid</code> function acts similarly to the <code>setregid</code> function, with the same shortcomings; use the <code>setegid</code> function instead. </p></li><li class="li"><p>The <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_38"></a>setegid</code> function sets the effective GID. This function is the preferred call to use if you want to set the EGID. </p></li></ul><a name="//apple_ref/doc/uid/TP40002589-SW19" title="Avoiding Forking Off a Privileged Process"></a><h2>Avoiding Forking Off a Privileged Process</h2><p>There are a couple of functions you might be able to use to avoid forking off a privileged helper application: The <code>authopen</code> function lets you obtain temporary rights to create, read, or update a file. You can call the <code>launchd</code> command to start a process with specified privileges and a known environment. </p><a name="//apple_ref/doc/uid/TP40002589-SW5" title="authopen"></a><h3>authopen</h3><p>When you call the <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_39"></a>authopen</code> function, you provide the pathname of the file that you want to access. There are options for reading the file, writing to the file, and creating a new file. Before carrying out any of these operations, the <code>authopen</code> function requests authorization from the system security daemon, which authenticates the user (through a password dialog or other means) and determines whether the user has sufficient rights to carry out the operation. See the manual page for <code>authopen(1)</code> for the syntax of this command.</p><a name="//apple_ref/doc/uid/TP40002589-SW4" title="launchd"></a><h3>launchd</h3><p>Starting with Mac OS X v10.4, the <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_40"></a>launchd</code> daemon is used to launch daemons and other programs automatically, without user intervention. (For systems running versions of the OS earlier than Mac OS X v10.4, you can use the standard BSD routine <code><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_41"></a>mach_init</code> for this purpose.) The <code>launchd</code> daemon launches <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_42"></a>daemons on a per-user basis and can restart daemons after they quit if they are needed. You provide a configuration file that tells <code>launchd</code> the level of privilege with which to launch your routine. You can use <code>launchd</code> to launch a privileged helper daemon rather than factoring your application into privileged and unprivileged processes. Be sure that you do not request higher privilege than you actually need, and to drop privilege or quit execution as soon as possible. </p><p>There are several reasons to use <code>launchd</code> in preference to writing a factored application that forks off a privileged process:</p><ul class="spaceabove"><li class="li"><p>Because <code>launchd</code> can launch a routine with elevated privileges, you do not have to set the setuid or setgid bits for the helper tool. Any routine that has the setuid or setgid bit set is likely to be a target for attack by malicious users.</p></li><li class="li"><p>A privileged routine started by <code>launchd</code> runs in a controlled environment that can't be tampered with. If you launch a helper tool that has the setuid bit set, it inherits numerous environmental factors from the launching application, including file descriptors, environmental variables, resource limits, command-line arguments, and several others. It is much safer to use <code>launchd</code>, which completely controls the launch environment.</p></li><li class="li"><p>It’s much easier to understand and verify the security of a protocol between your controlling application and a privileged daemon than to handle the interprocess communication needed for a process you forked yourself. When you fork a process it inherits its environment from your application, including file descriptors and environmental variables, which might be used to attack the process (see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW6">“The Hostile Environment and the Principle of Least Privilege”</a></span>). In addition, an attacker might be able to use a debugger to intercept your interprocess communications or find other ways to attack your privileged process. You can avoid all these problems by using <code>launchd</code> to launch a daemon.</p></li><li class="li"><p>It's easier to write a daemon and launch it with launchd than to write factored code and fork off a separate process.</p></li><li class="li"><p>Because <code>launchd</code> is a critical system component, it receives a lot of peer review by in-house developers at Apple. It is less likely to contain security vulnerabilities than most production code.</p></li> </ul><p>For more information on <code>launchd</code>, see the manual pages for <code>launchd(8)</code>, <code>launchctl(1)</code>, and <code>launchd.plist(5)</code>, and <em>Getting Started with launchd</em> in <span class="content_text"><a href="http://developer.apple.com/macosx/" target="_top">http://developer.apple.com/macosx/</a></span>. For more information about mach_init, see <span class="content_text"><a href="../../../../MacOSX/Conceptual/BPSystemStartup/Articles/BootProcess.html#//apple_ref/doc/uid/20002130" target="_top">The Boot Process</a></span> in <em><a href="../../../../MacOSX/Conceptual/BPSystemStartup/index.html#//apple_ref/doc/uid/10000172i" target="_top">System Startup Programming Topics</a></em> and <span class="content_text"><a href="../../../../MacOSX/Conceptual/BPMultipleUsers/Concepts/SystemContexts.html#//apple_ref/doc/uid/20002208" target="_top">Root and Login Sessions</a></span> in <em><a href="../../../../MacOSX/Conceptual/BPMultipleUsers/index.html#//apple_ref/doc/uid/10000180i" target="_top">Multiple User Environments</a></em>. </p><a name="//apple_ref/doc/uid/TP40002589-SW2" title="Factoring Applications"></a><h2>Factoring Applications</h2><p>If you've read this far and you're still convinced you need to <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_43"></a>factor your <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_44"></a>application into privileged and nonprivileged processes, this section provides some tips and sample code. In addition, see <em><a href="../../authorization_concepts/index.html#//apple_ref/doc/uid/TP30000995" target="_top">Authorization Services Programming Guide</a></em> for more advice on the use of Authorization Services and the proper way to factor an application.</p><p>As explained in the Authorization Services documentation, it is very important that you check the user's rights to perform the privileged operation, both before and after launching your privileged helper tool. Your helper tool, owned by root and with the setuid bit set, has sufficient privileges to perform whatever task it has to do. However, if the user doesn't have the rights to perform this task, you shouldn't launch the tool and—if the tool gets launched anyway—the tool should quit without performing the task. Your nonprivileged process should first use Authorization Services to determine whether the user is authorized and to authenticate the user if necessary (this is called <em>preauthorizing</em>; see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW7">Listing 1</a></span>). Then launch your privileged process. The privileged process then should authorize the user again, before performing the task that requires elevated privileges; see <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW8">Listing 2</a></span>. As soon as the task is complete, the privileged process should terminate.</p><p>In determining whether a user has sufficient privileges to perform a task, you should use rights that you have defined and put into the <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_45"></a>policy database yourself. If you use a right provided by the system or by some other developer, the user might be granted authorization for that right by some other process, thus gaining privileges to your application or access to data that you did not authorize or intend. For more information about policies and the policy database, (see the section "The Policy Database" in the <span class="content_text"><a href="../../authorization_concepts/02authconcepts/authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205" target="_top">Authorization Concepts</a></span> chapter of <em><a href="../../authorization_concepts/index.html#//apple_ref/doc/uid/TP30000995" target="_top">Authorization Services Programming Guide</a></em>).</p><p>In the code samples shown here, the task that requires privilege is killing a process that the user does not own. </p><a name="//apple_ref/doc/uid/TP40002589-SW20" title="Example: Preauthorizing"></a><h3>Example: Preauthorizing</h3><p>If user tries to kill a process that he doesn’t own, the application has to make sure user is authorized to do so. The following numbered items correspond to comments in the code sample:</p><ol class="ol"><li class="li"><p>If the process is owned by the user, and the process is not the window server or the login window, go ahead and kill it.</p></li><li class="li"><p>Call the <code>permitWithRight</code> method to determine whether the user has the right to kill the process. The application must have previously added this right—in this example, called <code>com.apple.processkiller.kill</code>—to the policy database. The <code>permitWithRight</code> method handles the interaction with the user (such as an authentication dialog). If this method returns 0, it completed without an error and the user is considered preauthorized.</p></li><li class="li"><p>Obtain the authorization reference. </p></li><li class="li"><p>Create an external form of the authorization reference.</p></li><li class="li"><p>Create a data object containing the external authorization reference.</p></li><li class="li"><p>Pass this serialized authorization reference to the setuid tool that will kill the process (<span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW8">Listing 2</a></span>).</p></li></ol><a name="//apple_ref/doc/uid/TP40002589-SW7" title="Listing 1Nonprivileged process"></a><p class="codesample"><strong>Listing 1&nbsp;&nbsp;</strong>Nonprivileged process</p><div class="codesample"><table><tr><td scope="row"><pre>if (ownerUID == _my_uid &amp;&amp; ![[contextInfo processName]<span></span></pre></td></tr><tr><td scope="row"><pre>        isEqualToString:@"WindowServer"] &amp;&amp; ![[contextInfo processName]<span></span></pre></td></tr><tr><td scope="row"><pre>        isEqualToString:@"loginwindow"]) {<span></span></pre></td></tr><tr><td scope="row"><pre>[self killPid:pid withSignal:signal];                                      <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>SFAuthorization *auth = [SFAuthorization authorization];<span></span></pre></td></tr><tr><td scope="row"><pre>if (![auth permitWithRight:"com.apple.proccesskiller.kill" flags:<span></span></pre></td></tr><tr><td scope="row"><pre>        kAuthorizationFlagDefaults|kAuthorizationFlagInteractionAllowed|<span></span></pre></td></tr><tr><td scope="row"><pre>        kAuthorizationFlagExtendRights|kAuthorizationFlagPreAuthorize])    <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>AuthorizationRef authRef = [auth authorizationRef];                        <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>AuthorizationExternalForm authExtForm;<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = AuthorizationMakeExternalForm(authRef, &amp;authExtForm);    <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>if (errAuthorizationSuccess == status) {<span></span></pre></td></tr><tr><td scope="row"><pre>NSData *authData = [NSData dataWithBytes: authExtForm.bytes<span></span></pre></td></tr><tr><td scope="row"><pre>                             length: kAuthorizationExternalFormLength];    <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>[_agent killProcess:pid signal:signal authData: authData];                 <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The external tool is owned by root and has its setuid bit set so that it runs with root privileges. It imports the externalized authorization rights and checks the user's authorization rights again. If the user has the rights, the tool kills the process and quits. The following numbered items correspond to comments in the code sample:</p><ol class="ol"><li class="li"><p>Convert the external authorization reference to an authorization reference.</p></li><li class="li"><p>Create an authorization item array.</p></li><li class="li"><p>Create an authorization rights set.</p></li><li class="li"><p>Call the <code>AuthorizationCopyRights</code> function to determine whether the user has the right to kill the process. You pass this function the authorization reference. If the credentials issued by the Security Server when it authenticated the user have not yet expired, this function can determine whether the user is authorized to kill the process without reauthentication. If the credentials have expired, the Security Server handles the authentication (for example, by displaying a password dialog). (You specify the expiration period for the credentials when you add the authorization right to the policy database.) </p></li><li class="li"><p>If the user is authorized to do so, kill the process.</p></li><li class="li"><p>If the user is not authorized to kill the process, log the unsuccessful attempt.</p></li><li class="li"><p>Release the authorization reference.</p></li></ol><a name="//apple_ref/doc/uid/TP40002589-SW8" title="Listing 2Privileged process"></a><p class="codesample"><strong>Listing 2&nbsp;&nbsp;</strong>Privileged process</p><div class="codesample"><table><tr><td scope="row"><pre>AuthorizationRef authRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = AuthorizationCreateFromExternalForm(<span></span></pre></td></tr><tr><td scope="row"><pre>  (AuthorizationExternalForm *)[authData bytes], &amp;authRef);              <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>if ((errAuthorizationSuccess == status) &amp;&amp; (NULL != authRef)) {<span></span></pre></td></tr><tr><td scope="row"><pre>AuthorizationItem right = {"com.apple.proccesskiller.kill",<span></span></pre></td></tr><tr><td scope="row"><pre>                                                0L, NULL, 0L};           <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>AuthorizationItemSet rights = {1, &amp;right};                               <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>status = AuthorizationCopyRights(authRef, &amp;rights, NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>        kAuthorizationFlagDefaults | kAuthorizationFlagInteractionAllowed |<span></span></pre></td></tr><tr><td scope="row"><pre>        kAuthorizationFlagExtendRights,    NULL);                        <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>if (errAuthorizationSuccess == status)<span></span></pre></td></tr><tr><td scope="row"><pre>kill(pid, signal);                                                       <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>NSLog(@"Unauthorized attempt to signal process %d with %d",<span></span></pre></td></tr><tr><td scope="row"><pre>            pid, signal);                                                <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>AuthorizationFree(authRef, kAuthorizationFlagDefaults);                  <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002589-SW21" title="Helper Tool Cautions"></a><h3>Helper Tool Cautions</h3><p>If you write a privileged helper tool, you need to be very careful to examine your assumptions. For example, you should always check the results of function calls; it is dangerous to assume they succeeded and to proceed on that assumption. You must be careful to avoid any of the pitfalls discussed in this document, such as buffer overflows and race conditions. </p><p>If possible, avoid linking in any extra libraries. If you do have to link in a library, you must not only be sure that the library has no security vulnerabilities, but also that it doesn't link in any other libraries. Any dependencies on other code potentially open your code to attack.</p><p>In order to make your helper tool as secure as possible, you should make it as short as possible—have it do only the very minimum necessary and then quit. Keeping it short makes it less likely that you made mistakes, and makes it easier for others to audit your code. Be sure to get a security review from someone who did not help write the tool originally. An independent reviewer is less likely to share your assumptions and more likely to spot vulnerabilities that you missed.</p><a name="//apple_ref/doc/uid/TP40002589-SW22" title="Authorization and Trust Policies"></a><h2>Authorization and Trust Policies</h2><p>In addition to the basic permissions provided by BSD, the Mac OS X <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_46"></a>Authorization Services API enables you to use the policy database to determine whether an entity should have access to specific features or data within your application. Authorization Services includes functions to read, add, edit, and delete policy database items.</p><p>You should define your own trust policies and put them in the <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_47"></a>policy database. If you use a policy provided by the system or by some other developer, the user might be granted authorization for a right by some other process, thus gaining privileges to your application or access to data that you did not authorize or intend. Define a different policy for each operation to avoid having to give broad permissions to users who need only narrow privileges. For more information about policies and the policy database, (see the section "The Policy Database" in the <span class="content_text"><a href="../../authorization_concepts/02authconcepts/authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205" target="_top">Authorization Concepts</a></span> chapter of <em><a href="../../authorization_concepts/index.html#//apple_ref/doc/uid/TP30000995" target="_top">Authorization Services Programming Guide</a></em>). </p><p>Authorization Services does not enforce access controls; rather, it authenticates users and lets you know whether they have permission to carry out the action they wish to perform. It is up to your program to either deny the action or carry it out. </p><a name="//apple_ref/doc/uid/TP40002589-SW23" title="Security in a KEXT"></a><h2>Security in a KEXT</h2><p>Because <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_48"></a><a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_49"></a>kernel extensions have no user interface, you cannot call Authorization Services to obtain permissions that you do not already have. However, you can determine what permissions you have and evaluate access control lists (ACLs; see the section "ACLs" in the <a name="//apple_ref/doc/uid/TP40002589-DontLinkElementID_50"></a><span class="content_text"><a href="../../Security_Overview/Concepts/Concepts.html#//apple_ref/doc/uid/TP30000976-CH203" target="_top">Security Concepts</a></span> section of <em><a href="../../Security_Overview/index.html#//apple_ref/doc/uid/TP30000976" target="_top">Security Overview</a></em>). Starting in Mac OS X v10.4, you can use the Kernel Authorization (Kauth) subsystem to manage authorization. For more information on Kauth, see Technical Note TN2127, <em>Kernel Authorization</em> (<span class="content_text"><a href="http://developer.apple.com/technotes/tn2005/tn2127.html" target="_top">http://developer.apple.com/technotes/tn2005/tn2127.html</a></span>).</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="RaceConditions.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="AppInterfaces.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-05-23<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/AccessControl.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/AccessControl.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/AccessControl.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
