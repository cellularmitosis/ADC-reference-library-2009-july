<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DTSCPlusLibrary - /Sources/CollectionClasses.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">DTSCPlusLibrary</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DTSCPlusLibrary</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/CollectionClasses.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers/AppleEvent.h</option>
<option value="listing2.html">/Headers/Application.h</option>
<option value="listing3.html">/Headers/ApplicationResources.h</option>
<option value="listing4.html">/Headers/CollectionClasses.h</option>
<option value="listing5.html">/Headers/ColorPicker.h</option>
<option value="listing6.html">/Headers/DTSCPlusLibrary.h</option>
<option value="listing7.html">/Headers/Environment.h</option>
<option value="listing8.html">/Headers/FileClass.h</option>
<option value="listing9.html">/Headers/GDevice.h</option>
<option value="listing10.html">/Headers/GraphicsEnv.h</option>
<option value="listing11.html">/Headers/KeyMap.h</option>
<option value="listing12.html">/Headers/MemoryClass.h</option>
<option value="listing13.html">/Headers/Menu.h</option>
<option value="listing14.html">/Headers/Process.h</option>
<option value="listing15.html">/Headers/Random.h</option>
<option value="listing16.html">/Headers/SoundClass.h</option>
<option value="listing17.html">/Headers/SpinCursor.h</option>
<option value="listing18.html">/Headers/Template.h</option>
<option value="listing19.html">/Headers/Timer.h</option>
<option value="listing20.html">/Headers/Toolbox.h</option>
<option value="listing21.html">/Headers/Tracer.h</option>
<option value="listing22.html">/Headers/UserTermination.h</option>
<option value="listing23.html">/Headers/Volume.h</option>
<option value="listing24.html">/Headers/Window.h</option>
<option value="listing25.html">/Resources/GUIApplication.r</option>
<option value="listing26.html">/Resources/MemoryClass.r</option>
<option value="listing27.html">/Resources/SoundClass.r</option>
<option value="listing28.html">/Resources/SpinCursor.r</option>
<option value="listing29.html">/Sources/AppleEvent.cp</option>
<option value="listing30.html">/Sources/Application.cp</option>
<option value="listing31.html">/Sources/CollectionClasses.cp</option>
<option value="listing32.html">/Sources/CollectionClassesTest.cp</option>
<option value="listing33.html">/Sources/ColorPicker.cp</option>
<option value="listing34.html">/Sources/ColorPickerTest.cp</option>
<option value="listing35.html">/Sources/DTSCPlusLibrary.cp</option>
<option value="listing36.html">/Sources/Environment.cp</option>
<option value="listing37.html">/Sources/EnvironmentTest.cp</option>
<option value="listing38.html">/Sources/FileClass.cp</option>
<option value="listing39.html">/Sources/FileClassTest.cp</option>
<option value="listing40.html">/Sources/GDevice.cp</option>
<option value="listing41.html">/Sources/GDeviceTest.cp</option>
<option value="listing42.html">/Sources/GraphicsEnv.cp</option>
<option value="listing43.html">/Sources/GraphicsEnvTest.cp</option>
<option value="listing44.html">/Sources/KeyMap.cp</option>
<option value="listing45.html">/Sources/KeyMapTest.cp</option>
<option value="listing46.html">/Sources/MemoryClass.cp</option>
<option value="listing47.html">/Sources/MemoryClassTest.cp</option>
<option value="listing48.html">/Sources/Menu.cp</option>
<option value="listing49.html">/Sources/Process.cp</option>
<option value="listing50.html">/Sources/ProcessTest.cp</option>
<option value="listing51.html">/Sources/Random.cp</option>
<option value="listing52.html">/Sources/RandomTest.cp</option>
<option value="listing53.html">/Sources/SoundClass.cp</option>
<option value="listing54.html">/Sources/SoundClassTest.cp</option>
<option value="listing55.html">/Sources/SpinCursor.cp</option>
<option value="listing56.html">/Sources/SpinCursorTest.cp</option>
<option value="listing57.html">/Sources/Template.cp</option>
<option value="listing58.html">/Sources/TemplateTest.cp</option>
<option value="listing59.html">/Sources/Timer.cp</option>
<option value="listing60.html">/Sources/TimerTest.cp</option>
<option value="listing61.html">/Sources/Toolbox.cp</option>
<option value="listing62.html">/Sources/ToolboxTest.cp</option>
<option value="listing63.html">/Sources/Tracer.cp</option>
<option value="listing64.html">/Sources/tracertest.cp</option>
<option value="listing65.html">/Sources/UserTermination.cp</option>
<option value="listing66.html">/Sources/UserTerminationTest.cp</option>
<option value="listing67.html">/Sources/Volume.cp</option>
<option value="listing68.html">/Sources/VolumeTest.cp</option>
<option value="listing69.html">/Sources/Window.cp</option></select>
				</p>
				</form>
				<p><strong><a href="DTSCPlusLibrary.zip">Download Sample</a></strong> (&#147;DTSCPlusLibrary.zip&#148;, 435.0K)<BR>
<strong><a href="DTSCPlusLibrary.dmg">Download Sample</a></strong> (&#147;DTSCPlusLibrary.dmg&#148;, 521.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    CollectionClasses.cp  Contains:  The following collection classes are implemented: TLinkedList, TStack, (TQueue, TDeQueue),          THashTable.          CollectionClasses.cp contains the collection class member functions.   Written by: Kent Sandvik    Copyright:  Copyright &copy; 1992-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/18/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#ifndef _COLLECTION_#include &quot;CollectionClasses.h&quot;#endif// _________________________________________________________________________________________________________ ////  TLINKEDLIST Class definitions.//  CONSTRUCTORS AND DESTRUCTORS#pragma segment CollectionsTLinkedList::TLinkedList(short max)// Create a Linked list class (max entries pre-defined in a constant in the header file).{  fMaxCollectionSize = max;          // keep track of how many entries we could add to the collection  fCollectionSize = 0;            // no entries yet  // Fix the head and the rest of the pointer hooks.  fHead = new fNODE;              // create nodes  fTail = new fNODE;  fLastEntry = new fNODE;  fCurrentNode = new fNODE;  fHead-&gt;fNext = fTail;            // default head points at tail, then we will push in nodes between  fHead-&gt;fPrevious = fHead;          // bit your own tail  fTail-&gt;fNext = fTail;            // bite your own tail  fTail-&gt;fPrevious = fHead;          // hook tail with head (double linked list)  fTail-&gt;fKey = NULL;              // mark the last entry as NULL  fHead-&gt;fKey = NULL;              // mark the first entry as NULL  fLastEntry-&gt;fPrevious = fHead;        // hook the ptr node between the head  fLastEntry-&gt;fNext = fTail;          // \xC9and the tail}#pragma segment CollectionsTLinkedList::~TLinkedList()// Destruct the structures required for the former linked list.{  struct fNODE* temp = fHead;          // create a temp node  while (temp != fTail)    // while we have entries, delete them from head to tail    {      fHead = temp;            // copy temp node to the head position      temp = temp-&gt;fNext;          // and make temp point at the next one      delete fHead;            // meanwhile delete the head, and continue copying tmp to head    }}//  MAIN INTERFACES#pragma segment CollectionsBoolean TLinkedList::Append(const TItemtype item)// Append entry to the linked list (at the end).{  if (fCollectionSize &lt; fMaxCollectionSize)  {    struct fNODE*        temp = new fNODE;  // create a new node    temp-&gt;fKey = item;    // Hook the temp node between the last entry and the tail        if (fCollectionSize == 0)        // first entry?    {      fHead-&gt;fNext = temp;        // hook it just after the head      temp-&gt;fNext = fTail;        // and before the tail      fLastEntry = temp;          // and keep track of it!    }    else                  // OK now we will track of the fCurrentNode      {        temp-&gt;fNext = fTail;      // stuck it just before the tail        fLastEntry-&gt;fNext = temp;    // and after the current node        fLastEntry = temp;        // and mark it the current node      }    fCollectionSize++;            // keep a count on the size of the linked list    goto AppendOK;  }  ASSERT(fCollectionSize &lt; fMaxCollectionSize, &quot;\pOverflow of the LinkedList&quot;);  return false;AppendOK:return true;}#pragma segment CollectionsBoolean TLinkedList::Remove(const TItemtype item)// Remove defined entry from the linked list.{  // First find the item, if found remove it, connect the links and decrease the collection size count  this-&gt;Reset();                // get back to the first entry  struct fNODE*            temp = fHead;    // keep a temp pointer to earlier node passed  do                      // walk along the list    {    if (fCurrentNode-&gt;fKey == item)      // found a hit?      {      // yes!      temp-&gt;fNext = fCurrentNode-&gt;fNext;  // short circuit the current node      delete fCurrentNode;        // delete this node      fCollectionSize--;          // decreate the collection count      goto OK;              // and jump out     }    temp = fCurrentNode;          // keep track of the just visited node    fCurrentNode = fCurrentNode-&gt;fNext;    // \xC9and step forward  } while (fCurrentNode != fTail);      // as long as we are inside the linked list    return false;                // nothing happened\xC9OK:  return true;                // OK, we were able to delete the entry}#pragma segment CollectionsBoolean TLinkedList::IsEmpty()// Check if the collection is empty (head points at tail).{  return (fHead-&gt;fNext == fTail);        // check if the next pointer is pointing on the tail}#pragma segment CollectionsBoolean TLinkedList::Find(const TItemtype item)// Find if we have the itemtype in the 'queue'.{  TItemtype tempVal;  this-&gt;Reset();                // get back to the first entry  while ((tempVal = this-&gt;Next()) != NULL)    // get all entries one at a time    {      if (tempVal == item)        // if we found a one-to-one relationship        return true;          // signal OK    }  return false;                // otherwise signal false}#pragma segment CollectionsSize TLinkedList::GetSize() const// Return the internal count of entries in collection.{  return fCollectionSize;}// ITERATORS#pragma segment CollectionsTItemtype TLinkedList::First()// Get the first entry in the collection.{  if (fCollectionSize != 0)    return fHead-&gt;fNext-&gt;fKey;        // return what FHead-&gt;fNext has (the first 'real' node)  else    return NULL;}#pragma segment CollectionsTItemtype TLinkedList::Next()// Return next entry in the list.{  TItemtype item;  item = fCurrentNode-&gt;fKey;          // get current item  fCurrentNode = fCurrentNode-&gt;fNext;      // then increase the node to the next entry  return item;                // return item}#pragma segment CollectionsTItemtype TLinkedList::Last()// Return last entry in the list.{  // because we cached the first entry, it's easy to return it  // we might have problems with a real de-queue later if   // we don't revise this scheme (but most likely we will override Last() with new behavior  return fLastEntry-&gt;fKey;          // the fLastNode is always pointing at the last entry}#pragma segment Collectionsvoid TLinkedList::Reset()// Make the current node point at the first entry from beginning (reset).{  fCurrentNode = fHead-&gt;fNext;        // reset the fCurrentNode pointer to the first entry}// _________________________________________________________________________________________________________ ////  TSTACK Class definitions.//  CONSTRUCTORS AND DESTRUCTORS#pragma segment CollectionsTStack::TStack(short max)// Create a stack class (max pre-defined in the header files as a constant).{  fMaxCollectionSize = max;          // keep track of how big we could grow the stack into  fCollectionSize = 0;            // no entries yet}#pragma segment CollectionsTStack::~TStack()// Default constructor -- not used for the time being.{}//  MAIN INTERFACES#pragma segment CollectionsBoolean TStack::Push(const TItemtype item)// Push entry into the stack (beginning).{  if (fCollectionSize &lt; fMaxCollectionSize)  // yes, we bail out and don't add more entries  {    struct fNODE* temp = new fNODE;      // create temp node    temp-&gt;fKey = item;            // store value in temp node    temp-&gt;fNext = fHead-&gt;fNext;        // make temp point at the real next block     fHead-&gt;fNext = temp;          // and make temp suddenly the real head (stack head!)    fCollectionSize++;            // increase the stack size    if (fCollectionSize == 1)        // first entry?      fLastEntry = temp;          // store it for fast access later (cache the ptr)    goto PushOK;  }  ASSERT(fCollectionSize &lt; fMaxCollectionSize, &quot;\pOverflow of the Stack&quot;);// signal about a possible problem  return false;PushOK:return true;}#pragma segment CollectionsTItemtype TStack::Pop()// Pop entry from the stack (beginning).{  TItemtype item;  struct fNODE* temp = fHead-&gt;fNext;      // create temp node with the header next pointer values  fHead-&gt;fNext = temp-&gt;fNext;          // copy back the following pointer from temp to the head  item = temp-&gt;fKey;              // get the temp item  delete temp;                // delete the suddenly non-needed node  fCollectionSize--;              // decrease the stack  return item;                // return the asked value}#pragma segment CollectionsBoolean TStack::Append(const TItemtype item)// Append entry, same as Push, but we included it.{  return (this-&gt;Push(item));          // call the one and only method supported with stack insertion}#pragma segment CollectionsBoolean TStack::Remove(const TItemtype      /*item*/)// Remove is not implemented, but we had to include it because we are subclassing from a TLinkedList.{  return false;                // not supported}// _________________________________________________________________________________________________________ ////  TQUEUE//  CONSTRUCTORS AND DESTRUCTORS#pragma segment CollectionsTQueue::TQueue(short max)// Create a queue class (max pre-defined in the header files as a constant).{  fMaxCollectionSize = max;          // keep track of how big we could grow the stack into  fCollectionSize = 0;            // no entries yet}#pragma segment CollectionsTQueue::~TQueue()// Default destructor, not used for the time being.{}//  MAIN INTERFACE#pragma segment CollectionsBoolean TQueue::Put(const TItemtype item)// Put entry into the queue (beginning).{  if (fCollectionSize &lt; fMaxCollectionSize)  // no problems?  {    struct fNODE* temp = new fNODE;      // create a new node    temp-&gt;fKey = item;            // add value to the node bucket      // place it in the beginning of the queue    temp-&gt;fNext = fHead-&gt;fNext;        // push it into the queue    fHead-&gt;fNext = temp;          // now it's there    // update the tail pointer    if (fCollectionSize == 0)        // first entry?    {      fTail-&gt;fPrevious = temp;      // hook fTail to the entry    }    temp-&gt;fPrevious = fHead;        // and hook it back to head    fLastEntry-&gt;fPrevious = temp;      // and as well as to the current first entry    fLastEntry = temp;            // and mark it as the current first entry      fCollectionSize++;            // increase the collection count    goto QueueOK;  }  ASSERT(fCollectionSize &lt; fMaxCollectionSize, &quot;\pOverflow of TQueue&quot;);  return false;QueueOK:return true;}#pragma segment CollectionsBoolean TQueue::Append(const TItemtype item)// Append is the same as Put.{  return (this-&gt;Put(item));          // call TQueue.Put}#pragma segment CollectionsTItemtype TQueue::Get()// Get entry from the end of the list (queue).{  TItemtype item;  // get the node and the value      struct fNODE* temp = fTail-&gt;fPrevious;    // get the last before fTail  item = temp-&gt;fKey;              // get the item    // change the pointers  fTail-&gt;fPrevious = temp-&gt;fPrevious;      // hook fTail to the previous entry  temp-&gt;fPrevious-&gt;fNext = fTail;        // hook the node to tail as well    delete temp;                // delete the entry    fCollectionSize--;              // decrease the collection count    return item;                // return the item}#pragma segment CollectionsTItemtype TQueue::Last()// Get last entry from queue.{  return fTail-&gt;fPrevious-&gt;fKey;        // get the last entry}#pragma segment CollectionsBoolean TQueue::Remove(const TItemtype      /*item*/)// Remove is not supported, but we needed to include this because TQueue is subclassed from TLinkedList{  return false;                // not supported}// _________________________________________________________________________________________________________ //// TDEQUE//  CONSTRUCTORS AND DESTRUCTORS#pragma segment CollectionsTDeque::TDeque(short max)// Create dequeue class (max pre-defined in the header files as a constant).{  fMaxCollectionSize = max;          // keep track of how big we could grow the stack into  fCollectionSize = 0;            // no entries yet}#pragma segment CollectionsTDeque::~TDeque()// Default destructor, not used for the time being.{}#pragma segment CollectionsBoolean TDeque::Push(const TItemtype item)// Push entry into queue (beginning).{  return (TQueue::Put(item));          // call inherited Put}#pragma segment CollectionsBoolean TDeque::PutAtEnd(const TItemtype item)// Place entry at end of the deque.{  if (fCollectionSize &lt; fMaxCollectionSize)  // bail out if we reach the limit  {    struct fNODE*     temp = new fNODE;    // create temp node    temp-&gt;fKey = item;            // store the value    temp-&gt;fNext = fTail;          // point at tail    temp-&gt;fPrevious = fTail-&gt;fPrevious;    // make the backwards ptr hooked to the new entry    fTail-&gt;fPrevious-&gt;fNext = temp;      // and hook the old last one into this one     fTail-&gt;fPrevious = temp;        // make the tail point at the new entry    fCollectionSize++;            // increase the counter    goto PutAtEndOK;  }  ASSERT(fCollectionSize &lt; fMaxCollectionSize, &quot;\pOverflow of the TDeque&quot;);  return false;PutAtEndOK:return true;}TItemtype TDeque::Pop()// Pop entry from the queue end.{  TItemtype item;  struct fNODE* temp = fHead-&gt;fNext;      // hook to the beginning of the deque  fHead-&gt;fNext = temp-&gt;fNext;          // hook head to the following node  temp-&gt;fNext-&gt;fPrevious = fHead;        // and the next one should point back at the head  item = temp-&gt;fKey;              // get the stored value  delete temp;                // remove node  fCollectionSize--;              // decrease the counter  return item;                // and return the item}// _________________________________________________________________________________________________________ //// THASHTABLE //  CONSTRUCTORS AND DESTRUCTORSTHashTable::THashTable()// Create a hash table class.{  // Clear the array bucket.  for (long i = 0; i &lt; NBUCKETS; i++)    fBucket[i] = 0;}THashTable::~THashTable()// Delete any memory structures required for the hashtable class.{  // Delete the entries in the array bucket.    for (long i = 0; i &lt; NBUCKETS; i++)  {    THashEntryPtr p = fBucket[i];      // get a ptr to the entry    while (p)      // while a valid ptr      {        fBucket[i] = p-&gt;fNext;      // install next entry in array        delete p;            // delete the current node        p = fBucket[i];          // ptr back to the new value      }  }}//  MAIN INTERFACE#pragma segment CollectionsBoolean THashTable::Add(THashKey key,            TItemtype value)// Add entries to the hash table.{  THashEntryPtr p;  THashKey whichItem = this-&gt;Hash(key);    // hash out the real value  cout &lt;&lt; &quot; whichItem = &quot; &lt;&lt; whichItem &lt;&lt; &quot;\n&quot;;  p = FindInBucket(fBucket[whichItem], key);  if (p)                    // have already an entry?    goto problem;              // signal the failure  p = this-&gt;AddElement(key);          // add our entry  p-&gt;fValue = value;              // add the item value to the entry  return true;problem:return false;}#pragma segment CollectionsBoolean THashTable::Remove(THashKey key)// Remove entries from the hash table.{  THashKey whichItem = this-&gt;Hash(key);    // hash out the real value  THashEntryPtr p = FindInBucket(fBucket[whichItem], key);  if (!p)                    // no valid ptr?    goto problem;  if (fBucket[whichItem] == p)    fBucket[whichItem] = p-&gt;fNext;      // connect to next node  delete p;                  // delete current node  return true;problem:return false;}#pragma segment CollectionsTItemtype THashTable::Find(THashKey key)// Find entries in the hash table.{  THashKey whichItem = this-&gt;Hash(key);    // hash out the real value  THashEntryPtr p = this-&gt;FindInBucket(fBucket[whichItem], key);  if (!p)    return 0;                // return 0  else    return p-&gt;fValue;            // return valid value}void THashTable::MapCar(MapFun function)// Run a function on each entry in the hash table.{  for (long i = 0; i &lt; NBUCKETS; i++)      // iterate through all the entries  {    THashEntryPtr p = fBucket[i];      // get the ptr to the entry    while (p)      // while we have a nice value      {        function(p);          // call the function on p        p = p-&gt;fNext;          // get the next ptr      }  }}// PRIVATE INTERNAL FUNCTIONSTHashEntryPtr THashTable::AddElement(THashKey key)// Add an element to the internal structure.{  THashKey whichItem = this-&gt;Hash(key);  THashEntryPtr p = new THashEntry(key);  p-&gt;fNext = fBucket[whichItem];        // get ptr to next entry  if (fBucket[whichItem])            // OK?    fBucket[whichItem]-&gt;fPrevious = p;    // establish ptrs backwards  fBucket[whichItem] = p;            // as well as the current one  return p;}THashKey THashTable::Hash(THashKey key)// Hash out a key to be used with the buckets. Override for your own preferences.{  key &amp;= kResourceIDMask;  return ((THashKey)(0x7FF &amp; (key ^ (key &gt;&gt; 11))) % NBUCKETS);  // Note: if you write your own hash function, don't forget modula NBUCKETS to get  // down the size of the key so it hooks to the buckets.}THashEntryPtr THashTable::FindInBucket(THashEntryPtr p,                     THashKey key)// Find bucket where entry is located.{  while (p)    // valid pointer?    {      if (p-&gt;fKey == key)          // hit?        break;              // found it!      p = p-&gt;fNext;            // nope, continue cycling the list    }  return p;                  // return found (not found) ptr}// _________________________________________________________________________________________________________ ///*  Change History (most recent last):  No    Init.  Date    Comment  1      khs    11/7/92    New file  2      khs    11/28/92  Added TLinkedList  3      khs    11/29/92  Added TQueue and TDeque  4      khs    1/14/93    Cleanup*/</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DTSCPlusLibrary/listing31.html%3Fid%3DDTS10000731-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DTSCPlusLibrary/listing31.html%3Fid%3DDTS10000731-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DTSCPlusLibrary/listing31.html%3Fid%3DDTS10000731-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>