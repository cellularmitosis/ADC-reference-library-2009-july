<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OTLLCTest - /OTLLCTest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; <A HREF="javascript:location.replace('index.html');">OTLLCTest</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/index.html" target="_blank">Reference Library > Networking</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OTLLCTest</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/OTLLCTest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/NegotiateRawModeSample.c</option>
<option value="listing2.html">/NegotiateRawModeSample.h</option>
<option value="listing3.html">/OTLLCTest.c</option>
<option value="listing4.html">/OTLLCTest.h</option></select>
				</p>
				</form>
				<p><strong><a href="OTLLCTest.zip">Download Sample</a></strong> (&#147;OTLLCTest.zip&#148;, 56.8K)<BR>
<strong><a href="OTLLCTest.dmg">Download Sample</a></strong> (&#147;OTLLCTest.dmg&#148;, 120.9K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    OTLLCTest.c  Contains:  Simple app write or receive 8022 Ethernet packets using a multicast address        This program implements both a sender and receiver such that both sides        open an 802.2 Ethernet endpoint. The user can then select whether to run the         program as a sender or receiver. If implemented as a receiver, the endpoint        is bound, and the multicast option is turned on. The receiver waits in a         spin loop for a specified period of time before quitting.  The receiver will process        all incoming ethernet packets destined to the endpoint for the specified        protocol.  Upon receipt, the program checks to see whether the packet was sequential        to the previous packet.  A collection of global counter maintains the number of        inOrder, outOfOrder packets, and the number of packets reads resulting in an error,        plus the number of packets which come in back to back while in the handler.          Note the this sample turns on the rawmode option so that the handler will be passed the        14 byte 802.2 header.        Also note that the sender may also implement the rawmode option so that it can also        fill in the header bytes itself.  If this is done, then the buffer needs to         be enlarged to include these additional bytes.  These additional bytes will not affect        the maximum tsdu size since the tsdu size is the i-frame limit and does not include        the header size.          The sender process, sends 10005 x 1500 byte packets as fast as possible.  The user         can select to to turn on AckSends mode where the packet is handed to OT and not                released until OT sends the information to the lower layer.   Written by: Rich Kubota    Copyright:  Copyright &copy; 1993-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/22/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        01/98            added threshold timer to control how often WNE gets called.          01/98            fixed sample so that you can send in raw mode and receive in                      regular mode or vice versa and things work.                        Fixed problem that when setting the max data packet size to                      1500 bytes and are sending data in regular mode, adjust the                      unitdata.data.len field to account for the fact that the                      endpoint will insert the LLC header and the SNAP header.                        For raw mode, this is not an issue. Added feature to 1. allow                      the program to be re-used without having to quit 2. ask user for                      the drivername to use e.g. 'enet0, 'enet1', etc.,        01/98            modified the sample to use the revised NegotiateRawModeOption                      code which returns the template type.  The Mentat template driver                      returns an additional 24 bytes of info at the beginning of the                      raw data packet.        01/98            modified DoBind so that one can use either a regular LLC to SNAP                       endpoint.        10/97            fixed bug in OT 8022 module which prevented more than 1483 data                      bytes from being sent in raw mode.  Requires OT 1.3 to send &gt; 1483                      data bytes with endpoint in rawdata mode.*/#include &lt;stdio.h&gt;#include &lt;Types.h&gt;#include &lt;Memory.h&gt;#include &lt;Resources.h&gt;#include &lt;Events.h&gt;#include &lt;OpenTransport.h&gt;      // open transport files      #include &lt;OpenTptLinks.h&gt;#include &lt;OpenTptAppleTalk.h&gt;#include &lt;OpenTptConfig.h&gt;#include &lt;Time.h&gt;#include &lt;Errors.h&gt;#include &lt;String.h&gt;#include &quot;OTLLCTest.h&quot;#include &quot;NegotiateRawModeSample.h&quot;// Comment out the following line if synchronous sends desired.#define __ASYNCSEND__  1//-----------------------------------------------------------------------------------------// Globals//-----------------------------------------------------------------------------------------EndpointRef    gEndpoint;OSStatus    gstatus;UInt32      gFlags;UInt32      gNumBack, gNumFore;UInt32      gPacketsRead;UInt32      gBackToBackPackets;  UInt32      gInOrder;UInt32      gOutOfOrder;UInt32      gCounter;UInt32      gNumDataEvents;UInt32      gReadErrors;UInt32      gTemplateType;UInt32      gNumMemErrs;UInt32      gTimerThreshold;UInt8      *gBuffer;UInt8      *gDummyBuffer;struct T8022Address   gAddr;UInt8      gmcAddr[k48BitAddrLength] = {MCASTADDR0,MCASTADDR1,MCASTADDR2,MCASTADDR3,MCASTADDR4,MCASTADDR5};PacketBuffer  gPacket;UInt8      gFlag1;Boolean      gDone;Boolean      gAbort;//-----------------------------------------------------------------------------------------// Prototypes//-----------------------------------------------------------------------------------------extern OSStatus OTSetMemoryLimits(size_t growSize, size_t mazSize);OSStatus     DoBind();OSStatus     DoAddMulticast(EndpointRef ep, unsigned char *mcAddr);OSStatus    DoRemoveMulticast(EndpointRef ep, unsigned char *mcAddr);void       WriteApplIntro(void);UInt32       GetYesNoOption(void);UInt32       GetUserOption(void);Boolean     CanDoMDATAMode(EndpointRef ep);void      DoOTLLCWriteTest(void);Boolean     DoSendPacket(EndpointRef ep);void      DoOTLLCReadTest(void);OSStatus     DoReadPacket(EndpointRef ep, UInt8 *mainBuffer);pascal void   LLCEventHandler(void* ref, OTEventCode event, OTResult result, void* cookie);void       CallWNE(void);void      MyIdle(void);void       DoValueBreak(long value, const char* message);void       GetDriverName(char *name);void       SetTimerThreshold(void);void       PrintAppleTalkPortName(void);void       ListEnetDrivers(void);/********************************************************************************* DoBindENET********************************************************************************/OSStatus DoBind(void){  OSStatus    osstatus;  TBind      requestInfo;  TBind      responseInfo;  UInt32      i;    gAddr.fAddrFamily = AF_8022;    for (i = 0; i &lt; k48BitAddrLength; i++)    gAddr.fHWAddr[i] = 0x00;      gAddr.fSAP = TESTSAP;    if (TESTSAP == 0xAA)  {      // set SNAP fields;        gAddr.fSNAP[0] = MYSNAP0;    // set these values in the interface file OTLLCTest.h    gAddr.fSNAP[1] = MYSNAP1;    gAddr.fSNAP[2] = MYSNAP2;    gAddr.fSNAP[3] = MYSNAP3;    gAddr.fSNAP[4] = MYSNAP4;        requestInfo.addr.len = k8022SNAPAddressLength;      }  else  {    requestInfo.addr.len = k8022BasicAddressLength;      }        // finish bind information  requestInfo.addr.buf = (UInt8 *)&amp;gAddr;  requestInfo.addr.maxlen = 0;        requestInfo.qlen = 0;    responseInfo.addr.buf = (UInt8 *)&amp;gAddr;  responseInfo.addr.len = 0;      responseInfo.addr.maxlen = k8022SNAPAddressLength;  responseInfo.qlen = 0;        osstatus = OTBind(gEndpoint, &amp;requestInfo, &amp;responseInfo);  if (osstatus == kOTNoError)    SetEPBoundFlag(gFlags);      return osstatus;}/********************************************************************************* DoAddMulticast********************************************************************************/OSStatus DoAddMulticast(EndpointRef ep, unsigned char *mcAddr){  OSStatus  osstatus = noErr;  TOptMgmt  req;  UInt8    reqOpt[64];        req.opt.buf  = reqOpt;  req.flags  = T_NEGOTIATE;    ((TOption*)reqOpt)-&gt;level  = LNK_TPI;  ((TOption*)reqOpt)-&gt;name  = OPT_ADDMCAST;  ((TOption*)reqOpt)-&gt;len    = kOTOptionHeaderSize + k48BitAddrLength;  ((TOption*)reqOpt)-&gt;status  = 0;  memcpy(((TOption*)reqOpt)-&gt;value, mcAddr, k48BitAddrLength);          req.opt.len = kOTOptionHeaderSize + k48BitAddrLength;  req.opt.maxlen = sizeof(reqOpt);          if ( (osstatus = OTOptionManagement(ep, &amp;req, &amp;req)) != kOTNoError )    fprintf(stderr, &quot;DoAddMulticast - OptionManagement Returned %d\n&quot;, osstatus);  else  {    if (((TOption*)reqOpt)-&gt;status != T_SUCCESS)        {      fprintf(stderr, &quot;DoAddMulticast - failed Status = %d\n&quot;, ((TOption*)reqOpt)-&gt;status);      osstatus = -1;    }    else    {      fprintf(stderr, &quot;DoAddMulticast - was successful\n&quot;);      SetMCastActiveFlag(gFlags);    }  }  return osstatus;}/********************************************************************************* DoRemoveMulticast********************************************************************************/OSStatus DoRemoveMulticast(EndpointRef ep, unsigned char *mcAddr){  OSStatus  osstatus = noErr;  TOptMgmt  req;  UInt8    reqOpt[64];        req.opt.buf  = reqOpt;  req.flags  = T_NEGOTIATE;    ((TOption*)reqOpt)-&gt;level  = LNK_TPI;  ((TOption*)reqOpt)-&gt;name  = OPT_DELMCAST;  ((TOption*)reqOpt)-&gt;status  = 0;  ((TOption*)reqOpt)-&gt;len    = kOTOptionHeaderSize + k48BitAddrLength;  memcpy(((TOption*)reqOpt)-&gt;value, mcAddr, k48BitAddrLength);            req.opt.len = kOTOptionHeaderSize + k48BitAddrLength;  req.opt.maxlen  = sizeof(reqOpt);    if ( (osstatus = OTOptionManagement(ep, &amp;req, &amp;req)) != kOTNoError )    fprintf(stderr, &quot;\nDoRemoveMulticast failed - OptionManagement Returned %d.&quot;, osstatus);  else  {     if (((TOption*)reqOpt)-&gt;status != T_SUCCESS)    {      fprintf(stderr, &quot;nDoRemoveMulticast - failed Status = %d\n&quot;, ((TOption*)reqOpt)-&gt;status);      osstatus = -1;    }    else    {      fprintf(stderr, &quot;nDoRemoveMulticast - was successful\n&quot;);      SetMCastActiveFlag(gFlags);    }  }  return osstatus;}void WriteApplIntro(void){  fprintf(stderr, &quot;\nEthernet 802.2 LLC Test program v1.0\n&quot;);  fprintf(stderr, &quot;\nThis test application sets the system&quot;);  fprintf(stderr, &quot;\ninto send or receive mode.\n&quot;);  fprintf(stderr, &quot;\nThe send portion of this program sets the Ethernet&quot;);  fprintf(stderr, &quot;\ndriver to use a multicast address, then sends 10000&quot;);  fprintf(stderr, &quot;\n- 1500 byte packets out the wire.\n&quot;);  fprintf(stderr, &quot;\nThe receive portion of this program sets the Ethernet&quot;);  fprintf(stderr, &quot;\ndriver to use a multicast address, then waits for the&quot;);  fprintf(stderr, &quot;\n10000 - 1500 byte packets or times out after 30 seconds.\n&quot;);  fprintf(stderr, &quot;\n\nUsing SAP address %d.\n&quot;, TESTSAP);  }UInt32 GetYesNoOption(void){  UInt32  result;  char  selection[32];  Boolean  done;    fprintf(stdout, &quot;\n    Enter Y - To accept option&quot;);  fprintf(stdout, &quot;\n    Enter N - To decline option&quot;);  fprintf(stdout, &quot;\n    Enter Q - To quit&quot;);  fprintf(stdout, &quot;\nYour selection -&gt; &quot;);  fflush(stdout);  done = false;  do  {    scanf(&quot;%s&quot;, selection);    switch (selection[0])    {      case 'y':      case 'Y':        result = kAcceptOption;        done = true;        break;            case 'n':      case 'N':        result = kDeclineOption;        done = true;        break;      case 'q':      case 'Q':        result = kQuitTest;        done = true;        break;              default:        fprintf(stdout, &quot;\nInvalid entry - %c, try again -&gt; &quot;, selection);        fflush(stdout);        break;    }  } while (!done);    fflush (stdout);  return result;}UInt32 GetUserOption(void){  UInt32  result;  char  selection[32];  Boolean  done;    fprintf(stdout, &quot;\nSelect the type of test to run&quot;);  fprintf(stdout, &quot;\nMake sure that the receive program is already launched&quot;);  fprintf(stdout, &quot;\n    Enter S - Send test packets&quot;);  fprintf(stdout, &quot;\n    Enter R - Receive test packets&quot;);  fprintf(stdout, &quot;\n    Enter q - quit&quot;);  fprintf(stdout, &quot;\nYour selection -&gt; &quot;);  fflush(stdout);  done = false;  do  {    scanf(&quot;%s&quot;, selection);    switch (selection[0])    {      case 'r':      case 'R':        result = kReceiveTest;        done = true;        break;            case 's':      case 'S':        result = kSendTest;        done = true;        break;      case 'q':      case 'Q':        result = kQuitTest;        done = true;        break;              default:        fprintf(stdout, &quot;\nInvalid entry - %c, try again -&gt; &quot;, selection);        fflush(stdout);        break;    }  } while (!done);    fflush (stdout);  return result;}/*  CanDoMDATAMode gets the endpoint info and checks whether the T_CAN_SUPPORT_MDATA bit is  set in the endpoint info flag field and returns true if so, false otherwise.*/Boolean CanDoMDATAMode(EndpointRef ep){  TEndpointInfo  info;  OSStatus    err;  Boolean      result;    err = OTGetEndpointInfo(ep, &amp;info);  if (err != kOTNoError)    result = false;  else if (info.flags &amp; T_CAN_SUPPORT_MDATA)    result = true;    // this also means that the src addr info is in the info record  else    result = false;  return result;}void DoOTLLCWriteTest(void){  OSStatus  osstatus;  UInt32    numMemErrs, last250;  UInt32    lastFlowErrPacketNum;  UInt32    timer;  time_t    t1, t2, t3;  UInt16    rawModeOffset = 0;  Boolean    callDoIdle;      osstatus = DoBind();    OTMemzero(&amp;gPacket, sizeof(gPacket));    // zero out the global packet buffer structure  if (TstUseAckSendsFlag(gFlags))  {    osstatus = OTAckSends(gEndpoint);    if (osstatus != kOTNoError)    {      fprintf (stdout, &quot;\n Error turning AckSends on - error %ld&quot;, osstatus);      ClrUseAckSendsFlag(gFlags);      gNumFore = gNumBack = 0;    }  }  if (TstUseRawModeFlag(gFlags))  {    if (CanDoMDATAMode(gEndpoint) &amp;&amp; (DATASIZE &lt;= 1500))    {      osstatus = DoNegotiateRawModeOption(gEndpoint, kOTRawRcvOn, &amp;gTemplateType);      if (osstatus == kOTNoError)      {        SetRawModeFlag(gFlags);          /* if rawmode is on then we want to offset the data          * an additional 17 bytes and set the header info          * ourselves.          * note that 17 bytes constitutes the 6 byte dAddr, 6 byte sAddr          * 2 byte length field, 1 byte ssap, 1 byte dsap and 1 byte control byte                    * Note that even if the DSAP is not 0xAA, we go ahead and stuff the 5 bytes          * following the control byte, with whatever SNAP values have been defined.          */        gPacket.rawModeOffset = 17;          // check is we are doing SNAP        if (TESTSAP == 0xAA)          gPacket.rawModeOffset += 5;        fprintf (stdout, &quot;\n raw mode option enabled&quot;);      }      else      {          // if the option failed, then we don't use it'        fprintf (stdout, &quot;\nError negotiating raw mode option&quot;);          // reset the status result.        osstatus = kOTNoError;      }    }    else      fprintf (stdout, &quot;\nYou need a later version of OT which supports the MDataMode option&quot;);  }#if __ASYNCSEND__  if (osstatus == kOTNoError)  {    osstatus = OTSetAsynchronous(gEndpoint);    if (osstatus != kOTNoError)     {      fprintf(stderr, &quot;\n\nError making endpoint asynchronous!&quot;);      fprintf(stderr, &quot;\nOTSetAsynchronous returned %d\n&quot;, osstatus);    }  }  // now ready to handle async events#endif      if (osstatus == kOTNoError)  {      // set up the first 18 bytes past the control byte for non SNAP LLC endpoint or      // past the SNAP header for a SNAP endpoint, so that we can recognize it     OTStrCopy((char*)&amp;gPacket.data[gPacket.rawModeOffset], &quot;begin data section&quot;);      // set up some specific bytes in the data buffer that begins at the same point      // relative to the LLC or SNAP header    gPacket.data[DATAOFFSET     + gPacket.rawModeOffset] = 0;    gPacket.data[DATAOFFSET + 1 + gPacket.rawModeOffset] = 0;    OTStrCopy((char*)&amp;gPacket.data[DATAOFFSET+2 + gPacket.rawModeOffset], &quot;end of data section&quot;);        gPacket.unitdata.udata.buf = (UInt8*)gPacket.data;      if (TstRawModeFlag(gFlags))      gPacket.unitdata.udata.len = DATASIZE + 14;    else    {        // the DATASIZE setting represents the total size of the packet        // following the ethernet header.  If we are not doing a rawmode send        // then we need to account for the fact that part of the data area        // will be used by OT to place the SSAP, DSAP, and Control byte.  If        // we are sending a SNAP packet, then we have to account for the 5        // additional bytes of the SNAP header.  Otherwise if the unidata.data.len        // field were set to the full size of 1500, the packet would not be sent        // since OT would think it was trying to send a 1503 or 1508 byte         // ethernet packet (not including the ethernet header).                // By doing this, we can process the packet using either a raw data or        // regular ethernet endpoint as the receiver.              if (TESTSAP == 0xAA)        gPacket.unitdata.udata.len = DATASIZE - 8;      else        gPacket.unitdata.udata.len = DATASIZE - 3;    }          gPacket.unitdata.opt.len = 0;    gPacket.unitdata.opt.buf = NULL;    if (TstRawModeFlag(gFlags) == false)    {        // set up the destination addresss      gPacket.dAddr.fAddrFamily = AF_8022;            gPacket.dAddr.fHWAddr[0] = MCASTADDR0;      gPacket.dAddr.fHWAddr[1] = MCASTADDR1;      gPacket.dAddr.fHWAddr[2] = MCASTADDR2;      gPacket.dAddr.fHWAddr[3] = MCASTADDR3;      gPacket.dAddr.fHWAddr[4] = MCASTADDR4;      gPacket.dAddr.fHWAddr[5] = MCASTADDR5;              gPacket.dAddr.fSAP = TESTSAP;            gPacket.unitdata.addr.buf = (UInt8*)&amp;gPacket.dAddr;      if (TESTSAP == 0xAA)      {        gPacket.dAddr.fSNAP[0] = MYSNAP0;        gPacket.dAddr.fSNAP[1] = MYSNAP1;        gPacket.dAddr.fSNAP[2] = MYSNAP2;        gPacket.dAddr.fSNAP[3] = MYSNAP3;        gPacket.dAddr.fSNAP[4] = MYSNAP4;            gPacket.unitdata.addr.len = k8022SNAPAddressLength;      }      else        gPacket.unitdata.addr.len = k8022BasicAddressLength;    }    else    {        // set up for a rawmode send data call      gPacket.data[0] = MCASTADDR0;      gPacket.data[1] = MCASTADDR1;      gPacket.data[2] = MCASTADDR2;      gPacket.data[3] = MCASTADDR3;      gPacket.data[4] = MCASTADDR4;      gPacket.data[5] = MCASTADDR5;        // set the packet len field      gPacket.data[12] = DATASIZE &gt;&gt; 8;      gPacket.data[13] = DATASIZE &amp; 0xFF;        // set the dsap, ssap, and control byte fields.      gPacket.data[14] = TESTSAP;      // set DSAP      gPacket.data[15] = TESTSAP;      // set SSAP      gPacket.data[16] = 0x03;      // set control byte            if (TESTSAP == 0xAA)      {          // set up the SNAP Addr        gPacket.data[17] = MYSNAP0;        gPacket.data[18] = MYSNAP1;        gPacket.data[19] = MYSNAP2;        gPacket.data[20] = MYSNAP3;        gPacket.data[21] = MYSNAP4;      }          gPacket.unitdata.addr.buf = nil;                      // don't want to set the destination address since we've already                     // done so in the data                                        // the following line is required for OT 1.2 and greater                    // where there is a bug with how OT deals with mentat template                    // based drivers, such that in rawmode, the total packet size -                     // header + data is limited to 1500 bytes.  By using the following                    // line, OT will not check for this limitation and will go ahead                    // and send an MDATA message.      gPacket.unitdata.addr.len = 0xFFFFFFFFL;                        // magic constant for M_DATA mode                }    ClrFlowClrFlag(gFlags);    // clear the flag that indicates that a T_GODATA event occurred                  // we do this because a race condition might occur when we make the                  // the OTSndUData call, a flowerr may occur, but get cleared by the time                  // we actually check the osstatus field    fprintf (stdout, &quot;\n starting write of %ld llc packets of %ld bytes\n&quot;, (long)SENDCOUNT, (long)DATASIZE);    fflush(stdout);    t1 = clock ();        gDone = false;    gPacket.i = 0;    numMemErrs = last250 = 0;    lastFlowErrPacketNum = 0;    timer = 0;    callDoIdle = false;          // set the flag that will tell us to send a packet at system task time so that      // we can send the initial packet    SetSysTaskSendFlag(gFlags);        while (!gDone &amp;&amp; !gAbort)    {            if (TstSysTaskSendFlag(gFlags))      {        if (DoSendPacket(gEndpoint) == true)        {          gNumFore++;        }      }      if (gNumMemErrs)      {        if (numMemErrs != gNumMemErrs)        {          numMemErrs = gNumMemErrs;          fprintf(stderr, &quot;\nkENOMEMErr %ld.&quot;, gPacket.i);          callDoIdle = true;        }      }            #if 0  // the following code really affect the performance of this tool    // and can consume over 95 percent of the processing time of this tool    // on a fast system.      n = gPacket.i / 250;      if (n &gt; last250)      {        fprintf(stderr, &quot;%d &quot;, n * 250);        fflush(stderr);        last250 = n;      }#endif                  timer++;      if (timer &gt; gTimerThreshold)      {        callDoIdle = true;      }                if (gPacket.lastFlowErrPacketNum != 0)      {        if (lastFlowErrPacketNum != gPacket.lastFlowErrPacketNum)        {          fprintf(stderr, &quot;\nflow error occurred while sending packet %d.&quot;, gPacket.lastFlowErrPacketNum);          lastFlowErrPacketNum = gPacket.lastFlowErrPacketNum;        }      }              // check if we are flow controlled or if it's time to call WNE and call it.      if ((callDoIdle == true) || TstFlowErrFlag(gFlags))      {        CallWNE();        callDoIdle = false;        timer = 0;      }          }  // end while loop sending data    fflush(stderr);            t2 = clock();    t3 = t2 - t1;    fprintf (stdout, &quot;\nCompleted sending %ld llc packets.&quot;, (long)gPacket.i);    fprintf (stdout, &quot;\nTime start = %ld, time end = %ld, time taken %ld seconds.&quot;,           t1, t2, (long)t3/CLOCKS_PER_SEC);    fprintf (stdout, &quot;\nPackets per second = %ld, bytes/second = %ld.&quot;,           ((long)gPacket.i*CLOCKS_PER_SEC)/t3, ((long)gPacket.i*DATASIZE*CLOCKS_PER_SEC)/t3);        fprintf (stdout, &quot;\n Press the mouse to unbind the endpoint&quot;);        if (TstUseAckSendsFlag(gFlags) == true)    {      fprintf (stdout, &quot;\nThe number of packets sent from the while loop - %ld&quot;, gNumFore);      fprintf (stdout, &quot;\nThe number of packets sent from the handler - %ld&quot;, gNumBack);    }        fflush(stdout);    while (!Button())      MyIdle();                  }  // end if bind successful#if __ASYNCSEND__    if (TstEPBoundFlag(gFlags))  {    OTSetSynchronous(gEndpoint);    OTUnbind(gEndpoint);  }#endif}Boolean DoSendPacket(EndpointRef ep){  OSStatus    osstatus;  Boolean      didEnter;    // check to see if we have already entered this function.    // we only want to enter into it once whether at system task time or from the    // handler  if (OTAtomicSetBit(&amp;gFlag1, kInSendPacketBit))    return false;      // call OTenterNotifier so that the notifier is not entered while we are in the following    // section of code. In this way we protect ourselves from race conditions that could     // happen - for example if a flowErr occured, but was cleared before we set the flowErr    // flag, this would be a problem since we would never receive notification that flow    // control was lifted.      didEnter = OTEnterNotifier(ep);      if (gDone == false)  {      // we already assume that the packet is ready to send    osstatus = OTSndUData(gEndpoint, &amp;gPacket.unitdata);  }    switch (osstatus)  {    case kENOMEMErr:      gNumMemErrs++;      break;          case kOTNoError:  // send was successful      gPacket.i++;                    if (gPacket.i &gt;= SENDCOUNT)        gDone = true;      else      {          // increment the counter in the packet        gPacket.data[DATAOFFSET+0+gPacket.rawModeOffset] = gPacket.i &gt;&gt; 8;        gPacket.data[DATAOFFSET+1+gPacket.rawModeOffset] = gPacket.i;                }              break;        case kOTFlowErr:      SetFlowErrFlag(gFlags);      // a T_GODATA did not just come in      ClrSysTaskSendFlag(gFlags);    // clear the flag that we check to send a packet      gPacket.lastFlowErrPacketNum = gPacket.i;  // save the packet number on which the flow err occured      break;        default:      DoValueBreak(osstatus, &quot;Unknown error occurred in DoSendPacket #;&quot;);      gDone = true;      ClrSysTaskSendFlag(gFlags);      break;  }    if (didEnter == true)     OTLeaveNotifier(ep);    OTAtomicClearBit(&amp;gFlag1, kInSendPacketBit);  return true;}    void DoOTLLCReadTest(void){  OSStatus  osstatus;  long    timer;    gBuffer = (UInt8*)NewPtr(DATASIZE + 2* DATASLOP);  // allocate the data buffer + some slop  if (gBuffer)    osstatus = DoBind();  else  {    osstatus = memFullErr;    return;  }  gBackToBackPackets = 0;  gInOrder = 0;  gOutOfOrder = 0;  gCounter = 0;  gPacketsRead = 0;  gNumDataEvents = 0;  gReadErrors = 0;  gNumMemErrs = 0;  gDone = false;    if (osstatus == kOTNoError)  {    osstatus = DoAddMulticast(gEndpoint, gmcAddr);  }    if (osstatus == kOTNoError)  {    if (TstUseRawModeFlag(gFlags))    {      osstatus = DoNegotiateRawModeOption(gEndpoint, kOTRawRcvOn, &amp;gTemplateType);      if (osstatus == kOTNoError)      {        SetRawModeFlag(gFlags);      }      else      {          // if the option failed, then we don't use it'        fprintf (stdout, &quot;\nError negotiating raw mode option&quot;);          // reset the status result.        osstatus = kOTNoError;      }    }  }  #ifdef __ASYNCSEND__  if (osstatus == kOTNoError)  {    osstatus = OTSetAsynchronous(gEndpoint);    if (osstatus != kOTNoError)     {      fprintf(stderr, &quot;\n\nError making endpoint asynchronous!&quot;);      fprintf(stderr, &quot;\nOTSetAsynchronous returned %d\n&quot;, osstatus);    }  }  // now ready to handle async events#endif      if (osstatus == kOTNoError)  {    gAbort = false;    SetWantDataFlag(gFlags);            fprintf (stdout, &quot;\nStarting Read test - will terminate in %d seconds&quot;, TIMEOUT);    fprintf (stdout, &quot;\nor as soon as the trigger packet is received.&quot;);    fprintf (stdout, &quot;\nYou may use Command-Q to quit the program entirely.&quot;);    fprintf (stdout, &quot;\nYou may also use Command-A to terminate this test.\n&quot;);    fprintf (stdout, &quot;\nStarting Read&quot;);    fflush(stdout);        timer = TickCount() + TIMEOUT * 60;      // loop until timer is less than TickCount or until the endtime value gets set        while ((timer &gt; TickCount()) &amp;&amp; (gDone == false) &amp;&amp; (gAbort == false))    {        // allow the user to exit the timer loop by       CallWNE();    }          }    OTSetSynchronous(gEndpoint);      if (TstMCastActiveFlag(gFlags))    DoRemoveMulticast(gEndpoint, gmcAddr);        if (osstatus == kOTNoError)  {    fprintf (stdout, &quot;\n\nBufferReadCount = %ld&quot;, gPacketsRead);    fprintf (stdout, &quot;\nInOrder = %ld\n&quot;, gInOrder);    fprintf (stdout, &quot;\nOutofOrder = %ld\n&quot;, gOutOfOrder);    fprintf (stdout, &quot;\nlast packet read was = %ld\n&quot;, gCounter);    fprintf (stdout, &quot;\nNumber of data events was = %ld\n&quot;, gNumDataEvents);    fprintf (stdout, &quot;\nNumber of read errors was = %ld\n&quot;, gReadErrors);    fprintf (stdout, &quot;\nNumber of back to back packets was = %ld\n&quot;, gBackToBackPackets);    fflush(stdout);  }  if (TstEPBoundFlag(gFlags))    OTUnbind(gEndpoint);  if (gBuffer)    DisposePtr((Ptr)gBuffer);  }OSStatus DoReadPacket(EndpointRef ep, UInt8 *mainBuffer){  TUnitData  unitdata;  struct T8022Address  dAddr;  OTFlags    otFlags;  OSStatus  result;    unitdata.addr.maxlen = sizeof(dAddr);  unitdata.addr.buf = (UInt8*)&amp;dAddr;  unitdata.udata.buf = mainBuffer;  unitdata.udata.maxlen = DATASIZE + DATASLOP;  unitdata.opt.maxlen = 0;    result = OTRcvUData(ep, &amp;unitdata, &amp;otFlags);  return result;}pascal void LLCEventHandler(void* ref, OTEventCode event, OTResult result, void* cookie){  #pragma unused(ref,cookie)  OSStatus  osstatus;  UInt8    *bufferToUse;  UInt32    lcounter, offset;  Boolean    firstTimeFlag;    gstatus = result;  switch (event)  {    case T_MEMORYRELEASED:      if (DoSendPacket(gEndpoint) == false)        SetSysTaskSendFlag(gFlags);      else      {        ClrSysTaskSendFlag(gFlags);        gNumBack++;      }      break;    case T_OPTMGMTCOMPLETE:      ClrWaitOptMgmtFlag(gFlags);      break;          case T_BINDCOMPLETE:      ClrStillBindFlag(gFlags);      break;        case T_UNBINDCOMPLETE:      break;        case T_GODATA:      SetFlowClrFlag(gFlags);  // indicate that the flow data problem has now cleared.      SetSysTaskSendFlag(gFlags);      break;        case T_DATA:      gNumDataEvents++;      if (TstWantDataFlag(gFlags))        bufferToUse = gBuffer;      else        bufferToUse = gDummyBuffer;                // initialize variables as we enter while loop      osstatus = kOTNoError;      firstTimeFlag = true;            while ((osstatus == kOTNoError) &amp;&amp; (!gDone))      {        osstatus = DoReadPacket(gEndpoint, bufferToUse);                if (firstTimeFlag == true)              // this is the first time through this loop             // for this call to the handler          firstTimeFlag = false;        else            // increment the counter to indicate that there was a packet to            // handle after reading the previous packet          gBackToBackPackets++;                  if (osstatus != kOTNoDataErr)        {          if (osstatus &lt; 0)            gReadErrors++;          else            gPacketsRead++;        }                  if (TstWantDataFlag(gFlags) &amp;&amp; (osstatus == kOTNoError))        {          if (TstRawModeFlag(gFlags))          {              // if rawmode is on then we want to account for              // the additional 17 bytes which will be at the              // beginning of the packet.            offset = 17;            if (TESTSAP == 0xAA)            {              offset += 5;    // account for the SNAP header            }                          // check if the template is a mentat template and               // adjust the offset to account for the additional              // bytes that the template prepends to the ethernet              // packet.            if (gTemplateType == kMentatTemplate)              offset += sizeof(dl_recv_status_t);          }          else            offset = 0;                    lcounter = gBuffer[DATAOFFSET + offset +0] &lt;&lt; 8;          lcounter |= gBuffer[DATAOFFSET + offset +1];          if (lcounter &gt;= TRIGGEREND)          {            gDone = true;    // we can bail now.          }          else          {            if (lcounter == gCounter)              gInOrder++;            else              gOutOfOrder++;                        gCounter = lcounter + 1;  // prepare gCounter for next incoming packet to compare          }        }      }      break;          default:      DoValueBreak(event, &quot;Unknown event  occurred #           ;g&quot;);      break;            }  /* end switch on event */}/********************************************************************************* CallWNE is implemented to call WaitNextEvent to check for the Command-Q key** sequence.  When this happens, then the gdone flag is set to true********************************************************************************/void CallWNE(void){  EventRecord   event;  char      key;    if (!WaitNextEvent(everyEvent, &amp;event, 15, nil))    event.what = nullEvent;        switch (event.what)  {    case nullEvent:    case mouseDown:    case activateEvt:    case updateEvt:    case kHighLevelEvent:    case osEvt:    case diskEvt:      break;    case autoKey:    case keyDown:      key = event.message &amp; charCodeMask;      switch (key)      {        case 'q':        case 'Q':          if (event.modifiers &amp; cmdKey)          gDone = true;          break;                  case 'a':        case 'A':          if (event.modifiers &amp; cmdKey)          gAbort = true;          break;      }      break;  }  }void MyIdle(void){  EventRecord    event;  OSErr      err;    err = WaitNextEvent(everyEvent, &amp;event, 15 + gNumMemErrs * 5, nil);}void main (void){  OSStatus  osstatus = noErr;  UInt32    selection;  char    drvrname[64];  Boolean    done = false;    WriteApplIntro();  gFlags = 0;  if (osstatus = InitOpenTransport())  {    fprintf(stderr, &quot;\n\nOpen Transport is not installed!\n&quot;);    fprintf(stderr, &quot;\nBye Bye.\n&quot;);  }  else  {    SetOTActiveFlag(gFlags);  // indicate that OT is active    gDummyBuffer = (UInt8*)NewPtr(DATASIZE + 2 * DATASLOP);    if (gDummyBuffer == NULL)      osstatus = memFullErr;  }    PrintAppleTalkPortName();  while (done == false)  {    osstatus = OTSetMemoryLimits(10240000, 0);    if (osstatus != kOTNoError)    {      fprintf(stderr, &quot;\n OTSetMemoryLimits returned %d\n&quot;, osstatus);      osstatus = kOTNoError;    }            if (osstatus != kOTNoError)    {      done = true;      break;    }        ListEnetDrivers();    GetDriverName(drvrname);          // open the default ethernet endpoint    gEndpoint = OTOpenEndpoint(OTCreateConfiguration(drvrname), (OTOpenFlags)NULL, NULL, &amp;osstatus);    if (osstatus != kOTNoError)    {      fprintf(stderr, &quot;\n\nError opening Ethernet endpoint!&quot;);      fprintf(stderr, &quot;\nOTOpenEndpoint returned %d\n&quot;, osstatus);      fprintf(stderr, &quot;\nBye Bye.\n&quot;);      done = true;    }    else      SetEPActiveFlag(gFlags);  // indicate that the endpoint is opened      if (osstatus == kOTNoError)    {      osstatus = OTInstallNotifier(gEndpoint, LLCEventHandler, NULL);      if (osstatus != kOTNoError)      {        fprintf(stderr, &quot;\n\nError installing notifier!&quot;);        fprintf(stderr, &quot;\nOTInstallNotifier returned %d\n&quot;, osstatus);      }    }  // now ready to handle async events      if (osstatus == kOTNoError)    {        // ask whether to use the rawmode option or not      fprintf(stdout, &quot;\nDo you want to use the raw mode option?&quot;);      selection = GetYesNoOption();      if (selection == kQuitTest)      {        fprintf(stderr, &quot;\n\nBye-Bye!&quot;);        osstatus = -1;        done = true;      }      else if (selection == kAcceptOption)        SetUseRawModeFlag(gFlags);      else if (selection == kDeclineOption)        ClrUseRawModeFlag(gFlags);          }      if (osstatus == kOTNoError)    {                // what does the user want to do      selection = GetUserOption();            switch (selection)      {        case kSendTest:          fprintf(stdout, &quot;\nDo you want to turn on AckSends?&quot;);          selection = GetYesNoOption();          if (selection == kQuitTest)          {            fprintf(stderr, &quot;\n\nBye-Bye!&quot;);            done = true;            break;          }          else if (selection == kAcceptOption)          {            SetUseAckSendsFlag(gFlags);          }          else if (selection == kDeclineOption)          {            ClrUseAckSendsFlag(gFlags);            SetTimerThreshold();          }            // pause until the user clicks the mouse button          fprintf(stderr, &quot;Click Mouse to start test\n&quot;);          while (!Button());          DoOTLLCWriteTest();          break;                case kReceiveTest:            // pause until the user clicks the mouse button          fprintf(stderr, &quot;\n\nClick Mouse to start test\n&quot;);          while (!Button());          DoOTLLCReadTest();          break;                case kQuitTest:        default:          fprintf(stderr, &quot;\n\nBye-Bye!&quot;);          done = true;          break;      }    }          if (TstEPActiveFlag(gFlags))    {        // force endpoint to be synchronous      OTSetSynchronous(gEndpoint);      OTCloseProvider(gEndpoint);    }        if (done == false)    {      fprintf(stdout, &quot;\n\nDo you want to repeat the test?&quot;);      selection = GetYesNoOption();      if (selection != kAcceptOption)        done = true;    }  }    if (gDummyBuffer)    DisposePtr((Ptr)gDummyBuffer);    OTSetMemoryLimits(0, 0);      if (TstOTActiveFlag(gFlags))    CloseOpenTransport();    fprintf(stderr, &quot;\nProgram ended&quot;);}void DoValueBreak(long value, const char* message){  static short  sDoErrorBreak = 0;  {    Str255  s,        n = &quot;\p&quot;;    s[0] = strlen(message);    BlockMoveData(message,&amp;s[1],s[0]);    if (value &lt; 0)    {      s[0] += 1;      s[s[0]] = '-';      value = -value;    }    while (value)    {      if (n[0])        BlockMoveData(&amp;n[1],&amp;n[2],n[0]);      n[0]++;      n[1] = 48 + (value % 10);      value /= 10;    }    BlockMoveData(&amp;n[1],&amp;s[s[0]+1],n[0]);    s[0] += n[0];    sDoErrorBreak++;    {      short  cnt = sDoErrorBreak;      s[0]++;      s[s[0]] = ',';      s[0]++;      s[s[0]] = ' ';      n[0] = 0;      while (cnt)      {        if (n[0])          BlockMoveData(&amp;n[1],&amp;n[2],n[0]);        n[0]++;        n[1] = 48 + (cnt % 10);        cnt /= 10;      }      BlockMoveData(&amp;n[1],&amp;s[s[0]+1],n[0]);      s[0] += n[0];    }    DebugStr(s);  }}void GetDriverName(char *name){    fprintf(stdout, &quot;\nEnter the driver name to use&quot;);    fprintf(stdout, &quot;\nEnter an invalid driver name to quit&quot;);    fprintf(stdout, &quot;\n : &quot;);    while (true)    {      gets(name);      if (*name != 0)        break;    }}void SetTimerThreshold(void){  char  chr, str[256];  size_t  len, i;  Boolean  done = false;    while (done == false)  {    fprintf(stdout, &quot;\n Enter the timer threshold&quot;);    fprintf(stdout, &quot;\n This is the number of times that the write loop loops before calling&quot;);    fprintf(stdout, &quot;\n WaitNextEvent. Enter a value of 10000 to never call WNE.&quot;);    fprintf(stdout, &quot;\n Enter a value of 100 to call WNE every 100 packets.\n&quot;);    while (true)    {      gets(str);      if (*str != 0)        break;    }        gTimerThreshold = 0;    len = strlen(str);        for (i = 0; i &lt; len; i++)    {      chr = str[i];      if ((chr &gt;= '0') &amp;&amp; (chr &lt;= '9'))        gTimerThreshold = gTimerThreshold*10 + chr - '0';    }        if (gTimerThreshold != 0)    {      done = true;      fprintf(stdout, &quot;\n The timer threshold is set at %ld\n\n&quot;, gTimerThreshold);      fflush(stdout);    }  }}/*  The following routine prints the name of the port currently being used by AppleTalk  If AppleTalk is using Ethernet, then the fPortName field could be used in the   OpenEndpoint call to open an ethernet endpoint on the same hardware port as AppleTalk*/void PrintAppleTalkPortName(void){  ATSvcRef      atref;  OSStatus      err;  OTPortRef      portref;  OTPortRecord    portrecord;  TEndpointInfo    info;    atref = OTOpenEndpoint(OTCreateConfiguration(kDDPName), 0, &amp;info, &amp;err);    if (err == kOTNoError)  {    portref = OTGetProviderPortRef(atref);    if (portref != nil)    {      if (OTFindPortByRef(&amp;portrecord, portref) == true)      {//        fprintf(stderr, &quot;\n Appletalk port name is %s&quot;, portrecord.fPortName);        portref = portrecord.fChildPorts[0];        if (OTFindPortByRef(&amp;portrecord, portref) == true)          fprintf(stdout, &quot;\n Appletalk child port name is %s&quot;, portrecord.fPortName);        else          fprintf(stdout, &quot;\n Appletalk child port record could not be found using PortRef %lX&quot;, portref);      }      else        fprintf(stdout, &quot;\n Appletalk port record could not be found using PortRef %lX&quot;, portref);    }    else      fprintf(stdout, &quot;\n OTGetProviderPortRef returned nil result&quot;);          OTCloseProvider(atref);  }  else    fprintf(stdout, &quot;\n OTOpenAppleTalkServices returned error %d&quot;, err);    }void ListEnetDrivers(void){  OTPortRecord  portRecord;  Boolean      foundAPort;  UInt32      index;  Str255      userFriendlyName;    fprintf(stdout, &quot;\n The list of drivers present is:\n&quot;);      index = 0;    // iterate thru each OT port record for ethernet ports.    while (foundAPort = OTGetIndexedPort(&amp;portRecord,index))  {    if ((portRecord.fCapabilities &amp; kOTPortIsDLPI) &amp;&amp;      (portRecord.fCapabilities &amp; kOTPortIsTPI) &amp;&amp;      (kOTEthernetDevice == OTGetDeviceTypeFromPortRef(portRecord.fRef)))    {      OTGetUserPortNameFromPortRef(portRecord.fRef, userFriendlyName);      fprintf(stdout, &quot;\n Driver name - %s, &quot;, portRecord.fPortName);      fprintf(stdout, &quot;user readable name is - %#s&quot;, userFriendlyName);            }    index++;  }  fprintf(stdout, &quot;\n&quot;);    }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OTLLCTest/listing3.html%3Fid%3DDTS10000250-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OTLLCTest/listing3.html%3Fid%3DDTS10000250-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OTLLCTest/listing3.html%3Fid%3DDTS10000250-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>