<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Fundamentals Guide: Cocoa Objects</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Cocoa Objects"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002974-CH4" title="Cocoa Objects"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40002974-CH1-SW1">Cocoa Fundamentals Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WhatIsCocoa/WhatIsCocoa.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002974-CH4-SW31" title="Cocoa Objects"></a><h1>Cocoa Objects</h1><p>To say that Cocoa is object-oriented is to invite the question: What is a Cocoa object? This section describes what is distinctive about Objective-C objects and what advantages the language brings to software development. It also shows you how to use Objective-C to send messages to objects and how to handle return values from those messages. (Objective-C is an elegantly simple language, so this is not too hard to do.) This section also describes the root class, <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code>, and explains how to use its programmatic interface to create objects, introspect them, and manage object life cycles</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW42">A Simple Cocoa Command-Line Tool</a>
				
			<br/>
			
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW43">Object-Oriented Programming With Objective-C</a>
				
			<br/>
			
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW35">The Root Class</a>
				
			<br/>
			
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW39">Object Retention and Disposal</a>
				
			<br/>
			
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW17">Object Creation</a>
				
			<br/>
			
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW25">Introspection</a>
				
			<br/>
			
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW33">Object Mutability</a>
				
			<br/>
			
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW34">Class Clusters</a>
				
			<br/>
			
        
			
			
				<a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW32">Creating a Singleton Instance</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002974-CH4-SW42" title="A Simple Cocoa Command-Line Tool"></a><h2>A Simple Cocoa Command-Line Tool</h2><p>Let’s begin with a simple command-line program created using the Foundation framework for Mac OS X. Given a series of arbitrary words as arguments, the program removes redundant occurrences, sorts the remaining list of words in alphabetical order, and prints the list to standard output. <span class="content_text">Listing 2-1</span> shows a typical execution of this program.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW16" title="Listing 2-1Output from a simple Cocoa tool"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Output from a simple Cocoa tool</p><div class="codesample"><table><tr><td scope="row"><pre>localhost> SimpleCocoaTool a z c a l q m z<span></span></pre></td></tr><tr><td scope="row"><pre>a<span></span></pre></td></tr><tr><td scope="row"><pre>c<span></span></pre></td></tr><tr><td scope="row"><pre>l<span></span></pre></td></tr><tr><td scope="row"><pre>m<span></span></pre></td></tr><tr><td scope="row"><pre>q<span></span></pre></td></tr><tr><td scope="row"><pre>z<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 2-2</span> shows the code for an Objective-C version of this program.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW1" title="Listing 2-2Cocoa code for a uniquing and sorting tool"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Cocoa code for a uniquing and sorting tool</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main (int argc, const char * argv[]) {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray *args = [[NSProcessInfo processInfo] arguments];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSCountedSet *cset = [[NSCountedSet alloc] initWithArray:args];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray *sorted_args = [[cset allObjects]<span></span></pre></td></tr><tr><td scope="row"><pre>        sortedArrayUsingSelector:@selector(compare:)];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSEnumerator *enm = [sorted_args objectEnumerator];<span></span></pre></td></tr><tr><td scope="row"><pre>    id word;<span></span></pre></td></tr><tr><td scope="row"><pre>    while (word = [enm nextObject]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("%s\n", [word UTF8String]);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [cset release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This code creates and uses several objects: an autorelease pool for memory management, collection objects (arrays and a set) for “uniquing” and sorting the specified words, and an enumerator object for iterating through the elements in the final array and printing them to standard output.</p><p>The first thing you probably notice about this code is that it is short, perhaps much shorter than a typical <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_333"></a>ANSI C version of the same program. Although much of this code might look strange to you, many of its elements are familiar ANSI C. These include assignment operators, control-flow statements (<code>while</code>), calls to C-library routines (<code>printf</code>), primitive scalar types, and so on. Objective-C obviously has ANSI C underpinnings.</p><p>The rest of this chapter examines the Objective-C elements of this code, using them as examples in discussions on subjects ranging from the mechanics of message-sending to the techniques of memory management. If you haven’t seen Objective-C code before, the code in the example might seem formidably convoluted and obscure, but that impression will melt away soon. Objective-C is actually a simple, elegant programming language that is easy to learn and intuitive to program with.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW43" title="Object-Oriented Programming With Objective-C"></a><h2>Object-Oriented Programming With Objective-C</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_334"></a>Cocoa is pervasively object-oriented, from its paradigms and mechanisms to its event-driven architecture. Objective-C, the development language for Cocoa, is thoroughly object-oriented too, despite its grounding in ANSI C. It provides runtime support for message dispatch and specifies syntactical conventions for defining new classes. Objective-C supports most of the abstractions and mechanisms found in other object-oriented languages such as C++ and Java. These include inheritance, encapsulation, reusability, and polymorphism. </p><p>But Objective-C is different from these other object-oriented languages, often in important ways. For example, Objective-C, unlike <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_335"></a>C++, doesn’t allow operator overloading, templates, or multiple inheritance. </p><p>Although Objective-C doesn’t have these features, its strengths as an object-oriented programming language more than compensate. What follows is an exploration of the special capabilities of Objective-C.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW82" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;Much of this section summarizes information from the definitive guide to Objective-C, <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>. Consult this document for a detailed and comprehensive description of Objective-C.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW44" title="The Objective-C Advantage"></a><h3>The Objective-C Advantage</h3><p>If you’re a procedural programmer new to object-oriented concepts, it might help at first to think of an object as essentially a structure with functions associated with it. This notion is not too far off the reality, particularly in terms of runtime implementation.</p><p>Every <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_336"></a>Objective-C object hides a data structure whose first member—or instance variable—is the “<a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_337"></a>isa pointer.” (Most remaining members are defined by the object’s class and superclasses.) The isa pointer, as the name suggests, points to the object’s class, which is an object in its own right (see <span class="content_text">Figure 2-1</span>) and is compiled from the class definition. The class object maintains a dispatch table consisting essentially of pointers to the methods it implements; it also holds a pointer to its superclass, which has its own dispatch table and superclass pointer. Through this chain of references, an object has access to the method implementations of its class and all its superclasses (as well as all inherited public and protected instance variables). The isa pointer is critical to the message-dispatch mechanism and to the dynamism of Cocoa objects.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW26" title="Figure 2-1An object&acirc;&#128;&#153;s isa pointer"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>An object’s isa pointer</p><img src = "../Art/ns_gadget.gif" alt = "An object’s isa pointer" width="205" height="121"></div><br/><p>This peek behind the object facade gives a highly simplified view of what happens in the Objective-C runtime to enable message-dispatch, inheritance, and other facets of general object behavior. But this information is essential to understanding the major strength of Objective-C, its dynamism. </p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW45" title="The Dynamism of Objective-C"></a><h3>The Dynamism of Objective-C</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_338"></a>Objective-C is a very dynamic language. Its dynamism frees a program from compile-time and link-time constraints and shifts much of the responsibility for symbol resolution to runtime, when the user is in control. Objective-C is more dynamic than other programming languages because its dynamism springs from three sources:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_339"></a>Dynamic typing—determining the class of an object at runtime</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_340"></a>Dynamic binding—determining the method to invoke at runtime</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_341"></a>Dynamic loading—adding new modules to a program at runtime</p></li></ul><p>For dynamic typing, Objective-C introduces the <code>id</code> <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_342"></a>data type, which can represent any Cocoa object. A typical use of this generic object type is shown in this part of the code example from <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW1">Listing 2-2</a></span>:</p><div class="codesample"><table><tr><td scope="row"><pre>id word;<span></span></pre></td></tr><tr><td scope="row"><pre>while (word = [enm nextObject]) {<span></span></pre></td></tr><tr><td scope="row"><pre>// etc....<span></span></pre></td></tr></table></div><p>The <code>id</code> data type makes it possible to substitute any type of object at runtime. You can thereby let runtime factors dictate what kind of object is to be used in your code. Dynamic typing permits associations between objects to be determined at runtime rather than forcing them to be encoded in a static design. <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_343"></a>Static type checking at compile time may ensure stricter data integrity, but in exchange for that integrity, dynamic typing gives your program much greater flexibility. And through <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_344"></a>object introspection (for example, asking a dynamically typed, anonymous object what its class is) you can still verify the type of an object at runtime and thus validate its suitability for a particular operation. (Of course, you can always statically check the types of objects when you need to.)</p><p>Dynamic typing gives substance to <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_345"></a>dynamic binding, the second kind of dynamism in Objective-C. Just as dynamic typing defers the resolution of an object’s class membership until runtime, dynamic binding defers the decision of which method to invoke until runtime. Method invocations are not bound to code during compilation, but only when a message is actually delivered. With both dynamic typing and dynamic binding, you can obtain different results in your code each time you execute it. Runtime factors determine which receiver is chosen and which method is invoked.</p><p>The runtime’s message-dispatch machinery enables dynamic binding. When you send a message to a dynamically typed object, the runtime system uses the receiver’s isa pointer to locate the object’s class, and from there the method implementation to invoke. The method is dynamically bound to the message. And you don’t have to do anything special in your Objective-C code to reap the benefits of dynamic binding. It happens routinely and transparently every time you send a message, especially one to a dynamically typed object.</p><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_346"></a>Dynamic loading, the final type of dynamism, is a feature of Cocoa that depends on Objective-C for runtime support. With dynamic loading, a Cocoa program can load executable code and resources as they’re needed instead of having to load all program components at launch time. The executable code (which is linked prior to loading) often contains new classes that become integrated into the runtime image of the program. Both code and localized resources (including nib files) are packaged in bundles and are explicitly loaded with methods defined in Foundation’s <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> class.</p><p>This “lazy-loading” of program code and resources improves overall performance by placing lower memory demands on the system. Even more importantly, dynamic loading makes applications <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_347"></a>extensible. You can devise a plug-in architecture for your application that allows you and other developers to customize it with additional modules that the application can dynamically load months or even years after the application is released. If the design is right, the classes in these modules will not clash with the classes already in place because each class encapsulates its implementation and has its own name space.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW46" title="Extensions to the Objective-C Language"></a><h3>Extensions to the Objective-C Language</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_348"></a>Objective-C features two extensions to the base language that are powerful tools in software development: categories and protocols. Some extensions introduce different techniques for declaring methods and associating them with a class. Others offer convenient ways to declare and access object properties, enumerate quickly over collections, handle exceptions, and perform other tasks. </p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW30" title="Categories"></a><h4>Categories</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_349"></a>Categories give you a way to add methods to a class without having to make a subclass. The methods in the category become part of the class type (within the scope of your program) and are inherited by all the class’s subclasses. There is no difference at runtime between the original methods and the added methods. You can send a message to any instance of the class (or its subclasses) to invoke a method defined in the category.</p><p>Categories are more than a convenient way to add behavior to a class. You can also use categories to compartmentalize methods, grouping related methods in different categories. Categories can be particularly handy for organizing large classes; you can even put different categories in different source files if, for instance, there are several developers working on the class. </p><p>You declare and implement a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_350"></a>category much as you do a subclass. Syntactically, the only difference is the name of the category, which follows the <code>@interface</code> or <code>@implementation</code> directive and is put in parentheses. For example, say you want to add a method to the <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSArray" target="_top">NSArray</a></code> class that prints the description of the collection in a more structured way. In the header file for the category, you would write declaration code similar to the following: </p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Foundation/NSArray.h> // if Foundation not already imported<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface NSArray (PrettyPrintElements)<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString *)prettyPrintDescription;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Then in the implementation file you’d write code such as:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "PrettyPrintCategory.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation NSArray (PrettyPrintElements)<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString *)prettyPrintDescription {<span></span></pre></td></tr><tr><td scope="row"><pre>    // implementation code here...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>There are some limitations to categories. You cannot use a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_351"></a>category to add any new instance variables to the class. Although a category method can override an existing method, it is not recommended that you do so, especially if you want to augment the current behavior. One reason for this caution is that the category method is part of the class’s interface, and so there is no way to send a message to <code>super</code> to get the behavior already defined by the class. If you need to change what an existing method of a class does, it is better to make a subclass of the class.</p><p>You can define categories that add methods to the root class, <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code>. Such methods are available to <em>all</em> instances and class objects that are linked into your code. Informal protocols—the basis for the Cocoa delegation mechanism—are declared as categories on <code>NSObject</code>. This wide exposure, however, has its dangers as well as its uses. The behavior you add to every object through a category on <code>NSObject</code> could have consequences that you might not be able to anticipate, leading to crashes, data corruption, or worse.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW41" title="Protocols"></a><h4>Protocols</h4><p>The Objective-C extension called a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_352"></a>protocol is very much like an interface in Java. Both are simply a list of method declarations publishing an interface that any class can choose to implement. The methods in the protocol are invoked by messages sent by an instance of some other class. </p><p>The main value of protocols is that they, like categories, can be an alternative to subclassing. They yield some of the advantages of <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_353"></a>multiple inheritance in C++, allowing sharing of interfaces (if not implementations). A protocol is a way for a class to declare an interface while concealing its identity. That interface may expose all or (as is usually the case) only a range of the services the class has to offer. Other classes throughout the class hierarchy, and not necessarily in any inheritance relationship (not even to the root class), can implement the methods of that protocol and so access the published services. With a protocol, even classes that have no knowledge of another’s identity (that is, class type) can communicate for the specific purpose established by the protocol.</p><p>There are two types of protocols: formal and informal. <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_354"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_355"></a>Informal protocols were briefly introduced in <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW30">“Categories.”</a></span> These are categories on <code>NSObject</code>; as a consequence, every object with <code>NSObject</code> as its root object (as well as class objects) implicitly adopts the interface published in the category. To use an informal protocol, a class does not have to implement every method in it, just those methods it’s interested in. For an informal protocol to work, the class declaring the informal protocol must get a positive response to a <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code> message from a target object before sending that object the protocol message. (If the target object did not implement the method there would be a runtime exception.)</p><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_356"></a>Formal protocols are usually what is designated by “protocol” in Cocoa. They allow a class to formally declare a list of methods that are an interface to a vended service. The Objective-C language and runtime system supports formal protocols; the compiler can check for types based on protocols, and objects can introspect at runtime to verify conformance to a protocol. Formal protocols have their own terminology and syntax. The terminology is different for provider and client:</p><ul class="spaceabove"><li class="li"><p>A provider (which usually is a class) <em>declares</em> the formal protocol.</p></li><li class="li"><p>A client class <em>adopts</em> a formal <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_357"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_358"></a>protocol, and by doing so agrees to implement all required methods of the protocol.</p></li><li class="li"><p>A class is said to <em>conform</em> to a formal <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_359"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_360"></a>protocol if it adopts the protocol or inherits from a class that adopts it. (Protocols are inherited by subclasses.)</p></li></ul><p>Both the declaration and the adoption of a protocol have their own syntactical forms in Objective-C. To declare a protocol you must use the <code>@protocol</code><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_361"></a> compiler directive. The following example shows the declaration of the <code><a href="../../../Reference/Foundation/Protocols/NSCoding_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSCoding" target="_top">NSCoding</a></code> protocol (in the Foundation framework’s header file <code>NSObject.h</code>).</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol NSCoding<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)encodeWithCoder:(NSCoder *)aCoder;<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithCoder:(NSCoder *)aDecoder;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Objective-C 2.0 adds a refinement to formal protocols by giving you the option of declaring <em>optional</em> protocol methods as well as required ones. In Objective-C 1.0, the adopter of a protocol had to implement all methods of the protocol. In Objective-C 2.0 protocol methods are still implicitly required, and can be specifically marked as such using the <code>@required</code> directive. But you can also mark blocks of protocol methods for optional implementation using the <code>@optional</code> directive; all methods declared after this directive, unless there is an intervening <code>@required</code>, can be optionally implemented. Consider these declarations:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol MyProtocol<span></span></pre></td></tr><tr><td scope="row"><pre>// implementation this method is required implicitly<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)requiredMethod;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@optional<span></span></pre></td></tr><tr><td scope="row"><pre>// implementation of these methods is optional<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)anOptionalMethod;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)anotherOptionalMethod;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@required<span></span></pre></td></tr><tr><td scope="row"><pre>// implementation of this method is required<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)anotherRequiredMethod;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The class that declares the protocol methods typically does not implement those methods; however, it should invoke these methods in instances of the class that conforms to the protocol. Before invoking optional methods, it should verify that they’re implemented using the <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code> method. </p><p>A class adopts a protocol by specifying the protocol, enclosed by angle brackets, at the end of its <code>@interface</code> <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_362"></a>directive, just after the superclass. A class can adopt multiple protocols by delimiting them with commas. This is how the Foundation <code><a href="../../../Reference/Foundation/Classes/NSData_Class/Reference/Reference.html#//apple_ref/occ/cl/NSData" target="_top">NSData</a></code> class adopts three protocols.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface NSData : NSObject &lt;NSCopying, NSMutableCopying, NSCoding><span></span></pre></td></tr></table></div><p>By adopting these protocols, <code>NSData</code> commits itself to implementing all required methods declared in the protocols. It may also choose to implement methods marked with the  <code>@optional</code> directive. Categories can also adopt protocols, and their adoption becomes part of the definition of their class.</p><p>Objective-C types classes by the protocols they conform to as well as the classes they inherit from. You can check if a class conforms to a particular protocol by sending it a <code>conformsToProtocol:</code> message:</p><div class="codesample"><table><tr><td scope="row"><pre>if ([anObject conformsToProtocol:@protocol(NSCoding)]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // do something appropriate<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In a declaration of a type—a method, instance variable, or function—you can specify protocol conformance as part of the type. You thus get another level of type checking by the compiler, one that’s more abstract because it’s not tied to particular implementations. You use the same syntactical convention as for protocol adoption: Put the protocol name between angle brackets to specify protocol conformance in the type. You often see the dynamic object type, <code>id</code>, used in these declarations, for example:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)draggingEnded:(id &lt;NSDraggingInfo>)sender;<span></span></pre></td></tr></table></div><p>Here the object referred to in the argument can be of any class type, but it must conform to the <code><a href="../../../Reference/ApplicationKit/Protocols/NSDraggingInfo_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSDraggingInfo" target="_top">NSDraggingInfo</a></code> protocol.</p><p>Cocoa provides several examples of protocols other than the ones shown so far. An interesting one is the <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intf/NSObject" target="_top">NSObject</a></code> protocol. Not surprisingly, the <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code> class adopts it, but so does the other root class, <code><a href="../../../Reference/Foundation/Classes/NSProxy_Class/Reference/Reference.html#//apple_ref/occ/cl/NSProxy" target="_top">NSProxy</a></code>. Through the protocol, the <code>NSProxy</code> class can interact with the parts of the Objective-C runtime essential to reference counting, introspection, and other basic aspects of object behavior.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW38" title="Declared Properties"></a><h4>Declared Properties</h4><p>In the object modeling design pattern (see <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW2">“Object Modeling”</a></span>) objects have <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_363"></a>properties. Properties consist of an object’s attributes, such as title and color, and an object’s relationships with other objects. In traditional Objective-C code, you define properties by declaring instance variables and, to enforce encapsulation, by implementing accessor methods to get and set the values of those variables. This a tedious and error-prone task, especially when memory management is a concern (see <span class="content_text"><a href="../AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW5">“Storing and Accessing Properties”</a></span>). </p><p>Objective-C 2.0, which was introduced in Mac OS X version 10.5, offers a syntax for declaring properties and specifying how they are to be accessed. Declaring a property becomes a kind of shorthand for declaring a setter and getter method for the property. With properties, you no longer have to implement accessor methods. Direct access to property values is also available through a new dot-notation syntax. There are three aspects to the syntax of properties: declaration, implementation, and access.</p><p>You can declare <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_364"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_365"></a>properties wherever methods can be declared in a class, category, or protocol declarative section. The syntax for declaring properties is:</p><ul class="simple"><li><p><code>@property(</code><em>attributes...</em><code>)</code><em>type propertyName</em></p></li></ul><p>where <em>attributes</em> are one or more optional attributes (comma-separated if multiple) that affect how the compiler stores instance variables and synthesizes accessor methods. The <em>type</em> element specifies an object type, declared type, or scalar type, such as <code>id</code>, <code>NSString *</code>, <code>NSRange</code>, or <code>float</code>. The property must be backed by an instance variable of the same type and name.  </p><p>The possible <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_366"></a>attributes in a property declaration are the following:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Attribute</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Effect</p></th></tr><tr><td  scope="row"><p><code>getter=</code><em>getterName</em></p><p><code>setter=</code><em>setterName</em></p></td><td ><p>Specifies the names of getter and setter accessor methods (see <span class="content_text"><a href="../AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW5">“Storing and Accessing Properties.”</a></span>) You specify these attributes when you are implementing your own accessor methods and want to control their names.</p></td></tr><tr><td  scope="row"><p><code>readonly</code></p></td><td ><p>Indicates that the property can only be read from, not written to. The compiler does not synthesize a setter accessor or allow a non-synthesized one to be called.</p></td></tr><tr><td  scope="row"><p><code>readwrite</code></p></td><td ><p>Indicates that the property can be read from and written to. This is the default if <code>readonly</code> is not specified.</p></td></tr><tr><td  scope="row"><p><code>assign</code></p></td><td ><p>Specifies that simple assignment should be used in the implementation of the setter; this is the default. If properties are declared in a non-garbage-collected program, you must specify <code>retain</code> or <code>copy</code> for properties that are objects.</p></td></tr><tr><td  scope="row"><p><code>retain</code></p></td><td ><p>Specifies that <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/retain" target="_top">retain</a></code> should be sent to the property (which must be of an object type) upon assignment. Note that <code>retain</code> is a no-op in a garbage-collected environment.</p></td></tr><tr><td  scope="row"><p><code>copy</code></p></td><td ><p>Specifies that <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/copy" target="_top">copy</a></code> should be sent to the property (which must be of an object type) upon assignment. The object’s class must implement the <code><a href="../../../Reference/Foundation/Protocols/NSCopying_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSCopying" target="_top">NSCopying</a></code> protocol.</p></td></tr><tr><td  scope="row"><p><code>nonatomic</code></p></td><td ><p>Specifies that accessor methods are synthesized as nonatomic.  By default, all synthesized accessor methods are <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_367"></a>atomic: a getter method is guaranteed to return a valid value, even when other threads are executing simultaneously. For a discussion of atomic versus nonatomic properties, especially with regard to performance, see “<span class="content_text"><a href="../../ObjectiveC/Articles/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_top">Declared Properties</a></span>“ in The <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>. </p></td></tr></table></div><p>If you specify no attributes and specify <code>@synthesize</code> <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_368"></a>for the implementation, the compiler synthesizes getter and setter methods for the property that use simple assignment and that have the forms <em>propertyName</em> for the getter and <code>set</code><em>PropertyName</em><code>:</code> for the setter.</p><p>In the <code>@implementation</code> blocks of a class definition, you can use the <code>@dynamic</code> <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_369"></a> and <code>@synthesize</code> directives to control whether the compiler synthesizes accessor methods for particular properties. Both directives have the same general syntax:</p><ul class="simple"><li><p><code>@dynamic</code> <em>propertyName</em> [<code>, </code><em>propertyName2</em>...]<code>;</code></p></li><li><p><code>@synthesize</code> <em>propertyName</em> [<code>, </code><em>propertyName2</em>...]<code>;</code></p></li></ul><p>The <code>@dynamic</code> directive tells the compiler that you are implementing accessor methods for the property, either directly or dynamically (such as when dynamically loading code). The <code>@synthesize</code> directive, on the other hand, tells the compiler to synthesize the getter and setter methods if they do not appear in the <code>@implementation</code> block. The syntax for <code>@synthesize</code> also includes an extension that allows you to name a property differently from its instance-variable storage. Consider, for example, the following statement:</p><div class="codesample"><table><tr><td scope="row"><pre>@synthesize title, directReports, role = jobDescrip;<span></span></pre></td></tr></table></div><p>This tells the computer to synthesize accessor methods for properties <code>title</code>, <code>directReports</code>, and <code>role</code>, and to use the <code>jobDescrip</code> instance variable to back the <code>role</code> property.</p><p>Finally, the Objective-C properties feature supports a simplified syntax for <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_370"></a>accessing (getting and setting) properties through the use of dot notation and simple assignment. A few examples suffice to show how easy it is to get the values of properties and set them using this syntax:</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *title = employee.title; // assigns employee title to local variable<span></span></pre></td></tr><tr><td scope="row"><pre>employee.ID = "A542309"; // assigns literal string to employee ID<span></span></pre></td></tr><tr><td scope="row"><pre>// gets last name of this employee's manager<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *lname = employee.manager.lastName;<span></span></pre></td></tr></table></div><p>Note that dot-notation syntax works only for attributes and simple one-to-one relationships, not to-many relationships.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW83" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To learn more about declared properties, read “<span class="content_text"><a href="../../ObjectiveC/Articles/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_top">Declared Properties</a></span>“ in <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW47" title="Fast Enumeration"></a><h4>Fast Enumeration</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_371"></a>Fast enumeration is a language feature introduced in Objective-C 2.0 that gives you a concise syntax for efficient enumeration of collections. It is much faster than the traditional use of <code><a href="../../../Reference/Foundation/Classes/NSEnumerator_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEnumerator" target="_top">NSEnumerator</a></code> objects to iterate through arrays, sets, and dictionaries. Moreover, it ensures safe enumeration by including a mutation guard to prevent modification of a collection during enumeration. (An exception is thrown if a mutation is attempted.)</p><p>The syntax for fast enumeration is similar to that used in scripting languages such as Perl and Ruby; there are two supported versions:</p><ul class="simple"><li><p><code>for</code> <code>(</code> <em>type newVariable</em> <code>in</code> <em>expression</em> <code>) {</code> <em>statements</em> <code>}</code></p></li></ul><p>and</p><ul class="simple"><li><p><em>type</em> <em>existingVariable</em><code>;</code></p><p><code>for</code><code>(</code> <em>existingVariable</em> <code>in</code> <em>expression</em> <code>) {</code> <em>statements</em> <code>}</code></p></li></ul><p><em>expression</em> must evaluate to an object whose class conforms to the <code><a href="../../../Reference/NSFastEnumeration_protocol/Reference/NSFastEnumeration.html#//apple_ref/occ/intf/NSFastEnumeration" target="_top">NSFastEnumeration</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_372"></a>protocol. The fast-enumeration implementation is shared between the Objective-C runtime and the Foundation framework. Foundation declares the <code><a href="../../../Reference/NSFastEnumeration_protocol/Reference/NSFastEnumeration.html#//apple_ref/occ/intf/NSFastEnumeration" target="_top">NSFastEnumeration</a></code> protocol, and the Foundation collection classes—<code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSArray" target="_top">NSArray</a></code>, <code><a href="../../../Reference/Foundation/Classes/NSDictionary_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDictionary" target="_top">NSDictionary</a></code>, and <code><a href="../../../Reference/Foundation/Classes/NSSet_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSet" target="_top">NSSet</a></code>—and the <code>NSEnumerator</code> class adopt the protocol. Other classes that hold collections of other objects, including custom classes, may adopt <code>NSFastEnumeration</code> to take advantage of this feature.</p><p>The following snippet of code illustrates how you might use fast enumeration with <code>NSArray</code> and <code>NSSet</code> objects:</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *array = [NSArray arrayWithObjects:<span></span></pre></td></tr><tr><td scope="row"><pre>        @"One", @"Two", @"Three", @"Four", nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>for (NSString *element in array) {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"element: %@", element);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSSet *set = [NSSet setWithObjects:<span></span></pre></td></tr><tr><td scope="row"><pre>        @"Alpha", @"Beta", @"Gamma", @"Delta", nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSString *setElement;<span></span></pre></td></tr><tr><td scope="row"><pre>for (setElement in set) {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"element: %@", setElement);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW84" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To find out more about fast enumeration, including how a custom collection class can take advantage of this feature, see “<span class="content_text"><a href="../../ObjectiveC/Articles/ocFastEnumeration.html#//apple_ref/doc/uid/TP30001163-CH18" target="_top">Fast Enumeration</a></span>“ in <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW48" title="Using Objective-C"></a><h3>Using Objective-C</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_373"></a>The way work gets done in an object-oriented program is through messages; one object sends a message to another object. Through the message, the sending object requests something from the receiving object (receiver). It requests that the receiver perform some action, return some object or value, or do both things.</p><p>Objective-C adopts a unique syntactical form for <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_374"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_375"></a>messaging. Take the following statement from the SimpleCocoaTool code in <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW1">Listing 2-2</a></span>:</p><div class="codesample"><table><tr><td scope="row"><pre>NSEnumerator *enm = [sorted_args objectEnumerator];<span></span></pre></td></tr></table></div><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_376"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_377"></a>message expression is on the right side of the assignment, enclosed by the square brackets. The left-most item in the message expression is the receiver, a variable or expression representing the object to which the message is sent. In this case, the receiver is <code>sorted_args</code>, an instance of the <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSArray" target="_top">NSArray</a></code> class. Following the receiver is the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_378"></a>message proper, in this case <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/objectEnumerator" target="_top">objectEnumerator</a></code>. (For now, we are going to focus on message syntax and not look too deeply into what this and other messages in SimpleCocoaTool actually do.) The message <code>objectEnumerator</code> invokes a method of the <code>sorted_args</code> object named <code>objectEnumerator</code>, which returns a reference to an object that is held by the variable <code>enm</code> on the left side of the assignment. This variable is statically typed as an instance of the <code><a href="../../../Reference/Foundation/Classes/NSEnumerator_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEnumerator" target="_top">NSEnumerator</a></code> class. You can diagram this statement as:</p><br/><div><img src = "../Art/msg_syntax1.gif" alt = "Object messaging syntax" width="283" height="14"></div><br/><p>However, this diagram is simplistic and not really accurate. A message consists of a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_379"></a> selector name and the parameters of the message. The Objective-C runtime uses a selector name, such as <code>objectEnumerator</code> above, to look up a selector in a table in order to find the method to invoke. A selector is a unique identifier that represents a method and that has a special type, <code>SEL</code>. Because it’s so closely related, the selector name used to look up a selector is frequently called a selector as well. The above statement thus is more correctly shown as:</p><br/><div><img src = "../Art/msg_syntax1a.gif" alt = "Object messaging syntax" ></div><br/><p>Messages often have parameters, or <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_380"></a>arguments. A message with a single argument affixes a colon to the selector name and puts the argument right after the colon. This construct is called a keyword <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_381"></a>; a keyword ends with a colon, and an argument follows the colon. Thus we could diagram a message expression with a single argument (and assignment) as the following:</p><br/><div><img src = "../Art/msg_syntax2.gif" alt = "Object messaging with argument" ></div><br/><p>If a message has multiple arguments, the selector has multiple keywords.  A selector name includes all keywords, including colons, but does not include anything else, such as return type or parameter types. A message expression with multiple keywords (plus assignment) could be diagrammed as follows:</p><br/><div><img src = "../Art/msg_syntax3.gif" alt = "Object messaging with multiple arguments" ></div><br/><p>As with function parameters, the type of an argument must match the type specified in the method declaration. Take as an example the following message expression from SimpleCocoaTool:</p><div class="codesample"><table><tr><td scope="row"><pre>NSCountedSet *cset = [[NSCountedSet alloc] initWithArray:args];<span></span></pre></td></tr></table></div><p>Here <code>args</code>, which is also an instance of the <code>NSArray</code> class, is the argument of the message named <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/initWithArray:" target="_top">initWithArray:</a></code>. </p><p>The <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/initWithArray:" target="_top">initWithArray:</a></code> example cited above is interesting in that it illustrates <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_382"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_383"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_384"></a>nesting. With Objective-C, you can nest one message inside another message; the object returned by one message expression is used as the receiver by the message expression that encloses it. So to interpret nested message expressions, start with the inner expression and work your way outward. The interpretation of the above statement would be:</p><ol class="ol"><li class="li"><p>The <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/alloc" target="_top">alloc</a></code> message is sent to the <code><a href="../../../Reference/Foundation/Classes/NSCountedSet_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCountedSet" target="_top">NSCountedSet</a></code> class, which creates (by allocating memory for it) an uninitialized instance of the class.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW85" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_385"></a>Objective-C classes are objects in their own right and you can send messages to them as well as to their instances. In a message expression, the receiver of a class message is always a class object.</p></div></li><li class="li"><p>The <code>initWithArray:</code> message is sent to the uninitialized instance, which initializes itself with the array <code>args</code> and returns a reference to itself.</p></li></ol><p>Next consider this statement from the <code>main</code> routine of SimpleCocoaTool:</p><div class="codesample"><table><tr><td scope="row"><pre>NSArray *sorted_args = [[cset allObjects] sortedArrayUsingSelector:@selector(compare:)];<span></span></pre></td></tr></table></div><p>What’s noteworthy about this message expression is the argument of the <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/sortedArrayUsingSelector:" target="_top">sortedArrayUsingSelector:</a></code> message. This argument requires the use of <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_386"></a>the <code>@selector</code> compiler directive to create a selector to be used as an argument. </p><p>Let’s pause a moment to review message and method terminology. A method is essentially a function defined and implemented by the class of which the receiver of a message is a member. A message is a selector name (perhaps consisting of one of more keywords) along with its arguments; a message is sent to a receiver and this results in the invocation (or execution) of the method. A message expression encompasses both receiver and message. <span class="content_text">Figure 2-2</span> depicts these relationships.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW19" title="Figure 2-2Message terminology"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>Message terminology</p><img src = "../Art/message_terms.gif" alt = "Message terminology" width="323" height="149"></div><br/><p>Objective-C uses a number of <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_387"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_388"></a>defined types and literals that you won’t find in ANSI C. In some cases, these types and literals replace their ANSI C counterparts. <span class="content_text">Table 2-1</span> describes a few of the important ones, including the allowable literals for each type. </p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW5" title="Table 2-1Important Objective-C defined types and literals"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Important Objective-C defined types and literals</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type </p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description and literal</p></th></tr><tr><td  scope="row"><p><code>id</code></p></td><td ><p>The dynamic object type. Its negative literal is <code>nil</code>.</p></td></tr><tr><td  scope="row"><p><code>Class</code></p></td><td ><p>The dynamic class type. Its negative literal is <code>Nil</code>.</p></td></tr><tr><td  scope="row"><p><code>SEL</code></p></td><td ><p>The data type (<code>typedef</code>) of a selector. The negative literal of this type is <code>NULL</code>.</p></td></tr><tr><td  scope="row"><p><code>BOOL</code></p></td><td ><p>A Boolean type. The literal values are <code>YES</code> and <code>NO</code>.</p></td></tr></table></div><p>In your program’s control-flow statements, you can test for the presence (or absence) of the appropriate negative literal to determine how to proceed. For example, the following <code>while</code> statement from the SimpleCocoaTool code implicitly tests the <code>word</code> object variable for the presence of a returned object (or, in another sense, the absence of <code>nil</code>):</p><div class="codesample"><table><tr><td scope="row"><pre>while (word = [enm nextObject]) {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("%s\n", [word UTF8String]);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In Objective-C, you can often send a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_389"></a>message to <code>nil</code> with no ill effects. Return values from messages sent to <code>nil</code> are guaranteed to work as long as what is returned is typed as an object. </p><p>One final thing to note about the SimpleCocoaTool code is something that is not readily apparent if you’re new to Objective-C. Compare this statement:</p><div class="codesample"><table><tr><td scope="row"><pre>NSEnumerator *enm = [sorted_args objectEnumerator];<span></span></pre></td></tr></table></div><p>with this one:</p><div class="codesample"><table><tr><td scope="row"><pre>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr></table></div><p>On the surface, they seem to do identical things; both return a reference to an object. However there is an important semantic difference (for memory-managed code) that has to do with the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_390"></a>ownership of the returned object, and hence the responsibility for freeing it. In the first statement, the SimpleCocoaTool program does not own the returned object. In the second statement, the program creates the object and so owns it. The last thing the program does is to send the <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">release</a></code> message to the created object, thus freeing it. The only other explicitly created object (the <code>NSCountedSet</code> instance) is also explicitly released at the end of the program. For a summary of the memory-management policy for object ownership and disposal, and the methods to use to enforce this policy, see  <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW10">“How Memory Management Works”</a></span><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_391"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_392"></a>.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW35" title="The Root Class"></a><h2>The Root Class</h2><p>Just by themselves, the Objective-C language and runtime are not enough to construct even the simplest object-oriented program, at least not easily. Something is still missing: a definition of the fundamental behavior and interface common to all objects. A root class supplies that definition.</p><p>A <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_393"></a>root class is so-called because it lies at the root of a class hierarchy—in this case, the Cocoa class hierarchy. The root class inherits from no other class, and all other classes in the hierarchy ultimately inherit from it. Along with the Objective-C language, the root class is primarily where Cocoa directly accesses and interacts with the Objective-C runtime. Cocoa objects derive the ability to behave as objects in large part from the root class.</p><p>Cocoa supplies two root classes: <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_394"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_395"></a><code><a href="../../../Reference/Foundation/Classes/NSProxy_Class/Reference/Reference.html#//apple_ref/occ/cl/NSProxy" target="_top">NSProxy</a></code>. Cocoa defines the latter class, an abstract superclass, for objects that act as stand-ins for other objects; thus <code>NSProxy</code> is essential in the distributed objects architecture. Because of this specialized role, NSProxy appears infrequently in Cocoa programs. When Cocoa developers refer to a root or base class, they almost always mean <code>NSObject</code>.</p><p>This section looks at <code>NSObject</code>, how it interacts with the runtime, and the basic behavior and interface it defines for all Cocoa objects. Primary among these are the methods it declares for allocation, initialization, memory management, introspection, and runtime support. These concepts are fundamental to an understanding of Cocoa.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW49" title="NSObject"></a><h3>NSObject</h3><p><code>NSObject</code> is the root class of most Objective-C class hierarchies; it has no superclass. From <code>NSObject</code>, other classes inherit a basic interface to the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_396"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_397"></a>run-time system for the Objective-C language, and its instances obtain their ability to behave as objects. </p><p>Although it is not strictly an abstract class, <code>NSObject</code> is virtually one. By itself, an <code>NSObject</code> instance cannot do anything useful beyond being a simple object. To add any attributes and logic specific to your program, you must create one or more classes inheriting from NSObject or from any other class derived from <code>NSObject</code>.</p><p><code>NSObject</code> adopts the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_398"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intf/NSObject" target="_top">NSObject</a></code> protocol (see <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW13">“Root Class—and Protocol”</a></span>). The <code>NSObject</code> protocol allows for multiple root objects. For example, <code>NSProxy</code>, the other root class, does not inherit from <code>NSObject</code> but adopts the <code>NSObject</code> protocol so that it shares a common interface with other Objective-C objects.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW13" title="Root Class&acirc;&#128;&#148;and Protocol"></a><h3>Root Class—and Protocol</h3><p><code>NSObject</code> is the name not only of a class but of a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_399"></a>protocol. Both are essential to the definition of an object in Cocoa. The <code>NSObject</code> protocol specifies the basic programmatic interface required of <em>all</em> root classes in Cocoa; thus not only the <code>NSObject</code> class adopts the identically named protocol, but the other Cocoa root class, <code>NSProxy</code>, adopts it as well. The <code>NSObject</code> class further specifies the basic programmatic interface for any Cocoa object that is not a proxy object.</p><p>A protocol such as <code>NSObject</code> is used in the overall definition of Cocoa objects (rather than including those protocol methods in the class interface) to make multiple root classes possible. Each root class shares a common interface, as defined by the protocols they adopt.</p><p>In another sense, <code>NSObject</code> is not the only “root” protocol. Although the <code>NSObject</code> class does not formally adopt the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_400"></a><code><a href="../../../Reference/Foundation/Protocols/NSCopying_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSCopying" target="_top">NSCopying</a></code>, <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_401"></a><code><a href="../../../Reference/Foundation/Protocols/NSMutableCopying_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSMutableCopying" target="_top">NSMutableCopying</a></code>, and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_402"></a><code><a href="../../../Reference/Foundation/Protocols/NSCoding_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSCoding" target="_top">NSCoding</a></code> protocols, it declares and implements methods related to those protocols. (Moreover, the <code>NSObject.h</code> header file, which contains the definition of the <code>NSObject</code> class, also contains the definitions of all four protocols mentioned above.) Object copying, encoding, and decoding are fundamental aspects of object behavior. Many, if not most, subclasses are expected to adopt or conform to these protocols. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW86" title="Note"></a><p><strong>Note:</strong>&nbsp;Other Cocoa classes can (and do) add methods to <code>NSObject</code> through categories. These categories are often informal protocols used in delegation; they permit the delegate to choose which methods of the category to implement. However, these categories on <code>NSObject</code> are not considered part of the fundamental object interface.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW50" title="Overview of Root-Class Methods"></a><h3>Overview of Root-Class Methods</h3><p>The <code>NSObject</code> root class, along with the adopted <code>NSObject</code> protocol and other “root” protocols, specify the following interface and behavioral characteristics for all non-proxy Cocoa objects:</p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_403"></a>Allocation, <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_404"></a>initialization, and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_405"></a>duplication</strong>. Some methods of <code>NSObject</code> (including some from adopted protocols) deal with the creation, initialization, and duplication of objects:</p><ul class="nested"><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_406"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/alloc" target="_top">alloc</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_407"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/allocWithZone:" target="_top">allocWithZone:</a></code> methods allocate memory for an object from a memory zone and set the object to point to its runtime class definition.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_408"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/init" target="_top">init</a></code> method is the prototype for object initialization, the procedure that sets the instance variables of an object to a known initial state. The class methods <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_409"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/initialize" target="_top">initialize</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_410"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/load" target="_top">load</a></code> give classes a chance to initialize themselves. </p></li><li class="nested li"><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_411"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/new" target="_top">new</a></code> is a convenience method that combines simple allocation and initialization.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_412"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/copy" target="_top">copy</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_413"></a><code><a href="../../../Reference/Foundation/Protocols/NSCopying_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSCopying/copyWithZone:" target="_top">copyWithZone:</a></code> methods make copies of any object that is a member of a class implementing these methods (from the NSCopying protocol); the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_414"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/mutableCopy" target="_top">mutableCopy</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_415"></a><code><a href="../../../Reference/Foundation/Protocols/NSMutableCopying_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSMutableCopying/mutableCopyWithZone:" target="_top">mutableCopyWithZone:</a></code> (defined in the <code><a href="../../../Reference/Foundation/Protocols/NSMutableCopying_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSMutableCopying" target="_top">NSMutableCopying</a></code> protocol) are implemented by classes that want to make mutable copies of their objects.</p></li></ul><p>See <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW17">“Object Creation”</a></span> for more information.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_416"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_417"></a>Object retention and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_418"></a>disposal</strong>. The following methods are particularly important to an object-oriented program that uses the traditional, and explicit, form of memory management: </p><ul class="nested"><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_419"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/retain" target="_top">retain</a></code> method increments an object’s retain count.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_420"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">release</a></code> method decrements an object’s retain count.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_421"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/autorelease" target="_top">autorelease</a></code> method also decrements an object’s retain count, but in a deferred fashion.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_422"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/retainCount" target="_top">retainCount</a></code> method returns an object’s current retain count.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_423"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/dealloc" target="_top">dealloc</a></code> method is implemented by class to release its objects’ instance variables and free dynamically allocated memory.</p></li></ul><p>See the <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW10">“How Memory Management Works”</a></span> for more information about explicit memory management.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_424"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_425"></a>Introspection and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_426"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_427"></a>comparison</strong>. Many <code>NSObject</code> methods enable you to make runtime queries about an object. These introspection methods help to discover an object’s position in the class hierarchy, determine whether it implements a certain method, and test whether it conforms to a specific protocol. Some of these are class methods only.</p><ul class="nested"><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_428"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/superclass" target="_top">superclass</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_429"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/class" target="_top">class</a></code> methods (class and instance) return the receiver’s superclass and class, respectively, as <code>Class</code> objects.</p></li><li class="nested li"><p>You can determine the class membership of objects with the methods <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_430"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isKindOfClass:" target="_top">isKindOfClass:</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_431"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isMemberOfClass:" target="_top">isMemberOfClass:</a></code>; the latter method is for testing whether the receiver is an instance of the specified class. The class method <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_432"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/isSubclassOfClass:" target="_top">isSubclassOfClass:</a></code> tests class inheritance.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_433"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code> method tests whether the receiver implements a method identified by a selector. The class method <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_434"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/instancesRespondToSelector:" target="_top">instancesRespondToSelector:</a></code> tests whether instances of a given class implement the specified method.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_435"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/conformsToProtocol:" target="_top">conformsToProtocol:</a></code> method tests whether the receiver (object or class) conforms to a given protocol,.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_436"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isEqual:" target="_top">isEqual:</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_437"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/hash" target="_top">hash</a></code> methods are used in object comparison.</p></li><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_438"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/description" target="_top">description</a></code> method allows an object to return a string describing its contents; this output is often used in debugging (“print object” command) and by the “%@” specifier for objects in formatted strings.</p></li></ul><p>See <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW25">“Introspection”</a></span> for more information.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_439"></a>Object encoding and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_440"></a>decoding</strong>. The following methods pertain to object encoding and decoding (as part of the archiving process):</p><ul class="nested"><li class="nested li"><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_441"></a><code><a href="../../../Reference/Foundation/Protocols/NSCoding_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSCoding/encodeWithCoder:" target="_top">encodeWithCoder:</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_442"></a><code><a href="../../../Reference/Foundation/Protocols/NSCoding_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSCoding/initWithCoder:" target="_top">initWithCoder:</a></code> methods are the sole members of the NSCoding protocol. The first allows an object to encode its instance variables and the second enables an object to initialize itself from decoded instance variables.</p></li><li class="nested li"><p>The NSObject class declares other methods related to object encoding: <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/classForCoder" target="_top">classForCoder</a></code>, <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_443"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/replacementObjectForCoder:" target="_top">replacementObjectForCoder:</a></code>, and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_444"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/awakeAfterUsingCoder:" target="_top">awakeAfterUsingCoder:</a></code>. </p></li></ul><p>See <em><a href="../../Archiving/index.html#//apple_ref/doc/uid/10000047i" target="_top">Archives and Serializations Programming Guide for Cocoa</a></em> for further information.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_445"></a>Message forwarding</strong>. The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_446"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/forwardInvocation:" target="_top">forwardInvocation:</a></code> and related methods permit an object to forward a message to another object.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_447"></a>Message dispatch</strong>. A set of methods beginning with <code>performSelector...</code> allow you to dispatch messages after a specified delay and to dispatch messages (synchronously or asynchronously) from a secondary thread to the main thread.</p></li></ul><p><code>NSObject</code> has several other methods, including class methods for versioning and posing (the latter lets a class present itself to the runtime as another class). It also includes methods that let you access runtime data structures, such as method selectors and function pointers to method implementations.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW51" title="Interface Conventions"></a><h3>Interface Conventions</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_448"></a>Some <code>NSObject</code> methods are meant only to be invoked while others are intended to be overridden. For example, most subclasses should not override <code>allocWithZone:</code> but they should implement <code>init</code>—or at least an initializer that ultimately invokes the root-class <code>init</code> method (see <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW17">“Object Creation”</a></span>). Of those methods that subclasses are expected to override, <code>NSObject</code>’s implementation either does nothing or returns some reasonable default value such as <code>self</code>. These default implementations make it possible to send basic messages such as <code>init</code> to any Cocoa object—even to an object whose class doesn’t override them—without risking a runtime exception. It’s not necessary to check (using <code>respondsToSelector:</code>) before sending the message. More importantly, the “placeholder” methods of <code>NSObject</code> define a common structure for Cocoa objects and establish conventions that, when followed by all classes, make object interactions more reliable.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW52" title="Instance and Class Methods"></a><h3>Instance and Class Methods</h3><p>The runtime system treats methods defined in the root class in a special way. Instance methods defined in a root class can be performed both by instances and by class objects. Therefore, all class objects have access to the instance methods defined in the root class. Any class object can perform any root instance method, provided it doesn’t have a class method with the same name.</p><p>For example, a class object could be sent messages to perform <code>NSObject</code>’s <code>respondsToSelector:</code> and <code>performSelector:withObject:</code> instance methods:</p><div class="codesample"><table><tr><td scope="row"><pre>SEL method = @selector(riskAll:);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ([MyClass respondsToSelector:method])<span></span></pre></td></tr><tr><td scope="row"><pre>    [MyClass performSelector:method withObject:self];<span></span></pre></td></tr></table></div><p>Note that the only instance methods available to a class object are those defined in its root class. In the example above, if <code>MyClass</code> had re-implemented either <code>respondsToSelector:</code> or <code>performSelector:withObject:</code>, those new versions would be available only to instances. The class object for <code>MyClass</code> could perform only the versions defined in the <code>NSObject</code> class. (Of course, if <code>MyClass</code> had implemented <code>respondsToSelector:</code> or <code>performSelector:withObject:</code> as class methods rather than instance methods, the class would perform those new versions.)</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW39" title="Object Retention and Disposal"></a><h2>Object Retention and Disposal</h2><p>Beginning with Mac OS X version 10.5, Objective-C gives you two ways to ensure that objects persist when they are needed and are destroyed when they are no longer needed, thus freeing up memory. The preferred approach is to use the technology of garbage collection: the runtime detects objects that are no longer needed and disposes of them automatically. (It also happens to be the simpler approach in most cases.) The second approach, called memory management, is based on reference counting: an object carries with it a numerical value reflecting the current claims on the object; when this value reaches zero, the object is deallocated.</p><p>The amount of work that you, as a developer writing Objective-C code, must do to take advantage of garbage collection or memory management varies considerably.</p><ul class="ul"><li class="li"><p><strong>Garbage Collection</strong>. To enable <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_449"></a>garbage collection, turn on the Enable Objective-C Garbage Collection build setting (the <code>-fobjc-gc</code> flag). For each of your custom classes you might also have to implement the <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/finalize" target="_top">finalize</a></code> method to remove instances as a notification observers and to free any resources that are not instance variables. Also, ensure that in your nib files the object acting as File’s Owner maintains an outlet connection to each top-level nib object you want to persist.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW87" title="iPhone OS Note:"></a><p><strong>iPhone OS Note::</strong>&nbsp;Garbage collection is not supported on iPhone OS.</p></div></li><li class="li"><p><strong>Memory Management</strong>. <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_450"></a>In memory-managed code each call that makes a claim of ownership on an object—object allocation and initialization, object copying, and <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/retain" target="_top">retain</a></code>—must be balanced with a call that removes that claim—<code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">release</a></code> and <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/autorelease" target="_top">autorelease</a></code>. When the object’s retain count (reflecting the number of claims on it) reaches zero, the object is deallocated and the memory occupied by the object is freed.</p></li></ul><p>In addition to being easier to implement, garbage-collected code has several advantages over memory-managed code. Garbage collection provides a simple, consistent model for all participating programs while avoiding problems such as retain cycles. It also simplifies the implementation of accessor methods and makes it easier to ensure thread and exception safety.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;Although memory-management methods are “no-ops” in a garbage-collected application, there are still intractable differences between certain programming paradigms and patterns used in the two models. Therefore it is not recommended that you migrate a memory-managed application to a source base that tries to support both memory management and garbage collection. Instead, create a new full-version release that supports garbage collection.</p><p></p></div><p>The following sections explore how garbage collection and memory management work by following the life cycle of objects from their creation to their destruction. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW88" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To learn all about about the garbage-collection feature of Objective-C, read <em><a href="../../GarbageCollection/index.html#//apple_ref/doc/uid/TP40002431" target="_top">Garbage Collection Programming Guide</a></em>. Memory management is discussed in detail in <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW53" title="How Garbage Collection Works"></a><h3>How Garbage Collection Works</h3><p>To the garbage collector, objects in a program are either <em>reachable</em> or are not <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_451"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_452"></a>reachable. Periodically the collector scans through the objects and collects those that are reachable. Those objects that aren’t reachable—the “garbage” objects—are finalized (that is, <code>finalize</code> is invoked). Subsequently, the memory they had occupied is freed.</p><p>The critical notion behind the architecture of the Objective-C garbage collector is the set of factors that constitute a reachable object. These start with an initial root set of objects: global variables (including <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/c/data/NSApp" target="_top">NSApp</a></code>), stack variables, and objects with external references (that is, outlets). The objects of the initial root set are never treated as garbage and therefore persist throughout the runtime life of the program. The collector adds to this initial set all objects that are directly reachable through strong references as well as all possible references found in the call stacks of every Cocoa thread. The garbage collector recursively follows strong references from the root set of objects to other objects, and from those objects to other objects, until all potentially reachable objects have been accounted for. (All references from one object to another object are considered strong references by default; weak references have to be explicitly marked as such.) In other words, a nonroot object persists at the end of a collection cycle only if the collector can reach it via strong references from a root object. </p><p><span class="content_text">Figure 2-3</span> illustrates the general path the collector follows when it looks for reachable objects. But it also shows a few other important aspects of the garbage collector. The collector scans only a portion of a Cocoa program’s virtual memory for reachable objects. <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_453"></a>Scanned memory includes the call stacks of threads, global variables, and the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_454"></a>auto zone, an area of memory from which all garbage collected blocks of memory are dispensed. The collector does not scan the malloc zone, which is the zone from which blocks of memory or allocated via the <code>malloc</code> function. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW37" title="Figure 2-3Reachable and unreachable objects"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>Reachable and unreachable objects</p><img src = "../Art/gc_reach.jpg" alt = "Reachable and unreachable objects" ></div><br/><p>Another thing the diagram illustrates is that objects may have strong references to other objects, but if there is no chain of strong references that leads back to a root object, the object is considered unreachable and is disposed of at the end of a collection cycle. And indeed these references can be circular, but in garbage collection the circular references do not cause memory leaks, as do <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_455"></a>retain cycles in memory-managed code. All of these objects are disposed of when they are no longer reachable.</p><p>The Objective-C garbage collector is request-driven, not demand-driven. It initiates collection cycles only upon request, which Cocoa makes at intervals optimized for performance or when a certain memory threshold has been exceeded. You can also request collections using methods of the <code><a href="../../../Reference/NSGarbageCollector_class/Introduction/Introduction.html#//apple_ref/occ/cl/NSGarbageCollector" target="_top">NSGarbageCollector</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_456"></a>class. The garbage collector is also generational. It makes not only exhaustive, or full, collections of program objects periodically, but it makes incremental collections based on the “generation” of objects. A object’s generation is determined by when it was allocated. Incremental collections, which are faster and more frequent than full collections, affect the more recently allocated objects. (Most objects are assumed to “die young”; if an object survives the first collection, it is likely to be intended to have a longer life.)</p><p>The garbage collector runs on one thread of a Cocoa program. During a collection cycle it will stop secondary threads to determine which objects in those threads are unreachable. But it never stops all threads at once, and it stops each thread for as short a time as possible. The collector is also conservative in that it never compacts auto-zone memory by relocating blocks of memory or updating pointers; once allocated, an object always stays in its original memory location.<a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_457"></a></p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW10" title="How Memory Management Works"></a><h3>How Memory Management Works</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_458"></a>In memory-managed Objective-C code, a Cocoa <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_459"></a>object exists over a life span which, potentially at least, has distinct stages. It is created, initialized, and used (that is, other objects send messages to it). It is possibly retained, copied, or archived, and eventually it is released and destroyed. The following discussion charts the life of a typical object without going into much detail—yet.</p><p>Let’s begin at the end, at the way objects are disposed of when garbage collection is turned off. In this context Cocoa and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_460"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_461"></a>Objective-C opt for a voluntary, policy-driven procedure for keeping objects around and disposing of them when they’re no longer needed.</p><p>This procedure and policy rest on the notion of <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_462"></a>reference counting. Each Cocoa object carries with it an integer indicating the number of other objects (or even procedural code sites) that are interested in its persistence. This integer is referred to as the object’s <em><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_463"></a>retain count</em> (“retain” is used to avoid overloading the term “reference”). When you create an object, either by using a class factory method or by using the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_464"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/alloc" target="_top">alloc</a></code>  or <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_465"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/allocWithZone:" target="_top">allocWithZone:</a></code> class methods, Cocoa does a couple of very important things: </p><ul class="spaceabove"><li class="li"><p>It sets the object’s <code>isa</code> <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_466"></a>pointer—the <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code> class's sole public instance variable—to point to the object’s class, thus integrating the object into the runtime’s view of the class hierarchy. (See <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW17">“Object Creation”</a></span> for further information.)</p></li><li class="li"><p>It sets the object’s retain count—a kind of hidden instance variable managed by the runtime—to one. (The assumption here is that an object’s creator is interested in its persistence.)</p></li></ul><p>After <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_467"></a>object allocation, you generally initialize an object by setting its instance variables to reasonable initial values. (<code>NSObject</code> declares the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_468"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/init" target="_top">init</a></code> method as the prototype for this purpose.) The object is now ready to be used; you can send messages to it, pass it to other objects, and so on.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW89" title="Note"></a><p><strong>Note:</strong>&nbsp;Because an initializer can return an object other than the one explicitly allocated, the convention is to nest the <code>alloc</code> message expression in the <code>init</code> message (or other initializer)—for example: </p><code>id anObj = [[MyClass alloc] init];</code></p></div><p>When you release an object—that is, send a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_469"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">release</a></code> message to it—<code>NSObject</code> decrements its retain count. If the retain count falls from one to zero, the object is deallocated. <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_470"></a>Deallocation takes place in two steps. First, the object’s <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_471"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/dealloc" target="_top">dealloc</a></code> method is invoked to release instance variables and free dynamically allocated memory. Then the operating system destroys the object itself and reclaims the memory the object once occupied.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_7" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should never directly invoke an object’s <code>dealloc</code> method.</p><p></p></div><p>What if you don’t want an object to go away any time soon? If after receiving an object from somewhere you send it a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_472"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/retain" target="_top">retain</a></code> message, the object’s retain count is incremented to two. Now two <code>release</code> messages are required before deallocation occurs. <span class="content_text">Figure 2-4</span> depicts this rather simplistic scenario.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW20" title="Figure 2-4The life cycle of an object&acirc;&#128;&#148;simplified view"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>The life cycle of an object—simplified view</p><img src = "../Art/object_lifecycle_1.gif" alt = "The life cycle of an object—simplified view" width="431" height="274"></div><br/><p>Of course, in this scenario the creator of an object has no need to retain the object. <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_473"></a>It owns the object already. But if this creator were to pass the object to another object in a message, the situation changes. In an Objective-C program, an object received from some other object is always assumed to be valid within the scope it is obtained. The receiving object can send messages to the received object and can pass it to other objects. This assumption requires the sending object to “behave” and not prematurely free the object while a client object has a reference to it. </p><p>If the client object wants to keep the received object around after it goes out of programmatic scope, it can retain it—that is, send it a <code>retain</code> message. Retaining an object increments its retain count, thereby expressing an ownership interest in the object. The client object assumes a responsibility to release the object at some later time. If the creator of an object releases it, but a client object has retained that same object, the object persists until the client releases it. <span class="content_text">Figure 2-5</span> illustrates this sequence.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW14" title="Figure 2-5Retaining a received object"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>Retaining a received object</p><img src = "../Art/object_lifecycle_2.gif" alt = "Retaining a received object" width="528" height="207"></div><br/><p>Instead of retaining an object you could <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_474"></a>copy it by sending it a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_475"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/copy" target="_top">copy</a></code> or <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_476"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/copyWithZone:" target="_top">copyWithZone:</a></code> message. (Many, if not most, subclasses encapsulating some kind of data adopt or conform to this protocol.) Copying an object not only duplicates it but almost always resets its retain count to one (see <span class="content_text">Figure 2-6</span>). The copy can be shallow or deep, depending on the nature of the object and its intended usage. A deep copy duplicates the objects held as instance variables of the copied object while a shallow copy duplicates only the references to those instance variables. </p><p>In terms of usage, what differentiates a <code>copy</code> from a <code>retain</code> is that the former claims the object for the sole use of the new owner; the new owner can mutate the copied object without regard to its origin. Generally you copy an object instead of retaining it when it is a value object—that is, an object encapsulating some primitive value. This is especially true when that object is mutable, such as an <code><a href="../../../Reference/Foundation/Classes/NSMutableString_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableString" target="_top">NSMutableString</a></code>. For immutable objects, <code>copy</code> and <code>retain</code> can be equivalent and might be implemented similarly.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW21" title="Figure 2-6Copying a received object"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>Copying a received object</p><img src = "../Art/object_lifecycle_3.gif" alt = "Copying a received object" width="527" height="207"></div><br/><p>You might have noticed a potential problem with this scheme for managing the object life cycle. An object that creates an object and passes it to another object cannot always know when it can release the object safely. There could be multiple references to that object on the call stack, some by objects unknown to the creating object. If the creating object releases the created object and then some other object sends a message to that now-destroyed object, the program could crash. To get around this problem, Cocoa introduces a mechanism for deferred deallocation called <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_477"></a>autoreleasing.</p><p>Autoreleasing makes use of <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_478"></a>autorelease pools (defined by the <code><a href="../../../Reference/Foundation/Classes/NSAutoreleasePool_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAutoreleasePool" target="_top">NSAutoreleasePool</a></code> class). A autorelease pool is a collection of objects within an explicitly defined scope that are marked for eventual release. Autorelease pools can be nested. When you send an object an <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_479"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/autorelease" target="_top">autorelease</a></code> message, a reference to that object is put into the most immediate autorelease pool. It is still a valid object, so other objects within the scope defined by the autorelease pool can send messages to it. When program execution reaches the end of the scope, the pool is released and, as a consequence, all objects in the pool are released as well (see <span class="content_text">Figure 2-7</span>). If you are developing an application you may not need to set up an autorelease pool; the Application Kit automatically sets up an autorelease pool scoped to the application’s event cycle.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW27" title="Figure 2-7An autorelease pool"></a><p><strong>Figure 2-7&nbsp;&nbsp;</strong>An autorelease pool</p><img src = "../Art/autoreleasepool.gif" alt = "An autorelease pool" width="454" height="313"></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW90" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;Because on iPhone OS an application executes in a more memory-constrained environment, the use of autorelease pools is discouraged in methods or blocks of code (for example, loops) where an application creates many objects. Instead, you should explicitly release objects whenever possible.</p></div><p>So far the discussion of the object life cycle has focused on the mechanics of managing objects through that cycle. But a policy of object ownership guides the use of these mechanisms. This <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_480"></a>policy can be summarized as follows:</p><ul class="spaceabove"><li class="li"><p>If you <em>create</em> an object by allocating and initializing it (for example, <code>[[MyClass alloc] init]</code>), you own the object and are responsible for releasing it. This rule also applies if you use the NSObject convenience method <code>new</code>.</p></li><li class="li"><p>If you <em>copy</em> an object, you own the copied object and are responsible for releasing it.</p></li><li class="li"><p>If you <em>retain</em> an object, you have partial ownership of the object and must release it when you no longer need it.</p></li></ul><p>Conversely,</p><ul class="spaceabove"><li class="li"><p>If you receive an object from some other object, you do not own the object and should not release it. (There are a handful of exceptions to this rule, which are explicitly noted in the reference documentation.)</p></li></ul><p>As with any set of rules, there are exceptions and “gotchas”:</p><ul class="spaceabove"><li class="li"><p>If you create an object using a class factory method (such as the <code>NSMutableArray</code> <code><a href="../../../Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html#//apple_ref/occ/clm/NSMutableArray/arrayWithCapacity:" target="_top">arrayWithCapacity:</a></code> method), assume that the object you receive has been autoreleased. You should not release the object yourself and should retain it if you want to keep it around.</p></li><li class="li"><p>To avoid cyclic references, a child object should never retain its parent. (A parent is the creator of the child or is an object holding the child as instance variable.) </p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW91" title="Note"></a><p><strong>Note:</strong>&nbsp;“Release” in the above guidelines means sending either a <code>release</code> message or an <code>autorelease</code> message to an object.</p></div><p>If you do not follow this ownership policy, two bad things are likely to happen in your Cocoa program. Because you did not release created, copied, or retained objects, your program is now leaking memory. Or your program crashes because you sent a message to an object that was deallocated out from under you. And here’s a further caveat: debugging these problems can be a time-consuming affair. </p><p>A further basic event that could happen to an object during its life cycle is archiving. Archiving converts the web of interrelated objects that comprise an object-oriented program—the object graph—into a persistent form (usually a file) that preserves the identity and relationships of each object in the graph. When the program is unarchived, its object graph is reconstructed from this archive. To participate in archiving (and unarchiving), an object must be able to encode (and decode) its instance variables using the methods of the NSCoder class. NSObject adopts the NSCoding protocol for this purpose. For more information on the archiving of objects, <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_481"></a>see “Object Archives”.<a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_482"></a></p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW17" title="Object Creation"></a><h2>Object Creation</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_483"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_484"></a>The creation of a Cocoa object always takes place in two stages: allocation and initialization. Without both steps an object generally isn’t usable. Although in almost all cases initialization immediately follows allocation, the two operations play distinct roles in the formation of an object. </p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW54" title="Allocating an Object"></a><h3>Allocating an Object</h3><p>When you <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_485"></a>allocate an object, part of what happens is what you might expect, given the term “allocate.” Cocoa allocates enough memory for the object from a region of application virtual memory. To calculate how much memory to allocate, it takes the object’s instance variables into account—including their types and order—as specified by the object’s class. </p><p>To allocate an object, you send the message <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_486"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/alloc" target="_top">alloc</a></code>  or <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_487"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/allocWithZone:" target="_top">allocWithZone:</a></code> to the object’s class. In return, you get a “raw” (uninitialized) instance of the class. The <code>alloc</code> variant of the method uses the application’s default zone. A <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_488"></a>zone is a page-aligned area of memory for holding related objects and data allocated by an application. See <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em> for more information on zones.</p><p>An allocation message does other important things besides allocating memory:</p><ul class="spaceabove"><li class="li"><p>It sets the object’s <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_489"></a>retain count to one (as described in <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW10">“How Memory Management Works”</a></span>).</p></li><li class="li"><p>It initializes the object’s <code>isa</code> <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_490"></a>instance variable to point to the object’s class, a runtime object in its own right that is compiled from the class definition. </p></li><li class="li"><p>It initializes all other <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_491"></a>instance variables to zero (or to the equivalent type for zero, such as <code>nil</code>, <code>NULL</code>, and <code>0.0</code>).</p></li></ul><p>An object’s <code>isa</code> instance variable is inherited from <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code>, so it is common to all Cocoa objects. After allocation sets <code>isa</code> to the object’s class, the object is integrated into the runtime’s view of the inheritance hierarchy and the current network of objects (class and instance) that constitute a program. Consequently an object can find whatever information it needs at <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_492"></a>runtime, such as another object’s place in the inheritance hierarchy, the protocols that other objects conform to, and the location of the method implementations it can perform in response to messages.</p><p>In summary, allocation not only allocates memory for an object but initializes two small but very important attributes of any object: its <code>isa</code> instance variable and its retain count. It also sets all remaining instance variables to zero. But the resulting object is not yet usable. Initializing methods such as <code>init</code> must yet initialize objects with their particular characteristics and return a functional object. </p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW55" title="Initializing an Object"></a><h3>Initializing an Object</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_493"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_494"></a>Initialization sets the instance variables of an object to reasonable and useful initial values. It can also allocate and prepare other global resources needed by the object, loading them if necessary from an external source such as a file. Every object that declares instance variables should implement an initializing method—unless the default set-everything-to-zero initialization is sufficient. If an object does not implement an initializer, Cocoa invokes the initializer of the nearest ancestor instead.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW56" title="The Form of Initializers"></a><h4>The Form of Initializers</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_495"></a><code>NSObject</code> declares the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_496"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/init" target="_top">init</a></code> prototype for initializers; it is an instance method typed to return an object of type <code>id</code>. Overriding <code>init</code> is fine for subclasses that require no additional data to initialize their objects. But often initialization depends on external data to set an object to a reasonable initial state. For example, say you have an Account class; to initialize an Account object appropriately requires a unique account number, and this must be supplied to the initializer. Thus initializers can take one or more arguments; the only requirement is that the initializing method begins with the letters “init”. (The stylistic convention <code>init...</code> is sometimes used to refer to initializers.) </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW92" title="Note"></a><p><strong>Note:</strong>&nbsp;Instead of implementing an initializer with arguments, a subclass may implement only a simple <code>init</code> method and then use “set” <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_497"></a>accessor methods immediately after initialization to set the object to a useful initial state. (Accessor methods enforce encapsulation of object data by setting and getting the values of instance variables.) Or, if the subclass uses properties and the related access syntax, it may assign values to the properties immediately after initialization.</p></div><p>Cocoa has plenty of examples of initializers with arguments. Here are a few (with the defining class in parentheses):</p><ul class="simple"><li><p><code>- (id)initWithArray:(NSArray *)array;</code>  (from <code>NSSet</code>)</p></li><li><p><code>- (id)initWithTimeInterval:(NSTimeInterval)secsToBeAdded  sinceDate:(NSDate *)anotherDate;</code> (from <code>NSDate</code>)</p></li><li><p><code>- (id)initWithContentRect:(NSRect)contentRect  styleMask:(unsigned int)aStyle backing:(NSBackingStoreType)bufferingType defer:(BOOL)flag;</code> (from <code>NSWindow</code>)</p></li><li><p><code>- (id)initWithFrame:(NSRect)frameRect;</code> (from <code>NSControl</code> and <code>NSView</code>)</p></li></ul><p>These initializers are instance methods that begin with “init” and return an object of the dynamic type <code>id</code>. Other than that, they follow the Cocoa conventions for multi-argument methods, often using <code>With</code><em>Type</em><code>:</code> or <code>From</code><em>Source</em><code>:</code> before the first and most important argument.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW57" title="Issues with Initializers"></a><h4>Issues with Initializers</h4><p>Although <code>init...</code> methods are required by their method signature to <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_498"></a>return an object, that object is not necessarily the one that was most recently allocated—the receiver of the <code>init...</code> message. In other words, the object you get back from an initializer might not be the one you thought was being initialized. </p><p>Two conditions prompt the return of something other than the just-allocated object. The first involves two related situations: when there must be a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_499"></a>singleton instance or when the defining attribute of an object must be unique. Some Cocoa classes—<code><a href="../../../Reference/ApplicationKit/Classes/NSWorkspace_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWorkspace" target="_top">NSWorkspace</a></code>, for instance—allow only one instance in a program; a class in such a case must ensure (in an initializer or, more likely, in a class factory method) that only one instance is created, returning this instance if there is any further request for a new one. (See <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW32">“Creating a Singleton Instance”</a></span> for information on implementing a singleton object.)</p><p>A similar situation arises when an object is required to have an attribute that makes it unique. Recall the hypothetical Account class mentioned earlier. An account of any sort must have a unique identifier. If the initializer for this class—say, <code>initWithAccountID:</code>—is passed an identifier that has already been associated with an object, it must do two things:</p><ul class="spaceabove"><li class="li"><p>Release the newly allocated object (in memory-managed code).</p></li><li class="li"><p>Return the Account object previously initialized with this unique identifier.</p></li></ul><p>By doing this, the initializer ensures the uniqueness of the identifier while providing what was asked for: an Account instance with the requested identifier.</p><p>Sometimes an <code>init...</code> method cannot perform the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_500"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_501"></a>initialization requested. For example, an <code>initFromFile:</code> method expects to initialize an object from the contents of a file, the path to which is passed an argument. But if no file exists at that location the object cannot be initialized. A similar problem would happen if an <code>initWithArray:</code> initializer was passed an <code><a href="../../../Reference/Foundation/Classes/NSDictionary_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDictionary" target="_top">NSDictionary</a></code> object instead of an <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSArray" target="_top">NSArray</a></code> object. When an <code>init...</code> method cannot initialize an object, it should:</p><ul class="spaceabove"><li class="li"><p>Release the newly allocated object (in memory-managed code).</p></li><li class="li"><p>Return <code>nil</code>.</p></li></ul><p>Returning <code>nil</code> from an initializer indicates that the requested object cannot be created. When you create an object, you should generally check whether the returned value is <code>nil</code> before proceeding:</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [[MyClass alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>if (anObject) {<span></span></pre></td></tr><tr><td scope="row"><pre>    [anObject doSomething];<span></span></pre></td></tr><tr><td scope="row"><pre>    // more messages...<span></span></pre></td></tr><tr><td scope="row"><pre>} else {<span></span></pre></td></tr><tr><td scope="row"><pre>    // handle error<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Because an <code>init...</code> method might return <code>nil</code> or an object other than the one explicitly allocated, it is dangerous to use the instance returned by <code>alloc</code> or <code>allocWithZone:</code> instead of the one returned by the initializer. Consider the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>id myObject = [MyClass alloc];<span></span></pre></td></tr><tr><td scope="row"><pre>[myObject init];<span></span></pre></td></tr><tr><td scope="row"><pre>[myObject doSomething];<span></span></pre></td></tr></table></div><p>The <code>init</code> method in this example could have returned <code>nil</code> or could have substituted a different object. Because you can send a message to <code>nil</code> without raising an exception, nothing would happen in the former case except (perhaps) a debugging headache. But you should always rely on the initialized instance instead of the “raw” just-allocated one. It is recommended that you nest the allocation and initialization messages and test the object returned from the initializer before proceeding.</p><div class="codesample"><table><tr><td scope="row"><pre>id myObject = [[MyClass alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>if ( myObject ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    [myObject doSomething];<span></span></pre></td></tr><tr><td scope="row"><pre>} else {<span></span></pre></td></tr><tr><td scope="row"><pre>    // error recovery...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Once an object is initialized, you should not initialize it again. If you attempt a re-initialization, the framework class of the instantiated object often raises an exception. For example, the second initialization in this example would result in an <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Constants/Reference/reference.html#//apple_ref/c/data/NSInvalidArgumentException" target="_top">NSInvalidArgumentException</a></code> being raised.</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *aStr = [[NSString alloc] initWithString:@"Foo"];<span></span></pre></td></tr><tr><td scope="row"><pre>aStr = [aStr initWithString:@"Bar"];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW58" title="Implementing an Initializer"></a><h4>Implementing an Initializer</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_502"></a>There are several critical steps to follow when implementing an <code>init...</code> method that serves as a class’s sole initializer or, if there are multiple initializers, its <em>designated initializer</em> (described in <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW3">“Multiple Initializers and the Designated Initializer”</a></span>):</p><ul class="spaceabove"><li class="li"><p>Always invoke the superclass (<code>super</code>) initializer <em>first</em>.</p></li><li class="li"><p>Check the object returned by the superclass. If it is <code>nil</code>, then initialization cannot proceed; return <code>nil</code> to the receiver. </p></li><li class="li"><p>When initializing instance variables that are references to objects, retain or copy the object as necessary (in memory-managed code).</p></li><li class="li"><p>After setting instance variables to valid initial values, return <code>self</code> unless: </p><ul class="nested"><li class="nested li"><p>It was necessary to return a substituted object, in which case release the freshly allocated object first (in memory-managed code).</p></li><li class="nested li"><p>A problem prevented initialization from succeeding, in which case return <code>nil</code>.</p></li></ul></li></ul><p>The <code>init...</code> method in <span class="content_text">Listing 2-3</span> illustrates these steps:</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW29" title="Listing 2-3An example of an initializer"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>An example of an initializer</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithAccountID:(NSString *)identifier {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( self = [super init] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        Account *ac = [accountDictionary objectForKey:identifier];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (ac) { // object with that ID already exists<span></span></pre></td></tr><tr><td scope="row"><pre>            [self release];<span></span></pre></td></tr><tr><td scope="row"><pre>            return [ac retain];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if (identifier) {<span></span></pre></td></tr><tr><td scope="row"><pre>            accountID = [identifier copy]; // accountID is instance variable<span></span></pre></td></tr><tr><td scope="row"><pre>            [accountDictionary setObject:self forKey:identifier];<span></span></pre></td></tr><tr><td scope="row"><pre>            return self;<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self release];<span></span></pre></td></tr><tr><td scope="row"><pre>            return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW93" title="Note"></a><p><strong>Note:</strong>&nbsp;Although, for the sake of simplicity, this example returns <code>nil</code> if the argument is <code>nil</code>, the better Cocoa practice is to raise an exception.</p></div><p>It isn’t necessary to initialize all instance variables of an object explicitly, just those that are necessary to make the object functional. The default set-to-zero initialization performed on an instance variable during allocation is often sufficient. Make sure that you retain or copy instance variables, as required for memory management.</p><p>The requirement to <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_503"></a>invoke the superclass’ initializer as the first thing is important. Recall that an object encapsulates not only the instance variables defined by its class but the instance variables defined by all of its ancestor classes. By invoking <code>super</code>’s initializer first you help to ensure that the instance variables defined by classes up the inheritance chain are initialized first. The immediate superclass, in its initializer, invokes the initializer of its superclass, which invokes its superclasses main <code>init...</code> method, and so on (see <span class="content_text">Figure 2-8</span>). The proper order of initialization is critical because the later initializations of subclasses may depend on superclass-defined instance variables being initialized to reasonable values.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW24" title="Figure 2-8Initialization up the inheritance chain"></a><p><strong>Figure 2-8&nbsp;&nbsp;</strong>Initialization up the inheritance chain</p><img src = "../Art/init_inheritance_chain.gif" alt = "Initialization up the inheritance chain" width="243" height="442"></div><br/><p>Inherited initializers are a concern when you create a subclass. Sometimes a superclass <code>init...</code> method sufficiently initializes instances of your class. But it is more likely it won’t, and so you should override it. If you don’t, the superclass implementation will be invoked, and since the superclass knows nothing about your class, your instances may not be correctly initialized.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW3" title="Multiple Initializers and the Designated Initializer"></a><h4>Multiple Initializers and the Designated Initializer</h4><p>A class can define more than one <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_504"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_505"></a>initializer. Sometimes multiple initializers let clients of the class provide the input for the same initialization in different forms. The <code><a href="../../../Reference/Foundation/Classes/NSSet_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSet" target="_top">NSSet</a></code> class, for example, offers clients several initializers that accept the same data in different forms; one takes an <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSArray" target="_top">NSArray</a></code> object, another a counted list of elements, and another a <code>nil</code>-terminated list of elements:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithArray:(NSArray *)array;<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithObjects:(id *)objects count:(unsigned)count;<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithObjects:(id)firstObj, ...;<span></span></pre></td></tr></table></div><p>Some subclasses provide convenience initializers that supply default values to an initializer that takes the full complement of initialization parameters. This initializer is usually the designated initializer, the most important initializer of a class. For example, assume there is a Task class and it declares a designated initializer with this signature:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithTitle:(NSString *)aTitle date:(NSDate *)aDate;<span></span></pre></td></tr></table></div><p>The Task class might include secondary, or convenience, initializers that simply invoke the designated initializer, passing it default values for those parameters the secondary initializer doesn’t explicitly request (<span class="content_text">Listing 2-4</span>).</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW12" title="Listing 2-4Secondary initializers"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Secondary initializers</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithTitle:(NSString *)aTitle {<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self initWithTitle:aTitle date:[NSDate date]];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init {<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self initWithTitle:@"Task"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The designated initializer plays an important role for a class. It ensures that inherited instance variables are initialized by invoking <code>super</code>’s designated initializer. It is typically the <code>init...</code> method that has the most arguments and that does most of the initialization work, and it is the initializer that secondary initializers of the class invoke with messages to <code>self</code>.</p><p>When you define a subclass you must be able to identify the designated initializer of the superclass and invoke it in your subclass’s designated initializer through a message to <code>super</code>. You must also make sure that inherited initializers are covered in some way. And you may provide as many convenience initializers as you deem necessary. When designing the initializers of your class, keep in mind that designated initializers are chained to each other through messages to <code>super</code> while other initializers are chained to the designated initializer of their class through messages to <code>self</code>.</p><p>An example will make this clearer. Let’s say there are three classes, A, B, and C; class B inherits from class A, and class C inherits from class B. Each subclass adds an attribute as an instance variable and implements an <code>init...</code> method—the designated initializer—to initialize this instance variable. They also define secondary initializers and ensure that inherited initializers are overridden, if necessary. <span class="content_text">Figure 2-9</span> illustrates the initializers of all three classes and their relationships.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW15" title="Figure 2-9Interactions of secondary and designated initializers"></a><p><strong>Figure 2-9&nbsp;&nbsp;</strong>Interactions of secondary and designated initializers</p><img src = "../Art/designatedinitializer.gif" alt = "Interactions of secondary and designated initializers" width="259" height="376"></div><br/><p>The designated initializer for each class is the initializer with the most coverage; it is the method that initializes the attribute added by the subclass. The designated initializer is also the <code>init...</code> method that invokes the designated initializer of the superclass in a message to <code>super</code>. In this example, the designated initializer of class C, <code>initWithTitle:date:</code>, invokes the designated initializer of its superclass, <code>initWithTitle:</code>, which in turn invokes the <code>init</code> method of class A. When creating a subclass, it’s always important to know the designated initializer of the superclass.</p><p>While designated initializers are thus connected up the inheritance chain through messages to <code>super</code>, secondary initializers are connected to their class’s designated initializer through messages to <code>self</code>. <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_506"></a>Secondary initializers (as in this example) are frequently overridden versions of inherited initializers. Class C overrides <code>initWithTitle:</code> to invoke its designated initializer, passing it a default date. This designated initializer, in turn, invokes the designated initializer of class B, which is the overridden method, <code>initWithTitle:</code>. If you sent an <code>initWithTitle:</code> message to objects of class B and class C, you’d be invoking different method implementations. On the other hand, if class C did <em>not</em> override <code>initWithTitle:</code> and you sent the message to an instance of class C, the class B implementation would be invoked. Consequently, the C instance would be incompletely initialized (since it would lack a date). When creating a subclass, it’s important to make sure that all inherited initializers are adequately covered.</p><p>Sometimes the designated initializer of a superclass may be sufficient for the subclass, and so there is no need for the subclass to implement its own designated initializer. Other times, a class’s designated initializer may be an overridden version of its superclasses designated initializer. This is frequently the case when the subclass needs to supplement the work performed by the superclass’s designated initializer, even though the subclass does not add any instance variables of its own (or the instance variables it does add don’t require explicit initialization).<a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_507"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_508"></a></p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW40" title="The dealloc and finalize Methods"></a><h3>The dealloc and finalize Methods</h3><p>In Cocoa classes that use garbage collection, the <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/finalize" target="_top">finalize</a></code> method is the place where the class disposes of any remaining resources and attachments of its instances before those instances are freed. In Cocoa classes that use traditional memory management, the comparable method for resource cleanup is the <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/dealloc" target="_top">dealloc</a></code> method. Although similar in purpose, there are significant differences in how these methods should be implemented.</p><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_509"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_510"></a>In many respects, the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_511"></a><code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/dealloc" target="_top">dealloc</a></code> method is the counterpart to a class’s <code>init...</code> method, especially its designated initializer. Instead of being invoked just after the allocation of an object, <code>dealloc</code> is invoked just prior to the object’s destruction. Instead of ensuring that the instance variables of an object are properly initialized, the <code>dealloc</code> method makes sure that object instance variables are released and that any dynamically allocated memory has been freed.</p><p>The final point of parallelism has to do with the invocation of the superclass implementation of the same method. In an initializer, you invoke the superclasses designated initializer as the first step. In <code>dealloc</code>, you invoke the superclasses <code>dealloc</code> implementation as the <em>last</em> step. The reason for this is mirror-opposite to   that for initializers; subclasses should release or free the instance variables they own first before the instance variables of ancestor classes are released or freed. </p><p><span class="content_text">Listing 2-5</span> shows how you might implement this method.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW6" title="Listing 2-5An example dealloc method"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>An example <code>dealloc</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)dealloc {<span></span></pre></td></tr><tr><td scope="row"><pre>    [accountDictionary release];<span></span></pre></td></tr><tr><td scope="row"><pre>    free(mallocdChunk);<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that this example does not verify that <em>accountDictionary</em> (an instance variable) is non-<code>nil</code> before releasing it. That is because Objective-C lets you safely send a message to <code>nil</code>.</p><p>Similar to the <code>dealloc</code> method,  the <code>finalize</code> method is the place to close resources used by an object in a garbage-collected environment prior to that object being freed and its memory reclaimed. As in <code>dealloc</code>, the final line of a <code>finalize</code> implementation should invoke the superclass implementation of the method. However, unlike <code>dealloc</code>, a <code>finalize</code> implementation does not have to release instance variables because the garbage collector destroys these objects at the proper time.</p><p>But there is a more significant difference between these “cleanup” methods. It is actually recommended that you do <em>not</em> implement a <code>finalize</code> method if possible. And, if you must implement <code>finalize</code>, you should reference as few other objects as possible. The primary reason for this admonition is that the order in which garbage-collected objects are sent <code>finalize</code> is indeterminate, even if there are references between them. Thus the consequences are indeterminate, and potentially negative, if messages pass between objects being finalized. Your code cannot depend on the side effects arising from the order of deallocation, as it can in <code>dealloc</code>. Generally, you should try to architect your code so that such actions as freeing <code>malloc</code>’d blocks, closing file descriptors, and unregistering observers happen before <code>finalize</code> is invoked.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW94" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To learn about approaches to implementing the <code>finalize</code> method, read “<span class="content_text"><a href="../../GarbageCollection/Articles/gcFinalize.html#//apple_ref/doc/uid/TP40002453" target="_top">Implementing a finalize Method</a></span>" in <em><a href="../../GarbageCollection/index.html#//apple_ref/doc/uid/TP40002431" target="_top">Garbage Collection Programming Guide</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW36" title="Class Factory Methods"></a><h3>Class Factory Methods</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_512"></a>Class factory methods are implemented by a class as a convenience for clients. They combine allocation and initialization in one step and return the created object autoreleased (in memory-managed code). These methods are of the form <code>+ (</code><em>type</em><code>)</code><em>className</em><code>...</code> (where <em>className</em> excludes any prefix).   </p><p>Cocoa provides plenty of examples, especially among the “value” classes. NSDate includes the following class factory methods:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)secs;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)dateWithTimeIntervalSince1970:(NSTimeInterval)secs;<span></span></pre></td></tr></table></div><p>And NSData offers the following factory methods:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)dataWithBytes:(const void *)bytes length:(unsigned)length;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)dataWithBytesNoCopy:(void *)bytes length:(unsigned)length;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)dataWithBytesNoCopy:(void *)bytes length:(unsigned)length<span></span></pre></td></tr><tr><td scope="row"><pre>        freeWhenDone:(BOOL)b;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)dataWithContentsOfFile:(NSString *)path;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)dataWithContentsOfURL:(NSURL *)url;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)dataWithContentsOfMappedFile:(NSString *)path;<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_513"></a>Factory methods can be more than a simple convenience. They can not only combine allocation and initialization, but the allocation can inform the initialization. As an example, let’s say you must initialize a collection object from a property-list file that encodes any number of elements for the collection (<code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/cl/NSString" target="_top">NSString</a></code> objects, <code><a href="../../../Reference/Foundation/Classes/NSData_Class/Reference/Reference.html#//apple_ref/occ/cl/NSData" target="_top">NSData</a></code> objects, <code><a href="../../../Reference/Foundation/Classes/NSNumber_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNumber" target="_top">NSNumber</a></code> objects, and so on). Before the factory method can know how much memory to allocate for the collection, it must read the file and parse the property list to determine how many elements there are and what object type these elements are. </p><p>Another purpose for a class factory method is to ensure that a certain class (<code><a href="../../../Reference/ApplicationKit/Classes/NSWorkspace_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWorkspace" target="_top">NSWorkspace</a></code>, for example) vends a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_514"></a>singleton instance. Although an <code>init...</code> method could verify that only one instance exists at any one time in a program, it would require the prior allocation of a “raw” instance and then, in memory-managed code, would have to release that instance. A factory method, on the other hand, gives you a way to avoid blindly allocating memory for an object that you might not use (see <span class="content_text">Listing 2-6</span>).</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW4" title="Listing 2-6A factory method for a singleton instance"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>A factory method for a singleton instance</p><div class="codesample"><table><tr><td scope="row"><pre>static AccountManager *DefaultManager = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ (AccountManager *)defaultManager {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!DefaultManager) DefaultManager = [[self allocWithZone:NULL] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    return DefaultManager;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW95" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For a more detailed discussion of issues relating to the allocation and initialization of Cocoa objects, see “<span class="content_text"><!--a target="_top" -->The Runtime System<!--/a--></span>“ in <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>.<a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_515"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_516"></a></p></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW25" title="Introspection"></a><h2>Introspection</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_517"></a>Introspection is a powerful feature of object-oriented languages and environments, and Objective-C and Cocoa are particularly generous with this feature. Introspection refers to the capability of objects to divulge details about themselves as objects at runtime. Such details include an object’s place in the inheritance tree, whether it conforms to a specific protocol, and whether it responds to a certain message. The NSObject protocol and class define many introspection methods that you can use to query the runtime in order to characterize objects. </p><p>Used judiciously, introspection makes an object-oriented program more efficient and robust. It can help you to avoid message-dispatch errors, erroneous assumptions of object equality, and similar problems. The following sections show how you might effectively use the <code>NSObject</code> introspection methods in your code.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW59" title="Evaluating Inheritance Relationships"></a><h3>Evaluating Inheritance Relationships</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_518"></a>Once you know the class an object belongs to, you probably know quite a bit about the object. You might know what its capabilities are, what attributes it represents, and what kinds of messages it can respond to. Even if after introspection you are unfamiliar with the class to which an object belongs, you now know enough to not send it certain messages.</p><p>The <code>NSObject</code> protocol declares several methods for determining an object’s position in the class hierarchy. These methods operate at different granularities. The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_519"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/class" target="_top">class</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_520"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/superclass" target="_top">superclass</a></code> instance methods, for example, return the <code>Class</code> objects representing the class and superclass, respectively, of the receiver. These methods require you to compare one <code>Class</code> object with another. <span class="content_text">Listing 2-7</span> gives a simple (one might say trivial) example of their use.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW7" title="Listing 2-7Using the class and superclass methods"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>Using the class and superclass methods</p><div class="codesample"><table><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>while ( id anObject = [objectEnumerator nextObject] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( [self class] == [anObject superclass] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // do something appropriate...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW96" title="Note"></a><p><strong>Note:</strong>&nbsp;Sometimes you use the <code>class</code> or <code>superclass</code> methods to obtain an appropriate receiver for a class message.</p></div><p>More commonly to check an object’s class affiliation, you would send it a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_521"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isKindOfClass:" target="_top">isKindOfClass:</a></code> or <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_522"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isMemberOfClass:" target="_top">isMemberOfClass:</a></code> message. The former method returns whether the receiver is an instance of a given class or an instance of any class that inherits from that class. A <code>isMemberOfClass:</code> message, on the other hand, tells you if the receiver is an instance of the specified class. The <code>isKindOfClass:</code> method is generally more useful because from it you can know at once the complete range of messages you can send to an object. Consider the code snippet in <span class="content_text">Listing 2-8</span>.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW23" title="Listing 2-8Using isKindOfClass: "></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>Using isKindOfClass: </p><div class="codesample"><table><tr><td scope="row"><pre>if ([item isKindOfClass:[NSData class]]) {<span></span></pre></td></tr><tr><td scope="row"><pre>    const unsigned char *bytes = [item bytes];<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned int length = [item length];<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>By learning that the object <em>item</em> inherits from the <code><a href="../../../Reference/Foundation/Classes/NSData_Class/Reference/Reference.html#//apple_ref/occ/cl/NSData" target="_top">NSData</a></code> class, this code knows it can send it the <code>NSData</code> <code><a href="../../../Reference/Foundation/Classes/NSData_Class/Reference/Reference.html#//apple_ref/occ/instm/NSData/bytes" target="_top">bytes</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSData_Class/Reference/Reference.html#//apple_ref/occ/instm/NSData/length" target="_top">length</a></code> messages. The difference between <code>isKindOfClass:</code> and <code>isMemberOfClass:</code> becomes apparent if you assume that <em>item</em> is an instance of NSMutableData. If you use <code>isMemberOfClass:</code> instead of <code>isKindOfClass:</code>, the code in the conditionalized block is never executed because <em>item</em> is not an instance of <code>NSData</code> but rather of <code><a href="../../../Reference/Foundation/Classes/NSMutableData_Class/Reference/NSMutableData.html#//apple_ref/occ/cl/NSMutableData" target="_top">NSMutableData</a></code>, a subclass of <code>NSData</code>.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW60" title="Method Implementation and Protocol Conformance"></a><h3>Method Implementation and Protocol Conformance</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_523"></a>Two of the more powerful introspection methods of <code>NSObject</code> are <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_524"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_525"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/conformsToProtocol:" target="_top">conformsToProtocol:</a></code>. These methods tell you, respectively, whether an object implements a certain method and whether an object conforms to a specified formal protocol (that is, adopts the protocol, if necessary, and implements all the methods of the protocol).</p><p>You use these methods in a similar situation in your code. They enable you to discover whether some potentially anonymous object will respond appropriately to a particular message or set of messages <em>before</em> you send it any of those messages. By making this check before sending a message, you can avoid the risk of runtime exceptions resulting from unrecognized selectors. The Application Kit implements informal protocols—the basis of delegation—by checking whether delegates implement a delegation method (using <code>respondsToSelector:</code>) prior to invoking that method.</p><p><span class="content_text">Listing 2-9</span> illustrates how you might use the <code>respondsToSelector:</code> method in your code:</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW8" title="Listing 2-9Using respondsToSelector:"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>Using <code>respondsToSelector:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (void)doCommandBySelector:(SEL)aSelector {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([self respondsToSelector:aSelector]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self performSelector:aSelector withObject:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        [_client doCommandBySelector:aSelector];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 2-10</span> illustrates how you might use the <code>conformsToProtocol:</code> method in your code:</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW11" title="Listing 2-10Using conformsToProtocol:"></a><p class="codesample"><strong>Listing 2-10&nbsp;&nbsp;</strong>Using <code>conformsToProtocol:</code></p><div class="codesample"><table><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>if (!([((id)testObject) conformsToProtocol:@protocol(NSMenuItem)])) {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Custom MenuItem, '%@', not loaded; it must conform to the<span></span></pre></td></tr><tr><td scope="row"><pre>        'NSMenuItem' protocol.\n", [testObject class]);<span></span></pre></td></tr><tr><td scope="row"><pre>    [testObject release];<span></span></pre></td></tr><tr><td scope="row"><pre>    testObject = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW61" title="Object Comparison"></a><h3>Object Comparison</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_526"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_527"></a>Although they are not strictly introspection methods, the <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_528"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/hash" target="_top">hash</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_529"></a><code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isEqual:" target="_top">isEqual:</a></code> methods fulfill a similar role. They are indispensable runtime tools for identifying and comparing objects. But instead of querying the runtime for information about an object, they rely on class-specific comparison logic.</p><p>The <code>hash</code> and <code>isEqual:</code> methods, both declared by the <code>NSObject</code> protocol, are closely related. The <code>hash</code> method must be implemented to return an integer that can be used as a table address in a hash table structure. If two objects are equal (as determined by the <code>isEqual:</code> method), they must have the same hash value. If your object could be included in collections such as NSSet, you need to define <code>hash</code> and verify the invariant that if two objects are equal, they return the same hash value. The default <code>NSObject</code> implementation of <code>isEqual:</code> simply checks for pointer equality. </p><p>Using the <code>isEqual:</code> method is straightforward; it compares the receiver against the object supplied as argument. Object comparison frequently informs runtime decisions about what should be done with an object. As <span class="content_text">Listing 2-11</span> illustrates, you can use <code>isEqual:</code> to decide whether to perform an action, in this case to save user preferences that have been modified.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW28" title="Listing 2-11Using isEqual:"></a><p class="codesample"><strong>Listing 2-11&nbsp;&nbsp;</strong>Using isEqual:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)saveDefaults {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSDictionary *prefs = [self preferences];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![origValues isEqual:prefs])<span></span></pre></td></tr><tr><td scope="row"><pre>        [Preferences savePreferencesToDefaults:prefs];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If you are creating a subclass, you might need to override <code>isEqual:</code> to add further checks for points of equality. The subclass might define an extra attribute that might have to be the same value in two instances for them to be considered equal. For example, say you create a subclass of NSObject called MyWidget that contains two instance variables, <code>name</code> and <code>data</code>. Both of these must be the same value for two instances of MyWidget to be considered equal. <span class="content_text">Listing 2-12</span> illustrates how you might implement <code>isEqual:</code> for the MyWidget class.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW2" title="Listing 2-12Overriding isEqual:"></a><p class="codesample"><strong>Listing 2-12&nbsp;&nbsp;</strong>Overriding <code>isEqual:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)isEqual:(id)other {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (other == self)<span></span></pre></td></tr><tr><td scope="row"><pre>        return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!other || ![other isKindOfClass:[self class]])<span></span></pre></td></tr><tr><td scope="row"><pre>        return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self isEqualToWidget:other];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isEqualToWidget:(MyWidget *)aWidget {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self == aWidget)<span></span></pre></td></tr><tr><td scope="row"><pre>        return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![(id)[self name] isEqual:[aWidget name]])<span></span></pre></td></tr><tr><td scope="row"><pre>        return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![[self data] isEqualToData:[aWidget data]])<span></span></pre></td></tr><tr><td scope="row"><pre>        return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This <code>isEqual:</code> method first checks for pointer equality, then class equality, and finally invokes an object comparator whose name indicates the class of object involved in the comparison. This type of comparator, which forces type-checking of the object passed in, is a common convention in Cocoa; the <code>NSString</code> <code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/instm/NSString/isEqualToString:" target="_top">isEqualToString:</a></code> and the <code>NSTimeZone</code> <code><a href="../../../Reference/Foundation/Classes/NSTimeZone_Class/Reference/Reference.html#//apple_ref/occ/instm/NSTimeZone/isEqualToTimeZone:" target="_top">isEqualToTimeZone:</a></code> are but two examples. The class-specific comparator—<code>isEqualToWidget:</code> in this case—performs the checks for name and data equality.</p><p>In all <code>isEqualTo</code><em>Type</em><code>:</code> methods of the Cocoa frameworks <code>nil</code> is not a valid argument and implementations of these methods may raise an exception upon receiving a <code>nil</code>. However, for backwards compatibility, <code>isEqual:</code> methods of the Cocoa frameworks do accept <code>nil</code>, returning <code>NO</code><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_530"></a>.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW33" title="Object Mutability"></a><h2>Object Mutability</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_531"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_532"></a>Cocoa objects are either mutable or immutable. You cannot change the encapsulated values of immutable objects; once such an object is created, the value it represents remains the same throughout the object’s life. But you can change the encapsulated value of a mutable object at any time. The following sections explain the reasons for having mutable and immutable variants of an object type, describes the characteristics and side-effects of object mutability, and recommends how best to handle objects when their mutability is an issue.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW62" title="Why Mutable and Immutable Object Variants?"></a><h3>Why Mutable and Immutable Object Variants?</h3><p>Objects by default are mutable. Most objects allow you to change their encapsulated data through “setter” <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_533"></a>accessor methods. For example, you can change the size, positioning, title, buffering behavior, and other characteristics of an NSWindow object. A well-designed model object—say, an object representing a customer record—<em>requires</em> setter methods to change its instance data.</p><p>The Foundation framework adds some nuance to this picture by introducing classes that have mutable and immutable variants. The mutable subclasses are typically subclasses of their immutable superclass and have “Mutable” embedded in the class name. These classes include the following:</p><ul class="simple"><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableArray" target="_top">NSMutableArray</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableDictionary_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableDictionary" target="_top">NSMutableDictionary</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableSet_Class/Reference/NSMutableSet.html#//apple_ref/occ/cl/NSMutableSet" target="_top">NSMutableSet</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableIndexSet_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableIndexSet" target="_top">NSMutableIndexSet</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableCharacterSet_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableCharacterSet" target="_top">NSMutableCharacterSet</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableData_Class/Reference/NSMutableData.html#//apple_ref/occ/cl/NSMutableData" target="_top">NSMutableData</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableString_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableString" target="_top">NSMutableString</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableAttributedString_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableAttributedString" target="_top">NSMutableAttributedString</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSMutableURLRequest_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableURLRequest" target="_top">NSMutableURLRequest</a></code></p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH4-SW97" title="Note"></a><p><strong>Note:</strong>&nbsp;Except for <code><a href="../../../Reference/ApplicationKit/Classes/NSMutableParagraphStyle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableParagraphStyle" target="_top">NSMutableParagraphStyle</a></code> in the Application Kit, the Foundation framework currently defines all explicitly named mutable classes. However, any Cocoa framework can potentially have its own mutable and immutable class variants.</p></div><p>Although these classes have atypical names, they are closer to the mutable norm than their immutable counterparts. Why this complexity? What purpose does having an immutable variant of a mutable object serve?</p><p>Consider a scenario where all objects are capable of being mutated. In your application you invoke a method and are handed back a reference to an object representing a string. You use this string in your user interface to identify a particular piece of data. Now another subsystem in your application gets its own reference to that same string and decides to mutate it. Suddenly your label has changed out from under you. Things can become even more dire if, for instance, you get a reference to an array that you use to populate a table view. The user selects a row corresponding to an object in the array that has been removed by some code elsewhere in the program—problems ensue. <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_534"></a>Immutability is a guarantee that an object won’t unexpectedly change in value while you’re using it. </p><p>Objects that are good candidates for immutability are ones that encapsulate collections of discrete values or contain values that are stored in buffers (which are themselves kinds of collections, either of characters or bytes). But not all “value” objects necessarily benefit from having mutable versions. Objects that contain a single simple value, such as instances of <code><a href="../../../Reference/Foundation/Classes/NSNumber_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNumber" target="_top">NSNumber</a></code> or <code><a href="../../../Reference/Foundation/Classes/NSDate_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDate" target="_top">NSDate</a></code>, are not good candidates for mutability. When the represented value changes in these cases, it makes more sense to replace the old instance with a new instance. </p><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_535"></a>Performance is also a reason for immutable versions of objects representing things such as strings and dictionaries. Mutable objects such as these bring some overhead with them. Because they must dynamically manage a changeable backing store—allocating and deallocating chunks of memory as needed—mutable objects can be less efficient than their immutable counterparts. </p><p>Although in theory immutability guarantees that an object’s value is stable, in practice this guarantee isn’t always assured. A method may choose to hand out a mutable object under the return type of its immutable variant; later, it may decide to mutate the object, possibly violating assumptions and choices the recipient has made based on the earlier value. The mutability of an object itself may change as it undergoes various transformations. For example, serializing a property list (using the <code><a href="../../../Reference/Foundation/Classes/NSPropertyListSerialization_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPropertyListSerialization" target="_top">NSPropertyListSerialization</a></code> class) does not preserve the mutability aspect of objects, only their general kind—a dictionary, an array, and so on. Thus, when you deserialize this property list, the resulting objects might not be of the same class as the original objects. For instance, what was once an <code><a href="../../../Reference/Foundation/Classes/NSMutableDictionary_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableDictionary" target="_top">NSMutableDictionary</a></code> object might now be a <code><a href="../../../Reference/Foundation/Classes/NSDictionary_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDictionary" target="_top">NSDictionary</a></code> object. </p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW63" title="Programming With Mutable Objects"></a><h3>Programming With Mutable Objects</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_536"></a>When the mutability of objects is an issue, it’s best to adopt some defensive programming practices. Here are a few general rules of thumb: </p><ul class="spaceabove"><li class="li"><p>Use a mutable variant of an object when you need to modify its contents frequently and incrementally after it has been created.</p></li><li class="li"><p>Sometimes it’s preferable to replace one immutable object with another; for example, most instance variables that hold string values should be assigned immutable NSString objects that are replaced with “setter” methods.</p></li><li class="li"><p>Rely on the return type for indications of mutability. </p></li><li class="li"><p>if you have any doubts about whether an object is, or should be, mutable, go with immutable. </p></li></ul><p>This section explores the gray areas in these rules of thumb, discussing typical choices you have to make when programming with mutable objects. It also gives an overview of methods in the Foundation framework for creating mutable objects and for converting between mutable and immutable object variants. </p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW64" title="Creating and Converting Mutable Objects"></a><h4>Creating and Converting Mutable Objects</h4><p>You can <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_537"></a>create a mutable object through the standard nested <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/alloc" target="_top">alloc</a></code>-<code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/init" target="_top">init</a></code> message, for example:</p><div class="codesample"><table><tr><td scope="row"><pre>NSMutableDictionary *mutDict = [[NSMutableDictionary alloc] init];<span></span></pre></td></tr></table></div><p>However, many mutable classes offer initializers and factory methods that let you specify the initial or probable capacity of the object, such as the <code>arrayWithCapacity:</code> class method of <code>NSMutableArray</code>: </p><div class="codesample"><table><tr><td scope="row"><pre>NSMutableArray *mutArray = [NSMutableArray arrayWithCapacity:[timeZones count]];<span></span></pre></td></tr></table></div><p>This hint enables more efficient storage of the mutable object’s data. (Because the convention for class factory methods is to return autoreleased instances, be sure to retain the object if you wish to keep it viable in your code.)</p><p>You can also create a mutable object by making a mutable copy of an existing object of that general type. To do so, invoke the <code>mutableCopy</code> method that each immutable super class of a Foundation mutable class implements:</p><div class="codesample"><table><tr><td scope="row"><pre>NSMutableSet *mutSet = [aSet mutableCopy];<span></span></pre></td></tr></table></div><p>In the other direction, you can send <code>copy</code> to a mutable object to make an immutable copy of it.</p><p>Many Foundation classes with immutable and mutable variants include methods for converting between the variants, including:</p><ul class="spaceabove"><li class="li"><p><em>type</em><code>With</code><em>Type</em><code>:</code>—for example, <code>arrayWithArray:</code></p></li><li class="li"><p><code>set</code><em>Type</em><code>:</code>—for example, <code>setString:</code> (mutable classes only)</p></li><li class="li"><p><code>initWith</code><em>Type</em><code>:copyItems:</code>—for example, <code>initWithDictionary:copyItems:</code></p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH4-SW65" title="Storing and Returning Mutable Instance Variables "></a><h4>Storing and Returning Mutable Instance Variables </h4><p>A common decision in Cocoa development is whether to make an <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_538"></a>instance variable mutable or immutable. For an instance variable whose value can change, such as a dictionary or string, when is it appropriate to make the object mutable? And when is it better to make the object immutable and replace it with another object when its represented value changes?</p><p>Generally, when you have an object whose contents change wholesale, it’s better to use an immutable object. Strings (<code>NSString</code>) and data objects (<code>NSData</code>) usually fall into this category. If an object is likely to change incrementally, it is a reasonable approach to make it mutable. Collections such as arrays and dictionaries fall into this category. However, the frequency of changes and the size of the collection should be factors in this decision. For example, if you have a small array that seldom changes, it’s better to make it immutable.</p><p>There are a couple of other considerations when deciding on the mutability of an collection held as an instance variable:</p><ul class="spaceabove"><li class="li"><p>If you have a mutable collection that is frequently changed and that you frequently hand out to clients (that is, you return it directly in a “getter” <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_539"></a>accessor method) you run the risk of mutating something that your clients might have a reference to. If this risk is probable, the instance variable should be immutable. </p></li><li class="li"><p>If the value of the instance variable frequently changes but you rarely return it to clients in <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_540"></a>getter methods, you can make the instance variable mutable but return an immutable copy of it in your accessor method; in memory-managed programs, this object would be autoreleased (<span class="content_text">Listing 2-13</span>).</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH4-SW9" title="Listing 2-13Returning an immutable copy of a mutable instance variable"></a><p class="codesample"><strong>Listing 2-13&nbsp;&nbsp;</strong>Returning an immutable copy of a mutable instance variable</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyClass : NSObject {<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableSet *widgets;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSSet *)widgets {<span></span></pre></td></tr><tr><td scope="row"><pre>    return (NSSet *)[[widgets copy] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>One sophisticated approach for handling mutable collections that are returned to clients is to maintain a flag that records whether the object is currently mutable or immutable. If there is a change, make the object mutable and apply the change. When handing out the collection, make the object immutable (if necessary) before returning it. </p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW66" title="Receiving Mutable Objects"></a><h4>Receiving Mutable Objects</h4><p>The invoker of a method is interested in the mutability of a returned object for two reasons:</p><ul class="spaceabove"><li class="li"><p>It wants to know if it can change the object’s value.</p></li><li class="li"><p>It wants to know if the object’s value will change unexpectedly while it has a reference to it.</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH4-SW67" title="Use Return Type, Not Introspection"></a><h5>Use Return Type, Not Introspection</h5><p>To determine whether it can change a received object, the receiver must rely on the formal type of the return value. If it receives, for instance, an array object typed as immutable, it should not attempt to mutate it. It is not an acceptable programming practice to determine if an object is mutable based on its class membership, for example:</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anArray isKindOfClass:[NSMutableArray class]] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // add, remove objects from anArray<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Because of implementation reasons, what <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isKindOfClass:" target="_top">isKindOfClass:</a></code> returns in this case may not be accurate. But for reasons other than this, you should not make decisions on whether an object is mutable based on class membership. That decision should be guided solely by what the signature of the method vending the object says about its mutability. If you are not sure whether an object is mutable or immutable, assume it’s immutable.</p><p>A couple of examples might help clarify why this guideline is important:</p><ul class="spaceabove"><li class="li"><p>You read a property list from a file. When the Foundation framework processes the list it notices that various subsets of the property list are identical, so it creates a set of objects that it shares among all those subsets. Afterwards you look at the created property list objects and decide to mutate one subset. Suddenly, and without being aware of it, you’ve changed the tree in multiple places.</p></li><li class="li"><p>You ask <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> for its subviews (<code>subviews</code> method) and it returns an object that is declared to be an <code>NSArray</code> but which could be an <code>NSMutableArray</code> internally. Then you pass that array to some other code that, through introspection, determines it to be mutable and changes it. By changing this array, the code is mutating <code>NSView</code>’s internal data structures.</p></li></ul><p>So don’t make a decision on object mutability based on what <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_541"></a>introspection tells you about an object. Treat objects as mutable or not based on what you are handed at the API boundaries (that is, based on the return type). If you need to unambiguously mark an object as mutable or immutable when you pass it to clients, pass that information as a flag along with the object.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW68" title="Make Snapshots of Received Objects"></a><h5>Make Snapshots of Received Objects</h5><p>If you want to ensure that a supposedly immutable object received from a method does not mutate without your knowing about it, you can make “snapshots” of the object by copying it locally. Then occasionally compare the stored version of the object with the most recent version. If the object has mutated, you can adjust anything in your program that is dependent on the previous version of the object. <span class="content_text">Listing 2-14</span> shows a possible implementation of this technique.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW22" title="Listing 2-14Making a snapshot of a potentially mutable object"></a><p class="codesample"><strong>Listing 2-14&nbsp;&nbsp;</strong>Making a snapshot of a potentially mutable object</p><div class="codesample"><table><tr><td scope="row"><pre>static NSArray *snapshot = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)myFunction {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray *thingArray = [otherObj things];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (snapshot) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( ![thingArray isEqualToArray:snapshot] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self updateStateWith:thingArray];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    snapshot = [thingArray copy];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>A problem with making snapshots of objects for later comparison is that it is expensive. You’re required to make multiple copies of the same object. A more efficient alternative is to use <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_542"></a>key-value observing. See <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW7">“Key-Value Observing”</a></span>  for an overview of this protocol.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW69" title="Mutable Objects in Collections"></a><h4>Mutable Objects in Collections</h4><p>Storing mutable objects in <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_543"></a>collection objects can cause problems. Certain collections can become invalid or even corrupt if objects they contain mutate because, by mutating, these objects can affect the way they are placed in the collection. In the first case, the properties of objects that are keys in hashing collections such as <code>NSDictionary</code> objects or <code>NSSet</code> objects will, if changed, corrupt the collection if the changed properties affect the results of the object’s <code>hash</code> or <code>isEqual:</code> methods. (If the <code>hash</code> method of the objects in the collection does not depend on their internal state, corruption is less of a likelihood.) Second, if an object in an ordered collection such as a sorted array has its properties changed, this might affect how the object compares to other objects in the array, thus rendering the ordering invalid<a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_544"></a><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_545"></a>.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW34" title="Class Clusters"></a><h2>Class Clusters</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_546"></a>Class clusters are a design pattern that the Foundation framework makes extensive use of. Class clusters group a number of private, concrete subclasses under a public, abstract superclass. The grouping of classes in this way simplifies the publicly visible architecture of an object-oriented framework without reducing its functional richness. Class clusters are based on the Abstract Factory design pattern discussed in <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6">“Cocoa Design Patterns.”</a></span></p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW70" title="Simple Concept, Complex Interface"></a><h3>Simple Concept, Complex Interface</h3><p>To illustrate the class cluster architecture and its benefits, consider the problem of constructing a class hierarchy that defines objects to store numbers of different types (<code>char</code>, <code>int</code>, <code>float</code>, <code>double</code>). Since numbers of different types have many features in common (they can be converted from one type to another and can be represented as strings, for example), they could be represented by a single class. However, their storage requirements differ, so it’s inefficient to represent them all by the same class. This suggests the following architecture:</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW71" title="Figure 2-10A simple hierarchy for number classes"></a><p><strong>Figure 2-10&nbsp;&nbsp;</strong>A simple hierarchy for number classes</p><img src = "../Art/cluster1.gif" alt = "A simple hierarchy for number classes" width="292" height="94"></div><br/><p>Number is the abstract superclass that declares in its methods the operations common to its subclasses. However, it doesn’t declare an instance variable to store a number. The subclasses declare such instance variables and share in the programmatic interface declared by Number.</p><p>So far, this design is relatively simple. However, if the commonly used modifications of these basic C types are taken into account, the diagram looks more like this:</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW72" title="Figure 2-11A more complete number class hierarchy"></a><p><strong>Figure 2-11&nbsp;&nbsp;</strong>A more complete number class hierarchy</p><img src = "../Art/cluster2.gif" alt = "A more complete number class hierarchy" width="594" height="94"></div><br/><p>The simple concept—creating a class to hold number values—can easily burgeon to over a dozen classes. The class cluster architecture presents a design that reflects the simplicity of the concept.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW73" title="Simple Concept, Simple Interface"></a><h3>Simple Concept, Simple Interface</h3><p>Applying the class cluster design pattern to this problem yields the following hierarchy (private classes are in gray):</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW74" title="Figure 2-12Class cluster architecture applied to number classes"></a><p><strong>Figure 2-12&nbsp;&nbsp;</strong>Class cluster architecture applied to number classes</p><img src = "../Art/cluster3.gif" alt = "Class cluster architecture applied to number classes" width="594" height="94"></div><br/><p>Users of this hierarchy see only one public class, Number, so how is it possible to allocate instances of the proper subclass? The answer is in the way the abstract superclass handles instantiation.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW18" title="Creating Instances"></a><h3>Creating Instances</h3><p>The abstract superclass in a <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_547"></a>class cluster must declare methods for creating instances of its private subclasses. It’s the superclass’s responsibility to dispense an object of the proper subclass based on the creation method that you invoke—you don’t, and can’t, choose the class of the instance.</p><p>In the Foundation framework, you generally create an object by invoking a <code>+ className...</code> method or the <code>alloc...</code> and <code>init...</code> methods. Taking the Foundation framework’s <code><a href="../../../Reference/Foundation/Classes/NSNumber_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNumber" target="_top">NSNumber</a></code> class as an example, you could send these messages to create number objects:</p><div class="codesample"><table><tr><td scope="row"><pre>NSNumber *aChar = [NSNumber numberWithChar:’a’];<span></span></pre></td></tr><tr><td scope="row"><pre>NSNumber *anInt = [NSNumber numberWithInt:1];<span></span></pre></td></tr><tr><td scope="row"><pre>NSNumber *aFloat = [NSNumber numberWithFloat:1.0];<span></span></pre></td></tr><tr><td scope="row"><pre>NSNumber *aDouble = [NSNumber numberWithDouble:1.0];<span></span></pre></td></tr></table></div><p>(This style of instantiation creates objects that will be deallocated automatically—See <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW36">“Class Factory Methods”</a></span> for more information. Many classes also provide the standard <code>alloc...</code> and <code>init...</code> methods to create objects that require you to manage their deallocation.)</p><p>Each object returned—<code>aChar</code>, <code>anInt</code>, <code>aFloat</code>, and <code>aDouble</code>—may belong to a different private subclass (and in fact does). Although each object’s class membership is hidden, its interface is public, being the interface declared by the abstract superclass, <code>NSNumber</code>. Although it is not precisely correct, it’s convenient to consider the <code>aChar</code>, <code>anInt</code>, <code>aFloat</code>, and <code>aDouble</code> objects to be instances of the <code>NSNumber</code> class, since they’re created by <code>NSNumber</code> class methods and accessed through instance methods declared by <code>NSNumber</code>.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW75" title="Class Clusters With Multiple Public Superclasses"></a><h3>Class Clusters With Multiple Public Superclasses</h3><p>In the example above, one abstract public class declares the interface for multiple private subclasses. This is a class cluster in the purest sense. It’s also possible, and often desirable, to have two (or possibly more) abstract public classes that declare the interface for the cluster. This is evident in the Foundation Framework, which includes these clusters:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Class Cluster</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Public Superclasses</p></th></tr><tr><td rowspan="2"  scope="row"><p><code>NSData</code></p></td><td ><p><code><a href="../../../Reference/Foundation/Classes/NSData_Class/Reference/Reference.html#//apple_ref/occ/cl/NSData" target="_top">NSData</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/Foundation/Classes/NSMutableData_Class/Reference/NSMutableData.html#//apple_ref/occ/cl/NSMutableData" target="_top">NSMutableData</a></code></p></td></tr><tr><td rowspan="2"  scope="row"><p><code>NSArray</code></p></td><td ><p><code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSArray" target="_top">NSArray</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableArray" target="_top">NSMutableArray</a></code></p></td></tr><tr><td rowspan="2"  scope="row"><p><code>NSDictionary</code></p></td><td ><p><code><a href="../../../Reference/Foundation/Classes/NSDictionary_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDictionary" target="_top">NSDictionary</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/Foundation/Classes/NSMutableDictionary_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableDictionary" target="_top">NSMutableDictionary</a></code></p></td></tr><tr><td rowspan="2"  scope="row"><p><code>NSString</code></p></td><td ><p><code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/cl/NSString" target="_top">NSString</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/Foundation/Classes/NSMutableString_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableString" target="_top">NSMutableString</a></code></p></td></tr></table></div><p>Other clusters of this type also exist, but these clearly illustrate how two abstract nodes cooperate in declaring the programmatic interface to a class cluster. In each of these clusters, one public node declares methods that all cluster objects can respond to, and the other node declares methods that are only appropriate for cluster objects that allow their contents to be modified.</p><p>This factoring of the cluster’s interface helps make an object-oriented framework’s programmatic interface more expressive. For example, imagine a Book object that declares this method:</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSString *)title;<span></span></pre></td></tr></table></div><p>The book object could return its own instance variable or create a new string object and return that—it doesn’t matter. It’s clear from this declaration that the returned string can’t be modified. Any attempt to modify the returned object will elicit a compiler warning.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW76" title="Creating Subclasses Within a Class Cluster"></a><h3>Creating Subclasses Within a Class Cluster</h3><p>The <a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_548"></a>class cluster architecture involves a trade-off between simplicity and extensibility: Having a few public classes stand in for a multitude of private ones makes it easier to learn and use the classes in a framework but somewhat harder to create subclasses within any of the clusters. However, if it’s rarely necessary to create a subclass, then the cluster architecture is clearly beneficial. Clusters are used in the Foundation Framework in just these situations.</p><p>If you find that a cluster doesn’t provide the functionality your program needs, then a subclass may be in order. For example, imagine that you want to create an array object whose storage is file-based rather than memory-based, as in the <code>NSArray</code> class cluster. Since you are changing the underlying storage mechanism of the class, you’d have to create a subclass. </p><p>On the other hand, in some cases it might be sufficient (and easier) to define a class that embeds within it an object from the cluster. Let’s say that your program needs to be alerted whenever some data is modified. In this case, creating a simple cover for a data object that the Foundation framework defines may be the best approach. An object of this class could intervene in messages that modify the data, intercepting the messages, acting on them, and then forwarding them to the embedded data object.</p><p>In summary, if you need to manage your object’s storage, create a true subclass. Otherwise, create a composite object, one that embeds a standard Foundation framework object in an object of your own design. The sections below give more detail on these two approaches.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW77" title="A True Subclass"></a><h4>A True Subclass</h4><p>A new class that you create within a class cluster must:</p><ul class="spaceabove"><li class="li"><p>Be a subclass of the cluster’s abstract superclass.</p></li><li class="li"><p>Declare its own storage.</p></li><li class="li"><p>Override the superclass’s primitive methods (described below).</p></li></ul><p>Since the cluster’s abstract superclass is the only publicly visible node in the cluster’s hierarchy, the first point is obvious. This implies that the new subclass will inherit the cluster’s interface but no instance variables, since the abstract superclass declares none. Thus the second point: The subclass must declare any instance variables it needs. Finally, the subclass must override any method it inherits that directly accesses an object’s instance variables. Such methods are called <em>primitive methods</em>.</p><p>A class’s primitive methods form the basis for its interface. For example, take the <code>NSArray</code> class, which declares the interface to objects that manage arrays of objects. In concept, an array stores a number of data items, each of which is accessible by index. <code>NSArray</code> expresses this abstract notion through its two primitive methods, <code>count</code> and <code>objectAtIndex:</code>. With these methods as a base, other methods—<em>derived methods</em>—can be implemented, for example:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Derived Method</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Possible Implementation</p></th></tr><tr><td  scope="row"><p><code>lastObject</code></p></td><td ><p>Find the last object by sending the array object this message: <code>[self objectAtIndex: ([self count] –1)]</code>.</p></td></tr><tr><td  scope="row"><p><code>containsObject:</code></p></td><td ><p>Find an object by repeatedly sending the array object an <code>objectAtIndex:</code> message, each time incrementing the index until all objects in the array have been tested.</p></td></tr></table></div><p>The division of an interface between primitive and derived methods makes creating subclasses easier. Your subclass must override inherited primitives, but having done so can be sure that all derived methods that it inherits will operate properly.</p><p>The primitive-derived distinction applies to the interface of a fully initialized object. The question of how <code>init...</code> methods should be handled in a subclass also needs to be addressed.</p><p>In general, a cluster’s abstract superclass declares a number of <code>init...</code> and <code>+ className</code> methods. As described in <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW18">“Creating Instances,”</a></span> the abstract class decides which concrete subclass to instantiate based your choice of <code>init...</code> or <code>+ className</code> method. You can consider that the abstract class declares these methods for the convenience of the subclass. Since the abstract class has no instance variables, it has no need of initialization methods.</p><p>Your subclass should declare its own <code>init...</code> (if it needs to initialize its instance variables) and possibly <code>+ className</code> methods. It should not rely on any of those that it inherits. To maintain its link in the initialization chain, it should invoke its superclass’s designated initializer within its own designated initializer method. (See “<span class="content_text"><!--a target="_top" -->The Runtime System<!--/a--></span>“ in <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em> for a discussion of designated initializers.) Within a class cluster, the designated initializer of the abstract superclass is always <code>init</code>.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW78" title="True Subclasses: An Example"></a><h4>True Subclasses: An Example</h4><p>An example will help clarify the foregoing discussion. Let’s say that you want to create a subclass of <code>NSArray</code>, named <code>MonthArray</code>, that returns the name of a month given its index position. However, a <code>MonthArray</code> object won’t actually store the array of month names as an instance variable. Instead, the method that returns a name given an index position (objectAtIndex:) will return constant strings. Thus, only twelve string objects will be allocated, no matter how many <code>MonthArray</code> objects exist in an application.</p><p>The <code>MonthArray</code> class is declared as:</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;foundation/foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>@interface MonthArray : NSArray<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ monthArray;<span></span></pre></td></tr><tr><td scope="row"><pre>- (unsigned)count;<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)objectAtIndex:(unsigned)index;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Note that the <code>MonthArray</code> class doesn’t declare an <code>init...</code> method since it has no instance variables to initialize. The <code>count</code> and <code>objectAtIndex:</code> methods simply cover the inherited primitive methods, as described above.</p><p>The implementation of the <code>MonthArray</code> class looks like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "MonthArray.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MonthArray<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static MonthArray *sharedMonthArray = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>static NSString *months[] = { @"January", @"February", @"March",<span></span></pre></td></tr><tr><td scope="row"><pre>    @"April", @"May", @"June", @"July", @"August", @"September",<span></span></pre></td></tr><tr><td scope="row"><pre>    @"October", @"November", @"December" };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ monthArray<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!sharedMonthArray) {<span></span></pre></td></tr><tr><td scope="row"><pre>        sharedMonthArray = [[MonthArray alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return sharedMonthArray;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (unsigned)count<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> return 12;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- objectAtIndex:(unsigned)index<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (index >= [self count])<span></span></pre></td></tr><tr><td scope="row"><pre>        [NSException raise:NSRangeException format:@"***%s: index<span></span></pre></td></tr><tr><td scope="row"><pre>            (%d) beyond bounds (%d)", sel_getName(_cmd), index,<span></span></pre></td></tr><tr><td scope="row"><pre>            [self count] - 1];<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        return months[index];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Since <code>MonthArray</code> overrides the inherited primitive methods, the derived methods that it inherits will work properly without being overridden. <code>NSArray</code>’s <code>lastObject</code>, <code>containsObject:</code>, <code>sortedArrayUsingSelector:</code>, <code>objectEnumerator</code>, and other methods work without problems for <code>MonthArray</code> objects.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW79" title="A Composite Object"></a><h4>A Composite Object</h4><p>By embedding a private cluster object in an object of your own design, you create a composite object. This composite object can rely on the cluster object for its basic functionality, only intercepting messages that it wants to handle in some particular way. Using this approach reduces the amount of code you must write and lets you take advantage of the tested code provided by the Foundation Framework.</p><p>A composite object can be viewed in this way:</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW80" title="Figure 2-13Embedding a Cluster Object"></a><p><strong>Figure 2-13&nbsp;&nbsp;</strong>Embedding a Cluster Object</p><img src = "../Art/compositeobject.gif" alt = "Embedding a Cluster Object" width="454" height="130"></div><br/><p>The composite object must declare itself to be a subclass of the cluster’s abstract node. As a subclass, it must override the superclass’s primitive methods. It can also override derived methods, but this isn’t necessary since the derived methods work through the primitive ones.</p><p>Using <code>NSArray</code>’s <code>count</code> method as an example, the intervening object’s implementation of a method it overrides can be as simple as:</p><div class="codesample"><table><tr><td scope="row"><pre>- (unsigned)count<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [embeddedObject count];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>However, your object could put code for its own purposes in the implementation of any method it overrides.</p><a name="//apple_ref/doc/uid/TP40002974-CH4-SW81" title="A Composite Object: An Example"></a><h4>A Composite Object: An Example</h4><p>To illustrate the use of a composite object, imagine you want a mutable array object that tests changes against some validation criteria before allowing any modification to the array’s contents. The example that follows describes a class called <code>ValidatingArray</code>, which contains a standard mutable array object. <code>ValidatingArray</code> overrides all of the primitive methods declared in its superclasses, <code>NSArray</code> and <code>NSMutableArray</code>. It also declares the <code>array</code>, <code>validatingArray</code>, and <code>init</code> methods, which can be used to create and initialize an instance:</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;foundation/foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface ValidatingArray : NSMutableArray<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableArray *embeddedArray;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ validatingArray;<span></span></pre></td></tr><tr><td scope="row"><pre>- init;<span></span></pre></td></tr><tr><td scope="row"><pre>- (unsigned)count;<span></span></pre></td></tr><tr><td scope="row"><pre>- objectAtIndex:(unsigned)index;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addObject:object;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)replaceObjectAtIndex:(unsigned)index withObject:object;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeLastObject;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)insertObject:object atIndex:(unsigned)index;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeObjectAtIndex:(unsigned)index;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The implementation file shows how, in a <code>ValidatingArray</code>’s <code>init</code> method, the embedded object is created and assigned to the <em>embeddedArray</em> variable. Messages that simply access the array but don’t modify its contents are relayed to the embedded object. Messages that could change the contents are scrutinized (here in pseudo-code) and relayed only if they pass the hypothetical validation test.<a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_549"></a></p><div class="codesample"><table><tr><td scope="row"><pre>#import "ValidatingArray.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation ValidatingArray<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- init<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self = [super init];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self) {<span></span></pre></td></tr><tr><td scope="row"><pre>        embeddedArray = [[NSMutableArray allocWithZone:[self zone]] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ validatingArray<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [[[self alloc] init] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (unsigned)count<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [embeddedArray count];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- objectAtIndex:(unsigned)index<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [embeddedArray objectAtIndex:index];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addObject:object<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (/* modification is valid */) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [embeddedArray addObject:object];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)replaceObjectAtIndex:(unsigned)index withObject:object;<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (/* modification is valid */) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [embeddedArray replaceObjectAtIndex:index withObject:object];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeLastObject;<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (/* modification is valid */) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [embeddedArray removeLastObject];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)insertObject:object atIndex:(unsigned)index;<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (/* modification is valid */) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [embeddedArray insertObject:object atIndex:index];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeObjectAtIndex:(unsigned)index;<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (/* modification is valid */) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [embeddedArray removeObjectAtIndex:index];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002974-CH4-SW32" title="Creating a Singleton Instance"></a><h2>Creating a Singleton Instance</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH4-DontLinkElementID_550"></a>Some classes of Foundation and the Application Kit create singleton objects: the sole allowable instance of a class in the current process. For example, the <code><a href="../../../Reference/Foundation/Classes/NSFileManager_Class/Reference/Reference.html#//apple_ref/occ/cl/NSFileManager" target="_top">NSFileManager</a></code> and the <code><a href="../../../Reference/ApplicationKit/Classes/NSWorkspace_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWorkspace" target="_top">NSWorkspace</a></code> classes instantiate singleton objects for use by a process. When you ask for an instance from these classes, they pass you a reference to the sole instance, allocating and initializing it if it doesn’t yet exist. </p><p>A singleton object acts as a kind of control center, directing or coordinating the services of the class. Your class should generate a singleton instance rather than multiple instances when there is conceptually only one instance (as with, for example, <code>NSWorkspace</code>). You use singleton instances rather than factory methods or functions when it is conceivable that there might be multiple instances one day. </p><p>To create a singleton, you need to do a few things in your code:</p><ul class="ul"><li class="li"><p>Declare a static instance of your singleton object and initialize it to <code>nil</code>.</p></li><li class="li"><p>In your class factory method for the class (named something like “sharedInstance” or “sharedManager”), generate an instance of the class but only if the static instance is <code>nil</code>.</p></li><li class="li"><p>Override the <code>allocWithZone:</code> method to ensure that another instance is not allocated if someone tries to allocate and initialize an instance of your class directly instead of using the class factory method.</p></li><li class="li"><p>Implement the base protocol methods <code>copyWithZone:</code>, <code>release</code>, <code>retain</code>, <code>retainCount</code>, and <code>autorelease</code> to do the appropriate things to ensure singleton status. (The last four of these methods apply to memory-managed code, not to garbage-collected code.)</p></li></ul><p><span class="content_text">Listing 2-15</span> illustrates how you might implement a singleton:</p><a name="//apple_ref/doc/uid/TP40002974-CH4-97333-CJBDDIBI" title="Listing 2-15Implementation of a singleton"></a><p class="codesample"><strong>Listing 2-15&nbsp;&nbsp;</strong>Implementation of a singleton</p><div class="codesample"><table><tr><td scope="row"><pre>static MyGizmoClass *sharedGizmoManager = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ (MyGizmoClass*)sharedManager<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    @synchronized(self) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (sharedGizmoManager == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [[self alloc] init]; // assignment not done here<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return sharedGizmoManager;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)allocWithZone:(NSZone *)zone<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    @synchronized(self) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (sharedGizmoManager == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>            sharedGizmoManager = [super allocWithZone:zone];<span></span></pre></td></tr><tr><td scope="row"><pre>            return sharedGizmoManager;  // assignment and return on first allocation<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return nil; //on subsequent allocation attempts return nil<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)copyWithZone:(NSZone *)zone<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)retain<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (unsigned)retainCount<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return UINT_MAX;  //denotes an object that cannot be released<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)release<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //do nothing<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)autorelease<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Situations could arise where you want a singleton instance (created and controlled by the class factory method) but also have the ability to create other instances as needed through allocation and initialization. In these cases, you would not override <code>allocWithZone:</code> and the other methods following it as shown in <span class="content_text"><a href="CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-97333-CJBDDIBI">Listing 2-15</a></span>. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WhatIsCocoa/WhatIsCocoa.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-11-19<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>