import java.awt.Frame;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;import java.io.IOException;import java.util.Vector;import com.apple.mrj.MRJOSType;import com.apple.mrj.MRJFileUtils;public class BatchJob implements Runnable{	/**	 * Constructs a new BatchJob	 * @param frame, the frame to use when displaying dialogs.	 * @param batchListener the ActionListener to notify when this job completes successfully.	 * @param rawFiles the array of File objects as they were passed to the application.	 * This may contain folders as well as files.	 * @see #processBatch()	 */	public BatchJob(Frame frame, ActionListener batchListener, File[] rawFiles)	{		this.batchListener	= batchListener;		this.rawFiles		= rawFiles;			this.frame			= frame;			isSuccessful		= false;		isStop				= false;		progressDialog		= new ProgressDialog(frame, false, new ProgressListener());			files				= new Vector();	}	/**	 * Start processing for the batch job.	 * @param myType the MacOS file type to search for	 * @param myCreator the MacOS creator type to set located files to.	 */	public void processBatch(MRJOSType myType, MRJOSType myCreator)	{		this.myType		= myType;		this.myCreator	= myCreator;		//Make the progress dialog visible.		//NOTE: if the progress dialog was modal, this will block!		//If a modal progress dialog is desired, you can put this call in its own thread.		progressDialog.setVisible(true);				Thread process = new Thread(this);		process.start();	}	/**	 * The main body for the processing associated with this batch job.	 */	public void run()	{		for (int i = 0; i < rawFiles.length; ++i)		{			gatherFiles(rawFiles[i]);		}		//We are done with pre-flight, now process the files.		processFiles();	}		/**	 * Recursive file gathering routine.	 * Recurses down a given file hierarchy gathering	 * all the non-directory files into the files vector.	 */	protected void gatherFiles(File file)	{		if(file != null)		{			//If the file is a directory, make sure its path ends in a /			//(forward slash) character, and recurse.			if (file.isDirectory())			{				java.lang.String directory = file.getPath();				if (!directory.endsWith("/"))					directory += "/";				java.lang.String[] fileList = file.list();				for (int fileInd = 0; fileInd < fileList.length; fileInd++)					this.gatherFiles(new File(directory + fileList[fileInd]));			}			//If the file is not a directory, it must be a leaf, so add the			//file to our vector to be processed later.			else			{				files.addElement(file);			}		}	}	/**	 * The main logic for processing the post-flight files.	 * Takes care of updating the progress dialog, displaying the	 * results dialog, and notifying the batchListener (if successfull).	 * @see #doForEachFile	 */	protected void processFiles()	{		if (files == null)			return;		File file;		int numFiles = files.size();		int errCount = 0;				if (progressDialog != null)		{			progressDialog.setFileCount(numFiles);			progressDialog.setFileIndex(0);		}				int i;		for (i = 0; i < numFiles && !isStop; ++i)		{			file = (File)files.elementAt(i);			if (progressDialog != null)			{				progressDialog.setFileIndex(i + 1);				progressDialog.setFileLabel(file.getName());			}						try			{				doForEachFile(file);			}			catch(Exception e)			{				++errCount;				System.err.println(e + " occured for " + file.toString());			}			try { Thread.sleep(PROCESS_SLEEP); } catch (InterruptedException exc) {}		}				isSuccessful = errCount == 0 && !isStop;				files = null;				if (progressDialog != null)			progressDialog.setVisible(false);		ResultsDialog resultsDialog = new ResultsDialog(frame);		resultsDialog.setLabel1("Done processing " + i + " of " + numFiles + " file" + (numFiles == 1 ? "" : "s") + ".");		resultsDialog.setLabel2("There " + (errCount == 1 ? "was" : "were") +  " " + (errCount == 0 ? "no" : "" + errCount) + " error" + (errCount == 1 ? "" : "s") + ".");				if (isStop)		{			resultsDialog.setLabel3("Processing was stopped by user.");		}		else		{			resultsDialog.setLabel3("Gave all '" + myType + "' files a creator of '" + myCreator + "'.");		}				resultsDialog.setVisible(true);				if(isSuccessful && batchListener != null)		{			batchListener.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, "BatchJob Finished"));		}	}		/**	 * Gets called on each post-flight file.	 * This is where each file should be processed (in whatever manner	 * intended).  Here we are just changing all files of a given type	 * to have a given creator.	 */	protected void doForEachFile(File file) throws IOException	{		//Filter for the desired type and change the creator.		MRJOSType fileType = MRJFileUtils.getFileType(file);		if (fileType.equals(myType))		{			MRJFileUtils.setFileCreator(file, myCreator);		}	}		/**	 * An ActionListener responsible for listening to the progress	 * dialog for user requests to stop the process.	 */	public class ProgressListener implements ActionListener	{		public void actionPerformed(ActionEvent event)		{			isStop = true;			progressDialog = null;		}	}	//The amount of time to give to other threads between	//each file processed.	protected static final int PROCESS_SLEEP = 30;			protected Vector files;	protected File[] rawFiles;	protected boolean isSuccessful;	protected boolean isStop;	protected ProgressDialog progressDialog;	protected MRJOSType myType;	protected MRJOSType myCreator;	protected Frame frame;	protected ActionListener batchListener;}