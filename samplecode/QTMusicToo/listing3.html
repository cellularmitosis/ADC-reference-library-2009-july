<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTMusicToo - /BigEasy/BigEasyControls.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">QTMusicToo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxMusicAudio-date.html" target="_blank">QuickTime > Audio</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTMusicToo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/BigEasy/BigEasyControls.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BigEasy/BigEasy2.c</option>
<option value="listing2.html">/BigEasy/BigEasy2.h</option>
<option value="listing3.html">/BigEasy/BigEasyControls.c</option>
<option value="listing4.html">/BigEasy/BigEasyControls.h</option>
<option value="listing5.html">/BigEasy/BigEasyDialogs.c</option>
<option value="listing6.html">/BigEasy/BigEasyDialogs.h</option>
<option value="listing7.html">/BigEasy/BigEasyGestalt.c</option>
<option value="listing8.html">/BigEasy/BigEasyGestalt.h</option>
<option value="listing9.html">/BigEasy/BigEasyGrafish.c</option>
<option value="listing10.html">/BigEasy/BigEasyGrafish.h</option>
<option value="listing11.html">/BigEasy/BigEasyPPC.c</option>
<option value="listing12.html">/BigEasy/BigEasyPPC.h</option>
<option value="listing13.html">/BigEasy/BigEasyStandardControls.c</option>
<option value="listing14.html">/BigEasy/BigEasyStandardControls.h</option>
<option value="listing15.html">/BigEasy/BigEasyTextish.c</option>
<option value="listing16.html">/BigEasy/BigEasyTextish.h</option>
<option value="listing17.html">/BigEasy/BigEasyUtils.c</option>
<option value="listing18.html">/BigEasy/BigEasyUtils.h</option>
<option value="listing19.html">/BigEasy/IconUtilsPriv.h</option>
<option value="listing20.html">/BigEasy/NWindows.c</option>
<option value="listing21.html">/BigEasy/OneWindow.c</option>
<option value="listing22.html">/•Instrument Editor/All The MIDI Components.h</option>
<option value="listing23.html">/•Instrument Editor/IE KeyboardDiagram.c</option>
<option value="listing24.html">/•Instrument Editor/IE KeyboardDiagram.h</option>
<option value="listing25.html">/•Instrument Editor/IE PrintUtilities.c</option>
<option value="listing26.html">/•Instrument Editor/IE PrintUtilities.h</option>
<option value="listing27.html">/•Instrument Editor/Instrument Editor Controls.c</option>
<option value="listing28.html">/•Instrument Editor/Instrument Editor Controls.h</option>
<option value="listing29.html">/•Instrument Editor/Instrument Editor Draw.c</option>
<option value="listing30.html">/•Instrument Editor/Instrument Editor Filing.c</option>
<option value="listing31.html">/•Instrument Editor/Instrument Editor Filing.h</option>
<option value="listing32.html">/•Instrument Editor/Instrument Editor Menus.c</option>
<option value="listing33.html">/•Instrument Editor/Instrument Editor Menus.h</option>
<option value="listing34.html">/•Instrument Editor/Instrument Editor.c</option>
<option value="listing35.html">/•Instrument Editor/Instrument Editor.h</option>
<option value="listing36.html">/•Instrument Editor/Instrument Editor.r</option>
<option value="listing37.html">/•Instrument Editor/Instrument Tests.c</option>
<option value="listing38.html">/•Instrument Editor/More IE Routines.c</option>
<option value="listing39.html">/•Instrument Editor/More IE Routines.h</option>
<option value="listing40.html">/•Instrument Picker Test/InstrumentPickerTest.c</option>
<option value="listing41.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.c</option>
<option value="listing42.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.h</option>
<option value="listing43.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.r</option>
<option value="listing44.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.c</option>
<option value="listing45.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.r</option>
<option value="listing46.html">/•QTMusic Sample Sequencer/Event Priority Queue.c</option>
<option value="listing47.html">/•QTMusic Sample Sequencer/Event Priority Queue.h</option>
<option value="listing48.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.c</option>
<option value="listing49.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.h</option>
<option value="listing50.html">/•QTMusic Sample Sequencer/SequencerTest Filing.c</option>
<option value="listing51.html">/•QTMusic Sample Sequencer/SequencerTest Filing.h</option>
<option value="listing52.html">/•QTMusic Sample Sequencer/SequencerTest Movies.h</option>
<option value="listing53.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.c</option>
<option value="listing54.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.h</option>
<option value="listing55.html">/•QTMusic Sample Sequencer/SequencerTest.c</option>
<option value="listing56.html">/•QTMusic Sample Sequencer/SequencerTest.h</option></select>
				</p>
				</form>
				<p><strong><a href="QTMusicToo.zip">Download Sample</a></strong> (&#147;QTMusicToo.zip&#148;, 115.5K)<BR>
<strong><a href="QTMusicToo.dmg">Download Sample</a></strong> (&#147;QTMusicToo.dmg&#148;, 173.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    BigEasyControls.c  Copyright:  &copy; 1990-1991, 1994 by Apple Computer, Inc., all rights reserved.    This file is used in these builds: Warhol  Change History (most recent first):    &lt;10&gt;  11-10-94  dvb         &lt;9&gt;   6/10/94  dvb    nil control list behaves better.     &lt;8&gt;   4/13/92  dvb    Minor bugs (empty controllist, &amp;c)     &lt;7&gt;    4/3/92  dvb    New calls.     &lt;6&gt;   5/28/91  JB    Added prototypes for BigEasy Proc Ptrs     &lt;5&gt;   5/22/91  PH    new style prototypes     &lt;4&gt;   4/25/91  JB    Changing to new THINK_C interface files     &lt;3&gt;   12/5/90  GW    Fix dispose easycontrol     &lt;2&gt;  11/17/90  dvb    Return unprocessed key-actions    &lt;1&gt;    11/17/90  dvb    New again after 1st CD!  To Do:*//*  * file: BigEasyControls.c  *  * started 25 May 1990 12:07:24 Friday at 310 Nobel  *   * david van brink  *  *//************************************* Inclusions************************************/#include &lt;Memory.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Events.h&gt;#define privateEasyControls#include &quot;BigEasy2.h&quot;#include &quot;BigEasyGrafish.h&quot;#include &quot;BigEasyTextish.h&quot;#include &quot;BigEasyControls.h&quot;/************************************* Globals************************************/static short defaultColors[6] =  {  0,  PackColor555(46035,46035,46035),  PackColor555(25535,65535,25535),  PackColor555(24000,0,0),  0,  0  };/************************************* Prototypes************************************/static void SelectEasyControl(easyControl ech, easyControlList list);static void UnhighlightSelection(easyControlList list);static void WalkDrawEasyControlList(easyControlList list,long,long);static void WalkInvalEasyControlList(easyControlList list,long,long);static short GetControlNumber(easyControl ech);static void SetListText(easyControlList listH);/************************************* Routines************************************/easyControl NewEasyControl(easyControlType *type,Rect *r, long variation, void *style,    long refcon,long id,long value,easyControlList list)/*  * Make a new handle for an easy control, and call the  * init routine for that control. Then, add it to the  * list passed in.  */  {  easyControl ech;  register easyControlPtr ec;  register easyControl w;  easyControlListPtr l;  ech = (easyControl)NewHandle(sizeof(easyControlRecord));  FailNil(ech);  HLock((Handle)ech);  ec = *ech;  ec-&gt;next = nil;  ec-&gt;list = list;  l = *list;  w = l-&gt;firstControl;  if(!w)    {    ec-&gt;prev = nil;    l-&gt;firstControl = ech;    }  else    {    while((**w).next)      w = (**w).next;    (**w).next = ech;    ec-&gt;prev = w;    }  ec-&gt;type = type;  ec-&gt;rect = *r;  ec-&gt;flags = easyControlActive;  ec-&gt;refcon = refcon;  ec-&gt;id = id;  ec-&gt;variation = variation;  ec-&gt;value = value;  ec-&gt;style = style;  ec-&gt;state = nil;  ec-&gt;color[0] = defaultColors[0];  ec-&gt;color[1] = defaultColors[1];  ec-&gt;color[2] = defaultColors[2];  ec-&gt;color[3] = defaultColors[3];  ec-&gt;color[4] = defaultColors[4];  ec-&gt;color[5] = defaultColors[5];  ec-&gt;actionProc = nil;  ec-&gt;initActionProc = nil;  ec-&gt;doneActionProc = nil;  ec-&gt;valueProc = nil;/*  ec-&gt;keyProc = nil; */  ec-&gt;low = 0;  ec-&gt;high = 100;  SetListText(list);  (*type-&gt;newProc)(ec);  HUnlock((Handle)ech);  return ech;  }void DisposeEasyControl(easyControl ech, easyControlList list)/*  * remove a control from the list passed  */  {  register easyControl *w;  register easyControlPtr ec;  register easyControlListPtr l;  easyControl last;  l = *list;  last = nil;  ec = *ech;  w = &amp;l-&gt;firstControl;  while(*w)    {    if(*w == ech)      {      *w = ec-&gt;next;      if (*w != nil)  /* Make sure its not nil - GW */        (**(ec-&gt;next)).prev = last;      goto goHome;      }    else      {      last = *w;      w = &amp;(***w).next;      }    }goHome:;  DisposHandle((Handle)ech);  }void DisposeEasyControlList(easyControlList list)  {  register easyControl w,n;  w = (**list).firstControl;  while(w)    {    n = (**w).next;    DisposeEasyControl(w,list);    w = n;    }  DisposHandle((Handle)list);  }easyControlList NewEasyControlList(WindowPtr w,long refcon)  {  easyControlList listH;  easyControlListPtr list;  listH = (easyControlList)NewHandle(sizeof(easyControlListRecord));  list = *listH;  list-&gt;firstControl = nil;  list-&gt;selectedControl = nil;  list-&gt;nextSelectedControl = nil;  list-&gt;ownerWindow = w;  list-&gt;refcon = refcon;  list-&gt;textFont = 3;  /* geneva */  list-&gt;textSize = 9;  list-&gt;textFace = 0;  list-&gt;nextIdle = 0;  list-&gt;ticksPerIdle = 30;  return listH;  }void SetListText(easyControlList listH)  {  TextFont((**listH).textFont);  TextFace((**listH).textFace);  TextSize((**listH).textSize);  }void KeyEasyControlList(easyControlList listH,short key,short mods,controlClickResult *ccr)/*  * Pass a keypress to the currently  * selected control. we swipe &quot;tab&quot;s  * to skip from control to control, and  * &quot;esc&quot; to say &quot;no control selected&quot;.  */  {  register easyControl ech;  register easyControlPtr ec;  register easyControlListPtr list;  short listHState;  Boolean tookKey;  listHState = HGetState((Handle)listH);  HLock((Handle)listH);  list = *listH;  if(ccr)    {    ccr-&gt;whichControl = nil;    ccr-&gt;tracked = false;    ccr-&gt;value = 0;    ccr-&gt;refcon = 0;    ccr-&gt;id = 0;    }  ech = list-&gt;selectedControl;  if(key == '\t')    {  nextEch:    if(ech)      {      if(mods &amp; shiftKey)        ech = (**ech).prev;      else        ech =(**ech).next;      }    else      {      ech = list-&gt;firstControl;      if(mods &amp; shiftKey &amp;&amp; ech)        while((**ech).next)          ech = (**ech).next;      }    if(list-&gt;nextSelectedControl)      {      ech = list-&gt;nextSelectedControl;      list-&gt;nextSelectedControl = nil;      }    if(ech &amp;&amp; !(**ech).type-&gt;keyProc)    /* if its got no keyproc, it doesn't do keypresses */      goto nextEch;    SelectEasyControl(ech,listH);    }  else if(key == 27)      /* the escape key */    {    SelectEasyControl(nil,listH);    list-&gt;nextSelectedControl = ech;    }  else    {    if(ech)      {      HLock((Handle)ech);      ec = *ech;      (*ec-&gt;type-&gt;keyProc)(ec,key,mods,&amp;tookKey);      if(ccr)        {        ccr-&gt;whichControl = ech;        ccr-&gt;tracked = tookKey;        ccr-&gt;value = ec-&gt;value;        ccr-&gt;refcon = ec-&gt;refcon;        ccr-&gt;id = ec-&gt;id;        }      HUnlock((Handle)ech);      UnhighlightSelection(listH);      /* and forestall the next idle-blink for a while */      }    }  HSetState((Handle)listH,listHState);  }short GetControlNumber(register easyControl ech)/*  * return the position in whatever list owns this control  */  {  short n;  n = 1;  while( (**ech).prev)    {    n++;    ech = (**ech).prev;    }  return n;  }void UnhighlightSelection(easyControlList listH)/*  * if there's a selected control,  * put it in the unhighlighted phase  */  {  register easyControl ech;  register easyControlPtr ec;  easyControlListPtr list;  short listHState;  listHState = HGetState((Handle)listH);  HLock((Handle)listH);  list = *listH;  ech = list-&gt;selectedControl;  if(ech)    {    list-&gt;nextIdle = TickCount()+list-&gt;ticksPerIdle;    /* reset the idling phase to normal  */    HLock((Handle)ech);    ec = *ech;    list-&gt;idleRef = 0;    SetPort((*ec-&gt;list)-&gt;ownerWindow);    (*ec-&gt;type-&gt;idleProc)(ec,&amp;list-&gt;idleRef);    HUnlock((Handle)ech);    }  HSetState((Handle)listH,listHState);  }easyControl ClickEasyControlList(easyControlList listH,Point p,    controlClickResult *ccr,short mods)  {  register easyControl w;  register easyControlPtr ec;  easyControlListPtr list;  short trackResult;  short whichControl;  short listHState;  listHState = HGetState((Handle)listH);  HLock((Handle)listH);  list = *listH;  w = list-&gt;firstControl;  whichControl = 0;  if(ccr)    {    ccr-&gt;whichControl = nil;    ccr-&gt;tracked = false;    ccr-&gt;value = 0;    ccr-&gt;refcon = 0;    ccr-&gt;id = 0;    }  while(w)    {    whichControl++;    if(PtInRect(p,&amp;(**w).rect) &amp;&amp; (**w).type-&gt;trackProc)    /* in rect and mouse sensitive */      {      SelectEasyControl(nil,listH);      HLock((Handle)w);      ec = *w;      ec-&gt;flags |= easyControlTracking;      if(ec-&gt;type-&gt;keyProc)              /* never select keyless control */        list-&gt;nextSelectedControl = w;      trackResult = 0;      ec-&gt;flags |= easyControlSetValue;      (*ec-&gt;type-&gt;trackProc)(ec,p,&amp;trackResult,mods);      if(trackResult &amp;&amp; ec-&gt;valueProc)        (*ec-&gt;valueProc)(w);      ec-&gt;flags &amp;= ~easyControlSetValue;      if(ccr)        {        ccr-&gt;whichControl = w;        ccr-&gt;tracked = true;        ccr-&gt;value = ec-&gt;value;        ccr-&gt;refcon = ec-&gt;refcon;        ccr-&gt;id = ec-&gt;id;        }      ec-&gt;flags &amp;= ~easyControlTracking;      (*ec-&gt;type-&gt;drawValueProc)(ec);      HUnlock((Handle)w);      goto goHome;      }    else      w = (**w).next;    }goHome:;  HSetState((Handle)listH,listHState);  return w;  }void DrawEasyControlList(register easyControlList list)  {  WalkDrawEasyControlList(list,~0,0);  }void DeactivateEasyControlList(easyControlList list)/*  * A window should call this when it  * becomes un-frontmost  */  {  WalkDrawEasyControlList(list,~0,easyControlBack);  } void ActivateEasyControlList(easyControlList list)/*  * A window should call this when it  * becomes frontmost  */  {  WalkInvalEasyControlList(list,~easyControlBack,0);  } void WalkDrawEasyControlList(easyControlList listH,long and,long or)/*  * The gut routine of Draw, Activate, and DeactivateEasyControlList  */  {  register easyControlPtr ec;  register easyControl w;  register easyControlListPtr list;  short listHState;  GrafPtr oldPort;  if(!listH)    goto goHome;  GetPort(&amp;oldPort);  listHState = HGetState((Handle)listH);  HLock((Handle)listH);  list = *listH;  SetPort(list-&gt;ownerWindow);  SetListText(listH);  w = list-&gt;firstControl;  while (w)    {    HLock((Handle)w);    ec = *w;    ec-&gt;flags &amp;= and;    ec-&gt;flags |= or;    (*ec-&gt;type-&gt;drawProc)(ec);    ValidRect(&amp;ec-&gt;rect);    HUnlock((Handle)w);    w = ec-&gt;next;    }  HSetState((Handle)listH,listHState);  SetPort(oldPort);goHome:;  } void WalkInvalEasyControlList(easyControlList listH,long and,long or)/*  * The gut routine of Draw, Activate, and DeactivateEasyControlList  */  {  register easyControlPtr ec;  register easyControl w;  register easyControlListPtr list;  short listHState;  listHState = HGetState((Handle)listH);  HLock((Handle)listH);  list = *listH;  SetPort(list-&gt;ownerWindow);  w = list-&gt;firstControl;  while (w)    {    HLock((Handle)w);    ec = *w;    ec-&gt;flags &amp;= and;    ec-&gt;flags |= or;    InvalRect(&amp;ec-&gt;rect);    HUnlock((Handle)w);    w = ec-&gt;next;    }  HSetState((Handle)listH,listHState);  } void IdleEasyControlList(register easyControlList listH)  {  register easyControl ech;  easyControlPtr ec;  register easyControlListPtr list;  long t;  short listHState;  listHState = HGetState((Handle)listH);  HLock((Handle)listH);  list = *listH;  ech = list-&gt;selectedControl;  if(ech)    {    t = TickCount();    if(t &gt; list-&gt;nextIdle)      {      list-&gt;nextIdle = t+list-&gt;ticksPerIdle;      list-&gt;idleRef++;      HLock((Handle)ech);      ec = *ech;      SetPort((*ec-&gt;list)-&gt;ownerWindow);      (*ec-&gt;type-&gt;idleProc)(ec,&amp;list-&gt;idleRef);      HUnlock((Handle)ech);      }    }  HSetState((Handle)listH,listHState);  }void SetEasyControlValue(register easyControl ech,long v)  {  register easyControlPtr ec;  becSetValueProcPtr svp;  HLock((Handle)ech);  ec = *ech;  SetPort((**ec-&gt;list).ownerWindow);  svp = ec-&gt;type-&gt;setValueProc;  if(svp)    (*svp)(ec,v);  else    ec-&gt;value = v;  ec-&gt;flags |= easyControlSetValue;  SetListText(ec-&gt;list);  (*ec-&gt;type-&gt;drawValueProc)(ec);  ec-&gt;flags &amp;= ~easyControlSetValue;  HUnlock((Handle)ech);  }long GetEasyControlValue(easyControl ech)  {  return (**ech).value;  }long GetEasyControlRefcon(easyControl ech)  {  return (**ech).refcon;  }long GetEasyControlID(easyControl ech)  {  return (**ech).id;  }void SetEasyControlRange(easyControl ech,long l,long h)  {  register easyControlPtr ec;  ec = *ech;  ec-&gt;low = l;  ec-&gt;high = h;  }void SetEasyControlValueProc(easyControl ech,becValueProcPtr proc)  {  register easyControlPtr ec;  ec = *ech;  ec-&gt;valueProc = proc;  }void SetEasyControlActionProc(easyControl ech,becActionProcPtr proc)  {  register easyControlPtr ec;  ec = *ech;  ec-&gt;actionProc = proc;  }void SetEasyControlInitActionProc(easyControl ech,becInitActionProcPtr proc)  {  register easyControlPtr ec;  ec = *ech;  ec-&gt;initActionProc = proc;  }void SetEasyControlDoneActionProc(easyControl ech,becDoneActionProcPtr proc)  {  register easyControlPtr ec;  ec = *ech;  ec-&gt;doneActionProc = proc;  }void GetEasyControlColors(easyControl ech,register short *colors)  {  register short i;  register short *src;  if(ech)    src = &amp;(**ech).color[0];  else    src = &amp;defaultColors[0];  for(i = 5; i&gt;=0; i--)    *colors++ = *src++;  }void SetEasyControlColors(easyControl ech,register short *colors)  {  register short i;  register short *dst;  if(ech)    dst = &amp;(**ech).color[0];  else    dst = &amp;defaultColors[0];  for(i = 5; i&gt;=0; i--)    *dst++ = *colors++;  }void SelectEasyControl(easyControl ech,easyControlList listH)/*  * Unselect the current one (if any)  * and start the new one blinking.  */  {  register easyControlListPtr list;  short listHState;  listHState = HGetState((Handle)listH);  HLock((Handle)listH);  list = *listH;  list-&gt;idleRef = 0;  UnhighlightSelection(listH);  list-&gt;selectedControl = ech;  list-&gt;nextIdle = 0;  IdleEasyControlList(listH);  HSetState((Handle)listH,listHState);  }void GetEasyControlRect(easyControl ech,Rect *r)/*  * Return the current bounds of the control  */  {  *r = (**ech).rect;  }void SetEasyControlRect(easyControl ech,Rect *r)/*  * Move the control to the newly specified rectangle  */  {  register easyControlPtr ec;  HLock((Handle)ech);  ec = *ech;  SetPort((*ec-&gt;list)-&gt;ownerWindow);  InvalRect(&amp;ec-&gt;rect);  ec-&gt;rect = *r;  ec-&gt;flags |= easyControlMoved;  InvalRect(&amp;ec-&gt;rect);  HUnlock((Handle)ech);  }unsigned short Replicate555(register unsigned short x)  {  x &amp;= 0x001F;  return (x&lt;&lt;11) | (x&lt;&lt;6) | (x&lt;&lt;1) | (x&gt;&gt;4);  }void Color555(register short x,register RGBColor *c)  {  c-&gt;red = Replicate555(x&gt;&gt;10);  c-&gt;green = Replicate555(x&gt;&gt;5);  c-&gt;blue = Replicate555(x);  }void Fore555(register short x)  {  RGBColor c;  Color555(x,&amp;c);  RGBForeColor(&amp;c);  RGBBackColor(&amp;c);  }#define kGrade 24000static long PinAdd(long,long);static long PinAdd(register long a,register long b)  {  a+= b;  if(a &gt; 65535)    a = 65535;  else if(a &lt; 0)    a = 0;  return a;  }void Fore555Light(register short x)  {  RGBColor c;  Color555(x,&amp;c);  c.red = PinAdd(c.red,kGrade);  c.green = PinAdd(c.green,kGrade);  c.blue = PinAdd(c.blue,kGrade);/*  c.green = (c.green + 65535L)&gt;&gt;1;  c.blue = (c.blue + 65535L)&gt;&gt;1;*/  RGBForeColor(&amp;c);  }void Fore555Dark(register short x)  {  RGBColor c;  Color555(x,&amp;c);  c.red = PinAdd(c.red,-kGrade);  c.green = PinAdd(c.green,-kGrade);  c.blue = PinAdd(c.blue,-kGrade);/*  c.red = c.red &gt;&gt; 1;  c.green = c.green &gt;&gt; 1;  c.blue = c.blue &gt;&gt; 1;*/  RGBForeColor(&amp;c);  }#define kCCEdge 10000void Fore555Contrast(register short x)/*  * Make a color that contrasts well with  * the passed color: invert if close to a  * side of the color cube, or shift by 32768  */  {  RGBColor c;  Color555(x,&amp;c);  if(c.red &lt; kCCEdge || c.red &gt; (65535-kCCEdge) ||      c.green &lt; kCCEdge || c.green &gt; (65535-kCCEdge) ||      c.blue &lt; kCCEdge || c.blue &gt; (65535-kCCEdge) )    {    c.red = ~c.red;    c.green = ~c.green;    c.blue = ~c.blue;    }  else    {    c.red += 32768;    c.green += 32768;    c.blue += 32768;    }  RGBForeColor(&amp;c);  }void RaisedRect(register Rect *r,register short x)/*  * Draw rectangle r with a 1 pixel highlight  * to raise it off the screen  */  {  Fore555(x);  if( ((r-&gt;right - r-&gt;left) &lt;= 2) || ((r-&gt;bottom - r-&gt;top) &lt;= 2) )    PaintRect(r);  else    {    PenSize(1,1);    PaintRect(r);    Fore555Light(x);    MoveTo(r-&gt;left,r-&gt;bottom-1);    LineTo(r-&gt;left,r-&gt;top);    LineTo(r-&gt;right-1,r-&gt;top);    Fore555Dark(x);    LineTo(r-&gt;right-1,r-&gt;bottom-1);    LineTo(r-&gt;left,r-&gt;bottom-1);    }  }void LoweredRect(Rect *r,register short x)/*  * Draw rectangle r with a 1 pixel highlight  * to raise it off the screen  */  {  PenSize(1,1);  Fore555(x);  PaintRect(r);  Fore555Dark(x);  MoveTo(r-&gt;left,r-&gt;bottom-1);  LineTo(r-&gt;left,r-&gt;top);  LineTo(r-&gt;right-1,r-&gt;top);  Fore555Light(x);  LineTo(r-&gt;right-1,r-&gt;bottom-1);  LineTo(r-&gt;left,r-&gt;bottom-1);  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTMusicToo/listing3.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTMusicToo/listing3.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTMusicToo/listing3.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>