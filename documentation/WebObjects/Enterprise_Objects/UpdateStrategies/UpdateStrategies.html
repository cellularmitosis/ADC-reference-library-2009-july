<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>WebObjects Enterprise Objects Programming Guide: Update Strategies</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Update Strategies"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001011-CH209" title="Update Strategies"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../InternetWeb/index.html#//apple_ref/doc/uid/TP30000440-TP30000469" target="_top">Internet &amp; Web</a> &gt; <a href="../../../InternetWeb/WebObjects-date.html#//apple_ref/doc/uid/TP30000440-TP30000469-TP30000592" target="_top">WebObjects</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30001011-CH201-DontLinkElementID_1">WebObjects Enterprise Objects Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Saving/Saving.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Connecting/Connecting.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_150" title="Update Strategies"></a><h1><a name="//apple_ref/doc/uid/TP30001011-CH209-TP1" title="Update Strategies"></a>Update Strategies</h1><p>The applications you build with Enterprise Objects will likely be used simultaneously by many different users. These users usually can access the same set of data and probably have the rights to update all or part of that data set. But what happens when multiple users try to update the same data simultaneously? How do you prevent users from overwriting other user’s work? This realm of database application development is referred to as <strong>update conflicts</strong>.</p><p>This chapter discusses the update strategies available in Enterprise Objects. It is divided into the following sections:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TPXREF167">“Choosing a Strategy”</a></span> discusses the available strategies for dealing with update conflicts.</p></li><li class="li"><p><span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TPXREF168">“Inside Optimistic Locking”</a></span> provides details on the mechanics of Enterprise Object’s optimistic locking mechanism.</p></li><li class="li"><p><span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-BFJHFCHE">“Multiple Coordinators and Optimistic Locking”</a></span> discusses how optimistic locking is affected when you use multiple object store coordinators.</p></li><li class="li"><p><span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TPXREF170">“Using Optimistic Locking”</a></span> discusses what you need to do to use optimistic locking in an Enterprise Objects application.</p></li><li class="li"><p><span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TPXREF166">“Prevention”</a></span> discusses how to instrument your applications to prevent update conflicts.</p></li><li class="li"><p><span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TPXREF169">“Recovery”</a></span> discusses how to instrument your applications to recover from update conflicts, specifically optimistic locking conflicts.</p></li><li class="li"><p><span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-BHAHFAFH">“Recovering and Refaulting”</a></span> shows you one way to recover from an optimistic locking failure.</p></li><li class="li"><p><span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-BHADAIHE">“Recovering and Last Write Wins”</a></span> shows you an advanced way to recover from an optimistic locking failure.</p></li></ul><a name="//apple_ref/doc/uid/TP30001011-CH209-TPXREF167" title="Choosing a Strategy"></a><h2>Choosing a Strategy</h2><p>An <strong>update strategy</strong> determines how update conflicts should be handled. The most common update strategy in database application development is <strong>locking</strong><a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_625"></a>. A locking strategy represents a preventative approach to managing update conflicts. There are a few different locking strategies, the most common of which is pessimistic locking. Using the pessimistic locking approach, a row of data in the database is locked when it is fetched to prevent other users from accessing that row of data.</p><p>It is generally a poor approach in three-tier database applications. Of the many reasons that make it a poor approach, perhaps the most important is that of all the data a given user fetches, they are likely to edit only a small amount of that data. When you implement a pessimistic locking strategy, however, you prevent other users from even viewing the data that one user has accessed. So the pessimistic approach severely impacts the usability of your application and compromises the value of the application’s data (since users aren’t guaranteed that they can see all the data).</p><p>Although a pessimistic locking strategy largely guarantees that update conflicts won’t occur, pessimistic locking has these undesirable effects:</p><ul class="ul"><li class="li"><p>Not all databases support pessimistic locking.</p></li><li class="li"><p>Databases support pessimistic locking in different ways.</p></li><li class="li"><p>Pessimistic locking prevents other users from reading locked data.</p></li><li class="li"><p>Pessimistic locking can cause deadlocks and excessive locking.</p></li></ul><p>Consistent with Enterprise Object’s abstract character, it provides a locking strategy that works at a higher level than the database. This approach is called <strong>optimistic locking</strong>. With optimistic locking, database rows are never actually locked. This strategy doesn’t detect update conflicts until an application attempts to save changes to the database. Optimistic locking provides these advantages:</p><ul class="ul"><li class="li"><p>It is supported by all databases.</p></li><li class="li"><p>It is database independent.</p></li><li class="li"><p>It is easy to use.</p></li><li class="li"><p>It doesn’t use any extra database resources.</p></li></ul><p>The recommended update strategy in an Enterprise Objects application is optimistic locking. In addition to pessimistic locking, Enterprise Objects supports other locking strategies but they are not generally appropriate for three-tier application environments.</p><a name="//apple_ref/doc/uid/TP30001011-CH209-TPXREF168" title="Inside Optimistic Locking"></a><h2>Inside Optimistic Locking</h2><p>By default, Enterprise Objects uses optimistic locking<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_626"></a> to manage update conflicts. The idea behind optimistic locking is rather simple: When a user attempts to save changes made to an enterprise object, the framework compares the data in that object’s snapshots with the current data in the database. If the comparison yields no differences, the save is allowed to execute.</p><p>In more detail, when data is fetched from a data source, Enterprise Objects records a snapshot for each row of data that is fetched. It stores these snapshots in an EODatabaseContext object. From these snapshots, enterprise object instances are created. When users make changes to the data in enterprise object instances and attempt to commit those changes back to the data source, the framework finds the object’s corresponding row-level snapshots and identifies the locking attributes in those snapshots. In the <code>UPDATE</code> statement, it uses these values in a <code>WHERE</code> clause to make sure the row that is being updated hasn’t changed in the database since it was last fetched.</p><p>If the update operation returns zero rows, it means that the values in the columns referenced in the update’s <code>WHERE<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_627"></a></code> clause changed, which means that the data in the database that corresponds to the enterprise object instance that is trying to save has been changed by another user or process, and an optimistic locking exception is thrown.</p><p>Consider this example. Using the entity described in <span class="content_text"><a href="../EnterpriseObjects/EnterpriseObjects.html#//apple_ref/doc/uid/TP30001011-CH203-CEHBGGIA">“Reference Entity,”</a></span> suppose a Listing enterprise object is fetched and has the following data values:</p><ul class="ul"><li class="li"><p><code>bathrooms</code>, 2</p></li><li class="li"><p><code>bedrooms</code>, 4</p></li></ul><p>Then suppose that a user changes the value of the <code>bathrooms</code> property to 2.5. When the user attempts to save that change, the following SQL is generated: <code>UPDATE LISTING SET BATHROOMS = 2.5 WHERE (BATHROOMS = 2 AND BEDROOMS = 4)</code>. </p><p>The columns specified in the <code>WHERE</code> clause include only the attributes that are marked for locking in the application’s EOModel. If this update returns zero rows, it means that the condition of the <code>WHERE</code> clause isn’t satisfied, which means that the enterprise object’s data in the database changed from the time it was last fetched—an optimistic locking failure.</p><p>When a user makes changes to data and attempts to save those changes, they must be reasonably guaranteed that the data they edited represents the freshest state of the data in the database. Simply committing a user’s changes back to the data source without determining if the data in the data source has changed compromises data consistency and integrity.</p><a name="//apple_ref/doc/uid/TP30001011-CH209-BFJHFCHE" title="Multiple Coordinators and Optimistic Locking"></a><h2>Multiple Coordinators and Optimistic Locking</h2><p>In some ways, when you provide each session with its own access layer<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_628"></a> stack, you complicate the optimistic<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_629"></a> locking equation. When multiple users share the same row-level snapshots, in contrast, you minimize the opportunities for multiple users to cause an optimistic locking conflict. </p><p>Consider the case when user A and user B share row-level snapshots and both users open a record that contains the same row of data. When user A make changes to that row and commits those changes back to the data source, the snapshot of that row reflects user A’s changes. When user B requests the same record after user A changes it, user B is guaranteed to see the data with user A’s changes. In this scenario, both users share the same set of cached data.</p><p>Then consider the case when user A and user B don’t share row-level snapshots. When user A makes changes to a row and commits those changes back to the data source, user B doesn’t see those changes unless they explicitly request fresh data from the database. When user B changes the same record and attempts to commit those changes, an optimistic locking exception is thrown since user B was editing stale data. (The exception usually occurs in the method <code>updateValuesInRowDescribedByQualifier</code> in a EOAdaptorChannel subclass).</p><p>If you want to provide each session with an independent access layer stack, there are a number of workarounds to deal with the optimistic locking issues that result from that configuration. As discussed in <span class="content_text"><a href="../Fetching/Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADDGFAG">“Ensuring Fresh Data,”</a></span> you can explicitly set the fetch timestamp on an editing context to encourage refetching from the data source rather than from the access layer’s row-level snapshots. While this causes an inordinate amount of fetching, depending on the average size of an application’s data sets, it may be a viable option.</p><p>Another workaround is to perform raw row operations—operations that don’t automatically result in the creation of enterprise object instances from fetched data. The results of raw row operations—such as raw row fetching, raw SQL operations, or fetch specifications that fetch raw rows—are not cached so you don’t need to worry about optimistic locking. The optimistic locking mechanism is effectively bypassed for raw row operations. This has other significant consequences as discussed in <span class="content_text"><a href="../Fetching/Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF161">“Raw Row Fetching.”</a></span></p><a name="//apple_ref/doc/uid/TP30001011-CH209-TPXREF170" title="Using Optimistic Locking"></a><h2>Using Optimistic Locking</h2><p>Although optimistic<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_630"></a> locking is enabled by default in an Enterprise Objects application, you still need to make decisions that affect how it works. At minimum, you need to select which attributes in your application’s entities participate in optimistic locking. You identify an attribute as a participant in optimistic locking by selecting its locking characteristic in EOModeler. Attributes that are selected for locking appear with a lock icon in their row. </p><p>By default, all attributes you add to entities other than primary keys are selected for optimistic locking. However, selecting all types of attributes for optimistic locking is not optimum and can result in serious performance implications. Consider these guidelines when choosing which attributes to select for locking:</p><ul class="ul"><li class="li"><p>Binary data types (such as <code>BLOB</code>, <code>RAW</code>, <code>object</code>, <code>binary</code>) must not be selected for locking since they are not easily comparable to one another.</p></li><li class="li"><p>Avoid locking on nonbinary data types that contain a lot of data as snapshot comparisons consume resources in proportion to their size. For example, a <code>varchar</code> column of width 2048 should not be selected for locking.</p></li></ul><a name="//apple_ref/doc/uid/TP30001011-CH209-TPXREF166" title="Prevention"></a><h2>Prevention</h2><p>Before determining how to instrument your application to deal with update conflicts<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_631"></a>, you should understand the mechanisms Enterprise Objects uses to prevent update conflicts, and especially how you can utilize these mechanisms in your applications.</p><p>Within Enterprise Objects, there are a number of contexts in which the preventative mechanisms for avoiding update conflicts work. These contexts include application instances, individual sessions, and an application’s data sources.</p><p>Within a given application instance, an Enterprise Objects application that uses a single access layer stack (as described in <span class="content_text"><a href="../Geography/Geography.html#//apple_ref/doc/uid/TP30001011-CH205-TP1">“Core Framework Stack”</a></span> provides a single database context (per data source) for all the application’s sessions. When sessions share a database context, they share row-level snapshots that participate in the update strategy called optimistic locking. By sharing row-level snapshots, multiple sessions are less likely to encounter optimistic locking exceptions caused by other sessions since the shared snapshots contribute to fresher data in each session than if the snapshots aren’t shared.</p><p>Within a given session, Enterprise Objects provides a change notification infrastructure that updates in-memory enterprise object instances when the data in other enterprise object instances changes. This helps to ensure that within a given session, a user sees the freshest data throughout, especially when they’ve changed data. This helps minimize the possibility of a given session from triggering an optimistic locking failure based on data that is edited within that session. For example, if a session edits a Listing enterprise object early in the session and then later edits it again, notifications ensure that the second time the Listing object is edited, it reflects the changes made in the first edit. Otherwise, sessions would likely overwrite their own data, causing optimistic locking failures.</p><p>Finally, within a database that an Enterprise Objects application uses, optimistic locking ensures that one user’s changes aren’t overwritten by another user’s changes. How this works is discussed in <span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TPXREF168">“Inside Optimistic Locking.”</a></span></p><p>Mechanisms within each of these three realms contribute to the prevention of update conflicts. In most applications, you’ll need to take some control over the mechanisms in each realm. Perhaps the most common type of intervention is adjusting an editing context’s fetch timestamp to encourage more fetching from the database, which ensures that an application’s user interface reflects fresh data. It is discussed in <span class="content_text"><a href="../Fetching/Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADDGFAG">“Ensuring Fresh Data.”</a></span></p><a name="//apple_ref/doc/uid/TP30001011-CH209-TPXREF169" title="Recovery"></a><h2>Recovery</h2><p>Instrumenting your applications to prevent update conflicts may not be enough to deal with the problem. It’s also prudent to instrument your applications to recover<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_632"></a> gracefully when an update conflict occurs. This section discusses what you need to think about to instrument recovery and provides code samples that can help you implement a recovery strategy.</p><p>When an optimistic locking conflict is detected, an EOGeneralAdaptorException is thrown. You can do a number of things to deal with this exception. By default, Enterprise Objects doesn’t do anything when the exception is thrown. A common design pattern is to wrap an invocation of <code>EOEditingContext.saveChanges()</code> in a try-catch block. In the catch block, you can choose to do a number of things.</p><p>You can choose to do nothing, which simply hides the exception from the user. You can choose to identify the affected enterprise objects, refault them, tell the user to make their changes and try saving again, as discussed in <span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-BHAHFAFH">“Recovering and Refaulting.”</a></span> You can choose to identify the affected enterprise objects, identify the changes that failed to save, and choose to save those changes again, disregarding the data in the database, as discussed in <span class="content_text"><a href="UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-BHADAIHE">“Recovering and Last Write Wins.”</a></span></p><a name="//apple_ref/doc/uid/TP30001011-CH209-BHAHFAFH" title="Recovering and Refaulting"></a><h2>Recovering and Refaulting</h2><p>The following example catches an optimistic locking failure, identifies the enterprise objects involved in the failure, and refaults those objects. </p><p>To catch an optimistic locking failure, you typically add a try-catch block around an invocation of <code>EOEditingContext.saveChanges()</code>, as shown in <span class="content_text">Listing 9-1</span>.</p><a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_151" title="Listing 8-1Adding a try-catch block around saveChanges"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001011-CH209-BHADIIEA" title="Listing 8-1Adding a try-catch block around saveChanges"></a><strong>Listing 8-1&nbsp;&nbsp;</strong>Adding a try-catch block around <code>saveChanges</code></p><div class="codesample"><table><tr><td scope="row"><pre>public void save() {<span></span></pre></td></tr><tr><td scope="row"><pre>        EOEditingContext editingContext = session().defaultEditingContext();<span></span></pre></td></tr><tr><td scope="row"><pre>        try {<span></span></pre></td></tr><tr><td scope="row"><pre>            editingContext.saveChanges();<span></span></pre></td></tr><tr><td scope="row"><pre>            //Thrown for each eo that fails to save.<span></span></pre></td></tr><tr><td scope="row"><pre>        } catch (EOGeneralAdaptorException saveException) { <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>            //Determine if the exception is an optimistic locking exception.<span></span></pre></td></tr><tr><td scope="row"><pre>            if (isOptimisticLockingFailure(saveException)) {<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                //Deal with the optimistic locking exception.<span></span></pre></td></tr><tr><td scope="row"><pre>                handleOptimisticLockingFailure(saveException);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>            } else {<span></span></pre></td></tr><tr><td scope="row"><pre>                //Don't know what went wrong so revert editing context to a stable state.<span></span></pre></td></tr><tr><td scope="row"><pre>                editingContext.revert();<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div>	<p>Code line 1 catches the exception that is thrown when a save fails, which is usually an EOGeneralAdaptorException. The method invoked in code line 2 determines if the exception is an optimistic locking failure. The method invoked in code line 3 deals with the failure. If another kind of exception is thrown during the save, code line 4 simply invokes <code>revert<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_633"></a></code> on the editing context, which returns the editing context to a stable state.</p><p>The code sample in <span class="content_text">Listing 9-2</span> determines if the exception thrown is an optimistic locking failure. It is invoked from code line 2 in <span class="content_text">Listing 9-1</span>.</p><a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_152" title="Listing 8-2Determining if the exception is an optimistic locking failure"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001011-CH209-BHADECFJ" title="Listing 8-2Determining if the exception is an optimistic locking failure"></a><strong>Listing 8-2&nbsp;&nbsp;</strong>Determining if the exception is an optimistic locking failure</p><div class="codesample"><table><tr><td scope="row"><pre>//Determine if the exception thrown during a save is an optimistic locking exception.<span></span></pre></td></tr><tr><td scope="row"><pre>    public boolean isOptimisticLockingFailure(EOGeneralAdaptorException                                                            exceptionWhileSaving) {<span></span></pre></td></tr><tr><td scope="row"><pre>        //Get the info dictionary that is created when the exception is thrown.<span></span></pre></td></tr><tr><td scope="row"><pre>        NSDictionary exceptionInfo = exceptionWhileSaving.userInfo();<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>        //Determine the type of the failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        Object failureType = (exceptionInfo != null) ?              exceptionInfo.objectForKey(EOAdaptorChannel.AdaptorFailureKey) : null;<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        //Return depending on the type of failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((failureType != null) &amp;&amp;              (failureType.equals(EOAdaptorChannel.AdaptorOptimisticLockingFailure))) {<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>            return true;<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            return false;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div>	<p>Throughout Enterprise Objects, many of the possible exceptions that are thrown include an info dictionary that provides details about the causes of an exception. Code line 1 simply retrieves the info dictionary from the exception thrown during the optimistic locking failure. Code line 2 uses that dictionary to determine the type of failure. Code line 3 returns <code>true</code> if the failure type is an optimistic locking failure and <code>false</code> otherwise.</p><p>After the method in <span class="content_text">Listing 9-1</span> determines if the exception resulted from an optimistic locking failure, the code sample in <span class="content_text">Listing 9-3</span> manages the failure. The method in <span class="content_text">Listing 9-3</span>, <code>handleOptimisticLockingFailureByRefaulting</code>, is invoked in code line 3 of <span class="content_text">Listing 9-1</span>.</p><a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_153" title="Listing 8-3Managing an optimistic locking failure by refaulting"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001011-CH209-BHAGBDCF" title="Listing 8-3Managing an optimistic locking failure by refaulting"></a><strong>Listing 8-3&nbsp;&nbsp;</strong>Managing an optimistic locking failure by refaulting</p><div class="codesample"><table><tr><td scope="row"><pre>//Deal with an optimistic locking failure.<span></span></pre></td></tr><tr><td scope="row"><pre>    public void handleOptimisticLockingFailureByRefaulting(EOGeneralAdaptorException         lockingException) {<span></span></pre></td></tr><tr><td scope="row"><pre>        //Get the info dictionary that is created when the exception is thrown.<span></span></pre></td></tr><tr><td scope="row"><pre>        NSDictionary info = lockingException.userInfo();<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>        //Determine the adaptor operation that triggered the optimistic locking failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        EOAdaptorOperation adaptorOperation =     (EOAdaptorOperation)info.objectForKey(EOAdaptorChannel.FailedAdaptorOperationKey);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        int operationType = adaptorOperation.adaptorOperator();<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        //Determine the database operation that triggered the failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        EODatabaseOperation dbOperation = (EODatabaseOperation)info.objectForKey(EODatabaseContext.FailedDatabaseOperationKey);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        //Retrieve the enterprise object that triggered the failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        EOEnterpriseObject failedEO = (EOEnterpriseObject)dbOperation.object();<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>        //Retrieve the dictionary of values involved in the failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        //Take action based on the type of adaptor operation that triggered the optimistic          locking failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (operationType == EODatabaseOperation.AdaptorUpdateOperator) {<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>            //Recover by refaulting the enterprise object involved in the failure.<span></span></pre></td></tr><tr><td scope="row"><pre>            //This refreshes the eo's data and allows the user to enter changes again               and resave.<span></span></pre></td></tr><tr><td scope="row"><pre>            session().defaultEditingContext().refaultObject(failedEO);<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        } else { //The optimistic locking failure was caused by another type of adaptor             operation, not an update.<span></span></pre></td></tr><tr><td scope="row"><pre>            throw new NSForwardException(lockingException, "Unknown adaptorOperator " +               operationType + " in optimistic locking exception.");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        session().defaultEditingContext().saveChanges();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div>	<p>Code line 1 retrieves the info dictionary that contains detailed information about the optimistic locking failure. Code line 2 determines the adaptor<a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_634"></a> operation that triggered the failure. </p><p>Code line 3 determines the type of the adaptor operation that triggered the failure. There are a number of adaptor operations that include AdaptorUpdateOperator and AdaptorDeleteOperator. See the API reference for the class <code>com.webobjects.eoaccess.EOAdaptorOperation</code> for a list of all the operations. The adaptor operation type is used in code line 6. </p><p>Code line 4 retrieves the database operation in which the optimistic locking failure originated. From the database operation, code line 5 retrieves the enterprise object that was involved in the locking failure. An optimistic locking exception is thrown when an individual enterprise object instance fails to save. When even a single enterprise object fails to save, the entire <code>saveChanges</code><a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_635"></a> operation fails.</p><p>From the information retrieved by the code in code line 3, code line 6 takes action based on the type of adaptor operation. You need to determine which adaptor operation triggered the optimistic locking failure to know how to manage the failure. You’d manage a failure resulting from an AdaptorDeleteOperator differently than you’d manage a failure resulting from an AdaptorUpdateOperator.</p><p>After determining that the exception thrown during <code>saveChanges</code> resulted from an optimistic locking failure, code line 7 attempts to refault the enterprise object that was involved in the failure. Refaulting clears in-memory changes in an enterprise object and populates its data with values from the database. Users would then need to reenter their changes and attempt to save again, so you should display a message in the user interface with those instructions.</p><a name="//apple_ref/doc/uid/TP30001011-CH209-BHADAIHE" title="Recovering and Last Write Wins"></a><h2>Recovering and Last Write Wins</h2><p>The following example catches an optimistic locking failure, identifies the enterprise objects involved in the failure, identifies the values of the enterprise objects involved in the failure, and attempts to commit those values to the database.</p><a name="//apple_ref/doc/uid/TP30001011-CH209-DontLinkElementID_154" title="Listing 8-4Managing an optimistic locking failure by last write wins"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001011-CH209-BHAFDFJD" title="Listing 8-4Managing an optimistic locking failure by last write wins"></a><strong>Listing 8-4&nbsp;&nbsp;</strong>Managing an optimistic locking failure by last write wins</p><div class="codesample"><table><tr><td scope="row"><pre>//Deal with an optimistic locking failure.<span></span></pre></td></tr><tr><td scope="row"><pre>    public void handleOptimisticLockingFailureByLastWriteWins(EOGeneralAdaptorException lockingException) {<span></span></pre></td></tr><tr><td scope="row"><pre>        //Get the info dictionary that is created when the exception is thrown.<span></span></pre></td></tr><tr><td scope="row"><pre>        NSDictionary info = lockingException.userInfo();<span></span></pre></td></tr><tr><td scope="row"><pre>        //Determine the adaptor operation that triggered the optimistic locking failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        EOAdaptorOperation adaptorOperation = (EOAdaptorOperation)info.objectForKey(EOAdaptorChannel.FailedAdaptorOperationKey);<span></span></pre></td></tr><tr><td scope="row"><pre>        int operationType = adaptorOperation.adaptorOperator();<span></span></pre></td></tr><tr><td scope="row"><pre>        //Determine the database operation that triggered the failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        EODatabaseOperation dbOperation = (EODatabaseOperation)info.objectForKey(EODatabaseContext.FailedDatabaseOperationKey);<span></span></pre></td></tr><tr><td scope="row"><pre>        //Retrieve the enterprise object that triggered the failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        EOEnterpriseObject failedEO = (EOEnterpriseObject)dbOperation.object();<span></span></pre></td></tr><tr><td scope="row"><pre>        //Retrieve the dictionary of values involved in the failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        NSDictionary valuesInFailedSave = adaptorOperation.changedValues();<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>        NSLog.out.appendln("valuesInFailedSave: " + valuesInFailedSave);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Take action based on the type of adaptor operation that triggered the optimistic locking failure.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (operationType == EODatabaseOperation.AdaptorUpdateOperator) {<span></span></pre></td></tr><tr><td scope="row"><pre>            //Recover by essentially ignoring the optimistic locking failure and committing the<span></span></pre></td></tr><tr><td scope="row"><pre>            //changes that originally failed. This is a last write wins policy.<span></span></pre></td></tr><tr><td scope="row"><pre>            //Overwrite any changes in the database with the eo's values.<span></span></pre></td></tr><tr><td scope="row"><pre>            failedEO.reapplyChangesFromDictionary(valuesInFailedSave); <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        } else { //The optimistic locking failure was causes by another type of adaptor operation, not an update.<span></span></pre></td></tr><tr><td scope="row"><pre>            throw new NSForwardException(lockingException, "Unknown adaptorOperator " + operationType + " in optimistic locking exception.");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        session().defaultEditingContext().saveChanges();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div>	<p><span class="content_text">Listing 9-4</span> differs from <span class="content_text">Listing 9-3</span> only in code line 1 and code line 2. Code line 1 of <span class="content_text">Listing 9-4</span> retrieves the values of the enterprise object that were involved in the optimistic locking failure. For example, if the enterprise object represents the Listing entity in the Real Estate model and the <code>bedrooms</code> attribute of that enterprise object had changes, the dictionary of changes retrieved in code line 1 contains a key called <code>bedrooms</code> and its changed in-memory value (not the attribute’s value in the database).</p><p>This dictionary is used in code line 2, which attempts to reapply the changes that failed to be committed. This approach is referred to as a “last write wins” approach because code line 2 commits the changes regardless of the values in the database. So if the optimistic locking failure was caused because another user or process changed the data in the database that corresponds to the edited enterprise object, code line 2 disregards those changes and writes the changes that failed in their place. This may or may not be a reasonable approach for your application.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Saving/Saving.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Connecting/Connecting.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/WebObjects/Enterprise_Objects/UpdateStrategies/UpdateStrategies.html%3Fid%3DTP30001011-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/WebObjects/Enterprise_Objects/UpdateStrategies/UpdateStrategies.html%3Fid%3DTP30001011-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/WebObjects/Enterprise_Objects/UpdateStrategies/UpdateStrategies.html%3Fid%3DTP30001011-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>