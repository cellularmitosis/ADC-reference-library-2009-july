<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PT31: Pascal to C:  PROCEDURE Parameters</title>                                      <meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="Jan 29, 1990 - Feb 2, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002685" title="Pascal to C:  PROCEDURE Parameters"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxPorting-date.html">Porting</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxPorting-date.html" target="_blank">Carbon > Porting</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PT31</div>
<div id="pageheadsub">Pascal to C:  PROCEDURE Parameters</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">How Pascal Implements Nested Procedures</A><BR><BR><A HREF="#Section3">How Pascal Implements PROCEDURE Parameters</A><BR><BR><A HREF="#Section4">Pascal to C++ to Pascal</A><BR><BR><A HREF="#Section5">C++ to Pascal to C++</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note talks about nested procedures and <code>PROCEDURE</code>parameters in Pascal and what to do when converting them into C or C++.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Feb 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A> <h2>Introduction</h2><p>Pascal and C offer many of the same features, but there are some differences.These differences make converting between languages or calling librarieswritten in one language from the other difficult sometimes.  Two closelyassociated features of Pascal that C does not offer are nested procedures and<code>PROCEDURE</code> parameters.  Since these two features are commonly used whenprogramming with MacApp, the problem of implementing them in C++ is a commonone.</p><a name="Section2"></a><P><A HREF="#top">Back to top</A></p><h2>How Pascal Implements Nested Procedures</h2><p>Pascal lets programmers nest procedures within each other.  Doing so allows oneto limit the scope of local variables, as well as allow multiple proceduresaccess to the same set of dynamically created variables.</p><p>Let's take a look at the following bit o' code:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  PROCEDURE CallBack;    { Outer level procedure }    BEGIN    END;  PROCEDURE CallingProcedure;    { Outer level procedure }    VAR      aVar: integer;    PROCEDURE NestedCallBack;        { Nested procedure - can access &quot;aVar&quot; }      VAR        anotherVar: integer;      BEGIN {NestedCallBack }        aVar := 1;        anotherVar := 2;      END; {NestedCallBack }    BEGIN {CallingProcedure }      CallBack;      NestedCallBack;</pre>	</TD></TR></TABLE></CENTER><p>This code shows three Pascal procedures:  <code>CallingProcedure</code>,<code>CallBack</code>, and <code>NestedCallBack</code>.  <code>NestedCallBack</code> is thenested procedure, which means that it can access the local variables of theprocedure it is nested within, namely, <code>CallingProcedure</code>.</p><p>The method used to allow <code>NestedCallBack</code> to access its host procedure'slocal variables is not so obvious and involves a little hack.  As you may know,local variables are created on the stack when a procedure is entered, and the680x0 register <code>A6</code> is initialized to point to them.  Fine, but thisleads to a little conflict within <code>NestedCallBack</code>.  It needs to use<code>A6</code> to point to its own local variables (e.g., <code>anotherVar</code>), sohow does it access its host procedure's local variables?</p><p>The answer, logically enough, is that it uses another register for thispurpose.  When <code>NestedCallBack</code> is called from its host procedure, thehost's <code>A6</code> is pushed onto the stack after any and all formal parametershave been pushed on, but before the <code>JSR</code> is performed (this extraparameter is often referred to as the "static link").  As<code>NestedCallBack</code> is being entered, you have a stack similar to that inFigure 1.  By comparison, Figure 2 shows what the stack would look like if youmade a normal call to a procedure on the outer level, such as the procedureshown above named <code>CallBack</code>.</p><P align=center><img src="images/pt_31_001.gif" alt="Figure 1. Call to NestedCallBack &amp; Figure 2-Call to CallBack." width=384 height=138></P><P align=center><b>Figure 1</b>.  Call to NestedCallBack</p><P align=center><b>Figure 2</b>.Call to CallBack</p><p>Each procedure knows at compile time whether it is nested or not and adjustsitself accordingly.  If it turns out that a procedure is nested, then it iscompiled as if you had declared an extra parameter at the end of the formalparameter list, one that held the value of the host's <code>A6</code>.  Pascal thenuses this parameter for fetching the local variables of the nested procedure'shost.  It pulls this parameter off of the stack just like any other parameter,sticks it into a handy register, and uses it as a base address to the host'slocal variables, just as it uses <code>A6</code> as the base address to its ownlocals.</p><a name="Section3"></a> <P><A HREF="#top">Back to top</A></p><h2>How Pascal Implements PROCEDURE Parameters</h2><p>As seen in the previous section, nested procedures require a little help to getthemselves up and running.  Specifically, they need an extra parameter called astatic link.  You've seen one way in which Pascal provides support for thisparameter.  In this section, you see another important case.</p><p>There are many Toolbox routines that require a pointer to a procedure beingpassed to them as a parameter.  These procedures are called "callback"procedures, because the Toolbox makes a call back to those procedures toperform some application-specific function.  An example of this type of routinewould be the Control Manager routine <code>_TrackControl</code>, which requires acallback procedure called <code>actionProc</code>.</p><p>By now, you should see why you cannot pass the address of a nested procedure tosuch a Toolbox routine.  Nested procedures require that they be passed thestatic link parameter so that they can access their host variables.  TheToolbox doesn't support this convention, so it cannot pass the required staticlink to the nested routine.</p><p>While the Toolbox doesn't support the nested procedure convention, Pascalitself does support a method whereby you can pass around all the informationnecessary to implement a callback procedure as a nested procedure.Syntactically, this is done by including a full procedure heading in the listof formal parameters a procedure takes.  An example of such could look like thefollowing:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  PROCEDURE SomeProcedure(        PROCEDURE CallBackProc(i:integer);        iterForward: BOOLEAN);    BEGIN      ...      CallBackProc(5);      ...</pre>	</TD></TR></TABLE></CENTER><p><code>SomeProcedure</code> takes two parameters.  The first is a <code>PROCEDURE</code>parameter that refers to a routine that takes a parameter itself, namely, asingle integer.  In addition, <code>SomeProcedure</code> takes a <code>BOOLEAN</code>called <code>iterForward</code> as a second parameter.  You would call<code>SomeProcedure</code> with something like the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  PROCEDURE MyCallingProcedure;    PROCEDURE MyCallBackProcedure(i: integer);      BEGIN { of MyCallBackProcedure }        &lt; mumble &gt;;      END;    BEGIN { of MyCallingProcedure }      SomeProcedure(MyCallBackProcedure, TRUE);</pre>	</TD></TR></TABLE></CENTER><p>Through the use of the <code>PROCEDURE</code> parameter, you can invoke thecallback procedure using a natural Pascal syntax.  In the<code>SomeProcedure</code> example, the statement <code>CallBackProc(5)</code> causes<code>MyCallBackProcedure</code> to be called with a value of five.  Not only canyou just invoke the procedure by entering the name of the <code>PROCEDURE</code>variable, but you can pass parameters to it with full Pascal typecheckinginvoked.  In this case, Pascal ensures that when you call<code>CallBackProc</code>, you also pass a single integer to it.</p><p><code>PROCEDURE</code> parameters also give the support for nested procedures for whichyou are looking.  When a <code>PROCEDURE</code> parameter is passed on the stack,two components are used to represent it.  The first is a pointer to the actualprocedure.  The second is the static link.  Therefore, you can think of a<code>PROCEDURE</code> parameter as being represented by the following record:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  TYPE    ProcedureParameter = RECORD      procPtr: Ptr;      staticLink: Ptr;</pre>	</TD></TR></TABLE></CENTER><p>When you pass a <code>PROCEDURE</code> parameter to a destination procedure, bothof these components are pushed onto the stack as <code>LONG</code> values (fourbytes each).  When it comes time for the destination procedure to invoke thecallback, any necessary parameters for the callback are placed onto the stack,followed by the <code>staticLink</code> value.  Then the routine specified by<code>procPtr</code> is called.</p><p>The step where the destination procedure pushes the static link onto the stackis important and should be examined more closely.  Specifically, how do youknow that a static link parameter is necessary at this point?  After all,<code>SomeProcedure</code> simply declares that it takes a <code>PROCEDURE</code> as aparameter; it doesn't differentiate between nested and non-nested procedures.But, as you saw in the first section, these two kinds of procedures are calleddifferently.  How do you know if the the static link passed to you needs to bepushed onto the stack for the callback procedure?</p><p>The answer is that <code>SomeProcedure</code> receives a special value for thestatic link parameter for non-nested procedures.  If the callback procedure isat the outer level, <code>SomeProcedure</code> receives <code>NIL</code> for the valueof the static link.  When Pascal compiles the commands that invoke<code>PROCEDURE</code> parameters, it generates code that checks the static link.If it is <code>NIL</code>, it doesn't push it onto the stack.  If it is not<code>NIL</code>, then you are calling a nested procedure, and must push the staticlink onto the stack.</p><p>So, how do you utilize nested procedures and <code>PROCEDURE</code> parameters in Cor C++?  Obviously, you cannot--at least not directly.  C and C++ don't supportthem.  At this point, you might as well just give up and use Pascal; you alwayssaid C++ was highly overrated anyway.</p><p>There are two scenarios to examine:</p><ul type="disc">	<li>A Pascal routine calls your C++ routine, passing a <code>PROCEDURE</code> parameter to another Pascal routine you have to call.</li>	<li>Your C++ routine calls a Pascal routine expecting a <code>PROCEDURE</code> parameter, which you have implemented in C++.</li></ul><p>The rest of the Note looks at both of these cases.</p> <P><A HREF="#top">Back to top</A></p> <a name="Section4"></a><h2>Pascal to C++ to Pascal</h2><p>MacApp supports an object inspector, which it implements by calling a<code>Fields</code> method common to all descendants of <code>TObject</code>.  Eachclass you define should override this method so that MacApp can find out aboutyour class's fields.  Such a method definition would look like the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  PROCEDURE TJustCommand.Fields(        PROCEDURE DoToField(fieldName: Str255;                            fieldAddr: Ptr;                            fieldType: INTEGER)); OVERRIDE;  BEGIN    DoToField('TJustCommand', NIL, bClass);    DoToField('fTEView', @fTEView, bObject);    DoToField('fOldJust', @fOldJust, bInteger);    DoToField('fNewJust', @fNewJust, bInteger);    INHERITED Fields(DoToField);</pre>	</TD></TR></TABLE></CENTER><p>You tell it the name of your class so that whatever routine is calling you(usually MacApp's inspector or debugger) can identify the class it isinspecting.  Then, for each field in your class, you call the procedure passedto you, giving it the three parameters it needs.  Finally, you call yoursuperclass' <code>Fields</code> method so that it can identify its name andfields.</p><p>When your <code>Fields</code> method is called, the <code>DoToField</code> parameterappears on the stack as a pointer to the procedure you are supposed to call, aswell as the static link value it needs.  When you actually call<code>DoToField</code>, the necessary parameters are first pushed onto the stack(i.e., <code>fieldName</code>, <code>fieldAddr</code>, and <code>fieldType</code>).  Pascalthen adds some code that makes a determination based on the value of the staticlink parameter.  If it is non-zero, then you are calling a nested procedure andneed to pass back the static link back on the stack.  If static link is zero,then you are not calling a nested procedure and don't need to pass that staticlink back.</p><p>Pascal handles all of this for you transparently.  This ease in Pascal makesthe process of writing a similar routine in C or C++ that much more difficult,as that process has been hidden from us.</p><p>There is no way in C or C++ to pass a variable number of parameters in onestatement.  In other words, you <b>cannot</b> do something like thefollowing:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>DoToField(&quot;\pTJustCommand&quot;, nil, bClass,        StaticLink ? StaticLink : void); /* No Workie */</pre>	</TD></TR></TABLE></CENTER><p>That would be too easy.  Instead, you must use some inline glue that preparesthe stack for you.  This inline procedure accepts the three parameters you seein the Pascal version, as well as both components of the <code>PROCEDURE</code>parameter (i.e., the procedure pointer and static link).  The glue looks at thestatic link value and removes it from the stack if it is zero and, thus, notneeded.</p><p>One solution is as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef pascal void (*FieldProcPtr) (        StringPtr fieldName, Ptr fieldAddr,        short fieldType, void *DoToField_StaticLink);pascal void CallDoToField(StringPtr, Ptr, short, void *, FieldProcPtr)  = {    0x205F,    // MOVEA.L    (A7)+,A0    ; get the DoToField pointer    0x4A97,    // TST.L      (A7)        ; check the StaticLink    0x6602,    // BNE.S      *+$0004     ; if non-zero, keep it in    0x588F,    // ADDQ.L     #$4,A7      ; if zero, pull it off    0x4E90     // JSR        (A0)        ; Call DoToField    };pascal void TJustCommand::Fields(        FieldProcPtr DoToField,        void *DoToField_StaticLink) {  CallDoToField(&quot;\pTJustCommand&quot;, NULL, bClass,                DoToField_StaticLink, DoToField);  CallDoToField(&quot;\pfTEView&quot;, (Ptr) &amp;fTEView, bObject,                DoToField_StaticLink, DoToField);  CallDoToField(&quot;\pfOldJust&quot;, (Ptr) &amp;fOldJust, bInteger,                DoToField_StaticLink, DoToField);  CallDoToField(&quot;\pfNewJust&quot;, (Ptr) &amp;fNewJust, bInteger,                DoToField_StaticLink, DoToField);</pre>	</TD></TR></TABLE></CENTER> <P><A HREF="#top">Back to top</A></p> <a name="Section5"></a><h2>C++ to Pascal to C++</h2><p>Now look at another case that occurs often in MacApp.  This is where your C++routine calls a MacApp procedure that needs a <code>PROCEDURE</code> reference backto one of your own routines.  For instance, MacApp has a class called<code>TList</code> that allows you to maintain a list of objects.  This class has amethod called <code>Each</code> that allows you to perform some operation on eachobject in the list.  MacApp takes care of iterating over all of the objects andcalls a routine you pass to it for each one.</p><p>For this example, you have a list of objects stored in a <code>TList</code> and youwant to pass the <code>Graze</code> message to all of them.  At the same time, youwant to keep track of how many grazed so much that they fell off a cliff duringthe process.  If the number of objects grazing off a cliff is greater than somethreshold, then you call <code>_SysBeep</code>.  You could use the followingprocedures to accomplish this in Object Pascal:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  VAR    myList: TList;  PROCEDURE TMyApplication.GrazeAll;    VAR      offTheCliff: integer;    PROCEDURE DoGraze(theObject: TObject);      BEGIN        TGrazer(theObject).Graze;        IF TGrazer(theObject).GrazedOffTheCliff THEN          offTheCliff := offThecliff + 1;        IF offTheCliff &gt; SELF.fCliffThreshhold THEN          ApplicationBeep;      END;    BEGIN      offTheCliff := 0;      myGrazerList.Each(DoGraze);</pre>	</TD></TR></TABLE></CENTER><p>You use a nested procedure so that <code>DoGraze</code> can access the localvariable <code>offTheCliff</code>.  This allows you to use a variable that haslimited scope and that is created dynamically so that you don't have toallocate a global variable.  Also, since <code>DoGraze</code> is embedded within a<code>TMyApplication</code> method, you have access to the <code>this</code> symbol(<code>this</code> is the equivalent to <code>SELF</code> in Object Pascal).</p><p>Therefore, the problem for C++ programmers here is that there is no implicitsupport for getting access to local variables, such as <code>offTheCliff</code>, aswell as the reference to the correct object through <code>this</code>.  So what'sthe alternative for C++ programmers in a case like this?</p><p>First, let's take a quick look at how the <code>Each</code> method is declared:</p><h3>Object Pascal</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>TList = OBJECT (TDynamicArray)  ...  PROCEDURE TList.Each(PROCEDURE DoToItem(item: TObject));  ...</pre>	</TD></TR></TABLE></CENTER><h3>C++</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TList : public TDynamicArray {  public:  ...  virtual pascal void Each(pascal void (*DoToItem)(                TObject *item,                void *DoToItem_StaticLink),                void *DoToItem_StaticLink);  ...</pre>	</TD></TR></TABLE></CENTER><p>As you can see, the two components of the <code>PROCEDURE</code> parameter have tobe declared explicitly in C++.  Because of this, you can come up with fourdifferent solutions to the problem, and all of them hinge on being creativewith what you pass for the static link parameter.</p><ol type="1" start="1">	<li>Case:  You need access to <code>this</code>, but don't need to access any local variables.  Pass <code>this</code> in <code>DoToItem_StaticLink</code> directly.</li>	<li>Case:  You need access to a single local variable, but not <code>SELF</code>. Pass the reference to that local variable in <code>DoToItem_StaticLink</code>.</li>	<li>Case:  You need access to multiple amounts of information, including more than one local variable and <code>this</code>.  Pass a pointer to a <code>struct</code> that contains this information.</li>	<li>Case:  You don't need access to anything from the host procedure (including local variables and <code>this</code>).  Pass a <code>NIL</code> for the static link.</li></ol><p>Now to look at each of these in more depth.</p><h3>Pass <code>this</code> in DoToItem_StaticLink Directly</h3><p>This is the approach where you would pass <code>this</code> as the<code>DoToItem_StaticLink</code> value.  You would want to do this if you needed toaccess your object, but didn't need to access any local variables.  Here's whatsome C++ code would look like using this method.  You pass <code>this</code> as thestatic link parameter and convert it back into an object reference in yourcallback procedure.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal void DoGraze(TObject* item, void* staticLink) {    TMyApplication *self;    self = (TMyApplication *) staticLink;    self-&gt;DoSomethingElse();    ((TGrazer *)item)-&gt;Graze();}pascal void TMyApplication::GrazeAll() {    myGrazerList-&gt;Each(DoGraze, this);</pre>	</TD></TR></TABLE></CENTER><h3>Pass the Reference to a Single Local Variable in DoToItem_StaticLink</h3><p>You would use this method if all you had to do was access a local variable ofyour host procedure.  Getting to your local variable is now just a matter ofdereferencing the <code>staticLink</code> parameter.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal void CountGrazers(TObject* item, void* staticLink) {    int *grazerCountPtr = (int *) staticLink;    ++(*grazerCountPtr);}pascal void TMyApplication::GrazeAll() {    int grazerCount = 0;    myGrazerList-&gt;Each(CountGrazers, &amp;grazerCount);</pre>	</TD></TR></TABLE></CENTER><h3>Pass a Pointer to a struct in DoToItem_StaticLink</h3><p>If you need to pass multiple amounts of information, such as more than onelocal variable, possibly including a reference to <code>this</code>, you can do sowith a <code>struct</code>.  This <code>struct</code> would hold all the localvariables you need to pass to the callback routine.  You would declare aninstance of this <code>struct</code> in your local parameter list and pass apointer to it as the static link.  In your callback procedure, you would coercethe <code>staticLink</code> variable back into a <code>Pointer</code> to this<code>struct</code>, and then get all the information you need.</p><p>An example of this could look as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct {    int offTheCliff;    TMyApplication *self;} localVars;pascal void DoGraze(TObject* item, void* staticLink) {    localVars *hostLocals = (localVars *) staticLink;    ((TGrazer *)item)-&gt;Graze();    if ((TGrazer *)item-&gt;GrazedOffTheCliff()) {        ++(hostLocals-&gt;offTheCliff);    }    if (hostLocals-&gt;offTheCliff &gt;            hostLocals-&gt;self-&gt;fCliffThreshhold) {        ApplicationBeep();    }}pascal void TMyApplication::GrazeAll() {    localVars myLocals;    myLocals.self = this;    myLocals.offTheCliff = 0;    myGrazerList-&gt;Each(DoGraze, &amp;myLocals);</pre>	</TD></TR></TABLE></CENTER><h3>Pass a Zero for the Static Link</h3><p>You would do this in situations where you can get by with the formal parametersthat are given to you and don't need to access any of your host's localvariables or the object reference.  Since passing a zero means "don't push astatic link onto the stack" in this convention, you have to adjust theparameter list of your callback <code>DoGraze</code> accordingly.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef pascal void (* EachProcType)(TObject *, void *);pascal void DoGraze(TObject* item) {    ((TGrazer *)item)-&gt;Graze();}pascal void TMyApplication::GrazeAll() {    myGrazerList-&gt;Each((EachProcType)DoGraze, nil);</pre>	</TD></TR></TABLE></CENTER><p>Which of these methods you use is up to you.</p><a name="References"></a> <P><A HREF="#top">Back to top</A></p><h2>References</h2><P>   <i>MPW 3.0 Pascal Reference</i>, Chapter 8, pp. 145-147</p><P>   Your dentist, twice a year</p>         <a name=Downloads></A>                  <P><A HREF="#top">Back to top</A></p> <h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pt_31.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pt/pt_31.html%3Fid%3DDTS10002685-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pt/pt_31.html%3Fid%3DDTS10002685-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pt/pt_31.html%3Fid%3DDTS10002685-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>