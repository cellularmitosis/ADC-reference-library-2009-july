// ===========================================================================//	CAttachment.cp				©1995 Apple Computer, Inc. All rights reserved.// ===========================================================================////	Misc attachments//#include "CAttachment.h"// ===========================================================================// ¥ C3DBorderAttachment								 C3DBorderAttachment ¥// ===========================================================================//	Draws a 3D chisseled border within the Frame of a Pane//		For use only with msg_DrawOrPrintC3DBorderAttachment::C3DBorderAttachment(void)		: LAttachment(msg_DrawOrPrint, true){}voidC3DBorderAttachment::ExecuteSelf(	MessageT	/* inMessage */,	void		*ioParam){	StColorPenState	savePenState;		// Will save and restore pen state	Rect			*frame = (Rect *)ioParam, erase = *frame;		::PenNormal();		::InsetRect (frame, 1, 1 );	::FrameRect (frame);	::InsetRect (frame, -1, -1);	::InsetRect (&erase, 2, 2);			StDeviceLoop	theLoop(*frame);	// Set up for looping thru each device	Int16	depth;		while (theLoop.NextDepth(depth)) {				// At this point, the clipping region is set to the portion			// of the Pane that is on the screen with the current			// bit depth. Therefore, we can just draw everything, and			// let the clipping region restrict the drawing.			//			// If you are interested in other characteristics of the			// current screen device, you can call theLoop.GetCurrentDevice			// which will return a GDHandle.		if (depth >= 4) {				// When there are at least 16 colors, draw the 3D chissel effect							StColorState	colorSaver;	// Constructor saves fore and back										// colors; Destructor restores them			RGBColor		white = {0xffff, 0xffff, 0xffff}, dkGrey = {0x5555, 0x5555, 0x5555},							ltGrey = {0xCCCC, 0xCCCC, 0xCCCC};						::RGBBackColor(&white);			::EraseRect (&erase);			::RGBForeColor(&dkGrey);			::MoveTo(frame->left, frame->bottom-1);			::LineTo(frame->left, frame->top);			::LineTo(frame->right-1, frame->top);						::RGBForeColor(&ltGrey);			::MoveTo(frame->left+1, frame->bottom-1);			::LineTo(frame->right-1, frame->bottom-1);			::RGBForeColor(&white);			::LineTo(frame->right-1, frame->top+1);		}		else ::EraseRect (&erase);	}}