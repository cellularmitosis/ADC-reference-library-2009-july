<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>LW8_Hosesample - /HoseIrda.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">LW8_Hosesample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">LW8_Hosesample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/HoseIrda.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Hose.h</option>
<option value="listing2.html">/HoseFile.r</option>
<option value="listing3.html">/HoseIrda.c</option>
<option value="listing4.html">/HoseIrda.h</option>
<option value="listing5.html">/PSWriterErr.h</option></select>
				</p>
				</form>
				<p><strong><a href="LW8_Hosesample.zip">Download Sample</a></strong> (&#147;LW8_Hosesample.zip&#148;, 26.1K)<BR>
<strong><a href="LW8_Hosesample.dmg">Download Sample</a></strong> (&#147;LW8_Hosesample.dmg&#148;, 86.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    HoseIrda.c  Contains:  Sample code to demonstrate how a LaserWriter communication hose         plugin can be written. An Irda (Infrared) hose is used here.  Written by: Chorng-Shyan Lin and Ingrid Kelly    Copyright:  Copyright &copy; 1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/26/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        5/5/99    lin        changed the way cntl-D is sent at close time,                      longer time-out        */#include &lt;CommResources.h&gt;#include &lt;CTBUtilities.h&gt;#include &lt;Connections.h&gt;#include &quot;Hose.h&quot;#include &quot;HoseIrda.h&quot;#include &quot;PSWriterErr.h&quot;          #define LockHint(collection, tag, id)  SetCollectionItemInfo((collection), (tag), (id), kCollectionLockMask, kCollectionLockMask)    /*  The following two macros are intended to make it easier to  declare routines that will be invoked by the MixedMode Mgr.  DeclareProcPtr() will create a routine descriptor with the  name g_'proc' if we are compiling in an environment that  needs routine descriptors. If we are in the old 68K environment  then this macro does nothing. MakeProcPtr creates a reference to  the function pointer 'proc'. If we are using routine descriptors  then the reference is the address of the descriptor created by  DeclareProcPtr(). If we are in a 68K world then the reference  is just the proc pointer itself.*/#if TARGET_RT_MAC_CFM#define DeclareProcPtr(proc, upp)  \    RoutineDescriptor g_##proc = BUILD_ROUTINE_DESCRIPTOR(upp, proc);#define ExternalProcPtr(proc)  \    extern RoutineDescriptor g_##proc;#define MakeProcPtr(proc, procType)  \    ((procType)&amp;g_##proc)    #else#define DeclareProcPtr(proc, upp)#define ExternalProcPtr(proc)#define MakeProcPtr(proc, procType)  \    ((procType)proc)    #endif/*** Constants ***/#define kClosingTimeOut 3600/*** Variable Types ***/struct IrdaHoseRec {  ConnHandle               connectionH;  ConnState              connectionState;  MemQElemPtr              writeMemQElemPtr;  MemQElemPtr              readMemQElemPtr;  BufCallbacks            callbacks;  Boolean                eojFired;  Boolean                needToDumpDataOut;  Boolean                needToRequestStatus;  OSErr                openResult;  Boolean                needCloseEoj;    long                startCloseTime;  };typedef struct IrdaHoseRec      IrdaHoseRec;typedef IrdaHoseRec*        IrdaHoseRecPtr;/*** Prototypes ***/OSErr InitLib(CFragInitBlockPtr initBlkPtr);                            void TerminateLib(void);// hose APIstatic OSStatus closeIrdaHose(void *refcon);static OSStatus outIrdaHose(void *refcon, MemQElemPtr memElem);static OSStatus inIrdaHose(void *refcon, MemQElemPtr memElem);static OSStatus idleIrdaHose(void *refcon);static OSStatus statusIrdaHose(void *refcon, StringPtr statusStr);        static OSStatus disposeIrdaHose(void *refcon);                static ConnState connStateIrdaHose(void *refcon);// callback from CTBstatic  void commOpenCompletion(ConnHandle connectionH);static  void commWriteCompletion(ConnHandle connectionH);static  void commReadCompletion(ConnHandle connectionH);static  void commStatusCompletion(ConnHandle connectionH);static  void closingEojSentCompletion(ConnHandle connectionH);static  void closingEojReceivedCompletion(ConnHandle connectionH);// utilitiesstatic OSStatus requestStatus(IrdaHoseRecPtr irdaHoseP);static OSStatus cmWritePending(ConnHandle connectionH, Boolean* writePendingP);static OSErr translateErr(OSErr err);static void StripEOJs(unsigned char* buffer, SInt32* nBytesP);  // lin016static OSErr UnLockHint(Collection collection, CollectionTag tag, long id);/***Globals**/unsigned char  gInCntlD = 0x04;unsigned char  gOutCntlD = 0x04;unsigned char  gCntlT = 0x14;long  gInOne = 1;long  gOutOne = 1;char *gIrDALaserconfigStr = &quot;myClass: LaserPrinter myAttr: IrDA:IrLMP:LsapSel peerClass: IrLPT peerAttr: IrDA:IrLMP:LsapSel\0&quot;;DeclareProcPtr(commOpenCompletion, uppConnectionCompletionProcInfo)DeclareProcPtr(commWriteCompletion, uppConnectionCompletionProcInfo)DeclareProcPtr(commReadCompletion, uppConnectionCompletionProcInfo)DeclareProcPtr(commStatusCompletion, uppConnectionCompletionProcInfo)DeclareProcPtr(closingEojSentCompletion, uppConnectionCompletionProcInfo)DeclareProcPtr(closingEojReceivedCompletion, uppConnectionCompletionProcInfo)/*** Code ***/OSErr InitLib(CFragInitBlockPtr /* initBlkPtr */){  return noErr;}void TerminateLib(void){  // any clean up if needed  // do nothing in this case}                            #pragma mark -#pragma export onOSStatus hoseOpen(HoseInfo *hoseInfo, BufCallbacks *callbacks, Collection hints, Handle /* papaH */)    /*  Fill out 'hose' with information that describes the IrDA hoseand Open connection to IrDA printer.*/{OSStatus err = noErr;short irdaProcID = -1;  // -1 is invalid ProcIDConnHandle connectionH = 0;CMBufferSizes irDaBufSizes;IrdaHoseRecPtr irdaHoseP = 0;Boolean eighthBit = false;          Boolean transparentBit = false;          short i;  // fill out the proc pointers to our hose  hoseInfo-&gt;out = outIrdaHose;      hoseInfo-&gt;in = inIrdaHose;          hoseInfo-&gt;idle = idleIrdaHose;        hoseInfo-&gt;close = closeIrdaHose;      hoseInfo-&gt;connState = connStateIrdaHose;      hoseInfo-&gt;status = statusIrdaHose;    hoseInfo-&gt;dispose = disposeIrdaHose;  // buffer info  hoseInfo-&gt;bufSize = kPrinterHoseBufSize;        hoseInfo-&gt;minBufs = 4;          hoseInfo-&gt;maxBufs = kPrinterHoseMaxBufs;          // add necessary hints  err = UnLockHint(hints, kHintEighthBitTag, kHintDataFormatId);  err = AddCollectionItem(hints, kHintEighthBitTag, kHintDataFormatId, sizeof(eighthBit), &amp;eighthBit);  if(!err) err = LockHint(hints, kHintEighthBitTag, kHintDataFormatId);          if(!err) err = UnLockHint(hints, kHintTransparentChannelTag, kHintTransparentChannelId);  if(!err) err = AddCollectionItem(hints, kHintTransparentChannelTag, kHintTransparentChannelId,                     sizeof(transparentBit), &amp;transparentBit);  if(!err) err = LockHint(hints, kHintTransparentChannelTag, kHintTransparentChannelId);      // allocate private storage for the hose  if(!err) irdaHoseP = (IrdaHoseRecPtr)NewPtrClear(sizeof(IrdaHoseRec));          if(irdaHoseP){    hoseInfo-&gt;refcon = (void *)irdaHoseP;            irdaHoseP-&gt;connectionH = 0;    irdaHoseP-&gt;callbacks = *callbacks;    if(InitCRM != 0){  // if there is Communication Toolbox, initialize it      err = InitCRM();      if(!err)        err = InitCTBUtilities();      if(!err)        err = InitCM();      if(!err){        irdaProcID = CMGetProcID(&quot;\pIrDA Tool&quot;);  // name of IrDA tool        if(irdaProcID != -1){          for(i = cmDataIn; i &lt;= cmRsrvOut ; i++)            irDaBufSizes[i] = 0;  // let IrDA tool decide buffer sizes          // make a new connection record          irdaHoseP-&gt;connectionH = connectionH = CMNew(irdaProcID, cmData | cmNoMenus | cmQuiet, irDaBufSizes, (long)irdaHoseP, 0);          if(connectionH){            // configure the connection record            err = CMSetConfig (connectionH, gIrDALaserconfigStr);            if(err == cmNoErr){              irdaHoseP-&gt;connectionState = kConnOpening;                // try to open a connection async.                          err = CMOpen(connectionH, true, MakeProcPtr(commOpenCompletion, ConnectionCompletionUPP), -1);                if(err != cmNoErr)                irdaHoseP-&gt;connectionState = kConnClosed;            }else{              err = irdaHoseP-&gt;openResult = errIrdaUnknownOpenErr;              /* CTB does not provide a good error code */                    }          }else{            err = irdaHoseP-&gt;openResult = errIrdaUnknownOpenErr;              /* CTB does not provide a good error code, possibly out of memory */                  }        }else{          err = irdaHoseP-&gt;openResult = errIrdaToolNotFoundErr;  // no comm. tool for irDA        }      }    }else{      err = irdaHoseP-&gt;openResult = errHoseCantBeUsed;  // CTB not available    }  }else{    err = irdaHoseP-&gt;openResult = memFullErr;  // out of memory  }  if(err){  // clean up    if(connectionH)      CMDispose(connectionH);    if(irdaHoseP){      DisposePtr((Ptr)irdaHoseP);      hoseInfo-&gt;refcon = 0;    }  }  return (translateErr(err));}#pragma export offstatic OSStatus statusIrdaHose(void *refcon, StringPtr /* statusStr */){IrdaHoseRecPtr irdaHoseP;OSStatus err = noErr;  if((irdaHoseP = (IrdaHoseRecPtr)refcon) != 0){    irdaHoseP-&gt;needToRequestStatus = true;    // request status from printer    err = requestStatus(irdaHoseP);  }  if(err){    err = statusErr;    if(irdaHoseP &amp;&amp; irdaHoseP-&gt;openResult)      err = irdaHoseP-&gt;openResult;  }  return (err);}static OSStatus closeIrdaHose(void *refcon){OSStatus err = noErr;IrdaHoseRecPtr irdaHoseP;ConnHandle connectionH;Boolean writePending;    if((irdaHoseP = (IrdaHoseRecPtr)refcon) != 0){    irdaHoseP-&gt;connectionState = kConnClosing;    if((connectionH = irdaHoseP-&gt;connectionH) != 0){      // depending on the type of hose and printer, we may not want to      // report &quot;closed&quot; until the printer is done and ready for the next job      // in this particular hose, we wait for the printer to respond to our extra eoj      irdaHoseP-&gt;startCloseTime = TickCount();      irdaHoseP-&gt;needCloseEoj = true;      err = cmWritePending(connectionH, &amp;writePending);      if(!err &amp;&amp; !writePending){        irdaHoseP-&gt;needCloseEoj = false;        gOutOne = 1;        err = CMWrite(connectionH,               &amp;gOutCntlD,               &amp;gOutOne,               cmData,               true,               MakeProcPtr(closingEojSentCompletion, ConnectionCompletionUPP),               -1,               0);                   }    }  }  return (noErr);}/*  routine to write data stream out, async.*/static OSStatus outIrdaHose(void *refcon, MemQElemPtr memElem){OSStatus err = paramErr;                    IrdaHoseRecPtr irdaHoseP;ConnHandle connectionH;Boolean writePending;  if((irdaHoseP = (IrdaHoseRecPtr)refcon) != 0){    if(irdaHoseP-&gt;connectionState == kConnClosing){      err = noErr;  // ignore it if we are already closing    }else{      if(irdaHoseP-&gt;connectionState == kConnOpen){  // if the hose is open        irdaHoseP-&gt;writeMemQElemPtr = memElem;        irdaHoseP-&gt;eojFired = false;        if((connectionH = irdaHoseP-&gt;connectionH) != 0){          // CTB does not allow multiple writes, may have to postpone it          err = cmWritePending(connectionH, &amp;writePending);          if(!err){            irdaHoseP-&gt;needToDumpDataOut = writePending ? true : false;            if(!writePending){              err = CMWrite(connectionH,                     memElem-&gt;buf,                     &amp;(memElem-&gt;nBytes),                     cmData,                     true,                     MakeProcPtr(commWriteCompletion, ConnectionCompletionUPP),                     -1,                     0);              if(err){                err = errIrdaDisconnectedErr;                  err = translateErr(err);                        }            }          }        }      }else{        err = PAPNoPrinter;      }    }  }  if(err){    if(irdaHoseP &amp;&amp; irdaHoseP-&gt;openResult)      err = irdaHoseP-&gt;openResult;  }  return err;                            }/*  routine to read data stream in, async.*/static OSStatus inIrdaHose(void *refcon, MemQElemPtr memElem){OSStatus err = paramErr;                    IrdaHoseRecPtr irdaHoseP;ConnHandle connectionH;long numOfBytes;CMBufferSizes cmBufSizes;CMStatFlags cmFlags;  memElem-&gt;nBytes = 0;  if((irdaHoseP = (IrdaHoseRecPtr)refcon) != 0){    if(irdaHoseP-&gt;connectionState == kConnClosing){      err = noErr;  // ignore it if we are already closing    }else{      if(irdaHoseP-&gt;connectionState == kConnOpen){  // if the hose is open        irdaHoseP-&gt;readMemQElemPtr = memElem;        if((connectionH = irdaHoseP-&gt;connectionH) != 0){          err = CMStatus(connectionH,                  cmBufSizes,                  &amp;cmFlags);          if(!err){            numOfBytes = cmBufSizes[cmDataIn];  // number of bytes available            if(numOfBytes &gt; memElem-&gt;maxBytes)              numOfBytes = memElem-&gt;maxBytes;            if(numOfBytes &lt;= 0)              numOfBytes = 1;  // try to read at least one byte            err = CMRead(connectionH,                   memElem-&gt;buf,                   &amp;numOfBytes,                   cmData,                   true,                   MakeProcPtr(commReadCompletion, ConnectionCompletionUPP),                   -1,                   0);            if(err){              err = errIrdaDisconnectedErr;                err = translateErr(err);                      }          }        }      }else{        err = PAPNoPrinter;      }    }  }  if(err){    if(irdaHoseP &amp;&amp; irdaHoseP-&gt;openResult)      err = irdaHoseP-&gt;openResult;  }  return err;                            }static OSStatus idleIrdaHose(void *refcon){IrdaHoseRecPtr irdaHoseP;ConnHandle connectionH;OSStatus err = noErr;  if((irdaHoseP = (IrdaHoseRecPtr)refcon) != 0){    if((connectionH = irdaHoseP-&gt;connectionH) != 0){      CMIdle(connectionH);      // take this chance to request status if necessary      requestStatus(irdaHoseP);    }    err = irdaHoseP-&gt;openResult ? irdaHoseP-&gt;openResult : noErr;  }  return(err);}static OSStatus disposeIrdaHose(void *refcon){OSStatus err = noErr;IrdaHoseRecPtr irdaHoseP;ConnHandle connectionH;  if((irdaHoseP = (IrdaHoseRecPtr)refcon) != 0){    if((connectionH = irdaHoseP-&gt;connectionH) != 0){        // close connection      err = CMClose(connectionH, false, 0, -1, true);      // dispose connection record      CMDispose(connectionH);    }      // dispose private storage    DisposePtr((Ptr)irdaHoseP);  }  return noErr;}/*  Return the current state of the hose*/static ConnState connStateIrdaHose(void *refcon){IrdaHoseRecPtr irdaHoseP;ConnHandle connectionH;ConnState connState = kConnClosed;OSStatus err = noErr;Boolean writePending;  if((irdaHoseP = (IrdaHoseRecPtr)refcon) != 0){    if(irdaHoseP-&gt;connectionState == kConnClosing){  // if we are closing down the hose      if((TickCount() - irdaHoseP-&gt;startCloseTime) &gt; kClosingTimeOut){  // test time-out        irdaHoseP-&gt;connectionState = kConnClosed;      }else{        // write an extra eoj to printer as part of closing process        connectionH = irdaHoseP-&gt;connectionH;        if(irdaHoseP-&gt;needCloseEoj &amp;&amp; connectionH){          err = cmWritePending(connectionH, &amp;writePending);          if(!err &amp;&amp; !writePending){            gOutOne = 1;            err = CMWrite(connectionH,                   &amp;gOutCntlD,                   &amp;gOutOne,                   cmData,                   true,                   MakeProcPtr(closingEojSentCompletion, ConnectionCompletionUPP),                   -1,                   0);            irdaHoseP-&gt;needCloseEoj = false;          }        }      }    }    connState = irdaHoseP-&gt;connectionState;  }  return connState;}/*  This call-back routine is called by CTB when our open request completes*/static void commOpenCompletion(ConnHandle connectionH){IrdaHoseRecPtr irdaHoseP;  if(connectionH){    irdaHoseP = (IrdaHoseRecPtr)(*connectionH)-&gt;refCon;    if(irdaHoseP){      irdaHoseP-&gt;connectionState = (*connectionH)-&gt;errCode ? kConnClosed : kConnOpen;      irdaHoseP-&gt;openResult = (*connectionH)-&gt;errCode ? PAPNoPrinter : noErr;    }  }}static  void closingEojSentCompletion(ConnHandle connectionH){IrdaHoseRecPtr irdaHoseP;OSStatus err;  if(connectionH){    if((irdaHoseP = (IrdaHoseRecPtr)(*connectionH)-&gt;refCon) != 0){      err = (*connectionH)-&gt;errCode;      if(err == noErr){        gInOne = 1;        err = CMRead(connectionH,               &amp;gInCntlD,               &amp;gInOne,               cmData,               true,               MakeProcPtr(closingEojReceivedCompletion, ConnectionCompletionUPP),               -1,               0);      }    }  }  }static  void closingEojReceivedCompletion(ConnHandle connectionH){IrdaHoseRecPtr irdaHoseP;  /* we can further test if the received data contain eoj from the printer.      we don't do this here b/c we seem to have posponed the closing report long enough     already and also it could be an overkill to wait for the eoj.  */  if(connectionH){    if((irdaHoseP = (IrdaHoseRecPtr)(*connectionH)-&gt;refCon) != 0){      irdaHoseP-&gt;connectionState = kConnClosed;    }  }}static void commWriteCompletion(ConnHandle connectionH){IrdaHoseRecPtr irdaHoseP;MemQElemPtr writeMemQElemPtr;OSStatus err;  if(connectionH){    irdaHoseP = (IrdaHoseRecPtr)(*connectionH)-&gt;refCon;    if(irdaHoseP){      writeMemQElemPtr = irdaHoseP-&gt;writeMemQElemPtr;      err = (*connectionH)-&gt;errCode;      if(err){        err = errIrdaDisconnectedErr;          err = translateErr(err);                }      // if we have sent an eoj as part of the previous write request      if(irdaHoseP-&gt;eojFired){          requestStatus(irdaHoseP);  // give status request a chance                irdaHoseP-&gt;eojFired = false;        // notify client of completion        if(err &amp;&amp; (irdaHoseP-&gt;connectionState == kConnClosing))          err = noErr;        if(irdaHoseP-&gt;callbacks.finishedWrite)          (irdaHoseP-&gt;callbacks.finishedWrite)(writeMemQElemPtr, err);      }else{        if(!err &amp;&amp; writeMemQElemPtr-&gt;eoj){  // need to send an eoj          irdaHoseP-&gt;eojFired = true;          gOutOne = 1;          err = CMWrite(connectionH,                 &amp;gOutCntlD,                 &amp;gOutOne,                 cmData,                 true,                 MakeProcPtr(commWriteCompletion, ConnectionCompletionUPP),                 -1,                 0);          // notify client of error          if(err){            irdaHoseP-&gt;eojFired = false;            if(err &amp;&amp; (irdaHoseP-&gt;connectionState == kConnClosing))              err = noErr;            if(irdaHoseP-&gt;callbacks.finishedWrite)              (irdaHoseP-&gt;callbacks.finishedWrite)(writeMemQElemPtr, err);          }        }else{          requestStatus(irdaHoseP);  // give status request a chance          if(err &amp;&amp; (irdaHoseP-&gt;connectionState == kConnClosing))            err = noErr;          // notify client of completion          if(irdaHoseP-&gt;callbacks.finishedWrite)            (irdaHoseP-&gt;callbacks.finishedWrite)(writeMemQElemPtr, err);        }      }    }  }}static void commReadCompletion(ConnHandle connectionH){IrdaHoseRecPtr irdaHoseP;MemQElemPtr readMemQElemPtr;OSStatus err;  if(connectionH){    err = (*connectionH)-&gt;errCode;    if(err){      err = errIrdaDisconnectedErr;              err = translateErr(err);              }    irdaHoseP = (IrdaHoseRecPtr)(*connectionH)-&gt;refCon;    if(irdaHoseP){      if(err &amp;&amp; (irdaHoseP-&gt;connectionState == kConnClosing))        err = noErr;      readMemQElemPtr = irdaHoseP-&gt;readMemQElemPtr;      if(readMemQElemPtr){        readMemQElemPtr-&gt;nBytes = *(SInt32*)(&amp;((*connectionH)-&gt;asyncCount[cmDataIn]));        StripEOJs(readMemQElemPtr-&gt;buf, &amp;readMemQElemPtr-&gt;nBytes);          if(irdaHoseP-&gt;callbacks.finishedRead)          (irdaHoseP-&gt;callbacks.finishedRead)(readMemQElemPtr, err);      }    }  }}static void commStatusCompletion(ConnHandle connectionH){IrdaHoseRecPtr irdaHoseP;OSStatus err;  if(connectionH){    irdaHoseP = (IrdaHoseRecPtr)(*connectionH)-&gt;refCon;    // if there is data waiting to be sent    if(irdaHoseP &amp;&amp; (irdaHoseP-&gt;needToDumpDataOut)){      irdaHoseP-&gt;needToDumpDataOut = false;      err = CMWrite(connectionH,             irdaHoseP-&gt;writeMemQElemPtr-&gt;buf,             &amp;(irdaHoseP-&gt;writeMemQElemPtr-&gt;nBytes),             cmData,             true,             MakeProcPtr(commWriteCompletion, ConnectionCompletionUPP),             -1,             0);    }    }}static OSStatus requestStatus(IrdaHoseRecPtr irdaHoseP){OSStatus err = noErr;ConnHandle connectionH;Boolean writePending;  if((irdaHoseP-&gt;connectionState == kConnOpen) &amp;&amp; (irdaHoseP-&gt;needToRequestStatus)){    if((connectionH = irdaHoseP-&gt;connectionH) != 0){      err = cmWritePending(connectionH, &amp;writePending);            // CTB does NOT allow multiple writes      if(!err &amp;&amp; !writePending){        irdaHoseP-&gt;needToRequestStatus = false;        gOutOne = 1;        // request status from printer        err = CMWrite(connectionH,               &amp;gCntlT,               &amp;gOutOne,               cmData,               true,               MakeProcPtr(commStatusCompletion, ConnectionCompletionUPP),               -1,               0);      }    }    }  return (err);}static OSStatus cmWritePending(ConnHandle connectionH, Boolean* writePendingP){OSStatus err;CMBufferSizes cmBufSizes;CMStatFlags cmFlags;  *writePendingP = false;  err = CMStatus(connectionH,          cmBufSizes,          &amp;cmFlags);  // CTB does NOT allow multiple writes  if(!err &amp;&amp; (cmFlags &amp; cmStatusDWPend))    *writePendingP = true;  return (err);}/* translate connection Mgr. errors to something meaningful*/static OSErr translateErr(OSErr err){OSErr newErr = err;  switch(err){    case cmNotOpen:    case readErr:          // readErr and writErr should be mapped to 'errIrdaDisconnectedErr' when    case writErr:          // we can supply better error reporting for that error.     case cmNotClosed:        // This should be 'errHoseInUse' when we can supply better error reporting.     case errIrdaDisconnectedErr:   // also make sure that this error is mapped        newErr = PAPNoPrinter;    break;        case errIrdaUnknownOpenErr:                  newErr = errUnableToDoNewIrdaConnection;    break;        case cmNoTools:      newErr = errIrdaToolNotFoundErr;    break;        case cmGenericError:    case cmRejected:    case cmFailed:    case cmTimeOut:    case cmNoRequestPending:    case cmNotSupported:    case cmUserCancel:    case cmUnknownError:      newErr = errGenericComponentErr;    break;  }  return newErr;}static void StripEOJs(unsigned char* buffer, SInt32* nBytesP)    {  unsigned char *src, *dst;  SInt32  count;  src = dst = buffer;  count = *nBytesP + 1;  // +1 for pre-decrement  while (--count)  {    if ((*dst++ = *src++) == '\x04')    {      dst--;      // Opps, we hit a control-D, backup a character &amp; decrement num bytes      (*nBytesP)--;    }  }}static OSErr UnLockHint(Collection collection, CollectionTag tag, long id)/*   If the hint is locked UnLockHint() will unlock it, if  it is unlocked UnLockHint() will do nothing.*/{  OSErr err = noErr;  long attributes;     err = GetCollectionItemInfo(collection, tag, id, kCollectionDontWantIndex, kCollectionDontWantSize, &amp;attributes);  if(!err){    attributes = attributes &amp; ~kCollectionLockMask;                      err = SetCollectionItemInfo(collection, tag, id, kCollectionLockMask, attributes);  }  if(err == collectionItemNotFoundErr) err = noErr;    //If it wasn't there that's fine.    return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/LW8_Hosesample/listing3.html%3Fid%3DDTS10000295-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/LW8_Hosesample/listing3.html%3Fid%3DDTS10000295-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/LW8_Hosesample/listing3.html%3Fid%3DDTS10000295-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>