<html><head><title>Mac OS X Developer Tools
 Manual Page For Tcl_ParseVarName(3tcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3tcl/Tcl_ParseVarName" title="Mac OS X Developer Tools
 Manual Page for Tcl_ParseVarName(3tcl)"><a name="//apple_ref/doc/man/3/Tcl_ParseVarName" title="Mac OS X Developer Tools
 Manual Page for Tcl_ParseVarName(3tcl)"><!-- headerDoc=man; indexgroup=Section 3tcl; uid="//apple_ref/doc/man/3tcl/Tcl_ParseVarName"; name=Tcl_ParseVarName(3tcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac&nbsp;OS&nbsp;X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>

<p style='text-align:justify;'>This manual page is associated with the Mac&nbsp;OS&nbsp;X
developer tools.  The software or headers described may not be present on your
Mac&nbsp;OS&nbsp;X installation until you install the developer tools
package.  This package is available on your Mac&nbsp;OS&nbsp;X installation DVD,
and the latest versions can be downloaded from
<a href="http://developer.apple.com/tools/download/">developer.apple.com</a>.</p>

<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Tcl_ParseCommand(3)                        Tcl Library Procedures                        <a href="Tcl_ParseCommand.3tcl.html#//apple_ref/doc/man/3/Tcl_ParseCommand">Tcl_ParseCommand(3)</a>



____________________________________________________________________________________________________________

<b>NAME</b>
       Tcl_ParseCommand, Tcl_ParseExpr, Tcl_ParseBraces, Tcl_ParseQuotedString, Tcl_ParseVarName, Tcl_Parse-<font color="#ffffff" class="whiteout">Var,&nbsp;Tcl_ParseVar,</font>
       Var, Tcl_FreeParse, Tcl_EvalTokens, Tcl_EvalTokensStandard - parse Tcl scripts and expressions

<b>SYNOPSIS</b>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       int
       <b>Tcl_ParseCommand</b>(<u>interp,</u> <u>string,</u> <u>numBytes,</u> <u>nested,</u> <u>parsePtr</u>)

       int
       <b>Tcl_ParseExpr</b>(<u>interp,</u> <u>string,</u> <u>numBytes,</u> <u>parsePtr</u>)

       int
       <b>Tcl_ParseBraces</b>(<u>interp,</u> <u>string,</u> <u>numBytes,</u> <u>parsePtr,</u> <u>append,</u> <u>termPtr</u>)

       int
       <b>Tcl_ParseQuotedString</b>(<u>interp,</u> <u>string,</u> <u>numBytes,</u> <u>parsePtr,</u> <u>append,</u> <u>termPtr</u>)

       int
       <b>Tcl_ParseVarName</b>(<u>interp,</u> <u>string,</u> <u>numBytes,</u> <u>parsePtr,</u> <u>append</u>)

       CONST char *
       <b>Tcl_ParseVar</b>(<u>interp,</u> <u>string,</u> <u>termPtr</u>)

       <b>Tcl_FreeParse</b>(<u>usedParsePtr</u>)

       Tcl_Obj *
       <b>Tcl_EvalTokens</b>(<u>interp,</u> <u>tokenPtr,</u> <u>numTokens</u>)

       int
       <b>Tcl_EvalTokensStandard</b>(<u>interp,</u> <u>tokenPtr,</u> <u>numTokens</u>)

<b>ARGUMENTS</b>
       Tcl_Interp   <u>*interp</u>         (out)     For procedures other than  <b>Tcl_FreeParse</b>,  <b>Tcl_EvalTokens</b>  and
                                              <b>Tcl_EvalTokensStandard</b>,  used  only  for  error  reporting; if
                                              NULL, then no error  messages  are  left  after  errors.   For
                                              <b>Tcl_EvalTokens</b> and <b>Tcl_EvalTokensStandard</b>, determines the con-<font color="#ffffff" class="whiteout">text&nbsp;context</font>
                                              text for evaluating the script and  also  is  used  for  error
                                              reporting; must not be NULL.

       CONST char   <u>*string</u>         (in)      Pointer to first character in string to parse.

       int          <u>numBytes</u>        (in)      Number  of bytes in <u>string</u>, not including any terminating null
                                              character.  If less than 0 then the  script  consists  of  all
                                              characters in <u>string</u> up to the first null character.

       int          <u>nested</u>          (in)      Non-zero  means that the script is part of a command substitu-<font color="#ffffff" class="whiteout">tion&nbsp;substitution</font>
                                              tion so an unquoted close bracket should be treated as a  com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
                                              mand  terminator.   If  zero,  close  brackets have no special
                                              meaning.

       int          <u>append</u>          (in)      Non-zero means that <u>*parsePtr</u> already contains  valid  tokens;
                                              the  new  tokens  should be appended to those already present.
                                              Zero means that <u>*parsePtr</u> is uninitialized; any information in
                                              it is ignored.  This argument is normally 0.

       Tcl_Parse    <u>*parsePtr</u>       (out)     Points  to  structure  to  fill  in with information about the
                                              parsed command, expression, variable name, etc.  Any  previous
                                              information  in  this  structure  is ignored, unless <u>append</u> is
                                              non-zero in a call to <b>Tcl_ParseBraces</b>,  <b>Tcl_ParseQuotedString</b>,
                                              or <b>Tcl_ParseVarName</b>.

       CONST char   <u>**termPtr</u>       (out)     If  not  NULL,  points  to  a  location where <b>Tcl_ParseBraces</b>,
                                              <b>Tcl_ParseQuotedString</b>, and <b>Tcl_ParseVar</b> will store  a  pointer
                                              to  the  character  just  after the terminating character (the
                                              close-brace, the last character of the variable name,  or  the
                                              close-quote (respectively)) if the parse was successful.

       Tcl_Parse    <u>*usedParsePtr</u>   (in)      Points  to  structure that was filled in by a previous call to
                                              <b>Tcl_ParseCommand</b>, <b>Tcl_ParseExpr</b>, <b>Tcl_ParseVarName</b>, etc.
____________________________________________________________________________________________________________


<b>DESCRIPTION</b>
       These procedures parse Tcl commands or portions of Tcl commands such as expressions or references  to
       variables.   Each  procedure takes a pointer to a script (or portion thereof) and fills in the struc-<font color="#ffffff" class="whiteout">ture&nbsp;structure</font>
       ture pointed to by <u>parsePtr</u> with a collection of tokens describing the information that  was  parsed.
       The procedures normally return <b>TCL_OK</b>.  However, if an error occurs then they return <b>TCL_ERROR</b>, leave
       an error message in <u>interp's</u> result (if <u>interp</u> is not NULL), and leave nothing in <u>parsePtr</u>.

       <b>Tcl_ParseCommand</b> is a procedure that parses Tcl scripts.  Given a pointer to a script, it parses  the
       first  command  from  the  script.   If the command was parsed successfully, <b>Tcl_ParseCommand</b> returns
       <b>TCL_OK</b> and fills in the structure pointed to by <u>parsePtr</u> with information about the structure of  the
       command  (see  below  for  details).   If  an error occurred in parsing the command then <b>TCL_ERROR</b> is
       returned, an error message is left in <u>interp</u>'s result, and no information is left at <u>*parsePtr</u>.

       <b>Tcl_ParseExpr</b> parses Tcl expressions.  Given a pointer to a script containing an expression, <b>Tcl_Par</b>-<font color="#ffffff" class="whiteout">seCommand&nbsp;Tcl_ParseCommand</font>
       <b>seCommand</b>  parses  the  expression.  If the expression was parsed successfully, <b>Tcl_ParseExpr</b> returns
       <b>TCL_OK</b> and fills in the structure pointed to by <u>parsePtr</u> with information about the structure of  the
       expression  (see  below  for details).  If an error occurred in parsing the command then <b>TCL_ERROR</b> is
       returned, an error message is left in <u>interp</u>'s result, and no information is left at <u>*parsePtr</u>.

       <b>Tcl_ParseBraces</b> parses a string or command argument enclosed in braces such as <b>{hello}</b> or <b>{string</b>  <b>\t</b>
       <b>with</b>  <b>\t</b>  <b>tabs}</b>  from the beginning of its argument <u>string</u>.  The first character of <u>string</u> must be <b>{</b>.
       If the braced string was parsed successfully, <b>Tcl_ParseBraces</b> returns <b>TCL_OK</b>, fills in the  structure
       pointed  to  by  <u>parsePtr</u> with information about the structure of the string (see below for details),
       and stores a pointer to the character just after the terminating <b>}</b> in the location given by <u>*termPtr</u>.
       If  an  error occurs while parsing the string then <b>TCL_ERROR</b> is returned, an error message is left in
       <u>interp</u>'s result, and no information is left at <u>*parsePtr</u> or <u>*termPtr</u>.

       <b>Tcl_ParseQuotedString</b> parses a double-quoted string such as <b>"sum</b> <b>is</b> <b>[expr</b> <b>$a+$b]"</b> from the  beginning
       of  the  argument  <u>string</u>.  The first character of <u>string</u> must be <b>"</b>.  If the double-quoted string was
       parsed successfully, <b>Tcl_ParseQuotedString</b> returns <b>TCL_OK</b>, fills  in  the  structure  pointed  to  by
       <u>parsePtr</u>  with  information  about  the structure of the string (see below for details), and stores a
       pointer to the character just after the terminating <b>"</b> in the location given by <u>*termPtr</u>.  If an error
       occurs  while  parsing  the  string  then <b>TCL_ERROR</b> is returned, an error message is left in <u>interp</u>'s
       result, and no information is left at <u>*parsePtr</u> or <u>*termPtr</u>.

       <b>Tcl_ParseVarName</b> parses a Tcl variable reference such as <b>$abc</b> or  <b>$x([expr</b>  <b>$index</b>  <b>+</b>  <b>1])</b>  from  the
       beginning  of  its <u>string</u> argument.  The first character of <u>string</u> must be <b>$</b>.  If a variable name was
       parsed successfully, <b>Tcl_ParseVarName</b> returns <b>TCL_OK</b>  and  fills  in  the  structure  pointed  to  by
       <u>parsePtr</u>  with  information  about the structure of the variable name (see below for details).  If an
       error occurs while parsing the command then <b>TCL_ERROR</b> is  returned,  an  error  message  is  left  in
       <u>interp</u>'s result (if <u>interp</u> isn't NULL), and no information is left at <u>*parsePtr</u>.

       <b>Tcl_ParseVar</b>  parse a Tcl variable reference such as <b>$abc</b> or <b>$x([expr</b> <b>$index</b> <b>+</b> <b>1])</b> from the beginning
       of its <u>string</u> argument.  The first character of <u>string</u> must be <b>$</b>.  If the  variable  name  is  parsed
       successfully, <b>Tcl_ParseVar</b> returns a pointer to the string value of the variable.  If an error occurs
       while parsing, then NULL is returned and an error message is left in <u>interp</u>'s result.

       The information left at <u>*parsePtr</u> by <b>Tcl_ParseCommand</b>, <b>Tcl_ParseExpr</b>, <b>Tcl_ParseBraces</b>, <b>Tcl_ParseQuot</b>-<font color="#ffffff" class="whiteout">edString,&nbsp;Tcl_ParseQuotedString,</font>
       <b>edString</b>,  and <b>Tcl_ParseVarName</b> may include dynamically allocated memory.  If these five parsing pro-<font color="#ffffff" class="whiteout">cedures&nbsp;procedures</font>
       cedures return <b>TCL_OK</b> then the caller must invoke <b>Tcl_FreeParse</b> to release the storage at  <u>*parsePtr</u>.
       These  procedures  ignore  any  existing  information in <u>*parsePtr</u> (unless <u>append</u> is non-zero), so if
       repeated calls are being made to any of them then <b>Tcl_FreeParse</b> must be invoked once after each call.

       <b>Tcl_EvalTokensStandard</b>  evaluates  a sequence of parse tokens from a Tcl_Parse structure.  The tokens
       typically consist of all the tokens in a word or all the tokens that make up the index for  a  refer-<font color="#ffffff" class="whiteout">ence&nbsp;reference</font>
       ence to an array variable.  <b>Tcl_EvalTokensStandard</b> performs the substitutions requested by the tokens
       and concatenates the resulting values.  The return value from <b>Tcl_EvalTokensStandard</b> is a Tcl comple-<font color="#ffffff" class="whiteout">tion&nbsp;completion</font>
       tion code with one of the values <b>TCL_OK</b>, <b>TCL_ERROR</b>, <b>TCL_RETURN</b>, <b>TCL_BREAK</b>, or <b>TCL_CONTINUE</b>, or possi-<font color="#ffffff" class="whiteout">bly&nbsp;possibly</font>
       bly some other integer value originating in an extension.  In addition, a result value or error  mes-<font color="#ffffff" class="whiteout">sage&nbsp;message</font>
       sage is left in <u>interp</u>'s result; it can be retrieved using <b>Tcl_GetObjResult</b>.

       <b>Tcl_EvalTokens</b> differs from <b>Tcl_EvalTokensStandard</b> only in the return convention used: it returns the
       result in a new Tcl_Obj.  The reference count of the object returned as result has been  incremented,
       so the caller must invoke <b>Tcl_DecrRefCount</b> when it is finished with the object.  If an error or other
       exception occurs while evaluating the tokens (such as a reference to a  non-existent  variable)  then
       the  return  value is NULL and an error message is left in <u>interp</u>'s result. The use of <b>Tcl_EvalTokens</b>
       is deprecated.


<b>TCL_PARSE</b> <b>STRUCTURE</b>
       <b>Tcl_ParseCommand</b>, <b>Tcl_ParseExpr</b>, <b>Tcl_ParseBraces</b>, <b>Tcl_ParseQuotedString</b>, and <b>Tcl_ParseVarName</b>  return
       parse information in two data structures, Tcl_Parse and Tcl_Token:
              typedef struct Tcl_Parse {
                CONST char *<u>commentStart</u>;
                int <u>commentSize</u>;
                CONST char *<u>commandStart</u>;
                int <u>commandSize</u>;
                int <u>numWords</u>;
                Tcl_Token *<u>tokenPtr</u>;
                int <u>numTokens</u>;
                ...
              } Tcl_Parse;

              typedef struct Tcl_Token {
                  int <u>type</u>;
                  CONST char *<u>start</u>;
                  int <u>size</u>;
                  int <u>numComponents</u>;
              } Tcl_Token;

       The  first five fields of a Tcl_Parse structure are filled in only by <b>Tcl_ParseCommand</b>.  These fields
       are not used by the other parsing procedures.

       <b>Tcl_ParseCommand</b> fills in a Tcl_Parse structure with information that describes one Tcl  command  and
       any comments that precede the command.  If there are comments, the <u>commentStart</u> field points to the <b>#</b>
       character that begins the first comment and <u>commentSize</u> indicates the number of bytes in all  of  the
       comments preceding the command, including the newline character that terminates the last comment.  If
       the command is not preceded by any comments, <u>commentSize</u> is 0.  <b>Tcl_ParseCommand</b> also sets  the  <u>com</u>-<font color="#ffffff" class="whiteout">mandStart&nbsp;commandStart</font>
       <u>mandStart</u>  field  to point to the first character of the first word in the command (skipping any com-<font color="#ffffff" class="whiteout">ments&nbsp;comments</font>
       ments and leading space) and <u>commandSize</u> gives the total number of bytes in  the  command,  including
       the character pointed to by <u>commandStart</u> up to and including the newline, close bracket, or semicolon
       character that terminates the command.  The <u>numWords</u> field gives the total number  of  words  in  the
       command.

       All  parsing  procedures set the remaining fields, <u>tokenPtr</u> and <u>numTokens</u>.  The <u>tokenPtr</u> field points
       to the first in an array of Tcl_Token structures that describe the components  of  the  entity  being
       parsed.   The <u>numTokens</u> field gives the total number of tokens present in the array.  Each token con-<font color="#ffffff" class="whiteout">tains&nbsp;contains</font>
       tains four fields.  The <u>type</u> field selects one of several token types that are described below.   The
       <u>start</u>  field  points to the first character in the token and the <u>size</u> field gives the total number of
       characters in the token.  Some token types, such as <b>TCL_TOKEN_WORD</b> and <b>TCL_TOKEN_VARIABLE</b>, consist of
       several  component  tokens,  which  immediately  follow  the  parent  token;  the <u>numComponents</u> field
       describes how many of these there are.  The <u>type</u> field has one of the following values:

       <b>TCL_TOKEN_WORD</b>      This token ordinarily describes one word of a command but it may also describe  a
                           quoted or braced string in an expression.  The token describes a component of the
                           script that is the result of concatenating together a sequence of  subcomponents,
                           each described by a separate subtoken.  The token starts with the first non-blank
                           character of the component (which may  be  a  double-quote  or  open  brace)  and
                           includes all characters in the component up to but not including the space, semi-<font color="#ffffff" class="whiteout">colon,&nbsp;semicolon,</font>
                           colon, close bracket, close quote, or close brace that terminates the  component.
                           The  <u>numComponents</u>  field  counts the total number of sub-tokens that make up the
                           word, including sub-tokens of <b>TCL_TOKEN_VARIABLE</b> and <b>TCL_TOKEN_BS</b> tokens.

       <b>TCL_TOKEN_SIMPLE_WORD</b>
                           This token has the same meaning as <b>TCL_TOKEN_WORD</b>, except that the word is  guar-<font color="#ffffff" class="whiteout">anteed&nbsp;guaranteed</font>
                           anteed  to consist of a single <b>TCL_TOKEN_TEXT</b> sub-token.  The <u>numComponents</u> field
                           is always 1.

       <b>TCL_TOKEN_TEXT</b>      The token describes a range of literal text that is part of a word.  The  <u>numCom</u>-<font color="#ffffff" class="whiteout">ponents&nbsp;numComponents</font>
                           <u>ponents</u> field is always 0.

       <b>TCL_TOKEN_BS</b>        The  token describes a backslash sequence such as <b>\n</b> or <b>\0xa3</b>.  The <u>numComponents</u>
                           field is always 0.

       <b>TCL_TOKEN_COMMAND</b>   The token describes a command whose result result must be  substituted  into  the
                           word.   The  token  includes  the square brackets that surround the command.  The
                           <u>numComponents</u> field is always 0 (the nested command is not parsed; call  <b>Tcl_Par</b>-<font color="#ffffff" class="whiteout">seCommand&nbsp;Tcl_ParseCommand</font>
                           <b>seCommand</b> recursively if you want to see its tokens).

       <b>TCL_TOKEN_VARIABLE</b>  The  token describes a variable substitution, including the <b>$</b>, variable name, and
                           array index (if there is one) up through the close  parenthesis  that  terminates
                           the index.  This token is followed by one or more additional tokens that describe
                           the variable name and array index.  If <u>numComponents</u>  is 1 then the variable is a
                           scalar and the next token is a <b>TCL_TOKEN_TEXT</b> token that gives the variable name.
                           If <u>numComponents</u> is greater than 1 then the variable is an array: the first  sub-<font color="#ffffff" class="whiteout">token&nbsp;subtoken</font>
                           token  is  a  <b>TCL_TOKEN_TEXT</b>  token  giving the array name and the remaining sub-<font color="#ffffff" class="whiteout">tokens&nbsp;subtokens</font>
                           tokens are <b>TCL_TOKEN_TEXT</b>, <b>TCL_TOKEN_BS</b>, <b>TCL_TOKEN_COMMAND</b>,  and  <b>TCL_TOKEN_VARI</b>-<font color="#ffffff" class="whiteout">ABLE&nbsp;TCL_TOKEN_VARIABLE</font>
                           <b>ABLE</b>  tokens  that must be concatenated to produce the array index. The <u>numCompo</u>-<font color="#ffffff" class="whiteout">nents&nbsp;numComponents</font>
                           <u>nents</u> field includes nested sub-tokens that are part of <b>TCL_TOKEN_VARIABLE</b> tokens
                           in the array index.

       <b>TCL_TOKEN_SUB_EXPR</b>  The token describes one subexpression of an expression (or an entire expression).
                           A subexpression may consist of a value such as an integer literal, variable  sub-<font color="#ffffff" class="whiteout">stitution,&nbsp;substitution,</font>
                           stitution, or parenthesized subexpression; it may also consist of an operator and
                           its operands.  The token starts with the first non-blank character of the  subex-<font color="#ffffff" class="whiteout">pression&nbsp;subexpression</font>
                           pression  up  to but not including the space, brace, close-paren, or bracket that
                           terminates the subexpression.  This token is followed by one or  more  additional
                           tokens  that  describe  the  subexpression.   If  the  first  sub-token after the
                           <b>TCL_TOKEN_SUB_EXPR</b> token is a <b>TCL_TOKEN_OPERATOR</b> token,  the  subexpression  con-<font color="#ffffff" class="whiteout">sists&nbsp;consists</font>
                           sists  of  an  operator and its token operands.  If the operator has no operands,
                           the subexpression consists of just the <b>TCL_TOKEN_OPERATOR</b> token.  Each operand is
                           described by a <b>TCL_TOKEN_SUB_EXPR</b> token.  Otherwise, the subexpression is a value
                           described by one of the token types <b>TCL_TOKEN_WORD</b>, <b>TCL_TOKEN_TEXT</b>, <b>TCL_TOKEN_BS</b>,
                           <b>TCL_TOKEN_COMMAND</b>, <b>TCL_TOKEN_VARIABLE</b>, and <b>TCL_TOKEN_SUB_EXPR</b>.  The <u>numComponents</u>
                           field counts the total number of sub-tokens that make up the subexpression;  this
                           includes the sub-tokens for any nested <b>TCL_TOKEN_SUB_EXPR</b> tokens.

       <b>TCL_TOKEN_OPERATOR</b>  The  token  describes  one  operator  of  an  expression such as <b>&amp;&amp;</b> or <b>hypot</b>.  An
                           <b>TCL_TOKEN_OPERATOR</b> token is always preceded by a  <b>TCL_TOKEN_SUB_EXPR</b>  token  that
                           describes the operator and its operands; the <b>TCL_TOKEN_SUB_EXPR</b> token's <u>numCompo</u>-<font color="#ffffff" class="whiteout">nents&nbsp;numComponents</font>
                           <u>nents</u> field can be used to determine the number of operands.  A  binary  operator
                           such  as  <b>*</b>  is followed by two <b>TCL_TOKEN_SUB_EXPR</b> tokens that describe its oper-<font color="#ffffff" class="whiteout">ands.&nbsp;operands.</font>
                           ands.  A unary operator like <b>-</b> is followed by a single  <b>TCL_TOKEN_SUB_EXPR</b>  token
                           for  its  operand.   If  the  operator  is  a  math  function  such as <b>log10</b>, the
                           <b>TCL_TOKEN_OPERATOR</b> token will give its name and the following  <b>TCL_TOKEN_SUB_EXPR</b>
                           tokens  will  describe  its operands; if there are no operands (as with <b>rand</b>), no
                           <b>TCL_TOKEN_SUB_EXPR</b> tokens follow.  There is one trinary operator, <b>?</b>, that appears
                           in if-then-else subexpressions such as <u>x</u><b>?</b><u>y</u><b>:</b><u>z</u>; in this case, the <b>?</b> <b>TCL_TOKEN_OPER</b>-<font color="#ffffff" class="whiteout">ATOR&nbsp;TCL_TOKEN_OPERATOR</font>
                           <b>ATOR</b> token is followed by three <b>TCL_TOKEN_SUB_EXPR</b> tokens for the operands <u>x</u>,  <u>y</u>,
                           and <u>z</u>.  The <u>numComponents</u> field for a <b>TCL_TOKEN_OPERATOR</b> token is always 0.

       After  <b>Tcl_ParseCommand</b>  returns,  the  first token pointed to by the <u>tokenPtr</u> field of the Tcl_Parse
       structure always has type <b>TCL_TOKEN_WORD</b> or <b>TCL_TOKEN_SIMPLE_WORD</b>.  It is followed by the  sub-tokens
       that must be concatenated to produce the value of that word.  The next token is the <b>TCL_TOKEN_WORD</b> or
       <b>TCL_TOKEN_SIMPLE_WORD</b> token for the second word, followed by sub-tokens for  that  word,  and  so  on
       until all <u>numWords</u> have been accounted for.

       After <b>Tcl_ParseExpr</b> returns, the first token pointed to by the <u>tokenPtr</u> field of the Tcl_Parse struc-<font color="#ffffff" class="whiteout">ture&nbsp;structure</font>
       ture always has type <b>TCL_TOKEN_SUB_EXPR</b>.  It is followed by the sub-tokens that must be evaluated  to
       produce  the value of the expression.  Only the token information in the Tcl_Parse structure is modi-<font color="#ffffff" class="whiteout">fied:&nbsp;modified:</font>
       fied: the <u>commentStart</u>, <u>commentSize</u>,  <u>commandStart</u>,  and  <u>commandSize</u>  fields  are  not  modified  by
       <b>Tcl_ParseExpr</b>.

       After  <b>Tcl_ParseBraces</b> returns, the array of tokens pointed to by the <u>tokenPtr</u> field of the Tcl_Parse
       structure will contain a single <b>TCL_TOKEN_TEXT</b> token if the braced string does not contain any  back-<font color="#ffffff" class="whiteout">slash-newlines.&nbsp;backslash-newlines.</font>
       slash-newlines.   If the string does contain backslash-newlines, the array of tokens will contain one
       or more <b>TCL_TOKEN_TEXT</b> or <b>TCL_TOKEN_BS</b> sub-tokens that must be concatenated to produce the  value  of
       the  string.   If  the  braced  string  was  just  <b>{}</b>  (that  is,  the  string was empty), the single
       <b>TCL_TOKEN_TEXT</b> token will have a <u>size</u> field containing zero; this ensures that  at  least  one  token
       appears to describe the braced string.  Only the token information in the Tcl_Parse structure is mod-<font color="#ffffff" class="whiteout">ified:&nbsp;modified:</font>
       ified: the <u>commentStart</u>, <u>commentSize</u>, <u>commandStart</u>,  and  <u>commandSize</u>  fields  are  not  modified  by
       <b>Tcl_ParseBraces</b>.

       After  <b>Tcl_ParseQuotedString</b>  returns,  the  array  of tokens pointed to by the <u>tokenPtr</u> field of the
       Tcl_Parse structure depends on the contents of the quoted string.  It will consist  of  one  or  more
       <b>TCL_TOKEN_TEXT</b>, <b>TCL_TOKEN_BS</b>, <b>TCL_TOKEN_COMMAND</b>, and <b>TCL_TOKEN_VARIABLE</b> sub-tokens.  The array always
       contains at least one token; for example, if the argument <u>string</u> is empty, the  array  returned  con-<font color="#ffffff" class="whiteout">sists&nbsp;consists</font>
       sists  of  a  single  <b>TCL_TOKEN_TEXT</b> token with a zero <u>size</u> field.  Only the token information in the
       Tcl_Parse structure is modified: the <u>commentStart</u>, <u>commentSize</u>, <u>commandStart</u>, and <u>commandSize</u>  fields
       are not modified.

       After  <b>Tcl_ParseVarName</b>  returns,  the  first token pointed to by the <u>tokenPtr</u> field of the Tcl_Parse
       structure always has type <b>TCL_TOKEN_VARIABLE</b>.  It is followed by the  sub-tokens  that  make  up  the
       variable  name  as  described  above.  The total length of the variable name is contained in the <u>size</u>
       field of the first token.  As in <b>Tcl_ParseExpr</b>, only the token information in the Tcl_Parse structure
       is  modified by <b>Tcl_ParseVarName</b>: the <u>commentStart</u>, <u>commentSize</u>, <u>commandStart</u>, and <u>commandSize</u> fields
       are not modified.

       All of the character pointers in the Tcl_Parse and Tcl_Token structures refer to  characters  in  the
       <u>string</u>  argument  passed  to <b>Tcl_ParseCommand</b>, <b>Tcl_ParseExpr</b>, <b>Tcl_ParseBraces</b>, <b>Tcl_ParseQuotedString</b>,
       and <b>Tcl_ParseVarName</b>.

       There are additional fields in the Tcl_Parse structure after the <u>numTokens</u> field, but these  are  for
       the  private  use  of  <b>Tcl_ParseCommand</b>,  <b>Tcl_ParseExpr</b>,  <b>Tcl_ParseBraces</b>, <b>Tcl_ParseQuotedString</b>, and
       <b>Tcl_ParseVarName</b>; they should not be referenced by code outside of these procedures.


<b>KEYWORDS</b>
       backslash substitution, braces, command, expression, parse, token, variable substitution



Tcl                                                  8.3                                 <a href="Tcl_ParseCommand.3tcl.html#//apple_ref/doc/man/3/Tcl_ParseCommand">Tcl_ParseCommand(3)</a>
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_ParseVarName.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_ParseVarName.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_ParseVarName.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
