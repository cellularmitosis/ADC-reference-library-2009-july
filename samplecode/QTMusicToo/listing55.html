<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTMusicToo - /&bull;QTMusic Sample Sequencer/SequencerTest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">QTMusicToo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxMusicAudio-date.html" target="_blank">QuickTime > Audio</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTMusicToo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/&bull;QTMusic Sample Sequencer/SequencerTest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BigEasy/BigEasy2.c</option>
<option value="listing2.html">/BigEasy/BigEasy2.h</option>
<option value="listing3.html">/BigEasy/BigEasyControls.c</option>
<option value="listing4.html">/BigEasy/BigEasyControls.h</option>
<option value="listing5.html">/BigEasy/BigEasyDialogs.c</option>
<option value="listing6.html">/BigEasy/BigEasyDialogs.h</option>
<option value="listing7.html">/BigEasy/BigEasyGestalt.c</option>
<option value="listing8.html">/BigEasy/BigEasyGestalt.h</option>
<option value="listing9.html">/BigEasy/BigEasyGrafish.c</option>
<option value="listing10.html">/BigEasy/BigEasyGrafish.h</option>
<option value="listing11.html">/BigEasy/BigEasyPPC.c</option>
<option value="listing12.html">/BigEasy/BigEasyPPC.h</option>
<option value="listing13.html">/BigEasy/BigEasyStandardControls.c</option>
<option value="listing14.html">/BigEasy/BigEasyStandardControls.h</option>
<option value="listing15.html">/BigEasy/BigEasyTextish.c</option>
<option value="listing16.html">/BigEasy/BigEasyTextish.h</option>
<option value="listing17.html">/BigEasy/BigEasyUtils.c</option>
<option value="listing18.html">/BigEasy/BigEasyUtils.h</option>
<option value="listing19.html">/BigEasy/IconUtilsPriv.h</option>
<option value="listing20.html">/BigEasy/NWindows.c</option>
<option value="listing21.html">/BigEasy/OneWindow.c</option>
<option value="listing22.html">/•Instrument Editor/All The MIDI Components.h</option>
<option value="listing23.html">/•Instrument Editor/IE KeyboardDiagram.c</option>
<option value="listing24.html">/•Instrument Editor/IE KeyboardDiagram.h</option>
<option value="listing25.html">/•Instrument Editor/IE PrintUtilities.c</option>
<option value="listing26.html">/•Instrument Editor/IE PrintUtilities.h</option>
<option value="listing27.html">/•Instrument Editor/Instrument Editor Controls.c</option>
<option value="listing28.html">/•Instrument Editor/Instrument Editor Controls.h</option>
<option value="listing29.html">/•Instrument Editor/Instrument Editor Draw.c</option>
<option value="listing30.html">/•Instrument Editor/Instrument Editor Filing.c</option>
<option value="listing31.html">/•Instrument Editor/Instrument Editor Filing.h</option>
<option value="listing32.html">/•Instrument Editor/Instrument Editor Menus.c</option>
<option value="listing33.html">/•Instrument Editor/Instrument Editor Menus.h</option>
<option value="listing34.html">/•Instrument Editor/Instrument Editor.c</option>
<option value="listing35.html">/•Instrument Editor/Instrument Editor.h</option>
<option value="listing36.html">/•Instrument Editor/Instrument Editor.r</option>
<option value="listing37.html">/•Instrument Editor/Instrument Tests.c</option>
<option value="listing38.html">/•Instrument Editor/More IE Routines.c</option>
<option value="listing39.html">/•Instrument Editor/More IE Routines.h</option>
<option value="listing40.html">/•Instrument Picker Test/InstrumentPickerTest.c</option>
<option value="listing41.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.c</option>
<option value="listing42.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.h</option>
<option value="listing43.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.r</option>
<option value="listing44.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.c</option>
<option value="listing45.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.r</option>
<option value="listing46.html">/•QTMusic Sample Sequencer/Event Priority Queue.c</option>
<option value="listing47.html">/•QTMusic Sample Sequencer/Event Priority Queue.h</option>
<option value="listing48.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.c</option>
<option value="listing49.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.h</option>
<option value="listing50.html">/•QTMusic Sample Sequencer/SequencerTest Filing.c</option>
<option value="listing51.html">/•QTMusic Sample Sequencer/SequencerTest Filing.h</option>
<option value="listing52.html">/•QTMusic Sample Sequencer/SequencerTest Movies.h</option>
<option value="listing53.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.c</option>
<option value="listing54.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.h</option>
<option value="listing55.html">/•QTMusic Sample Sequencer/SequencerTest.c</option>
<option value="listing56.html">/•QTMusic Sample Sequencer/SequencerTest.h</option></select>
				</p>
				</form>
				<p><strong><a href="QTMusicToo.zip">Download Sample</a></strong> (&#147;QTMusicToo.zip&#148;, 115.5K)<BR>
<strong><a href="QTMusicToo.dmg">Download Sample</a></strong> (&#147;QTMusicToo.dmg&#148;, 173.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* * file: SequencerTest.c * * started 12 January 1992 09:34 * david van brink * * A starting point for BigEasy programs * */ /*--------------------------  Inclusions--------------------------*/#include &lt;QuickDraw.h&gt;#include &lt;Windows.h&gt;#include &lt;Memory.h&gt;#include &lt;BDC.h&gt;//#include &lt;Packages.h&gt;#include &lt;Movies.h&gt;#include &quot;BigEasy2.h&quot;#include &quot;BigEasyUtils.h&quot;#include &quot;BigEasyTextish.h&quot;#include &quot;BigEasyGrafish.h&quot;#include &quot;BigEasyDialogs.h&quot;#define globals#include &quot;SequencerTest.h&quot;#include &quot;SequencerTest Filing.h&quot;#include &quot;SequencerTest Realtime.h&quot;#include &quot;SequencerTest Movies.h&quot;/*--------------------------  Limits and Konstants--------------------------*/enum  {  mNew = 100,  mOpen,  mSave,  mFirstDocOnly,  mClose,  mSaveAs,  mTestTunePlayer,  mTestTunePlayerFast,  mTestTunePlayerSlave,  mSetScale,  mMakeMIDIMovie,  mTestTuneRate,  mLastDocOnly,  mLast  };/*--------------------------  Types and globals--------------------------*/#define kHeaderHeight 16#define kDocMargin 8#define kPip 4#define kScorePartHeight (kPip*kScoreHeight + 1 + 3*kDocMargin)#define SignIt(x) ( (x)?1:-1)/*--------------------------  Prototypes--------------------------*/static void DrawDoc(short n);static void ClickDoc(short n,Point p,short mods);static void KeyDoc(short n,short key,short code, short mods);static short CloseDoc(short n);static void ActivateDoc(short n);static void DeactivateDoc(short n);static void MoveDoc(short n);static void IdleDoc(short n,Boolean front);static void LetsQuit(void);static void OpenAWindow(void);static void NewDoc(void);static void MakeWindow(void);static void About(void);static void InitVars(void);static void PointToPip(Point p,Rect *pipRect,short *pipX,short *pipY);static void PipToRect(short pipX,short pipY,Rect *pipRect,Rect *r);static void SetPipBit(ScorePart *sp,short pipX, short pipY, Boolean x);static pascal Boolean MyFilterProc(DialogPtr theDialog,    EventRecord *theEvent,short *itemHit);static void TestTuneQ1Looped(short n,short item, short ref);static void TestTuneQ1(short n,short item, short ref);static void TestTuneQ2(short n,short item, short ref);static void TestTuneQ3(short n,short item, short ref);static void TestTuneQ4(short n,short item, short ref);static void TestTuneQ5(short n,short item, short ref);static void TestTuneGaps(short n,short item, short ref);static void TestTuneQ(short n,short item, short ref);static void TestTune(short n,short item, short ref);static void TestTuneSlave(short n,short item, short ref);static void SetScale(short n,short item, short ref);static void TilePart(ScorePart *sp,short tileSize);/*--------------------------  Computer Programs--------------------------*/void DrawDoc(short n)/* * Draws the window. */  {  Rect r,r2;  TDoc *d;  short i,x,y;  ScorePart *sp;  short phase;  d = &amp;gDoc[n-kFirstDocWindow];  GoBW();  RGBBack(50000,50000,40000);  EraseRect(&amp;gBigRect);  GoBW();  MoveTo(0,kHeaderHeight - 3);  Line(10000,0);  MoveTo(0,kHeaderHeight - 1);  Line(10000,0);  MoveTo(10,kHeaderHeight - 6);  TextSize(9);  TextFont(3);  TextFace(0);  DrawString(&quot;\pQuickTime Score Length: &quot;);  if(d-&gt;qtScore)    {    DrawNum(GetHandleSize(d-&gt;qtScore));    DrawString(&quot;\p bytes&quot;);    }  EraseRect(&amp;g.timeRect);  FrameRect(&amp;g.timeRect);  for(i = 0; i&lt;kScoreParts; i++)    {    r = g.instrumentNameRect[i];    EraseRect(&amp;r);    FrameRect(&amp;r);    MoveTo(r.left + 5,r.bottom - 3);    DrawNum(i+1);    DrawString(&quot;\p. &quot;);    DrawString(d-&gt;sr.score[i].tone.instrumentName);    r2 = g.scoreRect[i];    EraseRect(&amp;r2);    FrameRect(&amp;r2);    phase = 0;    for(x = r2.top + kPipSize; x &lt; r2.bottom-1; x += kPipSize)      {      if(phase++ % 12)        RGBFore(50000,50000,50000);      else        RGBFore(20000,20000,20000);      MoveTo(r2.left + 1,x);      LineTo(r2.right - 2,x);      }    phase = 1;    for(x = r2.left + kPipSize; x &lt; r2.right-1; x += kPipSize)      {      if(phase % 16 == 0)        RGBFore(0,0,0);      else if(phase % 8 == 0)        RGBFore(20000,20000,20000);      else if(phase % 4 == 0)        RGBFore(40000,40000,40000);      else        RGBFore(50000,50000,50000);      MoveTo(x,r2.top + 1);      LineTo(x,r2.bottom - 2);      phase ++;      }    RGBFore(20000,20000,10000);    PenSize(2,2);    MoveTo(r.right,r.top + 2);    LineTo(r.right,r2.bottom);    LineTo(r2.left + 2,r2.bottom);    GoBW();    sp = &amp;d-&gt;sr.score[i];    for(x = 0; x &lt; kScoreLength; x++)      for(y = 0; y&lt; kScoreHeight; y++)        {        if(GetPipBit(sp,x,y))          {          PipToRect(x,y,&amp;g.scoreRect[i],&amp;r);          PaintRect(&amp;r);          }        }    }  }void ClickDoc(short n,Point p,short mods)  {  short i;  Boolean x;  ScorePart *sp;  TDoc *d;  short pipX,pipY;  short lastPipX,lastPipY;  short v;  Rect r;  ComponentResult thisError;  d = &amp;gDoc[n-kFirstDocWindow];  if(PtInRect(p,&amp;g.timeRect))    {    PointToPip(p,&amp;g.timeRect,&amp;pipX,&amp;pipY);    /* pipX is the time */    d-&gt;position = pipX;    DoTheHeader(d);    thisError = TuneInstant(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),pipX+1);    ShowError(thisError);    lastPipX = pipX;    while(Button())      {      GetMouse(&amp;p);      PointToPip(p,&amp;g.timeRect,&amp;pipX,&amp;pipY);    /* pipX is the time */      if(pipX != lastPipX)        {        thisError = TuneInstant(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),pipX+1);        ShowError(thisError);        lastPipX = pipX;        }      }    thisError = TuneInstant(d-&gt;tp,0,0);    ShowError(thisError);    }  for(i = 0; i&lt;kScoreParts; i++)    {    sp = &amp;d-&gt;sr.score[i];    if(PtInRect(p,&amp;g.scoreRect[i]))      {      if(mods &amp; optionKey)        {        PointToPip(p,&amp;g.scoreRect[i],&amp;pipX,&amp;pipY);        pipY = kNoteRangeHigh - pipY;        NAPlayNote(g.na,d-&gt;noteChannel[i],pipY,64);        while(StillDown());        NAPlayNote(g.na,d-&gt;noteChannel[i],pipY,0);                }      else        {        v = p.v;        d-&gt;changed = true;        PointToPip(p,&amp;g.scoreRect[i],&amp;lastPipX,&amp;lastPipY);        x = !GetPipBit(sp,lastPipX,lastPipY);        SetPipBit(sp,lastPipX,lastPipY,x);        PipToRect(lastPipX,lastPipY,&amp;g.scoreRect[i],&amp;r);        if(x)          PaintRect(&amp;r);        else          EraseRect(&amp;r);          do          {          GetMouse(&amp;p);          if(mods &amp; shiftKey)            p.v = v;          PointToPip(p,&amp;g.scoreRect[i],&amp;pipX,&amp;pipY);          if(pipX != lastPipX || pipY != lastPipY)            {            if(pipX &gt;= 0 &amp;&amp; pipX &lt; kScoreLength                &amp;&amp; pipY &gt;= 0 &amp;&amp; pipY &lt; kScoreHeight)              {              SetPipBit(sp,pipX,pipY,x);              PipToRect(pipX,pipY,&amp;g.scoreRect[i],&amp;r);              if(x)                PaintRect(&amp;r);              else                EraseRect(&amp;r);              }            lastPipX = pipX;            lastPipY = pipY;            }          } while(StillDown());        }  /* if in score rect w/o optionkey */      d-&gt;validQTScore = false;      } /* if in score rect */    else if(PtInRect(p,&amp;g.instrumentNameRect[i]))      {      UnrollDoc(d);      x = NAPickInstrument(g.na,MyFilterProc,&quot;\pNew instrument for part?&quot;,&amp;sp-&gt;tone,          0,0,0,0);//      x = NAPickInstrument(g.na,MyFilterProc,&quot;\pNew instrument for part?&quot;,&amp;sp-&gt;tone);      #ifdef separateNoteChannel        {        NoteRequest nr;        NADisposeNoteChannel(g.na,d-&gt;noteChannel[i]);        nr. = 2;        nr.tone = sp-&gt;tone;              NoteChannel(g.na,&amp;nr,&amp;d-&gt;noteChannel[i]);        }      #else        d-&gt;validQTScore = false;        DoTheHeader(d);      #endif      InvalRect(&amp;g.instrumentNameRect[i]);      d-&gt;changed = true;      }    }  FixUpMenus(d);  }pascal Boolean MyFilterProc(DialogPtr theDialog,    EventRecord *theEvent,short *itemHit)  {  GrafPort *oldPort;  GetPort(&amp;oldPort);  SetPort(theDialog);  if(theEvent-&gt;what == updateEvt &amp;&amp; (DialogPtr)theEvent-&gt;message != theDialog)      HandleUpdateEvent(theEvent);  SetPort(oldPort);  return false;  }void PointToPip(Point p,Rect *pipRect,short *pipX,short *pipY)  {  *pipX = (p.h - pipRect-&gt;left)/kPipSize;  *pipY = (p.v - pipRect-&gt;top)/kPipSize;  if(*pipX &lt; 0)    *pipX = 0;  else if (*pipX &gt;= kScoreLength)    *pipX = kScoreLength - 1;  if(*pipY &lt; 0)    *pipY = 0;  else if (*pipY &gt;= kScoreHeight)    *pipY = kScoreHeight - 1;  }void PipToRect(short pipX,short pipY,Rect *pipRect,Rect *r)  {  r-&gt;left = pipRect-&gt;left + kPipSize * pipX + 1;  r-&gt;top = pipRect-&gt;top + kPipSize * pipY + 1;  r-&gt;right = r-&gt;left + kPipSize - 1;  r-&gt;bottom = r-&gt;top + kPipSize - 1;  }void SetPipBit(ScorePart *sp,short pipX, short pipY, Boolean x)  {  if(pipY &gt;= kScoreHeight || pipX &gt;= kScoreLength)    Debugger();  /* bad input */  if(x)    sp-&gt;score[pipY][pipX/32] |= 1L&lt;&lt;(pipX &amp; 31);  else    sp-&gt;score[pipY][pipX/32] &amp;= ~(1L&lt;&lt;(pipX &amp; 31));  }Boolean GetPipBit(ScorePart *sp,short pipX, short pipY)  {  if(pipY &gt;= kScoreHeight || pipX &gt;= kScoreLength)    Debugger();  /* bad input */  return ((sp-&gt;score[pipY][pipX/32]) &amp; (1L&lt;&lt;(pipX &amp; 31))) != 0;  }void TilePart(ScorePart *sp,short tileSize)  {  short i,j;  Boolean p;  for(i = tileSize; i &lt; kScoreLength; i++)    for(j = 0; j &lt; kScoreHeight; j++)      {      p = GetPipBit(sp,i%tileSize,j);      SetPipBit(sp,i,j,p);      }  }void KeyDoc(short n,short key,short code, short mods)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n-kFirstDocWindow];  switch(key)    {    case '1':;  tileIt:      TilePart(&amp;d-&gt;sr.score[0],16);      TilePart(&amp;d-&gt;sr.score[1],16);      TilePart(&amp;d-&gt;sr.score[2],16);      TilePart(&amp;d-&gt;sr.score[3],16);      InvalRect(&amp;gBigRect);      d-&gt;validQTScore = false;      break;    case 'c':  /* left arrow */      d-&gt;position = 0;      goto snippet;    case 28:  /* left arrow */      if(mods &amp; shiftKey)        d-&gt;position -= 4;      else        d-&gt;position -= 1;      goto snippet;    case 29:  /* right arrow */      if(mods &amp; shiftKey)        d-&gt;position += 4;      else        d-&gt;position += 1;    snippet:      if(d-&gt;position &lt; 0 || d-&gt;position &gt; 64)        d-&gt;position = 0;      DoTheHeader(d);      thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),0x00010000,          d-&gt;position,d-&gt;position+4,kTuneStartNow,nil,0);      ShowError(thisError);      break;    }  }short CloseDoc(short n)/* * Close that window... */  {  short x;  TDoc *d;  Boolean cancelSave;  d = &amp;gDoc[n - kFirstDocWindow];  if(d-&gt;used &amp;&amp; d-&gt;changed)    {    x = EasyDialogMessage(0,d-&gt;docSpec.name,&quot;\pSave changes before closing this document?&quot;,        kEasyDialogSaveDiscardCancel);    if(x == 2)      cancelSave = true;    else if(x == 0)      cancelSave = SaveDoc(n,0,0);    else      cancelSave = false;    }  else    cancelSave = false;  if(!cancelSave)    {    short i;    UninstallWindow(n);  #ifdef separateNoteChannels    for(i = 0; i&lt;kScoreParts; i++)      NADisposeNoteChannel(g.na,d-&gt;noteChannel[i]);  #endif    CloseComponent(d-&gt;tp);    if(d-&gt;qtScore)      DisposeHandle(d-&gt;qtScore);    d-&gt;used = false;    gDocCount--;    }  return cancelSave;  }void FixUpMenus(TDoc *d)  /*   * Make menus suitable for document d,   * where d=nil means deactivate   */  {  short moreDocs;  moreDocs = SignIt(gDocCount&lt;kDocMax);  SetMenuItem(mNew,moreDocs,0,0,nil);  SetMenuItem(mOpen,moreDocs,0,0,nil);  if(d)    {     SetMenuItem(mSave,SignIt(d-&gt;changed || d-&gt;littleChanged),0,0,nil);    SetMenuItemRange(mFirstDocOnly,mLastDocOnly,1,0);    }  else    {     SetMenuItem(mSave,-1,0,0,nil);    SetMenuItemRange(mFirstDocOnly,mLastDocOnly,-1,0);    }  }void MoveDoc(short n)  {  TDoc *d;  d = &amp;gDoc[n - kFirstDocWindow];  d-&gt;littleChanged = true;  FixUpMenus(d);  }void ActivateDoc(short n)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  thisError = TunePreroll(d-&gt;tp);//  ShowError(thisError);  FixUpMenus(&amp;gDoc[n - kFirstDocWindow]);  }void DeactivateDoc(short n)  {  TDoc *d;  d = &amp;gDoc[n-kFirstDocWindow];  UnrollDoc(d);  FixUpMenus(nil);  }void IdleDoc(short n,Boolean front)  {  TDoc *d;  d = &amp;gDoc[n-kFirstDocWindow];  }void UnrollDoc(TDoc *d)  {  short j;  ComponentResult thisError;#ifdef separateNoteChannels  for(j = 0; j&lt;kScoreParts; j++)    NAUnrollNoteChannel(g.na,d-&gt;noteChannel[j]);#endif  thisError = TuneUnroll(d-&gt;tp);  ShowError(thisError);  }void LetsQuit(void)  {  short i;  TDoc *d;  short cancelQuit;  cancelQuit = 0;  for(i = 0; i&lt;kDocMax; i++)    {    d = &amp;gDoc[i];    if(d-&gt;used)      cancelQuit |= CloseDoc(i + kFirstDocWindow);    if(cancelQuit)      goto goHome;    }  gQuitApp++;goHome:;  }void NewDoc(void)  {  short i;  for(i = 0; i&lt;kDocMax; i++)    {    if(!gDoc[i].used)      {      NewDocFromSaveRecord(i,nil);      goto goHome;      }    }goHome:;  }void NewDocFromSaveRecord(short docNumber,TSaveRecord *sr)  {  TDoc *d;  Rect r;  short i;  ComponentResult thisError;  d = &amp;gDoc[docNumber];  d-&gt;changed = false;  if(sr)    {    gStaggerWindows = false;    r = sr-&gt;windowRect;    d-&gt;everSaved = true;    d-&gt;sr = sr-&gt;sr;    d-&gt;littleChanged = false;    }  else    {    gStaggerWindows = true;    SetRect(&amp;r,100,100,260,200);    CopyPString(d-&gt;docSpec.name,&quot;\pUntitled&quot;);    d-&gt;everSaved = false;    d-&gt;littleChanged = true;    for(i = 0; i &lt; kScoreParts; i++)      {      CopyPString(d-&gt;sr.score[i].tone.synthesizerName,&quot;\p&quot;);      CopyPString(d-&gt;sr.score[i].tone.instrumentName,&quot;\p&quot;);      d-&gt;sr.score[i].tone.instrumentNumber = 0;      d-&gt;sr.score[i].tone.gmNumber = 1;        {        short x,y;        for(x = 0; x &lt; kScoreLengthLongs; x++)          for(y = 0; y &lt; kScoreHeight; y++)            d-&gt;sr.score[i].score[y][x] = 0;        }      }    }  r.bottom = r.top + g.basicDocHeight;  r.right = r.left + g.basicDocWidth;  d-&gt;w = InstallWindow(docNumber + kFirstDocWindow,d-&gt;docSpec.name,&amp;r,0,0,      DrawDoc,ClickDoc,KeyDoc,(void *)CloseDoc,      ActivateDoc,DeactivateDoc,IdleDoc);  SetWindowMoveProc(docNumber + kFirstDocWindow,MoveDoc);  d-&gt;used = true;  #ifdef separateNoteChannel    {    NoteRequest nr[kScoreParts], *n;      for(i = 0; i&lt;kScoreParts; i++)      {      n = &amp;nr[i];      n-&gt;polyphony = 1;      n-&gt;tone = d-&gt;sr.score[i].tone;      thisError = NANewNoteChannel(g.na, n, &amp;d-&gt;noteChannel[i]);      ShowError(thisError);      }    }  #endif  d-&gt;tp = OpenDefaultComponent(kTunePlayerType,0);  thisError = TuneSetTimeScale(d-&gt;tp,10);  ShowError(thisError);  d-&gt;qtScore = 0;  d-&gt;validQTScore = false;  DoTheHeader(d);  gDocCount++;goHome:;  }void About(void)  {  EasyDialogMessage(0,(StringPtr)0x910,      &quot;\pby David Van Brink&quot;,      kEasyDialogOkay);  }void InitVars(void)/* * Called once at startup: yes, it * inits the vars. */  {  TDoc *dp;  short i;  Rect r;  short topBit;  EnterMovies();#if 0  do    {    g.na = OpenDefaultComponent('nota',0);    CloseComponent(g.na);    } while (!Button());#endif  g.na = OpenDefaultComponent('nota',0);  gDoc = (void *)NewPtrClear(kDocMax * sizeof(TDoc));  FailNil(gDoc);  for(i = 0; i&lt;kDocMax; i++)    {    dp = &amp;gDoc[i];    dp-&gt;used = false;    }  gDocCount = 0;  topBit = r.top = kHeaderHeight + kDocMargin;  r.left = kDocMargin;  for(i = 0; i&lt;kScoreParts; i++)    {    r.right = r.left + kPipSize*kScoreLength + 1;    r.bottom = r.top + 13;    g.instrumentNameRect[i] = r;    r.top = r.bottom - 1;    r.bottom = r.top + kPipSize*kScoreHeight + 1;    g.scoreRect[i] = r;    if(i &amp; 1)      {      r.top = topBit;      r.left = r.right + kDocMargin;      }    else      r.top = r.bottom + kDocMargin;    }  g.timeRect = g.scoreRect[kScoreParts-1];  g.timeRect.top = g.timeRect.bottom + kDocMargin;  g.timeRect.bottom = g.timeRect.top + kPipSize + 1;    g.basicDocWidth = g.scoreRect[kScoreParts-1].right + kDocMargin;  //g.basicDocHeight = g.scoreRect[kScoreParts-1].bottom + kDocMargin;  g.basicDocHeight = g.timeRect.bottom + kDocMargin;  }void Bootstrap()  {/*** File Menu ***/  InstallMenu(&quot;\pFile&quot;,nil,0);  InstallMenuItem(&quot;\pNew/N&quot;,(void *)NewDoc,mNew);  InstallMenuItem(&quot;\pOpen\xC9/O&quot;,OpenDoc,mOpen);  InstallMenuItem(&quot;\pClose/W&quot;,(void *)CloseDoc,-mClose);  InstallMenuItem(&quot;\p(-&quot;,nil,0);  InstallMenuItem(&quot;\pSave/S&quot;,(void *)SaveDoc,-mSave);  InstallMenuItem(&quot;\pSave As&quot;,(void *)SaveAsDoc,-mSaveAs);  InstallMenuItem(&quot;\pQuit/Q&quot;,(void *)LetsQuit,0);/*** Edit Menu ***/  InstallEditMenu(nil,nil,nil,nil,nil);/*** Special Menu ***/  InstallMenu(&quot;\pSpecial&quot;,(void *)nil,0);  InstallMenuItem(&quot;\pMake Movie&quot;,MakeAMIDIMovie,-mMakeMIDIMovie);  InstallMenuItem(&quot;\pMake timescaled Movie&quot;,MakeAFunkyMusicMovie,-mMakeMIDIMovie);  InstallMenuItem(&quot;\p(-&quot;,nil,0);  InstallMenuItem(&quot;\pTest Tune Looping&quot;,TestTuneQ1Looped,-mTestTunePlayer);  InstallMenuItem(&quot;\p(-&quot;,nil,0);  InstallMenuItem(&quot;\pTest Tune Queueing/1&quot;,TestTuneQ1,-mTestTunePlayer);  InstallMenuItem(&quot;\pTest Tune Queueing/2&quot;,TestTuneQ2,-mTestTunePlayer);  InstallMenuItem(&quot;\pTest Tune Queueing/3&quot;,TestTuneQ3,-mTestTunePlayer);  InstallMenuItem(&quot;\pTest Tune Queueing/4&quot;,TestTuneQ4,-mTestTunePlayer);  InstallMenuItem(&quot;\pTest Tune Rate/5&quot;,TestTuneQ5,-mTestTunePlayer);  InstallMenuItem(&quot;\pTest Tune Gaps/6&quot;,TestTuneGaps,-mTestTunePlayer);  InstallMenuItem(&quot;\p(-&quot;,nil,0);  InstallMenuItem(&quot;\pTest Fast Queueing/&quot;,TestTuneQ1,-mTestTunePlayerFast);  InstallMenuItem(&quot;\pTest Fast Queueing/(tm)&quot;,TestTuneQ2,-mTestTunePlayerFast);  InstallMenuItem(&quot;\pTest Fast Queueing/&pound;&quot;,TestTuneQ3,-mTestTunePlayerFast);  InstallMenuItem(&quot;\pTest Fast Queueing/&cent;&quot;,TestTuneQ4,-mTestTunePlayerFast);  InstallMenuItem(&quot;\p(-&quot;,nil,0);  InstallMenuItem(&quot;\pTest Tune Queueing/7&quot;,TestTuneQ,-mTestTunePlayer);  InstallMenuItem(&quot;\pTest Tune/8&quot;,TestTune,-mTestTunePlayer);  InstallMenuItem(&quot;\pTest Tune With Slave Time/9&quot;,TestTuneSlave,-mTestTunePlayerSlave);  InstallMenuItem(&quot;\pSet Scale&quot;,SetScale,-mSetScale);    {    Str63 s;    CopyPString(s,&quot;\pAbout &quot;);    ConcatenatePStrings(s,(StringPtr)0x910);    ConcatenatePStrings(s,&quot;\p&quot;);    SetAbout(s,0,About);    }  SetMasterOpenDocProc(OpenDocSpec);  SetMasterQuitAppProc(LetsQuit);  InitVars();  }void DoTheHeader(TDoc *d)  {  short i;  ComponentResult thisError;  Handle header;  UnrollDoc(d);  if(!d-&gt;validQTScore)    {    ScoreToQTScore(d);    header = BuildMusicHeader(d);      thisError = TuneSetHeader(d-&gt;tp,(unsigned long *)*header);    ShowError(thisError);    DisposeHandle(header);    for(i = 0; i &lt; kScoreParts; i++)      {      thisError = TuneGetIndexedNoteChannel(d-&gt;tp, i + 1, &amp;d-&gt;noteChannel[i]);      ShowError(thisError);      }    }  }void TestTune(short n,short item, short ref)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  DoTheHeader(d);  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),0x00010000,0,1000000,kTuneStartNow,nil,0);  ShowError(thisError);  }void TestTuneQ(short n,short item, short ref)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  if(!d-&gt;validQTScore)    return;  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),0x00010000,0,1000000,kTuneExcludeEdgeNotes,nil,0);  ShowError(thisError);  }void TestTuneQCommon(TDoc *d,Fixed rate,short ref,long start,long stop);void TestTuneQCommon(TDoc *d,Fixed rate,short ref,long start,long stop)  {  ComponentResult thisError;  if(!d-&gt;validQTScore)    return;  if(rate == 0)    rate = ref == mTestTunePlayerFast ? 2*0x00010000 : 0x00010000;  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),rate,start,stop,kTuneExcludeEdgeNotes,nil,0);  ShowError(thisError);  }void TestTuneQ1Looped(short n,short item, short ref)  {  ComponentResult thisError;  TDoc *d;  d = &amp;gDoc[n - kFirstDocWindow];  if(!d-&gt;validQTScore)    return;  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),0x00010000,      0,16,16+kTuneExcludeEdgeNotes,nil,0);  ShowError(thisError);  }void TestTuneQ1(short n,short item, short ref)  {  TDoc *d;  d = &amp;gDoc[n - kFirstDocWindow];  TestTuneQCommon(d,0,ref,0,16);  }void TestTuneQ2(short n,short item, short ref)  {  TDoc *d;  d = &amp;gDoc[n - kFirstDocWindow];  TestTuneQCommon(d,0,ref,16,32);  }void TestTuneQ3(short n,short item, short ref)  {  TDoc *d;  d = &amp;gDoc[n - kFirstDocWindow];  TestTuneQCommon(d,0,ref,32,48);  }void TestTuneQ4(short n,short item, short ref)  {  TDoc *d;  d = &amp;gDoc[n - kFirstDocWindow];  TestTuneQCommon(d,0,ref,48,64);  }static void TestTuneQ5(short n,short item, short ref)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  if(!d-&gt;validQTScore)    return;  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),0x00010000,0,16,kTuneExcludeEdgeNotes,nil,0);  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),2*0x00010000,16,32,kTuneExcludeEdgeNotes,nil,0);  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),3*0x00010000,32,48,kTuneExcludeEdgeNotes,nil,0);  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),0x00010000,48,64,kTuneExcludeEdgeNotes,nil,0);  ShowError(thisError);  }static void TestTuneGaps(short n,short item, short ref)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  if(!d-&gt;validQTScore)    return;  thisError = TuneQueue(d-&gt;tp,      0,0x00010000,0,16,kTuneExcludeEdgeNotes,nil,0);  }void IdleSlave(long refcon);void IdleSlave(long refcon)  {  TimeBase tb;  Rect r;  tb = (TimeBase)refcon;  SetRect(&amp;r,0,0,300,35);  MoveTo(30,30);  EraseRect(&amp;r);  DrawNum(GetTimeBaseTime(tb,1000,nil));  }void TestTuneSlave(short n,short item, short ref)  {  TDoc *d;  TimeBase myTB,theirTB;  ComponentInstance clock;  Component clockComponent;  ComponentDescription cd;  Rect r;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  DoTheHeader(d);  thisError = TuneGetTimeBase(d-&gt;tp,&amp;theirTB);  ShowError(thisError);  clock = GetTimeBaseMasterClock(theirTB);  GetComponentInfo((Component)clock,&amp;cd,0,0,0);  clockComponent = FindNextComponent(0,&amp;cd);  myTB = NewTimeBase();  SetTimeBaseRate(myTB,0x00000000);  SetTimeBaseMasterTimeBase(theirTB,myTB,0);  thisError = TuneQueue(d-&gt;tp,(unsigned long *)*(d-&gt;qtScore),0x00010000,0,1000000,kTuneStartNow,nil,0);  ShowError(thisError);  EasyDialogMessage(3,      &quot;\pPlay Tune&quot;,      &quot;\pStart the tune?&quot;,      kEasyDialogOkay);  SetTimeBaseRate(myTB,0x00030000);  SetRect(&amp;r,40,100,240,200);  EasyDialog(&amp;r,nil,nil,nil,IdleSlave,kEasyDialogOkay,(long)theirTB);  SetTimeBaseMasterClock(theirTB,clockComponent,nil);  DisposeTimeBase(myTB);  }static void SetScale(short n,short item, short ref)  {  TDoc *d;  ComponentResult thisError;  TimeScale ts;  Boolean x;  d = &amp;gDoc[n - kFirstDocWindow];  TuneGetTimeScale(d-&gt;tp,&amp;ts);  x = EasyDialogGetNumber(&quot;\pTune Scale&quot;,      &quot;\pEnter the number of beats per second:&quot;,      (long *)&amp;ts);  thisError = TuneSetTimeScale(d-&gt;tp,ts);  }void Hatstrap()/*  * clean up  */  {  }void ShowError(long error)  {  Str255 s1,s2,s3;  if(error &lt; 0)    {    AnyBaseToPString(error,16,8,s1);    NumToString((short)(error &amp; 0x0000FFFF),s2);    CopyPString(s3,&quot;\pComponent result: &quot;);    ConcatenatePStrings(s3,s1);    ConcatenatePStrings(s3,&quot;\p. Error word: &quot;);    ConcatenatePStrings(s3,s2);    ConcatenatePStrings(s3,&quot;\p.&quot;);    EasyDialogMessage(0,&quot;\pError&quot;,s3,kEasyDialogOkay);    }  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTMusicToo/listing55.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTMusicToo/listing55.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTMusicToo/listing55.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>