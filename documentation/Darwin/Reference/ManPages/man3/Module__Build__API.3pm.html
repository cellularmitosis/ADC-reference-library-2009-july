<html><head><title>Mac OS X
 Manual Page For Module::Build::API(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Module::Build::API" title="Mac OS X
 Manual Page for Module::Build::API(3pm)"><a name="//apple_ref/doc/man/3/Module::Build::API" title="Mac OS X
 Manual Page for Module::Build::API(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Module::Build::API"; name=Module::Build::API(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Module::Build::API(3)                User Contributed Perl Documentation               Module::Build::API(3)



<b>NAME</b>
       Module::Build::API - API Reference for Module Authors

<b>DESCRIPTION</b>
       I list here some of the most important methods in "Module::Build".  Normally you won't need to deal
       with these methods unless you want to subclass "Module::Build".  But since one of the reasons I
       created this module in the first place was so that subclassing is possible (and easy), I will
       certainly write more docs as the interface stabilizes.

       <b>CONSTRUCTORS</b>


       <u>current()</u>
           [version 0.20]

           This method returns a reasonable facsimile of the currently-executing "Module::Build" object
           representing the current build.  You can use this object to query its "notes()" method, inquire
           about installed modules, and so on.  This is a great way to share information between different
           parts of your build process.  For instance, you can ask the user a question during "perl
           Build.PL", then use their answer during a regression test:

             # In Build.PL:
             my $color = $build-&gt;prompt("What is your favorite color?");
             $build-&gt;notes(color =&gt; $color);

             # In t/colortest.t:
             use Module::Build;
             my $build = Module::Build-&gt;current;
             my $color = $build-&gt;notes('color');
             ...

           The way the "current()" method is currently implemented, there may be slight differences between
           the $build object in Build.PL and the one in "t/colortest.t".  It is our goal to minimize these
           differences in future releases of Module::Build, so please report any anomalies you find.

           One important caveat: in its current implementation, "current()" will <b>NOT</b> work correctly if you
           have changed out of the directory that "Module::Build" was invoked from.

       <u>new()</u>
           [version 0.03]

           Creates a new Module::Build object.  Arguments to the <u>new()</u> method are listed below.  Most
           arguments are optional, but you must provide either the "module_name" argument, or "dist_name"
           and one of "dist_version" or "dist_version_from".  In other words, you must provide enough
           information to determine both a distribution name and version.

           add_to_cleanup
               [version 0.19]

               An array reference of files to be cleaned up when the "clean" action is performed.  See also
               the <u>add</u><b>_</b><u>to</u><b>_</b><u>cleanup()</u> method.

           auto_features
               [version 0.26]

               This parameter supports the setting of features (see feature($name)) automatically based on a
               set of prerequisites.  For instance, for a module that could optionally use either MySQL or
               PostgreSQL databases, you might use "auto_features" like this:

                 my $build = Module::Build-&gt;new
                   (
                    ...other stuff here...
                    auto_features =&gt; {
                      pg_support    =&gt; {
                                        description =&gt; "Interface with Postgres databases",
                                        requires    =&gt; { 'DBD::Pg' =&gt; 23.3,
                                                         'DateTime::Format::Pg' =&gt; 0 },
                                       },
                      mysql_support =&gt; {
                                        description =&gt; "Interface with MySQL databases",
                                        requires    =&gt; { 'DBD::mysql' =&gt; 17.9,
                                                         'DateTime::Format::MySQL' =&gt; 0 },
                                       },
                    }
                   );

               For each feature named, the required prerequisites will be checked, and if there are no
               failures, the feature will be enabled (set to 1).  Otherwise the failures will be displayed
               to the user and the feature will be disabled (set to 0).

               See the documentation for requires for the details of how requirements can be specified.

           autosplit
               [version 0.04]

               An optional "autosplit" argument specifies a file which should be run through the
               "Autosplit::autosplit()" function.  If multiple files should be split, the argument may be
               given as an array of the files to split.

               In general I don't consider autosplitting a great idea, because it's not always clear that
               autosplitting achieves its intended performance benefits.  It may even harm performance in
               environments like mod_perl, where as much as possible of a module's code should be loaded
               during startup.

           build_class
               [version 0.28]

               The Module::Build class or subclass to use in the build script.  Defaults to "Module::Build"
               or the class name passed to or created by a call to "subclass()".  This property is useful if
               you're writing a custom Module::Build subclass and have a bootstrapping problem--that is,
               your subclass requires modules that may not be installed when "perl Build.PL" is executed,
               but you've listed in "build_requires" so that they should be available when "./Build" is
               executed.

           build_requires
               [version 0.07]

               Modules listed in this section are necessary to build and install the given module, but are
               not necessary for regular usage of it.  This is actually an important distinction - it allows
               for tighter control over the body of installed modules, and facilitates correct dependency
               checking on binary/packaged distributions of the module.

               See the documentation for "PREREQUISITES" in Module::Build::Authoring for the details of how
               requirements can be specified.

           create_packlist
               [version 0.28]

               If true, this parameter tells Module::Build to create a <u>.packlist</u> file during the "install"
               action, just like ExtUtils::MakeMaker does.  The file is created in a subdirectory of the
               "arch" installation location.  It is used by some other tools (CPAN, CPANPLUS, etc.) for
               determining what files are part of an install.

               The default value is true.  This parameter was introduced in Module::Build version 0.2609;
               previously no packlists were ever created by Module::Build.

           c_source
               [version 0.04]

               An optional "c_source" argument specifies a directory which contains C source files that the
               rest of the build may depend on.  Any ".c" files in the directory will be compiled to object
               files.  The directory will be added to the search path during the compilation and linking
               phases of any C or XS files.

           conflicts
               [version 0.07]

               Modules listed in this section conflict in some serious way with the given module.
               "Module::Build" (or some higher-level tool) will refuse to install the given module if the
               given module/version is also installed.

               See the documentation for "PREREQUISITES" in Module::Build::Authoring for the details of how
               requirements can be specified.

           create_makefile_pl
               [version 0.19]

               This parameter lets you use Module::Build::Compat during the "distdir" (or "dist") action to
               automatically create a Makefile.PL for compatibility with ExtUtils::MakeMaker.  The
               parameter's value should be one of the styles named in the Module::Build::Compat
               documentation.

           create_readme
               [version 0.22]

               This parameter tells Module::Build to automatically create a <u>README</u> file at the top level of
               your distribution.  Currently it will simply use "Pod::Text" (or "Pod::Readme" if it's
               installed) on the file indicated by "dist_version_from" and put the result in the <u>README</u>
               file.  This is by no means the only recommended style for writing a README, but it seems to
               be one common one used on the CPAN.

               If you generate a <u>README</u> in this way, it's probably a good idea to create a separate <u>INSTALL</u>
               file if that information isn't in the generated <u>README</u>.

           dist_abstract
               [version 0.20]

               This should be a short description of the distribution.  This is used when generating
               metadata for <u>META.yml</u> and PPD files.  If it is not given then "Module::Build" looks in the
               POD of the module from which it gets the distribution's version.  It looks for the first line
               matching "$package\s-\s(.+)", and uses the captured text as the abstract.

           dist_author
               [version 0.20]

               This should be something like "John Doe &lt;jdoe@example.com&gt;", or if there are multiple
               authors, an anonymous array of strings may be specified.  This is used when generating
               metadata for <u>META.yml</u> and PPD files.  If this is not specified, then "Module::Build" looks at
               the module from which it gets the distribution's version.  If it finds a POD section marked
               "=head1 AUTHOR", then it uses the contents of this section.

           dist_name
               [version 0.11]

               Specifies the name for this distribution.  Most authors won't need to set this directly, they
               can use "module_name" to set "dist_name" to a reasonable default.  However, some
               agglomerative distributions like "libwww-perl" or "bioperl" have names that don't correspond
               directly to a module name, so "dist_name" can be set independently.

           dist_version
               [version 0.11]

               Specifies a version number for the distribution.  See "module_name" or "dist_version_from"
               for ways to have this set automatically from a $VERSION variable in a module.  One way or
               another, a version number needs to be set.

           dist_version_from
               [version 0.11]

               Specifies a file to look for the distribution version in.  Most authors won't need to set
               this directly, they can use "module_name" to set it to a reasonable default.

               The version is extracted from the specified file according to the same rules as
               "ExtUtils::MakeMaker" and "CPAN.pm".  It involves finding the first line that matches the
               regular expression

                  /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/

               <u>eval()</u>-ing that line, then checking the value of the $VERSION variable.  Quite ugly, really,
               but all the modules on CPAN depend on this process, so there's no real opportunity to change
               to something better.

           dynamic_config
               [version 0.07]

               A boolean flag indicating whether the <u>Build.PL</u> file must be executed, or whether this module
               can be built, tested and installed solely from consulting its metadata file.  The main reason
               to set this to a true value is that your module performs some dynamic configuration as part
               of its build/install process.  If the flag is omitted, the <u>META.yml</u> spec says that
               installation tools should treat it as 1 (true), because this is a safer way to behave.

               Currently "Module::Build" doesn't actually do anything with this flag - it's up to higher-<font color="#ffffff" class="whiteout">level&nbsp;higherlevel</font>
               level tools like "CPAN.pm" to do something useful with it.  It can potentially bring lots of
               security, packaging, and convenience improvements.

           extra_compiler_flags
           extra_linker_flags
               [version 0.19]

               These parameters can contain array references (or strings, in which case they will be split
               into arrays) to pass through to the compiler and linker phases when compiling/linking C code.
               For example, to tell the compiler that your code is C++, you might do:

                 my $build = Module::Build-&gt;new
                   (
                    module_name          =&gt; 'Foo::Bar',
                    extra_compiler_flags =&gt; ['-x', 'c++'],
                   );

               To link your XS code against glib you might write something like:

                 my $build = Module::Build-&gt;new
                   (
                    module_name          =&gt; 'Foo::Bar',
                    dynamic_config       =&gt; 1,
                    extra_compiler_flags =&gt; scalar `glib-config --cflags`,
                    extra_linker_flags   =&gt; scalar `glib-config --libs`,
                   );

           get_options
               [version 0.26]

               You can pass arbitrary command line options to <u>Build.PL</u> or <u>Build</u>, and they will be stored in
               the Module::Build object and can be accessed via the "args()" method.  However, sometimes you
               want more flexibility out of your argument processing than this allows.  In such cases, use
               the "get_options" parameter to pass in a hash reference of argument specifications, and the
               list of arguments to <u>Build.PL</u> or <u>Build</u> will be processed according to those specifications
               before they're passed on to "Module::Build"'s own argument processing.

               The supported option specification hash keys are:

               type
                   The type of option.  The types are those supported by Getopt::Long; consult its
                   documentation for a complete list.  Typical types are "=s" for strings, "+" for additive
                   options, and "!" for negatable options.  If the type is not specified, it will be
                   considered a boolean, i.e. no argument is taken and a value of 1 will be assigned when
                   the option is encountered.

               store
                   A reference to a scalar in which to store the value passed to the option.  If not
                   specified, the value will be stored under the option name in the hash returned by the
                   "args()" method.

               default
                   A default value for the option.  If no default value is specified and no option is
                   passed, then the option key will not exist in the hash returned by "args()".

               You can combine references to your own variables or subroutines with unreferenced
               specifications, for which the result will also be stored in the hash returned by "args()".
               For example:

                 my $loud = 0;
                 my $build = Module::Build-&gt;new
                   (
                    module_name =&gt; 'Foo::Bar',
                    get_options =&gt; {
                                    loud =&gt;     { store =&gt; \$loud },
                                    dbd  =&gt;     { type  =&gt; '=s'   },
                                    quantity =&gt; { type  =&gt; '+'    },
                                   }
                   );

                 print STDERR "HEY, ARE YOU LISTENING??\n" if $loud;
                 print "We'll use the ", $build-&gt;args('dbd'), " DBI driver\n";
                 print "Are you sure you want that many?\n"
                   if $build-&gt;args('quantity') &gt; 2;

               The arguments for such a specification can be called like so:

                 perl Build.PL --loud --dbd=DBD::pg --quantity --quantity --quantity

               <b>WARNING:</b> Any option specifications that conflict with Module::Build's own options (defined by
               its properties) will throw an exception.

               Consult the Getopt::Long documentation for details on its usage.

           include_dirs
               [version 0.24]

               Specifies any additional directories in which to search for C header files.  May be given as
               a string indicating a single directory, or as a list reference indicating multiple
               directories.

           install_path
               [version 0.19]

               You can set paths for individual installable elements by using the "install_path" parameter:

                 my $build = Module::Build-&gt;new
                   (
                    ...other stuff here...
                    install_path =&gt; {
                                     lib  =&gt; '/foo/lib',
                                     arch =&gt; '/foo/lib/arch',
                                    }
                   );

           installdirs
               [version 0.19]

               Determines where files are installed within the normal perl hierarchy as determined by
               <u>Config.pm</u>.  Valid values are: "core", "site", "vendor".  The default is "site".  See "INSTALL
               PATHS" in Module::Build

           license
               [version 0.07]

               Specifies the licensing terms of your distribution.  Valid options include:

               apache
                   The distribution is licensed under the Apache Software License
                   (<a href="http://opensource.org/licenses/apachepl.php)">http://opensource.org/licenses/apachepl.php)</a>

               artistic
                   The distribution is licensed under the Artistic License, as specified by the <u>Artistic</u>
                   file in the standard perl distribution.

               bsd The distribution is licensed under the BSD License
                   (<a href="http://www.opensource.org/licenses/bsd-license.php)">http://www.opensource.org/licenses/bsd-license.php)</a>

               gpl The distribution is licensed under the terms of the Gnu General Public License
                   (<a href="http://www.opensource.org/licenses/gpl-license.php)">http://www.opensource.org/licenses/gpl-license.php)</a>

               lgpl
                   The distribution is licensed under the terms of the Gnu Lesser General Public License
                   (<a href="http://www.opensource.org/licenses/lgpl-license.php)">http://www.opensource.org/licenses/lgpl-license.php)</a>

               mit The distribution is licensed under the MIT License
                   (<a href="http://opensource.org/licenses/mit-license.php)">http://opensource.org/licenses/mit-license.php)</a>

               mozilla
                   The distribution is licensed under the Mozilla Public License.
                   (<a href="http://opensource.org/licenses/mozilla1.0.php">http://opensource.org/licenses/mozilla1.0.php</a> or
                   <a href="http://opensource.org/licenses/mozilla1.1.php)">http://opensource.org/licenses/mozilla1.1.php)</a>

               open_source
                   The distribution is licensed under some other Open Source Initiative-approved license
                   listed at <a href="http://www.opensource.org/licenses/">http://www.opensource.org/licenses/</a> .

               perl
                   The distribution may be copied and redistributed under the same terms as perl itself
                   (this is by far the most common licensing option for modules on CPAN).  This is a dual
                   license, in which the user may choose between either the GPL or the Artistic license.

               restrictive
                   The distribution may not be redistributed without special permission from the author
                   and/or copyright holder.

               unrestricted
                   The distribution is licensed under a license that is <b>not</b> approved by www.opensource.org
                   but that allows distribution without restrictions.

               Note that you must still include the terms of your license in your documentation - this field
               only lets automated tools figure out your licensing restrictions.  Humans still need
               something to read.  If you choose to provide this field, you should make sure that you keep
               it in sync with your written documentation if you ever change your licensing terms.

               It is a fatal error to use a license other than the ones mentioned above.  This is not
               because I wish to impose licensing terms on you - please let me know if you would like
               another license option to be added to the list.  You may also use a license type of "unknown"
               if you don't wish to specify your terms (but this is usually not a good idea for you to do!).

               I just started out with a small set of licenses to keep things simple, figuring I'd let
               people with actual working knowledge in this area tell me what to do.  So if that's you, drop
               me a line.

           meta_add
               [version 0.28]

               A hash of key/value pairs that should be added to the <u>META.yml</u> file during the "distmeta"
               action.  Any existing entries with the same names will be overridden.

           meta_merge
               [version 0.28]

               A hash of key/value pairs that should be merged into the <u>META.yml</u> file during the "distmeta"
               action.  Any existing entries with the same names will be overridden.

               The only difference between "meta_add" and "meta_merge" is their behavior on hash-valued and
               array-valued entries: "meta_add" will completely blow away the existing hash or array value,
               but "meta_merge" will merge the supplied data into the existing hash or array value.

           module_name
               [version 0.03]

               The "module_name" is a shortcut for setting default values of "dist_name" and
               "dist_version_from", reflecting the fact that the majority of CPAN distributions are centered
               around one "main" module.  For instance, if you set "module_name" to "Foo::Bar", then
               "dist_name" will default to "Foo-Bar" and "dist_version_from" will default to
               "lib/Foo/Bar.pm".  "dist_version_from" will in turn be used to set "dist_version".

               Setting "module_name" won't override a "dist_*" parameter you specify explicitly.

           PL_files
               [version 0.06]

               An optional parameter specifying a set of ".PL" files in your distribution.  These will be
               run as Perl scripts prior to processing the rest of the files in your distribution.  They are
               usually used as templates for creating other files dynamically, so that a file like
               "lib/Foo/Bar.pm.PL" might create the file "lib/Foo/Bar.pm".

               The files are specified with the ".PL" files as hash keys, and the <!-- a -->file(s)<!-- /a --> they generate as
               hash values, like so:

                 my $build = Module::Build-&gt;new
                   (
                    module_name =&gt; 'Foo::Bar',
                    ...
                    PL_files =&gt; { 'lib/Foo/Bar.pm.PL' =&gt; 'lib/Foo/Bar.pm' },
                   );

               Note that the path specifications are <u>always</u> given in Unix-like format, not in the style of
               the local system.

               If your ".PL" scripts don't create any files, or if they create files with unexpected names,
               or even if they create multiple files, you can indicate that so that Module::Build can
               properly handle these created files:

                 PL_files =&gt; {
                              'lib/Foo/Bar.pm.PL' =&gt; 'lib/Foo/Bar.pm',
                              'lib/something.PL'  =&gt; ['/lib/something', '/lib/else'],
                              'lib/funny.PL'      =&gt; [],
                             }

           pm_files
               [version 0.19]

               An optional parameter specifying the set of ".pm" files in this distribution, specified as a
               hash reference whose keys are the files' locations in the distributions, and whose values are
               their logical locations based on their package name, i.e. where they would be found in a
               "normal" Module::Build-style distribution.  This parameter is mainly intended to support
               alternative layouts of files.

               For instance, if you have an old-style MakeMaker distribution for a module called "Foo::Bar"
               and a <u>Bar.pm</u> file at the top level of the distribution, you could specify your layout in your
               "Build.PL" like this:

                 my $build = Module::Build-&gt;new
                   (
                    module_name =&gt; 'Foo::Bar',
                    ...
                    pm_files =&gt; { 'Bar.pm' =&gt; 'lib/Foo/Bar.pm' },
                   );

               Note that the values should include "lib/", because this is where they would be found in a
               "normal" Module::Build-style distribution.

               Note also that the path specifications are <u>always</u> given in Unix-like format, not in the style
               of the local system.

           pod_files
               [version 0.19]

               Just like "pm_files", but used for specifying the set of ".pod" files in your distribution.

           recommends
               [version 0.08]

               This is just like the "requires" argument, except that modules listed in this section aren't
               essential, just a good idea.  We'll just print a friendly warning if one of these modules
               aren't found, but we'll continue running.

               If a module is recommended but not required, all tests should still pass if the module isn't
               installed.  This may mean that some tests may be skipped if recommended dependencies aren't
               present.

               Automated tools like CPAN.pm should inform the user when recommended modules aren't
               installed, and it should offer to install them if it wants to be helpful.

               See the documentation for "PREREQUISITES" in Module::Build::Authoring for the details of how
               requirements can be specified.

           recursive_test_files
               [version 0.28]

               Normally, "Module::Build" does not search subdirectories when looking for tests to run. When
               this options is set it will search recursively in all subdirectories of the standard 't' test
               directory.

           requires
               [version 0.07]

               An optional "requires" argument specifies any module prerequisites that the current module
               depends on.

               One note: currently "Module::Build" doesn't actually <u>require</u> the user to have dependencies
               installed, it just strongly urges.  In the future we may require it.  There's also a
               "recommends" section for things that aren't absolutely required.

               Automated tools like CPAN.pm should refuse to install a module if one of its dependencies
               isn't satisfied, unless a "force" command is given by the user.  If the tools are helpful,
               they should also offer to install the dependencies.

               A synonym for "requires" is "prereq", to help succour people transitioning from
               "ExtUtils::MakeMaker".  The "requires" term is preferred, but the "prereq" term will remain
               valid in future distributions.

               See the documentation for "PREREQUISITES" in Module::Build::Authoring for the details of how
               requirements can be specified.

           script_files
               [version 0.18]

               An optional parameter specifying a set of files that should be installed as executable perl
               scripts when the module is installed.  May be given as an array reference of the files, or as
               a hash reference whose keys are the files (and whose values will currently be ignored).

               The default is to install no script files - in other words, there is no default location
               where Module::Build will look for script files to install.

               For backward compatibility, you may use the parameter "scripts" instead of "script_files".
               Please consider this usage deprecated, though it will continue to exist for several version
               releases.

           sign
               [version 0.16]

               If a true value is specified for this parameter, "Module::Signature" will be used (via the
               'distsign' action) to create a SIGNATURE file for your distribution during the 'distdir'
               action, and to add the SIGNATURE file to the MANIFEST (therefore, don't add it yourself).

               The default value is false.  In the future, the default may change to true if you have
               "Module::Signature" installed on your system.

           test_files
               [version 0.23]

               An optional parameter specifying a set of files that should be used as "Test::Harness"-style
               regression tests to be run during the "test" action.  May be given as an array reference of
               the files, or as a hash reference whose keys are the files (and whose values will currently
               be ignored).  If the argument is given as a single string (not in an array reference), that
               string will be treated as a "glob()" pattern specifying the files to use.

               The default is to look for a <u>test.pl</u> script in the top-level directory of the distribution,
               and any files matching the glob pattern "*.t" in the <u>t/</u> subdirectory.  If the
               "recursive_test_files" property is true, then the "t/" directory will be scanned recursively
               for "*.t" files.

           xs_files
               [version 0.19]

               Just like "pm_files", but used for specifying the set of ".xs" files in your distribution.

       new_from_context(%args)
           [version 0.28]

           When called from a directory containing a <u>Build.PL</u> script and a <u>META.yml</u> file (in other words,
           the base directory of a distribution), this method will run the <u>Build.PL</u> and return the resulting
           "Module::Build" object to the caller.  Any key-value arguments given to "new_from_context()" are
           essentially like command line arguments given to the <u>Build.PL</u> script, so for example you could
           pass "verbose =&gt; 1" to this method to turn on verbosity.

       <u>resume()</u>
           [version 0.03]

           You'll probably never call this method directly, it's only called from the auto-generated "Build"
           script.  The "new()" method is only called once, when the user runs "perl Build.PL".  Thereafter,
           when the user runs "Build test" or another action, the "Module::Build" object is created using
           the "resume()" method to re-instantiate with the settings given earlier to "new()".

       <u>subclass()</u>
           [version 0.06]

           This creates a new "Module::Build" subclass on the fly, as described in the "SUBCLASSING" in
           Module::Build::Authoring section.  The caller must provide either a "class" or "code" parameter,
           or both.  The "class" parameter indicates the name to use for the new subclass, and defaults to
           "MyModuleBuilder".  The "code" parameter specifies Perl code to use as the body of the subclass.

       <b>METHODS</b>


       add_build_element($type)
           [version 0.26]

           Adds a new type of entry to the build process.  Accepts a single string specifying its type-name.
           There must also be a method defined to process things of that type, e.g. if you add a build
           element called 'foo', then you must also define a method called "process_foo_files()".

           See also "Adding new file types to the build process" in Module::Build::Cookbook.

       add_to_cleanup(@files)
           [version 0.03]

           You may call "$self-&gt;add_to_cleanup(@patterns)" to tell "Module::Build" that certain files should
           be removed when the user performs the "Build clean" action.  The arguments to the method are
           patterns suitable for passing to Perl's "glob()" function, specified in either Unix format or the
           current machine's native format.  It's usually convenient to use Unix format when you hard-code
           the filenames (e.g. in <u>Build.PL</u>) and the native format when the names are programmatically
           generated (e.g. in a testing script).

           I decided to provide a dynamic method of the $build object, rather than just use a static list of
           files named in the <u>Build.PL</u>, because these static lists can get difficult to manage.  I usually
           prefer to keep the responsibility for registering temporary files close to the code that creates
           them.

       <u>args()</u>
           [version 0.26]

             my $args_href = $build-&gt;args;
             my %args = $build-&gt;args;
             my $arg_value = $build-&gt;args($key);
             $build-&gt;args($key, $value);

           This method is the preferred interface for retrieving the arguments passed via command line
           options to <u>Build.PL</u> or <u>Build</u>, minus the Module-Build specific options.

           When called in in a scalar context with no arguments, this method returns a reference to the hash
           storing all of the arguments; in an array context, it returns the hash itself.  When passed a
           single argument, it returns the value stored in the args hash for that option key.  When called
           with two arguments, the second argument is assigned to the args hash under the key passed as the
           first argument.

       autosplit_file($from, $to)
           [version 0.28]

           Invokes the "AutoSplit" module on the $from file, sending the output to the "lib/auto" directory
           inside $to.  $to is typically the "blib/" directory.

       <u>base</u><b>_</b><u>dir()</u>
           [version 0.14]

           Returns a string containing the root-level directory of this build, i.e. where the "Build.PL"
           script and the "lib" directory can be found.  This is usually the same as the current working
           directory, because the "Build" script will "chdir()" into this directory as soon as it begins
           execution.

       <u>build</u><b>_</b><u>requires()</u>
           [version 0.21]

           Returns a hash reference indicating the "build_requires" prerequisites that were passed to the
           "new()" method.

       check_installed_status($module, $version)
           [version 0.11]

           This method returns a hash reference indicating whether a version dependency on a certain module
           is satisfied.  The $module argument is given as a string like "Data::Dumper" or "perl", and the
           $version argument can take any of the forms described in requires above.  This allows very fine-
           grained version checking.

           The returned hash reference has the following structure:

             {
              ok =&gt; $whether_the_dependency_is_satisfied,
              have =&gt; $version_already_installed,
              need =&gt; $version_requested, # Same as incoming $version argument
              message =&gt; $informative_error_message,
             }

           If no version of $module is currently installed, the "have" value will be the string "&lt;none&gt;".
           Otherwise the "have" value will simply be the version of the installed module.  Note that this
           means that if $module is installed but doesn't define a version number, the "have" value will be
           "undef" - this is why we don't use "undef" for the case when $module isn't installed at all.

           This method may be called either as an object method ("$build-&gt;check_installed_status($module,
           $version)") or as a class method ("Module::Build-&gt;check_installed_status($module, $version)").

       check_installed_version($module, $version)
           [version 0.05]

           Like "check_installed_status()", but simply returns true or false depending on whether module
           $module satisfies the dependency $version.

           If the check succeeds, the return value is the actual version of $module installed on the system.
           This allows you to do the following:

             my $installed = $build-&gt;check_installed_version('DBI', '1.15');
             if ($installed) {
               print "Congratulations, version $installed of DBI is installed.\n";
             } else {
               die "Sorry, you must install DBI.\n";
             }

           If the check fails, we return false and set $@ to an informative error message.

           If $version is any non-true value (notably zero) and any version of $module is installed, we
           return true.  In this case, if $module doesn't define a version, or if its version is zero, we
           return the special value "0 but true", which is numerically zero, but logically true.

           In general you might prefer to use "check_installed_status" if you need detailed information, or
           this method if you just need a yes/no answer.

       compare_versions($v1, $op, $v2)
           [version 0.28]

           Compares two module versions $v1 and $v2 using the operator $op, which should be one of Perl's
           numeric operators like "!=" or "&gt;=" or the like.  We do at least a halfway-decent job of handling
           versions that aren't strictly numeric, like "0.27_02", but exotic stuff will likely cause
           problems.

           In the future, the guts of this method might be replaced with a call out to "version.pm".

       config($key)
       config($key, $value)
       <u>config()</u> [deprecated]
           [version 0.22]

           With a single argument $key, returns the value associated with that key in the "Config.pm" hash,
           including any changes the author or user has specified.

           With $key and $value arguments, sets the value for future callers of "config($key)".

           With no arguments, returns a hash reference containing all such key-value pairs.  This usage is
           deprecated, though, because it's a resource hog and violates encapsulation.

       config_data($name)
       config_data($name =&gt; $value)
           [version 0.26]

           With a single argument, returns the value of the configuration variable $name.  With two
           arguments, sets the given configuration variable to the given value.  The value may be any perl
           scalar that's serializable with "Data::Dumper".  For instance, if you write a module that can use
           a MySQL or PostgreSQL back-end, you might create configuration variables called "mysql_connect"
           and "postgres_connect", and set each to an array of connection parameters for "DBI-&gt;connect()".

           Configuration values set in this way using the Module::Build object will be available for
           querying during the build/test process and after installation via the generated "...::ConfigData"
           module, as "...::ConfigData-&gt;config($name)".

           The "feature()" and "config_data()" methods represent Module::Build's main support for
           configuration of installed modules.  See also "SAVING CONFIGURATION INFORMATION" in
           Module::Build::Authoring.

       <u>conflicts()</u>
           [version 0.21]

           Returns a hash reference indicating the "conflicts" prerequisites that were passed to the "new()"
           method.

       contains_pod($file)
           [version 0.20]

           [Deprecated] Please see Module::Build::ModuleInfo instead.

           Returns true if the given file appears to contain POD documentation.  Currently this checks
           whether the file has a line beginning with '=pod', '=head', or '=item', but the exact semantics
           may change in the future.

       copy_if_modified(%parameters)
           [version 0.19]

           Takes the file in the "from" parameter and copies it to the file in the "to" parameter, or the
           directory in the "to_dir" parameter, if the file has changed since it was last copied (or if it
           doesn't exist in the new location).  By default the entire directory structure of "from" will be
           copied into "to_dir"; an optional "flatten" parameter will copy into "to_dir" without doing so.

           Returns the path to the destination file, or "undef" if nothing needed to be copied.

           Any directories that need to be created in order to perform the copying will be automatically
           created.

           The destination file is set to read-only. If the source file has the executable bit set, then the
           destination file will be made executable.

       <u>create</u><b>_</b><u>build</u><b>_</b><u>script()</u>
           [version 0.05]

           Creates an executable script called "Build" in the current directory that will be used to execute
           further user actions.  This script is roughly analogous (in function, not in form) to the
           Makefile created by "ExtUtils::MakeMaker".  This method also creates some temporary data in a
           directory called "_build/".  Both of these will be removed when the "realclean" action is
           performed.

       <u>current</u><b>_</b><u>action()</u>
           [version 0.28]

           Returns the name of the currently-running action, such as "build" or "test".  This action is not
           necessarily the action that was originally invoked by the user.  For example, if the user invoked
           the "test" action, <u>current</u><b>_</b><u>action()</u> would initially return "test".  However, action "test"
           depends on action "code", so <u>current</u><b>_</b><u>action()</u> will return "code" while that dependency is being
           executed.  Once that action has completed, <u>current</u><b>_</b><u>action()</u> will again return "test".

           If you need to know the name of the original action invoked by the user, see <u>invoked</u><b>_</b><u>action()</u>
           below.

       depends_on(@actions)
           [version 0.28]

           Invokes the named action or list of actions in sequence.  Using this method is preferred to
           calling the action explicitly because it performs some internal record-keeping, and it ensures
           that the same action is not invoked multiple times (note: in future versions of Module::Build
           it's conceivable that this run-only-once mechanism will be changed to something more
           intelligent).

           Note that the name of this method is something of a misnomer; it should really be called
           something like "invoke_actions_unless_already_invoked()" or something, but for better or worse
           (perhaps better!) we were still thinking in "make"-like dependency terms when we created this
           method.

           See also "dispatch()".  The main distinction between the two is that "depends_on()" is meant to
           call an action from inside another action, whereas "dispatch()" is meant to set the very top
           action in motion.

       dir_contains($first_dir, $second_dir)
           [version 0.28]

           Returns true if the first directory logically contains the second directory.  This is just a
           convenience function because "File::Spec" doesn't really provide an easy way to figure this out
           (but "Path::Class" does...).

       dispatch($action, %args)
           [version 0.03]

           Invokes the build action $action.  Optionally, a list of options and their values can be passed
           in.  This is equivalent to invoking an action at the command line, passing in a list of options.

           Custom options that have not been registered must be passed in as a hash reference in a key named
           "args":

             $build-&gt;dispatch('foo', verbose =&gt; 1, args =&gt; { my_option =&gt; 'value' });

           This method is intended to be used to programmatically invoke build actions, e.g. by applications
           controlling Module::Build-based builds rather than by subclasses.

           See also "depends_on()".  The main distinction between the two is that "depends_on()" is meant to
           call an action from inside another action, whereas "dispatch()" is meant to set the very top
           action in motion.

       <u>dist</u><b>_</b><u>dir()</u>
           [version 0.28]

           Returns the name of the directory that will be created during the "dist" action.  The name is
           derived from the "dist_name" and "dist_version" properties.

       <u>dist</u><b>_</b><u>name()</u>
           [version 0.21]

           Returns the name of the current distribution, as passed to the "new()" method in a "dist_name" or
           modified "module_name" parameter.

       <u>dist</u><b>_</b><u>version()</u>
           [version 0.21]

           Returns the version of the current distribution, as determined by the "new()" method from a
           "dist_version", "dist_version_from", or "module_name" parameter.

       do_system($cmd, @args)
           [version 0.21]

           This is a fairly simple wrapper around Perl's "system()" built-in command.  Given a command and
           an array of optional arguments, this method will print the command to "STDOUT", and then execute
           it using Perl's "system()".  It returns true or false to indicate success or failure (the
           opposite of how "system()" works, but more intuitive).

           Note that if you supply a single argument to "do_system()", it will/may be processed by the
           systems's shell, and any special characters will do their special things.  If you supply multiple
           arguments, no shell will get involved and the command will be executed directly.

       feature($name)
       feature($name =&gt; $value)
           [version 0.26]

           With a single argument, returns true if the given feature is set.  With two arguments, sets the
           given feature to the given boolean value.  In this context, a "feature" is any optional
           functionality of an installed module.  For instance, if you write a module that could optionally
           support a MySQL or PostgreSQL backend, you might create features called "mysql_support" and
           "postgres_support", and set them to true/false depending on whether the user has the proper
           databases installed and configured.

           Features set in this way using the Module::Build object will be available for querying during the
           build/test process and after installation via the generated "...::ConfigData" module, as
           "...::ConfigData-&gt;feature($name)".

           The "feature()" and "config_data()" methods represent Module::Build's main support for
           configuration of installed modules.  See also "SAVING CONFIGURATION INFORMATION" in
           Module::Build::Authoring.

       <u>have</u><b>_</b><u>c</u><b>_</b><u>compiler()</u>
           [version 0.21]

           Returns true if the current system seems to have a working C compiler.  We currently determine
           this by attempting to compile a simple C source file and reporting whether the attempt was
           successful.

       <u>install</u><b>_</b><u>base</u><b>_</b><u>relpaths()</u>
       install_base_relpaths($type)
       install_base_relpaths($type =&gt; $path)
           [version 0.28]

           Set or retrieve the relative paths that are appended to "install_base" for any installable
           element. This is useful if you want to set the relative install path for custom build elements.

           With no argument, it returns a reference to a hash containing all elements and their respective
           values. This hash should not be modified directly; use the multi-argument below form to change
           values.

           The single argument form returns the value associated with the element $type.

           The multi-argument form allows you to set the paths for element types.  $value must be a relative
           path using unix-like paths.  (A series of directories seperated by slashes.  Eg 'foo/bar'.)  The
           return value is a localized path based on $value.

           Assigning the value "undef" to an element causes it to be removed.

       install_destination($type)
           [version 0.28]

           Returns the directory in which items of type $type (e.g. "lib", "arch", "bin", or anything else
           returned by the "install_types()" method) will be installed during the "install" action.  Any
           settings for "install_path", "install_base", and "prefix" are taken into account when determining
           the return value.

       <u>install</u><b>_</b><u>path()</u>
       install_path($type)
       install_path($type =&gt; $path)
           [version 0.28]

           Set or retrieve paths for specific installable elements. This is useful when you want to examine
           any explicit install paths specified by the user on the command line, or if you want to set the
           install path for a specific installable element based on another attribute like "install_base()".

           With no argument, it returns a reference to a hash containing all elements and their respective
           values. This hash should not be modified directly; use the multi-argument below form to change
           values.

           The single argument form returns the value associated with the element $type.

           The multi-argument form allows you to set the paths for element types.  The supplied $path should
           be an absolute path to install elements of $type.  The return value is $path.

           Assigning the value "undef" to an element causes it to be removed.

       <u>install</u><b>_</b><u>types()</u>
           [version 0.28]

           Returns a list of installable types that this build knows about.  These types each correspond to
           the name of a directory in <u>blib/</u>, and the list usually includes items such as "lib", "arch",
           "bin", "script", "libdoc", "bindoc", and if HTML documentation is to be built, "libhtml" and
           "binhtml".  Other user-defined types may also exist.

       <u>invoked</u><b>_</b><u>action()</u>
           [version 0.28]

           This is the name of the original action invoked by the user.  This value is set when the user
           invokes <u>Build.PL</u>, the <u>Build</u> script, or programatically through the <u>dispatch()</u> method.  It does
           not change as sub-actions are executed as dependencies are evaluated.

           To get the name of the currently executing dependency, see <u>current</u><b>_</b><u>action()</u> above.

       <u>notes()</u>
       notes($key)
       notes($key =&gt; $value)
           [version 0.20]

           The "notes()" value allows you to store your own persistent information about the build, and to
           share that information among different entities involved in the build.  See the example in the
           "current()" method.

           The "notes()" method is essentally a glorified hash access.  With no arguments, "notes()" returns
           the entire hash of notes.  With one argument, "notes($key)" returns the value associated with the
           given key.  With two arguments, "notes($key, $value)" sets the value associated with the given
           key to $value and returns the new value.

           The lifetime of the "notes" data is for "a build" - that is, the "notes" hash is created when
           "perl Build.PL" is run (or when the "new()" method is run, if the Module::Build Perl API is being
           used instead of called from a shell), and lasts until "perl Build.PL" is run again or the "clean"
           action is run.

       <u>orig</u><b>_</b><u>dir()</u>
           [version 0.28]

           Returns a string containing the working directory that was in effect before the <u>Build</u> script
           <u>chdir()</u>-ed into the "base_dir".  This might be useful for writing wrapper tools that might need
           to <u>chdir()</u> back out.

       <u>os</u><b>_</b><u>type()</u>
           [version 0.04]

           If you're subclassing Module::Build and some code needs to alter its behavior based on the
           current platform, you may only need to know whether you're running on Windows, Unix, MacOS, VMS,
           etc., and not the fine-grained value of Perl's $^O variable.  The "os_type()" method will return
           a string like "Windows", "Unix", "MacOS", "VMS", or whatever is appropriate.  If you're running
           on an unknown platform, it will return "undef" - there shouldn't be many unknown platforms
           though.

       <u>prefix</u><b>_</b><u>relpaths()</u>
       prefix_relpaths($installdirs)
       prefix_relpaths($installdirs, $type)
       prefix_relpaths($installdirs, $type =&gt; $path)
           [version 0.28]

           Set or retrieve the relative paths that are appended to "prefix" for any installable element.
           This is useful if you want to set the relative install path for custom build elements.

           With no argument, it returns a reference to a hash containing all elements and their respective
           values as defined by the current "installdirs" setting.

           With a single argument, it returns a reference to a hash containing all elements and their
           respective values as defined by $installdirs.

           The hash returned by the above calls should not be modified directly; use the three-argument
           below form to change values.

           The two argument form returns the value associated with the element $type.

           The multi-argument form allows you to set the paths for element types.  $value must be a relative
           path using unix-like paths.  (A series of directories seperated by slashes.  Eg 'foo/bar'.)  The
           return value is a localized path based on $value.

           Assigning the value "undef" to an element causes it to be removed.

       <u>prepare</u><b>_</b><u>metadata()</u>
           [version 0.28]

           This method is provided for authors to override to customize the fields of <u>META.yml</u>.  It is
           passed a YAML::Node node object which can be modified as desired and then returned.  E.g.

             package My::Builder;
             use base 'Module::Build';

             sub prepare_metadata {
               my $self = shift;
               my $node = $self-&gt;SUPER::prepare_metadata( shift );
               $node-&gt;{custom_field} = 'foo';
               return $node;
             }

       <u>prereq</u><b>_</b><u>failures()</u>
           [version 0.11]

           Returns a data structure containing information about any failed prerequisites (of any of the
           types described above), or "undef" if all prerequisites are met.

           The data structure returned is a hash reference.  The top level keys are the type of prerequisite
           failed, one of "requires", "build_requires", "conflicts", or "recommends".  The associated values
           are hash references whose keys are the names of required (or conflicting) modules.  The
           associated values of those are hash references indicating some information about the failure.
           For example:

             {
              have =&gt; '0.42',
              need =&gt; '0.59',
              message =&gt; 'Version 0.42 is installed, but we need version 0.59',
             }

           or

             {
              have =&gt; '&lt;none&gt;',
              need =&gt; '0.59',
              message =&gt; 'Prerequisite Foo isn't installed',
             }

           This hash has the same structure as the hash returned by the "check_installed_status()" method,
           except that in the case of "conflicts" dependencies we change the "need" key to "conflicts" and
           construct a proper message.

           Examples:

             # Check a required dependency on Foo::Bar
             if ( $build-&gt;prereq_failures-&gt;{requires}{Foo::Bar} ) { ...

             # Check whether there were any failures
             if ( $build-&gt;prereq_failures ) { ...

             # Show messages for all failures
             my $failures = $build-&gt;prereq_failures;
             while (my ($type, $list) = each %$failures) {
               while (my ($name, $hash) = each %$list) {
                 print "Failure for $name: $hash-&gt;{message}\n";
               }
             }

       <u>prereq</u><b>_</b><u>report()</u>
           [version 0.28]

           Returns a human-readable (table-form) string showing all prerequisites, the versions required,
           and the versions actually installed.  This can be useful for reviewing the configuration of your
           system prior to a build, or when compiling data to send for a bug report.  The "prereq_report"
           action is just a thin wrapper around the "prereq_report()" method.

       prompt($message, $default)
           [version 0.12]

           Asks the user a question and returns their response as a string.  The first argument specifies
           the message to display to the user (for example, "Where do you keep your money?").  The second
           argument, which is optional, specifies a default answer (for example, "wallet").  The user will
           be asked the question once.

           If "prompt()" detects that it is not running interactively and there is nothing on STDIN or if
           the PERL_MM_USE_DEFAULT environment variable is set to true, the $default will be used without
           prompting.  This prevents automated processes from blocking on user input.

           If no $default is provided an empty string will be used instead.

           This method may be called as a class or object method.

       <u>recommends()</u>
           [version 0.21]

           Returns a hash reference indicating the "recommends" prerequisites that were passed to the
           "new()" method.

       <u>requires()</u>
           [version 0.21]

           Returns a hash reference indicating the "requires" prerequisites that were passed to the "new()"
           method.

       rscan_dir($dir, $pattern)
           [version 0.28]

           Uses "File::Find" to traverse the directory $dir, returning a reference to an array of entries
           matching $pattern.  $pattern may either be a regular expression (using "qr//" or just a plain
           string), or a reference to a subroutine that will return true for wanted entries.  If $pattern is
           not given, all entries will be returned.

           Examples:

            # All the *.pm files in lib/
            $m-&gt;rscan_dir('lib', qr/\.pm$/)

            # All the files in blib/ that aren't *.html files
            $m-&gt;rscan_dir('blib', sub {-f $_ and not /\.html$/});

            # All the files in t/
            $m-&gt;rscan_dir('t');

       <u>runtime</u><b>_</b><u>params()</u>
       runtime_params($key)
           [version 0.28]

           The "runtime_params()" method stores the values passed on the command line for valid properties
           (that is, any command line options for which "valid_property()" returns a true value).  The value
           on the command line may override the default value for a property, as well as any value specified
           in a call to "new()".  This allows you to programmatically tell if "perl Build.PL" or any
           execution of "./Build" had command line options specified that override valid properties.

           The "runtime_params()" method is essentally a glorified read-only hash.  With no arguments,
           "runtime_params()" returns the entire hash of properties specified on the command line.  With one
           argument, "runtime_params($key)" returns the value associated with the given key.

           The lifetime of the "runtime_params" data is for "a build" - that is, the "runtime_params" hash
           is created when "perl Build.PL" is run (or when the "new()" method is called, if the
           Module::Build Perl API is being used instead of called from a shell), and lasts until "perl
           Build.PL" is run again or the "clean" action is run.

       <u>script</u><b>_</b><u>files()</u>
           [version 0.18]

           Returns a hash reference whose keys are the perl script files to be installed, if any.  This
           corresponds to the "script_files" parameter to the "new()" method.  With an optional argument,
           this parameter may be set dynamically.

           For backward compatibility, the "scripts()" method does exactly the same thing as
           "script_files()".  "scripts()" is deprecated, but it will stay around for several versions to
           give people time to transition.

       up_to_date($source_file, $derived_file)
       up_to_date(\@source_files, \@derived_files)
           [version 0.20]

           This method can be used to compare a set of source files to a set of derived files.  If any of
           the source files are newer than any of the derived files, it returns false.  Additionally, if any
           of the derived files do not exist, it returns false.  Otherwise it returns true.

           The arguments may be either a scalar or an array reference of file names.

       y_n($message, $default)
           [version 0.12]

           Asks the user a yes/no question using "prompt()" and returns true or false accordingly.  The user
           will be asked the question repeatedly until they give an answer that looks like "yes" or "no".

           The first argument specifies the message to display to the user (for example, "Shall I invest
           your money for you?"), and the second argument specifies the default answer (for example, "y").

           Note that the default is specified as a string like "y" or "n", and the return value is a Perl
           boolean value like 1 or 0.  I thought about this for a while and this seemed like the most useful
           way to do it.

           This method may be called as a class or object method.

       <b>Autogenerated</b> <b>Accessors</b>

       In addition to the aforementioned methods, there are also some get/set accessor methods for the
       following properties:

       <u>PL</u><b>_</b><u>files()</u>
       <u>allow</u><b>_</b><u>mb</u><b>_</b><u>mismatch()</u>
       <u>autosplit()</u>
       <u>base</u><b>_</b><u>dir()</u>
       <u>bindoc</u><b>_</b><u>dirs()</u>
       <u>blib()</u>
       <u>build</u><b>_</b><u>bat()</u>
       <u>build</u><b>_</b><u>class()</u>
       <u>build</u><b>_</b><u>elements()</u>
       <u>build</u><b>_</b><u>requires()</u>
       <u>build</u><b>_</b><u>script()</u>
       <u>c</u><b>_</b><u>source()</u>
       <u>config</u><b>_</b><u>dir()</u>
       <u>conflicts()</u>
       <u>create</u><b>_</b><u>makefile</u><b>_</b><u>pl()</u>
       <u>create</u><b>_</b><u>packlist()</u>
       <u>create</u><b>_</b><u>readme()</u>
       <u>debugger()</u>
       <u>destdir()</u>
       <u>get</u><b>_</b><u>options()</u>
       <u>html</u><b>_</b><u>css()</u>
       <u>include</u><b>_</b><u>dirs()</u>
       <u>install</u><b>_</b><u>base()</u>
       <u>install</u><b>_</b><u>sets()</u>
       <u>installdirs()</u>
       <u>libdoc</u><b>_</b><u>dirs()</u>
       <u>license()</u>
       <u>magic</u><b>_</b><u>number()</u>
       <u>mb</u><b>_</b><u>version()</u>
       <u>meta</u><b>_</b><u>add()</u>
       <u>meta</u><b>_</b><u>merge()</u>
       <u>metafile()</u>
       <u>module</u><b>_</b><u>name()</u>
       <u>orig</u><b>_</b><u>dir()</u>
       <u>original</u><b>_</b><u>prefix()</u>
       <u>perl()</u>
       <u>pm</u><b>_</b><u>files()</u>
       <u>pod</u><b>_</b><u>files()</u>
       <u>pollute()</u>
       <u>prefix()</u>
       <u>prereq</u><b>_</b><u>action</u><b>_</b><u>types()</u>
       <u>quiet()</u>
       <u>recommends()</u>
       <u>recurse</u><b>_</b><u>into()</u>
       <u>recursive</u><b>_</b><u>test</u><b>_</b><u>files()</u>
       <u>requires()</u>
       <u>scripts()</u>
       <u>use</u><b>_</b><u>rcfile()</u>
       <u>verbose()</u>
       <u>xs</u><b>_</b><u>files()</u>

<b>AUTHOR</b>
       Ken Williams &lt;kwilliams@cpan.org&gt;

<b>COPYRIGHT</b>
       Copyright (c) 2001-2006 Ken Williams.  All rights reserved.

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

<b>SEE</b> <b>ALSO</b>
       <a href="../man1/perl.1.html#//apple_ref/doc/man/1/perl"><u>perl</u>(1)</a>, <a href="Module__Build.3pm.html#//apple_ref/doc/man/3/Module::Build">Module::Build(3)</a>, <a href="Module__Build__Authoring.3pm.html#//apple_ref/doc/man/3/Module::Build::Authoring">Module::Build::Authoring(3)</a>, <a href="Module__Build__Cookbook.3pm.html#//apple_ref/doc/man/3/Module::Build::Cookbook">Module::Build::Cookbook(3)</a>,
       <a href="ExtUtils__MakeMaker.3pm.html#//apple_ref/doc/man/3/ExtUtils::MakeMaker">ExtUtils::MakeMaker(3)</a>, <!-- a -->YAML(3)<!-- /a -->

       <u>META.yml</u> Specification: &lt;<a href="http://module-build.sourceforge.net/META-spec-current.html">http://module-build.sourceforge.net/META-spec-current.html</a>



perl v5.8.8                                      2007-09-23                            Module::Build::API(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Module__Build__API.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Module__Build__API.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Module__Build__API.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
