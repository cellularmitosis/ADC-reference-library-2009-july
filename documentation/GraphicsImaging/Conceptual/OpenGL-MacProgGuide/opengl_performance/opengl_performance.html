<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>OpenGL Programming Guide for Mac OS X: Improving Performance</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Improving Performance"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001987-CH213" title="Improving Performance"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../OpenGL-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000549" target="_top">OpenGL</a> &gt; <a href="../opengl_intro/opengl_intro.html#//apple_ref/doc/uid/TP40001987-CH207-TP9">OpenGL Programming Guide for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_threading/opengl_threading.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_api_versions/opengl_api_versions.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001987-CH213-SW1" title="Improving Performance"></a><h1>Improving Performance</h1><p>OpenGL performs many complex operations—transformations, lighting, clipping, texturing, environmental effects, and so on—on large data sets. The amount of data and the number of operations can impact performance, making your stellar 3D graphics shine less brightly than you'd like. Unless, of course, you take steps to streamline your application.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH213-SW25" title="Figure 12-1OpenGL performs complex operations as data flows through a program"></a><p><strong>Figure 12-1&nbsp;&nbsp;</strong>OpenGL performs complex operations as data flows through a program</p><img src = "../art/application_pipeline.jpg" alt = "OpenGL performs complex operations as data flows through a program" ></div><br/><p>Techniques for improving data throughput and increasing program efficiency are discussed throughout this book. This chapter provides additional performance guidelines and discusses some of the tools that you can use to analyze your application. </p><ul class="ul"><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW12">“Best Practices”</a></span> summarizes coding tips that can help achieve optimal performance and provides links to other sections, either in this chapter or elsewhere in the book, where you can read more details.</p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW14">“Gathering and Analyzing Baseline Performance Data”</a></span> shows how to use <code>top</code> and OpenGL Profiler to obtain and interpret baseline performance data.</p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW20">“Identifying Bottlenecks with Shark”</a></span> discusses the patterns of usage that the Shark performance tool can make apparent and that indicate places in your code that you may want to improve.</p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH213-SW12" title="Best Practices"></a><h2>Best Practices</h2><p>Each of the following sections provides information that can help your application perform optimally:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW2">“Use Flush and Finish Routines Effectively.”</a></span></p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW11">“Be Mindful of OpenGL State Variables.”</a></span></p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW3">“Draw Only When Necessary.”</a></span></p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW4">“Synchronize with the Screen Refresh Rate.”</a></span></p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW7">“Use OpenGL Macros.”</a></span></p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW13">“Use the CPU and the GPU Asynchronously.”</a></span></p></li><li class="li"><p>Adopt <span class="content_text"><a href="../opengl_vertexdata/opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW3">“Techniques for Working with Vertex Data”</a></span> and <span class="content_text"><a href="../opengl_texturedata/opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW1">“Techniques for Working with Texture Data”</a></span> to optimize data throughput and decrease memory footprint.</p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW19">“Use Appropriate Routines for Images and Pixel Data.”</a></span></p></li><li class="li"><p>Use threading appropriately. See <span class="content_text"><a href="../opengl_threading/opengl_threading.html#//apple_ref/doc/uid/TP40001987-CH409-SW1">“Multithreading and OpenGL.”</a></span></p></li><li class="li"><p>Use performance tools to assess your application and identify areas that can be optimized. See <span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW14">“Gathering and Analyzing Baseline Performance Data”</a></span> and <span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW20">“Identifying Bottlenecks with Shark.”</a></span></p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW21">“Retrieve Error Information Only When Debugging.”</a></span></p></li><li class="li"><p><span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW23">“Use Optimal Data Types and Formats”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH213-SW2" title="Use Flush and Finish Routines Effectively"></a><h3>Use Flush and Finish Routines Effectively</h3><p>OpenGL commands are not executed immediately. They are queued to a command buffer and then read and executed by the hardware. The command buffer is used for vertices, normals, texture coordinates, and so forth, but not for textures themselves, which are stored elsewhere. </p><p>These functions  force OpenGL to submit the command buffer to the hardware for execution.</p><ul class="spaceabove"><li class="li"><p>The function <code><!--a-->glFlush<!--/a--></code> waits until commands are submitted but does not wait for the commands to finish executing.</p></li><li class="li"><p>The function <code>glFinish</code>  waits for the submitted commands to complete executing.</p></li></ul><p>For double-buffered contexts, the current OpenGL command buffer is not sent to the graphics processor until <code><!--a-->glFlush<!--/a--></code> or <code><!--a-->glFinish<!--/a--></code> is called, a buffer swap is requested, or the command buffer is full. This also applies to single-buffered contexts, although executing a buffer swap is really just an implicit call to <code><!--a-->glFlush<!--/a--></code>  to submit the queued commands to the renderer. This means that, for single-buffered contexts,  <code><!--a-->glFlush<!--/a--></code> and <code><!--a-->glFinish<!--/a--></code> are equivalent to a swap operation, since all rendering is taking place directly in the front buffer. </p><p>There are only a few cases that require you to call the  <code><!--a-->glFlush<!--/a--></code> function:</p><ul class="spaceabove"><li class="li"><p>Multithreaded applications. To keep drawing synchronized across the threads and prevent command buffer corruption, as each thread completes its command submissions, it should  call <code><!--a-->glFlush<!--/a--></code>. </p></li><li class="li"><p>A drawable object that changes during rendering. Before you can switch from one drawable object to another, you must call <code><!--a-->glFlush<!--/a--></code> to ensure that all commands written in the command queue for the previous drawable object have been submitted.</p></li><li class="li"><p>Whenever a drawable surface in modified by one context and then used in another context, you must call <code>glFlush</code>  to ensure the data is serialized to the video card before you attempt to draw with it on the second context.  Conversely, if you have drawn with surface that is about to get modified you should flush the context that draws the surface before the second context attempts to modify it. This applies to framebuffer objects as well as to pixel buffer objects. </p></li></ul><p>When used incorrectly,  <code><!--a-->glFlush<!--/a--></code> or <code><!--a-->glFinish<!--/a--></code> can cause your application to stall or slow down, using a higher percentage of the CPU than is necessary. You might also see visual anomalies, such as flickering or tearing. Most of the time you don't need to call <code><!--a-->glFlush<!--/a--></code> or <code><!--a-->glFinish<!--/a--></code> to move image data to the screen.</p><p>These are situations for which you don't need to, or should not, call <code>glFlush</code>:</p><ul class="spaceabove"><li class="li"><p>When the scene back buffer is not complete. For best results,  keep the back buffer as current as possible with a complete scene. Since the flushing and finishing routines force OpenGL to process queued commands, calling either of these when the scene in the back buffer is incomplete causes the incomplete scene to be rendered.</p></li><li class="li"><p>When calling a buffer swapping routine (the <code>flushBuffer</code> method of the <code>NSOpenGLContext</code> class, the <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglSwapBuffers" target="_top">aglSwapBuffers</a></code> function, or the <code>CGLFlushDrawable</code> function), because such functions implicitly call  the OpenGL command <code>glFlush</code>.  Note that when using the <code>NSOpenGLContext</code> class or the CGL API, the term <em>flush</em> actually refers to a buffer swapping operation. </p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH213-SW11" title="Be Mindful of OpenGL State Variables"></a><h3>Be Mindful of OpenGL State Variables</h3><p>The hardware has one current state, which is compiled and cached. Switching state is expensive, so it's best to design your application to minimize state switches.</p><p>Don't set a state that's already set. Once a feature is enabled, it does not need to be enabled again. Calling an enable function more than once does nothing except waste time because OpenGL does not check the state of a feature when you call <code>glEnable</code> or <code>glDisable</code>. For instance,  if you call <code>glEnable(GL_LIGHTING)</code> more than once, OpenGL does not check to see if the lighting state is already enabled. It simply updates the state value even if that value is identical to the current value.</p><p>You can avoid setting a state more than necessary by using dedicated setup or shutdown routines rather than putting such calls in a drawing loop. Setup and shutdown routines are also useful  for turning on and off features that achieve a specific visual effect—for example, when drawing a wire-frame outline around a textured polygon.</p><p>If you are drawing 2D images, disable all irrelevant state variables, similar to what's shown in <span class="content_text">Listing 12-1</span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH213-SW22" title="Listing 12-1Disabling state variables "></a><p class="codesample"><strong>Listing 12-1&nbsp;&nbsp;</strong>Disabling state variables </p><div class="codesample"><table><tr><td scope="row"><pre>glDisable(GL_DITHER);<span></span></pre></td></tr><tr><td scope="row"><pre>glDisable(GL_ALPHA_TEST);<span></span></pre></td></tr><tr><td scope="row"><pre>glDisable(GL_BLEND);<span></span></pre></td></tr><tr><td scope="row"><pre>glDisable(GL_STENCIL_TEST);<span></span></pre></td></tr><tr><td scope="row"><pre>glDisable(GL_FOG);<span></span></pre></td></tr><tr><td scope="row"><pre>glDisable(GL_TEXTURE_2D);<span></span></pre></td></tr><tr><td scope="row"><pre>glDisable(GL_DEPTH_TEST);<span></span></pre></td></tr><tr><td scope="row"><pre>glPixelZoom(1.0,1.0);<span></span></pre></td></tr><tr><td scope="row"><pre>// Disable other state variables as appropriate.<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH213-SW3" title="Draw Only When Necessary"></a><h3>Draw Only When Necessary</h3><p>You can ensure that your application draws only when necessary by following a few simple guidelines:</p><ul class="spaceabove"><li class="li"><p>Allow the system to regulate drawing. For example, in Cocoa use the  <code>setNeedsDisplay:</code> method.</p></li><li class="li"><p>Use a timer effectively.</p></li><li class="li"><p>Advance an animation only when necessary. To determine when to draw the next frame of an animation, calculate the difference between the current time and the start of the last frame. Use the difference to determine how much to advance the animation. You can use the Core Foundation function <code><a href="../../../../CoreFoundation/Reference/CFTimeUtils/Reference/reference.html#//apple_ref/c/func/CFAbsoluteTimeGetCurrent" target="_top">CFAbsoluteTimeGetCurrent</a></code> to obtain the current time. Don't simply draw each time the system sends the <code>drawRect:</code> method because the view can be redrawn for reasons other than a timer firing—such as when the user resizes the window.</p></li></ul><p>Drawing is typically triggered by a timer that fires at a set interval. Timer intervals that are set to very small values (such as 0.001 to yield 1000 executions per second) degrade application performance because they consume CPU time at a far higher rate than is necessary. In most cases, drawing 30 to 60 frames per second is sufficient (.033 to .0167 seconds). You'll get the best performance if you synchronize drawing to the refresh rate of the screen, which means that you should not set the timer interval to anything faster than the refresh rate.</p><p>The code in <span class="content_text">Listing 12-2</span> shows how to set up a timer in the rendering loop of a Cocoa application. When using a timer in Cocoa, make sure that you do not invoke the <code>drawRect:</code> method from the rendering loop. Instead, allow the system to send the <code>drawRect:</code> message when it needs to draw. This way, the system also takes care of locking and unlocking focus on the view.</p><p>The timer code shown in <span class="content_text">Listing 12-2</span> is in the <code>awakeFromNib</code> method to ensure that the timer starts up when the application launches. The timer interval is set to 100 milliseconds, which is 10 frames per second. Note that this is slower than the refresh rate, so that there is no risk of overdriving the animation and degrading performance. The <code>timerFired:</code> method is called by the system each time the timer fires. When called, this method signals to the system that the display needs refreshing.</p><a name="//apple_ref/doc/uid/TP40001987-CH213-SW6" title="Listing 12-2Setting up a drawing loop timer"></a><p class="codesample"><strong>Listing 12-2&nbsp;&nbsp;</strong>Setting up a drawing loop timer</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)awakeFromNib<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>renderTimer = [[NSTimer scheduledTimerWithTimeInterval:<span></span></pre></td></tr><tr><td scope="row"><pre>           0.1<span></span></pre></td></tr><tr><td scope="row"><pre>           target:self<span></span></pre></td></tr><tr><td scope="row"><pre>           selector:@selector(timerFired:)<span></span></pre></td></tr><tr><td scope="row"><pre>           userInfo:nil<span></span></pre></td></tr><tr><td scope="row"><pre>           repeats:YES]<span></span></pre></td></tr><tr><td scope="row"><pre>           retain];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)timerFired:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplay:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH213-SW4" title="Synchronize with the Screen Refresh Rate"></a><h3>Synchronize with the Screen Refresh Rate</h3><p>Tearing is a visual anomaly caused when part of the current frame overwrites previous frame data in the framebuffer before the current frame is fully rendered on the screen. Applications synchronize with the screen refresh rate (sometimes called VBL, vertical blank, or vsynch) to eliminate  frame tearing.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH213-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;During development, it's best to disable synchronization so that you can more accurately benchmark your application. Enable synchronization when you are ready to deploy your application.</p></div><p>The refresh rate of the display limits how often the screen can be refreshed. The screen can be refreshed at rates that are divisible by integer values. For example, a CRT display that has a refresh rate of 60 Hz can support screen refresh rates of 60 Hz, 30 Hz, 20 Hz, and 15 Hz. LCD displays do not have a vertical retrace in the CRT sense and are typically considered to have a fixed refresh rate of 60 Hz. </p><p>OpenGL blocks drawing to the display while waiting for the next vertical retrace. Applications that attempt to draw to the screen during this waiting period waste time that could be spent performing other drawing  operations or saving battery life and minimizing fan operation.</p><p><span class="content_text">Listing 12-3</span> shows how to use the CGL API to synchronize with the screen refresh rate, but you can use a similar approach if your application uses Cocoa or the AGL API. It assumes that you set up the context for double buffering. The swap interval can be set only to <code>0</code> or <code>1</code>. If the swap interval is set to <code>1</code>, the buffers are swapped only during the vertical retrace. After you  set up synchronization, call the function <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLFlushDrawable" target="_top">CGLFlushDrawable</a></code> to copy the back buffer to the front buffer during the vertical retrace of the display.</p><a name="//apple_ref/doc/uid/TP40001987-CH213-SW9" title="Listing 12-3Setting up synchronization"></a><p class="codesample"><strong>Listing 12-3&nbsp;&nbsp;</strong>Setting up synchronization</p><div class="codesample"><table><tr><td scope="row"><pre>long swapInterval = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetParameter (CGLGetCurrentContext(), kCGLCPSwapInterval, &amp;swapInterval);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH213-SW7" title="Use OpenGL Macros"></a><h3>Use OpenGL Macros</h3><p>OpenGL performs a global context and renderer lookup for each command it executes to ensure that all OpenGL commands are issued to the correct rendering context and renderer. There is significant overhead associated with these lookups; applications that have extremely high call frequencies may find that the overhead measurably affects performance. Mac OS X  allows your application to use macros to  provide a local context variable and cache the current renderer in that variable. You'll get the most out of using macros when your code makes millions of function calls per second. Then you'll see a noticeable boost in imaging response.</p><p>You can use the CGL macro header (<code>CGL/cglMacro.h</code>) if your application uses CGL from either a Cocoa or a Carbon application, and the AGL macro header (<code>AGL/aglMacro.h</code>) for Carbon applications. You must define the local variable <code>cgl_ctx</code> or <code>agl_ctx</code>  to be equal to the current context. <span class="content_text">Listing 12-4</span> shows what's needed to set up macro use for the AGL API. You use a similar approach for the CGL API. First, you need to include the correct macro header. Then, you must set the current context.</p><a name="//apple_ref/doc/uid/TP40001987-CH213-SW16" title="Listing 12-4Using AGL macros"></a><p class="codesample"><strong>Listing 12-4&nbsp;&nbsp;</strong>Using AGL macros</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;AGL/aglMacro.h> // include the header<span></span></pre></td></tr><tr><td scope="row"><pre>AGLContext agl_ctx = myContext; // set the current context<span></span></pre></td></tr><tr><td scope="row"><pre>glBegin (GL_QUADS);     // This code now uses the macro<span></span></pre></td></tr><tr><td scope="row"><pre>    // draw here<span></span></pre></td></tr><tr><td scope="row"><pre>glEnd ();<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH213-SW13" title="Use the CPU and the GPU Asynchronously"></a><h3>Use the CPU and the GPU Asynchronously</h3><p>Whenever it’s feasible to do so, it's best to keep both the CPU and GPU busy  and working as asynchronously as possible. You'll want to avoid pushing data through the bottleneck between the two units unless it is absolutely necessary.</p><p>These tips can help use the CPU and GPU optimally:</p><ul class="spaceabove"><li class="li"><p>Consider using the GPU to perform intense mathematical computations to take some of the load off the CPU.</p></li><li class="li"><p>Use double buffering and asynchronous vertex transfer, as described in <span class="content_text"><a href="../opengl_vertexdata/opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW10">“Double Buffering Vertex Data.”</a></span> If you are using the vertex array range extension, consider experimenting with triple buffers  or changing buffer size.</p></li><li class="li"><p>Use asynchronous texture fetching (see <span class="content_text"><a href="../opengl_texturedata/opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW13">“Downloading Texture Data”</a></span>) rather than calling the function <code>glReadPixels</code>. This call is an expensive one because  it  forces synchronization between the CPU and GPU, which can have the effect of stalling the rendering pipeline. Performance degrades if either the CPU or GPU is waiting for the other processing unit to catch up.</p></li><li class="li"><p>Upload textures asynchronously using DMA. See <span class="content_text"><a href="../opengl_texturedata/opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW21">“Apple Texture Range and Rectangle Texture.”</a></span></p></li></ul><p>You can use OpenGL Driver Monitor to analyze how long the CPU waits for the GPU, as shown in <span class="content_text">Figure 12-2</span>. OpenGL Driver Monitor is useful for analyzing other parameters as well. You can choose which parameters to monitor simply by clicking a parameter name from the drawer shown in the figure. </p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH213-SW24" title="Figure 12-2The graph view in OpenGL Driver Monitor"></a><p><strong>Figure 12-2&nbsp;&nbsp;</strong>The graph view in OpenGL Driver Monitor</p><img src = "../art/opengl_driver_monitor.gif" alt = "The graph view in OpenGL Driver Monitor" width="802" height="667"></div><br/><a name="//apple_ref/doc/uid/TP40001987-CH213-SW19" title="Use Appropriate Routines for Images and Pixel Data"></a><h3>Use Appropriate Routines for Images and Pixel Data</h3><p>The size of an image should guide the routine  you choose to draw it. Most images you'll draw will have dimensions greater than 128 pixels by 128 pixels. It's best to treat those images as texture data. See the <em><a href="../../../../../samplecode/OpenGL_Image/index.html#//apple_ref/doc/uid/DTS10000538" target="_top">OpenGL Image</a></em> sample application on <span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxOpenGL-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000549" target="_top">Sample Code > Graphics &amp; Imaging > OpenGL</a></span> for an example of high performance image display.</p><p>For small images, those  whose dimensions are less than or equal to 128 pixels by 128 pixels, use the OpenGL function <code>glDrawPixels</code>. See the <em><a href="../../../../../samplecode/Draw_Pixels/index.html#//apple_ref/doc/uid/DTS10000524" target="_top">Draw Pixels</a></em> sample application on <span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxOpenGL-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000549" target="_top">Sample Code > Graphics &amp; Imaging > OpenGL</a></span> for an example of the correct use of <code>glDrawPixels</code>.</p><p>Copying pixel data from one VRAM location to another VRAM location, for example, to an auxiliary buffer, requires an approach similar to the one used to draw image data. Perform the copy operation using the OpenGL function <code>glCopyPixels</code>, as shown in <span class="content_text">Listing 12-5</span>. If you are using Cocoa, you can use the <code>NSOpenGLPFAAuxBuffers</code> and <code>NSOpenGLPFAAuxDepthStencil</code> pixel format attributes in conjunction with <code>glReadBuffer</code> and<code>glDrawBuffer</code> to set up auxiliary buffers for temporary pixel storage. </p><p>Using OpenGL for drawing images and copying pixel data can incur a performance cost if the OpenGL state is a complex one. State variables such as dithering, fog, and depth testing don't need to be enabled for 2D drawing. To ensure efficient drawing, first disable irrelevant state variables as shown in <span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW22">Listing 12-1</a></span>. </p><a name="//apple_ref/doc/uid/TP40001987-CH213-SW17" title="Listing 12-5Copying pixels "></a><p class="codesample"><strong>Listing 12-5&nbsp;&nbsp;</strong>Copying pixels </p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void drawRect:(NSRect) aRect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    glDrawBuffer(GL_BACK);<span></span></pre></td></tr><tr><td scope="row"><pre>    glReadBuffer(GL_AUX0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    glCopyPixels(x, y, width, height, GL_COLOR);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH213-SW21" title="Retrieve Error Information Only When Debugging"></a><h3>Retrieve Error Information Only When Debugging</h3><p>When errors occur  OpenGL sets an error flag that you can retrieve with the function <code>glGetError</code>. During development, it's crucial that your code contains error checking routines, not only for the standard OpenGL calls, but for the Apple-specific functions provided by the AGL and CGL APIs. AGL uses a mechanism for errors that's similar to OpenGL through the functions <code>aglGetError</code> and <code>aglErrorString</code>. CGL functions return error codes.</p><p>If you are developing a performance-critical application, you'll want to retrieve error information in the debugging phase. When you deploy your application you'll want to remove the error-retrieval information for all but the most critical cases. If you retrieve error codes and strings for frequently-called functions, you'll cause performance to slow down.</p><a name="//apple_ref/doc/uid/TP40001987-CH213-SW23" title="Use Optimal Data Types and Formats"></a><h3>Use Optimal Data Types and Formats</h3><p>If you don't use data types and formats that are native to the graphics processor, you'll incur a costly data conversion.</p><p>For vertex data, use <code>GLfloat</code>, <code>GLshort</code>, or <code>GLubyte</code> data types. Most graphics processors handle these types natively. </p><p>For texture data, you’ll get the best performance, regardless of architecture, if you use the following format and data type combination:</p><ul class="simple"><li><p><code>GL_BGRA</code>, <code>GL_UNSIGNED_INT_8_8_8_8_REV</code></p></li></ul><p>These format and data type combinations also provide acceptable performance:</p><ul class="simple"><li><p><code>GL_BGRA</code>, <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code></p></li><li><p><code>GL_YCBCR_422_APPLE</code>, <code>GL_UNSIGNED_SHORT_8_8_REV_APPLE</code></p></li></ul><p>The combination <code>GL_RGBA</code>  and <code>GL_UNSIGNED_BYTE</code> needs to be swizzled by many cards when the data is loaded, so it's not recommended.</p><a name="//apple_ref/doc/uid/TP40001987-CH213-SW14" title="Gathering and Analyzing Baseline Performance Data"></a><h2>Gathering and Analyzing Baseline Performance Data</h2><p>Analyzing performance is a systematic process that starts with gathering baseline data. Mac OS X provides several applications that you can use to assess baseline performance for an OpenGL application:</p><ul class="ul"><li class="li"><p><code>top</code> is a command-line utility that you run in the Terminal window. You can use <code>top</code> to assess how much CPU time your application consumes.</p></li><li class="li"><p>OpenGL Profiler  is an application that determines how much time an application spends in OpenGL. It also provides function traces that you can use to look for redundant calls.</p></li><li class="li"><p>OpenGL Driver Monitor lets you gather real-time data on the operation of the GPU and lets you look at information (OpenGL extensions supported, buffer modes, sample modes, and so forth) for the available renderers. For more information, see <span class="content_text"><a href="http://developer.apple.com/graphicsimaging/opengl/opengl_serious.html" target="_top">OpenGL Tools for Serious Graphics Development</a></span> and <span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW13">“Use the CPU and the GPU Asynchronously.”</a></span></p></li></ul><p>This section shows how to use <code>top</code> along with OpenGL Profiler to analyze where to spend your optimization efforts—in your OpenGL code, your other application code, or in both. You'll see how to gather baseline data and how to determine the relationship of OpenGL performance to overall application performance.</p><ol class="ol"><li class="li"><p>Launch your OpenGL application.</p></li><li class="li"><p>Open a Terminal window and place it side-by-side with your application window.</p></li><li class="li"><p>In the Terminal window, type <code>top</code> and press Return. You'll see output similar to that shown in <span class="content_text">Figure 12-3</span>.</p><p> The <code>top</code> program indicates the amount of CPU time that an application uses. The CPU time serves as a good baseline value for gauging how much tuning your code needs. <span class="content_text">Figure 12-3</span> shows the percentage of CPU time for the OpenGL application GLCarbon1C (highlighted). Note this application utilizes 31.5% of CPU resources.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40001987-CH213-SW18" title="Figure 12-3Output produced by the top  application"></a><p><strong>Figure 12-3&nbsp;&nbsp;</strong>Output produced by the <code>top</code>  application</p><img src = "../art/top_pbuffer.gif" alt = "Output produced by the top  application" width="534" height="367"></div></li><li class="li"><p>Open the OpenGL Profiler application, located in <code>/Developer/Applications/Graphics Tools/</code>. In the window that appears, select the options to collect a trace and include backtraces, as shown in <span class="content_text">Figure 12-4</span>.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40001987-CH213-SW5" title="Figure 12-4The OpenGL Profiler window"></a><p><strong>Figure 12-4&nbsp;&nbsp;</strong>The OpenGL Profiler window</p><img src = "../art/opengl_profiler_window.jpg" alt = "The OpenGL Profiler window" ></div></li><li class="li"><p>Select Attach to application, then select your application from the Application list.</p><p>You may see small pauses or stutters in the application, particularly when OpenGL Profiler is collecting a function trace. This is normal and does not  significantly affect the performance statistics. The "glitches" are due to the large amount of data that OpenGL Profiler is writing out. </p></li><li class="li"><p>Click Suspend to stop data collection.</p></li><li class="li"><p>Open the Statistics and Trace windows by choosing them from the Views menu.</p><p><span class="content_text">Figure 12-5</span> provides an example of what the Statistics window looks like. <span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW8">Figure 12-6</a></span> shows a Trace window.</p><p>The estimated percentage of time spent in OpenGL is shown at the bottom of  <span class="content_text">Figure 12-5</span>. Note that for this example, it is 28.91%. The higher this number, the more time the application is spending in OpenGL and the more opportunity there may be to improve application performance by optimizing OpenGL code.</p><p>You can use the amount of time spent in OpenGL along with the CPU time to calculate a ratio of the application time versus OpenGL time. This ratio indicates where to spend most of your optimization efforts.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40001987-CH213-SW10" title="Figure 12-5A statistics window"></a><p><strong>Figure 12-5&nbsp;&nbsp;</strong>A statistics window</p><img src = "../art/profiler_1.jpg" alt = "A statistics window" ></div></li><li class="li"><p>In the Trace window, look for duplicate function calls and redundant or unnecessary state changes.  </p><p>Look for back-to-back function calls with the same or similar data. These are areas that can typically be optimized. Functions that are called more than necessary include <code>glTexParameter</code>, <code>glPixelStore</code>, <code>glEnable</code>, and <code>glDisable</code>. For most applications, these functions can be called once from a setup or state modification routine and only called when necessary. </p><p>It's generally good practice to keep state changes out of rendering loops (which can be seen in the function trace as the same sequence of state changes and drawing over and over again) as much as possible and use separate routines to adjust state as necessary.</p><p>Look at the time value to the left of each function call to determine the cost of the call.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40001987-CH213-SW8" title="Figure 12-6A Trace window"></a><p><strong>Figure 12-6&nbsp;&nbsp;</strong>A Trace window</p><img src = "../art/trace.jpg" alt = "A Trace window" ></div></li><li class="li"><p>Determine what the performance gain would be if it were possible to reduce the time to execute all OpenGL calls to zero.</p><p>For example, take the performance data from the GLCarbon1C application used in this section to determine the performance attributable to the OpenGL calls. </p><p>Total Application Time (from <code>top</code>) = 31.5%</p><p>Total Time in OpenGL (from OpenGL Profiler) = 28.91%</p><p>At first glance, you might think that optimizing the OpenGL code could improve application performance by almost 29%, thus reducing the total application time by 29%. This isn't the case. Calculate the theoretical performance increase by multiplying the total CPU time by the percentage of time spent in OpenGL. The theoretical performance improvement for this example is:</p><p><code>31.5 X .2891  = 9.11%</code></p><p>If OpenGL took no time at all to execute, the application would see a 9.11% increase in performance. So, if the application runs at 60 frames per second (FPS), it would perform as follows:</p><p><code>New FPS = previous FPS * (1 +(% performance increase)) = 60 fps *(1.0911) = 65.47 fps</code></p><p>The application gains almost 5.5 frames per second by reducing OpenGL from 28.91%  to 0%. This shows that the relationship of OpenGL performance to application performance is not linear. Simply reducing the amount of time spent in OpenGL may or may not offer any noticeable benefit in application performance.</p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH213-SW20" title="Identifying Bottlenecks with Shark"></a><h2>Identifying Bottlenecks with Shark</h2><p>Shark is an extremely useful tool for identifying places in your code that are slow and could benefit from optimization. If you are not familiar with Shark, read some of the documents listed in <span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW15">“See Also”</a></span> that describe Shark in detail and show how to use it. Once you learn the basics, you can use it on your OpenGL applications to identify bottlenecks. </p><p>There are three issues to watch out for in Shark when using it to analyze OpenGL performance:</p><ul class="ul"><li class="li"><p>Costly data conversions. If you notice the  <code>glgProcessPixels</code> call (in the <code>libGLImage.dylib</code> library) showing up in the analysis, it's an indication that the driver is not handling a texture upload optimally. The call is used when your application makes a <code>glTexImage</code> or <code>glTexSubImage</code> call using data that is in a nonnative format for the driver, which means the data must be converted before the driver can upload it. You can improve performance by changing your data so that it is in a native format for the driver. See <span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW23">“Use Optimal Data Types and Formats.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH213-SW27" title="Note"></a><p><strong>Note:</strong>&nbsp;If your data needs only to be swizzled, <code>glgProcessPixels</code> performs the swizzling reasonably fast although not as fast if the data didn't need swizzling. But non-native data formats are converted one byte at a time and will incur a performance cost that is best to avoid.</p></div></li><li class="li"><p>Time in the <code>mach_kernel</code> library. If you see time spent waiting for a timestamp or waiting for the driver, it indicates that your application is waiting for the GPU to finish processing. You'll see this during a texture upload. See <span class="content_text"><a href="../opengl_texturedata/opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW16">“Double Buffering Texture Data”</a></span> and <span class="content_text"><a href="opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW13">“Use the CPU and the GPU Asynchronously”</a></span> for ideas on how you might optimize asynchronous behavior between the CPU and the GPU.</p></li><li class="li"><p>Misleading symbols. You may see a symbol, such as <code>glgGetString</code>, that appears to be taking time but shouldn't be taking time in your application. That sometimes happens because the underlying optimizations performed by the system don't have any symbols attached to them on the driver side. Without a symbol to display, Shark shows the last symbol. You need to look for the call that your application made prior to that symbol and focus your attention there. You don't need to concern yourself with the calls that were made "underneath" your call.</p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH213-SW15" title="See Also"></a><h2>See Also</h2><p>If you are unfamiliar with general performance issues on the Macintosh platform, you will want to read <span class="content_text"><a href="../../../../../referencelibrary/GettingStarted/GS_Performance/index.html" target="_top">Getting Started with Performance</a></span> and  <em><a href="../../../../Performance/Conceptual/PerformanceOverview/index.html#//apple_ref/doc/uid/TP40001410" target="_top">Performance Overview</a></em>.  <em><a href="../../../../Performance/Conceptual/PerformanceOverview/index.html#//apple_ref/doc/uid/TP40001410" target="_top">Performance Overview</a></em> contains general performance tips that are useful to all applications. It also describes most of the  performance tools provided with Mac OS X, including:</p><ul class="ul"><li class="li"><p>Analysis tools—MallocDebug, ObjectAlloc, OpenGL Profiler, Sampler, Saturn, Shark, <code>heap</code>, <code>leaks</code>, and <code>vmmap</code></p></li><li class="li"><p>Monitoring tools—BigTop, Quartz Debug, Spin Control, Thread Viewer, <code>fs_usage</code>, <code>sc_usage</code>, and <code>top</code></p></li><li class="li"><p>Hardware analysis tools—CacheBasher, MONster, PMC Index, Reggie SE, Skidmarks GT, <code>acid</code>, <code>amber</code>, <code>simg4</code>, and <code>simg5</code></p></li><li class="li"><p>Assorted command-line tools—<code>atos</code>, <code>c2ph</code>, <code>gprof</code>, <code>kdump</code>, <code>malloc_history</code>, <code>nm</code>, <code>otool</code>, <code>pagestuff</code>, <code>pstruct</code>, <code>sample</code>, <code>vm_stat</code></p></li></ul><p>There are two tools other than OpenGL Profiler that are specific for OpenGL development—OpenGL Driver Monitor and OpenGL Shader Builder. OpenGL Driver Monitor collects real-time data from the hardware. OpenGL Shader Builder provides immediate feedback on vertex and fragment programs that you write. </p><p>For more information on these tools, see:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="http://developer.apple.com/graphicsimaging/opengl/opengl_serious.html" target="_top">OpenGL Tools for Serious Graphics Development</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://developer.apple.com/tools/shark_optimize.html" target="_top">Using Shark</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://developer.apple.com/tools/shark_optimize.html" target="_top">Optimizing with Shark: Big Payoff, Small Effort</a></span></p></li><li class="li"><p><em>Shark User Guide</em>, available by launching Shark and choosing Help > Shark Help.</p></li><li class="li"><p><span class="content_text"><a href="http://developer.apple.com/tools/performance/#CHUD" target="_top">CHUD Tools</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://developer.apple.com/graphicsimaging/opengl/profiler_image.html" target="_top">OpenGL Profiler</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://developer.apple.com/graphicsimaging/opengl/drivermon_image.html" target="_top">OpenGL Driver Monitor</a></span></p></li></ul><p>The following books contain many techniques for getting the most performance from the GPU: </p><ul class="ul"><li class="li"><p><em>GPU Gems: Programming Techniques, Tips, and Tricks for Real-Time Graphics</em>, Randima Fernando. </p></li><li class="li"><p><em>GPU Gems 2: Programming Techniques for High-Performance Graphics and General-Purpose Computation</em>, Matt Pharr and Randima Fernando.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_threading/opengl_threading.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_api_versions/opengl_api_versions.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_performance/opengl_performance.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_performance/opengl_performance.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_performance/opengl_performance.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>