<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1089: HFS Elucidations Revisited</title>    <meta name="keywords" content="Mac OS 8 HFS hierarchical file system names FCB record">    <meta name="Description" content="Technical Note TN1089: This Technical Note describes a fewproblems that may occur while using                                   the Hierarchical File System (HFS). It alsodescribes ways to                                     avoidthese problems. The Note discusses the importance of howfiles are opened and closed. This Note also discusses whyusing driver names such as .Bout may confuse the system."> <meta name="categories" content="Files"><meta name="week-posted" content="Sep 27, 1999 - Oct 1, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002929" title="HFS Elucidations Revisited"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1089</div>
<div id="pageheadsub">HFS Elucidations Revisited</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext">    <A HREF = "#Section1">One Close is Always Enough</A><BR><BR>    <A HREF = "#Section2">Avoiding the Problem of Overwriting The FCB Record</A><BR><BR>    <A HREF = "#Section3">This .filename Looks Outrageous</A><BR><BR>         <A HREF = "#References">References</a><BR><BR>    <A HREF="#Downloads">Downloadables</A></p>                  <!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text --><p id = "introtext">This Technote, originally     <CITE>FL 6 - HFS Elucidations</CITE>, describes a fewproblems that may occur while using Hierarchical File System (HFS). Italso describes ways to avoid these problems.</p><p id = "introtext">This Note is important for developers who need to address debuggingissues involving HFS. This is as important now as it was when the Notewas originally published. </P><p id = "introtext">The Note discusses the following problems: </P><OL TYPE="1" START="1">    <LI><p id = "introtext">It is very important to be careful about how files are opened and    closed. There must be no more than one close for every open.</p></li>    <LI><P id = "introtext">Don't use driver names, like <CODE>.Bout, .Print</CODE> or <CODE>.Sony</CODE>,     in place of file names, or the system may become confused.</p></li></OL><p id = "introtext">Each of these can lead to strange occurrences, as well as problems forusers. Performing any or all of these marginally-illegal operations willnot necessarily lead to a System Error. In some cases, the confusiongenerated may be worse than a System Error.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Dec 20 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --> <BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content -->    <A NAME="Section1"></A>    <H2>One Close is Always Enough</H2>        <P>If a file is closed twice, it is possible to corrupt the file system ona disk. Without a clear understanding of how the file system allocatesaccess paths to files that are currently open, it is possible to adopt arather cavalier attitude about opening and closing files. This Noteexplains why it is necessary to be very careful about opening andclosing files.</P><P>When the File Manager receives an <CODE>Open</CODE> call, it will look at theparameters passed in the parameter block and create a new access pathfor the file that is being opened. The access path is how the FileManager keeps track of where to send data that is written, and where toget data that is read from that file. An access path is nothing more than: </P><OL TYPE="1" START="1">    <LI>a buffer that the file system uses to read and write data, and</li>    <LI>a File Control Block that describes how the file is stored on a disk.</li></OL><P>A call such as: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre></pre>	</TD></TR></TABLE></CENTER><P>will create the access path as a buffer and a File Control Block (FCB)in the FCB buffer. The term "FCB buffer" is used in most documentation,although it actually behaves more like an array than a buffer. However,to avoid confusion, this Technote will continue to use the term "FCBbuffer," although "FCB array" would be a better description.</P>    <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>    The following example is here for illustrative purposes only;    dependence on it may cause compatibility problems with future system software.</P></TD></TR></TABLE></CENTER><BR>    <P>The <CODE>FCBSPtr</CODE> is a low-memory global (at <CODE>0x034E</CODE>) that holds the address ofa nonrelocatable block. That block is the File Control Block buffer, andis composed of the two byte header which gives the length of the block,followed by the FCB records themselves. The records are of fixed length,and give detailed information about an open file. The structure of thequeue can be visualized as: </P><p align=center><img src="images/tn1089_001.gif" alt="" width=320 height=210></p><P>As depicted, any given record can be found by adding the length of theprevious FCB records to the start of the block, adding 2 for the twobyte header; giving an offset to the record itself. The size of theblock, and hence the number of files that can be open at any given time,is determined at startup time and expanded on demand later. The call toopen the file referenced by <CODE>fsspec</CODE> above, will produce the filereference number (which refers to the access path to the file) in<CODE>firstRefNum</CODE>. This is the number that will be used to access that filefrom that point on. The File Manager passes back an offset into the FCBbuffer as the reference number (<CODE>RefNum</CODE>). This offset is the number ofbytes past the beginning of the queue to that FCB record in the buffer.That FCB record will describe the file that was opened. An example of anumber that might get passed back as a <CODE>RefNum</CODE> is <CODE>$1D8</CODE>. That also meansthat the FCB record is <CODE>$1D8</CODE> bytes into the FCB block.</P><P>A visual example of a record in use, and how the <CODE>RefNum</CODE> relates is: </P><p align=center><img src="images/tn1089_002.gif" alt="" width=132 height=200></p><P><CODE>Base</CODE> is merely the address of the nonrelocatable block that is the FCBbuffer. <CODE>FCBSPtr</CODE> points to it. The <CODE>RefNum</CODE> (a number like <CODE>$1D8</CODE>) is added to <CODE>Base</CODE>, to give an address in the block. That address is what the file system will use to read and write to an open file, which is why you arerequired to pass the <CODE>RefNum</CODE> to the <CODE>PBRead</CODE> and <CODE>PBWrite</CODE> calls. So <CODE>RefNum</CODE> is merely an offset into the buffer.</P><P>Let's step through a dangerous imaginary sequence and see what happensto a given record in the FCB buffer. Here's the sequence we will step through: </P>    <TABLE BORDER="0"><TR> <td bgcolor="#EEEEEE" align=left>    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    ErrStuff = FSpOpenDF (fsspec, permission, firstRefNum);    ErrStuff = FSClose ( firstRefNum );    ErrStuff = FSpOpenDF (secondFileSpec, permission, secondRefNum);    ErrStuff = FSClose ( firstRefNum ); {the wrong file gets closed!!!}    {the above line will close 'SecondFile', not 'FirstFile', which is     already closed}</pre>	</TD></TR></TABLE></CENTER>    </TD></TR></TABLE><P>Before any operations, the record at $1D8 is not used.</P><p align=center><img src="images/tn1089_003.gif" alt="" width=132 height=200></p><P>After the call: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre></pre>	</TD></TR></TABLE></CENTER><P>firstRefNum = $1D8 and the record is in use.</P><p align=center><img src="images/tn1089_004.gif" alt="" width=132 height=200></p><P>After the call: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre></pre>	</TD></TR></TABLE></CENTER><P>firstRefNum is still equal to $1D8, but the FCB record is unused.</P><p align=center><img src="images/tn1089_005.gif" alt="" width=132 height=200></p><P>After the call: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre></pre>	</TD></TR></TABLE></CENTER><P>SecondRefNum = $1D8, FirstRefNum = $1D8, and the record is reused.</P><p align=center><img src="images/tn1089_006.gif" alt="" width=132 height=200></p><P>After the call: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre></pre>	</TD></TR></TABLE></CENTER><P>The firstRefNum = $1D8, secondRefNum = $1D8, and the FCB buffer elementis cleared. This happens even though <CODE>firstFile</CODE> was already closed.Actually, <CODE>secondFile</CODE> was closed: </P><p align=center><img src="images/tn1089_007.gif" alt="" width=132 height=200></p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>    The second close is using the old <CODE>RefNum</CODE>. The second close will still    close a file, and in fact will return <CODE>noErr</CODE> as its result. Any    subsequent accesses to the <CODE>secondRefNum</CODE> will return an error, since the    file '<CODE>secondFile</CODE>' was closed. The File Control Blocks are reused, and    since they are just offsets, it is possible to get the same file <CODE>RefNum</CODE>    back for two different files. In this case, <CODE>firstRefNum == secondRefNum</CODE>    since '<CODE>firstFile</CODE>' was closed before opening '<CODE>secondFile</CODE>' and the same    FCB record was reused for '<CODE>secondFile</CODE>'.</P></TD></TR></TABLE></CENTER><BR><P>There are any number of nasty cases that can arise if a file is closedtwice, reusing an old <CODE>RefNum</CODE>. A common programming practice is to havean error handler or cleanup routine that goes through the files that aprogram creates and closes them all, even if some may already be closed.If an FCB element was not reused, the <CODE>Close</CODE> will return the expected<CODE>fnOpnErr</CODE>. If the FCB had been reused, then the <CODE>Close</CODE> could be closingthe wrong file. This can be very dangerous.</P><P>As a particularly nasty example, think of what can happen if a programwere to close a file, then the user inserted an HFS floppy disk. The FCBcould be reused for the Catalog File on that HFS disk. If the programhad a generic error handler that closed all of its files, it couldinadvertently close "its" file again. If it thought "its" file was stillopen it would do the close, which could close the Catalog file on theHFS disk. This is catastrophic for the disk since the file could easilybe closed in an inconsistent state. The result is a bad disk that needsto be reformatted.</P>        <A NAME="Section2"></A>    <H2>Avoiding the Problem of Overwriting The FCB Record</H2>    <P>A very simple technique is to merely clear the <CODE>RefNum</CODE> after each close.If the variable that the program uses is cleared after each close, thenthere is no way of reusing a <CODE>RefNum</CODE> in the program. An example of thistechnique would be: </P>    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    ErrStuff = FSpOpenDF (firstFileSpec, permission, firstRefNum);    ErrStuff = FSClose (firstRefNum);    firstRefNum = 0; { We just closed it, so clear our refnum }    ErrStuff = FSpOpenDF (secondFileSpec, permission, secondRefNum);    ErrStuff = FSClose (firstRefNum); { returns an error }</pre>	</TD></TR></TABLE></CENTER><P>This makes the second <CODE>Close</CODE> pass back an error. In this case, the secondclose will try to close RefNum = 0, which will pass back a <CODE>rfNumErr</CODE> anddo no damage. </P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>    Be sure to use 0, which will never be a valid <CODE>RefNum</CODE>, since the    first FCB entry is beyond the FCB buffer length word. Don't confuse this    with the 0 that the Resource Manager uses to represent the System file.</P></TD></TR></TABLE></CENTER><BR>    <P>Thus, if an error handler were cleaning up possibly open files, it couldblithely close all the files it knew about, since it would legitimatelyget an error back on files that are already closed. This is not doneautomatically, however. The programmer must be careful about the openingand closing of files. The problem can get quite complex if an error isreceived halfway through opening a sequence of ten files, for example.By merely clearing the <CODE>RefNum</CODE> that is stored after each close, it ispossible to avoid the complexities of trying to track which files areopen and which are closed.</P>    <A NAME="Section3"></A>    <H2>This .filename Looks Outrageous</H2>        <P>There is a potential conflict between file names and driver names whenusing deprecated <CODE>Open</CODE> calls, such as <CODE>FSOpen</CODE>, <CODE>PBHOpen</CODE> and <CODE>PBOpen</CODE>. If afile name is something like <B>.Bout, .Print</B> or <B>.Sony</B>, then the call willopen the corresponding driver instead of the file. Drivers have priorityand will always be opened before a file of the same name. This may meanthat an application will get an error back when opening these types offiles, or worse, it will get back a driver <CODE>RefNum</CODE> from the call. Whatthe application thought was a file open call was actually a driver opencall. If the program uses that access path as a file <CODE>RefNum</CODE>, it ispossible to get all kinds of strange things to happen. For example, if<CODE>.Sony</CODE> is opened, the Sony driver's <CODE>RefNum</CODE> would be passed back, insteadof a file <CODE>RefNum</CODE>. If the application does a <CODE>Write</CODE> call using that<CODE>RefNum</CODE>, it will actually be a driver call, using whatever parametershappen to be in the parameter block. Disks may be searching for new lifeafter this type of operation. If a program creates files, it should notallow a file to be created whose name begins with '.'.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>    This problem never occurs when using the new <CODE>Open</CODE> calls, such as    <CODE>FSOpenDF</CODE> and <CODE>PBHOpenDF</CODE>. For this reason,     it is strongly recommended that    these <CODE>Open</CODE> calls be used instead of <CODE>FSOpen</CODE>.</p></TD></TR></TABLE></CENTER><BR><a name="References"></a><H2>References</h2>    <p><a href="http://developer.apple.com/documentation/mac/Files/Files-72.html">    <CITE>Inside Macintosh: Files</CITE>, Ch 2, File Manager</A></p>        <p><A HREF = "../fl/fl_22.html">    Technical Note FL22 - HFS Ruminations</A></p>   <P><A HREF="#top">Back to top</A></p> <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 align=middle alt="Acrobat" height=23></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (132K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1089.pdf">Download</A></P>               </TD>	</tr>	</table><BR>         <P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1089.html%3Fid%3DDTS10002929-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1089.html%3Fid%3DDTS10002929-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1089.html%3Fid%3DDTS10002929-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --><hr width=500 align=center></BODY></HTML>