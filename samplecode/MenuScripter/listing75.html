<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MenuScripter - /Sources/MSWindow.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MenuScripter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MenuScripter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/MSWindow.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Resources/MenuScripterAETE.r</option>
<option value="listing2.html">/Sources/DebugUtils.c</option>
<option value="listing3.html">/Sources/DebugUtils.h</option>
<option value="listing4.html">/Sources/MenuScripter.r</option>
<option value="listing5.html">/Sources/MenuScripterPPC.r</option>
<option value="listing6.html">/Sources/MSAccessors.c</option>
<option value="listing7.html">/Sources/MSAccessors.h</option>
<option value="listing8.html">/Sources/MSAEClone.c</option>
<option value="listing9.html">/Sources/MSAEClone.h</option>
<option value="listing10.html">/Sources/MSAEClose.c</option>
<option value="listing11.html">/Sources/MSAEClose.h</option>
<option value="listing12.html">/Sources/MSAECoercions.c</option>
<option value="listing13.html">/Sources/MSAECoercions.h</option>
<option value="listing14.html">/Sources/MSAECompare.c</option>
<option value="listing15.html">/Sources/MSAECompare.h</option>
<option value="listing16.html">/Sources/MSAECopy.c</option>
<option value="listing17.html">/Sources/MSAECopy.h</option>
<option value="listing18.html">/Sources/MSAECountElements.c</option>
<option value="listing19.html">/Sources/MSAECountElements.h</option>
<option value="listing20.html">/Sources/MSAECreate.c</option>
<option value="listing21.html">/Sources/MSAECreate.h</option>
<option value="listing22.html">/Sources/MSAECut.c</option>
<option value="listing23.html">/Sources/MSAECut.h</option>
<option value="listing24.html">/Sources/MSAEDelete.c</option>
<option value="listing25.html">/Sources/MSAEDelete.h</option>
<option value="listing26.html">/Sources/MSAEGetData.c</option>
<option value="listing27.html">/Sources/MSAEGetData.h</option>
<option value="listing28.html">/Sources/MSAEGetDataSize.c</option>
<option value="listing29.html">/Sources/MSAEGetDataSize.h</option>
<option value="listing30.html">/Sources/MSAEMenuUtils.c</option>
<option value="listing31.html">/Sources/MSAEMenuUtils.h</option>
<option value="listing32.html">/Sources/MSAEMove.c</option>
<option value="listing33.html">/Sources/MSAEMove.h</option>
<option value="listing34.html">/Sources/MSAEObjectsExist.c</option>
<option value="listing35.html">/Sources/MSAEObjectsExist.h</option>
<option value="listing36.html">/Sources/MSAEPaste.c</option>
<option value="listing37.html">/Sources/MSAEPaste.h</option>
<option value="listing38.html">/Sources/MSAERecording.c</option>
<option value="listing39.html">/Sources/MSAERecording.h</option>
<option value="listing40.html">/Sources/MSAERevert.c</option>
<option value="listing41.html">/Sources/MSAERevert.h</option>
<option value="listing42.html">/Sources/MSAESave.c</option>
<option value="listing43.html">/Sources/MSAESave.h</option>
<option value="listing44.html">/Sources/MSAESelect.c</option>
<option value="listing45.html">/Sources/MSAESelect.h</option>
<option value="listing46.html">/Sources/MSAESetData.c</option>
<option value="listing47.html">/Sources/MSAESetData.h</option>
<option value="listing48.html">/Sources/MSAETextUtils.c</option>
<option value="listing49.html">/Sources/MSAETextUtils.h</option>
<option value="listing50.html">/Sources/MSAEUtils.c</option>
<option value="listing51.html">/Sources/MSAEUtils.h</option>
<option value="listing52.html">/Sources/MSAEWindowUtils.c</option>
<option value="listing53.html">/Sources/MSAEWindowUtils.h</option>
<option value="listing54.html">/Sources/MSAppleEvents.c</option>
<option value="listing55.html">/Sources/MSAppleEvents.h</option>
<option value="listing56.html">/Sources/MSASSubroutines.c</option>
<option value="listing57.html">/Sources/MSASSubroutines.h</option>
<option value="listing58.html">/Sources/MSDrag.c</option>
<option value="listing59.html">/Sources/MSDrag.h</option>
<option value="listing60.html">/Sources/MSFile.c</option>
<option value="listing61.html">/Sources/MSFile.h</option>
<option value="listing62.html">/Sources/MSGlobals.c</option>
<option value="listing63.html">/Sources/MSGlobals.h</option>
<option value="listing64.html">/Sources/MSGXPrinting.c</option>
<option value="listing65.html">/Sources/MSGXPrinting.h</option>
<option value="listing66.html">/Sources/MSMain.c</option>
<option value="listing67.html">/Sources/MSMain.h</option>
<option value="listing68.html">/Sources/MSResultWind.c</option>
<option value="listing69.html">/Sources/MSResultWind.h</option>
<option value="listing70.html">/Sources/MSScript.c</option>
<option value="listing71.html">/Sources/MSScript.h</option>
<option value="listing72.html">/Sources/MSToken.h</option>
<option value="listing73.html">/Sources/MSUtils.c</option>
<option value="listing74.html">/Sources/MSUtils.h</option>
<option value="listing75.html">/Sources/MSWindow.c</option>
<option value="listing76.html">/Sources/MSWindow.h</option>
<option value="listing77.html">/Sources/Offscreen.c</option>
<option value="listing78.html">/Sources/Offscreen.h</option>
<option value="listing79.html">/Sources/PLStrs.c</option>
<option value="listing80.html">/Sources/PLStrs.h</option></select>
				</p>
				</form>
				<p><strong><a href="MenuScripter.zip">Download Sample</a></strong> (&#147;MenuScripter.zip&#148;, 288.0K)<BR>
<strong><a href="MenuScripter.dmg">Download Sample</a></strong> (&#147;MenuScripter.dmg&#148;, 355.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">// MSWindow.c//// Original version by Jon Lansdell and Nigel Humphreys.// 4.0 and 3.1 updates by Greg Sutton.// &copy;Apple Computer Inc 1996, all rights reserved./*  Changes for 3.1 :    12-Oct-95 : CW : Cleaned up DoContent and added call to DoWindowContentDrag           Clean up CloseMyWindow and added call to RemoveDragHandlers           Added InstallDragHandlers call to NewDocument           Use HiliteControl on suspend/resume instead of Show/HideControl  1-Nov-95  : DS : Made Changes for GX Printing.  Changes for 4.0 :  17-Apr-96 : GS : Changed pascal calling conventions to C where possible.*/#include &lt;Scrap.h&gt;#include &lt;Packages.h&gt;#ifdef THINK_C  #include &quot;PLStrs.h&quot;#else  #include &lt;PLStringFuncs.h&gt;#endif#include &lt;GXPrinting.h&gt;#include &lt;PrintingMessages.h&gt;#include &quot;MSWindow.h&quot;#include &quot;MSMain.h&quot;#include &quot;MSDrag.h&quot;#include &quot;MSAERecording.h&quot;#include &quot;MSGXPrinting.h&quot;#include &quot;MSResultWind.h&quot;#include &quot;MSAEWindowUtils.h&quot;#define  kControlInvisible    0#define  kControlVisible      0xFF           #define  kScrollbarWidth      16#define  kScrollbarAdjust    (kScrollbarWidth - 1)#define  kScrollTweek      2#define  kTextOffset        5 #define  kButtonScroll      10      #define  kHOffset        20   // Stagger window offsets#define  kVOffset        20      #define  kTBarHeight        20#define  kMBarHeight        20#pragma segment WindowDPtr  DPtrFromWindowPtr(WindowPtr theWindow){  if ( theWindow &amp;&amp; IsDocumentWindow( theWindow ) )    return((DPtr)GetWRefCon(theWindow));  else    return(NULL);} // DPtrFromWindowPtr  #pragma segment main//  Scroll the TERec around to match up to the potentially updated scrollbar//  values. This is really useful when the window resizes such that the//  scrollbars become inactive and the TERec had been previously scrolled.void  AdjustTE( DPtr theDoc ){  short    h;  short    v;  TEHandle myText;    myText = theDoc-&gt;theText;  h = ((*myText)-&gt;viewRect.left - (*myText)-&gt;destRect.left) -  GetCtlValue(theDoc-&gt;hScrollBar) + kTextOffset;         v = ((*myText)-&gt;viewRect.top - (*myText)-&gt;destRect.top) -   GetCtlValue(theDoc-&gt;vScrollBar) + kTextOffset;             if (h || v)  {    TEScroll(h, v, theDoc-&gt;theText);    DrawPageExtras(theDoc);  }} // AdjustTE    // Calculate the new control maximum value and current value, whether it is the horizontal or// vertical scrollbar. The vertical max is calculated by comparing the number of lines to the// vertical size of the viewRect. The horizontal max is calculated by comparing the maximum document// width to the width of the viewRect. The current values are set by comparing the offset between// the view and destination rects. If necessary and we canRedraw, have the control be re-drawn by// calling ShowControl.// TEStyleSample-vertical max originally used line by line calculations-lineheight was a// constant value so it was easy to figure out what the range should be and pin the value// within range. Now we need to use max and min values in pixels rather than in nlines.#pragma segment mainvoid  AdjustHV( Boolean isVert, ControlHandle control, DPtr theDoc, Boolean canRedraw ){  TEHandle    docTE;  short       value;  short    max;  short    oldValue;  short    oldMax;  Rect    sizeRect;    GetRectOfPage( theDoc, &amp;sizeRect );  docTE    = theDoc-&gt;theText;    oldValue = GetCtlValue(control);  oldMax   = GetCtlMax(control);  if (isVert)  {      // new for TEStyleSample    max = TEGetHeight((*docTE)-&gt;nLines, 0, docTE) -             ((*docTE)-&gt;viewRect.bottom - (*docTE)-&gt;viewRect.top);    }  else    max = sizeRect.right - ((*docTE)-&gt;viewRect.right - (*docTE)-&gt;viewRect.left);        max += kTextOffset + kTextOffset; // Allow over scroll by kTextOffset        if (max &lt; 0)  max = 0; // check for negative values      SetCtlMax(control, max);    if (isVert)    value = (*docTE)-&gt;viewRect.top - (*docTE)-&gt;destRect.top;  else    value = (*docTE)-&gt;viewRect.left - (*docTE)-&gt;destRect.left;          value += kTextOffset;        if (value &lt; 0)    value = 0;  else    if (value &gt; max)      value = max; // pin the value to within range            SetCtlValue(control, value);  if (canRedraw &amp;&amp; ((max != oldMax) || (value != oldValue)))    ShowControl(control); // check to see if the control can be re-drawn} // AdjustHV#pragma segment Main// Simply call the common adjust routine for the vertical and horizontal scrollbars.void  AdjustScrollValues( DPtr theDoc, Boolean canRedraw ){          AdjustHV(true,  theDoc-&gt;vScrollBar, theDoc, canRedraw);  AdjustHV(false, theDoc-&gt;hScrollBar, theDoc, canRedraw);} // AdjustScrollValues// Return a rectangle that is inset from the portRect by the size of//  the scrollbars and a little extra margin.void  GetTERect( WindowPtr window, Rect *teRect ){  *teRect = window-&gt;portRect;  (*teRect).bottom -= kScrollbarAdjust; // and for the scrollbars  (*teRect).right  -= kScrollbarAdjust;} // GetTERect// Re-calculate the position and size of the viewRect and the scrollbars.//  kScrollTweek compensates for off-by-one requirements of the scrollbars//  to have borders coincide with the growbox.void  AdjustScrollSizes( DPtr theDoc ){    Rect    teRect;  Rect    myPortRect;    GetTERect(theDoc-&gt;theWindow, &amp;teRect); // start with teRect  myPortRect = theDoc-&gt;theWindow-&gt;portRect;    (*(theDoc-&gt;theText))-&gt;viewRect = teRect;    MoveControl(theDoc-&gt;vScrollBar, myPortRect.right - kScrollbarAdjust, - 1);  SizeControl(theDoc-&gt;vScrollBar,              kScrollbarWidth,                (myPortRect.bottom - myPortRect.top) - (kScrollbarAdjust - kScrollTweek));        MoveControl(theDoc-&gt;hScrollBar, - 1, myPortRect.bottom - kScrollbarAdjust);  SizeControl(theDoc-&gt;hScrollBar,              (myPortRect.right - myPortRect.left) - (kScrollbarAdjust - kScrollTweek),            kScrollbarWidth);} // AdjustScrollSizes#pragma segment Window// Turn off the controls by jamming a zero into their contrlVis fields//  (HideControl erases them and we don't want that). If the controls are to//  be resized as well, call the procedure to do that, then call the procedure//  to adjust the maximum and current values. Finally reset the controls//  to be visible if not in background.void  AdjustScrollbars( DPtr theDoc, Boolean  needsResize ){  (*(theDoc-&gt;vScrollBar))-&gt;contrlVis = kControlInvisible; // turn them off  (*(theDoc-&gt;hScrollBar))-&gt;contrlVis = kControlInvisible;    if (needsResize) // move and size if needed  AdjustScrollSizes(theDoc);    AdjustScrollValues(theDoc, !needsResize); // fool with max and current value    // Now, restore visibility in case we never had to ShowControl during adjustment    if (!gInBackground)  {    (*(theDoc-&gt;vScrollBar))-&gt;contrlVis = kControlVisible; // turn them on    (*(theDoc-&gt;hScrollBar))-&gt;contrlVis = kControlVisible;  }  else  {     // make sure they stay invisible    if ((*(theDoc-&gt;vScrollBar))-&gt;contrlVis)      HideControl(theDoc-&gt;vScrollBar);    if ((*(theDoc-&gt;vScrollBar))-&gt;contrlVis)      HideControl(theDoc-&gt;hScrollBar);  }} // AdjustScrollbars#pragma segment Windowvoid  GetWinContentRect( WindowPtr theWindow, Rect *r ){  *r         = theWindow-&gt;portRect;  r-&gt;right  -= kScrollbarAdjust;  r-&gt;bottom -= kScrollbarAdjust;} // GetWinContentRect  #pragma segment Window    void  InvalidateDocument( DPtr theDoc ){  GrafPtr oldPort;      GetPort(&amp;oldPort);  SetPort(theDoc-&gt;theWindow);  InvalRect(&amp;theDoc-&gt;theWindow-&gt;portRect);  SetPort(oldPort);}             // Called when the window has been resized to fix up the controls and content.void  ResizeWindow( DPtr theDoc ){  AdjustScrollbars(theDoc, true);  AdjustTE(theDoc);  InvalidateDocument(theDoc);} // ResizeWindow// Called when the window has been resized to fix up the controls and contentvoid  ResizePageSetupForDocument( DPtr theDoc ){  Rect pageRect;    GetRectOfPage( theDoc, &amp;pageRect );  (*(theDoc-&gt;theText))-&gt;destRect.right = (*(theDoc-&gt;theText))-&gt;destRect.left + pageRect.right;  TECalText(theDoc-&gt;theText);    ResizeWindow(theDoc);} // ResizePageSetupForDocument#pragma segment Main// Common algorithm for setting the new value of a control. It returns the actual amount//  the value of the control changed. Note the pinning is done for the sake of returning//  the amount the control value changed.void  CommonAction( ControlHandle control, short *amount ){  short   value;  short   max;    value   = GetCtlValue(control); // get current value  max     = GetCtlMax(control);  // and max value  *amount = value - *amount;  if (*amount &lt; 0)    *amount = 0;  else if (*amount &gt; max)    *amount = max;    SetCtlValue(control, *amount);  *amount = value - *amount;    // calculate true change} // CommonAction#pragma segment Main// Determines how much to change the value of the vertical scrollbar by and how//  much to scroll the TE record.pascal void VActionProc( ControlHandle control, short part ){  short           amount;  WindowPtr       window;  DPtr            theDoc;    if ( part )  {    window = (*control)-&gt;contrlOwner;    theDoc = DPtrFromWindowPtr(window);    switch (part)    {      case inUpButton:      case inDownButton:        amount = 24;        break;              case inPageUp:      case inPageDown:        amount = (*(theDoc-&gt;theText))-&gt;viewRect.bottom -                            (*(theDoc-&gt;theText))-&gt;viewRect.top;          break;    } // case        if (part == inDownButton || part == inPageDown)    amount = -amount; // reverse direction        CommonAction(control, &amp;amount);        if (amount)    {      TEScroll(0, amount, theDoc-&gt;theText);      DrawPageExtras(theDoc);    }  } // if} // VActionProc#pragma segment Main// Determines how much to change the value of the horizontal scrollbar by and how//  much to scroll the TE record.pascal void HActionProc(ControlHandle control, short part){  short      amount;  WindowPtr  window;  DPtr       theDoc;    if ( part )  {    window = (*control)-&gt;contrlOwner;    theDoc = DPtrFromWindowPtr(window);    switch ( part )    {      case inUpButton:      case inDownButton:        amount = kButtonScroll; // a few pixels        break;              case inPageUp:      case inPageDown:        amount = (*(theDoc-&gt;theText))-&gt;viewRect.right -               (*(theDoc-&gt;theText))-&gt;viewRect.left; // a page        break;    } // switch    if (part == inDownButton || part == inPageDown)    amount = - amount; // reverse direction        CommonAction(control, &amp;amount);    if (amount)    {      TEScroll(amount, 0, theDoc-&gt;theText);      DrawPageExtras(theDoc);    }  } // if} // HActionProc//    Name:       ShowSelect//    Purpose:    Scrolls the text selection into view.#pragma segment Windowvoid  ShowSelect( DPtr theDoc ){  AdjustScrollbars(theDoc, false);      //  Let TextEdit do the hard work of keeping the selection visible\xC9    TEAutoView(true, theDoc-&gt;theText);  TESelView(theDoc-&gt;theText);  TEAutoView(false, theDoc-&gt;theText);      //  Now rematch the text and the scrollbars\xC9    SetCtlValue(theDoc-&gt;hScrollBar,          (*(theDoc-&gt;theText))-&gt;viewRect.left -             (*(theDoc-&gt;theText))-&gt;destRect.left + kTextOffset);    SetCtlValue(theDoc-&gt;vScrollBar,          (*(theDoc-&gt;theText))-&gt;viewRect.top -             (*(theDoc-&gt;theText))-&gt;destRect.top  + kTextOffset);} // ShowSelect#pragma segment Windowvoid  OffsetWindow( WindowPtr aWindow ){  short  theWidth;  short  theHeight;  short  theHScreen;  short  theVScreen;  short  xWidth;  short  xHeight;  short  hMax;  short  vMax;  short  wLeft;  short  wTop;  long  docCount;     theWidth  = aWindow-&gt;portRect.right - aWindow-&gt;portRect.left;  theHeight = aWindow-&gt;portRect.bottom - aWindow-&gt;portRect.top + kTBarHeight;    theHScreen = qd.screenBits.bounds.right  - qd.screenBits.bounds.left;  theVScreen = qd.screenBits.bounds.bottom - qd.screenBits.bounds.top;    xWidth  = theHScreen - theWidth;  xHeight = theVScreen - (theHeight + kMBarHeight);    hMax = (xWidth / kVOffset) + 1;  vMax = (xHeight / kVOffset) + 1;    docCount = CountDocuments( );  if ( ! IsVisible( aWindow ) )    docCount++;    // Offset has been called on a window still hidden    wLeft = ( docCount % hMax ) * kVOffset;  wTop  = ( ( docCount % vMax ) * kVOffset ) + kTBarHeight + kMBarHeight;    MoveWindow(aWindow, wLeft, wTop, false);}/*// Returns the update region in local coordinates.void  GetLocalUpdateRgn( WindowPtr window, RgnHandle localRgn ){  CopyRgn(((WindowPeek)window)-&gt;updateRgn, localRgn); // save old update region  OffsetRgn(localRgn,        window-&gt;portBits.bounds.left,           window-&gt;portBits.bounds.top); // convert to local coords} // GetLocalUpdateRgn*/#pragma segment Windowvoid  MyGrowWindow( WindowPtr w, Point p ){  GrafPtr savePort;  long    theResult;  Rect    r;    GetPort(&amp;savePort);  SetPort(w);  SetRect(&amp;r, 80, 80, qd.screenBits.bounds.right, qd.screenBits.bounds.bottom);  theResult = GrowWindow(w, p, &amp;r);  if (theResult)    IssueSizeWindow(w, LoWord(theResult), HiWord(theResult));    SetPort(savePort);}#pragma segment Window// Because windows can be hidden we must check for menu changesvoid ShowMSWindow( WindowPtr theWindow ){  ShowWindow( theWindow );  if ( FrontWindow( ) == theWindow )  {    DoActivate( GetNthWindow( 2 ), false );    DoActivate( theWindow, true );  }  CheckMenus( );}void HideMSWindow( WindowPtr theWindow ){  Boolean    fActivate;  fActivate = ( FrontWindow( ) == theWindow );  HideWindow( theWindow );  if ( fActivate )  {    DoActivate( theWindow, false );    DoActivate( GetNthWindow( 1 ), true );  }    CheckMenus( );}#pragma segment Windowvoid  DoZoom( WindowPtr w, short c, Point p ){  GrafPtr savePort;    GetPort(&amp;savePort);  SetPort(w);  if (TrackBox(w, p, c))  {    EraseRect(&amp;w-&gt;portRect);    IssueZoomCommand(w, c);  }}#pragma segment Windowvoid  DoContent( WindowPtr theWindow, EventRecord theEvent ){  short      cntlCode;  short      part;  short      value;  ControlHandle  theControl;  GrafPtr      savePort;  Boolean      extend;  DPtr      theDoc;  Point      localPt;        GetPort ( &amp;savePort );    SetPort ( theWindow );    theDoc = DPtrFromWindowPtr ( theWindow );    localPt = theEvent.where;    GlobalToLocal ( &amp;localPt );    cntlCode = FindControl ( localPt, theWindow, &amp;theControl );  if ( cntlCode == 0 )  {    if ( UserWantsToDrag ( theWindow, theEvent.where ) )    {      if ( DoWindowContentDrag ( theWindow, &amp;theEvent ) )        TEClick ( localPt, false, theDoc-&gt;theText );    }    else    {      // only extend the selection if the shiftkey is down      extend = (theEvent.modifiers &amp; shiftKey);      if ( PtInDocument ( localPt, theDoc ) )        TEClick ( localPt, extend, theDoc-&gt;theText );    }  }    else if ( cntlCode == inThumb )  {    value = GetCtlValue(theControl);    part  = TrackControl(theControl, localPt, nil);    if (part)    {      value -= GetCtlValue(theControl);      if (value)      {        if (theControl == theDoc-&gt;vScrollBar)          TEScroll(0, value, theDoc-&gt;theText);        else          TEScroll(value, 0, theDoc-&gt;theText);        DrawPageExtras(theDoc);      }    }  }  else  {    if (theControl == theDoc-&gt;vScrollBar)      part = TrackControl(theControl, localPt, (ControlActionUPP) gVScrollActionUPP);    else      part = TrackControl(theControl, localPt, (ControlActionUPP) gHScrollActionUPP);  }  SetPort(savePort);}void  DoBackgroundContent( WindowPtr theWindow, EventRecord theEvent){  Point      thePoint;  GrafPtr      savePort;  RgnHandle    dragRgn;  DPtr            theDoc;    GetPort ( &amp;savePort );    SetPort ( theWindow );    theDoc = DPtrFromWindowPtr ( theWindow );  thePoint = theEvent.where;  GlobalToLocal ( &amp;thePoint );      dragRgn = NewRgn ( );  GetSelectedTextRgn ( theDoc, dragRgn );  if ( PtInRgn ( thePoint, dragRgn ) )  {    if ( DoWindowContentDrag ( theWindow, &amp;theEvent ) )      SelectWindow (theWindow );  }  else    SelectWindow ( theWindow );      SetPort ( savePort );  return;}#pragma segment WindowOSErr  DoActivate( WindowPtr theWindow, Boolean activate ){  Rect  r;  DPtr  theDoc;  OSErr err = noErr;      if (theWindow)    if (Ours(theWindow))    {      theDoc = DPtrFromWindowPtr(theWindow);      SetPort(theWindow);      DrawGrowIcon(theWindow);      GetWinContentRect(theWindow, &amp;r);      InvalRect(&amp;r);      if ( activate )      {        if ( theDoc-&gt;windowType == kOrdinaryWind )                      TEActivate(theDoc-&gt;theText);        HiliteControl ( theDoc-&gt;vScrollBar, 0 );        HiliteControl ( theDoc-&gt;hScrollBar, 0 );                SetMenuItemState ( false, myMenus[editM], undoCommand );        err = TEFromScrap();        CheckMenus( );      }      else      {        TEDeactivate( theDoc-&gt;theText );        HiliteControl ( theDoc-&gt;vScrollBar, 255 );        HiliteControl ( theDoc-&gt;hScrollBar, 255 );                err = ZeroScrap();        err = TEToScrap();      }    }  return err;}#pragma segment Windowvoid  GetPageEnds( short pageHeight, TEHandle theText,                PageEndsArray  pageBounds, short *nPages){  short  pageBase;      // total pixel offset of pages so far  short  thisLine;  short  lastLine;  short  pageSoFar;  short  thisPage;      // Current page being calced  short  thisLineH;     // Height of text line  short  pageFirstLine; // Line # of top of page      pageBase   = 0;  thisLine   = 1;  lastLine   = (*theText)-&gt;nLines;    thisPage   = 0;  pageSoFar  = 0;  while ((thisLine &lt;= lastLine) || (pageSoFar!=0))  {    pageFirstLine = thisLine;    thisLineH     = TEGetHeight(thisLine, thisLine, theText);        while ((thisLineH+pageSoFar&lt;pageHeight) &amp;&amp; (thisLine &lt;= lastLine))    {      pageSoFar += thisLineH;      thisLine++;      thisLineH = TEGetHeight(thisLine, thisLine, theText);    }          if (pageSoFar)    {      pageBounds[thisPage] = pageSoFar+pageBase;      pageBase  = pageBounds[thisPage];      thisPage++;      pageSoFar = 0;    }          //  Special case text line taller than page        if ((thisLine  == pageFirstLine) &amp;&amp;       (thisLineH &gt; pageHeight))      {        do {          pageBounds[thisPage] = pageBase+pageHeight;          pageBase   = pageBounds[thisPage];          thisPage  += 1;          thisLineH -= pageHeight;        } while (thisLineH &gt;= pageHeight);        pageSoFar = thisLineH;  // Carry bottom of large line to next page        thisLine += 1;       // carry xs on as pageSoFar and start measuring next line      }  }      *nPages = thisPage;} // GetPageEndsvoid  DrawPageBreaks( DPtr theDoc ){  PageEndsArray  pageEnds;  short         nPages;  short         ctr;  short         lineBase;  short         pageHeight;  Rect          viewRect;  Rect          pageRect;          GetRectOfPage( theDoc, &amp;pageRect );  pageHeight = pageRect.bottom - pageRect.top;        GetPageEnds(pageHeight, theDoc-&gt;theText, pageEnds, &amp;nPages);                      lineBase = (*(theDoc-&gt;theText))-&gt;destRect.top;  viewRect = (*(theDoc-&gt;theText))-&gt;viewRect;    PenPat(&amp;qd.gray);  for (ctr = 0; ctr&lt;nPages-1; ctr++)  {    MoveTo(viewRect.left, lineBase+pageEnds[ctr]);    LineTo(viewRect.right,lineBase+pageEnds[ctr]);  }  PenNormal();} // DrawPageBreaks    void  DrawPageExtras( DPtr theDoc ){  GrafPtr   oldPort;  RgnHandle  oldClip;  Rect      rectToClip;      GetPort(&amp;oldPort);  SetPort(theDoc-&gt;theWindow);        oldClip = NewRgn();  GetClip(oldClip);        GetWinContentRect(theDoc-&gt;theWindow,&amp;rectToClip);  ClipRect(&amp;rectToClip);              // and then the page breaks  DrawPageBreaks(theDoc);    SetClip(oldClip);    DisposeRgn(oldClip);    SetPort(oldPort);} // DrawPageExtrasvoid  DoUpdate( WindowPtr theWindow ){  GrafPtr    savePort;  Rect    rectClip;  DPtr    theDocument;      theDocument = DPtrFromWindowPtr ( theWindow );  if ( Ours ( theWindow ) )  {    GetPort ( &amp;savePort );    SetPort ( theWindow );    BeginUpdate ( theWindow );        ClipRect(&amp;theWindow-&gt;portRect);    EraseRect(&amp;theWindow-&gt;portRect);    DrawControls(theWindow);    DrawGrowIcon(theWindow);        GetWinContentRect(theWindow, &amp;rectClip);    ClipRect(&amp;rectClip);        TEUpdate(&amp;theWindow-&gt;portRect, theDocument-&gt;theText);        DrawPageExtras(theDocument);        EndUpdate(theWindow);    ClipRect(&amp;theWindow-&gt;portRect);        SetPort ( savePort );  }    return;} // DoUpdate#pragma segment WindowDPtr  NewDocument( Boolean isForOldDoc, WindowPtr behindWindow ){  Rect           destRect;  Rect           viewRect;  Rect           vScrollRect;  Rect           hScrollRect;  DPtr           myDoc;  WindowPtr      myWindow;  ControlHandle  vScroll;  ControlHandle  hScroll;  Str255         theName;  Str255         newNumber;  Rect           pageRect;  myDoc = nil;  myWindow = GetNewWindow(WindowID, nil, behindWindow);  if (myWindow)  {    if (isForOldDoc==false)    {      GetWTitle(myWindow, theName);      NumToString(++gNewDocCount, newNumber);      if (gNewDocCount&gt;1)      {        PLstrcat(theName, (unsigned char *)&quot;\p #&quot;);        PLstrcat(theName, newNumber);        SetWTitle(myWindow, theName);      }    }          OffsetWindow(myWindow);    SetPort(myWindow);    myDoc = (DPtr)NewPtr(sizeof(DocRec));    SetWRefCon(myWindow, (long)myDoc);    myDoc-&gt;theWindow  = myWindow;    myDoc-&gt;windowType = kOrdinaryWind;    vScrollRect = myWindow-&gt;portRect;    vScrollRect.left  = vScrollRect.right - kScrollbarAdjust;    vScrollRect.right = vScrollRect.left  + kScrollbarWidth;    vScrollRect.bottom = vScrollRect.bottom - 14;    vScrollRect.top    = vScrollRect.top - 1;        vScroll = NewControl(myWindow, &amp;vScrollRect, (unsigned char *)&quot;\pScrollBar&quot;, true, 0, 0, 0, scrollBarProc, 0);    hScrollRect = myWindow-&gt;portRect;    hScrollRect.top = hScrollRect.bottom - kScrollbarAdjust;    hScrollRect.bottom = hScrollRect.top + kScrollbarWidth;    hScrollRect.right = hScrollRect.right - 14;    hScrollRect.left  = hScrollRect.left - 1;    hScroll = NewControl(myWindow, &amp;hScrollRect, (unsigned char *)&quot;\pScrollBar&quot;, true, 0, 0, 0, scrollBarProc, 0);    myDoc-&gt;vScrollBar = vScroll;    myDoc-&gt;hScrollBar = hScroll;      myDoc-&gt;dirty = false;    GetTERect(myWindow, &amp;viewRect);    destRect = viewRect;    myDoc-&gt;theFont  = times;    myDoc-&gt;theStyle = 0;    myDoc-&gt;theSize  = 12;    myDoc-&gt;documentJob   = nil;    myDoc-&gt;thePrintSetup = nil;        if (gGXIsPresent)    {      if (GXNewJob(&amp;(myDoc-&gt;documentJob)) == noErr)        GXInstallApplicationOverride(myDoc-&gt;documentJob,                       gxPrintingEventMsg,                       NewGXPrintingEventProc(GXPrintingEventOverride));    }    else    {      myDoc-&gt;thePrintSetup = (THPrint)NewHandle(sizeof(TPrint));            PrOpen();      PrintDefault(myDoc-&gt;thePrintSetup);      PrClose();    }        GetRectOfPage( myDoc, &amp;pageRect );    destRect.right = destRect.left + pageRect.right;        OffsetRect(&amp;destRect, kTextOffset, kTextOffset);        TextFont(times);    TextSize(12);    TextFace(0);    myDoc-&gt;theText = TEStylNew(&amp;destRect, &amp;viewRect);// SetClikLoop(@AutoScroll, myDoc-&gt;theText);    myDoc-&gt;theFileName[0] = 0;    myDoc-&gt;everSaved      = false;    myDoc-&gt;theWindow      = myWindow;    ResizeWindow(myDoc);        InstallDragHandlers ( myWindow );        myDoc-&gt;theScriptID = kOSANullScript;  }  return(myDoc);}#pragma segment Windowvoid  CloseMyWindow( WindowPtr aWindow ){  DPtr     aDocument;  TEHandle theText;  if (IsThisResultWind(aWindow))    CloseResultWind(aWindow);  else  {    HideMSWindow(aWindow);    aDocument = DPtrFromWindowPtr(aWindow);        theText = aDocument-&gt;theText;    TEDispose(theText);        if (aDocument-&gt;thePrintSetup)      DisposHandle((Handle)aDocument-&gt;thePrintSetup);        if (aDocument-&gt;documentJob)      GXDisposeJob(aDocument-&gt;documentJob);        RemoveDragHandlers ( aWindow );        DisposPtr((Ptr)aDocument);      DisposeWindow(aWindow);  }}      //    Name     :  PrintWindow//    Function :  Prints the document supplied in theDoc. askUser controls interaction//                 with the user.//               //          Uses extra memory equal to the size of the textedit use in the //           printed document.  void  PrintWindow( DPtr theDoc, Boolean askUser ){  GrafPtr      oldPort;  TEHandle    printerTE;  TPPrPort    printerPort;  Rect      printView;  PageEndsArray   pageBounds;  short      nPages;  short      pageCtr;  Boolean      abort;  Rect      rectToClip;  TPrStatus    thePrinterStatus;  DialogPtr    progressDialog;  WindowPtr       tempWind;                 // Temp window to create TERec in   Rect            tempWindRect = {0,0,0,0}; // Bounds for temp window  abort = false;      //  Preserve the current port  GetPort(&amp;oldPort);  PrOpen();      if (askUser)    abort = !PrJobDialog(theDoc-&gt;thePrintSetup);        if (abort)  {    PrClose();    return;  }      progressDialog = GetNewDialog(1005, nil, (WindowPtr)-1);      DrawDialog(progressDialog);      printerPort = PrOpenDoc(theDoc-&gt;thePrintSetup, nil, nil);  SetPort((GrafPtr)printerPort);      // Create a temporary window(which is not shown)    tempWind = NewWindow( nil, &amp;tempWindRect, &quot;\p&quot;,                false, documentProc, (WindowPtr)-1, false, 0);    // Duplicate the text edit rec  printView = (*(theDoc-&gt;thePrintSetup))-&gt;prInfo.rPage;  DuplicateStyleTERec ( theDoc-&gt;theText, &amp;printerTE, &amp;printView, (GrafPtr)tempWind );    // Work out the offsets    (*printerTE)-&gt;destRect = printView; // GetPageEnds calls TECalText      GetPageEnds(printView.bottom-printView.top,              printerTE,              pageBounds,              &amp;nPages);      TEDeactivate(printerTE);    // Set the TERec to the printer port  (*printerTE)-&gt;inPort = (GrafPtr)printerPort;    for (pageCtr = 0; pageCtr &lt;= nPages-1; pageCtr++)    if (!abort)    {      PrOpenPage(printerPort, nil);                          rectToClip = printView;            if (pageCtr &gt; 0)        rectToClip.bottom = rectToClip.top + (pageBounds[pageCtr]-pageBounds[pageCtr-1]);      else        rectToClip.bottom = rectToClip.top + pageBounds[pageCtr];              ClipRect(&amp;rectToClip);            if (PrError() == iPrAbort)        abort = true;              if (! abort)        TEUpdate(&amp;printView, printerTE);                        if (PrError() == iPrAbort)        abort = true;              PrClosePage(printerPort);            TEScroll(0,rectToClip.top-rectToClip.bottom, printerTE);    }    TEDispose(printerTE);  DisposeWindow ( tempWind );  PrCloseDoc(printerPort);    if (( (*(theDoc-&gt;thePrintSetup))-&gt;prJob.bJDocLoop == bSpoolLoop ) &amp;&amp;       ( PrError() == noErr ) &amp;&amp; (! abort))    PrPicFile( theDoc-&gt;thePrintSetup, nil, nil, nil, &amp;thePrinterStatus);    PrClose();    DisposDialog(progressDialog);    SetPort(oldPort);  InvalRect(&amp;oldPort-&gt;portRect);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MenuScripter/listing75.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MenuScripter/listing75.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MenuScripter/listing75.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>