<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1043: On Drag Manager Additions (Release 1.1)</title>       <meta name="keywords" content="Mac OS 8 Drag Manager additions translucent GetDragHiliteColor SetDragImage gestalt">    <meta name="Description" content="Technical Note TN1043: This Technical Note details some ofthe features of the Drag Manager. Included are the gestaltcalls for detecting new Drag Manager behavior, a discussionof translucent dragging, the DragManagerAdditions.h file,the DragManagerAdditions.c file, and sample code that performsa translucent drag with a picture."><meta name="categories" content="Human Interface Toolbox"><meta name="week-posted" content="Apr 29, 1996 - May 3, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002885" title="On Drag Manager Additions (Release 1.1)"></a><A NAME="top"></A> <!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxHumanInterfaceToolbox-date.html">Human Interface Toolbox</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1043</div>
<div id="pageheadsub">On Drag Manager Additions (Release 1.1)</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><span id="menutitle">    CONTENTS     <BR>    <BR></span>    </td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><P id = "menutext"><A HREF = "#detect">Detecting New Drag Manager Behavior</A><BR><BR><A HREF = "#RTFToC1">Translucent Dragging -- Why &amp;   When</A><BR><BR><A HREF = "#RTFToC2">Appropriate Uses of Translucent   Dragging</A><BR><BR><A HREF = "#RTFToC5">Summary</A><BR><BR>   <A HREF = "#References">References</A><BR><BR><A HREF = "#RTFToC6">Appendix A: Interfaces and   Libraries</A><BR><BR><A HREF = "#RTFToC7">Appendix A1:    "DragManagerAdditions.h"</A><BR><BR><A HREF = "#RTFToC8">Appendix A2:    "DragManagerAdditions.c"</A><BR><BR>   <A HREF = "#RTFToC9">Appendix B: Sample Code for Performing a<BR>   Translucent Drag with a Picture</A><BR><BR>   <A HREF = "#changes">Change History</a><br><br><A HREF="#Downloads">Downloadables</A></P>   <!-- end_toc -->  </td></tr><tr>    <td width=300 align=left scope="row"><img src="images/tnmenubottom.gif" alt="" width=300 height=16>    </td></tr>    </table></td><td width=300 valign="top" align=left><!-- begin_intro_text --> <P id = "introtext">Since Drag Manager 1.0, two new calls have been added and threenew Gestalt response bits have been defined.</P><P id = "introtext">One new call obtains the drag highlight color. The other enablesthe user to drag translucent images. (For an example of thetranslucent dragging effect, see the Finder in System 7.5.3.)</P><P id = "introtext">The new Gestalt bits describe Text Services Manager windowcompatibility, PowerPC library availability, and the availability oftranslucent dragging.</P><P id = "introtext">This Technote is intended for Macintosh developers who need totake advantage of these new features.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Mar 1 1997]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR> <!-- begin_content --><P><A NAME="detect"></A></P><H2>Detecting New Drag Manager Behavior</H2><P>There are three new bits defined in the Gestalt response value forthe gestaltDragMgrAttr selector code. If your application uses theDrag Manager, it should already be calling Gestalt with this selectorcode and testing the gestaltDragMgrPresent bit; testing theseadditional bits should be similar.</P><CODE>gestaltDragMgrFloatingWind</CODE><BLOCKQUOTE><P>Denotes support for Text Services Manager floating windows.     In order to receive a drag, such windows must have their own     handlers; they cannot rely on a global handler. When this bit     is not set, neither sending nor receiving drags will work properly.</p></BLOCKQUOTE>    <CODE>gestaltPPCDragLibPresent</CODE>    <BLOCKQUOTE><P>Denotes whether there is a PowerPC CFM shared library     available for Drag Manager. PowerPC applications should attempt     to establish a connection (perhaps implicitly via a "weak" link) to the     library DragLib before testing this bit.</p></BLOCKQUOTE>    <CODE>gestaltDragMgrHasImageSupport</CODE>    <BLOCKQUOTE><P>Denotes the availability of SetDragImage and GetDragHiliteColor.     Although support for translucency is limited by hardware (see below),     it is safe for your application to call SetDragImage as long as Gestalt     indicates that it is available.</P></BLOCKQUOTE><P><A HREF="#top">Back to top</A></P><P><A NAME="RTFToC1"></A></P><H2>Translucent Dragging -- Why &amp; When</H2><P>Before Color QuickDraw, highlighting graphics on the Macintosh wasrestricted to inversion, a quick and effective operation. ColorQuickDraw introduced a highlighting scheme for color images based onsimple color substitution. On Macs with PowerPC processors, runningSystem 7.5.3, it has become possible for system software to furtherenhance the user experience.</P><H3>The User Experience of Translucent Dragging</H3><P>In Figure 1, the user has clicked on the trash icon, highlightingit. Then the user has held down the mouse button, dragging thetranslucent image of the icon up and to the left on the desktop.</P><center><img src="images/tn1043_003.gif" align=bottom alt="" width=118 height=107><BR><P><B>Figure 1: </B> Translucent dragging on the desktop</P></center><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> If you're looking at this document in black and white, you'll   have to imagine the lower right image to be opaque as normal and   the upper left image to be somewhat less visually substantial --   in a word, translucent.</P></TD></TR></TABLE></CENTER><BR>   <P>Apple is actively working to find a practical use for translucentdragging.</P><H3>Requirements for Translucent Dragging</H3><P>Translucent dragging is only supported on Macintosh computers withPowerPC processors. There are several reasons for this, specificallyan improved PowerPC-native Color QuickDraw, and the enhancedcalculation and execution speed provided by PowerPC processors.</P><P>In addition to PowerPC-only support, there are other requirementsfor translucency, including the following: </P><UL>   <LI>Monitors must be set to display at least 8 bits of color.</li>      <LI>8-bit monitors on multiple-monitor systems must have color   tables containing only colors that can be saved and restored using   a 24-bit color space.</li>      <LI>8-bit monitors can't have color tables containing animated   entries or a narrow range of colors.</li>      <LI>Video mirroring must be disabled.</li></UL><P>If the Drag Manager determines that translucency can't be done, itwill revert to inverted outline dragging for one or more screens.</P><P><A NAME="RTFToC2"></A></P><P><A HREF="#top">Back to top</A></P><H2>Appropriate Uses of Translucent Dragging</H2><P>Translucency is not appropriate for every drag. Applicationsshould use the effect sparingly, and, in general, only small,single-item graphics such as icons should be dragged translucently.Large or multi-part images such as pictures or groups of icons maybecome distracting for users. If the image is too large, a user'sattention may be diverted from the task of finding the destination ofthe drag.</P><P>In addition, large images may not drag smoothly. Even two iconsrendered in a PixMap constitute a large image if those icons are farapart within the PixMap.</P><P>Text and some other non-graphic elements are also not goodcandidates for translucent dragging. Dragging text may appearcluttered or too busy on the screen, and thus become more distractingfor the user. Use the older outline dragging for these drags.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>While the Drag Manager will not allow translucency when the   environment does not permit it, such as on 8-bit monitors with   altered color tables, it can't prevent translucency from being   used when it is inappropriate. Design your program to use   translucent dragging only when it's appropriate. Consider   following the example of the Finder and combining dragging of a   small image with outlines for other items in the drag.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="RTFToC4"></A></P><H2>Reference</H2><H3>DragImageFlags</H3><P>DragImageFlags is a 32-bit set of flags used to specify theappearance of a translucent drag. Here are a type declaration andvalid values for DragImageFlags: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef unsigned long DragImageFlags;enum{    dragStandardImage            = 0x00000000,    dragDarkImage                = 0x00000001,    dragDarkerImage                = 0x00000002,    dragOpaqueImage                = 0x00000003,    dragRegionAndImage            = 0x00000010};</pre>	</TD></TR></TABLE></CENTER><P>Four darkness values are permitted, ranging from the standard,Apple-recommended darkness used by Finder (approximately 35% blendingof the image with the background) to a near-opaque setting. Thecaller can add the constant dragRegionAndImage to the darkness valueto specify that the outline region passed to TrackDrag should bedrawn on the screen in addition to the translucent image. Without thedragRegionAndImage constant, the Drag Manager draws the outline onlyon screens that cannot support translucency.</P><H3>SetDragImage</H3><P>SetDragImage associates an image with a DragReference. UponTrackDrag, a translucent version of the image will follow the cursor.SetDragImage is defined as follows: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr SetDragImage (    DragReference    theDragRef,                PixMapHandle    imagePixMap,                RgnHandle    imageRgn,                Point    imageOffsetPt,                DragImageFlags    theImageFlags    );imagePixMap    A standard PixMapHandle. The Drag Manager will        temporarily lock the PixMapHandle during the drag        if necessary. Not copied into the DragReference. See below.imageRgn    A mask for the PixMap describing the portion of        the PixMap which contains the image. Pass nil for        imageRgn if the entire rectangular PixMap, including        white space, is to be dragged. Not copied into the DragReference. See below.imageOffsetPt    The offset required to move the imagePixMap to the        global coordinates where the image initially appears.        If imageOffsetPt is {0,0}, the imagePixMap should        already be in global coordinates.theImageFlags    A set of drag image flags as described above.<B></B></pre>	</TD></TR></TABLE></CENTER><P><B>DESCRIPTION</B></P><P>To determine if SetDragImage is available, call Gestalt with theselector gestaltDragMgrAttr. If the gestaltDragMgrHasImageSupport bitof the response is set, the SetDragImage call can be made safely.</P><P>SetDragImage should be called by the sending application prior tocalling TrackDrag. Prior to calling SetDragImage, the applicationshould draw into imagePixMap a solid, opaque image. The Drag Managerwill provide the translucency effects. Typically, your applicationwill obtain imagePixMap by calling GetGWorldPixMap and supplying aGWorld into which your app has drawn the image.</P><P>To allow the Drag Manager to analyze the PixMap's colors in orderto determine if it can be rendered on the available screens, Applerecommends using an 8-bit GWorld for the imagePixMap.</P><P><B>SPECIAL CONSIDERATIONS</B></P><P>SetDragImage installs a custom drawing procedure to do thetranslucent drawing. Applications calling SetDragImage should notalso call SetDragDrawingProc for the same drag.</P><P>SetDragImage does not copy the imagePixMap and imageRgn parameterdata. Until TrackDrag completes, you must ensure the data to whichthese parameters refer continues to exist.</P><P><B>ERRORS</B></P><P>Four new result codes have been defined for SetDragImage: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum{    unsupportedForPlatformErr = -1858,        // call is for PowerPC only    noSuitableDisplaysErr = -1859,        // no displays support translucency    badImageRgnErr = -1860,        // bad translucent image region    badImageErr = -1861        // bad translucent image PixMap};</pre>	</TD></TR></TABLE></CENTER><H3>GetDragHiliteColor</H3><P>To determine the color the Drag Manager will use for a particularwindow, call GetDragHiliteColor. GetDragHiliteColor can safely becalled when the gestaltDragMgrHasImageSupport bit is set in the Gestaltresponse to the selector gestaltDragMgrAttr.</P><CODE>pascal OSErr GetDragHiliteColor (WindowPtr window, RGBColor *color);</CODE><P><B>SPECIAL CONSIDERATIONS</B></P><P>The Drag Manager chooses an appropriate color for hilighting,depending on the colors available in the color table for the window.Limitations on the choice of available colors are described inMacintosh Technical Note <A HREF = "../tb/tb_33.html">TB 33 - Color,Windows and 7.0</A>.</P><P><A HREF="#top">Back to top</A></P><P><A NAME="RTFToC5"></A></P><H2>Summary</H2><P>The new Drag Manager Gestalt response bits have been defined. Testthe gestaltDragMgrFloatingWind bit to determine the availability ofText Services Manager Support. Test the gestaltPPCDragLibPresent bitto determine whether the CFM library DragLib has been prepared. Testthe gestaltDragMgrHasImageSupport bit to determine whethertranslucent dragging is supported.</P><P>Two new Drag Manager calls enable your app to obtain the draghighlight color and perform translucent dragging. Use SetDragImage tospecify a PixMap to be transformed into a translucent image fordisplay during dragging. Be careful to observe the human interfaceprinciples outlined in this Note. Use GetDragHiliteColor to obtainthe color used for drag highlighting.</P><P><A HREF="#top">Back to top</A></P><A NAME="References"></a><H2>References</h2><UL>   <LI><I>Drag Manager Programmer's Guide</I></li>      <LI><I>Inside Macintosh: Imaging with QuickDraw</I></li></UL><P><A HREF="#top">Back to top</A></P><P><A NAME="RTFToC6"></A></P><H2>Appendix A: Interfaces and Libraries</H2><P>As of June 6, 1996, there is no constant forgestaltDragMgrHasImageSupport defined in &lt;Drag.h&gt; and there are nointerfaces or CFM library glue for calling SetDragImage andGetDragHiliteColor. However, in Appendix A1, we provide interfaces you canuse in C and C++ programs, and in Appendix A2, we provide a libraryyou can compile with a C or C++ compiler and call from C, C++, andPascal. You need to compile and link the library module into yourprogram if your program is CFM-based (PowerPC or CFM-68K). If youcompile the library source into a non-CFM project accidentally, itwill automatically render itself invisible.</P><P><A NAME="RTFToC7"></A></P><P><A HREF="#top">Back to top</A></P><H2>Appendix A1: "DragManagerAdditions.h"</H2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#pragma once#ifndef __DRAG__#   include &lt;Drag.h&gt;#endifenum{    _DragDispatch = 0xABED};enum{    gestaltDragMgrHasImageSupport = 3};enum{    unsupportedForPlatformErr   = -1858,        // call is for PowerPC only    noSuitableDisplaysErr       = -1859,        // no displays support translucency    badImageRgnErr              = -1860,        // bad translucent image region    badImageErr                 = -1861        // bad translucent image PixMap};typedef unsigned long DragImageFlags;enum{    dragStandardImage   = 0x00000000,    dragDarkImage       = 0x00000001,    dragDarkerImage     = 0x00000002,    dragOpaqueImage     = 0x00000003,    dragRegionAndImage  = 0x00000010};#ifdef __cplusplusextern "C" {#endifpascal OSErr SetDragImage ( DragReference   theDragRef,                            PixMapHandle    imagePixMap,                            RgnHandle       imageRgn,                            Point           imageOffsetPt,                            DragImageFlags  theImageFlags   )    TWOWORDINLINE (0x7027, 0xABED);pascal OSErr GetDragHiliteColor    (WindowPtr window, RGBColor *color)        TWOWORDINLINE (0x7026, 0xABED);#ifdef __cplusplus}#endif</pre>	</TD></TR></TABLE></CENTER><P><A NAME="RTFToC8"></A></P><P><A HREF="#top">Back to top</A></P><H2>Appendix A2: "DragManagerAdditions.c"</H2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#define SystemSevenFiveOrLater  1#define CGLUESUPPORTED          0#define OLDROUTINENAMES         0#define OLDROUTINELOCATIONS     0#define STRICT_WINDOWS          1#ifndef __CONDITIONALMACROS__#   include &lt;ConditionalMacros.h&gt;#endif#if GENERATINGCFM    //    // If we're not generating CFM, then assume the    // 68K inlines in the headers apply instead.    //#include "DragManagerAdditions.h"    // if missing, see Appendix A1, Technote 1043pascal OSErr SetDragImage ( DragReference   theDragRef,                            PixMapHandle    imagePixMap,                            RgnHandle       imageRgn,                            Point           imageOffsetPt,                            DragImageFlags  theImageFlags   ){    enum    {        uppSetDragImageInfo = kD0DispatchedPascalStackBased            | RESULT_SIZE (SIZE_CODE (sizeof(OSErr)))            | DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE                  (SIZE_CODE (sizeof (unsigned long)))            | DISPATCHED_STACK_ROUTINE_PARAMETER                  (1, SIZE_CODE (sizeof (theDragRef)))            | DISPATCHED_STACK_ROUTINE_PARAMETER                  (2, SIZE_CODE (sizeof (imagePixMap)))            | DISPATCHED_STACK_ROUTINE_PARAMETER                  (3, SIZE_CODE (sizeof (imageRgn)))            | DISPATCHED_STACK_ROUTINE_PARAMETER                  (4, SIZE_CODE (sizeof (imageOffsetPt)))            | DISPATCHED_STACK_ROUTINE_PARAMETER                  (5, SIZE_CODE (sizeof (theImageFlags)))    };    return CallUniversalProc (        GetToolTrapAddress (_DragDispatch),        uppSetDragImageInfo, 0x27L, theDragRef, imagePixMap,        imageRgn, imageOffsetPt, theImageFlags);}pascal OSErr GetDragHiliteColor (WindowPtr window, RGBColor *color){    enum    {        uppGetDragHiliteColorInfo =            kD0DispatchedPascalStackBased                | RESULT_SIZE (SIZE_CODE (sizeof(OSErr)))                | DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE                    (SIZE_CODE (sizeof (unsigned long)))                | DISPATCHED_STACK_ROUTINE_PARAMETER                    (1, SIZE_CODE (sizeof (window)))                | DISPATCHED_STACK_ROUTINE_PARAMETER                    (2, SIZE_CODE (sizeof (color)))    };    return CallUniversalProc (        GetToolTrapAddress (_DragDispatch),            uppGetDragHiliteColorInfo, 0x26L, window, color);}#endif // GENERATINGCFM</pre>	</TD></TR></TABLE></CENTER><P><A NAME="RTFToC9"></A></P><P><A HREF="#top">Back to top</A></P><H2>Appendix B: Sample Code for Performing a Translucent Drag with aPicture</H2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#ifndef __QDOFFSCREEN__#   include &lt;QDOffscreen.h&gt;#endif#ifndef __GESTALT__#   include &lt;Gestalt.h&gt;#endif#ifndef __EVENTS__#   include &lt;Events.h&gt;#endif#ifndef __WINDOWS__#   include &lt;Windows.h&gt;#endif#ifndef __QUICKDRAW__#   include &lt;QuickDraw.h&gt;#endif#include "TranslucentDragSample.h"    // just a prototype for MyDoPictureDrag#include "DragManagerAdditions.h"    // if missing, see Appendix A1, Technote 1043pascal OSErr MyDoPictureDrag (  const EventRecord   *theEvent,                                WindowPtr           theWindow,                                PicHandle           thePicture  ){    OSErr               err;    DragReference       theDrag;    GWorldPtr           imageGWorld;    PixMapHandle        imagePixMap;    Rect                imageRect;    Rect                dragBounds;    RgnHandle           dragRgn;    RgnHandle           tempRgn;    RgnHandle           imageRgn;    RgnHandle           contRgn;    ItemReference       theItem;    char                saveHState;    long                response;    CGrafPtr            savePort;    Point               offsetPt;    GDHandle            saveDevice;    //    //  initialize values to allow for safe and easy    //  clean-up    //    theDrag         = 0;    imageGWorld     = nil;    dragRgn         = nil;    tempRgn         = nil;    imageRgn        = nil;    contRgn         = nil;    GetGWorld(&amp;savePort, &amp;saveDevice);    //    //  create a new drag    //    err = NewDrag(&amp;theDrag);    if (err != noErr) goto Bail;    //    //  add the picture data to the drag    //    saveHState = HGetState((Handle) thePicture);    HLock ((Handle) thePicture);    theItem = 1;    err = AddDragItemFlavor(theDrag, theItem, 'PICT',        *thePicture, GetHandleSize((Handle) thePicture), 0);    HSetState ((Handle) thePicture, saveHState);    if (err != noErr) goto Bail;    //    //  get the bounding rect of the picture and relocate    //  it to 0,0    //    imageRect = (**thePicture).picFrame;    SetPt (&amp;offsetPt, imageRect.left, imageRect.top);    OffsetRect (&amp;imageRect, -imageRect.left, -imageRect.top);    //    //  since our imageRect is based at 0,0, find    //  the global offset of the image    //    SetPort (theWindow);    LocalToGlobal (&amp;offsetPt);    SetPort ((GrafPtr) savePort);    //    //  check if the Drag Manager supports image dragging    //    err = Gestalt(gestaltDragMgrAttr, &amp;response);    if (err == noErr &amp;&amp; (response &amp; (1L &lt;&lt; gestaltDragMgrHasImageSupport)))    {        //        //  allocate a GWorld to hold the image; it is        //  okay if the pixels are in the app heap or        //  in temp memory        //        err = NewGWorld            (&amp;imageGWorld, 8, &amp;imageRect, nil, nil, useTempMem);        if (err)            err = NewGWorld (&amp;imageGWorld, 8, &amp;imageRect, nil, nil, 0);        if (err == noErr)        {            //            //  get the pixel map from the GWorld for:            //            //      [1] LockPixels before drawing            //      [2] SetDragImage            //            imagePixMap = GetGWorldPixMap(imageGWorld);            //  draw the picture into the GWorld            SetGWorld(imageGWorld, nil);            (void) LockPixels(imagePixMap);                //  LockPixels always returns true for                //  non-purgeable pixels            EraseRect (&amp;imageGWorld-&gt;portRect);            DrawPicture(thePicture, &amp;imageRect;));            UnlockPixels(imagePixMap);            SetGWorld(savePort, saveDevice);            //            //  allocate and set the region that            //  identifies the part of the image            //  being dragged            //            imageRgn = NewRgn();            if (imageRgn == nil)                err = MemError ( );            else            {                RectRgn (imageRgn, &amp;imageRect);                //  attach the image to the drag                err = SetDragImage (theDrag, imagePixMap, imageRgn,                    offsetPt, dragStandardImage);            }        }        //        //  Translucency is not critical, so errors which        //  occur during any of the enclosed code are not fatal;        //  we've only bothered to assign 'err' to see its value        //  in the debugger.        //        err = noErr;    }    //    //  set the bounds and region for the drag using the    //  window's content rectangle and the imageRect in    //  its global location    //    dragBounds = imageRect;    OffsetRect(&amp;dragBounds, offsetPt.h, offsetPt.v);    contRgn = NewRgn ( );    if (contRgn == nil)    {        err = MemError ( );        goto Bail;    }    GetWindowContentRgn (theWindow,contRgn);    SectRect (&amp;((**contRgn).rgnBBox), &amp;dragBounds, &amp;dragBounds);    err = SetDragItemBounds(theDrag, theItem, &amp;dragBounds);    if (err != noErr) goto Bail;    //    //  make a drag region outlining the image for screens    //  on which translucency isn't possible    //    dragRgn = NewRgn();    if (dragRgn == nil)    {        err = MemError ( );        goto Bail;    }    RectRgn(dragRgn, &amp;dragBounds);    tempRgn = NewRgn();    if (tempRgn == nil)    {        err = MemError ( );        goto Bail;    }    CopyRgn(dragRgn, tempRgn);    InsetRgn(tempRgn, 1, 1);    DiffRgn(dragRgn, tempRgn, dragRgn);    //    //  finally, do the drag    //    err = TrackDrag(theDrag, theEvent, dragRgn);Bail:    if (theDrag)(void)  DisposeDrag     (theDrag);    if (imageGWorld)    DisposeGWorld   (imageGWorld);    if (dragRgn)        DisposeRgn      (dragRgn);    if (tempRgn)        DisposeRgn      (tempRgn);    if (imageRgn)       DisposeRgn      (imageRgn);    if (contRgn)        DisposeRgn      (contRgn);    return err;}</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name="changes"></a><h2>Change History</h2>         <P>Add this section if there are changes. If you're writing         a new technote, then you can remove this section.</P>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-May-1996</P>               </TD>               <td align="left">                  <P>Originally published May 1996.</p>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-June-1996</P>               </TD>               <td align="left">                  <P>Added information on Gestalt response bits.<br>Added CFM interfaces and libraries.<br>Improved error-handling in sample code.</p>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-August-1996</P>               </TD>               <td align="left">                  <P>Added warning to preserve parameters to <code>SetDragImage</code>.</p>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-March-1997</P>               </TD>               <td align="left">                  <p>Refreshed HTML version of sample code from qualifying project.<br>Made descriptions of <code>gestaltDragMgrHasImageSupport</code> consistent.<br>Used the correct name of <code>GetDragHiliteColor</code> in all cases.<br>Changed some cosmetics in the description of Gestalt bits.</p>               </TD>            </TR>                        </table><P><A HREF="#top">Back to top</A></P>          <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (72K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1043.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1043.html%3Fid%3DDTS10002885-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1043.html%3Fid%3DDTS10002885-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1043.html%3Fid%3DDTS10002885-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>