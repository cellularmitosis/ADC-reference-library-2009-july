<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Porting to Mac OS X from Windows Win32 API: Drawing 2D Graphics in Mac OS X</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Drawing 2D Graphics in Mac OS X"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20002355" title="Drawing 2D Graphics in Mac OS X"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000431" target="_top">Porting</a> &gt; <a href="../../../Windows-date.html#//apple_ref/doc/uid/TP30000440-TP30000431-TP30000593" target="_top">Windows</a> &gt; <a href="../index.html" target="_top">Porting to Mac OS X from Windows Win32 API</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../win32porting.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="3dgraphics.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20002355-BABCFCIB" title="Drawing 2D Graphics in Mac OS X"></a> <hr /><H1>Drawing 2D Graphics in Mac OS X</H1>  <p>2D graphics are a big part of most applications. Except for the parts of a window drawn automatically by the user interface, you are responsible for drawing everything in your application's window. The portion of the Win32 API devoted to the Graphic Device Interface (abbreviated here as the Win32/GDI) provides routines that are analogous to those provided by QuickDraw (Apple's original graphic drawing environment for the Mac OS), but they are structured differently.</p> <p>Since this Guide is written for programmers porting existing Win32/GDI code to Mac OS X, this document concentrates on explaining the QuickDraw API, the Mac OS X API that is the closest structurally to your existing code. However, depending on your situation, you may want to consider using the more powerful Quartz 2D API. See "Introduction to Quartz 2D," later in this document, for a brief description of Quartz 2D and a summary of its advantages, which include vector-based, resolution-independent graphics, sophisticated drawing based on paths and complex transformations, and built-in support for creating PDF documents.</p> 
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="2dgraphics.html#//apple_ref/doc/uid/20002355-96878">A Caveat</a>
				
			<br/>
			
        
			
			
				<a href="2dgraphics.html#//apple_ref/doc/uid/20002355-96912">The Mac OS X Graphics Architecture</a>
				
			<br/>
			
        
			
			
				<a href="2dgraphics.html#//apple_ref/doc/uid/20002355-97089">Comparing Win32/GDI and QuickDraw</a>
				
			<br/>
			
        
			
			
				<a href="2dgraphics.html#//apple_ref/doc/uid/20002355-99913">An Introduction to Quartz 2D</a>
				
			<br/>
			
        
			
			
				<a href="2dgraphics.html#//apple_ref/doc/uid/20002355-100050">Notes for Win32 Programmers</a>
				
			<br/>
			
        
			
			
				<a href="2dgraphics.html#//apple_ref/doc/uid/20002355-100212">For Further Information</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20002355-96878" title="A Caveat"></a> <h2>A Caveat</h2> <p>This Guide is primarily concerned with the Win32/GDI API and Apple's QuickDraw API, both of which are well over 15 years old. During this time, these two APIs have evolved to provide graphics capabilities that have repeatedly tested the limits of the day's computers. The capabilities of both computers and their video displays have increased by more than a factor of 100 since these two drawing environments were created. This means that both of them are complicated by routines and concepts that, being outdated, clutter the API landscape and make it more difficult to describe how to move Win32/GDI drawing code to the Mac OS X platform.</p> <p>Because of these limiting factors, this document necessarily omits some aspects of both drawing environments, especially those that are no longer in common use. For the sake of clarity, this document ignores certain special-case situations and simplifies certain details. For example, this document ignores the subject of indexed color, since virtually all computers now display 16 or 24-bit "direct" color. Also, this document refers to both device-dependent bitmaps (DDBs) and device-independent bitmaps (DIBs) as "bitmaps," and it does not mention how both platforms automatically map a "pure" color into the closest equivalent available on the display device being used.</p>  <a name="//apple_ref/doc/uid/20002355-96912" title="The Mac OS X Graphics Architecture"></a> <h2>The Mac OS X Graphics Architecture</h2> <p>The core portion of the Mac OS X graphics and windowing environment is called Quartz. To achieve various benefits (including implementation of backward compatibility), Quartz is implemented in two pieces, a rendering API (Quartz 2D) and a window server (Quartz Compositor). This modularity enables Quartz 2D to coexist with other APIs, one of which is QuickDraw, the API that you are most likely to use when you port your Win32 application to Mac OS X.</p> <a name="//apple_ref/doc/uid/20002355-96928" title="Quartz 2D and QuickDraw"></a> <h3>Quartz 2D and QuickDraw</h3> <p>The core of the Mac OS X drawing and windowing architecture is called Quartz. It has two pieces:</p> <ul class="spaceabove"> <li class="li"> <p>Quartz 2D--one of several graphics libraries that provide 2D text- and graphics-rendering services</p> </li> <li class="li"> <p>Quartz Compositor--the window server and Quartz Extreme, the component that interfaces to the computer's graphics-acceleration hardware</p> </li> </ul> <p>As you can see from the diagram below, QuickDraw is one of the graphics rendering libraries that you can use for drawing graphics under Mac OS X.</p> <br/><div> <img src = "../art/2dgr-architecture.gif" alt = "image: ../art/2dgr-architecture.gif" width="483" height="300"> </div><br/> <p> Under Mac OS X, QuickDraw thinks it is drawing directly to the graphics memory, just as it did in the earlier versions of Mac OS. In actuality, though, it is drawing to an off-screen graphics buffer. The Quartz Compositor combines this off-screen buffer with other graphics information (for example, soft-edge shadows and window transparency information) to produce the final pixmap. The Quartz Compositor delivers the final graphics image to the graphics hardware in a way that minimizes the delay in displaying changes to the screen, while maintaining the highest possible image quality (by preventing screen flicker and other visual artifacts).</p> <div class="notebox"><a name="//apple_ref/doc/uid/20002355-SW2" title="Note "></a> <p><strong>Note :</strong>&nbsp; In older Mac OS X documentation, Quartz 2D is referred to as the Core Graphics Rendering component of Quartz, while the Quartz Compositor is referred to as the Core Graphics Services component of Quartz.</p> </div>  <a name="//apple_ref/doc/uid/20002355-97060" title="Color QuickDraw"></a> <h3>Color QuickDraw</h3> <p>Just as the Win32 platform added new graphics capabilities as display hardware became more powerful, so did the Mac OS platform. The original QuickDraw, which handled only one-bit black-and-white graphics, was replaced by the more powerful Color QuickDraw, which handles both indexed and direct color graphics. The Color QuickDraw API is an almost perfect superset of the original QuickDraw API, though some irregularities exist.</p> <p> <em>Inside Macintosh: Imaging with QuickDraw</em> is the reference book you will use for learning QuickDraw. In it, the section on Color QuickDraw is an extension to the section on the original QuickDraw API; this means that you need to read both sections, even though you are interested in Color QuickDraw only.</p>   <a name="//apple_ref/doc/uid/20002355-97089" title="Comparing Win32/GDI and QuickDraw"></a> <h2>Comparing Win32/GDI and QuickDraw</h2> <p>Two problems that confront anyone learning a new platform are learning the overall approach the new technology uses and relating concepts from the old technology to those of the new technology. This section addresses both concerns through the use of some introductory text about the most-used parts of the QuickDraw drawing environment and through tables that compare how the Win32/GDI and QuickDraw environment compare to each other.</p> <a name="//apple_ref/doc/uid/20002355-97105" title="Windows"></a> <h3>Windows</h3> <p>While programming, you need a way to refer to a window. Under Win32, you identify a window through its <em>display context</em>. (Granted, in some cases you are manipulating the <em>device context</em> of the graphics hardware, but this Guide simplifies things by always using the term "display context.") In QuickDraw, you refer to a window by its <code>CGrafPort</code> (a programming shorthand for "color graphics port").</p> <p>In QuickDraw, drawing commands have a slightly different form from their Win32 counterparts. While Win32 drawing commands always take a display context as their first argument, QuickDraw commands do not. Instead, QuickDraw always assume that any drawing command is intended for the current graphics port. Therefore, to draw into a different window, you must first "set the graphics port" (that is, set the <code>CGrafPort</code> of the desired window to be the current port), then issue the drawing commands for the new window.</p> <p>There is one terminology difference you need to be aware of. Whereas the Win32/GDI API simply speaks of bitmaps, which can be black-and-white (one bit per pixel) or color (multiple bits per pixel), past and current versions of the Mac OS operating systems--and their documentation--use separate terms: <em>bitmap</em> for a one-bit black-and-white pixel image, and <em>pixmap</em> for a color pixel image.</p> <p><span class="content_text">Table 1</span> summarizes the differences regarding windows under the Win32/GDI and QuickDraw drawing environments.</p> <a name="//apple_ref/doc/uid/20002355-SW1" title="Table 1Comparison of window basics."></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 1&nbsp;&nbsp;</strong>Comparison of window basics.</caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p>The data structure that allows drawing in a window is a device context or a display context (abbreviated as DC).</p> </td> <td > <p>The data structure that allows drawing in a window is a color graphics port, also called a <code>CGrafPort</code>.</p> </td> </tr> <tr> <td  scope="row"> <p>A display context (usually) represents the client area of a window.</p> </td> <td > <p>The <code>CGrafPort</code> represents the client area of a window.</p> </td> </tr> <tr> <td  scope="row"> <p>All drawing routines include the name of the DC they are drawn to.</p> </td> <td > <p>Drawing routines do not include the name of the window's <code>CGrafPort</code>. Instead, you make a window the current graphics port. All subsequent drawing occurs in the current port.</p> </td> </tr> <tr> <td  scope="row"> <p>A memory device context is used as an offscreen bitmap.</p> </td> <td > <p>To draw in an offscreen pixel map, you must create a "graphics world," or <code>GWorld</code> , and make it the current graphics port. Subsequent drawing occurs into the <code>GWorld</code> until the graphics port is changed.</p> </td> </tr> <tr> <td  scope="row"> <p>It is possible, though not recommended, to access and change the bitmap associated with a DC.</p> </td> <td > <p>It is possible to access and change the pixel map associated with a <code>CGrafPort</code>. See text for details.</p> </td> </tr>  </table></div> <p>If you are interested in accessing the pixel map associated with a <code>CGrafPort</code>, see the documentation for the following routines: <code>GetWindowPort</code>, <code>LockPortBits</code>, <code>GetPortPixMap</code>, <code>LockPixels</code>, <code>GetPixBaseAddr</code>, <code>GetPixRowBytes</code>, <code>UnlockPixels</code>, and <code>UnlockPortBits</code>.</p>  <a name="//apple_ref/doc/uid/20002355-97500" title="Coordinate Systems"></a> <h3>Coordinate Systems</h3> <p>Apple has always controlled both the hardware and the operating-system software of its computers, so it was able to ensure that pixels are "square" – that is, that a pixel displayed on the screen is exactly as tall as it is wide. Because of this, the designers of QuickDraw did not have to deal with both logical and device coordinate systems, which possibly (in older computers) were not identical.</p> <p>In QuickDraw, there is only one coordinate system, and it is a simple one. Unless you specify otherwise, the point (0,0) is the upper left corner of the client area of a window (if you are talking about the "local" coordinate system of a given window) or of the desktop itself.</p> <p>Another subtle but very important difference between the Win32/GDI and QuickDraw coordinate systems is the relationship between the abstract coordinate grid and the pixels and lines drawn in relation to them. On the Win32 side, pixels (which have a measurable diameter) are drawn so that their centers correspond to the intersection of the appropriate horizontal and vertical grid lines, and the thickness of drawn lines straddle their corresponding coordinate lines.</p> <p>In QuickDraw, pixels and lines are drawn in the spaces <em>between</em> coordinate lines. To be specific, they are drawn immediately to the right of and below the points that define them. The original QuickDraw engineers felt that this method leads to less confusion when questioning whether, for example, a 10-by-10 square drawn with its upper left corner at (0,0) includes the pixel corresponding to the point (10, 10). In QuickDraw, the answer is "yes," while in Win32/GDI, the answer is "no," and Win32 programmers must keep this "up to but not including" rule in mind.</p> <p><span class="content_text">Table 2</span> summarizes the differences regarding coordinate systems between the Win32/GDI and QuickDraw drawing environments. </p> <a name="//apple_ref/doc/uid/20002355-101038" title="Table 2Comparison of coordinate systems. "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 2&nbsp;&nbsp;</strong>Comparison of coordinate systems. </caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p>Device contexts can use logical coordinates that do not have a 1:1 relationship to the physical display (that is, scaling can occur).</p> </td> <td > <p>Coordinates in the programming model have a one-to-one relationship to the physical display.</p> </td> </tr> <tr> <td  scope="row"> <p>Has multiple mapping modes, in which increasing x values may indicate movement to the right or left, and increasing y values may indicate movement up or down.</p> </td> <td > <p>Has fixed coordinate system: increasing x values move to the right, and increasing y values move down. Equivalent to Win32 MM_TEXT mode. Points may be described using either local (window) or global (desktop) coordinates.</p> </td> </tr> <tr> <td  scope="row"> <p>Pixels are drawn at the intersection of the imaginary lines that define the logical coordinate system. That is, the imaginary lines that define point (x0, y0) go through the center of the pixel drawn at (x0, y0).</p> </td> <td > <p>In QuickDraw, the intersection of the two imaginary lines that define point (x0, y0) is "ideal" — that is, it has no height or depth. Pixels, which have measurable height and depth, are drawn in the squares between the imaginary lines that define the coordinate system. In particular, the pixel corresponding to (x0, y0) is drawn to the right of and below the ideal point at (x0, y0).</p> </td> </tr>  </table></div>  <a name="//apple_ref/doc/uid/20002355-97654" title="Pens"></a> <h3>Pens</h3> <p>Win32/GDI pens have evolved over time, so you now have different kinds of pens available for use — stock pens, logical pens, and geometric and cosmetic extended pens. In contrast, QuickDraw has only one kind of pen.</p> <p>Just as QuickDraw always draws into the current port, it always draws with the current pen, and you use such routines as <code>PenSize</code>, <code>PenPixPat</code>, and <code>PenMode</code> to change the pen's size, pixel pattern, and drawing mode. If you have pens that you use frequently, you should create subroutines for defining them; that way, you can switch between pens with a single subroutine call.</p> <p>In QuickDraw, a pen can draw in a solid color, optionally modified by an arbitrary one-bit pattern, or it can draw using an arbitrary pixmap. In addition, the drawing process can also be modified by the use of different transfer modes, though these are infrequently used.</p> <p>The QuickDraw pen always has a pen pattern, a pen mode, a foreground color, and a background color, all of which affect how pen drawing works. The pen pattern, unlike the Win32/GDI hatch pattern, is defined by the programmer and can take on any value. QuickDraw defaults to using a solid black pen pattern and the <code>patCopy</code> pen mode, which results in an easy-to-understand pen that draws in the <code>CGrafPort</code>'s foreground color. However, the pen's behavior can become quite complex:</p> <ul class="spaceabove"> <li class="li"> <p>If the pen pattern is a bitmap, depending on the pen mode used, a pixel "touched" by the pen can become the foreground color or the background color, it can be inverted, or it can remain unchanged.</p> </li> <li class="li"> <p>If the pen pattern is a pixmap, the pixmap itself is used to draw whatever line or area that is requested by the pen-drawing command. In this case, any pixel touched by the pen is replaced by the appropriate pixel from the pixmap.</p> </li> <li class="li"> <p>Also, when the pen is used to draw a line or outline a shape, it does not draw with its width straddling the path. Instead, the upper left corner of the pen is dragged along the path, meaning that "ink" is always deposited below and to the right of the current point on the path.</p> </li> </ul> <p>If your application makes heavy use of drawing features not found in QuickDraw, you should consider porting your Win32 application to Mac OS X using the Quartz 2D API. See "Using Quartz 2D," later in this document, for details.</p> <p><span class="content_text">Table 3</span> summarizes the most important differences regarding pens between the Win32/GDI and QuickDraw drawing environments. This summary should make the process of learning about QuickDraw pens easier.</p> <a name="//apple_ref/doc/uid/20002355-101043" title="Table 3Comparison of Win32 geometric pens and QuickDraw pens. "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 3&nbsp;&nbsp;</strong>Comparison of Win32 geometric pens and QuickDraw pens. </caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p>A DC includes attributes that point to the current pen and brush (which are separate data structures from the DC).</p> </td> <td > <p>A <code>CGrafPort</code> contains attributes that describe the current pen and its color or pixel pattern.</p> </td> </tr> <tr> <td  scope="row"> <p>The cross-section of a geometric pen is square.</p> </td> <td > <p>The cross-section of a QuickDraw pen is rectangular--that is, its width and height can be different from each other.</p> </td> </tr> <tr> <td  scope="row"> <p>A geometric pen can draw in a solid color and erase using background color.</p> </td> <td > <p>A pen can draw in a solid color and erase using background color.</p> </td> </tr> <tr> <td  scope="row"> <p>A geometric pen is specified by a width value; the line drawn is (usually) centered on the "ideal" line described by the drawing command.</p> </td> <td > <p>A pen is described by width and height values; the pen draws in such a way that the upper left corner of the pen's rectangular cross-section traces the "ideal" line described by the drawing command.</p> </td> </tr> <tr> <td  scope="row"> <p>A geometric pen, using a hatched brush, can draw a solid color modified by a predefined hatch pattern.</p> </td> <td > <p>A pen can draw with a solid color and any pattern.</p> </td> </tr> <tr> <td  scope="row"> <p>A geometric pen can specify dash, endcap, and line join styles.</p> </td> <td > <p>QuickDraw has no equivalent, though Quartz 2D (a more advanced drawing environment) does.</p> </td> </tr> <tr> <td  scope="row"> <p>By using a pattern brush, a geometric pen can draw using an arbitrary bitmap as its "ink."</p> </td> <td > <p>By using a color pixel pattern (<code>PixPat</code>), a pen can draw using an arbitrary bitmap as its "ink."</p> </td> </tr> <tr> <td  scope="row"> <p>The drawing process can be modified by using a DC's drawing mode attribute.</p> </td> <td > <p>The drawing process can be modified by using different transfer modes.</p> </td> </tr>  </table></div>  <a name="//apple_ref/doc/uid/20002355-97965" title="Geometric Shapes"></a> <h3>Geometric Shapes</h3> <p>Though the Win32/GDI and QuickDraw environments have roughly the same capabilities when it comes to drawing geometric shapes, each environment structures the drawing process differently. QuickDraw does not have an equivalent to the Win32/GDI brush. Instead, when you are drawing shapes, you use a different command depending on how you wish to draw its interior, and the drawing can be accomplished with either the pen or an arbitrary bitmap or pixmap.</p> <p>The verb at the beginning of each shape-drawing command's name indicates how the drawing is accomplished:</p> <ul class="spaceabove"> <li class="li"> <p>Commands starting with "Frame" (for example, <code>FrameOval</code> ) draw the outline of the shape using the pen and its behavior as described earlier; the interior of the shape is not affected.</p> </li> <li class="li"> <p>Commands starting with "Paint" (for example, <code>PaintOval</code> ) paints the shape's interior using the pen and its behavior described earlier. The outline of the shape is not stroked by the pen.</p> </li> <li class="li"> <p>Commands starting with "FillC" (for example, <code>FillCOval</code> ) fills the shape's interior using an arbitrary pixel pattern (not the pen pattern). Any pixel touched by the pen is replaced by the appropriate color pixel from the pixmap. The command for setting this <em>pixel</em> pattern is <code>PenPixPat</code>.</p> </li> </ul> <p><span class="content_text">Table 4</span> summarizes the most important differences regarding geometric shapes between the Win32/GDI and QuickDraw drawing environments.</p> <a name="//apple_ref/doc/uid/20002355-101048" title="Table 4Comparison of geometric shapes. "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 4&nbsp;&nbsp;</strong>Comparison of geometric shapes. </caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p>Geometric shapes available: rectangles, ellipses, chords, pie-shaped wedges, rounded rectangles.</p> </td> <td > <p>Geometric shapes available: rectangles, ovals, arcs and wedges, rounded rectangles.</p> </td> </tr> <tr> <td  scope="row"> <p>To draw a basic geometric shape (for example, an ellipse) without filling it, you must draw it with the display context's brush filled to the background color. In this case, the drawing command is <code>Ellipse</code>.</p> </td> <td > <p>To draw an outlined shape, QuickDraw uses commands that begin with "Frame" — in this case, <code>FrameOval</code>.</p> </td> </tr> <tr> <td  scope="row"> <p>To draw an ellipse filled with a solid color, you must set the display context's brush to the given color and call the <code>Ellipse</code> command.</p> </td> <td > <p>To draw a filled shape, QuickDraw uses commands that begin with "Paint" — in this case, <code>PaintOval</code>. This command paints the interior of the ellipse with the current foreground color. If you specify a one-bit pattern and a Boolean transfer mode, you can fill the oval with a result that is based on the pattern and weighted mixes of the foreground and background colors.</p> </td> </tr> <tr> <td  scope="row"> <p>To draw an ellipse filled with a color bitmap, you must set the display context's brush to a pattern brush and call the <code>Ellipse</code> command.</p> </td> <td > <p>QuickDraw uses commands that begin with "FillC" — in this case, <code>FillCOval</code>. This command requires, in addition to the description of the bounding rectangle, a reference to the pixel pattern to be used.</p> </td> </tr> <tr> <td  scope="row"> <p>Win32 has an <code>InvertRect</code> command but no other commands for erasing or inverting geometric shapes.</p> </td> <td > <p>QuickDraw has additional commands for erasing and inverting each geometric shape (in this example, <code>EraseOval</code> and <code>InvertOval</code>).</p> </td> </tr>  </table></div>  <a name="//apple_ref/doc/uid/20002355-98325" title="Polygons"></a> <h3>Polygons</h3> <p>In QuickDraw, the drawing of polygons mirrors the drawing of geometric shapes in most respects (see <span class="content_text"><a href="2dgraphics.html#//apple_ref/doc/uid/20002355-101053">Table 5</a></span>, below). One difference from the Win32/GDI model is that in QuickDraw, you must explicitly create the polygon as a data structure before you can draw it.</p> <a name="//apple_ref/doc/uid/20002355-101053" title="Table 5Comparison of polygons. "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 5&nbsp;&nbsp;</strong>Comparison of polygons. </caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p>A polygon is defined by an array of points, which is one of the parameters of the <code>Polygon</code> command.</p> </td> <td > <p>In QuickDraw, you must create a polygon data structure before you can draw using it. You do this using an <code>OpenPoly</code> command, followed by line-drawing commands, followed by a <code>ClosePoly</code> command.</p> </td> </tr> <tr> <td  scope="row"> <p>As with geometric shapes, you create outline, color-filled, and bitmap-filled polygons with the same command, but with different brush settings.</p> </td> <td > <p>As with geometric shapes, you have multiple polygon commands. <code>FramePoly</code> draws the polygon with the pen. <code>PaintPoly</code> draws the polygon with the pan and fills its interior with a solid color. <code>FillCPoly</code> draws the polygon with the pen and fills its interior with a pixel map (color bitmap).</p> </td> </tr> <tr> <td  scope="row"> <p>Win32/GDI has no commands for erasing or inverting a polygon.</p> </td> <td > <p>As with geometric shapes, QuickDraw includes <code>ErasePoly</code> and <code>InvertPoly</code> commands.</p> </td> </tr>  </table></div>  <a name="//apple_ref/doc/uid/20002355-98536" title="Win32/GDI Paths, Win32/GDI Regions, and QuickDraw Regions"></a> <h3>Win32/GDI Paths, Win32/GDI Regions, and QuickDraw Regions</h3> <p>A QuickDraw region performs the same task as a Win32/GDI path in that you can use either to draw lines and fill areas based on a prerecorded set of graphic operations (see <span class="content_text">Table 6</span>).</p> <a name="//apple_ref/doc/uid/20002355-101058" title="Table 6Comparison of Win32/GDI paths and QuickDraw regions. "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 6&nbsp;&nbsp;</strong>Comparison of Win32/GDI paths and QuickDraw regions. </caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p>A Win32/GDI path is the union of an arbitrary collection of graphical outlines that can be filled or stroked.</p> </td> <td > <p>A QuickDraw region is a data structure that separates all points into those included in the region and those not included in the region. You can stroke its outline with a pen, paint its interior with a solid color or pixel pattern, use it as a mask for another drawing operation, or test for the presence of a mouse click inside it.</p> </td> </tr> <tr> <td  scope="row"> <p>You must create a Win32/GDI path before you can draw using it. You do this using a <code>BeginPath</code> command, followed by a series of drawing commands, followed by an <code>EndPath</code> command.</p> </td> <td > <p>You must create a QuickDraw region before you can draw using it. You do this using a <code>OpenRgn</code> command, followed by a series of drawing commands, followed by an <code>CloseRgn</code> command.</p> </td> </tr> <tr> <td  scope="row"> <p>Use the <code>StrokePath</code> command to draw an outline using a Win32/GDI path and the current pen.</p> </td> <td > <p>Use the <code>FrameRgn</code> command to draw an outline using a QuickDraw region and the current pen.</p> </td> </tr> <tr> <td  scope="row"> <p>Use the <code>StrokeAndFillPath</code> command to draw with the current pen and fill with either a solid color or a bitmap.</p> </td> <td > <p>Use the <code>PaintRgn</code> command to draw with the current pen and fill with a solid color. Use the <code>FillRgn</code> command to draw with the current pen and fill with a pixel map (color bitmap).</p> </td> </tr> <tr> <td  scope="row"> <p>You can convert a Win32/GDI path to a clipping region for a given DC.</p> </td> <td > <p>You can use a QuickDraw region as a clipping region for the current <code>CGrafPort</code> . You do not need to convert it to another form for this purpose.</p> </td> </tr> <tr> <td  scope="row"> <p>There are no Win32/GDI equivalents to the commands mentioned at right.</p> </td> <td > <p>QuickDraw includes <code>EraseRgn</code> and <code>InvertRgn</code> commands.</p> </td> </tr>  </table></div> <p>QuickDraw regions can also perform the same drawing and clipping tasks as Win32/GDI regions (see <span class="content_text">Table 7</span>). When creating a QuickDraw region, you can use certain drawing commands that cannot be used to create a Win32/GDI region. However, this difference is largely negated by the fact that you can create a Win32/GDI path that is equivalent to the QuickDraw region, then convert it to a Win32/GDI region.</p> <a name="//apple_ref/doc/uid/20002355-101063" title="Table 7Comparison of Win32/GDI regions and QuickDraw regions. "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 7&nbsp;&nbsp;</strong>Comparison of Win32/GDI regions and QuickDraw regions. </caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p>A Win32/GDI region is a data structure that separates all points into those included in the path and those not included in the path. You can stroke its outline with a pen, paint its interior with a brush, use it as a mask for another drawing operation, or test for the presence of a mouse click inside it.</p> </td> <td > <p>A QuickDraw region is a data structure that separates all points into those included in the region and those not included in the region. You can stroke its outline with a pen, paint its interior with a solid color or pixel pattern, use it as a mask for another drawing operation, or test for the presence of a mouse click inside it.</p> </td> </tr> <tr> <td  scope="row"> <p>You create Win32/GDI regions like you do Win32/GDI paths, but your drawing operations are limited to ellipses, polygons, rectangles, and rounded rectangles. You can also convert a Win32/GDI path (which is more versatile) to a Win32/GDI region.</p> </td> <td > <p>Like Win32/GDI regions, QuickDraw regions are created by a series of drawing operations, but QuickDraw regions can be created using all the shape-drawing commands.</p> </td> </tr> <tr> <td  scope="row"> <p>You can create a region from the union, intersection, difference, or XOR of two other regions.</p> </td> <td > <p>You can create a region from the union, intersection, difference, or XOR of two other regions.</p> </td> </tr>  </table></div>  <a name="//apple_ref/doc/uid/20002355-98947" title="Offscreen Bitmaps and GWorlds"></a> <h3>Offscreen Bitmaps and GWorlds</h3> <p>On most computer systems, if you issue drawing commands that write directly to video memory, such commands will occasionally do so just as the video hardware is reading its memory and displaying the results. This results in unintended visual artifacts or "glitches" that degrade the quality of the display. The classic solution for this problem is to first draw the image in an offscreen bitmap, then transfer that image to video memory in one fast operation (called a bit-block transfer, or <em>bitblt</em>).</p> <p>When Apple engineers created Color QuickDraw, they added a new data structure called a <code>GWorld</code> (a shortened version of the phrase "graphics world"). A <code>GWorld</code> behaves like a Win32/GDI offscreen bitmap, and in Color QuickDraw, you set the graphics port for both (on-screen) windows and (offscreen) and <code>GWorld</code>s with the command <code>SetGWorld</code>. You can learn about <code>GWorld</code>s and how to use them in the "Offscreen Graphics Worlds" chapter of <em>Inside Macintosh: Imaging with QuickDraw</em>.</p> <p>As part of the Quartz drawing architecture, QuickDraw automatically draws into an offscreen bitmap; in fact, it cannot be used in any other way. Therefore, you do not need to use <code>GWorld</code>s if your only intent is to prevent visual artifacts from occurring in your display. However, there still are reasons to use <code>GWorld</code> s. If, for example, you need to draw a complicated image that you will be reusing, you can first draw the image into a <code>GWorld</code> and then save the result for reuse.</p>  <a name="//apple_ref/doc/uid/20002355-99085" title="Bit-Block Transfers (BitBlts)"></a> <h3>Bit-Block Transfers (BitBlts)</h3> <p>QuickDraw has one drawing command, <code>CopyBits</code>, that performs the same functions as the <code>BitBlt</code> and <code>StretchBlt</code> commands in Win32/GDI. Though <code>CopyBits</code> is most often used simply to copy a pixmap to new location, be aware that you can also use it to transform the image in various ways during the copy process; see the “Color QuickDraw” chapter of <em>Inside Macintosh: Imaging with QuickDraw</em> for details.</p> <p><span class="content_text">Table 8</span> summarizes the differences regarding bit-block transfers between the Win32/GDI and QuickDraw drawing environments.</p> <a name="//apple_ref/doc/uid/20002355-101068" title="Table 8Comparison of bit-block transfer commands in Win32/GDI and QuickDraw. "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 8&nbsp;&nbsp;</strong>Comparison of bit-block transfer commands in Win32/GDI and QuickDraw. </caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p> <code>BitBlt</code> transfers pixels from a source device context to a destination device context, modified by one of 256 raster operations that combines each source bit, the corresponding pattern bit (from the current brush), and the corresponding destination bit.</p> </td> <td > <p> <code>CopyBits</code> transfers pixels from a source <code>CGrafPort</code> to a destination <code>CGrafPort</code>, modified by one of 18 source transfer modes that combines each source bit and its corresponding destination bit. If the source and destination areas are not the same size, <code>CopyBits</code> resizes the source area to fit the destination area.</p> </td> </tr> <tr> <td  scope="row"> <p> <code>StretchBlt</code> behaves like <code>BitBlt</code> , but it stretches the source bitmap to fit the dimensions of the destination bitmap.</p> </td> <td > <p>See above.</p> </td> </tr> <tr> <td  scope="row"> <p> <code>PatBlt</code> copies a 1-bit pattern (from the current brush) into a destination device context, modified by one of 16 raster operations that combines each pattern bit with its corresponding destination bit.</p> </td> <td > <p>You can use <code>FillRect</code> to achieve a similar result to that of <code>PatBlt</code>.</p> </td> </tr> <tr> <td  scope="row"> <p> <code>MaskBlt</code> (not available on Windows 98 and earlier versions) transfers pixels from a source device context to a destination device context, modified by a 1-bit mask and a ROP4 raster operator</p> </td> <td > <p> <code>CopyMask</code> and <code>CopyDeepMask</code> (available on all versions of Mac OS) transfer pixels from a source <code>CGrafPort</code> to a destination <code>CGrafPort</code>, modified by a pixel mask. Each resulting pixel is a blending of the source and destination pixels as determined by the value of the corresponding mask pixel. If the mask contains color pixels, the blending is computed per color component. <code>CopyDeepMask</code> behaves like <code>CopyMask</code>, but in addition, it allows you to select special transfer modes and to pass in a mask-clipping region (as in <code>CopyBits</code>).</p> </td> </tr> <tr> <td  scope="row"> <p> <code>PlgBlt</code> (not available on Windows 98 and earlier versions) transfers pixels from a source device context to a destination device context, modified by a 1-bit mask and optional shearing, rotation, and mirror-image operations.</p> </td> <td > <p>QuickDraw has no equivalent to <code>PlgBlt</code>, though Quartz 2D (a more advanced drawing environment) can perform arbitrary 2D transformations on pixmaps, including many not available to <code>PlgBlt</code>.</p> </td> </tr>  </table></div>  <a name="//apple_ref/doc/uid/20002355-99530" title="Metafiles and Picture Files"></a> <h3>Metafiles and Picture Files</h3> <p>Just as the Win32/GDI drawing environment has metafiles, a mechanism for storing and playing back a set of drawing commands, QuickDraw has its equivalent: the <em>picture record</em> (also called a QuickDraw picture, or <code>PICT</code>). And, just as the original <code>.wmf</code> format was largely replaced by the enhanced <code>.emf</code> metafile, the original <code>PICT</code> format was largely replaced by a color-based "version 2" <code>PICT</code> format.</p> <p>As with everything else in QuickDraw, <code>PICT</code> s are measured in pixels, and you can easily retrieve the size of the <code>PICT</code> from its header. You create <code>PICT</code> s by executing the <code>OpenCPicture</code> command, some drawing commands, then finally the <code>CloseCPicture</code> command. Later, you can draw them into a rectangular portion of a window or <code>GWorld</code> using the <code>DrawPicture</code> command.</p> <p>The <code>PICT</code> format is also a standard format for the Clipboard. Along with the plain-text format, every Mac OS X application should be able to cut, copy, and paste <code>PICT</code> resources.</p>  <a name="//apple_ref/doc/uid/20002355-99709" title="Text"></a> <h3>Text</h3> <p>Very little needs to be said about using QuickDraw to draw text, since you will probably use functions outside QuickDraw to do so. However, QuickDraw does include a <code>DrawText</code> command for simple text drawing. Just as there is only one pen associated with a <code>CGrafPort</code> , you also have only one "text tool" to work with, but you can change the font, style, size, and drawing mode of the current <code>CGrafPort</code> before using the <code>DrawText</code> command.</p> <p><span class="content_text">Table 9</span> summarizes the differences regarding text between the Win32/GDI and QuickDraw drawing environments.</p> <a name="//apple_ref/doc/uid/20002355-101073" title="Table 9Comparison of basic text drawing. "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"> <caption class="tablecaption"><strong>Table 9&nbsp;&nbsp;</strong>Comparison of basic text drawing. </caption>  <tr> <td  scope="row"> <p> <strong>Win32/GDI</strong> </p> </td> <td > <p> <strong>QuickDraw</strong> </p> </td> </tr> <tr> <td  scope="row"> <p> <code>TextOut</code> draws text in the current font to the location specified in the command's arguments.</p> </td> <td > <p> <code>DrawText</code> draws text in the current font at the current pen location. (Use <code>MoveTo</code> to move the pen to a given location.)</p> </td> </tr> <tr> <td  scope="row"> <p> <code>DrawText</code> draws text into a specified rectangle.</p> </td> <td > <p>Use <code>TXNDrawCFStringTextBox</code> or <code>TXNDrawUnicodeTextBox</code> in the Multilingual Text Engine (MLTE) API to draw text into a specified rectangle.</p> </td> </tr>  </table></div>   <a name="//apple_ref/doc/uid/20002355-99913" title="An Introduction to Quartz 2D"></a> <h2>An Introduction to Quartz 2D</h2> <p>Quartz 2D is Apple's newest two-dimensional drawing and windowing technology, available only under Mac OS X. It uses the Adobe PDF format as its internal graphics model, thus providing a rich 2D imaging model for graphics, as well as greatly simplifying the creation of PDF files.</p> <p>Among the features available in Quartz 2D but not in QuickDraw are:</p> <ul class="ul"> <li class="li"> <p>vector-based, resolution-independent 2D drawing</p> </li> <li class="li"> <p>Bezier curves</p> </li> <li class="li"> <p>path-based drawing of graphics and text</p> </li> <li class="li"> <p>arbitrary 2D transformations of vector shapes (also called paths), text, and pixmaps</p> </li> <li class="li"> <p>transparency as an attribute of drawing </p> </li> <li class="li"> <p>contexts, an abstraction that enables the same drawing code to draw to the screen, a printer, or a PDF file </p> </li> <li class="li"> <p>per-context thread-safe drawing (all drawing for a given context must occur in the same thread)</p> </li> </ul> <a name="//apple_ref/doc/uid/20002355-99981" title="Quartz 2D and Your Porting Effort"></a> <h3>Quartz 2D and Your Porting Effort</h3> <p>Porting an application to a new platform always has its own challenges, and these determine what development choices you have. When you port your Win32 application to Mac OS X, you have three choices:</p> <ul class="spaceabove"> <li class="li"> <p>to port using QuickDraw only </p> </li> <li class="li"> <p>to port using QuickDraw, with occasional uses of Quartz 2D </p> </li> <li class="li"> <p>to port using Quartz 2D only </p> </li> </ul> <p>The Mac OS X implementation of QuickDraw includes two routines, <code>QDBeginCGContext</code> and <code>QDEndCGContext</code> , that enable you to switch to Quartz 2D temporarily for graphic operations that are not available in QuickDraw.</p> <p>To compete with other Mac OS X applications similar to yours, you will eventually want to rewrite your application to use Quartz 2D exclusively. If your schedule allows it, you may want to consider porting your Win32 code directly to Quartz 2D instead of QuickDraw. This will give you a stronger initial product that will be easier to upgrade in the future. </p>   <a name="//apple_ref/doc/uid/20002355-100050" title="Notes for Win32 Programmers"></a> <h2>Notes for Win32 Programmers</h2> <p>The following paragraphs describe several miscellaneous issues you should be aware of while porting a Win32 application to QuickDraw: </p> <ul class="ul"> <li class="li"> <p>Given the fact that QuickDraw graphics are always double-buffered under Mac OS X, the drawing process alone does not determine when the drawn graphics will become visible. If you want to control exactly when they are drawn to screen, first perform the drawing, then call the <code>QDFlushPortBuffer</code> routine.</p> </li> <li class="li"> <p>As mentioned earlier, you do not need to use <code>GWorld</code> s simply to prevent unsightly visual artifacts; Mac OS X's built-in double-buffering does this automatically.</p> </li> <li class="li"> <p>First-time users of the <code>CopyBits</code> routine may have trouble getting the desired result. If you're using <code>CopyBits</code> to copy a source pixmap, unchanged, to a destination pixmap, you need to make sure that the foreground color is set to black, the background color is set to white, and the source mode is <code>srcCopy</code> . For details, read the text at the top of page 4-34 of the <em>Imaging with QuickDraw</em> book.</p> </li> <li class="li"> <p>Because Apple controls the hardware on which Mac OS X runs, Mac OS X "knows" more about the display hardware available to it than the Win32 operating systems do. Mac OS X does not need to deal with device-dependent bitmaps (DDBs), device-independent bitmaps (DIBs), and DIB sections. </p> </li> <li class="li"> <p>Some Win32 programmers have reported that <code>CopyBits</code> , when used to stretch an image, produces results that are visibly different from those produced by <code>StretchBlt</code> . This difference occurs because of the different algorithms used to stretch an image. If you use <code>StretchBlt</code> in your Win32 code, be sure to check the visual appearance of the ported code that uses <code>CopyBits</code>.</p> </li> <li class="li"> <p>In indexed color modes under Mac OS X, black and white have fixed palette positions that cannot be changed. Unfortunately, the index values for black and white are reversed from what they are under Win32. If this situation applies to you, you will need to change your application so that it displays black and white correctly in its ported Mac OS X version.</p> </li> <li class="li"> <p>Although QuickDraw routines specify point coordinates with the horizontal component first--that is, with the x coordinate specified first--the QuickDraw points are stored in memory with the vertical component first--that is, with the y value stored at a lower memory location than the x value. Of course, you shouldn't be accessing memory directly anyway.</p> </li> </ul>  <a name="//apple_ref/doc/uid/20002355-100212" title="For Further Information"></a> <h2>For Further Information</h2> <p>Your main reference for QuickDraw is <em>Inside Macintosh: Imaging with QuickDraw</em>. In addition to the link for this book, you may find some of the other links below helpful.</p> <a name="//apple_ref/doc/uid/20002355-101078"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">  <tr> <td  scope="row"> <p>The QuickDraw documentation page (includes links to <em>Imaging with QuickDraw</em> and QuickDraw API documentation)</p> </td> <td > <p> <span class="content_text"><a href="../../../../../documentation/macos8/MultimediaGraphics/QuickDraw/quickdraw.html" target="_top">http://developer.apple.com/documentation/macos8/MultimediaGraphics/QuickDraw/quickdraw.html</a></span> </p> </td> </tr> <tr> <td  scope="row"> <p>QuickDraw Text book</p> </td> <td > <p> <em><a href="../../../../Carbon/Reference/QuickDraw_Text/index.html#//apple_ref/doc/uid/TP30000026" target="_top">QuickDraw Text Reference</a></em> </p> </td> </tr> <tr> <td  scope="row"> <p>links to <code>QDBeginCGContext</code> and <code>QDEndCGContext</code> documentation </p> </td> <td > <p> <em><a href="../../../../Carbon/Reference/QuickDraw_Ref/index.html#//apple_ref/doc/uid/TP30000975" target="_top">QuickDraw Reference</a></em> </p> </td> </tr> <tr> <td  scope="row"> <p>QuickDraw Text Anti-Aliasing using Quartz 2D</p> </td> <td > <p> <span class="content_text"><a href="../../../../../qa/qa2001/qa1193.html" target="_top">http://developer.apple.com/qa/qa2001/qa1193.html</a></span> </p> </td> </tr> <tr> <td  scope="row"> <p>links to Quartz Primer, Drawing with Quartz 2D, Quartz 2D API reference</p> </td> <td > <p> <em><a href="../../../../GraphicsImaging/Reference/Quartz2D_Collection/index.html#//apple_ref/doc/uid/TP40003853" target="_top">Quartz 2D Reference Collection</a></em> </p> <p> <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em> </p> <p> <em><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/index.html#//apple_ref/doc/uid/TP30001070" target="_top">Quartz Display Services Reference</a></em> </p> </td> </tr> <tr> <td  scope="row"> <p>links to What's New with Quartz 2D documentation, Quartz Extreme information </p> </td> <td > <p> <span class="content_text"><a href="http://developer.apple.com/quartz/" target="_top">http://developer.apple.com/quartz/</a></span> </p> </td> </tr>  </table></div>   

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../win32porting.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="3dgraphics.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Porting/Conceptual/win32porting/Articles/2dgraphics.html%3Fid%3D10000190i-2.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Porting/Conceptual/win32porting/Articles/2dgraphics.html%3Fid%3D10000190i-2.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Porting/Conceptual/win32porting/Articles/2dgraphics.html%3Fid%3D10000190i-2.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
