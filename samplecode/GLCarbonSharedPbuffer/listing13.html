<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLCarbonSharedPbuffer - /HID Support/HID_Utilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLCarbonSharedPbuffer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLCarbonSharedPbuffer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/HID Support/HID_Utilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/camera.h</option>
<option value="listing2.html">/drawInfo.h</option>
<option value="listing3.html">/glCheck.c</option>
<option value="listing4.html">/glCheck.h</option>
<option value="listing5.html">/HID Support/HID_Config_Utilities.c</option>
<option value="listing6.html">/HID Support/HID_Config_Utilities.h</option>
<option value="listing7.html">/HID Support/HID_Error_Handler.c</option>
<option value="listing8.html">/HID Support/HID_Error_Handler.h</option>
<option value="listing9.html">/HID Support/HID_Name_Lookup.c</option>
<option value="listing10.html">/HID Support/HID_Name_Lookup.h</option>
<option value="listing11.html">/HID Support/HID_Queue_Utilities.c</option>
<option value="listing12.html">/HID Support/HID_Queue_Utilities.h</option>
<option value="listing13.html">/HID Support/HID_Utilities.c</option>
<option value="listing14.html">/HID Support/HID_Utilities.h</option>
<option value="listing15.html">/HID Support/HID_Utilities_External.h</option>
<option value="listing16.html">/HID Support/HID_Utilities_Internal.h</option>
<option value="listing17.html">/HID Support/HIDSupport.c</option>
<option value="listing18.html">/HID Support/HIDSupport.h</option>
<option value="listing19.html">/main.c</option>
<option value="listing20.html">/main.h</option>
<option value="listing21.html">/pbuffer.c</option>
<option value="listing22.html">/pbuffer.h</option>
<option value="listing23.html">/SurfaceGeometry.c</option>
<option value="listing24.html">/SurfaceGeometry.h</option>
<option value="listing25.html">/trackball.c</option>
<option value="listing26.html">/trackball.h</option></select>
				</p>
				</form>
				<p><strong><a href="GLCarbonSharedPbuffer.zip">Download Sample</a></strong> (&#147;GLCarbonSharedPbuffer.zip&#148;, 221.9K)<BR>
<strong><a href="GLCarbonSharedPbuffer.dmg">Download Sample</a></strong> (&#147;GLCarbonSharedPbuffer.dmg&#148;, 271.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
 *  HID Utilities.c
 *  HID Explorer
 *
 *  Created by ggs on Fri Apr 20 2001.

  Copyright:  Copyright &copy; 2001 Apple Computer, Inc., All Rights Reserved

  Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.   Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include &quot;HID_Utilities_Internal.h&quot;
#include &quot;HID_Utilities_External.h&quot;

// ==================================
// private functions

// path to follow to next element
static char MapChar (char c);
static void CleanString (char * targetString);
static void HIDGetElementInfo (CFTypeRef refElement, pRecElement pElement);
static void HIDAddElement (CFTypeRef refElement, pRecElement * ppElementCurrent);
static void HIDGetElementsCFArrayHandler (const void * value, void * parameter);
static void HIDGetElements (CFTypeRef refElementCurrent, pRecElement * ppElementCurrent);
static void HIDGetCollectionElements (CFMutableDictionaryRef deviceProperties, pRecElement * ppElementCurrent);
static void HIDGetDeviceInfo (io_object_t hidDevice, CFMutableDictionaryRef hidProperties, pRecDevice pDevice);
static void HIDAddDevice (pRecDevice *ppListDeviceHead, pRecDevice pNewDevice);
static pRecDevice HIDMoveDevice (pRecDevice *ppListDeviceHead, pRecDevice pNewDevice, pRecDevice *ppOldListDeviceHead);
static pRecDevice HIDBuildDevice (io_object_t hidDevice);
static pRecDevice HIDCreateSingleTypeDeviceList (io_iterator_t hidObjectIterator);
static pRecDevice HIDCreateMultiTypeDeviceList (UInt32 *usagePage, UInt32 *usage, UInt32 numDeviceTypes);
static Boolean HIDFindDeviceInList (pRecDevice pDeviceList, pRecDevice pFindDevice);
static Boolean HIDCompareUpdateDeviceList (pRecDevice *ppListDeviceHead, pRecDevice *ppNewDeviceList);
static void HIDMergeDeviceList (pRecDevice *ppNewDeviceList, pRecDevice *ppDeviceList);
static io_iterator_t HIDGetIterator (const mach_port_t masterPort, UInt32 usagePage, UInt32 usage);
static CFMutableDictionaryRef HIDSetUpMatchingDictionary (UInt32 usagePage, UInt32 usage);
static void HIDDisposeDeviceElements (pRecElement pElement);
static pRecDevice HIDDisposeDevice (pRecDevice *ppDevice);
static UInt32 HIDCountCurrentDevices (pRecDevice pDeviceList);
static Boolean HIDMatchElementTypeMask (IOHIDElementType type, HIDElementTypeMask typeMask);
static pRecElement HIDGetDeviceElement (pRecElement pElement, HIDElementTypeMask typeMask);

// ==================================
// globals

// for element retrieval
pRecDevice gCurrentGetDevice = NULL;
Boolean gfAddAsChild = true;

pRecDevice gpDeviceList = NULL;
unsigned long gNumDevices = 0;

// ==================================
// private functions

// Maps bad chars to good chars for html/printing ASCII

static char MapChar (char c)
{
  unsigned char uc = (unsigned char) c;
  switch (uc)
  {
    case 0x01: return ' ';
    case 0x02: return ' ';
    case 0x03: return ' ';
    case 0x04: return ' ';
    case 0x05: return ' ';
    case 0x06: return ' ';
    case 0x07: return ' ';
    case 0x08: return ' ';
    case 0x09: return ' ';
    case 0x0A: return ' ';
    case 0x0B: return ' ';
    case 0x0C: return ' ';
    case 0x0D: return ' ';
    case 0x0E: return ' ';
    case 0x0F: return ' ';
    case 0x10: return ' ';
    case 0x11: return ' ';
    case 0x12: return ' ';
    case 0x13: return ' ';
    case 0x14: return ' ';
    case 0x15: return ' ';
    case 0x16: return ' ';
    case 0x17: return ' ';
    case 0x18: return ' ';
    case 0x19: return ' ';
    case 0x1A: return ' ';
    case 0x1B: return ' ';
    case 0x1C: return ' ';
    case 0x1D: return ' ';
    case 0x1E: return ' ';
    case 0x1F: return ' ';
    case '/': return '-'; // use dash instead of slash
    
    case 0x7F: return ' ';
    case 0x80: return 'A';
    case 0x81: return 'A';
    case 0x82: return 'C';
    case 0x83: return 'E';
    case 0x84: return 'N';
    case 0x85: return 'O';
    case 0x86: return 'U';
    case 0x87: return 'a';
    case 0x88: return 'a';
    case 0x89: return 'a';
    case 0x8A: return 'a';
    case 0x8B: return 'a';
    case 0x8C: return 'a';
    case 0x8D: return 'c';
    case 0x8E: return 'e';
    case 0x8F: return 'e';
    case 0x90: return ' ';
    case 0x91: return ' '; // ? '
    case 0x92: return ' '; // ? '
    case 0x93: return ' '; // ? &quot;
    case 0x94: return ' '; // ? &quot;
    case 0x95: return ' ';
    case 0x96: return ' ';
    case 0x97: return ' ';
    case 0x98: return ' ';
    case 0x99: return ' ';
    case 0x9A: return ' ';
    case 0x9B: return 0x27;
    case 0x9C: return 0x22;
    case 0x9D: return ' ';
    case 0x9E: return ' ';
    case 0x9F: return ' ';
    case 0xA0: return ' ';
    case 0xA1: return ' ';
    case 0xA2: return ' ';
    case 0xA3: return ' ';
    case 0xA4: return ' ';
    case 0xA5: return ' ';
    case 0xA6: return ' ';
    case 0xA7: return ' ';
    case 0xA8: return ' ';
    case 0xA9: return ' ';
    case 0xAA: return ' ';
    case 0xAB: return ' ';
    case 0xAC: return ' ';
    case 0xAD: return ' ';
    case 0xAE: return ' ';
    case 0xAF: return ' ';
    case 0xB0: return ' ';
    case 0xB1: return ' ';
    case 0xB2: return ' ';
    case 0xB3: return ' ';
    case 0xB4: return ' ';
    case 0xB5: return ' ';
    case 0xB6: return ' ';
    case 0xB7: return ' ';
    case 0xB8: return ' ';
    case 0xB9: return ' ';
    case 0xBA: return ' ';
    case 0xBB: return ' ';
    case 0xBC: return ' ';
    case 0xBD: return ' ';
    case 0xBE: return ' ';
    case 0xBF: return ' ';
    case 0xC0: return ' ';
    case 0xC1: return ' ';
    case 0xC2: return ' ';
    case 0xC3: return ' ';
    case 0xC4: return ' ';
    case 0xC5: return ' ';
    case 0xC6: return ' ';
    case 0xC7: return ' ';
    case 0xC8: return ' ';
    case 0xC9: return ' ';
    case 0xCA: return ' ';
    case 0xCB: return 'A';
    case 0xCC: return 'A';
    case 0xCD: return 'O';
    case 0xCE: return ' ';
    case 0xCF: return ' ';
    case 0xD0: return '-';
    case 0xD1: return '-';
    case 0xD2: return 0x22;
    case 0xD3: return 0x22;
    case 0xD4: return 0x27;
    case 0xD5: return 0x27;
    case 0xD6: return '-'; // use dash instead of slash
    case 0xD7: return ' ';
    case 0xD8: return 'y';
    case 0xD9: return 'Y';
    case 0xDA: return '-'; // use dash instead of slash
    case 0xDB: return ' ';
    case 0xDC: return '&lt;';
    case 0xDD: return '&gt;';
    case 0xDE: return ' ';
    case 0xDF: return ' ';
    case 0xE0: return ' ';
    case 0xE1: return ' ';
    case 0xE2: return ',';
    case 0xE3: return ',';
    case 0xE4: return ' ';
    case 0xE5: return 'A';
    case 0xE6: return 'E';
    case 0xE7: return 'A';
    case 0xE8: return 'E';
    case 0xE9: return 'E';
    case 0xEA: return 'I';
    case 0xEB: return 'I';
    case 0xEC: return 'I';
    case 0xED: return 'I';
    case 0xEE: return 'O';
    case 0xEF: return 'O';
    case 0xF0: return ' ';
    case 0xF1: return 'O';
    case 0xF2: return 'U';
    case 0xF3: return 'U';
    case 0xF4: return 'U';
    case 0xF5: return '|';
    case 0xF6: return ' ';
    case 0xF7: return ' ';
    case 0xF8: return ' ';
    case 0xF9: return ' ';
    case 0xFA: return '.';
    case 0xFB: return ' ';
    case 0xFC: return ' ';
    case 0xFD: return 0x22;
    case 0xFE: return ' ';
    case 0xFF: return ' ';
  }
  return c;
}

// ---------------------------------

// ensures the string only contains printable ASCII characters
// using varition of my html conversion source
// input is null terminated string, change is made in place

static void CleanString (char * targetString)
{
  char * charIt = targetString;
  while (*charIt) {
    *charIt = MapChar (*charIt);
    charIt++;
  }
}

// ---------------------------------

// extracts actual specific element information from each element CF dictionary entry

static void HIDGetElementInfo (CFTypeRef refElement, pRecElement pElement)
{
  long number;
  CFTypeRef refType;
  // type, usagePage, usage already stored
  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementCookieKey));
  if (refType &amp;&amp; CFNumberGetValue (refType, kCFNumberLongType, &amp;number))
    pElement-&gt;cookie = (IOHIDElementCookie) number;
  else
    pElement-&gt;cookie = (IOHIDElementCookie) 0;
    
  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementMinKey));
  if (refType &amp;&amp; CFNumberGetValue (refType, kCFNumberLongType, &amp;number))
    pElement-&gt;min = number;
  else
    pElement-&gt;min = 0;
  pElement-&gt;maxReport = pElement-&gt;min;
  pElement-&gt;userMin = kDefaultUserMin;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementMaxKey));
  if (refType &amp;&amp; CFNumberGetValue (refType, kCFNumberLongType, &amp;number))
    pElement-&gt;max = number;
  else
    pElement-&gt;max = 0;

  pElement-&gt;minReport = pElement-&gt;max;
  pElement-&gt;userMax = kDefaultUserMax;
  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementScaledMinKey));
  if (refType &amp;&amp; CFNumberGetValue (refType, kCFNumberLongType, &amp;number))
    pElement-&gt;scaledMin = number;
  else
    pElement-&gt;scaledMin = 0;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementScaledMaxKey));
  if (refType &amp;&amp; CFNumberGetValue (refType, kCFNumberLongType, &amp;number))
    pElement-&gt;scaledMax = number;
  else
    pElement-&gt;scaledMax = 0;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementSizeKey));
  if (refType &amp;&amp; CFNumberGetValue (refType, kCFNumberLongType, &amp;number))
    pElement-&gt;size = number;
  else
    pElement-&gt;size = 0;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsRelativeKey));
  if (refType)
    pElement-&gt;relative = CFBooleanGetValue (refType);
  else
    pElement-&gt;relative = 0;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsWrappingKey));
  if (refType)
    pElement-&gt;wrapping = CFBooleanGetValue (refType);
  else
    pElement-&gt;wrapping = false;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsNonLinearKey));
  if (refType)
    pElement-&gt;nonLinear = CFBooleanGetValue (refType);
  else
    pElement-&gt;nonLinear = false;


  #ifdef kIOHIDElementHasPreferredStateKey
    refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementHasPreferredStateKey));
  #else // Mac OS X 10.0 has spelling error
    refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementHasPreferedStateKey));
  #endif
  if (refType)
    pElement-&gt;preferredState = CFBooleanGetValue (refType);
  else
    pElement-&gt;preferredState = false;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementHasNullStateKey));
  if (refType)
    pElement-&gt;nullState = CFBooleanGetValue (refType);
  else
    pElement-&gt;nullState = false;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementUnitKey));
  if (refType &amp;&amp; CFNumberGetValue (refType, kCFNumberLongType, &amp;number))
    pElement-&gt;units = number;
  else
    pElement-&gt;units = 0;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementUnitExponentKey));
  if (refType &amp;&amp; CFNumberGetValue (refType, kCFNumberLongType, &amp;number))
    pElement-&gt;unitExp = number;
  else
    pElement-&gt;unitExp = 0;

  refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementNameKey));
  if (refType)
    if (!CFStringGetCString (refType, pElement-&gt;name, 256, CFStringGetSystemEncoding ()))
      HIDReportError (&quot;CFStringGetCString error retrieving pElement-&gt;name.&quot;);
    CleanString (pElement-&gt;name);
  if (!*pElement-&gt;name) { // set name from vendor id/product id look up
    GetElementNameFromVendorProduct (gCurrentGetDevice-&gt;vendorID,  gCurrentGetDevice-&gt;productID, (long) pElement-&gt;cookie, pElement-&gt;name);
    if (!*pElement-&gt;name) { // if no name
      HIDGetUsageName (pElement-&gt;usagePage, pElement-&gt;usage, pElement-&gt;name);
      if (!*pElement-&gt;name) // if not usage
        sprintf (pElement-&gt;name, &quot;Element&quot;);
    }
  }
}       

// ---------------------------------

// examines CF dictionary value in device element hierarchy to determine if it is element of interest or a collection of more elements
// if element of interest allocate storage, add to list and retrieve element specific info
// if collection then pass on to deconstruction collection into additional individual elements

static void HIDAddElement (CFTypeRef refElement, pRecElement * ppElementCurrent)
{
  pRecDevice pDevice = gCurrentGetDevice;
  pRecElement pElement = NULL;
  long elementType, usagePage, usage;
  CFTypeRef refElementType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementTypeKey));   
  CFTypeRef refUsagePage = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementUsagePageKey));  
  CFTypeRef refUsage = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementUsageKey));
  
  if (refElementType)
    CFNumberGetValue (refElementType, kCFNumberLongType, &amp;elementType);
  if (refUsagePage)
    CFNumberGetValue (refUsagePage, kCFNumberLongType, &amp;usagePage);
  if (refUsage)
    CFNumberGetValue (refUsage, kCFNumberLongType, &amp;usage);
    
  if (NULL == pDevice)
    return;
  if (elementType)
  {
    // look at types of interest
    if (elementType != kIOHIDElementTypeCollection)       
    {
      switch (usagePage) // only interested in kHIDPage_GenericDesktop and  kHIDPage_Button
      {
        case kHIDPage_GenericDesktop:
          {
            switch (usage) // look at usage to determine function
            {
              case kHIDUsage_GD_X: 
              case kHIDUsage_GD_Y: 
              case kHIDUsage_GD_Z: 
              case kHIDUsage_GD_Rx: 
              case kHIDUsage_GD_Ry: 
              case kHIDUsage_GD_Rz: 
                pElement = (pRecElement) malloc (sizeof (recElement));
                if (pElement)
                  pDevice-&gt;axis++; 
              break;
              case kHIDUsage_GD_Slider: 
                pElement = (pRecElement) malloc (sizeof (recElement));
                if (pElement)
                  pDevice-&gt;sliders++; 
              break;
              case kHIDUsage_GD_Dial: 
                pElement = (pRecElement) malloc (sizeof (recElement));
                if (pElement)
                  pDevice-&gt;dials++; 
              break;
              case kHIDUsage_GD_Wheel: 
                pElement = (pRecElement) malloc (sizeof (recElement));
                if (pElement)
                  pDevice-&gt;wheels++; 
              break;
              case kHIDUsage_GD_Hatswitch: 
                pElement = (pRecElement) malloc (sizeof (recElement));
                if (pElement)
                  pDevice-&gt;hats++; 
              break;
            }               
          }
          break;
        case kHIDPage_Button:
          pElement = (pRecElement) malloc (sizeof (recElement));
          if (pElement)
            pDevice-&gt;buttons++;
          break;
        default:
          // just add a generic element
          pElement = (pRecElement) malloc (sizeof (recElement));
          break;
      }
    }
    else // collection
      pElement = (pRecElement) malloc (sizeof (recElement));
  }
  else
    HIDReportError (&quot;CFNumberGetValue error when getting value for refElementType.&quot;);
  if (pElement) // add to list
  {
    // this code builds a binary tree based on the collection hierarchy of inherent in the device element layout
    // it preserves the structure of the lements as collections have children and lements are siblings to each other

    // clear record
    unsigned long i;
    char * temp = (char *) pElement;
    for (i = 0; i &lt; sizeof (recElement); i++)
      *temp++ = 0x00;
    
    // get element info
    pElement-&gt;type = elementType;
    pElement-&gt;usagePage = usagePage;
    pElement-&gt;usage = usage;
    HIDGetElementInfo (refElement, pElement);
    
    // count elements
    pDevice-&gt;totalElements++;
    switch (pElement-&gt;type)
    {
      case kIOHIDElementTypeInput_Misc:
      case kIOHIDElementTypeInput_Button:
      case kIOHIDElementTypeInput_Axis:
      case kIOHIDElementTypeInput_ScanCodes:
        pDevice-&gt;inputs++;
        break;
      case kIOHIDElementTypeOutput:
        pDevice-&gt;outputs++;
        break;
      case kIOHIDElementTypeFeature:
        pDevice-&gt;features++;
        break;
      case kIOHIDElementTypeCollection:
        pDevice-&gt;collections++;
        break;
      default:
        HIDReportErrorNum (&quot;Unknown element type : &quot;, pElement-&gt;type);
    }
    // if a type that is normally an axis and has a preferred state and is not relative
    pElement-&gt;hasCenter = false;
    if ((pElement-&gt;preferredState) &amp;&amp; (!pElement-&gt;relative) &amp;&amp; (pElement-&gt;usagePage == kHIDPage_GenericDesktop))
      switch (pElement-&gt;usage) {
        case kHIDUsage_GD_X: 
        case kHIDUsage_GD_Y: 
        case kHIDUsage_GD_Z: 
        case kHIDUsage_GD_Rx: 
        case kHIDUsage_GD_Ry: 
        case kHIDUsage_GD_Rz: 
//        case kHIDUsage_GD_Slider: // should not have center
//        case kHIDUsage_GD_Dial:  // should not have center
        case kHIDUsage_GD_Wheel: 
        case kHIDUsage_GD_Hatswitch:
          pElement-&gt;hasCenter = true; // respect center
          pElement-&gt;initialCenter = HIDGetElementValue (pDevice, pElement);
      }

    if (NULL == *ppElementCurrent) // if at list head
    {
      pDevice-&gt;pListElements = pElement; // add current element
      *ppElementCurrent = pElement; // set current element to element we just added
      if (elementType == kIOHIDElementTypeCollection) // if this element is a collection of other elements
      {
        gfAddAsChild = true; // the next element is a child of this element
        HIDGetCollectionElements ((CFMutableDictionaryRef) refElement, &amp;pElement); // recursively process the collection
      }
      gfAddAsChild = false; // when returning from the recursive processing or the element is not a collection, add the next as a sibling
    }
    else // have existing structure
    {
      if (gfAddAsChild) // if the previous element was a collection, let's add this as a child of the previous
      {
        // this iteration should not be needed but there maybe some untested degenerate case which this code will ensure works
        while ((*ppElementCurrent)-&gt;pChild) // step down tree until free child node found
          *ppElementCurrent = (*ppElementCurrent)-&gt;pChild;
        (*ppElementCurrent)-&gt;pChild = pElement; // insert there
      }
      else // add as sibling
      {
        // this iteration should not be needed but there maybe some untested degenerate case which this code will ensure works
        while ((*ppElementCurrent)-&gt;pSibling) // step down tree until free sibling node found
          *ppElementCurrent = (*ppElementCurrent)-&gt;pSibling;
        (*ppElementCurrent)-&gt;pSibling = pElement; // insert there
      }
      pElement-&gt;pPrevious = *ppElementCurrent; // point to previous
      *ppElementCurrent = pElement; // set current to our collection        
      if (elementType == kIOHIDElementTypeCollection) // if this element is a collection of other elements
      {
        gfAddAsChild = true; // add next set as children to this element
        HIDGetCollectionElements ((CFMutableDictionaryRef) refElement, &amp;pElement); // recursively process the collection
      }
      gfAddAsChild = false; // add next as this elements sibling (when return from a collection or with non-collections)
    }
  }
}

// ---------------------------------

// collects information from each array member in device element list (each array memeber = element)

static void HIDGetElementsCFArrayHandler (const void * value, void * parameter)
{
  if (CFGetTypeID (value) == CFDictionaryGetTypeID ()) 
    HIDAddElement ((CFTypeRef) value, (pRecElement *) parameter);
}

// ---------------------------------

// handles retrieval of element information from arrays of elements in device IO registry information

static void HIDGetElements (CFTypeRef refElementCurrent, pRecElement *ppCurrentElement)
{
  CFTypeID type = CFGetTypeID (refElementCurrent);
  if (type == CFArrayGetTypeID()) // if element is an array
  {
    CFRange range = {0, CFArrayGetCount (refElementCurrent)};
    // CountElementsCFArrayHandler called for each array member
    CFArrayApplyFunction (refElementCurrent, range, HIDGetElementsCFArrayHandler, ppCurrentElement);
  }
}       

// ---------------------------------

// handles extracting element information from element collection CF types
// used from top level element decoding and hierarchy deconstruction to flatten device element list

static void HIDGetCollectionElements (CFMutableDictionaryRef deviceProperties, pRecElement *ppCurrentCollection)
{
  CFTypeRef refElementTop = CFDictionaryGetValue (deviceProperties, CFSTR(kIOHIDElementKey));
  if (refElementTop)
    HIDGetElements (refElementTop, ppCurrentCollection);
  else
    HIDReportError (&quot;CFDictionaryGetValue error when creating CFTypeRef for kIOHIDElementKey.&quot;);
}

// ---------------------------------

// use top level element usage page and usage to discern device usage page and usage setting appropriate values in device record

static void HIDTopLevelElementHandler (const void * value, void * parameter)
{
  CFTypeRef refCF = 0;
  if ((NULL == value) || (NULL == parameter)) 
    return; // (paramErr)
  if (CFGetTypeID (value) != CFDictionaryGetTypeID ()) 
    return;
  refCF = CFDictionaryGetValue (value, CFSTR(kIOHIDElementUsagePageKey));
  if (!CFNumberGetValue (refCF, kCFNumberLongType, &amp;((pRecDevice) parameter)-&gt;usagePage))
    HIDReportError (&quot;CFNumberGetValue error retrieving pDevice-&gt;usagePage.&quot;);
  refCF = CFDictionaryGetValue (value, CFSTR(kIOHIDElementUsageKey));
  if (!CFNumberGetValue (refCF, kCFNumberLongType, &amp;((pRecDevice) parameter)-&gt;usage))
    HIDReportError (&quot;CFNumberGetValue error retrieving pDevice-&gt;usage.&quot;);
}

// ---------------------------------

// extracts device info from CF dictionary records in IO registry

static void HIDGetDeviceInfo (io_object_t hidDevice, CFMutableDictionaryRef hidProperties, pRecDevice pDevice)
{
  CFMutableDictionaryRef usbProperties = 0;
  io_registry_entry_t parent1, parent2;
  
  // Mac OS X currently is not mirroring all USB properties to HID page so need to look at USB device page also
  // get dictionary for usb properties: step up two levels and get CF dictionary for USB properties
  if ((KERN_SUCCESS == IORegistryEntryGetParentEntry (hidDevice, kIOServicePlane, &amp;parent1)) &amp;&amp;
    (KERN_SUCCESS == IORegistryEntryGetParentEntry (parent1, kIOServicePlane, &amp;parent2)) &amp;&amp;
    (KERN_SUCCESS == IORegistryEntryCreateCFProperties (parent2, &amp;usbProperties, kCFAllocatorDefault, kNilOptions)))
  {
    if (usbProperties)
    {
      CFTypeRef refCF = 0;
      // get device info
      // try hid dictionary first, if fail then go to usb dictionary
      
      
      // get transport
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDTransportKey));
      if (refCF)
      {
        if (!CFStringGetCString (refCF, pDevice-&gt;transport, 256, CFStringGetSystemEncoding ()))
          HIDReportError (&quot;CFStringGetCString error retrieving pDevice-&gt;transport.&quot;);
        CleanString (pDevice-&gt;transport);
      }
      
      // get vendorID
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDVendorIDKey));
      if (!refCF)
        refCF = CFDictionaryGetValue (usbProperties, CFSTR(&quot;idVendor&quot;));
      if (refCF)
      {
        if (!CFNumberGetValue (refCF, kCFNumberLongType, &amp;pDevice-&gt;vendorID))
          HIDReportError (&quot;CFNumberGetValue error retrieving pDevice-&gt;vendorID.&quot;);
      }
      
      // get product ID
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDProductIDKey));
      if (!refCF)
        refCF = CFDictionaryGetValue (usbProperties, CFSTR(&quot;idProduct&quot;));
      if (refCF)
      {
        if (!CFNumberGetValue (refCF, kCFNumberLongType, &amp;pDevice-&gt;productID))
          HIDReportError (&quot;CFNumberGetValue error retrieving pDevice-&gt;productID.&quot;);
      }
      
      // get product version
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDVersionNumberKey));
      if (refCF)
      {
        if (!CFNumberGetValue (refCF, kCFNumberLongType, &amp;pDevice-&gt;version))
          HIDReportError (&quot;CFNumberGetValue error retrieving pDevice-&gt;version.&quot;);
      }
      
      // get manufacturer name
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDManufacturerKey));
      if (!refCF)
        refCF = CFDictionaryGetValue (usbProperties, CFSTR(&quot;USB Vendor Name&quot;));
      if (refCF)
      {
        if (!CFStringGetCString (refCF, pDevice-&gt;manufacturer, 256, CFStringGetSystemEncoding ()))
          HIDReportError (&quot;CFStringGetCString error retrieving pDevice-&gt;manufacturer.&quot;);
        CleanString (pDevice-&gt;manufacturer);
      }
      
      // get product name
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDProductKey));
      if (!refCF)
        refCF = CFDictionaryGetValue (usbProperties, CFSTR(&quot;USB Product Name&quot;));
      if (refCF)
      {
        if (!CFStringGetCString (refCF, pDevice-&gt;product, 256, CFStringGetSystemEncoding ()))
          HIDReportError (&quot;CFStringGetCString error retrieving pDevice-&gt;product.&quot;);
        CleanString (pDevice-&gt;product);
      }
      
      // get serial
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDSerialNumberKey));
      if (refCF)
      {
        if (!CFStringGetCString (refCF, pDevice-&gt;serial, 256, CFStringGetSystemEncoding ()))
          HIDReportError (&quot;CFStringGetCString error retrieving pDevice-&gt;serial.&quot;);
        CleanString (pDevice-&gt;serial);
      }
      
      // get location ID
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDLocationIDKey));
      if (!refCF)
        refCF = CFDictionaryGetValue (usbProperties, CFSTR(&quot;locationID&quot;));
      if (refCF)
      {
        if (!CFNumberGetValue (refCF, kCFNumberLongType, &amp;pDevice-&gt;locID))
          HIDReportError (&quot;CFNumberGetValue error retrieving pDevice-&gt;locID.&quot;);
      }
      
      // get usage page and usage
      refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDPrimaryUsagePageKey));
      if (refCF)
      {
        if (!CFNumberGetValue (refCF, kCFNumberLongType, &amp;pDevice-&gt;usagePage))
          HIDReportError (&quot;CFNumberGetValue error retrieving pDevice-&gt;usagePage.&quot;);
        refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDPrimaryUsageKey));
        if (refCF)
          if (!CFNumberGetValue (refCF, kCFNumberLongType, &amp;pDevice-&gt;usage))
            HIDReportError (&quot;CFNumberGetValue error retrieving pDevice-&gt;usage.&quot;);
      }
      if (NULL == refCF) // get top level element HID usage page or usage
      {
        // use top level element instead
        CFTypeRef refCFTopElement = 0;
        refCFTopElement = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDElementKey));
        {
          // refCFTopElement points to an array of element dictionaries
          CFRange range = {0, CFArrayGetCount (refCFTopElement)};
          CFArrayApplyFunction (refCFTopElement, range, HIDTopLevelElementHandler, NULL);
        }
      }
    }
    else
      HIDReportError (&quot;IORegistryEntryCreateCFProperties failed to create usbProperties.&quot;);

    CFRelease (usbProperties);
    if (kIOReturnSuccess != IOObjectRelease (parent2))
      HIDReportError (&quot;IOObjectRelease error with parent2.&quot;);
    if (kIOReturnSuccess != IOObjectRelease (parent1))
      HIDReportError (&quot;IOObjectRelease error with parent1.&quot;);
  }
}

// ---------------------------------

// adds device to linked list of devices passed in (handles NULL lists properly)

static void HIDAddDevice (pRecDevice *ppListDeviceHead, pRecDevice pNewDevice)
{
  if (NULL == *ppListDeviceHead)
    *ppListDeviceHead = pNewDevice;
  else
  {
    pRecDevice pDevicePrevious = NULL, pDevice = *ppListDeviceHead;
    while (pDevice)
    {
      pDevicePrevious = pDevice;
      pDevice = pDevicePrevious-&gt;pNext;
    }
    pDevicePrevious-&gt;pNext = pNewDevice;
  }
  pNewDevice-&gt;pNext = NULL;
}

// ---------------------------------

// adds device to linked list of devices passed in (handles NULL lists properly)
// returns next device is old list (for properly iterating)

static pRecDevice HIDMoveDevice (pRecDevice *ppListDeviceHead, pRecDevice pNewDevice, pRecDevice *ppOldListDeviceHead)
{
  pRecDevice pDeviceNext = NULL;
  if (!pNewDevice || !ppOldListDeviceHead || !ppListDeviceHead) { // handle NULL pointers
    HIDReportError (&quot;HIDMoveDevice, NULL input error.&quot;);
    return pDeviceNext;
  }

  // remove from old
  if (pNewDevice == *ppOldListDeviceHead) { // replacing head
    *ppOldListDeviceHead = pNewDevice-&gt;pNext;
    pDeviceNext = *ppOldListDeviceHead;
  } else {
    pRecDevice pDevicePrevious = NULL, pDevice = *ppOldListDeviceHead;
    while (pDevice &amp;&amp; (pDevice != pNewDevice)) { // step through list until match or end
      pDevicePrevious = pDevice;
      pDevice = pDevicePrevious-&gt;pNext;
    }
    if (pDevice == pNewDevice) { // if there was a match
      pDevicePrevious-&gt;pNext = pDevice-&gt;pNext; // skip this device
      pDeviceNext = pDevice-&gt;pNext;
    } else
      HIDReportError (&quot;HIDMoveDevice device not found when moving.&quot;);
  }

  // add to new list
  HIDAddDevice (ppListDeviceHead, pNewDevice);
  return pDeviceNext; // return next device
}

// ---------------------------------

// given a IO device object build a flat device record including device info and elements

static pRecDevice HIDBuildDevice (io_object_t hidDevice)
{
  pRecDevice pDevice = (pRecDevice) malloc (sizeof (recDevice));
  if (pDevice)
  {
    unsigned long i;
    // get dictionary for HID properties
    CFMutableDictionaryRef hidProperties = 0;
    kern_return_t result = IORegistryEntryCreateCFProperties (hidDevice, &amp;hidProperties, kCFAllocatorDefault, kNilOptions);
    // clear record
    for (i = 0; i &lt; sizeof (recDevice); i++) // clear array
      *((char *) pDevice + i) = 0x00;
    if ((result == KERN_SUCCESS) &amp;&amp; hidProperties)
    {
      pRecElement pCurrentElement = NULL;
      // create device interface
      result = HIDCreateOpenDeviceInterface (hidDevice, pDevice);
      if (kIOReturnSuccess != result)
        HIDReportErrorNum (&quot;HIDCreateOpenDeviceInterface failed.&quot;, result);
      HIDGetDeviceInfo (hidDevice, hidProperties, pDevice); // hidDevice used to find parents in registry tree
      // set current device for use in getting elements
      gCurrentGetDevice = pDevice;
      HIDGetCollectionElements (hidProperties, &amp;pCurrentElement);
      gCurrentGetDevice = NULL;
      CFRelease (hidProperties);
    }
    else
      HIDReportErrorNum (&quot;IORegistryEntryCreateCFProperties error when creating deviceProperties.&quot;, result);
  }
  else
    HIDReportError (&quot;malloc error when allocating pRecDevice.&quot;);
  return pDevice;
}

// ---------------------------------

// build flat linked list of devices from device iterator

static pRecDevice HIDCreateSingleTypeDeviceList (io_iterator_t hidObjectIterator)
{
  IOReturn result = kIOReturnSuccess;
  pRecDevice pListDeviceHead = NULL;
  pRecDevice pNewDevice = NULL;
  io_object_t ioHIDDeviceObject = NULL;

  while ((ioHIDDeviceObject = IOIteratorNext (hidObjectIterator)))
  {
    pNewDevice = HIDBuildDevice (ioHIDDeviceObject);
    // dump device object, it is no longer needed
    result = IOObjectRelease (ioHIDDeviceObject);
    if (KERN_SUCCESS != result)
      HIDReportErrorNum (&quot;IOObjectRelease error with ioHIDDeviceObject.&quot;, result);
    HIDAddDevice (&amp;pListDeviceHead, pNewDevice);
  }
  result = IOObjectRelease (hidObjectIterator); // release the iterator
  if (kIOReturnSuccess != result) 
    HIDReportErrorNum (&quot;IOObjectRelease error with hidObjectIterator.&quot;, result);
  return pListDeviceHead;
}

// ---------------------------------

// build flat linked list of devices from list of usages and usagePages

static pRecDevice HIDCreateMultiTypeDeviceList (UInt32 *usagePage, UInt32 *usage, UInt32 numDeviceTypes)
{
  mach_port_t masterPort = NULL;
  io_iterator_t hidObjectIterator = NULL;
  pRecDevice pNewDeviceList = NULL; // build new list
  UInt32 i;

  if (!usage || !usagePage || (numDeviceTypes == 0))
    HIDReportError (&quot;HIDCreateMultiTypeDeviceList: NULL usage, usagePage or numDeviceTypes.&quot;);
  else {
    if (kIOReturnSuccess != IOMasterPort (bootstrap_port, &amp;masterPort))
      HIDReportError (&quot;HIDCreateMultiTypeDeviceList: IOMasterPort error with bootstrap_port.&quot;);
    else
      for (i = 0; i &lt; numDeviceTypes; i++) { // for all usage and usage page types
        pRecDevice pDeviceList = NULL;
        hidObjectIterator = HIDGetIterator (masterPort, usagePage[i], usage[i]); // get iterator
        if (NULL != hidObjectIterator) 
          pDeviceList = HIDCreateSingleTypeDeviceList (hidObjectIterator); // build device list
        if (NULL != pDeviceList) // if there are devices to merge
          HIDMergeDeviceList (&amp;pNewDeviceList, &amp;pDeviceList); // merge into new list
        while (NULL != pDeviceList) // dump what is left of source list (head first no clean up needed)
          pDeviceList = HIDDisposeDevice (&amp;pDeviceList); // dispose current device return next device, will set pDeviceList to NULL
      }
  }
  return pNewDeviceList;
}

// ---------------------------------

// given a device list and a device find if device is in list
// returns true if in list, false otherwise
// this is problematic for generic devices as location id could be zero
// also match number of elements
static Boolean HIDFindDeviceInList (pRecDevice pDeviceList, pRecDevice pFindDevice)
{
  Boolean found = false; // not found
  pRecDevice pDevice = pDeviceList; // not really needed but is clearer this way
  while (pDevice &amp;&amp; !found) { // while we still have device to look at and have not found the target device
    if ((pDevice-&gt;vendorID == pFindDevice-&gt;vendorID) &amp;&amp;   // if we match same vendor, product &amp; location
      (pDevice-&gt;productID == pFindDevice-&gt;productID) &amp;&amp; // this is not quite right for same tyes plugged into the same location but different physical devices
      (pDevice-&gt;locID == pFindDevice-&gt;locID) &amp;&amp;      // since this is a corner and impossible to detect without serial numbers case we will ignore it
      (pDevice-&gt;usage == pFindDevice-&gt;usage) &amp;&amp;     // ensure all device parameters really match (helps with generic devices)    
      (pDevice-&gt;usagePage == pFindDevice-&gt;usagePage) &amp;&amp;            
      (pDevice-&gt;totalElements == pFindDevice-&gt;totalElements) &amp;&amp;            
      (pDevice-&gt;features == pFindDevice-&gt;features) &amp;&amp;            
      (pDevice-&gt;inputs == pFindDevice-&gt;inputs) &amp;&amp;            
      (pDevice-&gt;outputs == pFindDevice-&gt;outputs) &amp;&amp;            
      (pDevice-&gt;collections == pFindDevice-&gt;collections) &amp;&amp;            
      (pDevice-&gt;axis == pFindDevice-&gt;axis) &amp;&amp;            
      (pDevice-&gt;buttons == pFindDevice-&gt;buttons) &amp;&amp;            
      (pDevice-&gt;hats == pFindDevice-&gt;hats) &amp;&amp;            
      (pDevice-&gt;sliders == pFindDevice-&gt;sliders) &amp;&amp;            
      (pDevice-&gt;wheels == pFindDevice-&gt;wheels) &amp;&amp;            
      (pDevice-&gt;dials == pFindDevice-&gt;dials))            
      found = true; // found device
    pDevice = pDevice-&gt;pNext; // step to next device
  }
  return found;
}

// ---------------------------------

// update main list with new devices and remove unplugged devices
// startegy is to update based on location of device, if this changed then previous device was
// at least unplugged and plugged in somewhere else, thus can't be considered the same
// return true if any changes
 
static Boolean HIDCompareUpdateDeviceList (pRecDevice *ppListDeviceHead, pRecDevice *ppNewDeviceList)
{
  Boolean changedList = false;
  pRecDevice pDevice = *ppListDeviceHead;
  pRecDevice pPrevDevice = NULL;
  while (pDevice)  { // for all the devices in main list
    Boolean present = false;
    // ensure they are in new list
    present = HIDFindDeviceInList (*ppNewDeviceList, pDevice);
    // remove those that are not
    if (!present) {
      changedList = true;
      if (pDevice == *ppListDeviceHead) // if we are removing the list head
        *ppListDeviceHead = pDevice-&gt;pNext; // move list head
      pDevice = HIDDisposeDevice (&amp;pDevice); // remove device from list and dispose device and step to next device
      if (pPrevDevice) // next device clean up required for HIDDisposeDevice 
        pPrevDevice-&gt;pNext = pDevice;
     } else {
      pPrevDevice = pDevice; // only advance here since other case removes a device and prev stays constant
      pDevice = pDevice-&gt;pNext; // step to next device
    }
  }
  pDevice = *ppNewDeviceList;
  while (pDevice)  { // for all the devices in new list
    Boolean present = false;
    present = HIDFindDeviceInList (*ppListDeviceHead, pDevice); // ensure they are in original list
    if (!present) { // not found in old list so move to old list from new 
      changedList = true;
      pDevice = HIDMoveDevice (ppListDeviceHead, pDevice, ppNewDeviceList); // move those that are not
    } else // found
      pDevice = pDevice-&gt;pNext; // just step to next device
  }
  return changedList;
}

// ---------------------------------

// merges two devicelist into single *ppNewDeviceList
// note: ppNewDeviceList may have head device modified (such as if it is NULL) thus pointer to pointer to device
// devices are matched on vendorID, productID, locID by HIDFindDeviceInList
// device record in pNewDeviceList maintained

static void HIDMergeDeviceList (pRecDevice *ppNewDeviceList, pRecDevice *ppDeviceList)
{
  pRecDevice pDevice = *ppDeviceList;
  while (pDevice)  { // for all the devices in old list
    Boolean present = false;
    present = HIDFindDeviceInList (*ppNewDeviceList, pDevice); // ensure they are in new list
    if (!present) // not found in new list
      pDevice = HIDMoveDevice (ppNewDeviceList, pDevice, ppDeviceList); // move to new list and get next
    else // found in new list (so don't do anything
      pDevice = pDevice-&gt;pNext; // just step to next device
  }
}

// ---------------------------------

// builds a matching dictionary based on usage page and usage

static CFMutableDictionaryRef HIDSetUpMatchingDictionary (UInt32 usagePage, UInt32 usage)
{
  CFNumberRef refUsage = NULL, refUsagePage = NULL;
  CFMutableDictionaryRef refHIDMatchDictionary = NULL;

  // Set up a matching dictionary to search I/O Registry by class name for all HID class devices.
  refHIDMatchDictionary = IOServiceMatching (kIOHIDDeviceKey);
  if ((refHIDMatchDictionary != NULL) &amp;&amp; (usagePage) &amp;&amp; (usage))
  {
    // Add key for device type (joystick, in this case) to refine the matching dictionary.
    refUsagePage = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;usagePage);
    CFDictionarySetValue (refHIDMatchDictionary, CFSTR (kIOHIDPrimaryUsagePageKey), refUsagePage);
    CFRelease (refUsagePage);
    refUsage = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;usage);
    CFDictionarySetValue (refHIDMatchDictionary, CFSTR (kIOHIDPrimaryUsageKey), refUsage);
    CFRelease (refUsage);
  }
  else if (NULL == refHIDMatchDictionary)
    HIDReportError (&quot;Failed to get HID CFMutableDictionaryRef via IOServiceMatching.&quot;);
  return refHIDMatchDictionary;
}

// ---------------------------------

// sets up a matching dictionary based on usage page and usage passed in and uses it to get a device iterator
// 

static io_iterator_t HIDGetIterator (const mach_port_t masterPort, UInt32 usagePage, UInt32 usage)
{
  IOReturn result = kIOReturnSuccess;
  CFMutableDictionaryRef hidMatchDictionary = NULL;
  io_iterator_t hidObjectIterator = NULL;

  // Set up matching dictionary to search the I/O Registry for HID devices we are interested in. Dictionary reference is NULL if error.
  hidMatchDictionary = HIDSetUpMatchingDictionary (usagePage, usage);
  if (NULL == hidMatchDictionary)
  {
    HIDReportError (&quot;Couldn't create a matching dictionary.&quot;);
    return hidObjectIterator;
  }

  // Now search I/O Registry for matching devices.
  result = IOServiceGetMatchingServices (masterPort, hidMatchDictionary, &amp;hidObjectIterator);
  if (kIOReturnSuccess != result)
     HIDReportErrorNum (&quot;Failed to create IO object iterator, error:&quot;, result);
// --- this is a &quot;normal&quot; failure condition (such as no devices of a certain type plugged in) so do not issue a warning
//  else if (NULL == hidObjectIterator) // likely no HID devices which matched selection criteria are connected
//     HIDReportError (&quot;Warning: Could not find any matching devices, thus iterator creation failed.&quot;);
 
  // IOServiceGetMatchingServices consumes a reference to the dictionary, so we don't need to release the dictionary ref.
  hidMatchDictionary = NULL;
  return hidObjectIterator;
}

// ---------------------------------

// disposes of the element list associated with a device and the memory associated with the list
// uses depthwise recursion to dispose both collections and elements.

static void HIDDisposeDeviceElements (pRecElement pElement)
{
  if (pElement)
  {
    if (pElement-&gt;pChild)
      HIDDisposeDeviceElements (pElement-&gt;pChild);
    if (pElement-&gt;pSibling)
      HIDDisposeDeviceElements (pElement-&gt;pSibling);
    free (pElement);
  }
  
}

// ---------------------------------

// disposes of a single device, closing and releasing interface, freeing memory for device and elements, setting device pointer to NULL
// all your device no longer belong to us... (i.e., you do not 'own' the device anymore)
// routines calling this need to fix up previous previous device next device pointer to point to the device returned by this routine

static pRecDevice HIDDisposeDevice (pRecDevice *ppDevice)
{
  kern_return_t result = KERN_SUCCESS;
  pRecDevice pDeviceNext = NULL;
  if (*ppDevice)
  {
    // save next device prior to disposing of this device
    pDeviceNext = (*ppDevice)-&gt;pNext;
    HIDDisposeDeviceElements ((*ppDevice)-&gt;pListElements);
    (*ppDevice)-&gt;pListElements = NULL;
    result = HIDCloseReleaseInterface (*ppDevice); // function sanity checks interface value (now application does not own device)
    if (kIOReturnSuccess != result)
      HIDReportErrorNum (&quot;HIDCloseReleaseInterface failed when trying to dipose device.&quot;, result);
    free (*ppDevice);
    *ppDevice = NULL;
  }
  return pDeviceNext;
}

// ---------------------------------

// count number of devices in global device list (gpDeviceList)

static UInt32 HIDCountCurrentDevices (pRecDevice pDeviceList)
{
  pRecDevice pDevice = pDeviceList;
  UInt32 devices = 0;
  while (pDevice)
  {
    devices++;
    pDevice = pDevice-&gt;pNext;
  }
  return devices;
}

// ---------------------------------

// matches type masks passed in to actual element types (which are not set up to be used as a mask
static Boolean HIDMatchElementTypeMask (IOHIDElementType type, HIDElementTypeMask typeMask)
{
  if (typeMask &amp; kHIDElementTypeInput)
    if ((type == kIOHIDElementTypeInput_Misc) || (type == kIOHIDElementTypeInput_Button) || (type == kIOHIDElementTypeInput_Axis) || (type == kIOHIDElementTypeInput_ScanCodes))
      return true;
  if (typeMask &amp; kHIDElementTypeOutput)
    if (type == kIOHIDElementTypeOutput)
      return true;
  if (typeMask &amp; kHIDElementTypeFeature)
    if (type == kIOHIDElementTypeFeature)
      return true;
  if (typeMask &amp; kHIDElementTypeCollection)
    if (type == kIOHIDElementTypeCollection)
      return true;
  return false;
}

// ---------------------------------

static pRecElement HIDGetDeviceElement (pRecElement pElement, HIDElementTypeMask typeMask)
{
  // we are asking for this element
  if (NULL != pElement)
  {
    if (HIDMatchElementTypeMask (pElement-&gt;type, typeMask)) // if the type match what we are looking for
      return pElement; // return the element
    else
      return HIDGetNextDeviceElement (pElement, typeMask); // else get the next one
  }
  return NULL;
}

// ---------------------------------

void HIDDumpDevice (pRecDevice pDevice)
{
  printf (&quot;    %s %s: 0x%lX&quot;, pDevice-&gt;manufacturer, pDevice-&gt;product, (unsigned long)pDevice);  
  if (!pDevice-&gt;pListElements)
    printf (&quot; (NO elements)&quot;);    
  else
    printf (&quot; (%ld elements)&quot;, pDevice-&gt;inputs);    
}

// ---------------------------------

void HIDDumpDeviceList (pRecDevice pDeviceList)
{
  printf (&quot;HIDDumpDeviceList (0x%lX):\n&quot;, (unsigned long)pDeviceList);
  pRecDevice pDevice = pDeviceList;
  while (pDevice) {
    HIDDumpDevice (pDevice);
    printf(&quot;\n&quot;);
    pDevice = pDevice-&gt;pNext;
  }
}

#pragma mark -
// =================================
// public functions

// builds list of devices with elements (allocates memory and captures devices) 
// in which the devices could be of different types/usages
// list is allocated internally within HID Utilites and can be accessed via accessor functions
// structures within list are considered flat and user accessable, but not user modifiable
// can be called again to rebuild list to account for new devices (will do the right thing in case of disposing existing list)
// usagePage, usage are each a numDeviceTypes sized array of matching usage and usage pages
// returns true if succesful

Boolean HIDBuildMultiDeviceList (UInt32 *pUsagePage, UInt32 *pUsage, UInt32 numDeviceTypes)
{
  gpDeviceList = HIDCreateMultiTypeDeviceList (pUsagePage, pUsage, numDeviceTypes);  
  gNumDevices = HIDCountCurrentDevices (gpDeviceList);  // set count of main list
  if (gpDeviceList)
    return true; 
  else
    return false;
}

// ---------------------------------

// same as above but this uses a single usagePage and usage

Boolean HIDBuildDeviceList (UInt32 usagePage, UInt32 usage)
{
  return HIDBuildMultiDeviceList (&amp;usagePage, &amp;usage, 1); // call HIDBuildMultiDeviceList with a single usage
}

// ---------------------------------

// updates the current device list for any new/removed devices
// if this is called before HIDBuildDeviceList the it functions like HIDBuildMultiDeviceList
// usagePage, usage are each a numDeviceTypes sized array of matching usage and usage pages
// returns true if successful which means if any device were added or removed (the device config changed)

Boolean HIDUpdateDeviceList (UInt32 *pUsagePage, UInt32 *pUsage, UInt32 numDeviceTypes)
{
  Boolean updateResult = false;
  pRecDevice pNewDeviceList = HIDCreateMultiTypeDeviceList (pUsagePage, pUsage, numDeviceTypes); // get current list
  if (gpDeviceList) { // if we have a list already
    updateResult = HIDCompareUpdateDeviceList (&amp;gpDeviceList, &amp;pNewDeviceList); // update main list
    while (NULL != pNewDeviceList) // dispose new list after compare and update of main list (heaad first distruction to no next device clean up)
      pNewDeviceList = HIDDisposeDevice (&amp;pNewDeviceList); // dispose current device return next device, will set pNewDeviceList to NULL
  } else
    gpDeviceList = pNewDeviceList;
  gNumDevices = HIDCountCurrentDevices (gpDeviceList);  // set count
  return updateResult;
}

// ---------------------------------

// release list built by above function
// MUST be called prior to application exit to properly release devices
// if not called (or app crashes) devices can be recovered by pluging into different location in USB chain

void HIDReleaseDeviceList (void)
{
  IOReturn result = kIOReturnSuccess;
  if (NULL != gpDeviceList) // release queues and device
  {
    result = HIDReleaseAllDeviceQueues ();
    if (kIOReturnSuccess != result) 
      HIDReportErrorNum (&quot;Could not Dequeue Device elements and release devices.&quot;, result);
  }
  while (NULL != gpDeviceList) // head first destruction no clean needed
     gpDeviceList = HIDDisposeDevice (&amp;gpDeviceList); // dispose current device return next device will set gpDeviceList to NULL
  gNumDevices = 0;
}

// ---------------------------------

// does a device list exist

Boolean HIDHaveDeviceList (void)
{
  if (NULL != gpDeviceList)
    return true;
  return false;
}

// ---------------------------------

// how many HID devices have been found
// returns 0 if no device list exist

UInt32 HIDCountDevices (void)
{
  return gNumDevices;
}

// ---------------------------------

// how many elements does a specific device have
// returns 0 if device is invlaid or NULL

UInt32 HIDCountDeviceElements (pRecDevice pDevice, HIDElementTypeMask typeMask)
{
  long count = 0;
  if (NULL != pDevice)
  {
    if (typeMask &amp; kHIDElementTypeInput)
      count += pDevice-&gt;inputs;
    if (typeMask &amp; kHIDElementTypeOutput)
      count += pDevice-&gt;outputs;
    if (typeMask &amp; kHIDElementTypeFeature)
      count += pDevice-&gt;features;
    if (typeMask &amp; kHIDElementTypeCollection)
      count += pDevice-&gt;collections;
  }
  return count;
}

// ---------------------------------

// get the first device in the device list
// returns NULL if no list exists

pRecDevice HIDGetFirstDevice (void)
{
  return gpDeviceList;
}

// ---------------------------------

// get next device in list given current device as parameter
// returns NULL if end of list

pRecDevice HIDGetNextDevice (pRecDevice pDevice)
{
  if (NULL != pDevice)
    return pDevice-&gt;pNext;
  else
    return NULL;
}

// ---------------------------------

// get the first element of device passed in as parameter
// returns NULL if no list exists or device does not exists or is NULL
pRecElement HIDGetFirstDeviceElement (pRecDevice pDevice, HIDElementTypeMask typeMask)
{
  if (NULL != pDevice)
  {
    if (HIDMatchElementTypeMask (pDevice-&gt;pListElements-&gt;type, typeMask)) // ensure first type matches
      return pDevice-&gt;pListElements;
    else
      return HIDGetNextDeviceElement (pDevice-&gt;pListElements, typeMask);
  }
  else
    return NULL;
}

// ---------------------------------

// get next element of given device in list given current element as parameter
// will walk down each collection then to next element or collection (depthwise traverse)
// returns NULL if end of list
// uses mask of HIDElementTypeMask to restrict element found
// use kHIDElementTypeIO to get previous HIDGetNextDeviceElement functionality
pRecElement HIDGetNextDeviceElement (pRecElement pElement, HIDElementTypeMask typeMask)
{
  // should only have elements passed in (though someone could mix calls and pass us a collection)
  // collection means return the next child or sibling (in that order)
  // element means returnt he next sibling (as elements can't have children
  if (NULL != pElement)
  {
    if (pElement-&gt;pChild)
    {
      if (pElement-&gt;type != kIOHIDElementTypeCollection)
        HIDReportError (&quot;Malformed element list: found child of element.&quot;);
      else  
        return HIDGetDeviceElement (pElement-&gt;pChild, typeMask); // return the child of this element
    }
    else if (pElement-&gt;pSibling)
    {
      return HIDGetDeviceElement (pElement-&gt;pSibling, typeMask); //return the sibling of this element
    }
    else // at end back up correctly
    {
      pRecElement pPreviousElement = NULL;
      // malformed device ending in collection
      if (pElement-&gt;type == kIOHIDElementTypeCollection)
        HIDReportError (&quot;Malformed device: found collection at end of element chain.&quot;);
      // walk back up tree to element prior to first collection ecountered and take next element 
      while (pElement)
      {
        pPreviousElement = pElement;
        pElement = pElement-&gt;pPrevious; // look at previous element
        if (!pElement) // if we are at the top and did not find another branch
          return NULL;
        // if the previous element is the branch element
        // which means the previous the we are coming back up the child path and we have a sibling
        if ((pPreviousElement != pElement-&gt;pSibling) &amp;&amp; pElement-&gt;pSibling)
          break;
      }
      // now we must have been down the child route so go down the sibling route
      pElement = pElement-&gt;pSibling; // element of interest
      return HIDGetDeviceElement (pElement, typeMask); // otherwise return this element
    }
  }
  return NULL;
}

// ---------------------------------

// get previous element of given device in list given current element as parameter
// this wlaks directly up the tree to the top element and does not search at each level
// returns NULL if beginning of list
// uses mask of HIDElementTypeMask to restrict element found
// use kHIDElementTypeIO to get non-collection elements
pRecElement HIDGetPreviousDeviceElement (pRecElement pElement, HIDElementTypeMask typeMask)
{
  pRecElement pPreviousElement = pElement-&gt;pPrevious;
  // walk back up tree to element prior
  while (pPreviousElement &amp;&amp; !HIDMatchElementTypeMask (pPreviousElement-&gt;type, typeMask))
  {
    pElement = pPreviousElement; // look at previous element
    pPreviousElement = pElement-&gt;pPrevious;
  }
  return pPreviousElement; // return this element
}

// ---------------------------------

// returns C string type name given a type enumeration passed in as parameter (see IOHIDKeys.h)
// returns &quot;Unknown Type&quot; for invalid types

void HIDGetTypeName (unsigned long type, char * cstrName)
{
  switch (type)
  {
    case kIOHIDElementTypeInput_Misc:
      sprintf(cstrName, &quot;Miscellaneous Input&quot;);
      break;
    case kIOHIDElementTypeInput_Button:
      sprintf(cstrName, &quot;Button Input&quot;);
      break;
    case kIOHIDElementTypeInput_Axis:
      sprintf(cstrName, &quot;Axis Input&quot;);
      break;
    case kIOHIDElementTypeInput_ScanCodes:
      sprintf(cstrName, &quot;Scan Code Input&quot;);
      break;
    case kIOHIDElementTypeOutput:
      sprintf(cstrName, &quot;Output&quot;);
      break;
    case kIOHIDElementTypeFeature:
      sprintf(cstrName, &quot;Feature&quot;);
      break;
    case kIOHIDElementTypeCollection:
      sprintf(cstrName, &quot;Collection&quot;);
      break;
    default:
      sprintf(cstrName, &quot;Unknown Type&quot;);
      break;
  }
}

// ---------------------------------

// returns C string usage given usage page and usage passed in as parameters (see IOUSBHIDParser.h)
// returns usage page and usage values in string form for unknown values

void HIDGetUsageName (long valueUsagePage, long valueUsage, char * cstrName)
{
  switch (valueUsagePage)
  {
    case kHIDPage_Undefined:
       switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Undefined Page, Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_GenericDesktop:
      switch (valueUsage)
      {
        case kHIDUsage_GD_Pointer: sprintf (cstrName, &quot;Pointer&quot;); break;
        case kHIDUsage_GD_Mouse: sprintf (cstrName, &quot;Mouse&quot;); break;
        case kHIDUsage_GD_Joystick: sprintf (cstrName, &quot;Joystick&quot;); break;
        case kHIDUsage_GD_GamePad: sprintf (cstrName, &quot;GamePad&quot;); break;
        case kHIDUsage_GD_Keyboard: sprintf (cstrName, &quot;Keyboard&quot;); break;
        case kHIDUsage_GD_Keypad: sprintf (cstrName, &quot;Keypad&quot;); break;
        case kHIDUsage_GD_MultiAxisController: sprintf (cstrName, &quot;Multi-Axis Controller&quot;); break;

        case kHIDUsage_GD_X: sprintf (cstrName, &quot;X-Axis&quot;); break;
        case kHIDUsage_GD_Y: sprintf (cstrName, &quot;Y-Axis&quot;); break;
        case kHIDUsage_GD_Z: sprintf (cstrName, &quot;Z-Axis&quot;); break;
        case kHIDUsage_GD_Rx: sprintf (cstrName, &quot;X-Rotation&quot;); break;
        case kHIDUsage_GD_Ry: sprintf (cstrName, &quot;Y-Rotation&quot;); break;
        case kHIDUsage_GD_Rz: sprintf (cstrName, &quot;Z-Rotation&quot;); break;
        case kHIDUsage_GD_Slider: sprintf (cstrName, &quot;Slider&quot;); break;
        case kHIDUsage_GD_Dial: sprintf (cstrName, &quot;Dial&quot;); break;
        case kHIDUsage_GD_Wheel: sprintf (cstrName, &quot;Wheel&quot;); break;
        case kHIDUsage_GD_Hatswitch: sprintf (cstrName, &quot;Hatswitch&quot;); break;
        case kHIDUsage_GD_CountedBuffer: sprintf (cstrName, &quot;Counted Buffer&quot;); break;
        case kHIDUsage_GD_ByteCount: sprintf (cstrName, &quot;Byte Count&quot;); break;
        case kHIDUsage_GD_MotionWakeup: sprintf (cstrName, &quot;Motion Wakeup&quot;); break;
        case kHIDUsage_GD_Start: sprintf (cstrName, &quot;Start&quot;); break;
        case kHIDUsage_GD_Select: sprintf (cstrName, &quot;Select&quot;); break;

        case kHIDUsage_GD_Vx: sprintf (cstrName, &quot;X-Velocity&quot;); break;
        case kHIDUsage_GD_Vy: sprintf (cstrName, &quot;Y-Velocity&quot;); break;
        case kHIDUsage_GD_Vz: sprintf (cstrName, &quot;Z-Velocity&quot;); break;
        case kHIDUsage_GD_Vbrx: sprintf (cstrName, &quot;X-Rotation Velocity&quot;); break;
        case kHIDUsage_GD_Vbry: sprintf (cstrName, &quot;Y-Rotation Velocity&quot;); break;
        case kHIDUsage_GD_Vbrz: sprintf (cstrName, &quot;Z-Rotation Velocity&quot;); break;
        case kHIDUsage_GD_Vno: sprintf (cstrName, &quot;Vno&quot;); break;

        case kHIDUsage_GD_SystemControl: sprintf (cstrName, &quot;System Control&quot;); break;
        case kHIDUsage_GD_SystemPowerDown: sprintf (cstrName, &quot;System Power Down&quot;); break;
        case kHIDUsage_GD_SystemSleep: sprintf (cstrName, &quot;System Sleep&quot;); break;
        case kHIDUsage_GD_SystemWakeUp: sprintf (cstrName, &quot;System Wake Up&quot;); break;
        case kHIDUsage_GD_SystemContextMenu: sprintf (cstrName, &quot;System Context Menu&quot;); break;
        case kHIDUsage_GD_SystemMainMenu: sprintf (cstrName, &quot;System Main Menu&quot;); break;
        case kHIDUsage_GD_SystemAppMenu: sprintf (cstrName, &quot;System App Menu&quot;); break;
        case kHIDUsage_GD_SystemMenuHelp: sprintf (cstrName, &quot;System Menu Help&quot;); break;
        case kHIDUsage_GD_SystemMenuExit: sprintf (cstrName, &quot;System Menu Exit&quot;); break;
        case kHIDUsage_GD_SystemMenu: sprintf (cstrName, &quot;System Menu&quot;); break;
        case kHIDUsage_GD_SystemMenuRight: sprintf (cstrName, &quot;System Menu Right&quot;); break;
        case kHIDUsage_GD_SystemMenuLeft: sprintf (cstrName, &quot;System Menu Left&quot;); break;
        case kHIDUsage_GD_SystemMenuUp: sprintf (cstrName, &quot;System Menu Up&quot;); break;
        case kHIDUsage_GD_SystemMenuDown: sprintf (cstrName, &quot;System Menu Down&quot;); break;

        case kHIDUsage_GD_DPadUp: sprintf (cstrName, &quot;DPad Up&quot;); break;
        case kHIDUsage_GD_DPadDown: sprintf (cstrName, &quot;DPad Down&quot;); break;
        case kHIDUsage_GD_DPadRight: sprintf (cstrName, &quot;DPad Right&quot;); break;
        case kHIDUsage_GD_DPadLeft: sprintf (cstrName, &quot;DPad Left&quot;); break;

        case kHIDUsage_GD_Reserved: sprintf (cstrName, &quot;Reserved&quot;); break;

        default: sprintf (cstrName, &quot;Generic Desktop Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Simulation:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Simulation Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_VR:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;VR Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Sport:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Sport Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Game:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Game Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_KeyboardOrKeypad:
      switch (valueUsage)
      {
        case kHIDUsage_KeyboardErrorRollOver: sprintf (cstrName, &quot;Error Roll Over&quot;); break;
        case kHIDUsage_KeyboardPOSTFail: sprintf (cstrName, &quot;POST Fail&quot;); break;
        case kHIDUsage_KeyboardErrorUndefined: sprintf (cstrName, &quot;Error Undefined&quot;); break;
        case kHIDUsage_KeyboardA: sprintf (cstrName, &quot;A&quot;); break;
        case kHIDUsage_KeyboardB: sprintf (cstrName, &quot;B&quot;); break;
        case kHIDUsage_KeyboardC: sprintf (cstrName, &quot;C&quot;); break;
        case kHIDUsage_KeyboardD: sprintf (cstrName, &quot;D&quot;); break;
        case kHIDUsage_KeyboardE: sprintf (cstrName, &quot;E&quot;); break;
        case kHIDUsage_KeyboardF: sprintf (cstrName, &quot;F&quot;); break;
        case kHIDUsage_KeyboardG: sprintf (cstrName, &quot;G&quot;); break;
        case kHIDUsage_KeyboardH: sprintf (cstrName, &quot;H&quot;); break;
        case kHIDUsage_KeyboardI: sprintf (cstrName, &quot;I&quot;); break;
        case kHIDUsage_KeyboardJ: sprintf (cstrName, &quot;J&quot;); break;
        case kHIDUsage_KeyboardK: sprintf (cstrName, &quot;K&quot;); break;
        case kHIDUsage_KeyboardL: sprintf (cstrName, &quot;L&quot;); break;
        case kHIDUsage_KeyboardM: sprintf (cstrName, &quot;M&quot;); break;
        case kHIDUsage_KeyboardN: sprintf (cstrName, &quot;N&quot;); break;
        case kHIDUsage_KeyboardO: sprintf (cstrName, &quot;O&quot;); break;
        case kHIDUsage_KeyboardP: sprintf (cstrName, &quot;P&quot;); break;
        case kHIDUsage_KeyboardQ: sprintf (cstrName, &quot;Q&quot;); break;
        case kHIDUsage_KeyboardR: sprintf (cstrName, &quot;R&quot;); break;
        case kHIDUsage_KeyboardS: sprintf (cstrName, &quot;S&quot;); break;
        case kHIDUsage_KeyboardT: sprintf (cstrName, &quot;T&quot;); break;
        case kHIDUsage_KeyboardU: sprintf (cstrName, &quot;U&quot;); break;
        case kHIDUsage_KeyboardV: sprintf (cstrName, &quot;V&quot;); break;
        case kHIDUsage_KeyboardW: sprintf (cstrName, &quot;W&quot;); break;
        case kHIDUsage_KeyboardX: sprintf (cstrName, &quot;X&quot;); break;
        case kHIDUsage_KeyboardY: sprintf (cstrName, &quot;Y&quot;); break;
        case kHIDUsage_KeyboardZ: sprintf (cstrName, &quot;Z&quot;); break;
        case kHIDUsage_Keyboard1: sprintf (cstrName, &quot;1&quot;); break;
        case kHIDUsage_Keyboard2: sprintf (cstrName, &quot;2&quot;); break;
        case kHIDUsage_Keyboard3: sprintf (cstrName, &quot;3&quot;); break;
        case kHIDUsage_Keyboard4: sprintf (cstrName, &quot;4&quot;); break;
        case kHIDUsage_Keyboard5: sprintf (cstrName, &quot;5&quot;); break;
        case kHIDUsage_Keyboard6: sprintf (cstrName, &quot;6&quot;); break;
        case kHIDUsage_Keyboard7: sprintf (cstrName, &quot;7&quot;); break;
        case kHIDUsage_Keyboard8: sprintf (cstrName, &quot;8&quot;); break;
        case kHIDUsage_Keyboard9: sprintf (cstrName, &quot;9&quot;); break;
        case kHIDUsage_Keyboard0: sprintf (cstrName, &quot;0&quot;); break;
        case kHIDUsage_KeyboardReturnOrEnter: sprintf (cstrName, &quot;Return&quot;); break;
        case kHIDUsage_KeyboardEscape: sprintf (cstrName, &quot;Escape&quot;); break;
        case kHIDUsage_KeyboardDeleteOrBackspace: sprintf (cstrName, &quot;Delete&quot;); break;
        case kHIDUsage_KeyboardTab: sprintf (cstrName, &quot;Tab&quot;); break;
        case kHIDUsage_KeyboardSpacebar: sprintf (cstrName, &quot;Spacebar&quot;); break;
        case kHIDUsage_KeyboardHyphen: sprintf (cstrName, &quot;Dash&quot;); break;
        case kHIDUsage_KeyboardEqualSign: sprintf (cstrName, &quot;Equal&quot;); break;
        case kHIDUsage_KeyboardOpenBracket: sprintf (cstrName, &quot;Left Square Bracket&quot;); break;
        case kHIDUsage_KeyboardCloseBracket: sprintf (cstrName, &quot;Right Square Bracket&quot;); break;
        case kHIDUsage_KeyboardBackslash: sprintf (cstrName, &quot;Slash&quot;); break;
        case kHIDUsage_KeyboardNonUSPound: sprintf (cstrName, &quot;Non-US #&quot;); break;
        case kHIDUsage_KeyboardSemicolon: sprintf (cstrName, &quot;Semi-Colon&quot;); break;
        case kHIDUsage_KeyboardQuote: sprintf (cstrName, &quot;Single Quote&quot;); break;
        case kHIDUsage_KeyboardGraveAccentAndTilde: sprintf (cstrName, &quot;Grave Accent&quot;); break;
        case kHIDUsage_KeyboardComma: sprintf (cstrName, &quot;Comma&quot;); break;
        case kHIDUsage_KeyboardPeriod: sprintf (cstrName, &quot;Period&quot;); break;
        case kHIDUsage_KeyboardSlash: sprintf (cstrName, &quot;Slash&quot;); break;
        case kHIDUsage_KeyboardCapsLock: sprintf (cstrName, &quot;Caps Lock&quot;); break;
        case kHIDUsage_KeyboardF1: sprintf (cstrName, &quot;F1&quot;); break;
        case kHIDUsage_KeyboardF2: sprintf (cstrName, &quot;F2&quot;); break;
        case kHIDUsage_KeyboardF3: sprintf (cstrName, &quot;F3&quot;); break;
        case kHIDUsage_KeyboardF4: sprintf (cstrName, &quot;F4&quot;); break;
        case kHIDUsage_KeyboardF5: sprintf (cstrName, &quot;F5&quot;); break;
        case kHIDUsage_KeyboardF6: sprintf (cstrName, &quot;F6&quot;); break;
        case kHIDUsage_KeyboardF7: sprintf (cstrName, &quot;F7&quot;); break;
        case kHIDUsage_KeyboardF8: sprintf (cstrName, &quot;F8&quot;); break;
        case kHIDUsage_KeyboardF9: sprintf (cstrName, &quot;F9&quot;); break;
        case kHIDUsage_KeyboardF10: sprintf (cstrName, &quot;F10&quot;); break;
        case kHIDUsage_KeyboardF11: sprintf (cstrName, &quot;F11&quot;); break;
        case kHIDUsage_KeyboardF12: sprintf (cstrName, &quot;F12&quot;); break;
        case kHIDUsage_KeyboardPrintScreen: sprintf (cstrName, &quot;Print Screen&quot;); break;
        case kHIDUsage_KeyboardScrollLock: sprintf (cstrName, &quot;Scroll Lock&quot;); break;
        case kHIDUsage_KeyboardPause: sprintf (cstrName, &quot;Pause&quot;); break;
        case kHIDUsage_KeyboardInsert: sprintf (cstrName, &quot;Insert&quot;); break;
        case kHIDUsage_KeyboardHome: sprintf (cstrName, &quot;Home&quot;); break;
        case kHIDUsage_KeyboardPageUp: sprintf (cstrName, &quot;Page Up&quot;); break;
        case kHIDUsage_KeyboardDeleteForward: sprintf (cstrName, &quot;Delete Forward&quot;); break;
        case kHIDUsage_KeyboardEnd: sprintf (cstrName, &quot;End&quot;); break;
        case kHIDUsage_KeyboardPageDown: sprintf (cstrName, &quot;Page Down&quot;); break;
        case kHIDUsage_KeyboardRightArrow: sprintf (cstrName, &quot;Right Arrow&quot;); break;
        case kHIDUsage_KeyboardLeftArrow: sprintf (cstrName, &quot;Left Arrow&quot;); break;
        case kHIDUsage_KeyboardDownArrow: sprintf (cstrName, &quot;Down Arrow&quot;); break;
        case kHIDUsage_KeyboardUpArrow: sprintf (cstrName, &quot;Up Arrow&quot;); break;
        case kHIDUsage_KeypadNumLock: sprintf (cstrName, &quot;Keypad NumLock&quot;); break;
        case kHIDUsage_KeypadSlash: sprintf (cstrName, &quot;Keypad Slash&quot;); break;
        case kHIDUsage_KeypadAsterisk: sprintf (cstrName, &quot;Keypad Asterisk&quot;); break;
        case kHIDUsage_KeypadHyphen: sprintf (cstrName, &quot;Keypad Dash&quot;); break;
        case kHIDUsage_KeypadPlus: sprintf (cstrName, &quot;Keypad Plus&quot;); break;
        case kHIDUsage_KeypadEnter: sprintf (cstrName, &quot;Keypad Enter&quot;); break;
        case kHIDUsage_Keypad1: sprintf (cstrName, &quot;Keypad 1&quot;); break;
        case kHIDUsage_Keypad2: sprintf (cstrName, &quot;Keypad 2&quot;); break;
        case kHIDUsage_Keypad3: sprintf (cstrName, &quot;Keypad 3&quot;); break;
        case kHIDUsage_Keypad4: sprintf (cstrName, &quot;Keypad 4&quot;); break;
        case kHIDUsage_Keypad5: sprintf (cstrName, &quot;Keypad 5&quot;); break;
        case kHIDUsage_Keypad6: sprintf (cstrName, &quot;Keypad 6&quot;); break;
        case kHIDUsage_Keypad7: sprintf (cstrName, &quot;Keypad 7&quot;); break;
        case kHIDUsage_Keypad8: sprintf (cstrName, &quot;Keypad 8&quot;); break;
        case kHIDUsage_Keypad9: sprintf (cstrName, &quot;Keypad 9&quot;); break;
        case kHIDUsage_Keypad0: sprintf (cstrName, &quot;Keypad 0&quot;); break;
        case kHIDUsage_KeypadPeriod: sprintf (cstrName, &quot;Keypad Period&quot;); break;
        case kHIDUsage_KeyboardNonUSBackslash: sprintf (cstrName, &quot;Non-US Backslash&quot;); break;
        case kHIDUsage_KeyboardApplication: sprintf (cstrName, &quot;Application&quot;); break;
        case kHIDUsage_KeyboardPower: sprintf (cstrName, &quot;Power&quot;); break;
        case kHIDUsage_KeypadEqualSign: sprintf (cstrName, &quot;Keypad Equal&quot;); break;
        case kHIDUsage_KeyboardF13: sprintf (cstrName, &quot;F13&quot;); break;
        case kHIDUsage_KeyboardF14: sprintf (cstrName, &quot;F14&quot;); break;
        case kHIDUsage_KeyboardF15: sprintf (cstrName, &quot;F15&quot;); break;
        case kHIDUsage_KeyboardF16: sprintf (cstrName, &quot;F16&quot;); break;
        case kHIDUsage_KeyboardF17: sprintf (cstrName, &quot;F17&quot;); break;
        case kHIDUsage_KeyboardF18: sprintf (cstrName, &quot;F18&quot;); break;
        case kHIDUsage_KeyboardF19: sprintf (cstrName, &quot;F19&quot;); break;
        case kHIDUsage_KeyboardF20: sprintf (cstrName, &quot;F20&quot;); break;
        case kHIDUsage_KeyboardF21: sprintf (cstrName, &quot;F21&quot;); break;
        case kHIDUsage_KeyboardF22: sprintf (cstrName, &quot;F22&quot;); break;
        case kHIDUsage_KeyboardF23: sprintf (cstrName, &quot;F23&quot;); break;
        case kHIDUsage_KeyboardF24: sprintf (cstrName, &quot;F24&quot;); break;
        case kHIDUsage_KeyboardExecute: sprintf (cstrName, &quot;Execute&quot;); break;
        case kHIDUsage_KeyboardHelp: sprintf (cstrName, &quot;Help&quot;); break;
        case kHIDUsage_KeyboardMenu: sprintf (cstrName, &quot;Menu&quot;); break;
        case kHIDUsage_KeyboardSelect: sprintf (cstrName, &quot;Select&quot;); break;
        case kHIDUsage_KeyboardStop: sprintf (cstrName, &quot;Stop&quot;); break;
        case kHIDUsage_KeyboardAgain: sprintf (cstrName, &quot;Again&quot;); break;
        case kHIDUsage_KeyboardUndo: sprintf (cstrName, &quot;Undo&quot;); break;
        case kHIDUsage_KeyboardCut: sprintf (cstrName, &quot;Cut&quot;); break;
        case kHIDUsage_KeyboardCopy: sprintf (cstrName, &quot;Copy&quot;); break;
        case kHIDUsage_KeyboardPaste: sprintf (cstrName, &quot;Paste&quot;); break;
        case kHIDUsage_KeyboardFind: sprintf (cstrName, &quot;Find&quot;); break;
        case kHIDUsage_KeyboardMute: sprintf (cstrName, &quot;Mute&quot;); break;
        case kHIDUsage_KeyboardVolumeUp: sprintf (cstrName, &quot;Volume Up&quot;); break;
        case kHIDUsage_KeyboardVolumeDown: sprintf (cstrName, &quot;Volume Down&quot;); break;
        case kHIDUsage_KeyboardLockingCapsLock: sprintf (cstrName, &quot;Locking Caps Lock&quot;); break;
        case kHIDUsage_KeyboardLockingNumLock: sprintf (cstrName, &quot;Locking Num Lock&quot;); break;
        case kHIDUsage_KeyboardLockingScrollLock: sprintf (cstrName, &quot;Locking Scroll Lock&quot;); break;
        case kHIDUsage_KeypadComma: sprintf (cstrName, &quot;Keypad Comma&quot;); break;
        case kHIDUsage_KeypadEqualSignAS400: sprintf (cstrName, &quot;Keypad Equal Sign for AS-400&quot;); break;
        case kHIDUsage_KeyboardInternational1: sprintf (cstrName, &quot;International1&quot;); break;
        case kHIDUsage_KeyboardInternational2: sprintf (cstrName, &quot;International2&quot;); break;
        case kHIDUsage_KeyboardInternational3: sprintf (cstrName, &quot;International3&quot;); break;
        case kHIDUsage_KeyboardInternational4: sprintf (cstrName, &quot;International4&quot;); break;
        case kHIDUsage_KeyboardInternational5: sprintf (cstrName, &quot;International5&quot;); break;
        case kHIDUsage_KeyboardInternational6: sprintf (cstrName, &quot;International6&quot;); break;
        case kHIDUsage_KeyboardInternational7: sprintf (cstrName, &quot;International7&quot;); break;
        case kHIDUsage_KeyboardInternational8: sprintf (cstrName, &quot;International8&quot;); break;
        case kHIDUsage_KeyboardInternational9: sprintf (cstrName, &quot;International9&quot;); break;
        case kHIDUsage_KeyboardLANG1: sprintf (cstrName, &quot;LANG1&quot;); break;
        case kHIDUsage_KeyboardLANG2: sprintf (cstrName, &quot;LANG2&quot;); break;
        case kHIDUsage_KeyboardLANG3: sprintf (cstrName, &quot;LANG3&quot;); break;
        case kHIDUsage_KeyboardLANG4: sprintf (cstrName, &quot;LANG4&quot;); break;
        case kHIDUsage_KeyboardLANG5: sprintf (cstrName, &quot;LANG5&quot;); break;
        case kHIDUsage_KeyboardLANG6: sprintf (cstrName, &quot;LANG6&quot;); break;
        case kHIDUsage_KeyboardLANG7: sprintf (cstrName, &quot;LANG7&quot;); break;
        case kHIDUsage_KeyboardLANG8: sprintf (cstrName, &quot;LANG8&quot;); break;
        case kHIDUsage_KeyboardLANG9: sprintf (cstrName, &quot;LANG9&quot;); break;
        case kHIDUsage_KeyboardAlternateErase: sprintf (cstrName, &quot;Alternate Erase&quot;); break;
        case kHIDUsage_KeyboardSysReqOrAttention: sprintf (cstrName, &quot;SysReq or Attention&quot;); break;
        case kHIDUsage_KeyboardCancel: sprintf (cstrName, &quot;Cancel&quot;); break;
        case kHIDUsage_KeyboardClear: sprintf (cstrName, &quot;Clear&quot;); break;
        case kHIDUsage_KeyboardPrior: sprintf (cstrName, &quot;Prior&quot;); break;
        case kHIDUsage_KeyboardReturn: sprintf (cstrName, &quot;Return&quot;); break;
        case kHIDUsage_KeyboardSeparator: sprintf (cstrName, &quot;Separator&quot;); break;
        case kHIDUsage_KeyboardOut: sprintf (cstrName, &quot;Out&quot;); break;
        case kHIDUsage_KeyboardOper: sprintf (cstrName, &quot;Oper&quot;); break;
        case kHIDUsage_KeyboardClearOrAgain: sprintf (cstrName, &quot;Clear or Again&quot;); break;
        case kHIDUsage_KeyboardCrSelOrProps: sprintf (cstrName, &quot;CrSel or Props&quot;); break;
        case kHIDUsage_KeyboardExSel: sprintf (cstrName, &quot;ExSel&quot;); break;
        case kHIDUsage_KeyboardLeftControl: sprintf (cstrName, &quot;Left Control&quot;); break;
        case kHIDUsage_KeyboardLeftShift: sprintf (cstrName, &quot;Left Shift&quot;); break;
        case kHIDUsage_KeyboardLeftAlt: sprintf (cstrName, &quot;Left Alt&quot;); break;
        case kHIDUsage_KeyboardLeftGUI: sprintf (cstrName, &quot;Left GUI&quot;); break;
        case kHIDUsage_KeyboardRightControl: sprintf (cstrName, &quot;Right Control&quot;); break;
        case kHIDUsage_KeyboardRightShift: sprintf (cstrName, &quot;Right Shift&quot;); break;
        case kHIDUsage_KeyboardRightAlt: sprintf (cstrName, &quot;Right Alt&quot;); break;
        case kHIDUsage_KeyboardRightGUI: sprintf (cstrName, &quot;Right GUI&quot;); break;
        case kHIDUsage_Keyboard_Reserved: sprintf (cstrName, &quot;Reserved&quot;); break;
        default: sprintf (cstrName, &quot;Keyboard Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_LEDs:
      switch (valueUsage)
      {
        // some LED usages
        case kHIDUsage_LED_IndicatorRed: sprintf (cstrName, &quot;Red LED&quot;); break;
        case kHIDUsage_LED_IndicatorGreen: sprintf (cstrName, &quot;Green LED&quot;); break;
        case kHIDUsage_LED_IndicatorAmber: sprintf (cstrName, &quot;Amber LED&quot;); break;
        case kHIDUsage_LED_GenericIndicator: sprintf (cstrName, &quot;Generic LED&quot;); break;
        case kHIDUsage_LED_SystemSuspend: sprintf (cstrName, &quot;System Suspend LED&quot;); break;
        case kHIDUsage_LED_ExternalPowerConnected: sprintf (cstrName, &quot;External Power LED&quot;); break;
        default: sprintf (cstrName, &quot;LED Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Button:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Button #%ld&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Ordinal:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Ordinal Instance %lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Telephony:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Telephony Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Consumer:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Consumer Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Digitizer:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Digitizer Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Unicode:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Unicode Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_AlphanumericDisplay:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Alphanumeric Display Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
     case kHIDPage_BarCodeScanner:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Bar Code Scanner Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Scale:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Scale Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_CameraControl:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Camera Control Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    case kHIDPage_Arcade:
      switch (valueUsage)
      {
        default: sprintf (cstrName, &quot;Arcade Usage 0x%lx&quot;, valueUsage); break;
      }
      break;
    default:
      if (valueUsagePage &gt; kHIDPage_VendorDefinedStart)
        sprintf (cstrName, &quot;Vendor Defined Usage 0x%lx&quot;, valueUsage);
      else  
        sprintf (cstrName, &quot;Page: 0x%lx, Usage: 0x%lx&quot;, valueUsagePage, valueUsage);
      break;
  }
}

// ---------------------------------

// returns calibrated value given raw value passed in
// calibrated value is equal to min and max values returned by HIDGetElementValue since device list built scaled to element reported min and max values
// 2002-05-01: ggs: add support for center calibration

SInt32 HIDCalibrateValue (SInt32 value, pRecElement pElement)
{
  if (NULL != pElement)
  {
    float readScale, deviceScale = pElement-&gt;max - pElement-&gt;min;
    if (!pElement-&gt;hasCenter) { // no center for this element type
      if (pElement-&gt;maxReport == pElement-&gt;minReport)
        return value; // no scaling as 
      else {
        readScale = pElement-&gt;maxReport - pElement-&gt;minReport;
        return ((value - pElement-&gt;minReport) * deviceScale / readScale) + pElement-&gt;min;
      }
    } else { // has center
      if (value &lt; pElement-&gt;initialCenter) {
        readScale = pElement-&gt;initialCenter - pElement-&gt;minReport;
        if (readScale &gt; 0.5f) { // if we have a positve range and reasonable value
          return ((value - pElement-&gt;minReport) * deviceScale * 0.5f / readScale ) + pElement-&gt;min;
        } else return value; // bad scaling
      } else if (value &gt; pElement-&gt;initialCenter) {
        readScale = pElement-&gt;maxReport - pElement-&gt;initialCenter;
        if (readScale &gt; 0.5f) { // if we have a positve range and reasonable value
          return ((value - pElement-&gt;initialCenter) * deviceScale * 0.5f / readScale ) + pElement-&gt;min + deviceScale / 2.0;
        } else return value; // bad scaling
      } else // at center so return center of range
        return (pElement-&gt;min + deviceScale / 2.0);
    }
  }
  else
    return 0; // bad element passed in 
}

// ---------------------------------

// returns scaled value given raw value passed in
// scaled value is equal to current value assumed to be in the range of element reported min and max values scaled to user min and max scaled values

SInt32 HIDScaleValue (SInt32 value, pRecElement pElement)
{
  float deviceScale = pElement-&gt;userMax - pElement-&gt;userMin;
  float readScale = pElement-&gt;max - pElement-&gt;min;
  if (readScale == 0)
  return value;
  return (value - pElement-&gt;min) * deviceScale / readScale + pElement-&gt;userMin;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GLCarbonSharedPbuffer/listing13.html%3Fid%3DDTS10003149-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GLCarbonSharedPbuffer/listing13.html%3Fid%3DDTS10003149-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GLCarbonSharedPbuffer/listing13.html%3Fid%3DDTS10003149-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>