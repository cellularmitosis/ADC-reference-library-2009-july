<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Carbon Porting Guide (Legacy): The Sample Application</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The Sample Application"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000991-CH207" title="The Sample Application"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../../LegacyTechnologies/Carbon-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000494" target="_top">Carbon</a> &gt; <a href="../cpg_intro_struct/cpg_intro_struct.html#//apple_ref/doc/uid/TP30000991-CH201-TPXREF101">Carbon Porting Guide (Legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../cpg_apdx_func/cpg_apdx_funcs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../cpg_apdx_versionhist/cpg_apdx_version_hist.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP30000991-CH207-BIABHIDD" title="The Sample Application"></a><h1>The Sample Application</h1><p><a name="//apple_ref/doc/uid/TP30000991-CH207-DontLinkElementID_41"></a>The main code for Sample is included in <code>Sample.c</code> and <code>SampleInit.c</code> as shown in <span class="content_text">Listing B-1</span> and <span class="content_text"><a href="cpg_apdx_sample_app.html#//apple_ref/doc/uid/TP30000991-CH207-BBGBCHIC">Listing B-2</a></span>. Sample also includes a definition file, <code>Sample.h</code>, and a compiled resource file, <code>TCSample.rsrc.</code></p><p>The chapter <span class="content_text"><a href="../cpg_portexampstruct/cpg_portexamp_struct.html#//apple_ref/doc/uid/TP30000991-CH204-TPXREF101">“A Porting Example”</a></span> describes how to port the Sample application to Carbon. <span class="content_text"><a href="../cpg_newtechstruct/cpg_newtech_struct.html#//apple_ref/doc/uid/TP30000991-CH205-BABBFCCI">“An Example: Adding Carbon Events to Sample”</a></span> describes how to add Carbon events to the Carbon version of Sample. </p><a name="//apple_ref/doc/uid/TP30000991-CH207-BBGBAJFH" title="Listing B-1Sample.c "></a><p class="codesample"><strong>Listing B-1&nbsp;&nbsp;</strong>Sample.c </p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre>    File:       Sample.c<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Contains:   Sample is an example application that demonstrates how to<span></span></pre></td></tr><tr><td scope="row"><pre>                initialize the commonly used toolbox managers, operate<span></span></pre></td></tr><tr><td scope="row"><pre>                successfully under MultiFinder, handle desk accessories,<span></span></pre></td></tr><tr><td scope="row"><pre>                and create, grow, and zoom windows.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                It does not by any means demonstrate all the techniques<span></span></pre></td></tr><tr><td scope="row"><pre>                you need for a large application. In particular, Sample<span></span></pre></td></tr><tr><td scope="row"><pre>                does not cover exception handling, multiple windows/documents,<span></span></pre></td></tr><tr><td scope="row"><pre>                sophisticated memory management, printing, or undo. All of<span></span></pre></td></tr><tr><td scope="row"><pre>                these are vital parts of a normal full-sized application.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                This application is an example of the form of a Macintosh<span></span></pre></td></tr><tr><td scope="row"><pre>                application; it is NOT a template. It is NOT intended to be<span></span></pre></td></tr><tr><td scope="row"><pre>                used as a foundation for the next world-class, best-selling,<span></span></pre></td></tr><tr><td scope="row"><pre>                600K application. A stick figure drawing of the human body may<span></span></pre></td></tr><tr><td scope="row"><pre>                be a good example of the form for a painting, but that does not<span></span></pre></td></tr><tr><td scope="row"><pre>                mean it should be used as the basis for the next Mona Lisa.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                We recommend that you review this program or TESample before<span></span></pre></td></tr><tr><td scope="row"><pre>                beginning a new application.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Written by:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Copyright:  Copyright © 1988-1999 by Apple Computer, Inc., All Rights Reserved.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    You may incorporate this Apple sample source code into your program(s) without<span></span></pre></td></tr><tr><td scope="row"><pre>    restriction. This Apple sample source code has been provided "AS IS" and the<span></span></pre></td></tr><tr><td scope="row"><pre>    responsibility for its operation is yours. You are not permitted to redistribute<span></span></pre></td></tr><tr><td scope="row"><pre>    this Apple sample source code as "Apple sample source code" after having made<span></span></pre></td></tr><tr><td scope="row"><pre>    changes. If you're going to re-distribute the source, we require that you make<span></span></pre></td></tr><tr><td scope="row"><pre>    it clear in the source that the code was descended from Apple sample source<span></span></pre></td></tr><tr><td scope="row"><pre>    code, but that you've made changes.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Change History (most recent first):<span></span></pre></td></tr><tr><td scope="row"><pre>    8/13/1999   Karl Groethe    Updated for Metrowerks Codewarror Pro 2.1<span></span></pre></td></tr><tr><td scope="row"><pre>*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Segmentation strategy:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   This program consists of three segments.<span></span></pre></td></tr><tr><td scope="row"><pre>   1. "Main" contains most of the code, including the MPW libraries, and the<span></span></pre></td></tr><tr><td scope="row"><pre>      main program.  This segment is in the file Sample.c<span></span></pre></td></tr><tr><td scope="row"><pre>   2. "Initialize" contains code that is only used once, during startup, and<span></span></pre></td></tr><tr><td scope="row"><pre>      can be unloaded after the program starts.  This segment is in the file<span></span></pre></td></tr><tr><td scope="row"><pre>      SampleInit.c.<span></span></pre></td></tr><tr><td scope="row"><pre>   3. "%A5Init" is automatically created by the Linker to initialize globals<span></span></pre></td></tr><tr><td scope="row"><pre>      for the MPW libraries and is unloaded right away. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* SetPort strategy:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   Toolbox routines do not change the current port. In spite of this, in this<span></span></pre></td></tr><tr><td scope="row"><pre>   program we use a strategy of calling SetPort whenever we want to draw or<span></span></pre></td></tr><tr><td scope="row"><pre>   make calls which depend on the current port. This makes us less vulnerable<span></span></pre></td></tr><tr><td scope="row"><pre>   to bugs in other software which might alter the current port (such as the<span></span></pre></td></tr><tr><td scope="row"><pre>   bug (feature?) in many desk accessories which change the port on OpenDeskAcc).<span></span></pre></td></tr><tr><td scope="row"><pre>   Hopefully, this also makes the routines from this program more self-contained,<span></span></pre></td></tr><tr><td scope="row"><pre>   since they don't depend on the current port setting. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma segment Main<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Limits.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Types.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Resources.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;QuickDraw.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Fonts.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Events.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Windows.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Menus.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;TextEdit.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Dialogs.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Desk.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;ToolUtils.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Memory.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;SegLoad.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Files.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;OSUtils.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;DiskInit.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Packages.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Traps.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include "Sample.h      "/* bring in all the #defines for Sample */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* The "g" prefix is used to emphasize that a variable is global. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GMac is used to hold the result of a SysEnvirons call. This makes<span></span></pre></td></tr><tr><td scope="row"><pre>   it convenient for any routine to check the environment. */<span></span></pre></td></tr><tr><td scope="row"><pre>SysEnvRec   gMac;               /* set up by Initialize */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GHasWaitNextEvent is set at startup, and tells whether the WaitNextEvent<span></span></pre></td></tr><tr><td scope="row"><pre>   trap is available. If it is false, we know that we must call GetNextEvent. */<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean     gHasWaitNextEvent;  /* set up by Initialize */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GInBackground is maintained by our osEvent handling routines. Any part of<span></span></pre></td></tr><tr><td scope="row"><pre>   the program can check it to find out if it is currently in the background. */<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean     gInBackground;      /* maintained by Initialize and DoEvent */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* The following globals are the state of the window. If we supported more than<span></span></pre></td></tr><tr><td scope="row"><pre>   one window, they would be attached to each document, rather than globals. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GStopped tells whether the stop light is currently on stop or go. */<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean     gStopped;           /* maintained by Initialize and SetLight */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GStopRect and gGoRect are the rectangles of the two stop lights in the window. */<span></span></pre></td></tr><tr><td scope="row"><pre>Rect        gStopRect;          /* set up by Initialize */<span></span></pre></td></tr><tr><td scope="row"><pre>Rect        gGoRect;            /* set up by Initialize */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Define TopLeft and BotRight macros for convenience. Notice the implicit<span></span></pre></td></tr><tr><td scope="row"><pre>   dependency on the ordering of fields within a Rect */<span></span></pre></td></tr><tr><td scope="row"><pre>#define TopLeft(aRect)  (* (Point *) &amp;(aRect).top)<span></span></pre></td></tr><tr><td scope="row"><pre>#define BotRight(aRect) (* (Point *) &amp;(aRect).bottom)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* This routine is part of the MPW runtime library. This external<span></span></pre></td></tr><tr><td scope="row"><pre>   reference to it is done so that we can unload its segment, %A5Init. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#ifndef THINK_C<span></span></pre></td></tr><tr><td scope="row"><pre>  extern void _DataInit();<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void main()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#ifndef THINK_C<span></span></pre></td></tr><tr><td scope="row"><pre>    UnloadSeg((Ptr) _DataInit);     /* note that _DataInit must not be in Main! */<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* 1.01 - call to ForceEnvirons removed */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  If you have stack requirements that differ from the default,<span></span></pre></td></tr><tr><td scope="row"><pre>        then you could use SetApplLimit to increase StackSpace at<span></span></pre></td></tr><tr><td scope="row"><pre>        this point, before calling MaxApplZone. */<span></span></pre></td></tr><tr><td scope="row"><pre>    MaxApplZone();          /* expand the heap so code segments load at the top */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Initialize();                   /* initialize the program */<span></span></pre></td></tr><tr><td scope="row"><pre>    UnloadSeg((Ptr) Initialize);    /* note that Initialize must not be in Main! */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    EventLoop();                    /* call the main event loop */<span></span></pre></td></tr><tr><td scope="row"><pre>} /*main*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Get events forever, and handle them by calling DoEvent.<span></span></pre></td></tr><tr><td scope="row"><pre>    Get the events by calling WaitNextEvent, if it's available, otherwise<span></span></pre></td></tr><tr><td scope="row"><pre>    by calling GetNextEvent. Also call AdjustCursor each time through the loop. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void EventLoop()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle   cursorRgn;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean     gotEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>    EventRecord event;<span></span></pre></td></tr><tr><td scope="row"><pre>    Point       mouse;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    cursorRgn = NewRgn();   /* we’ll pass WNE an empty region the 1st time thru */<span></span></pre></td></tr><tr><td scope="row"><pre>    do {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* use WNE if it is available */<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( gHasWaitNextEvent ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            GetGlobalMouse(&amp;mouse);<span></span></pre></td></tr><tr><td scope="row"><pre>            AdjustCursor(mouse, cursorRgn);<span></span></pre></td></tr><tr><td scope="row"><pre>            gotEvent = WaitNextEvent(everyEvent, &amp;event, LONG_MAX, cursorRgn);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else {<span></span></pre></td></tr><tr><td scope="row"><pre>            SystemTask();<span></span></pre></td></tr><tr><td scope="row"><pre>            gotEvent = GetNextEvent(everyEvent, &amp;event);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( gotEvent ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            /* make sure we have the right cursor before handling the event */<span></span></pre></td></tr><tr><td scope="row"><pre>            AdjustCursor(event.where, cursorRgn);<span></span></pre></td></tr><tr><td scope="row"><pre>            DoEvent(&amp;event);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        /*  If you are using modeless dialogs that have editText items,<span></span></pre></td></tr><tr><td scope="row"><pre>            you will want to call IsDialogEvent to give the caret a chance<span></span></pre></td></tr><tr><td scope="row"><pre>            to blink, even if WNE/GNE returned FALSE. However, check FrontWindow<span></span></pre></td></tr><tr><td scope="row"><pre>            for a non-NIL value before calling IsDialogEvent. */<span></span></pre></td></tr><tr><td scope="row"><pre>    } while ( true );   /* loop forever; we quit via ExitToShell */<span></span></pre></td></tr><tr><td scope="row"><pre>} /*EventLoop*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Do the right thing for an event. Determine what kind of event it is, and call<span></span></pre></td></tr><tr><td scope="row"><pre> the appropriate routines. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void DoEvent(EventRecord *event)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    short       part, err;<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowPtr   window;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean     hit;<span></span></pre></td></tr><tr><td scope="row"><pre>    char        key;<span></span></pre></td></tr><tr><td scope="row"><pre>    Point       aPoint;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( event->what ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case mouseDown:<span></span></pre></td></tr><tr><td scope="row"><pre>            part = FindWindow(event->where, &amp;window);<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( part ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                case inMenuBar:         /* process a mouse menu command (if any) */<span></span></pre></td></tr><tr><td scope="row"><pre>                    AdjustMenus();<span></span></pre></td></tr><tr><td scope="row"><pre>                    DoMenuCommand(MenuSelect(event->where));<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                case inSysWindow:       /* let the system handle the mouseDown */<span></span></pre></td></tr><tr><td scope="row"><pre>                    SystemClick(event, window);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                case inContent:<span></span></pre></td></tr><tr><td scope="row"><pre>                    if ( window != FrontWindow() ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                        SelectWindow(window);<span></span></pre></td></tr><tr><td scope="row"><pre>                        /*DoEvent(event);*//* use this line for "do first click" */<span></span></pre></td></tr><tr><td scope="row"><pre>                    } else<span></span></pre></td></tr><tr><td scope="row"><pre>                        DoContentClick(window);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                case inDrag:    /* pass screenBits.bounds to get all gDevices */<span></span></pre></td></tr><tr><td scope="row"><pre>                    DragWindow(window, event->where, &amp;qd.screenBits.bounds);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                case inGrow:<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                case inZoomIn:<span></span></pre></td></tr><tr><td scope="row"><pre>                case inZoomOut:<span></span></pre></td></tr><tr><td scope="row"><pre>                    hit = TrackBox(window, event->where, part);<span></span></pre></td></tr><tr><td scope="row"><pre>                    if ( hit ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                        SetPort(window); /* the window must be the current port... */<span></span></pre></td></tr><tr><td scope="row"><pre>                        EraseRect(&amp;window->portRect);   /* because of a bug in */<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        /* ZoomWindow */<span></span></pre></td></tr><tr><td scope="row"><pre>                        ZoomWindow(window, part, true); /* note that we invalidate */<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        /* and erase... */<span></span></pre></td></tr><tr><td scope="row"><pre>                        InvalRect(&amp;window->portRect);   /* to make things look */<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        /* better on-screen */<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case keyDown:<span></span></pre></td></tr><tr><td scope="row"><pre>        case autoKey:                       /* check for menukey equivalents */<span></span></pre></td></tr><tr><td scope="row"><pre>            key = event->message &amp; charCodeMask;<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( event->modifiers &amp; cmdKey )            /* Command key down */<span></span></pre></td></tr><tr><td scope="row"><pre>                if ( event->what == keyDown ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    AdjustMenus();      /* enable/disable/check menu items properly */<span></span></pre></td></tr><tr><td scope="row"><pre>                    DoMenuCommand(MenuKey(key));<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case activateEvt:<span></span></pre></td></tr><tr><td scope="row"><pre>            DoActivate((WindowPtr) event->message,<span></span></pre></td></tr><tr><td scope="row"><pre>                        (event->modifiers &amp; activeFlag) != 0);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case updateEvt:<span></span></pre></td></tr><tr><td scope="row"><pre>            DoUpdate((WindowPtr) event->message);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        /*  1.01 - It is not a bad idea to at least call DIBadMount in response<span></span></pre></td></tr><tr><td scope="row"><pre>            to a diskEvt, so that the user can format a floppy. */<span></span></pre></td></tr><tr><td scope="row"><pre>        case diskEvt:<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( HiWord(event->message) != noErr ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                SetPt(&amp;aPoint, kDILeft, kDITop);<span></span></pre></td></tr><tr><td scope="row"><pre>                err = DIBadMount(aPoint, event->message);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kOSEvent:<span></span></pre></td></tr><tr><td scope="row"><pre>        /*  1.02 - must BitAND with 0x0FF to get only low byte */<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ((event->message >> 24) &amp; 0x0FF) {       /* high byte of message */<span></span></pre></td></tr><tr><td scope="row"><pre>                case kSuspendResumeMessage: /* suspend/resume is also an */<span></span></pre></td></tr><tr><td scope="row"><pre>                                            /* activate/deactivate */<span></span></pre></td></tr><tr><td scope="row"><pre>                    gInBackground = (event->message &amp; kResumeMask) == 0;<span></span></pre></td></tr><tr><td scope="row"><pre>                    DoActivate(FrontWindow(), !gInBackground);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>} /*DoEvent*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Change the cursor's shape, depending on its position. This also calculates the region<span></span></pre></td></tr><tr><td scope="row"><pre>    where the current cursor resides (for WaitNextEvent). If the mouse is ever outside of<span></span></pre></td></tr><tr><td scope="row"><pre>    that region, an event would be generated, causing this routine to be called,<span></span></pre></td></tr><tr><td scope="row"><pre>    allowing us to change the region to the region the mouse is currently in. If<span></span></pre></td></tr><tr><td scope="row"><pre>    there is more to the event than just "the mouse moved", we get called before the<span></span></pre></td></tr><tr><td scope="row"><pre>    event is processed to make sure the cursor is the right one. In any (ahem) event,<span></span></pre></td></tr><tr><td scope="row"><pre>    this is called again before we fall back into WNE. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void AdjustCursor(Point mouse, RgnHandle region)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowPtr   window;<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle   arrowRgn;<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle   plusRgn;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect        globalPortRect;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    window = FrontWindow(); /* we only adjust the cursor when we are in front */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( (! gInBackground) &amp;&amp; (! IsDAWindow(window)) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* calculate regions for different cursor shapes */<span></span></pre></td></tr><tr><td scope="row"><pre>        arrowRgn = NewRgn();<span></span></pre></td></tr><tr><td scope="row"><pre>        plusRgn = NewRgn();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* start with a big, big rectangular region */<span></span></pre></td></tr><tr><td scope="row"><pre>        SetRectRgn(arrowRgn, kExtremeNeg, kExtremeNeg, kExtremePos, kExtremePos);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* calculate plusRgn */<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( IsAppWindow(window) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            SetPort(window);    /* make a global version of the viewRect */<span></span></pre></td></tr><tr><td scope="row"><pre>            SetOrigin(-window->portBits.bounds.left, -window->portBits.bounds.top);<span></span></pre></td></tr><tr><td scope="row"><pre>            globalPortRect = window->portRect;<span></span></pre></td></tr><tr><td scope="row"><pre>            RectRgn(plusRgn, &amp;globalPortRect);<span></span></pre></td></tr><tr><td scope="row"><pre>            SectRgn(plusRgn, window->visRgn, plusRgn);<span></span></pre></td></tr><tr><td scope="row"><pre>            SetOrigin(0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* subtract other regions from arrowRgn */<span></span></pre></td></tr><tr><td scope="row"><pre>        DiffRgn(arrowRgn, plusRgn, arrowRgn);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* change the cursor and the region parameter */<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( PtInRgn(mouse, plusRgn) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            SetCursor(*GetCursor(plusCursor));<span></span></pre></td></tr><tr><td scope="row"><pre>            CopyRgn(plusRgn, region);<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            SetCursor(&amp;qd.arrow);<span></span></pre></td></tr><tr><td scope="row"><pre>            CopyRgn(arrowRgn, region);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* get rid of our local regions */<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeRgn(arrowRgn);<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeRgn(plusRgn);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>} /*AdjustCursor*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Get the global coordinates of the mouse. When you call OSEventAvail<span></span></pre></td></tr><tr><td scope="row"><pre>    it will return either a pending event or a null event. In either case,<span></span></pre></td></tr><tr><td scope="row"><pre>    the where field of the event record will contain the current position<span></span></pre></td></tr><tr><td scope="row"><pre>    of the mouse in global coordinates and the modifiers field will reflect<span></span></pre></td></tr><tr><td scope="row"><pre>    the current state of the modifiers. Another way to get the global<span></span></pre></td></tr><tr><td scope="row"><pre>    coordinates is to call GetMouse and LocalToGlobal, but that requires<span></span></pre></td></tr><tr><td scope="row"><pre>    being sure that thePort is set to a valid port. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void GetGlobalMouse(Point *mouse)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    EventRecord event;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSEventAvail(kNoEvents, &amp;event);    /* we aren't interested in any events */<span></span></pre></td></tr><tr><td scope="row"><pre>    *mouse = event.where;               /* just the mouse position */<span></span></pre></td></tr><tr><td scope="row"><pre>} /*GetGlobalMouse*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  This is called when an update event is received for a window.<span></span></pre></td></tr><tr><td scope="row"><pre>    It calls DrawWindow to draw the contents of an application window.<span></span></pre></td></tr><tr><td scope="row"><pre>    As an efficiency measure that does not have to be followed, it<span></span></pre></td></tr><tr><td scope="row"><pre>    calls the drawing routine only if the visRgn is non-empty. This<span></span></pre></td></tr><tr><td scope="row"><pre>    will handle situations where calculations for drawing or drawing<span></span></pre></td></tr><tr><td scope="row"><pre>    itself is very time-consuming. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void DoUpdate(WindowPtr window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( IsAppWindow(window) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        BeginUpdate(window);                /* this sets up the visRgn */<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( ! EmptyRgn(window->visRgn) )   /* draw if updating needs to be done */<span></span></pre></td></tr><tr><td scope="row"><pre>            DrawWindow(window);<span></span></pre></td></tr><tr><td scope="row"><pre>        EndUpdate(window);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>} /*DoUpdate*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  This is called when a window is activated or deactivated.<span></span></pre></td></tr><tr><td scope="row"><pre>    In Sample, the Window Manager's handling of activate and<span></span></pre></td></tr><tr><td scope="row"><pre>    deactivate events is sufficient. Other applications may have<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEdit records, controls, lists, etc., to activate/deactivate. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void DoActivate(WindowPtr window, Boolean becomingActive)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( IsAppWindow(window) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( becomingActive )<span></span></pre></td></tr><tr><td scope="row"><pre>            /* do whatever you need to at activation */ ;<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            /* do whatever you need to at deactivation */ ;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>} /*DoActivate*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  This is called when a mouse-down event occurs in the content of a window.<span></span></pre></td></tr><tr><td scope="row"><pre>    Other applications might want to call FindControl, TEClick, etc., to<span></span></pre></td></tr><tr><td scope="row"><pre>    further process the click. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void DoContentClick(WindowPtr window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    SetLight(window, ! gStopped);<span></span></pre></td></tr><tr><td scope="row"><pre>} /*DoContentClick*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Draw the contents of the application window. We do some drawing in color, using<span></span></pre></td></tr><tr><td scope="row"><pre>   Classic QuickDraw's color capabilities. This will be black and white on old<span></span></pre></td></tr><tr><td scope="row"><pre>   machines, but color on color machines. At this point, the window’s visRgn<span></span></pre></td></tr><tr><td scope="row"><pre>   is set to allow drawing only where it needs to be done. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void DrawWindow(WindowPtr window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    SetPort(window);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    EraseRect(&amp;window->portRect);   /* clear out any garbage that may linger */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( gStopped )                 /* draw a red (or white) stop light */<span></span></pre></td></tr><tr><td scope="row"><pre>        ForeColor(redColor);<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        ForeColor(whiteColor);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    PaintOval(&amp;gStopRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    ForeColor(blackColor);<span></span></pre></td></tr><tr><td scope="row"><pre>    FrameOval(&amp;gStopRect);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( ! gStopped )               /* draw a green (or white) go light */<span></span></pre></td></tr><tr><td scope="row"><pre>        ForeColor(greenColor);<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        ForeColor(whiteColor);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    PaintOval(&amp;gGoRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    ForeColor(blackColor);<span></span></pre></td></tr><tr><td scope="row"><pre>    FrameOval(&amp;gGoRect);<span></span></pre></td></tr><tr><td scope="row"><pre>} /*DrawWindow*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Enable and disable menus based on the current state.<span></span></pre></td></tr><tr><td scope="row"><pre>    The user can only select enabled menu items. We set up all the menu items<span></span></pre></td></tr><tr><td scope="row"><pre>    before calling MenuSelect or MenuKey, since these are the only times that<span></span></pre></td></tr><tr><td scope="row"><pre>    a menu item can be selected. Note that MenuSelect is also the only time<span></span></pre></td></tr><tr><td scope="row"><pre>    the user will see menu items. This approach to deciding what enable/<span></span></pre></td></tr><tr><td scope="row"><pre>    disable state a menu item has the advantage of concentrating all<span></span></pre></td></tr><tr><td scope="row"><pre>    the decision-making in one routine, as opposed to being spread throughout<span></span></pre></td></tr><tr><td scope="row"><pre>    the application. Other application designs may take a different approach<span></span></pre></td></tr><tr><td scope="row"><pre>    that is just as valid. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void AdjustMenus()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowPtr   window;<span></span></pre></td></tr><tr><td scope="row"><pre>    MenuHandle  menu;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    window = FrontWindow();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    menu = GetMenuHandle(mFile);<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( IsDAWindow(window) )       /* we can allow desk accessories to be */<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* closed from the menu */<span></span></pre></td></tr><tr><td scope="row"><pre>        EnableItem(menu, iClose);<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        DisableItem(menu, iClose);  /* but not our traffic light window */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    menu = GetMenuHandle(mEdit);<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( IsDAWindow(window) ) {     /* a desk accessory might need the edit menu… */<span></span></pre></td></tr><tr><td scope="row"><pre>        EnableItem(menu, iUndo);<span></span></pre></td></tr><tr><td scope="row"><pre>        EnableItem(menu, iCut);<span></span></pre></td></tr><tr><td scope="row"><pre>        EnableItem(menu, iCopy);<span></span></pre></td></tr><tr><td scope="row"><pre>        EnableItem(menu, iClear);<span></span></pre></td></tr><tr><td scope="row"><pre>        EnableItem(menu, iPaste);<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {                        /* …but we don’t use it */<span></span></pre></td></tr><tr><td scope="row"><pre>        DisableItem(menu, iUndo);<span></span></pre></td></tr><tr><td scope="row"><pre>        DisableItem(menu, iCut);<span></span></pre></td></tr><tr><td scope="row"><pre>        DisableItem(menu, iCopy);<span></span></pre></td></tr><tr><td scope="row"><pre>        DisableItem(menu, iClear);<span></span></pre></td></tr><tr><td scope="row"><pre>        DisableItem(menu, iPaste);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    menu = GetMenuHandle(mLight);<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( IsAppWindow(window) ) {    /* we know that it must be the traffic light */<span></span></pre></td></tr><tr><td scope="row"><pre>        EnableItem(menu, iStop);<span></span></pre></td></tr><tr><td scope="row"><pre>        EnableItem(menu, iGo);<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        DisableItem(menu, iStop);<span></span></pre></td></tr><tr><td scope="row"><pre>        DisableItem(menu, iGo);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    CheckItem(menu, iStop, gStopped); /* we can also determine the check/uncheck */<span></span></pre></td></tr><tr><td scope="row"><pre>                                     /* state,too */<span></span></pre></td></tr><tr><td scope="row"><pre>    CheckItem(menu, iGo, ! gStopped);<span></span></pre></td></tr><tr><td scope="row"><pre>} /*AdjustMenus*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  This is called when an item is chosen from the menu bar (after calling<span></span></pre></td></tr><tr><td scope="row"><pre>    MenuSelect or MenuKey). It performs the right operation for each command.<span></span></pre></td></tr><tr><td scope="row"><pre>    It is good to have both the result of MenuSelect and MenuKey go to<span></span></pre></td></tr><tr><td scope="row"><pre>    one routine like this to keep everything organized. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void DoMenuCommand(long menuResult)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    short       menuID;             /* the resource ID of the selected menu */<span></span></pre></td></tr><tr><td scope="row"><pre>    short       menuItem;           /* the item number of the selected menu */<span></span></pre></td></tr><tr><td scope="row"><pre>    short       itemHit;<span></span></pre></td></tr><tr><td scope="row"><pre>    Str255      daName;<span></span></pre></td></tr><tr><td scope="row"><pre>    short       daRefNum;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean     handledByDA;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    menuID = HiWord(menuResult);    /* use macros for efficiency to... */<span></span></pre></td></tr><tr><td scope="row"><pre>    menuItem = LoWord(menuResult);  /* get menu item number and menu number */<span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( menuID ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case mApple:<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( menuItem ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                case iAbout:        /* bring up alert for About */<span></span></pre></td></tr><tr><td scope="row"><pre>                    itemHit = Alert(rAboutAlert, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                default:            /* all non-About items in this menu are DAs */<span></span></pre></td></tr><tr><td scope="row"><pre>                    /* type Str255 is an array in MPW 3 */<span></span></pre></td></tr><tr><td scope="row"><pre>                    GetMenuItemText(GetMenuHandle(mApple), menuItem, daName);<span></span></pre></td></tr><tr><td scope="row"><pre>                    daRefNum = OpenDeskAcc(daName);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case mFile:<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( menuItem ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                case iClose:<span></span></pre></td></tr><tr><td scope="row"><pre>                    DoCloseWindow(FrontWindow());<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                case iQuit:<span></span></pre></td></tr><tr><td scope="row"><pre>                    Terminate();<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case mEdit:                 /* call SystemEdit for DA editing &amp; MultiFinder */<span></span></pre></td></tr><tr><td scope="row"><pre>            handledByDA = SystemEdit(menuItem-1);/* since we don’t do any Editing */<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case mLight:<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( menuItem ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                case iStop:<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetLight(FrontWindow(), true);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                case iGo:<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetLight(FrontWindow(), false);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    HiliteMenu(0);              /* unhighlight what MenuSelect (or MenuKey) hilited */<span></span></pre></td></tr><tr><td scope="row"><pre>} /*DoMenuCommand*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Change the setting of the light. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void SetLight(WindowPtr window, Boolean newStopped)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( newStopped != gStopped ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        gStopped = newStopped;<span></span></pre></td></tr><tr><td scope="row"><pre>        SetPort(window);<span></span></pre></td></tr><tr><td scope="row"><pre>        InvalRect(&amp;window->portRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>} /*SetLight*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Close a window. This handles desk accessory and application windows. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  1.01 - At this point, if there was a document associated with a<span></span></pre></td></tr><tr><td scope="row"><pre>    window, you could do any document saving processing if it is 'dirty'.<span></span></pre></td></tr><tr><td scope="row"><pre>    DoCloseWindow would return true if the window actually closed, i.e.,<span></span></pre></td></tr><tr><td scope="row"><pre>    the user didn’t cancel from a save dialog. This result is handy when<span></span></pre></td></tr><tr><td scope="row"><pre>    the user quits an application, but then cancels the save of a document<span></span></pre></td></tr><tr><td scope="row"><pre>    associated with a window. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Boolean DoCloseWindow(WindowPtr window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( IsDAWindow(window) )<span></span></pre></td></tr><tr><td scope="row"><pre>        CloseDeskAcc(((WindowPeek) window)->windowKind);<span></span></pre></td></tr><tr><td scope="row"><pre>    else if ( IsAppWindow(window) )<span></span></pre></td></tr><tr><td scope="row"><pre>        CloseWindow(window);<span></span></pre></td></tr><tr><td scope="row"><pre>    return true;<span></span></pre></td></tr><tr><td scope="row"><pre>} /*DoCloseWindow*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/**************************************************************************************<span></span></pre></td></tr><tr><td scope="row"><pre>*** 1.01 DoCloseBehind(window) was removed ***<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    1.01 - DoCloseBehind was a good idea for closing windows when quitting<span></span></pre></td></tr><tr><td scope="row"><pre>    and not having to worry about updating the windows, but it suffered<span></span></pre></td></tr><tr><td scope="row"><pre>    from a fatal flaw. If a desk accessory owned two windows, it would<span></span></pre></td></tr><tr><td scope="row"><pre>    close both those windows when CloseDeskAcc was called. When DoCloseBehind<span></span></pre></td></tr><tr><td scope="row"><pre>    got around to calling DoCloseWindow for that other window that was already<span></span></pre></td></tr><tr><td scope="row"><pre>    closed, things would go very poorly. Another option would be to have a<span></span></pre></td></tr><tr><td scope="row"><pre>    procedure, GetRearWindow, that would go through the window list and return<span></span></pre></td></tr><tr><td scope="row"><pre>    the last window. Instead, we decided to present the standard approach<span></span></pre></td></tr><tr><td scope="row"><pre>    of getting and closing FrontWindow until FrontWindow returns NIL. This<span></span></pre></td></tr><tr><td scope="row"><pre>    has a potential benefit in that the window whose document needs to be saved<span></span></pre></td></tr><tr><td scope="row"><pre>    may be visible since it is the front window, therefore decreasing the<span></span></pre></td></tr><tr><td scope="row"><pre>    chance of user confusion. For aesthetic reasons, the windows in the<span></span></pre></td></tr><tr><td scope="row"><pre>    application should be checked for updates periodically and have the<span></span></pre></td></tr><tr><td scope="row"><pre>    updates serviced.<span></span></pre></td></tr><tr><td scope="row"><pre>**************************************************************************************/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Clean up the application and exit. We close all of the windows so that<span></span></pre></td></tr><tr><td scope="row"><pre> they can update their documents, if any. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  1.01 - If we find out that a cancel has occurred, we won't exit to the */<span></span></pre></td></tr><tr><td scope="row"><pre>/*          shell, but will return instead. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void Terminate()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowPtr   aWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean     closed;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    closed = true;<span></span></pre></td></tr><tr><td scope="row"><pre>    do {<span></span></pre></td></tr><tr><td scope="row"><pre>        aWindow = FrontWindow();                /* get the current front window */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (aWindow != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>            closed = DoCloseWindow(aWindow);    /* close this window */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    while (closed &amp;&amp; (aWindow != nil));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (closed)<span></span></pre></td></tr><tr><td scope="row"><pre>        ExitToShell();                          /* exit if no cancellation */<span></span></pre></td></tr><tr><td scope="row"><pre>} /*Terminate*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Check to see if a window belongs to the application. If the window pointer<span></span></pre></td></tr><tr><td scope="row"><pre>    passed was NIL, then it could not be an application window. WindowKinds<span></span></pre></td></tr><tr><td scope="row"><pre>    that are negative belong to the system and windowKinds less than userKind<span></span></pre></td></tr><tr><td scope="row"><pre>    are reserved by Apple except for windowKinds equal to dialogKind, which<span></span></pre></td></tr><tr><td scope="row"><pre>    mean it is a dialog.<span></span></pre></td></tr><tr><td scope="row"><pre>    1.02 - In order to reduce the chance of accidentally treating some window<span></span></pre></td></tr><tr><td scope="row"><pre>    as an AppWindow that shouldn't be, we'll only return true if the windowkind<span></span></pre></td></tr><tr><td scope="row"><pre>    is userKind. If you add different kinds of windows to Sample you'll need<span></span></pre></td></tr><tr><td scope="row"><pre>    to change how this all works. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Boolean IsAppWindow(WindowPtr window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    short       windowKind;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( window == nil )<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre>    else {  /* application windows have windowKinds = userKind (8) */<span></span></pre></td></tr><tr><td scope="row"><pre>        windowKind = ((WindowPeek) window)->windowKind;<span></span></pre></td></tr><tr><td scope="row"><pre>        return ( windowKind == userKind );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>} /*IsAppWindow*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Check to see if a window belongs to a desk accessory. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Boolean IsDAWindow(WindowPtr window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( window == nil )<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre>    else    /* DA windows have negative windowKinds */<span></span></pre></td></tr><tr><td scope="row"><pre>        return ( ((WindowPeek) window)->windowKind &lt; 0 );<span></span></pre></td></tr><tr><td scope="row"><pre>} /*IsDAWindow*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Display an alert that tells the user an error occurred, then exit the program.<span></span></pre></td></tr><tr><td scope="row"><pre>    This routine is used as an ultimate bail-out for serious errors that prohibit<span></span></pre></td></tr><tr><td scope="row"><pre>    the continuation of the application. Errors that do not require the termination<span></span></pre></td></tr><tr><td scope="row"><pre>    of the application should be handled in a different manner. Error checking and<span></span></pre></td></tr><tr><td scope="row"><pre>    reporting has a place even in the simplest application. The error number is used<span></span></pre></td></tr><tr><td scope="row"><pre>    to index an 'STR#' resource so that a relevant message can be displayed. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void AlertUser()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    short       itemHit;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetCursor(&amp;qd.arrow);<span></span></pre></td></tr><tr><td scope="row"><pre>    itemHit = Alert(rUserAlert, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>    ExitToShell();<span></span></pre></td></tr><tr><td scope="row"><pre>} /* AlertUser */<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP30000991-CH207-BBGBCHIC" title="Listing B-2SampleInit.c "></a><p class="codesample"><strong>Listing B-2&nbsp;&nbsp;</strong>SampleInit.c </p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* File:            SampleInit.c */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Repeated comments from Sample.c removed */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma segment Initialize<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Limits.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Types.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Resources.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;QuickDraw.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Fonts.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Events.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Windows.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Menus.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;TextEdit.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Dialogs.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Desk.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;ToolUtils.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Memory.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;SegLoad.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Files.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;OSUtils.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;DiskInit.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Packages.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Traps.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;OSUtils.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include "Sample.h      "/* bring in all the #defines for Sample */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* The "g" prefix is used to emphasize that a variable is global. */<span></span></pre></td></tr><tr><td scope="row"><pre>/* All are extern since the variables are declared in the main segment. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GMac is used to hold the result of a SysEnvirons call. This makes<span></span></pre></td></tr><tr><td scope="row"><pre>   it convenient for any routine to check the environment. */<span></span></pre></td></tr><tr><td scope="row"><pre>extern SysEnvRec    gMac;               /* set up by Initialize */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GHasWaitNextEvent is set at startup, and tells whether the WaitNextEvent<span></span></pre></td></tr><tr><td scope="row"><pre>   trap is available. If it is false, we know that we must call GetNextEvent. */<span></span></pre></td></tr><tr><td scope="row"><pre>extern Boolean      gHasWaitNextEvent;  /* set up by Initialize */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GInBackground is maintained by our osEvent handling routines. Any part of<span></span></pre></td></tr><tr><td scope="row"><pre>   the program can check it to find out if it is currently in the background. */<span></span></pre></td></tr><tr><td scope="row"><pre>extern Boolean      gInBackground;      /* maintained by Initialize and DoEvent */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* The following globals are the state of the window. If we supported more than<span></span></pre></td></tr><tr><td scope="row"><pre>   one window, they would be attached to each document, rather than globals. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GStopped tells whether the stop light is currently on stop or go. */<span></span></pre></td></tr><tr><td scope="row"><pre>extern Boolean      gStopped;           /* maintained by Initialize and SetLight */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* GStopRect and gGoRect are the rectangles of the two stop lights in the window. */<span></span></pre></td></tr><tr><td scope="row"><pre>extern Rect     gStopRect;          /* set up by Initialize */<span></span></pre></td></tr><tr><td scope="row"><pre>extern Rect     gGoRect;            /* set up by Initialize */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Set up the whole world, including global variables, Toolbox managers,<span></span></pre></td></tr><tr><td scope="row"><pre>    and menus. We also create our one application window at this time.<span></span></pre></td></tr><tr><td scope="row"><pre>    Since window storage is non-relocateable, how and when to allocate space<span></span></pre></td></tr><tr><td scope="row"><pre>    for windows is very important so that heap fragmentation does not occur.<span></span></pre></td></tr><tr><td scope="row"><pre>    Because Sample has only one window and it is only disposed when the application<span></span></pre></td></tr><tr><td scope="row"><pre>    quits, we will allocate its space here, before anything that might be a locked<span></span></pre></td></tr><tr><td scope="row"><pre>    relocatable object gets into the heap. This way, we can force the storage to be<span></span></pre></td></tr><tr><td scope="row"><pre>    in the lowest memory available in the heap. Window storage can differ widely<span></span></pre></td></tr><tr><td scope="row"><pre>    amongst applications depending on how many windows are created and disposed. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  1.01 - The code that used to be part of ForceEnvirons has been moved into<span></span></pre></td></tr><tr><td scope="row"><pre>    this module. If an error is detected, instead of merely doing an ExitToShell,<span></span></pre></td></tr><tr><td scope="row"><pre>    which leaves the user without much to go on, we call AlertUser, which puts<span></span></pre></td></tr><tr><td scope="row"><pre>    up a simple alert that just says an error occurred and then calls ExitToShell.<span></span></pre></td></tr><tr><td scope="row"><pre>    Since there is no other cleanup needed at this point if an error is detected,<span></span></pre></td></tr><tr><td scope="row"><pre>    this form of error- handling is acceptable. If more sophisticated error recovery<span></span></pre></td></tr><tr><td scope="row"><pre>    is needed, an exception mechanism, such as is provided by Signals, can be used. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void Initialize()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Handle      menuBar;<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowPtr   window;<span></span></pre></td></tr><tr><td scope="row"><pre>    long        total, contig;<span></span></pre></td></tr><tr><td scope="row"><pre>    EventRecord event;<span></span></pre></td></tr><tr><td scope="row"><pre>    short       count;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    gInBackground = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    InitGraf((Ptr) &amp;qd.thePort);<span></span></pre></td></tr><tr><td scope="row"><pre>    InitFonts();<span></span></pre></td></tr><tr><td scope="row"><pre>    InitWindows();<span></span></pre></td></tr><tr><td scope="row"><pre>    InitMenus();<span></span></pre></td></tr><tr><td scope="row"><pre>    TEInit();<span></span></pre></td></tr><tr><td scope="row"><pre>    InitDialogs(nil);<span></span></pre></td></tr><tr><td scope="row"><pre>    InitCursor();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  Call MPPOpen and ATPLoad at this point to initialize AppleTalk,<span></span></pre></td></tr><tr><td scope="row"><pre>        if you are using it. */<span></span></pre></td></tr><tr><td scope="row"><pre>    /*  NOTE -- It is no longer necessary, and actually unhealthy, to check<span></span></pre></td></tr><tr><td scope="row"><pre>        PortBUse and SPConfig before opening AppleTalk. The drivers are capable<span></span></pre></td></tr><tr><td scope="row"><pre>        of checking for port availability themselves. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  This next bit of code is necessary to allow the default button of our<span></span></pre></td></tr><tr><td scope="row"><pre>        alert be outlined.<span></span></pre></td></tr><tr><td scope="row"><pre>        1.02 - Changed to call EventAvail so that we don't lose some important<span></span></pre></td></tr><tr><td scope="row"><pre>        events. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for (count = 1; count &lt;= 3; count++)<span></span></pre></td></tr><tr><td scope="row"><pre>        EventAvail(everyEvent, &amp;event);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  Ignore the error returned from SysEnvirons; even if an error occurred,<span></span></pre></td></tr><tr><td scope="row"><pre>        the SysEnvirons glue will fill in the SysEnvRec. You can save a redundant<span></span></pre></td></tr><tr><td scope="row"><pre>        call to SysEnvirons by calling it after initializing AppleTalk. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SysEnvirons(kSysEnvironsVersion, &amp;gMac);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Make sure that the machine has at least 128K ROMs. If it doesn't, exit. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (gMac.machineType &lt; 0) AlertUser();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  1.02 - Move TrapAvailable call to after SysEnvirons so that we can tell<span></span></pre></td></tr><tr><td scope="row"><pre>        in TrapAvailable if a tool trap value is out of range. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    gHasWaitNextEvent = TrapAvailable(_WaitNextEvent, ToolTrap);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  1.01 - We used to make a check for memory at this point by examining ApplLimit,<span></span></pre></td></tr><tr><td scope="row"><pre>        ApplicationZone, and StackSpace and comparing that to the minimum size we told<span></span></pre></td></tr><tr><td scope="row"><pre>        MultiFinder we needed. This did not work well because it assumed too much about<span></span></pre></td></tr><tr><td scope="row"><pre>        the relationship between what we asked MultiFinder for and what we would actually<span></span></pre></td></tr><tr><td scope="row"><pre>        get back, as well as how to measure it. Instead, we will use an alternate<span></span></pre></td></tr><tr><td scope="row"><pre>        method comprised of two steps. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  It is better to first check the size of the application heap against a value<span></span></pre></td></tr><tr><td scope="row"><pre>        that you have determined is the smallest heap the application can reasonably<span></span></pre></td></tr><tr><td scope="row"><pre>        work in. This number should be derived by examining the size of the heap that<span></span></pre></td></tr><tr><td scope="row"><pre>        is actually provided by MultiFinder when the minimum size requested is used.<span></span></pre></td></tr><tr><td scope="row"><pre>        The derivation of the minimum size requested from MultiFinder is described<span></span></pre></td></tr><tr><td scope="row"><pre>        in Sample.h. The check should be made because the preferred size can end up<span></span></pre></td></tr><tr><td scope="row"><pre>        being set smaller than the minimum size by the user. This extra check acts to<span></span></pre></td></tr><tr><td scope="row"><pre>        insure that your application is starting from a solid memory foundation. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ((long) GetApplLimit() - (long) ApplicationZone() &lt; kMinHeap) AlertUser();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  Next, make sure that enough memory is free for your application to run. It<span></span></pre></td></tr><tr><td scope="row"><pre>        is possible for a situation to arise where the heap may have been of required<span></span></pre></td></tr><tr><td scope="row"><pre>        size, but a large scrap was loaded which left too little memory. To check for<span></span></pre></td></tr><tr><td scope="row"><pre>        this, call PurgeSpace and compare the result with a value that you have<span></span></pre></td></tr><tr><td scope="row"><pre>        determined is the minimum amount of free memory your application needs at<span></span></pre></td></tr><tr><td scope="row"><pre>        initialization. This number can be derived several different ways. One way that<span></span></pre></td></tr><tr><td scope="row"><pre>        is fairly straightforward is to run the application in the minimum size<span></span></pre></td></tr><tr><td scope="row"><pre>        configuration as described previously. Call PurgeSpace at initialization and<span></span></pre></td></tr><tr><td scope="row"><pre>        examine the value returned. However, you should make sure that this result is not<span></span></pre></td></tr><tr><td scope="row"><pre>        being modified by the scrap's presence. You can do that by calling ZeroScrap<span></span></pre></td></tr><tr><td scope="row"><pre>        before calling PurgeSpace. Remove this call before shipping, though. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* ZeroScrap(); */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    PurgeSpace(&amp;total, &amp;contig);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (total &lt; kMinSpace) AlertUser();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  The extra benefit to waiting until after the Toolbox Managers have been<span></span></pre></td></tr><tr><td scope="row"><pre>        initialized to check memory is that we can now give the user an alert to tell<span></span></pre></td></tr><tr><td scope="row"><pre>        him/her what happened. Although it is possible that the memory situation could<span></span></pre></td></tr><tr><td scope="row"><pre>        be worsened by displaying an alert, MultiFinder would gracefully exit the<span></span></pre></td></tr><tr><td scope="row"><pre>        application with an informative alert if memory became critical. Here we are<span></span></pre></td></tr><tr><td scope="row"><pre>        acting more in a preventative manner to avoid future disaster from low-memory<span></span></pre></td></tr><tr><td scope="row"><pre>        problems. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*  We will allocate our own window storage instead of letting the Window<span></span></pre></td></tr><tr><td scope="row"><pre>        Manager do it because GetNewWindow may load in temp. resources before<span></span></pre></td></tr><tr><td scope="row"><pre>        making the NewPtr call, and this can lead to heap fragmentation. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    window = (WindowPtr) NewPtr(sizeof(WindowRecord));<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( window == nil ) AlertUser();<span></span></pre></td></tr><tr><td scope="row"><pre>    window = GetNewWindow(rWindow, (Ptr) window, (WindowPtr) -1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    menuBar = GetNewMBar(rMenuBar);         /* read menus into menu bar */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( menuBar == nil ) AlertUser();<span></span></pre></td></tr><tr><td scope="row"><pre>    SetMenuBar(menuBar);                    /* install menus */<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeHandle(menuBar);<span></span></pre></td></tr><tr><td scope="row"><pre>    AppendResMenu(GetMenuHandle(mApple), 'DRVR');   /* add DA names to Apple menu */<span></span></pre></td></tr><tr><td scope="row"><pre>    DrawMenuBar();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    gStopped = true;<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( !GoGetRect(rStopRect, &amp;gStopRect) )<span></span></pre></td></tr><tr><td scope="row"><pre>        AlertUser();                        /* the stop light rectangle */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( !GoGetRect(rGoRect, &amp;gGoRect) )<span></span></pre></td></tr><tr><td scope="row"><pre>        AlertUser();                        /* the go light rectangle */<span></span></pre></td></tr><tr><td scope="row"><pre>} /*Initialize*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  This utility loads the global rectangles that are used by the window<span></span></pre></td></tr><tr><td scope="row"><pre>    drawing routines. It shows how the resource manager can be used to hold<span></span></pre></td></tr><tr><td scope="row"><pre>    values in a convenient manner. These values are then easily altered without<span></span></pre></td></tr><tr><td scope="row"><pre>    having to re-compile the source code. In this particular case, we know<span></span></pre></td></tr><tr><td scope="row"><pre>    that this routine is being called at initialization time. Therefore,<span></span></pre></td></tr><tr><td scope="row"><pre>    if a failure occurs here, we will assume that the application is in such<span></span></pre></td></tr><tr><td scope="row"><pre>    bad shape that we should just exit. Your error handling may differ, but<span></span></pre></td></tr><tr><td scope="row"><pre>    the check should still be made. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Boolean GoGetRect(short rectID, Rect *theRect)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Handle      resource;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    resource = GetResource('RECT', rectID);<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( resource != nil ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        *theRect = **((Rect**) resource);<span></span></pre></td></tr><tr><td scope="row"><pre>        return true;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre>} /* GoGetRect */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Check to see if a given trap is implemented. This is only used by the<span></span></pre></td></tr><tr><td scope="row"><pre>    Initialize routine in this program, so we put it in the Initialize segment.<span></span></pre></td></tr><tr><td scope="row"><pre>    The recommended approach to see if a trap is implemented is to see if<span></span></pre></td></tr><tr><td scope="row"><pre>    the address of the trap routine is the same as the address of the<span></span></pre></td></tr><tr><td scope="row"><pre>    Unimplemented trap. */<span></span></pre></td></tr><tr><td scope="row"><pre>/*  1.02 - Needs to be called after call to SysEnvirons so that it can check<span></span></pre></td></tr><tr><td scope="row"><pre>    if a ToolTrap is out of range of a pre-MacII ROM. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Boolean TrapAvailable(short tNumber, TrapType tType)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( ( tType == ToolTrap ) &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>        ( gMac.machineType > envMachUnknown ) &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>        ( gMac.machineType &lt; envMacII ) ) {     /* it's a 512KE, Plus, or SE */<span></span></pre></td></tr><tr><td scope="row"><pre>        tNumber = tNumber &amp; 0x03FF;<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( tNumber > 0x01FF )                 /* which means the tool traps */<span></span></pre></td></tr><tr><td scope="row"><pre>            tNumber = _Unimplemented;           /* only go to 0x01FF */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return NGetTrapAddress(tNumber, tType) !=<span></span></pre></td></tr><tr><td scope="row"><pre>                                        NGetTrapAddress(_Unimplemented, ToolTrap);<span></span></pre></td></tr><tr><td scope="row"><pre>} /*TrapAvailable*/<span></span></pre></td></tr></table></div>	

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../cpg_apdx_func/cpg_apdx_funcs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../cpg_apdx_versionhist/cpg_apdx_version_hist.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2002-12-01<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_apdx_sampleapp/cpg_apdx_sample_app.html%3Fid%3DTP30000991-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_apdx_sampleapp/cpg_apdx_sample_app.html%3Fid%3DTP30000991-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_apdx_sampleapp/cpg_apdx_sample_app.html%3Fid%3DTP30000991-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>