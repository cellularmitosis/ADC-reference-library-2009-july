<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OTTCPWillDial - /OTTCPWillDial.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">OTTCPWillDial</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxNetworking-date.html" target="_blank">Carbon > Networking</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OTTCPWillDial</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/OTTCPWillDial.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Network Setup SDK Bits/NetworkSetup.h</option>
<option value="listing2.html">/Network Setup SDK Bits/NetworkSetupBigPicture.html</option>
<option value="listing3.html">/Network Setup SDK Bits/NetworkSetupTypes.h</option>
<option value="listing4.html">/OTTCPWillDial.c</option>
<option value="listing5.html">/OTTCPWillDial.h</option>
<option value="listing6.html">/TestOTTCPWillDial.c</option></select>
				</p>
				</form>
				<p><strong><a href="OTTCPWillDial.zip">Download Sample</a></strong> (&#147;OTTCPWillDial.zip&#148;, 53.8K)<BR>
<strong><a href="OTTCPWillDial.dmg">Download Sample</a></strong> (&#147;OTTCPWillDial.dmg&#148;, 117.9K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    OTTCPWillDial.c  Contains:  Library to determine whether open a TCP endpoint will        dial the modem.  Written by:  Quinn &quot;The Eskimo!&quot;  Copyright:  &copy; 1998 by Apple Computer, Inc., all rights reserved.  Change History (most recent first):  You may incorporate this sample code into your applications without  restriction, though the sample code has been provided &quot;AS IS&quot; and the  responsibility for its operation is 100% yours.  However, what you are  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;  after having made changes. If you're going to re-distribute the source,  we require that you make it clear in the source that the code was  descended from Apple Sample Code, but that you've made changes.*//////////////////////////////////////////////////////////////////#define qDebug 1/////////////////////////////////////////////////////////////////// Pick up lots of OT interfaces.#import &lt;OpenTransport.h&gt;#import &lt;OpenTptInternet.h&gt;#import &lt;OpenTptLinks.h&gt;#import &lt;OTDebug.h&gt;/////////////////////////////////////////////////////////////////// Pick up standard system interfaces.#import &lt;CodeFragments.h&gt;#import &lt;Resources.h&gt;#import &lt;Errors.h&gt;#import &lt;Folders.h&gt;/////////////////////////////////////////////////////////////////// Pick up OT configuration database stuff.#import &lt;NetworkSetup.h&gt;/////////////////////////////////////////////////////////////////// Pick up our own header file.#import &quot;OTTCPWillDial.h&quot;/////////////////////////////////////////////////////////////////// Default OTDebugStr prototype, because it's not in the interfaces.extern void OTDebugStr(const char *message);/////////////////////////////////////////////////////////////////// Common code to parse 'iitf' preferences.// The structure of an 'iitf' is the same regardless of whether it// comes from a resource or from the configuration database.// An 'iitf' preference consists of a UInt16 count followed// by 0 or more interface specifications.  Each interface// specification is a variable length data structure, with// some fixed length and some variable length fields.// This structure is used to represent an interface as // a fixed size data structure, much more suitable for// C programming.// In current versions of OT, only one interface is allowed.struct TCPiitfPref {  UInt8    fActive;  InetHost fIPAddress;  InetHost fSubnetMask;  Str255   fAppleTalkZone;  UInt8    fPath[36];      // Pascal string  UInt8    fModuleName[31];  // Pascal string  UInt32   fFramingFlags;};typedef struct TCPiitfPref TCPiitfPref;static void UnpackIITF(Ptr *buffer, TCPiitfPref *unpackedIITF)  // This routine unpacks an interface from an 'iitf' preference  // into a TCPiitfPref.  *buffer must point to the beginning  // of the interface, ie two bytes into the pref data if  // if you're extracting the first interface.  *buffer  // is updated to point to the byte after the last byte  // parsed, so you can parse multiple interfaces by  // repeatedly calling this routine.{  UInt8 *cursor;    cursor = (UInt8 *) *buffer;    unpackedIITF-&gt;fActive = *cursor;  cursor += sizeof(UInt8);  unpackedIITF-&gt;fIPAddress = *((InetHost *) cursor);  cursor += sizeof(InetHost);  unpackedIITF-&gt;fSubnetMask = *((InetHost *) cursor);  cursor += sizeof(InetHost);  BlockMoveData(cursor, unpackedIITF-&gt;fAppleTalkZone, *cursor + 1);  cursor += (*cursor + 1);  BlockMoveData(cursor, unpackedIITF-&gt;fPath, 36);  cursor += 36;  BlockMoveData(cursor, unpackedIITF-&gt;fModuleName, 32);  cursor += 32;  unpackedIITF-&gt;fFramingFlags = *((UInt32 *) cursor);  cursor += sizeof(UInt32);  *buffer = (Ptr) cursor;}static OSStatus GetPortNameFromIITF(Ptr buffer, SInt32 prefSize, char *portName)  // This routine takes the address and size of an 'iitf' preference  // and extracts the port name from the first interface.{  OSStatus err;  UInt16 interfaceCount;  Ptr cursor;  TCPiitfPref firstInterface;  UInt8 portNameLength;    // Get the count of interfaces, checking for possibly bogus  // preference data.    err = noErr;  if (prefSize &lt; sizeof(UInt16)) {    err = -1;  }  if (err == noErr) {    interfaceCount = *((UInt16 *)buffer);    if (interfaceCount &lt; 1) {      err = -1;    }  }    // Unpack the first interface out of the 'iitf'.    if (err == noErr) {    cursor = buffer + sizeof(UInt16);    UnpackIITF(&amp;cursor, &amp;firstInterface);    OTAssert(&quot;GetPortNameFromIITF: Did not consume correct number of bytes&quot;,          interfaceCount &gt; 1 || (cursor == buffer + prefSize) );  }    // Copy the port name out of the unpacked interface.    if (err == noErr) {    portNameLength = firstInterface.fPath[0];    if ( portNameLength &gt; kMaxProviderNameLength) {      err = -1;    } else {      // Poor Man's C2PString avoids me having to figure      // out which wacky library CodeWarrior wants me to link with      // today!            BlockMoveData(firstInterface.fPath + 1, portName, portNameLength);      portName[ portNameLength ] = 0;    }  }  return err;}/////////////////////////////////////////////////////////////////// OT configuration database implementation.static OSStatus GetFixedSizePref(CfgDatabaseRef ref, const CfgEntityRef *entityID, OSType prefType,            void *buffer, ByteCount prefSize)  // This routine gets a fixed size preference out of  // the configuration database described by ref.  entityID  // is the entity containing the preference.  prefType is the  // type of preference within the entity.  buffer is the address  // where the preference data should be put.  prefSize is the size  // of the buffer, and the routine validates that the preference  // is exactly that size.{  OSStatus err;  OSStatus err2;  CfgEntityAccessID prefsRefNum;  ByteCount actualPrefSize;    OTAssert(&quot;GetFixedSizePref: paramErr&quot;, buffer != nil);  // Open the entity, read out the preference, and then  // close it down.    err = OTCfgOpenPrefs(ref, entityID, false, &amp;prefsRefNum);  if (err == noErr) {    err = OTCfgGetPrefsSize(prefsRefNum, prefType, &amp;actualPrefSize);    if (err == noErr &amp;&amp; actualPrefSize != prefSize) {      err = -1;    }    if (err == noErr) {      err = OTCfgGetPrefs(prefsRefNum, prefType, buffer, prefSize);    }      err2 = OTCfgClosePrefs(prefsRefNum);    if (err == noErr) {      err = err2;    }  }    return err;}static OSStatus GetPref(CfgDatabaseRef ref, const CfgEntityRef *entityID, OSType prefType,            void **buffer, ByteCount *prefSize)  // This routine gets a variable size preference out of  // the configuration database described by ref.  entityID  // is the entity containing the preference.  prefType is the  // type of preference within the entity.  buffer is the address  // a pointer where the address of the newly allocated preference  // buffer should be put.  prefSize is the address of a variable  // where the size of the newly allocated preference should be.  //   // The caller is responsible for disposing of the preference buffer  // using OTFreeMem.  If the routine fails, no preference buffer is   // returned.{  OSStatus err;  OSStatus err2;  CfgEntityAccessID prefsRefNum;    OTAssert(&quot;GetPref: paramErr&quot;, buffer != nil);  // Open the entity, read out the preference, and then  // close it down.    *buffer = nil;    err = OTCfgOpenPrefs(ref, entityID, false, &amp;prefsRefNum);  if (err == noErr) {    err = OTCfgGetPrefsSize(prefsRefNum, prefType, prefSize);    if (err == noErr) {      *buffer = OTAllocMem(*prefSize);      if (*buffer == nil) {        err = kOTOutOfMemoryErr;      }    }    if (err == noErr) {      err = OTCfgGetPrefs(prefsRefNum, prefType, *buffer, *prefSize);    }      err2 = OTCfgClosePrefs(prefsRefNum);    if (err == noErr) {      err = err2;    }  }    // Clean up.    if (err != noErr &amp;&amp; *buffer != nil) {    OTFreeMem(*buffer);    *buffer = nil;  }  return err;}static OSStatus GetEntityList(CfgDatabaseRef ref, CfgAreaID area,                OSType class, OSType type,                CfgEntityRef **entityIDs, ItemCount *entityCount)  // This routine gets a list of all the entities that match  // class and type in the specified area of the specified database.  // It allocates a buffer (using OTAllocMem) to hold the CfgEntityRef's  // for the result and sets *entityIDs to point to the buffer.  It sets  // entityCount to the number of CfgEntityRef's in the buffer.{  OSStatus err;  CfgEntityInfo *junkEntityInfos;  OTAssert(&quot;GetEntityList: paramErr&quot;, entityIDs != nil);  OTAssert(&quot;GetEntityList: paramErr&quot;, entityCount != nil);    *entityIDs = nil;  junkEntityInfos = nil;    err = OTCfgGetEntitiesCount(ref, area, class, type, entityCount);  if (err == noErr) {    *entityIDs = OTAllocMem(*entityCount * sizeof(CfgEntityRef));    junkEntityInfos = OTAllocMem(*entityCount * sizeof(CfgEntityInfo));    if (*entityIDs == nil || junkEntityInfos == nil) {      err = kOTOutOfMemoryErr;    }  }  if (err == noErr) {      // I'm not sure whether you can pass nil to the entityInfos parameter    // of OTCfgGetEntitiesList, so for the moment I'm passing in a valid    // buffer.  I'll fix this up pending confirmation from engineering    // that nil is OK.        err = OTCfgGetEntitiesList(ref, area,           class, type,           entityCount, *entityIDs, junkEntityInfos);  }    // Clean up.    if (junkEntityInfos != nil) {    OTFreeMem(junkEntityInfos);  }    if (err != noErr) {    if (*entityIDs != nil) {      OTFreeMem(*entityIDs);      *entityIDs = nil;    }  }  return err;}static OSStatus GetInfoForTCPEntity(CfgDatabaseRef ref, const CfgEntityRef *entityID,                  Boolean *enabled, char *portName)  // This routine returns the enabled status and port name  // for the TCP/IP preferences entity described by entityID  // in the ref database.{    OSStatus err;  SInt16 enabledInt;  Ptr buffer;  ByteCount prefSize;  buffer = nil;  // First return enabled using the simple API.    err = GetFixedSizePref(ref, entityID, 'unld', &amp;enabledInt, sizeof(SInt16));  if (err == noErr) {    *enabled = (enabledInt != 3);  }    // Now return the port name.  Now call the variable sized  // API to get the 'iitf' resource and then extract the port name   // from the preference buffer.    if (err == noErr) {    err = GetPref(ref, entityID, 'iitf', &amp;buffer, &amp;prefSize);  }  if (err == noErr) {    err = GetPortNameFromIITF(buffer, prefSize, portName);  }    // Clean up.    if (buffer != nil) {    OTFreeMem(buffer);  }  return err;}static OSStatus FindActiveSet(CfgDatabaseRef ref, CfgAreaID area, CfgEntityRef *activeSet)  // This routine finds the entity ref of the active set entity  // in the database.  It works by finding all the set entities  // (there is generally only one in the current OT implementation)  // and checks each one for the active bit set in its flags.  // It returns the first set that claims to be active.{  OSStatus err;  ItemCount setCount;  CfgEntityRef *setEntities;  Boolean found;  ItemCount thisSetIndex;  CfgSetsStruct thisStruct;  setEntities = nil;  err = GetEntityList(ref, area, kOTSetOfSettingsClass, kOTSetOfSettingsType, &amp;setEntities, &amp;setCount);  if (err == noErr) {    thisSetIndex = 0;    found = false;    while (err == noErr &amp;&amp; thisSetIndex &lt; setCount &amp;&amp; ! found) {      err = GetFixedSizePref(ref, &amp;setEntities[thisSetIndex], kPrefsTypeStruct,              &amp;thisStruct, sizeof(thisStruct));      if (err == noErr) {        found = ((thisStruct.fFlags &amp; (1 &lt;&lt; kSetsIndexActive)) != 0);        if ( ! found ) {          thisSetIndex += 1;        }      }    }    if (err == noErr &amp;&amp; ! found) {      err = -1;    }  }  if (err == noErr) {    *activeSet = setEntities[thisSetIndex];  }  // Clean up.    if (setEntities != nil) {    OTFreeMem(setEntities);  }    return err;}static OSStatus FindCurrentTCPEntity(CfgDatabaseRef ref, CfgAreaID area, CfgEntityRef *currentTCPEntity)  // This routine finds the current active TCP/IP connection entity.  // It does this by first looking up the active set, then getting  // the list of entities out of the active set, then searching  // through that list of entities for the first TCP/IP connection  // entity.{  OSStatus err;  CfgEntityRef activeSet;  CfgSetsVector *vectorPrefData;  ByteCount vectorPrefSize;  Boolean found;  ItemCount thisElementIndex;  CfgEntityInfo thisEntityInfo;    vectorPrefData = nil;  err = FindActiveSet(ref, area, &amp;activeSet);  if (err == noErr) {    err = GetPref(ref, &amp;activeSet, kPrefsTypeVector,            &amp;vectorPrefData, &amp;vectorPrefSize);  }  if (err == noErr) {    // The kOTSetOfSettingsClass/kOTSetOfSettingsType preference    // data is a count of elements followed by an array of that    // many elements.  We walk index through the array looking    // for the first TCP/IP connection entity.        thisElementIndex = 0;    found = false;    while ( thisElementIndex &lt; vectorPrefData-&gt;fCount &amp;&amp; ! found ) {      thisEntityInfo = vectorPrefData-&gt;fElements[thisElementIndex].fEntityInfo;      found = (thisEntityInfo.fClass == kOTNetworkConnectionClass)             &amp;&amp; (thisEntityInfo.fType == kOTTCPv4NetworkConnection);      if (found) {        *currentTCPEntity = vectorPrefData-&gt;fElements[thisElementIndex].fEntityRef;                // A weird misfeature of kOTSetOfSettingsClass/kOTSetOfSettingsType         // preference is that the CfgEntityRef's it holds have their area        // (ie fLoc) set to a bogus area ID.  [It's actually the area ID        // of the temporary area generated when the person who wrote the        // set called OTCfgBeginAreaModifications.]  So we have to reset        // this to the current area before returning it to our caller.                currentTCPEntity-&gt;fLoc = area;      } else {        thisElementIndex += 1;      }    }    if ( err == noErr &amp;&amp; ! found ) {      err = -3;    }  }    // Clean up.    if (vectorPrefData != nil) {    OTFreeMem(vectorPrefData);  }  return err;}static OSStatus GetTCPInfoUsingAPI(Boolean *enabled, char *portName)  // The high-level entry point into the configuration database  // implementation.  We open the database, find the current  // TCP entity and read the info we need out of that entity.{  OSStatus err;  OSStatus err2;  CfgDatabaseRef ref;  CfgAreaID currentArea;  CfgEntityRef currentTCPEntity;    err = OTCfgOpenDatabase(&amp;ref);  if (err == noErr) {    err = OTCfgGetCurrentArea(ref, &amp;currentArea);    if (err == noErr) {      err = OTCfgOpenArea(ref, currentArea);      if (err == noErr) {        err = FindCurrentTCPEntity(ref, currentArea, &amp;currentTCPEntity);        if (err == noErr) {          err = GetInfoForTCPEntity(ref, &amp;currentTCPEntity, enabled, portName);        }                err2 = OTCfgCloseArea(ref, currentArea);        if (err == noErr) {          err = err2;        }      }    }      err2 = OTCfgCloseDatabase(&amp;ref);    if (err == noErr) {      err = err2;    }  }  return err;}/////////////////////////////////////////////////////////////////// Implementation that reads the TCP/IP Preferences file directly.// You have to search for the preferences file by type and creator// because the name will be different on localised systems.enum {  kOTTCPPrefFileType = 'pref',  kOTTCPPrefFileCreator = 'ztcp'};static OSStatus FindTCPPrefFile(FSSpec *fss)  // This routine scans the Preferences folder looking  // for the &quot;TCP/IP Preferences&quot; file by type and creator.{  OSStatus err;  Boolean found;  CInfoPBRec cpb;  SInt16 index;    err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kCreateFolder, &amp;fss-&gt;vRefNum, &amp;fss-&gt;parID);  if (err == noErr) {    found = false;    index = 1;    do {      cpb.hFileInfo.ioVRefNum = fss-&gt;vRefNum;      cpb.hFileInfo.ioDirID = fss-&gt;parID;      cpb.hFileInfo.ioNamePtr = fss-&gt;name;      cpb.hFileInfo.ioFDirIndex = index;      err = PBGetCatInfoSync(&amp;cpb);      if (err == noErr) {        found = (  cpb.hFileInfo.ioFlFndrInfo.fdType == kOTTCPPrefFileType &amp;&amp;              cpb.hFileInfo.ioFlFndrInfo.fdCreator == kOTTCPPrefFileCreator );      }      index += 1;    } while (err == noErr &amp; ! found);  }  return err;}static OSStatus CheckResError(void *testH)  // A trivial wrapper routine for ResError,  // which is too lame to report an error code  // in all cases when GetResource fails.{  OSStatus err;  err = ResError();  if (err == noErr &amp;&amp; testH == nil) {    err = resNotFound;  }  return err;}static OSStatus GetTCPInfoFromFile(Boolean *enabled, char *portName)  // This is the high-level entry point into the direct file  // access implementation.  It simply finds the preferences  // file and reads the preferences out directly.{  OSStatus err;  FSSpec fss;  SInt16 oldResFile;  SInt16 prefResFile;  Handle currentConfigResourceH;  Handle unldResource;  Handle iitfResource;  SInt8  s;    oldResFile = CurResFile();    err = FindTCPPrefFile(&amp;fss);  if (err == noErr) {    prefResFile = FSpOpenResFile(&amp;fss, fsRdPerm);    err = ResError();  }  if (err == noErr) {    currentConfigResourceH = Get1Resource('ccfg', 1);    err = CheckResError(currentConfigResourceH);    if (err == noErr &amp;&amp; GetHandleSize(currentConfigResourceH) != sizeof(SInt16) ) {      OTDebugBreak(&quot;GetTCPInfoFromFile: 'ccfg' is of the wrong size&quot;);      err = -1;    }    if (err == noErr) {      unldResource = Get1Resource('unld', **( (SInt16 **) currentConfigResourceH));      err = CheckResError(unldResource);    }    if (err == noErr) {      *enabled = ( **((SInt16 **) unldResource) != 3);    }    if (err == noErr) {      iitfResource = Get1Resource('iitf', **( (SInt16 **) currentConfigResourceH));      err = CheckResError(iitfResource);    }    if (err == noErr) {      s = HGetState(iitfResource);      HLock(iitfResource);      err = GetPortNameFromIITF(*iitfResource, GetHandleSize(iitfResource), portName);      HSetState(iitfResource, s);    }        CloseResFile(prefResFile);    OTAssert(&quot;GetTCPInfoFromFile: Failed to close prefResFile&quot;, ResError() == noErr);  }    UseResFile(oldResFile);  OTAssert(&quot;GetTCPInfoFromFile: Could not re-establish CurResFile&quot;, ResError() == noErr);    return err;}/////////////////////////////////////////////////////////////////// Code that's common to both implementations.static OSStatus GetTCPInfo(Boolean *enabled, char *portName)  // A dispatcher.  If the config database is available,  // we call it, otherwise we fall back to reading the  // preferences file directly.{  OSStatus err;    if ( (void *) OTCfgOpenDatabase == (void *) kUnresolvedCFragSymbolAddress) {    err = GetTCPInfoFromFile(enabled, portName);  } else {    err = GetTCPInfoUsingAPI(enabled, portName);  }  return err;}// If you set kUseInetInterfaceInfo to false, OTTCPWillDial will not// use the heuristic of &quot;if the TCP/IP stack is loaded, it's safe// to open an endpoint&quot;.  This is especially useful when debugging.const Boolean kUseInetInterfaceInfo = true;extern OSStatus OTTCPWillDial(UInt32 *willDial)  // The main entry point.  We call our core  // implementation and then generate the result  // based on the returned information.{  OSStatus err;  InetInterfaceInfo info;  Boolean enabled;  char currentPortName[kMaxProviderNameSize];  OTPortRecord portRecord;    OTAssert(&quot;OTTCPWillDial: paramErr&quot;, willDial != nil);    *willDial = kOTTCPDialUnknown;    err = noErr;  if ( kUseInetInterfaceInfo &amp;&amp; OTInetGetInterfaceInfo(&amp;info, kDefaultInetInterface) == noErr) {      // The TCP/IP stack is already loaded.  With the current    // way TCP/IP is organised, the stack being loaded implies    // that we're already dialled in.        *willDial = kOTTCPDialNo;      } else {    err = GetTCPInfo(&amp;enabled, currentPortName);    if (err == noErr) {      if (enabled) {        if ( OTStrEqual(currentPortName, &quot;ddp&quot;) ) {           // A special case for MacIP, because &quot;ddp&quot; does          // not have an active port if AppleTalk is disabled.                    *willDial = kOTTCPDialNo;                  } else if ( OTFindPort(&amp;portRecord, currentPortName) ) {                  // We know the port.  Look at the device type          // to decide whether we might dial.                  switch ( OTGetDeviceTypeFromPortRef(portRecord.fRef) ) {            case kOTADEVDevice:            case kOTIRTalkDevice:            case kOTSMDSDevice:              OTDebugBreak(&quot;OTTCPWillDial: TCP shouldn't be using this link type&quot;);              *willDial = kOTTCPDialNo;              break;                          case kOTISDNDevice:            case kOTATMDevice:            case kOTSerialDevice:            case kOTModemDevice:              OTDebugBreak(&quot;OTTCPWillDial: TCP shouldn't be using this link type&quot;);              *willDial = kOTTCPDialYes;              break;            case kOTLocalTalkDevice:            case kOTTokenRingDevice:            case kOTEthernetDevice:            case kOTFastEthernetDevice:            case kOTFDDIDevice:            case kOTIrDADevice:            case kOTATMSNAPDevice:            case kOTFibreChannelDevice:            case kOTFireWireDevice:              *willDial = kOTTCPDialNo;              break;            case kOTMDEVDevice:            case kOTSLIPDevice:            case kOTPPPDevice:              *willDial = kOTTCPDialYes;              break;            default:              OTAssert(&quot;OTTCPWillDial&quot;, *willDial == kOTTCPDialUnknown);              break;          }        } else {          err = -1;        }      } else {        *willDial = kOTTCPDialTCPDisabled;      }    }  }    return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OTTCPWillDial/listing4.html%3Fid%3DDTS10000256-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OTTCPWillDial/listing4.html%3Fid%3DDTS10000256-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OTTCPWillDial/listing4.html%3Fid%3DDTS10000256-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>