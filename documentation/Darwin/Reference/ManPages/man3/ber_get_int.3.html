<html><head><title>Mac OS X
 Manual Page For ber_get_int(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/ber_get_int" title="Mac OS X
 Manual Page for ber_get_int(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/ber_get_int"; name=ber_get_int(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
LBER_DECODE(3)                                                                                <!-- a -->LBER_DECODE(3)<!-- /a -->



<b>NAME</b>
       ber_get_next,  ber_skip_tag,  ber_peek_tag,  ber_scanf,  ber_get_int,  ber_get_enum, ber_get_stringb,
       ber_get_stringa,  ber_get_stringal,  ber_get_stringbv,  ber_get_null,  ber_get_boolean,  ber_get_bit-<font color="#ffffff" class="whiteout">string,&nbsp;ber_get_bitstring,</font>
       string,  ber_first_element,  ber_next_element - LBER simplified Basic Encoding Rules library routines
       for decoding

<b>LIBRARY</b>
       OpenLDAP LBER (liblber, -llber)

<b>SYNOPSIS</b>
       <b>#include</b> <b>&lt;lber.h&gt;</b>

       <b>ber_tag_t</b> <b>ber_get_next(Sockbuf</b> <b>*</b><u>sb</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>,</b> <b>BerElement</b> <b>*</b><u>ber</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_skip_tag(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_peek_tag(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_scanf(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>fmt</u><b>,</b> <b>...);</b>

       <b>ber_tag_t</b> <b>ber_get_int(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_int_t</b> <b>*</b><u>num</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_enum(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_int_t</b> <b>*</b><u>num</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_stringb(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>char</b> <b>*</b><u>buf</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_stringa(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>char</b> <b>**</b><u>buf</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_stringal(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>struct</b> <b>berval</b> <b>**</b><u>bv</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_stringbv(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>struct</b> <b>berval</b> <b>*</b><u>bv</u><b>,</b> <b>int</b> <u>alloc</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_null(BerElement</b> <b>*</b><u>ber</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_boolean(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_int_t</b> <b>*</b><u>bool</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_bitstringa(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>char</b> <b>**</b><u>buf</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>blen</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_first_element(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>,</b> <b>char</b> <b>**</b><u>cookie</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_next_element(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>cookie</u><b>);</b>

<b>DESCRIPTION</b>
       These routines provide a subroutine interface to a simplified implementation of  the  Basic  Encoding
       Rules  of ASN.1.  The version of BER these routines support is the one defined for the LDAP protocol.
       The encoding rules are the same as BER, except that only definite form lengths  are  used,  and  bit-<font color="#ffffff" class="whiteout">strings&nbsp;bitstrings</font>
       strings and octet strings are always encoded in primitive form.  This man page describes the decoding
       routines in the lber library.  See <a href="lber-encode.3.html#//apple_ref/doc/man/3/lber-encode"><b>lber-encode</b>(3)</a> for details on the corresponding encoding routines.
       Consult <a href="lber-types.3.html#//apple_ref/doc/man/3/lber-types"><b>lber-types</b>(3)</a> for information about types, allocators, and deallocators.

       Normally,  the  only  routines that need to be called by an application are <b>ber_get_next</b>() to get the
       next BER element and <b>ber_scanf</b>() to do the actual decoding.  In some cases, <b>ber_peek_tag</b>()  may  also
       need  to be called in normal usage.  The other routines are provided for those applications that need
       more control than <b>ber_scanf</b>() provides.  In general, these routines return the  tag  of  the  element
       decoded, or LBER_ERROR if an error occurred.

       The  <b>ber_get_next</b>()  routine  is  used  to  read the next BER element from the given Sockbuf, <u>sb</u>.  It
       strips off and returns the leading tag, strips off and returns the length of the  entire  element  in
       <u>len</u>,  and sets up <u>ber</u> for subsequent calls to <b>ber_scanf</b>() et al to decode the element. See <b>lber-<!-- a -->sock</b><!-- /a -->-<font color="#ffffff" class="whiteout">buf(3)&nbsp;lber-sockbuf(3)</font>
       <!-- a --><b>buf</b>(3)<!-- /a --> for details of the Sockbuf implementation of the <u>sb</u> parameter.

       The <b>ber_scanf</b>() routine is used to decode a BER element in much the same way that <a href="scanf.3.html#//apple_ref/doc/man/3/scanf"><b>scanf</b>(3)</a> works.  It
       reads  from  <u>ber</u>,  a pointer to a BerElement such as returned by <b>ber_get_next</b>(), interprets the bytes
       according to the format string <u>fmt</u>, and stores the results in its additional arguments.   The  format
       string contains conversion specifications which are used to direct the interpretation of the BER ele-<font color="#ffffff" class="whiteout">ment.&nbsp;element.</font>
       ment.  The format string can contain the following characters.


              <b>a</b>  Octet string.  A char ** should be supplied.  Memory is allocated, filled with the contents
                 of  the  octet  string,  null-terminated, and returned in the parameter.  The caller should
                 free the returned string using <b>ber_memfree</b>().

              <b>s</b>  Octet string.  A char * buffer should be supplied, followed by a  pointer  to  a  ber_len_t
                 initialized  to  the  size of the buffer.  Upon return, the null-terminated octet string is
                 put into the buffer, and the ber_len_t is set to the actual size of the octet string.

              <b>O</b>  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynam-<font color="#ffffff" class="whiteout">ically&nbsp;dynamically</font>
                 ically  allocated  struct  berval  containing  the octet string and its length.  The caller
                 should free the returned structure using <b>ber_bvfree</b>().

              <b>o</b>  Octet string.  A struct ber_val * should be supplied, which upon return contains the dynam-<font color="#ffffff" class="whiteout">ically&nbsp;dynamically</font>
                 ically  allocated  octet  string and its length.  The caller should free the returned octet
                 string using <b>ber_memfree</b>().

              <b>m</b>  Octet string.  A struct ber_val * should be supplied, which upon return contains the  octet
                 string  and  its length.  The string resides in memory assigned to the BerElement, and must
                 not be freed by the caller.

              <b>b</b>  Boolean.  A pointer to a ber_int_t should be supplied.

              <b>e</b>  Enumeration.  A pointer to a ber_int_t should be supplied.

              <b>i</b>  Integer.  A pointer to a ber_int_t should be supplied.

              <b>B</b>  Bitstring.  A char ** should be supplied which will  point  to  the  dynamically  allocated
                 bits,  followed by a ber_len_t *, which will point to the length (in bits) of the bitstring
                 returned.

              <b>n</b>  Null.  No parameter is required.  The element is simply skipped if it is recognized.

              <b>v</b>  Sequence of octet strings.  A char *** should be supplied, which upon return  points  to  a
                 dynamically allocated null-terminated array of char *'s containing the octet strings.  NULL
                 is returned if the sequence is empty.  The caller should free the returned array and  octet
                 strings using <b>ber_memvfree</b>().

              <b>V</b>  Sequence of octet strings with lengths.  A struct berval *** should be supplied, which upon
                 return points to a dynamically allocated null-terminated array of struct  berval  *'s  con-<font color="#ffffff" class="whiteout">taining&nbsp;containing</font>
                 taining  the  octet  strings and their lengths.  NULL is returned if the sequence is empty.
                 The caller should free the returned structures using <b>ber_bvecfree</b>().

              <b>W</b>  Sequence of octet strings with lengths.  A BerVarray  *  should  be  supplied,  which  upon
                 return  points  to  a  dynamically  allocated array of struct berval's containing the octet
                 strings and their lengths. The array is terminated by a struct berval with  a  NULL  bv_val
                 string  pointer.   NULL  is  returned if the sequence is empty.  The caller should free the
                 returned structures using <b>ber_bvarray_free</b>().

              <b>M</b>  Sequence of octet strings with lengths.  This is a generalized form of the  previous  three
                 formats.   A  void  **  (ptr)  should  be  supplied,  followed by a ber_len_t * (len) and a
                 ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose  ele-<font color="#ffffff" class="whiteout">ments&nbsp;elements</font>
                 ments  are  all of size (*len).  A struct berval will be filled starting at offset (off) in
                 each element.  The strings in each struct berval reside in memory assigned to  the  BerEle-<font color="#ffffff" class="whiteout">ment&nbsp;BerElement</font>
                 ment  and must not be freed by the caller.  The array is terminated by a struct berval with
                 a NULL bv_val string pointer.  NULL is returned if the sequence is empty.   The  number  of
                 elements  in  the  array  is  also  stored in (*len) on return.  The caller should free the
                 returned array using <b>ber_memfree</b>().

              <b>l</b>  Length of the next element.  A pointer to a ber_len_t should be supplied.

              <b>t</b>  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

              <b>T</b>  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

              <b>x</b>  Skip element.  The next element is skipped.

              <b>{</b>  Begin sequence.  No parameter is  required.   The  initial  sequence  tag  and  length  are
                 skipped.

              <b>}</b>  End sequence.  No parameter is required and no action is taken.

              <b>[</b>  Begin set.  No parameter is required.  The initial set tag and length are skipped.

              <b>]</b>  End set.  No parameter is required and no action is taken.

       The  <b>ber_get_int</b>() routine tries to interpret the next element as an integer, returning the result in
       <u>num</u>.  The tag of whatever it finds is returned on success, LBER_ERROR (-1) on failure.

       The <b>ber_get_stringb</b>() routine is used to read an octet string into a preallocated  buffer.   The  <u>len</u>
       parameter  should  be initialized to the size of the buffer, and will contain the length of the octet
       string read upon return.  The buffer should be big enough to take the octet string value plus a  ter-<font color="#ffffff" class="whiteout">minating&nbsp;terminating</font>
       minating NULL byte.

       The  <b>ber_get_stringa</b>()  routine  is  used to dynamically allocate space into which an octet string is
       read.  The caller should free the returned string using <b>ber_memfree().</b>

       The <b>ber_get_stringal</b>() routine is used to dynamically allocate space into which an octet  string  and
       its  length  are  read.   It takes a struct berval **, and returns the result in this parameter.  The
       caller should free the returned structure using <b>ber_bvfree().</b>

       The <b>ber_get_stringbv</b>() routine is used to read an octet string  and  its  length  into  the  provided
       struct  berval  *.  If  the <u>alloc</u> parameter is zero, the string will reside in memory assigned to the
       BerElement, and must not be freed by the caller. If the <u>alloc</u> parameter is non-zero, the string  will
       be copied into dynamically allocated space which should be returned using <b>ber_memfree</b>().

       The  <b>ber_get_null</b>()  routine  is  used  to read a NULL element.  It returns the tag of the element it
       skips over.

       The <b>ber_get_boolean</b>() routine is used to read a boolean value.   It  is  called  the  same  way  that
       <b>ber_get_int</b>() is called.

       The  <b>ber_get_enum</b>()  routine  is  used  to  read a enumeration value.  It is called the same way that
       <b>ber_get_int</b>() is called.

       The <b>ber_get_bitstringa</b>() routine is used to read a bitstring value.  It takes a char  **  which  will
       hold  the  dynamically allocated bits, followed by an ber_len_t *, which will point to the length (in
       bits) of the bitstring returned.  The caller should free the returned string using <b>ber_memfree</b>().

       The <b>ber_first_element</b>() routine is used to return the tag and length of the first element in a set or
       sequence.   It  also  returns  in <u>cookie</u> a magic cookie parameter that should be passed to subsequent
       calls to ber_next_element(), which returns similar information.

<b>EXAMPLES</b>
       Assume the variable <u>ber</u> contains a lightweight BER encoding of the following ASN.1 object:

             AlmostASearchRequest := SEQUENCE {
                 baseObject      DistinguishedName,
                 scope           ENUMERATED {
                     baseObject    (0),
                     singleLevel   (1),
                     wholeSubtree  (2)
                 },
                 derefAliases    ENUMERATED {
                     neverDerefaliases   (0),
                     derefInSearching    (1),
                     derefFindingBaseObj (2),
                     alwaysDerefAliases  (3)
                 },
                 sizelimit       INTEGER (0 .. 65535),
                 timelimit       INTEGER (0 .. 65535),
                 attrsOnly       BOOLEAN,
                 attributes      SEQUENCE OF AttributeType
             }

       The element can be decoded using <b>ber_scanf</b>() as follows.

             ber_int_t    scope, deref, size, time, attrsonly;
             char   *dn, **attrs;
             ber_tag_t tag;

             tag = ber_scanf( ber, "{aeeiib{v}}",
                 &amp;dn, &amp;scope, &amp;deref,
                 &amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

             if( tag == LBER_ERROR ) {
                     /* error */
             } else {
                     /* success */
             }

             ber_memfree( dn );
             ber_memvfree( attrs );

<b>ERRORS</b>
       If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).


<b>NOTES</b>
       The return values for all of these functions are declared in the <b>&lt;lber.h&gt;</b> header file.  Some routines
       may  dynamically  allocate  memory which must be freed by the caller using supplied deallocation rou-<font color="#ffffff" class="whiteout">tines.&nbsp;routines.</font>
       tines.

<b>SEE</b> <b>ALSO</b>
       <a href="lber-encode.3.html#//apple_ref/doc/man/3/lber-encode"><b>lber-encode</b>(3)</a>, <a href="lber-memory.3.html#//apple_ref/doc/man/3/lber-memory"><b>lber-memory</b>(3)</a>, <!-- a --><b>lber-sockbuf</b>(3)<!-- /a -->, <a href="lber-types.3.html#//apple_ref/doc/man/3/lber-types"><b>lber-types</b>(3)</a>

<b>ACKNOWLEDGEMENTS</b>
       <b>OpenLDAP</b> is developed and maintained by The OpenLDAP Project (<a href="http://www.openldap.org/)">http://www.openldap.org/)</a>  <b>OpenLDAP</b> is
       derived from University of Michigan LDAP 3.3 Release.



OpenLDAP 2.3.27                                  2006/08/19                                   <!-- a -->LBER_DECODE(3)<!-- /a -->
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/ber_get_int.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/ber_get_int.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/ber_get_int.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
