<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OpenGLMovieQT - /Carbon SetupGL/Carbon_SetupGL_Test.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">OpenGLMovieQT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxGraphicsImaging-date.html" target="_blank">QuickTime > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OpenGLMovieQT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Carbon SetupGL/Carbon_SetupGL_Test.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Carbon Include.h</option>
<option value="listing2.html">/Carbon Resource.r</option>
<option value="listing3.html">/Carbon SetupGL/aglString/aglString.c</option>
<option value="listing4.html">/Carbon SetupGL/aglString/aglString.h</option>
<option value="listing5.html">/Carbon SetupGL/Carbon_Error_Handler.c</option>
<option value="listing6.html">/Carbon SetupGL/Carbon_Error_Handler.h</option>
<option value="listing7.html">/Carbon SetupGL/Carbon_Include.h</option>
<option value="listing8.html">/Carbon SetupGL/Carbon_Resource.r</option>
<option value="listing9.html">/Carbon SetupGL/Carbon_SetupDSp.c</option>
<option value="listing10.html">/Carbon SetupGL/Carbon_SetupDSp.h</option>
<option value="listing11.html">/Carbon SetupGL/Carbon_SetupGL.c</option>
<option value="listing12.html">/Carbon SetupGL/Carbon_SetupGL.h</option>
<option value="listing13.html">/Carbon SetupGL/Carbon_SetupGL_Test.c</option>
<option value="listing14.html">/OpenGL Movie Controls.c</option>
<option value="listing15.html">/OpenGL Movie Main.c</option>
<option value="listing16.html">/OpenGL Movie.c</option>
<option value="listing17.html">/OpenGLMovie.h</option></select>
				</p>
				</form>
				<p><strong><a href="OpenGLMovieQT.zip">Download Sample</a></strong> (&#147;OpenGLMovieQT.zip&#148;, 139.4K)<BR>
<strong><a href="OpenGLMovieQT.dmg">Download Sample</a></strong> (&#147;OpenGLMovieQT.dmg&#148;, 197.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SetupGL Main Windowed.c  Contains:  An example of the use of the SeupGL utility code for windowed applications.  Written by:  Geoff Stahl  Copyright:  2000 Apple Computer, Inc., All Rights Reserved   Change History (most recent first):  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.             &lt;10&gt;    4/20/01    ggs     add menu command and code to demonstrate shared texturing         &lt;9&gt;     9/3/00     ggs     Multi-window handling         &lt;8&gt;     3/22/00    ggs     Carbon take one         &lt;7&gt;     2/24/00    ggs      Windowed mode support          &lt;6&gt;     1/26/00    ggs     Add preflight support, handle failure conditions throughout app                                    better         &lt;5&gt;     1/24/00    ggs     fixed Apple menu selection, fixed aglfont texture row length                                    problem, fixed suspend/resume, fixed update         &lt;4&gt;    12/18/99    ggs     Fix headers         &lt;3&gt;    12/18/99    ggs     Added window/fullscreen toggle support and error window         &lt;2&gt;    11/28/99    ggs     Standard toolbox application         &lt;1&gt;    11/28/99    ggs     Initial Add         &lt;6&gt;     9/14/99    GGS      Corrected buffer rect handling and cleaned up code         &lt;5&gt;     7/14/99    GGS      Fixed multi-monitor window centering         &lt;4&gt;     7/13/99    GGS      Add work around for over zealous checking in single buffer DSp context attributes         &lt;3&gt;     7/5/99     GGS      Now correctly handle multi-monitor (DSp front buffer for single device; Window on top of context for multiple devices)         &lt;2&gt;     5/28/99    GGS     Added better multi-monitor support, clean code, corrected blanking bug, added timing, correct pixel formats         &lt;1&gt;        ?        ?      Initial build*/// system includes ----------------------------------------------------------#ifdef __APPLE_CC__    #include &quot;Carbon_Include.h&quot;    #include &lt;Carbon/Carbon.h&gt;#else    #include &lt;Devices.h&gt;    #include &lt;Dialogs.h&gt;    #include &lt;DriverServices.h&gt;    #include &lt;Events.h&gt;    #include &lt;Gestalt.h&gt;    #include &lt;LowMem.h&gt;    #include &lt;PictUtils.h&gt;    #include &lt;TextEdit.h&gt;    #include &lt;ToolUtils.h&gt;    #include &lt;QDOffscreen.h&gt;    #include &lt;Windows.h&gt;#endif#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#ifdef __APPLE_CC__    #include &lt;OpenGL/gl.h&gt;#else    #include &lt;gl.h&gt;#endif// project includes ---------------------------------------------------------#include &quot;aglString.h&quot;#include &quot;Carbon_SetupGL.h&quot;#include &quot;Carbon_Error_Handler.h&quot;// prototypes ---------------------------------------------------------------static void IntializeWindowList (void); // zeroize list's WindowPtrs (does not dispose)static long FindFirstFreeWindowIndex (void); // return index of first free WindowPtrstatic void DisposeGLWindow (WindowPtr pWindow); // Dispose a single window and it's GL contextstatic void DisposeGLWindowList (void); // Dispose entire window list and GL contextsvoid LoadTextureRes (short resID, GLbyte ** ppBuffer, short * pWidth, short * pHeight);void InitToolbox(void);void CreateGLWindow (void);Boolean SetUp (void);void DoMenu (SInt32 menuResult);void DoKey (SInt8 theKey, SInt8 theCode);void DoUpdate (WindowPtr pWindow);void DoEvent (void);void CleanUp (void);void drawGL(WindowPtr pWindow);#if TARGET_API_MAC_CARBONpascal void IdleTimer (EventLoopTimerRef inTimer, void* userData);EventLoopTimerUPP GetTimerUPP (void);#endif// statics/globals (internal only) ------------------------------------------struct structWindowInfo{  structGLWindowInfo glInfo;  AGLContext aglContext;  GLuint fontList;  char strContext [256];};typedef struct structWindowInfo structWindowInfo;typedef struct structWindowInfo * structWindowInfoPtr;// Menu defsenum {  kMaxWindows = 200,    kMenuApple = 128,  kMenuFile = 129,    kAppleAbout = 1,  kFileNew = 1,  kFileClose,  kFileBufferRect,  kFileTexture,  kFileFlipTexture,  kFileQuit};#if TARGET_API_MAC_CARBONenum {  kForegroundSleep = 10,  kBackgroundSleep = 10000};EventLoopTimerRef gTimer = NULL;#elseenum {  kForegroundSleep = 0,  kBackgroundSleep = 100};#endifSInt32 gSleepTime = kForegroundSleep;Boolean gDone = false, gfFrontProcess = true;Rect rectWin, rectInitWin = {50, 5, 150, 105}; // initial window rectangleWindowPtr gpWindowList [kMaxWindows];char gStringWindow [kMaxWindows][32];long gFrameWindow [kMaxWindows];AbsoluteTime gTimeWindow [kMaxWindows];float gRotation [kMaxWindows];Boolean gBufferRect = false;Boolean gTexture = false;GLuint nameTexture[2] = { 0, 0 };short gFirstTexture = 0;Boolean gMenu = false;AGLContext gTextureSharingContext [2] = { NULL, NULL };// functions (internal/private) ---------------------------------------------static void IntializeWindowList (void) // zeroize list's WindowPtrs (does not dispose){  long i;  for (i = 0; i &lt; kMaxWindows; i++)    gpWindowList[i] = NULL;}// --------------------------------------------------------------------------static long FindFirstFreeWindowIndex (void) // return index of first free WindowPtr{  long i = 0;  while ((gpWindowList[i] != NULL) &amp;&amp; (kMaxWindows &gt; i))    i++;  if (kMaxWindows == i)    return -1;  else    return i;}// --------------------------------------------------------------------------static void DisposeGLWindow (WindowPtr pWindow) // Dispose a single window and it's GL context{  if (pWindow)  {    structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (pWindow);    SetWRefCon (pWindow, NULL);    if (pWindowInfo)    {      DeleteFontGL (pWindowInfo-&gt;fontList);      // must clean up failure to do so will result in an Unmapped Memory Exception      if (gTextureSharingContext[0] == pWindowInfo-&gt;aglContext) // insure we do not try to share textures from invalid context        gTextureSharingContext[0] = NULL;      if (gTextureSharingContext[1] == pWindowInfo-&gt;aglContext) // insure we do not try to share textures from invalid context        gTextureSharingContext[1] = NULL;      DestroyGLFromWindow (&amp;pWindowInfo-&gt;aglContext, &amp;pWindowInfo-&gt;glInfo);      DisposePtr ((Ptr) pWindowInfo);    }    DisposeWindow (pWindow);  }}// --------------------------------------------------------------------------static void DisposeGLWindowList (void) // Dispose entire window list and GL contexts{  long i;  for (i = 0; i &lt; kMaxWindows; i++)  {    DisposeGLWindow (gpWindowList[i]);    gpWindowList[i] = NULL;  }}// --------------------------------------------------------------------------#pragma mark -void LoadTextureRes (short resID, GLbyte ** ppBuffer, short * pWidth, short * pHeight){  PicHandle hPic = NULL;  PictInfo thePictInfo;  GWorldPtr pGW = NULL;  long stride = 0;  char * baseaddr = NULL;  short i, j;  GDHandle saveDevice;  CGrafPtr saveWorld;  GetGWorld (&amp;saveWorld, &amp;saveDevice);  hPic = GetPicture (resID); // get background picture  if (hPic)  {    GetPictInfo (hPic, &amp;thePictInfo, 0, 0, 0, 0);     NewGWorld (&amp;pGW, 32, &amp;(thePictInfo.sourceRect), NULL, NULL, 0 );    if (pGW &amp;&amp; LockPixels (GetGWorldPixMap (pGW)))    {      SetGWorld (pGW, NULL);      DrawPicture (hPic, &amp;(thePictInfo.sourceRect));      SetGWorld (saveWorld, saveDevice); //ensure gdevice is restored            *pWidth = thePictInfo.sourceRect.right - thePictInfo.sourceRect.left;      *pHeight = thePictInfo.sourceRect.bottom - thePictInfo.sourceRect.top;      stride = GetPixRowBytes (GetGWorldPixMap (pGW));      baseaddr = GetPixBaseAddr (GetGWorldPixMap (pGW));      *ppBuffer = (signed char *)NewPtr (3 * *pWidth * *pHeight);      if (*ppBuffer)      {        for (i = 0; i &lt; *pHeight; i++)          for (j = 0; j &lt; *pWidth; j++)          {            *(*ppBuffer + (i * *pWidth  + j) * 3 + 0) = *(baseaddr + (i * stride) + j * 4 + 1);            *(*ppBuffer + (i * *pWidth  + j) * 3 + 1) = *(baseaddr + (i * stride) + j * 4 + 2);            *(*ppBuffer + (i * *pWidth  + j) * 3 + 2) = *(baseaddr + (i * stride) + j * 4 + 3);          }      }    }  }  DisposeGWorld (pGW);  ReleaseResource ((Handle) hPic);}// --------------------------------------------------------------------------#pragma mark -static pascal OSErr QuitAppleEventHandler( const AppleEvent *appleEvt, AppleEvent* reply, SInt32 refcon ){  #pragma unused (appleEvt, reply, refcon)  gDone =  true;  return false;}// --------------------------------------------------------------------------void InitToolbox(void){  OSErr err;  long response;  MenuHandle menu;  #if !TARGET_API_MAC_CARBON  MaxApplZone ();  InitGraf((Ptr) &amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(nil);#endif  InitCursor();  #if !TARGET_API_MAC_CARBON  qd.randSeed =  TickCount(); // ? Carbon Equivalent ?#endif  // Init Menus  menu = NewMenu (kMenuApple, &quot;\p\024&quot;);      // new  apple menu  InsertMenu (menu, 0);              // add menu to end#if !TARGET_API_MAC_CARBON  AppendResMenu(menu, 'DRVR');#endif    menu = NewMenu (kMenuFile, &quot;\pFile&quot;);      // new menu  InsertMenu (menu, 0);              // add menu to end  // insert application menus here  AppendMenu (menu, &quot;\pNew Window/N&quot;);  AppendMenu (menu, &quot;\pClose Window/W&quot;);  AppendMenu (menu, &quot;\pToggle Buffer Rect/B&quot;);  AppendMenu (menu, &quot;\pToggle Texturing/T&quot;);  AppendMenu (menu, &quot;\pFlip Textures/F&quot;);    // add quit if not under Mac OS X  err = Gestalt (gestaltMenuMgrAttr, &amp;response);  if ((err == noErr) &amp;&amp; !(response &amp; gestaltMenuMgrAquaLayoutMask))      AppendMenu (menu, &quot;\pQuit/Q&quot;);           // add quit  DrawMenuBar();  {    err = AEInstallEventHandler( kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(QuitAppleEventHandler), 0, false );    if (err != noErr)      ExitToShell();  }      rectWin = rectInitWin;  IntializeWindowList ();  { // initialize frame timing    long i;    for (i = 0; i &lt; kMaxWindows; i++)    {      gFrameWindow [i] = 0;      gTimeWindow [i].hi = 0;      gTimeWindow [i].lo = 0;      gRotation [i] = 0.0;    }  }}// --------------------------------------------------------------------------void CreateGLWindow (void){  short i;  long indexWin;  short fNum;    indexWin = FindFirstFreeWindowIndex ();  if (indexWin &gt;= 0) // valid index  {    GDHandle hGDWindow;    Rect rectSect;    structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) NewPtrClear (sizeof (structWindowInfo));#if TARGET_API_MAC_CARBON    if (noErr != CreateNewWindow (kDocumentWindowClass, kWindowStandardDocumentAttributes, &amp;rectWin, &amp;(gpWindowList [indexWin])))    {      DebugStr (&quot;\pCreate window error&quot;);      return;    }#else    gpWindowList [indexWin] = (WindowPtr) NewCWindow (NULL, &amp;rectWin, &quot;\pWindow&quot;, false, kWindowFullZoomGrowDocumentProc, (WindowPtr)-1, true, 0);#endif    // offset next window rectangle    OffsetRect (&amp;rectWin, 120, 30);    FindGDHandleFromRect (&amp;rectWin, &amp;hGDWindow);    SectRect (&amp;rectWin, &amp;(**hGDWindow).gdRect, &amp;rectSect);    if (!EqualRect (&amp;rectWin, &amp;rectSect))    {      OffsetRect (&amp;rectInitWin, 30, 7);      FindGDHandleFromRect (&amp;rectInitWin, &amp;hGDWindow);      SectRect (&amp;rectInitWin, &amp;(**hGDWindow).gdRect, &amp;rectSect);      if (!EqualRect (&amp;rectInitWin, &amp;rectSect))        SetRect (&amp;rectInitWin, 5, 50, 505, 450);      rectWin = rectInitWin;    }    { // set title to indicate index number      Str255 pstrTitle = &quot;\p&quot;;      NumToString (indexWin, pstrTitle);      SetWTitle (gpWindowList [indexWin], pstrTitle);    }    SetWRefCon (gpWindowList [indexWin], (long) pWindowInfo);    ShowWindow (gpWindowList [indexWin]);    SetPortWindowPort (gpWindowList [indexWin]);        pWindowInfo-&gt;glInfo.fAcceleratedMust = false;   // must renderer be accelerated?    pWindowInfo-&gt;glInfo.VRAM = 0 * 1048576;      // minimum VRAM (if not zero this is always a required minimum)    pWindowInfo-&gt;glInfo.textureRAM = 0 * 1048576;  // minimum texture RAM (if not zero this is always a required minimum)    if (!CheckMacOSX ()) // this is false on Mac OS 9 since Mac OS 9 does not support dragging conttexts with shared txtures between to different vendor's renderers.      pWindowInfo-&gt;glInfo.fDraggable = false;     // should a pixel format that supports all monitors be chosen?    else      pWindowInfo-&gt;glInfo.fDraggable = true;     // should a pixel format that supports all monitors be chosen?    pWindowInfo-&gt;glInfo.fmt = 0;          // output pixel format        i = 0;    pWindowInfo-&gt;glInfo.aglAttributes [i++] = AGL_RGBA;    pWindowInfo-&gt;glInfo.aglAttributes [i++] = AGL_DOUBLEBUFFER;    pWindowInfo-&gt;glInfo.aglAttributes [i++] = AGL_ACCELERATED;    pWindowInfo-&gt;glInfo.aglAttributes [i++] = AGL_NO_RECOVERY;    pWindowInfo-&gt;glInfo.aglAttributes [i++] = AGL_DEPTH_SIZE;    pWindowInfo-&gt;glInfo.aglAttributes [i++] = 16;    pWindowInfo-&gt;glInfo.aglAttributes [i++] = AGL_NONE;    BuildGLFromWindow (gpWindowList [indexWin], &amp;pWindowInfo-&gt;aglContext, &amp;pWindowInfo-&gt;glInfo, gTextureSharingContext [indexWin &amp; 0x01]);    if (!pWindowInfo-&gt;aglContext)    {      DestroyGLFromWindow (&amp;pWindowInfo-&gt;aglContext, &amp;pWindowInfo-&gt;glInfo);      sprintf (pWindowInfo-&gt;strContext, &quot;No context&quot;);          }    else    {      Rect rectPort;      #if TARGET_API_MAC_CARBON      GetWindowPortBounds (gpWindowList [indexWin], &amp;rectPort);#else      rectPort = gpWindowList [indexWin]-&gt;portRect;#endif // TARGET_API_MAC_CARBON      aglSetCurrentContext (pWindowInfo-&gt;aglContext);      aglReportError ();      aglUpdateContext (pWindowInfo-&gt;aglContext);      aglReportError ();      // Set Texture mapping parameters      glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S, GL_REPEAT);      glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T, GL_REPEAT);      glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR);      glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR);      glClearColor(0.15f, 0.15f, 0.15f, 1.0f);          // Clear color buffer to dark grey      glClear (GL_COLOR_BUFFER_BIT);      glReportError ();      aglSwapBuffers (pWindowInfo-&gt;aglContext);      aglReportError ();      if (gBufferRect)      {        GLint bufferRect[4] = {0, 0, 0, 0};        bufferRect [0] = 10; bufferRect [1] = 10;        bufferRect [2] = rectPort.right - rectPort.left - 20; bufferRect [3] = rectPort.bottom - rectPort.top - 20;        aglSetInteger (pWindowInfo-&gt;aglContext, AGL_BUFFER_RECT, bufferRect);        aglReportError ();        aglEnable (pWindowInfo-&gt;aglContext, AGL_BUFFER_RECT);        aglReportError ();        glViewport (0, 0, bufferRect [2], bufferRect [3]);        glReportError ();        sprintf (pWindowInfo-&gt;strContext, &quot;%ld x %ld&quot;, bufferRect [2], bufferRect [3]);            }      else      {        aglDisable (pWindowInfo-&gt;aglContext, AGL_BUFFER_RECT);        aglReportError ();        glViewport (0, 0, rectPort.right - rectPort.left, rectPort.bottom - rectPort.top);        glReportError ();        sprintf (pWindowInfo-&gt;strContext, &quot;%d x %d&quot;, rectPort.right - rectPort.left, rectPort.bottom - rectPort.top);            }      GetFNum(&quot;\pMonaco&quot;, &amp;fNum);                  // build font        pWindowInfo-&gt;fontList = BuildFontGL (pWindowInfo-&gt;aglContext, fNum, normal, 9);      aglUpdateContext (pWindowInfo-&gt;aglContext);      aglReportError ();                  if (NULL == gTextureSharingContext [indexWin &amp; 0x01] )        gTextureSharingContext [indexWin &amp; 0x01] = pWindowInfo-&gt;aglContext;    }      }}// --------------------------------------------------------------------------Boolean SetUp (void){  InitToolbox ();  if (PreflightGL (false))    CreateGLWindow ();#if TARGET_API_MAC_CARBON  if (!gTimer)    InstallEventLoopTimer (GetCurrentEventLoop(), 0, 0.000001, GetTimerUPP (), 0, &amp;gTimer);#endif  return true;}// --------------------------------------------------------------------------void DoMenu (SInt32 menuResult){#if !TARGET_API_MAC_CARBON  Str255 daName;#endif  SInt16 theMenu;  SInt16 theItem;  MenuRef theMenuHandle;      theMenu = HiWord(menuResult);  theItem = LoWord(menuResult);  theMenuHandle = GetMenuHandle(theMenu);  switch (theMenu)  {    case kMenuApple:      switch (theItem)      {        case kAppleAbout:          break;        default:#if !TARGET_API_MAC_CARBON          GetMenuItemText (theMenuHandle, theItem, daName);          OpenDeskAcc(daName);#endif          break;      }      break;    case kMenuFile:      switch (theItem)      {        case kFileNew:          CreateGLWindow ();          break;        case kFileClose:        {          WindowPtr whichWindow = FrontWindow ();          long i = 0;          while ((whichWindow != gpWindowList[i]) &amp;&amp; (kMaxWindows &gt; i)) {i++;}          if (kMaxWindows != i)          {            DisposeGLWindow (gpWindowList[i]);            gpWindowList[i] = NULL;            gFrameWindow [i] = 0;            gTimeWindow [i].hi = 0;            gTimeWindow [i].lo = 0;            gRotation [i] = 0.0;          }        }          break;        case kFileBufferRect:        {          long i = 0;          gBufferRect = 1 - gBufferRect;          for (i = 0; kMaxWindows &gt; i; i++)          {            if (gpWindowList[i] != NULL)            {              Rect rectPort;              structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (gpWindowList [i]);            #if TARGET_API_MAC_CARBON              GetWindowPortBounds (gpWindowList [i], &amp;rectPort);#else              rectPort = gpWindowList [i]-&gt;portRect;#endif // TARGET_API_MAC_CARBON              aglSetCurrentContext(pWindowInfo-&gt;aglContext);              if (gBufferRect)              {                GLint bufferRect[4] = {0, 0, 0, 0};                bufferRect [0] = 10; bufferRect [1] = 10;                bufferRect [2] = rectPort.right - rectPort.left - 20; bufferRect [3] = rectPort.bottom - rectPort.top - 20;                aglSetInteger (pWindowInfo-&gt;aglContext, AGL_BUFFER_RECT, bufferRect);                aglEnable (pWindowInfo-&gt;aglContext, AGL_BUFFER_RECT);                glViewport (0, 0, bufferRect [2], bufferRect [3]);                sprintf (pWindowInfo-&gt;strContext, &quot;%ld x %ld&quot;, bufferRect [2], bufferRect [3]);                    }              else              {                aglDisable (pWindowInfo-&gt;aglContext, AGL_BUFFER_RECT);                glViewport (0, 0, rectPort.right - rectPort.left, rectPort.bottom - rectPort.top);                sprintf (pWindowInfo-&gt;strContext, &quot;%d x %d&quot;, rectPort.right - rectPort.left, rectPort.bottom - rectPort.top);                    }              aglUpdateContext (pWindowInfo-&gt;aglContext);            }          }        }          break;        case kFileTexture: // enable shared texturing.  For mac OS X 10.0.1 and earlier this requires creating all contexts first        {          long i = 0;          GLbyte * pBuffer = NULL;          short width = 0, height = 0;          gTexture = 1 - gTexture;          if (gTexture)          {            if (gpWindowList[0] != NULL) // load the texture for the first window            {              structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (gpWindowList [0]);                          aglSetCurrentContext(pWindowInfo-&gt;aglContext);                            glEnable (GL_TEXTURE_2D);              if (nameTexture [0])                glDeleteTextures (2, nameTexture);              glGenTextures (2, nameTexture);              // load first texture              glBindTexture(GL_TEXTURE_2D, nameTexture[0]);              LoadTextureRes (1000 + gFirstTexture, &amp;pBuffer, &amp;width, &amp;height);              glTexImage2D (GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pBuffer);              DisposePtr ((Ptr)pBuffer);            }            if (gpWindowList[1] != NULL) // load the texture for the first window            {              structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (gpWindowList [1]);                          aglSetCurrentContext (pWindowInfo-&gt;aglContext);                            glEnable (GL_TEXTURE_2D);              // load second texture              glBindTexture(GL_TEXTURE_2D, nameTexture [1]);              LoadTextureRes (1000 + 1 - gFirstTexture, &amp;pBuffer, &amp;width, &amp;height);              glTexImage2D (GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pBuffer);              DisposePtr ((Ptr)pBuffer);            }          }          for (i = 0; kMaxWindows &gt; i; i++) // enable texturing for all windows but do not load texture again          {            if (gpWindowList[i] != NULL)            {              structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (gpWindowList [i]);                          aglSetCurrentContext(pWindowInfo-&gt;aglContext);              if (gTexture)              {                glEnable (GL_TEXTURE_2D);                glBindTexture(GL_TEXTURE_2D, nameTexture[i &amp; 0x01]);              }              else                glDisable (GL_TEXTURE_2D);            }          }        }          break;        case kFileFlipTexture: // enable shared texturing.  For mac OS X 10.0.1 and earlier this requires creating all contexts first        {          long i = 0;          GLbyte * pBuffer = NULL;          short width = 0, height = 0;          gFirstTexture = 1 - gFirstTexture;          if (gTexture)          {            if (gpWindowList[0] != NULL) // load the texture for the first window            {              structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (gpWindowList [0]);                          aglSetCurrentContext(pWindowInfo-&gt;aglContext);                            glEnable (GL_TEXTURE_2D);              // load first texture              glBindTexture(GL_TEXTURE_2D, nameTexture[0]);              LoadTextureRes (1000 + gFirstTexture, &amp;pBuffer, &amp;width, &amp;height);              glTexImage2D (GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pBuffer);              DisposePtr ((Ptr)pBuffer);            }            if (gpWindowList[1] != NULL) // load the texture for the first window            {              structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (gpWindowList [1]);                          aglSetCurrentContext (pWindowInfo-&gt;aglContext);                            glEnable (GL_TEXTURE_2D);              // load second texture              glBindTexture(GL_TEXTURE_2D, nameTexture [1]);              LoadTextureRes (1000 + 1 - gFirstTexture, &amp;pBuffer, &amp;width, &amp;height);              glTexImage2D (GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pBuffer);              DisposePtr ((Ptr)pBuffer);            }          }          for (i = 0; kMaxWindows &gt; i; i++) // enable texturing for all windows but do not load texture again          {            if (gpWindowList[i] != NULL)            {              structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (gpWindowList [i]);                          aglSetCurrentContext(pWindowInfo-&gt;aglContext);              if (gTexture)              {                glEnable (GL_TEXTURE_2D);                glBindTexture (GL_TEXTURE_2D, nameTexture[i &amp; 0x01]);              }              else                glDisable (GL_TEXTURE_2D);            }          }        }          break;        case kFileQuit:          gDone = true;          break;      }      break;  }  HiliteMenu(0);  DrawMenuBar();}// -------------------------------------------------------------------------- void DoKey (SInt8 theKey, SInt8 theCode){  #pragma unused (theCode, theKey)  // do nothing}// --------------------------------------------------------------------------#if TARGET_API_MAC_CARBONpascal void IdleTimer (EventLoopTimerRef inTimer, void* userData){  #pragma unused (inTimer, userData)  long i;  if (!gMenu)    for (i = 0; i &lt; kMaxWindows; i++)      if (gpWindowList[i])        DoUpdate (gpWindowList[i]);}// --------------------------------------------------------------------------EventLoopTimerUPP GetTimerUPP (void){  static EventLoopTimerUPP  sTimerUPP = NULL;    if (sTimerUPP == NULL)    sTimerUPP = NewEventLoopTimerUPP (IdleTimer);    return sTimerUPP;}#endif// --------------------------------------------------------------------------void DoUpdate (WindowPtr pWindow){  if (pWindow)  {    structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (pWindow);    if (pWindowInfo)    {      aglSetCurrentContext (pWindowInfo-&gt;aglContext);      if (gMenu)        aglUpdateContext (pWindowInfo-&gt;aglContext);      drawGL (pWindow);    }  }}// --------------------------------------------------------------------------void DoEvent (void){  EventRecord theEvent;  Rect rectTemp;  WindowRef whichWindow;  SInt16 whatPart;    if (WaitNextEvent(everyEvent, &amp;theEvent, gSleepTime, NULL))  {    {      switch (theEvent.what)      {        case mouseDown:          whatPart = FindWindow (theEvent.where, &amp;whichWindow);          switch (whatPart)          {            case inContent:              if (whichWindow != FrontWindow())                 SelectWindow (whichWindow);              break;            case inMenuBar:            {              SInt32 menuResult;              gMenu = true;              menuResult = MenuSelect (theEvent.where);              gMenu = false;              if (HiWord (menuResult) != 0)                DoMenu (menuResult);            }              break;            case inDrag:              {#if !TARGET_API_MAC_CARBON                DragWindow (whichWindow, theEvent.where, &amp;(**LMGetGrayRgn()).rgnBBox);#else                GetRegionBounds(GetGrayRgn(), &amp;rectTemp);                SetPort((GrafPtr) GetWindowPort(whichWindow));                DragWindow(whichWindow, theEvent.where, &amp;rectTemp);#endif // !TARGET_API_MAC_CARBON                                                aglUpdateContext (((structWindowInfoPtr) GetWRefCon (whichWindow))-&gt;aglContext);              }              break;            case inGrow:            {              long grow;              SetRect (&amp;rectTemp, 100, 100, 20000, 20000);              grow = GrowWindow (whichWindow, theEvent.where, &amp;rectTemp);              if (grow)              {                structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (whichWindow);                SizeWindow (whichWindow, grow &amp; 0x0000FFFF, grow &gt;&gt; 16, true);                // do content stuff here                SetPort ((GrafPtr) GetWindowPort(whichWindow));#if !TARGET_API_MAC_CARBON                InvalRect (&amp;whichWindow-&gt;portRect);        // redraw all#else                InvalWindowRect (whichWindow, GetWindowPortBounds (whichWindow, &amp;rectTemp));#endif // !TARGET_API_MAC_CARBON                if ((pWindowInfo) &amp;&amp; (pWindowInfo-&gt;aglContext))                {                  if (gBufferRect)                  {                    GLint bufferRect[4] = {0, 0, 0, 0};#if TARGET_API_MAC_CARBON                    GetWindowPortBounds (whichWindow, &amp;rectTemp);#else                    rectTemp = whichWindow-&gt;portRect;#endif // TARGET_API_MAC_CARBON                    bufferRect [0] = 10; bufferRect [1] = 10;                    bufferRect [2] = rectTemp.right - rectTemp.left - 20; bufferRect [3] = rectTemp.bottom - rectTemp.top - 20;                    aglSetCurrentContext (pWindowInfo-&gt;aglContext); // ensure the context we are working with is current                    aglSetInteger (pWindowInfo-&gt;aglContext, AGL_BUFFER_RECT, bufferRect);                    aglUpdateContext (pWindowInfo-&gt;aglContext);                    glViewport (0, 0, bufferRect [2], bufferRect [3]);                    sprintf (pWindowInfo-&gt;strContext, &quot;%ld x %ld&quot;, bufferRect [2], bufferRect [3]);                        }                  else                  {#if TARGET_API_MAC_CARBON                    GetWindowPortBounds (whichWindow, &amp;rectTemp);#else                    rectTemp = whichWindow-&gt;portRect;#endif // TARGET_API_MAC_CARBON                    aglSetCurrentContext (pWindowInfo-&gt;aglContext); // ensure the context we are working with is current                    aglUpdateContext (pWindowInfo-&gt;aglContext);                    glViewport (0, 0, rectTemp.right - rectTemp.left, rectTemp.bottom - rectTemp.top);                    sprintf (pWindowInfo-&gt;strContext, &quot;%d x %d&quot;, rectTemp.right - rectTemp.left, rectTemp.bottom - rectTemp.top);                        }                }              }            }              break;            case inGoAway:            {              long i = 0;              while ((whichWindow != gpWindowList[i]) &amp;&amp; (kMaxWindows &gt; i)) {i++;}              if (kMaxWindows == i)                DisposeWindow (whichWindow);              else              {                DisposeGLWindow (gpWindowList[i]);                gpWindowList[i] = NULL;                gFrameWindow [i] = 0;                gTimeWindow [i].hi = 0;                gTimeWindow [i].lo = 0;                gRotation [i] = 0.0;              }            }              break;            case inZoomIn:            case inZoomOut:            {              if (TrackBox (whichWindow, theEvent.where, whatPart))               {                structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (whichWindow);                SetPort ((GrafPtr) GetWindowPort (whichWindow));   // window must be current port#if TARGET_API_MAC_CARBON                EraseRect (GetWindowPortBounds (whichWindow, &amp;rectTemp));   // inval/erase because of ZoomWindow bug                ZoomWindow (whichWindow, whatPart, true);                InvalWindowRect (whichWindow, GetWindowPortBounds (whichWindow, &amp;rectTemp));  #else                EraseRect (&amp;whichWindow-&gt;portRect);   // inval/erase because of ZoomWindow bug                ZoomWindow (whichWindow, whatPart, true);                InvalRect (&amp;whichWindow-&gt;portRect);  #endif // TARGET_API_MAC_CARBON                if ((pWindowInfo) &amp;&amp; (pWindowInfo-&gt;aglContext))                {                  if (gBufferRect)                  {                    GLint bufferRect[4] = {0, 0, 0, 0};#if TARGET_API_MAC_CARBON                    GetWindowPortBounds (whichWindow, &amp;rectTemp);#else                    rectTemp = whichWindow-&gt;portRect;#endif // TARGET_API_MAC_CARBON                    bufferRect [0] = 10; bufferRect [1] = 10;                    bufferRect [2] = rectTemp.right - rectTemp.left - 20; bufferRect [3] = rectTemp.bottom - rectTemp.top - 20;                    aglSetCurrentContext (pWindowInfo-&gt;aglContext); // ensure the context we are working with is current                    aglSetInteger (pWindowInfo-&gt;aglContext, AGL_BUFFER_RECT, bufferRect);                    aglUpdateContext (pWindowInfo-&gt;aglContext);                    glViewport (0, 0, bufferRect [2], bufferRect [3]);                    sprintf (pWindowInfo-&gt;strContext, &quot;%ld x %ld&quot;, bufferRect [2], bufferRect [3]);                        }                  else                  {#if TARGET_API_MAC_CARBON                    GetWindowPortBounds (whichWindow, &amp;rectTemp);#else                    rectTemp = whichWindow-&gt;portRect;#endif // TARGET_API_MAC_CARBON                    aglSetCurrentContext (pWindowInfo-&gt;aglContext); // ensure the context we are working with is current                    aglUpdateContext (pWindowInfo-&gt;aglContext);                    glViewport (0, 0, rectTemp.right - rectTemp.left, rectTemp.bottom - rectTemp.top);                    sprintf (pWindowInfo-&gt;strContext, &quot;%d x %d&quot;, rectTemp.right - rectTemp.left, rectTemp.bottom - rectTemp.top);                        }                }              }            }              break;            case inSysWindow:#if !TARGET_API_MAC_CARBON              SystemClick(&amp;theEvent, whichWindow);#endif // !TARGET_API_MAC_CARBON              break;          }          break;        case keyDown:        case autoKey:        {          SInt8 theKey;          SInt8 theCode;          theKey = theEvent.message &amp; charCodeMask;          theCode = (theEvent.message &amp; keyCodeMask) &gt;&gt; 8;          if ((theEvent.modifiers &amp; cmdKey) != 0)          {            SInt32 menuResult = MenuKey (theKey);            if (HiWord(menuResult) != 0)              DoMenu (menuResult);          }          else            DoKey (theKey, theCode);        }          break;        case activateEvt:          break;        case updateEvt:        {          GrafPtr pGrafSave;          whichWindow = (WindowRef) theEvent.message;          GetPort (&amp;pGrafSave);          SetPort((GrafPtr) GetWindowPort(whichWindow));          BeginUpdate(whichWindow);          DoUpdate(whichWindow);          SetPort((GrafPtr) GetWindowPort(whichWindow));          EndUpdate(whichWindow);          SetPort (pGrafSave);        }          break;        case diskEvt:          break;        case osEvt:          if (theEvent.message &amp; 0x01000000)    //  Suspend/resume event          {            if (theEvent.message &amp; 0x00000001)  //  Resume            {              gSleepTime = kForegroundSleep;                gfFrontProcess = true;            }            else            {              gSleepTime = kBackgroundSleep;  //  Suspend              gfFrontProcess = false;            }          }          break;        case kHighLevelEvent:          AEProcessAppleEvent (&amp;theEvent);          break;      }    }  }#if !TARGET_API_MAC_CARBON  else  {    long i;    for (i = 0; i &lt; kMaxWindows; i++)      if (gpWindowList[i])        DoUpdate (gpWindowList[i]);  }#endif // !TARGET_API_MAC_CARBON}// --------------------------------------------------------------------------void CleanUp (void){  MenuHandle hMenu;  DisposeGLWindowList ();#if TARGET_API_MAC_CARBON  if (gTimer)  {    RemoveEventLoopTimer(gTimer);    gTimer = NULL;  }#endif // TARGET_API_MAC_CARBON    hMenu = GetMenuHandle (kMenuFile);  DeleteMenu (kMenuFile);  DisposeMenu (hMenu);  hMenu = GetMenuHandle (kMenuApple);  DeleteMenu (kMenuApple);  DisposeMenu (hMenu);}// --------------------------------------------------------------------------int main (void){  if (SetUp ())      while (!gDone)       DoEvent ();  CleanUp ();  return 0;}#pragma mark -//-----------------------------------------------------------------------------------------------------------------------// OpenGL Drawingvoid drawGL(WindowPtr pWindow){  float f = 0.0;  structWindowInfoPtr pWindowInfo = (structWindowInfoPtr) GetWRefCon (pWindow);  long indexWindow = 0;  // find which window in list to match frame time and number  while ((pWindow != gpWindowList [indexWindow]) &amp;&amp; (kMaxWindows &gt; indexWindow)) {indexWindow++;}  if (kMaxWindows == indexWindow) // not in list    indexWindow = -1;  glClearColor(0.25f, 0.25f, 0.25f, 1.0f);        // Clear color buffer to dark grey  glClear(GL_COLOR_BUFFER_BIT);    if (0 &lt;= indexWindow)  {    gRotation [indexWindow] += 0.5;    f = gRotation [indexWindow];  }  glMatrixMode (GL_MODELVIEW);  glLoadIdentity ();  glRotated (f, 0.0, 0.0, 1.0);  glEnable (GL_TEXTURE_2D);  glBegin(GL_QUADS);                      // Draw textured polygon    if (gTexture)    {        glTexCoord2f(0.0, 0.0);        glColor3d(1.0, 1.0, 1.0);        glVertex3d(0.7, 0.7, 0.0);        glTexCoord2f(0.0, 1.0);        glColor3d(1.0, 1.0, 1.0);        glVertex3d(-0.7, 0.7, 0.0);        glTexCoord2f(1.0, 1.0);        glColor3d(1.0, 1.0, 1.0);        glVertex3d(-0.7, -0.7, 0.0);        glTexCoord2f(1.0, 0.0);        glColor3d(1.0, 1.0, 1.0);        glVertex3d(0.7, -0.7, 0.0);    }    else    {        glColor3d(1.0, 0.0, 0.0);        glVertex3d(0.7, 0.7, 0.0);        glColor3d(0.0, 1.0, 0.0);        glVertex3d(-0.7, 0.7, 0.0);        glColor3d(0.0, 0.0, 1.0);        glVertex3d(-0.7, -0.7, 0.0);        glColor3d(0.7, 0.7, 0.7);        glVertex3d(0.7, -0.7, 0.0);    }  glEnd();  glDisable (GL_TEXTURE_2D);  // draw info  {    Rect rectPort;    GLint matrixMode;#if TARGET_API_MAC_CARBON    GetWindowPortBounds (pWindow, &amp;rectPort);#else    rectPort = pWindow-&gt;portRect;#endif // TARGET_API_MAC_CARBON    glGetIntegerv (GL_MATRIX_MODE, &amp;matrixMode);    glMatrixMode (GL_PROJECTION);    glPushMatrix();      glLoadIdentity ();      glMatrixMode (GL_MODELVIEW);      glPushMatrix();        glLoadIdentity ();        glScalef (2.0 / (rectPort.right - rectPort.left), -2.0 /  (rectPort.bottom - rectPort.top), 1.0);        glTranslatef (-(rectPort.right - rectPort.left) / 2.0, -(rectPort.bottom - rectPort.top) / 2.0, 0.0);        glColor3f (1.0, 1.0, 1.0);        glRasterPos3d (10, 12, 0);         if (0 &lt;= indexWindow)          MultiWinDrawFrameRate (pWindowInfo-&gt;fontList, gStringWindow[indexWindow], &amp;gFrameWindow[indexWindow], &amp;gTimeWindow[indexWindow]);        glRasterPos3d (10, 24, 0);         DrawCStringGL (pWindowInfo-&gt;strContext, pWindowInfo-&gt;fontList);        glRasterPos3d (10, (rectPort.bottom - rectPort.top) - 15, 0);         DrawCStringGL ((char*) glGetString (GL_VENDOR), pWindowInfo-&gt;fontList);        glRasterPos3d (10, (rectPort.bottom - rectPort.top) - 3, 0);         DrawCStringGL ((char*) glGetString (GL_RENDERER), pWindowInfo-&gt;fontList);      glPopMatrix(); // GL_MODELVIEW      glMatrixMode (GL_PROJECTION);    glPopMatrix();    glMatrixMode (matrixMode);  }  aglSwapBuffers(pWindowInfo-&gt;aglContext);                    // send swap command}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OpenGLMovieQT/listing13.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OpenGLMovieQT/listing13.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OpenGLMovieQT/listing13.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>