<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shark User Guide: System Tracing</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="System Tracing"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005233-CH4" title="System Tracing"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../Performance-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000901" target="_top">Performance</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005233-CH1-DontLinkElementID_6">Shark User Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../TimeProfiling/TimeProfiling.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../OtherProfilingandTracingTechniques/OtherProfilingandTracingTechniques.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005233-CH4-SW12" title="System Tracing"></a><h1>System Tracing</h1><p>Shark’s <em>System Trace</em> configuration records an exact trace of system-level events, such as system calls, thread scheduling decisions, interrupts, and virtual memory faults. <em>System Trace</em> allows you to measure and understand how your code interacts with Mac OS X and how the threads in your multi-threaded application interact with each other. If you would like to gain a clear understanding of the multi-threaded behavior of a given program, characterize user vs. system processor utilization, or understand the virtual memory paging behavior of your application, then <em>System Trace</em> can give you the necessary insight.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW32">Tracing Methodology</a>
				
			<br/>
			
        
			
			
				<a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW26">Basic Usage</a>
				
			<br/>
			
        
			
			
				<a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW2">Interpreting Sessions</a>
				
			<br/>
			
        
			
			
				<a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW1">Sign Posts</a>
				
			<br/>
			
        
			
			
				<a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW45">Tips and Tricks</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005233-CH4-SW32" title="Tracing Methodology"></a><h2>Tracing Methodology</h2><p><em>System Trace</em> complements Shark’s default <em>Time Profiling</em> configuration (see <span class="content_text"><a href="../TimeProfiling/TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW1">“Time Profiling”</a></span>) by allowing you to see <em>all</em> transitions between OS and user code, a useful complement to the statistical sampling techniques used by <em>Time Profiling</em>. For example, in <span class="content_text">“Basic Usage”</span> we can see an example of a thread of execution sampled by both a <em>Time Profile</em> (on top) and a <em>System Trace</em> (on the bottom). Time profiling takes evenly-spaced samples over the course of time, allowing us to get an even distribution of samples from various points of execution in both the user and system code segments of the application. This gives us a statistical view of what the processor was doing, but it does not allow us to see all user-kernel transitions — the first, brief visit to the kernel is completely missed, because it falls between two sample points. System tracing, in contrast, records an event for each user-kernel transition. Unlike time profiling, this does not give us an overview of <em>all</em> execution, because we are looking only at the transition borders and never in the execution time between them, but we gain an <em>exact</em> view of all of the transitions. This precision is often more useful when debugging user-kernel and multithreading problems, because these issues frequently hinge upon managing the precise timing of interaction <em>events</em> properly in order to minimize the time that threads spend waiting for resources (blocked), as opposed to minimizing execution time.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW33" title="Figure 3-1Time Profile vs. System Trace Comparison"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Time Profile vs. System Trace Comparison</p><img src = "../Art/TP_ST_comparison.jpg" alt = "Time Profile vs. System Trace Comparison" ></div><br/><p>As with most other profiling options available from Shark, System Trace requires no modification of your binaries, and can be used on released products. However, it is possible to insert arbitrary events into the System Trace Session using <em>Sign Posts</em>, which are discussed in detail in <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW1">“Sign Posts,”</a></span> if the built-in selection of events simply does not record enough information.</p><a name="//apple_ref/doc/uid/TP40005233-CH4-SW26" title="Basic Usage"></a><h2>Basic Usage</h2><p>In its simplest usage, all you need to do is select System Trace from the Configuration Popup and start sampling. Shark will then capture up to 1,000,000 system events per-processor (a user-tunable limit), process the results, and display a session (see <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW2">“Interpreting Sessions”</a></span>). In most cases, this should be more than enough data to interpret. Note that you cannot select a single process before you start tracing using the standard pop-up menu (from <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW4">“Main Window”</a></span>); instead, if you only want to see a trace for a specific process or thread, you must narrow the <em>scope</em> of the traced events <em>after</em> the session is recorded (see <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW2">“Interpreting Sessions”</a></span>).</p><p>In order to allow direct correlation of system events to your application’s code, Shark records the following information with each event:</p><ul class="ul"><li class="li"><p>Start Time</p></li><li class="li"><p>Stop Time</p></li><li class="li"><p>A backtrace of the user-space function calls (callstack) associated with each event</p></li><li class="li"><p>Additional data customized depending on the event type that triggers recording (see <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW11">“Trace View In-depth”</a></span> for details)</p></li></ul><p>In the course of profiling your application, it may become necessary to trim or expand the number of events recorded. Most of the typical options are tunable by displaying the Mini Config Editor, depicted in <span class="content_text">Figure 3-2</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW5" title="Figure 3-2System Trace Mini Config Editor"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>System Trace Mini Config Editor</p><img src = "../Art/systrace-mini-config.jpg" alt = "System Trace Mini Configuration Editor" ></div><br/><p> The Mini Config Editor adds the following profiling controls to the main Shark window:</p><ol class="ol"><li class="li"><p><strong>Start Delay</strong>— Amount of time to wait after the user selects “Start” before data collection actually begins.</p></li><li class="li"><p><strong>Time Limit</strong>— The maximum amount of time to record samples. This is ignored if <em>Windowed Time Facility</em> is enabled, or if Sample Limit is reached before the time limit expires.</p></li><li class="li"><p><strong>Sample Limit </strong>— The maximum number of samples to record. Specifying a maximum of <em>N</em> samples will result in at most <em>N</em> samples being taken, even on a multi-processor system, so this should be scaled up as larger systems are sampled. On the other hand, you may need to reduce the sample limit if Shark runs out of memory when you attempt to start a system trace, because it must be able to allocate a buffer in RAM large enough to hold this number of samples. When the sample limit is reached, data collection automatically stops, unless the <em>Windowed Time Facility</em> is enabled (see below). The Sample Limit is always enforced, and cannot be disabled.</p></li><li class="li"><p><strong>Windowed Time Facility</strong>— If enabled, Shark will collect samples until you explicitly stop it. However, it will only store the last N samples, where N is the number entered into the Sample Limit field. This mode is described in <span class="content_text"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html#//apple_ref/doc/uid/TP40005233-CH13-SW1">“Windowed Time Facility (WTF).”</a></span></p></li></ol><p>If the user-level callstacks associated with each system event are of no interest to you, it is possible to disable their collection from within the Plugin Editor for the System Trace Data Source (see <span class="content_text"><a href="../CustomConfigurations/CustomConfigurations.html#//apple_ref/doc/uid/TP40005233-CH8-SW19">“System Trace Data Source PlugIn Editor”</a></span>), further reducing the overhead of system tracing. With callstack recording disabled, Shark will still record the instruction pointer associated with each event, but will not record a full callstack. Since most system calls come from somewhere within library code, you may lose some ability to relate system events to your code with callstack recording disabled. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH4-DontLinkElementID_16" title="Out of memory errors?"></a><p><strong>Out of memory errors?:</strong>&nbsp;If you see these when starting a system trace, then just reduce the <em>Sample Limit</em> value until Shark is able to successfully allocate a buffer for itself.</p></div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW2" title="Interpreting Sessions"></a><h2>Interpreting Sessions</h2><p>Upon opening a System Trace session, Shark will present you with three different views, each in a separate tab.  Each viewer has different strengths and typical usage: </p><ul class="ul"><li class="li"><p>The <em>Summary View</em> provides an overall breakdown of where and how time was spent during the profiling session, and is very analogous to the <em>Profile Browser</em> used with Time Profile. You can use this information to ensure your application is behaving more-or-less as expected. For example, you can see if your program is spending approximately the right amount of time in system calls that you were expecting. You can even click on the System Call Summary to find out <em>which</em> system calls are being used and open the disclosure triangles to see where, <em>in your code</em>, these calls are happening.</p></li><li class="li"><p>The <em>Trace View</em> provides a complete trace of system events during the profiling session. Does the Summary View show that your CPU-bound threads are only getting an average of 200 microseconds of processor time every time they are scheduled? Flip to the Trace View to see why your threads are blocking so soon.</p></li><li class="li"><p>The <em>Timeline View</em> provides a complete picture of system activity over the course of a session, similar to Time Profile’s <em>Chart View</em>. You can use it to verify that your worker threads are running concurrently across all the processors in your system, or to visually inspect when various threads block.</p></li></ul><p>All views show trace events from a configurable <em>scope</em> of your System Trace. The default scope is the entire system, but you can also focus the session view on a specific process, and even a specific thread within that process. Independently, you can choose to only view events from a single CPU. For example, when focusing on CPU 1 <em>and</em> thread 2, you will see only the events caused by thread 2 that also occurred on CPU 1. The current settings for the scope are set using the three popup menus at the bottom of all System Trace session windows, which select process, thread, and CPU, respectively.</p><a name="//apple_ref/doc/uid/TP40005233-CH4-SW31" title="Summary View In-depth"></a><h3>Summary View In-depth</h3><p>The <em>Summary View</em> is the starting point for most types of analysis, and is shown in <span class="content_text">Figure 3-3</span>. Its most salient feature is a pie chart that gives an overview of where time was spent during the session. Time is broken down between user, system call, virtual memory fault, interrupt, idle, and other kernel time.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW3" title="Figure 3-3Summary View"></a><p><strong>Figure 3-3&nbsp;&nbsp;</strong>Summary View</p><img src = "../Art/SummaryView.jpg" alt = "Summary View" ></div><br/><p>Underneath the pie chart, there are individual summaries of the various event types. Each of these is discussed in turn in the following subsections.</p><a name="//apple_ref/doc/uid/TP40005233-CH4-SW34" title="Scheduler Summary"></a><h4>Scheduler Summary</h4><p>The <em>Scheduler Summary</em> tab, shown in <span class="content_text">Figure 3-4</span>, summarizes the overall scheduling behavior of the threads running in the system during the trace. Each thread is listed in the outline underneath its owning process, as shown at (1). To the left of each thread’s name, Shark displays the number of run intervals of that thread (or all threads within a process) that it recorded in the course of this session.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW7" title="Figure 3-4Summary View: Scheduler"></a><p><strong>Figure 3-4&nbsp;&nbsp;</strong>Summary View: Scheduler</p><img src = "../Art/SchedulerSummary.jpg" alt = "Summary View: Scheduler" ></div><br/><p>The <em>Total</em>, <em>Avg</em>, <em>Min</em> and <em>Max</em> columns  list the total, average, minimum, and maximum values for the selected metric. A popup button below the outline (2) lists the supported metrics:</p><ul class="spaceabove"><li class="li"><p><strong>Busy Time</strong>— Total time spent running, including both user and non-idle system time</p></li><li class="li"><p><strong>User Time</strong>— Total time spent running in user space</p></li><li class="li"><p><strong>System Time</strong>— Total time spent running in supervisor space (kernel and driver code)</p></li><li class="li"><p><strong>Priority</strong>— Dynamic thread priority used by the scheduler</p></li></ul><p>Information about how your application’s threads are being scheduled can be used to verify that what is actually happening on the system matches your expectations. Because the maximum time that a thread can run before it is suspended to run something else (the maximum <em>quantum</em> or <em>time slice</em>) is 10ms on Mac OS X, you can expect that a CPU-bound thread will generally be scheduled for several milliseconds per thread tenure. If you rewrite your CPU-bound, performance-critical code with multiple threads, and System Trace shows that these threads are only running for very short intervals (on the order of microseconds), this may indicate that the amount of work given to any worker thread is too small to amortize the overhead of creating and synchronizing your threads, or that there is a significant amount of serialization between these threads.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH4-DontLinkElementID_17" title="Note on Thread IDs"></a><p><strong>Note on Thread IDs:</strong>&nbsp;Thread IDs on Mac OS X are not necessarily unique across the duration of a System Trace Session. The Thread IDs reported by the kernel are not static, single use identifiers - they are actually memory addresses. When you destroy a thread, and then create a new one immediately thereafter, there is a very high probability that the new thread will have the same thread ID as the one you just destroyed. This can lead to some confusion when profiling multithreaded applications that create and destroy many threads.</p>There are a couple of distinct ways to avoid this confusion. Your first option is to <em>park</em> your threads when you are profiling; if you don’t let any new threads exit for the duration of profiling, it is not possible to get duplicate thread IDs. A better option is to utilize a work queue model: create enough threads to fully populate the processors in your system, and instead of destroying the threads when they are out of work, put them on a work queue to be woken up later with more work.</p></div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW35" title="System Calls Summary"></a><h4>System Calls Summary</h4><p>The <em>System Calls Summary</em> tab, shown in <span class="content_text">Figure 3-5</span>, allows you to see the breakdown of system call time for each specific system call. Because System Trace normally records the user callstack for each system call, you can use this view to correlate system call time (and other metrics) directly to the locations in your application’s code that make system calls. This view is quite similar to Time Profile’s standard profile view, described in <span class="content_text"><a href="../TimeProfiling/TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW19">“Profile Browser.”</a></span> In fact, many of the same tools are available. For example, the system call profile can be viewed as either a heavy or tree view (selected using the popup menu at the bottom). Similarly, data mining can be used to simplify complex system call callstacks (see <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining”</a></span>).</p><p>More settings for modifying this display are available in the <em>Advanced Settings</em> drawer, and are described in <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW21">“Summary View Advanced Settings.”</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW6" title="Figure 3-5Summary View: System Calls"></a><p><strong>Figure 3-5&nbsp;&nbsp;</strong>Summary View: System Calls</p><img src = "../Art/SyscallSummary.jpg" alt = "Summary View: System Calls" ></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH4-DontLinkElementID_18" title="Note on System Trace callstacks"></a><p><strong>Note on System Trace callstacks:</strong>&nbsp;In rare cases, it is not possible for System Trace to accurately determine the user callstack for the currently active thread. In this case, it may just copy the callstack from the previous sample. While it occurs so rarely that it is usually not a problem, this “interpolation” can occasionally result in bad callstack information. As a result, you should carefully analyze Shark’s system trace callstacks when the callstack information seems unusual or impossible.</p></div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW29" title="Virtual Memory (VM) Faults Summary "></a><h4>Virtual Memory (VM) Faults Summary </h4><p>The <em>VM Faults Summary</em> tab, depicted in <span class="content_text">Figure 3-6</span>, allows you to see what code is causing virtual memory faults to occur. The purpose of this view is to help you find behavior that is normally transparent to software, and is obscured in a statistical time profile. Functionally, it acts just like the <em>System Calls Summary</em> tab.</p><p>By default, virtual memory faults are broken down by type:</p><ul class="spaceabove"><li class="li"><p><strong>Page In</strong>— A page was brought back into memory from disk.</p></li><li class="li"><p><strong>Page Out</strong>— A page was pushed out to disk, to make room for other pages.</p></li><li class="li"><p><strong>Zero Fill</strong>— A previously unused page marked “zero fill on demand” was touched for the first time.</p></li><li class="li"><p><strong>Non-Zero Fill</strong>— A previously unused page <em>not</em> marked “zero fill on demand” was touched for the first time. Generally, this is only used in situations when the OS knows that page being allocated will immediately be overwritten with new data, such as when it allocates I/O buffers.</p></li><li class="li"><p><strong>Copy on Write (COW)</strong>— A shared, read-only page was modified, so the OS made a private, read-write copy for this process.</p></li><li class="li"><p><strong>Page Cache Hit</strong>— A memory-resident but unmapped page was touched.</p></li><li class="li"><p><strong>Guard Fault</strong>— A page fault to a “guard” page. These pages are inserted just past the end of memory buffers allocated using the special MacOS X “guard malloc” routines, which can be used in place of normal memory allocations during debugging to test for buffer overrun errors. One of these faults is generated when the buffer overruns.</p></li><li class="li"><p><strong>Failed Fault</strong>— Any page fault (regardless of type) that started and could not be completed. User processes will usually die when these occur, but the kernel usually handles them more gracefully in order to avoid a panic.</p></li></ul><p>In some cases, virtual memory faults can represent a significant amount of overhead. For example, if you see a large amount of time being spent in zero fill faults, and correlate it to repeated allocation and subsequent deallocation of temporary memory in your code, you may be able to instead reuse a single buffer for the entire loop, reallocating it only when more space is needed. This type of optimization is especially useful in the case of very large (multiple page) allocations.</p><p>More settings for modifying this display are available in the <em>Advanced Settings</em> drawer, and are described in <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW21">“Summary View Advanced Settings.”</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW14" title="Figure 3-6Summary View: VM Faults"></a><p><strong>Figure 3-6&nbsp;&nbsp;</strong>Summary View: VM Faults</p><img src = "../Art/VMFaultSummary.jpg" alt = "Summary View: VM Faults" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW21" title="Summary View Advanced Settings"></a><h4>Summary View Advanced Settings</h4><p>When you are viewing the <em>System Calls Summary</em> and <em>VM Faults Summary</em> tabs, several options are available in the <em>Advanced Settings</em> drawer (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW9">“Advanced Settings Drawer”</a></span>), as seen in <span class="content_text">Figure 3-7</span>:</p><ol class="ol"><li class="li"><p><strong>Weight By Popup</strong>— the summary can construct the profile of system calls using several metrics. The following metrics can be selected:</p><ul class="ul"><li class="li"><p><em>CPU Time</em>— Total system call or fault time spent actively running on a processor</p></li><li class="li"><p><em>Wait Time</em>— Total system call or fault time spent blocked waiting on a resource or event</p></li><li class="li"><p><em>Total Time</em>— Total system call or fault time, including both CPU and waiting time</p></li><li class="li"><p><em>Count</em>— Total system call or fault count</p></li><li class="li"><p><em>Size</em>— (VM fault tab only) Total number of bytes faulted, since a single fault can sometimes affect more than one page</p></li></ul></li><li class="li"><p><strong>Display Popup</strong>— This lets you choose between having the <em>Self</em> and <em>Total</em> columns display the raw <em>Value</em> for the selected metric or the percent of total system call or fault time. You can also change the columns between these modes individually by double clicking on either column.</p></li><li class="li"><p><strong>Group by System Call/VM Fault Type</strong>— By default, the metrics are listed for each of the different <em>types</em> of system calls or faults in the trace. You can see summary statistics for all system calls or faults by deselecting this.</p></li><li class="li"><p><strong>Callstack Data Mining</strong>— The System Call and VM Fault summaries support Shark’s data mining options, described in <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining,”</a></span> which can also be used to customize the presentation of the data.</p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW25" title="Figure 3-7Summary View Advanced Settings Drawer"></a><p><strong>Figure 3-7&nbsp;&nbsp;</strong>Summary View Advanced Settings Drawer</p><img src = "../Art/SummaryAdvanced.jpg" alt = "Summary View Advanced Settings Drawer" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW11" title="Trace View In-depth"></a><h3>Trace View In-depth</h3><p>The <em>Trace View</em> lists <em>all</em> of the events that occurred in the currently selected scope. Because events are most commonly viewed with “System” scope (all processes <em>and</em> all CPUs), each event list has a <em>Process</em> and a <em>Thread</em> column describing the execution context in which it took place.</p><p>As with the <em>Summary View</em>, the <em>Trace View</em> is sub-divided according to the class of event. The events in each <em>event class</em> (scheduler events, system calls, and VM Faults) are separately indexed, starting from 0. Each tab in the <em>Trace View</em> lists the index of the event (specific to each event class) in the <em>Index Column</em>.</p><p>Each tab in the <em>Trace View</em> supports multi-level (hierarchical) sorting of the event records, based on the order that you click column header row cells. This provides an extremely flexible means for searching the event lists. For example, clicking on the “CPU Time” column title will immediately sort by CPU Time. If you then click on the “Name” column title Shark will group events by Name, and then within each group of identically named events it will sort secondarily by CPU Time.</p><p>You may click on events in the table to select them. As with most Mac tables, you may Shift-click to extend a contiguous selection or Command-click to select discontiguous events. Below the main <em>Trace View</em> table, Shark presents a line summarizing key features of the selected trace event(s). This is particularly convenient if you select multiple events at once, because Shark will automatically add up key features of the selected events together and present the totals here.</p><p>You should note that double-clicking on any event in the trace list will jump to that event in the <em>Timeline View</em>. This is a helpful way to go directly to a spot of interest in a System Trace, because you can reliably scroll to the same point by double-clicking on the same trace element.</p><p>The remainder of this section will examine the three different tabs in the trace view window.</p><a name="//apple_ref/doc/uid/TP40005233-CH4-SW30" title="Scheduler Trace"></a><h4>Scheduler Trace</h4><p>The <em>Scheduler Trace</em> Tab, shown in <span class="content_text">Figure 3-8</span>, lists the intervals that threads were running on the system. The meanings of the columns are as follows:</p><ul class="spaceabove"><li class="li"><p><strong>Index</strong>— A unique index for the thread interval, assigned by Shark</p></li><li class="li"><p><strong>Process</strong>— Shows the process to which the scheduled thread belongs. The process’ PID is in brackets after the name, which can be helpful if you have multiple copies of a process running simultaneously.</p></li><li class="li"><p><strong>Thread</strong>— The kernel’s identifier for the thread</p></li><li class="li"><p><strong>Time</strong>— Total time (the sum of user and system time) that the thread ran</p></li><li class="li"><p><strong>User Time</strong>— Time that the thread spent executing user code during the interval</p></li><li class="li"><p><strong>Sys Time</strong>— Time that the thread spent executing system (kernel) code during the interval</p></li><li class="li"><p><strong>Δt Prev</strong>— Time since this thread was previously scheduled</p></li><li class="li"><p><strong>Reason</strong>— Reason that the thread tenure ended (described in <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW23">“Thread Run Intervals”</a></span>)</p></li><li class="li"><p><strong>Priority</strong>— Dynamic scheduling priority of the thread</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW13" title="Figure 3-8Trace View: Scheduler"></a><p><strong>Figure 3-8&nbsp;&nbsp;</strong>Trace View: Scheduler</p><img src = "../Art/SchedulerTrace.jpg" alt = "Trace View: Scheduler" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW36" title="System Call Trace"></a><h4>System Call Trace</h4><p>The <em>System Call Trace</em> Tab, shown in <span class="content_text">Figure 3-9</span>, lists the system call events that occurred during the trace. In most respects, this Tab behaves much like the scheduler tab described previously, but it does have a couple of new features.</p><p>You can inspect the first five integer arguments to each system call by selecting an entry in the table and looking at the <code>arg</code> fields near the bottom of the window.</p><p>The current user callstack is recorded for each system call. You can toggle the display of the <em>Callstack Table</em> by clicking the <img src = "../Art/CallstackButton.jpg" alt = "Callstack Button" > button in the lower right corner of the trace table. When visible, the <em>Callstack Table</em>  displays the user callstack for the currently selected system call entry.</p><p>The meanings of the columns are as follows:</p><ul class="spaceabove"><li class="li"><p><strong>Index</strong>— A unique index for the system call event, assigned by Shark</p></li><li class="li"><p><strong>Interval</strong>— Displays thread run interval(s) in which the system call occurred. Each system call occurs over one or more thread run intervals . If the system call begins and ends in the same thread interval, the <em>Interval Column</em> for that event lists only a single number: the index of the thread interval in which the event occurred. Otherwise, the beginning and ending thread interval indices are listed. Because it is possible for an event to start before the beginning of a trace session, or end after a trace session is stopped, event records may be incomplete. Incomplete events are listed with “?” for the unknown thread run interval index, and have a gray background in the event lists.</p></li><li class="li"><p><strong>Process</strong>— Shows the process in which the system call occurred. The process’ PID is in brackets after the name, which can be helpful if you have multiple copies of a process running simultaneously.</p></li><li class="li"><p><strong>Thread</strong>— Thread in which the system call occurred</p></li><li class="li"><p><strong>Name</strong>— Name of the system call</p></li><li class="li"><p><strong>Return</strong>— Shows the return value from the system call. Many system calls return zero for success, and non-zero for failure, so you can often spot useless system calls by looking for multiple failures. Eliminating streams of these can reduce the amount of time an application spends in wasted system call overhead.</p></li><li class="li"><p><strong>CPU Time</strong>— Time spent actively running on a processor</p></li><li class="li"><p><strong>Wait Time</strong>— Time spent blocked waiting on a resource or event</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW15" title="Figure 3-9Trace View: System Calls"></a><p><strong>Figure 3-9&nbsp;&nbsp;</strong>Trace View: System Calls</p><img src = "../Art/SyscallTrace.jpg" alt = "Trace View: System Calls" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW37" title="VM Fault Trace"></a><h4>VM Fault Trace</h4><p>The <em>VM Fault Trace</em> Tab, illustrated in <span class="content_text">Figure 3-10</span>, lists the virtual memory faults that occurred. The current user callstack, if any, is recorded for each VM fault.</p><p>You can toggle the display of the <em>Callstack Table</em>, which displays the user callstack for the currently selected VM fault entry, by clicking the <img src = "../Art/CallstackButton.jpg" alt = "Callstack Button" > button in the lower right corner of the trace table.</p><p>The columns in the trace view have the following meanings in this tab:</p><ul class="spaceabove"><li class="li"><p><strong>Index</strong>— A unique index for the VM fault event, assigned by Shark</p></li><li class="li"><p><strong>Interval</strong>— Displays thread run interval(s) in which the VM fault occurred. Each fault occurs over one or more thread run intervals. If the fault begins and ends in the same thread interval, the <em>Interval Column</em> for that event lists only a single number: the index of the thread interval in which the event occurred. Otherwise, the beginning and ending thread interval indices are listed. Because it is possible for an event to start before the beginning of a trace session, or end after a trace session is stopped, event records may be incomplete. Incomplete events are listed with “?” for the unknown thread run interval index, and have a gray background in the event lists.</p></li><li class="li"><p><strong>Process</strong>— Shows the process in which the VM fault occurred. The process’ PID is in brackets after the name, which can be helpful if you have multiple copies of a process running simultaneously.</p></li><li class="li"><p><strong>Thread</strong>— Thread in which the VM fault occurred</p></li><li class="li"><p><strong>Type</strong>— Fault type (see <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW29">“Virtual Memory (VM) Faults Summary ”</a></span> for descriptions)</p></li><li class="li"><p><strong>CPU Time</strong>— Time spent actively running on a processor</p></li><li class="li"><p><strong>Wait Time</strong>— Time spent blocked waiting on a resource or event</p></li><li class="li"><p><strong>Library</strong>— In the case of a code fault, this lists the framework, library, or executable containing the faulted address. In contrast, it is blank for faults to data regions, such as the heap or stack.</p></li><li class="li"><p><strong>Address</strong>— Address in memory that triggered the fault</p></li><li class="li"><p><strong>Size</strong>— Number of bytes affected by the fault, an integral multiple of the 4096-byte system page size</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW8" title="Figure 3-10Trace View: VM Faults"></a><p><strong>Figure 3-10&nbsp;&nbsp;</strong>Trace View: VM Faults</p><img src = "../Art/VMFaultTrace.jpg" alt = "Trace View: VM Faults" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW4" title="Timeline View In-depth"></a><h3>Timeline View In-depth</h3><p>The <em>Timeline View</em>, displayed in <span class="content_text">Figure 3-11</span>, allows you to visualize a <em>complete</em> picture of system events and threading behavior in detail, instead of just summaries. Each row in the timeline corresponds to a traced thread, with the horizontal axis representing time. At a glance, you can see when and why the threads in your system start and stop, and how they interact with the system when they are running.</p><p>Session timelines are initially shown in their entirety. Because a typical session has thousands or millions of events in it, this initially means that you can only see a broad overview of when threads are running. Events such as system calls and VM faults are labeled with icons, but these icons are automatically hidden if there is insufficient space to display them, as is usually the case when the trace is completely zoomed out. Hence, to see and examine these events, you will need to zoom in on particular parts of the timeline display and then maneuver around to see other parts of the display. There are 3 main ways to perform this navigation:</p><ul class="spaceabove"><li class="li"><p><strong>Scroll/Zoom Bars</strong>— Use the scroll bar at the bottom of the window to scroll side to side, and zoom with the slider at the top of the window.</p></li><li class="li"><p><strong>Mouse Dragging</strong>— Click and drag anywhere (or “rubber-band”) within the main Timeline View to form a box. When you release the mouse bottom, the Timeline View will zoom so that the horizontal portion of the box fits on screen (until you reach the maximum zoom level).</p></li><li class="li"><p><strong>Keyboard Navigation</strong>— After highlighting a Thread Run Interval by clicking on it, the Left or Right Arrow keys will take you to the previous or next run interval from the same thread, respectively. If you highlighted a System Call, VM Fault, or Interrupt, the arrow keys will scroll to the next event of any of these types. Holding the Option key, however, will scroll to the next event of the <em>same</em> type. For example, if you had clicked on a Zero Fill Fault, the Right Arrow would take you to the next event on the same thread, whether it was a System Call, VM Fault, or Interrupt, but Option-Right Arrow would take you to the next Zero Fill Fault on the same thread.</p></li></ul><p>If you have too many threads, the <em>Timeline View</em> allows you to limit the scope of what is displayed using the standard scope-control menus described in <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW2">“Interpreting Sessions,”</a></span> at the bottom of the window. There are also many options for filtering out events in the <em>Advanced Settings</em> drawer, as described in <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW22">“Timeline View Advanced Settings.”</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW16" title="Figure 3-11Timeline View"></a><p><strong>Figure 3-11&nbsp;&nbsp;</strong>Timeline View</p><img src = "../Art/TimelineOverview.jpg" alt = "Timeline View" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW23" title="Thread Run Intervals"></a><h4>Thread Run Intervals</h4><p>Each time interval that a thread is actively running on a CPU is a <em>thread run interval</em>. Thread run intervals are depicted as solid rectangles in the <em>Timeline View</em>, as is shown in <span class="content_text">Figure 3-12</span>, with lines depicting context switches joining the ends of the two threads running before and after each context switch.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW18" title="Figure 3-12Timeline View: Thread Run Intervals"></a><p><strong>Figure 3-12&nbsp;&nbsp;</strong>Timeline View: Thread Run Intervals</p><img src = "../Art/RunIntervalsDetail.jpg" alt = "Timeline View: Thread Run Intervals" ></div><br/><p>Thread interval lines can be colored according to several metrics, including the CPU on which the thread ran, its dynamic priority, and the reason the thread was switched out. See <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW22">“Timeline View Advanced Settings”</a></span> for more information on how to control this.</p><p>You can inspect any thread run interval in the Timeline View by clicking on it. The inspector (see <span class="content_text">Figure 3-13</span>) will indicate the amount of time spent running in user mode and supervisor mode, the reason the thread was switched out, and its dynamic priority.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW19" title="Figure 3-13Thread Run Interval Inspector"></a><p><strong>Figure 3-13&nbsp;&nbsp;</strong>Thread Run Interval Inspector</p><img src = "../Art/ThreadInspector.jpg" alt = "Thread Run Interval Inspector" ></div><br/><p>There are five basic reasons a thread will be switched out by the system to run another thread:</p><ul class="simple"><li><p><strong>Blocked</strong>— The thread is waiting on a resource and has voluntarily released the processor while it waits.</p></li><li><p><strong>Explicit Yield</strong>— The thread voluntarily released its processor, even though it is not waiting on any particular resource.</p></li><li><p><strong>Quantum Expired</strong>— The thread ran for the maximum allowed time slice, normally 10ms, and was therefore interrupted and descheduled by the kernel.</p></li><li><p><strong>Preemption</strong>— A higher priority thread was made runnable, and the thread was interrupted in order to switch to that thread. It is also possible to be “urgently” preempted by some real-time threads.</p></li><li><p><strong>Urgent Preemption</strong>— Same as previous, except that the thread preempting us <em>must</em> have the processor immediately, usually due to real-time constraints.</p></li></ul><a name="//apple_ref/doc/uid/TP40005233-CH4-SW28" title="System Calls"></a><h4>System Calls</h4><p>System calls represent explicit work done on behalf of the calling process. They are a secure way for user-space applications to employ kernel APIs. On Mac OS X, these APIs can be divided into four groups:</p><ul class="simple"><li><p><img src = "../Art/BSDSysCallIcon.jpg" alt = "BSD System Call Icon" ><strong>BSD</strong>— Syscall, ioctl, sysctl APIs </p></li><li><p><img src = "../Art/MachSysCallIcon.jpg" alt = "Mach System Call Icon" ><strong>Mach</strong>— Basic services and abstractions (ports, locks, etc.) </p></li><li><p><img src = "../Art/LockIcon.jpg" alt = "Lock System Call Icon" ><strong>Locks</strong>— <em>pthread mutex</em> calls that trap to the kernel. These are a subset of Mach system calls.</p></li><li><p><img src = "../Art/MIGMessageIcon.jpg" alt = "MIG Message Icon" ><strong>MIG Message</strong>— Mach interface generator routines, which are usually only used within the kernel</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW17" title="Figure 3-14Timeline View: System Calls"></a><p><strong>Figure 3-14&nbsp;&nbsp;</strong>Timeline View: System Calls</p><img src = "../Art/SysCallDetail.jpg" alt = "Timeline View: System Calls" ></div><br/><p>Calls from all of these groups are visible in <span class="content_text">Figure 3-14</span>. Clicking on the icon for a system call will bring up the System Call Inspector, as seen in <span class="content_text">Figure 3-15</span>. The resulting inspector displays many useful pieces of information which you can use to correlate the system call to you application’s code. The listed information includes:</p><ul class="spaceabove"><li class="li"><p><strong>Type</strong>— The system call icon and a textual description</p></li><li class="li"><p><strong>Name</strong>— The system call name</p></li><li class="li"><p><strong>Number</strong>— The system call’s event index number (its number in the Trace View)</p></li><li class="li"><p><strong>Callstack</strong>— A backtrace of user space function calls that caused the system call</p></li><li class="li"><p><strong>Time</strong> — Total, CPU, and wait time</p></li><li class="li"><p><strong>Result</strong>— The return value from the call</p></li><li class="li"><p><strong>Arguments</strong>— The first four integer arguments</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW9" title="Figure 3-15System Call Inspector"></a><p><strong>Figure 3-15&nbsp;&nbsp;</strong>System Call Inspector</p><img src = "../Art/SysCallInspector.jpg" alt = "System Call Inspector" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW38" title="VM Faults"></a><h4>VM Faults</h4><p>As is the case with almost all modern operating systems, Mac OS X implements a virtual memory system. Virtual memory works by dividing up the addressable space (typically 4GB on a 32-bit machine, currently 256 TB on 64-bit machines) into pages (typically 4 KB in size). Pages are brought into available physical memory from a backing store (typically a hard disk) on demand through the page fault mechanism. In addition to efficiently managing a system’s available physical memory, this added level of indirection provided by the virtual to physical address mapping allows for memory protection, shared memory, and other modern operating system capabilities. There are five virtual memory events on Mac OS X, all of which are faults (running code is interrupted to handle them the first time the page is touched) except for page outs, which are completed asynchronously.</p><ul class="simple"><li><p><img src = "../Art/PageInIcon.jpg" alt = "Page In Fault" ><strong>Page In</strong>— A page was brought back into memory from disk.</p></li><li><p><img src = "../Art/PageOutIcon.jpg" alt = "Page Out Fault" ><strong>Page Out</strong>— A page was pushed out to disk, to make room for other pages.</p></li><li><p><img src = "../Art/ZeroFillIcon.jpg" alt = "Zero Fill On-Demand Fault" ><strong>Zero Fill</strong>— A previously unused page marked “zero fill on demand” was touched for the first time.</p></li><li><p><img src = "../Art/NZF.jpg" alt = "Callstack Button" ><strong>Non-Zero Fill</strong>— A previously unused page <em>not</em> marked “zero fill on demand” was touched for the first time. Generally, this is only used in situations when the OS knows that page being allocated will immediately be overwritten with new data, such as when it allocates I/O buffers.</p></li><li><p><img src = "../Art/COWIcon.jpg" alt = "Copy-on-write Fault" ><strong>Copy on Write (COW)</strong>— A shared, read-only page was modified, so the OS made a private, read-write copy for this process.</p></li><li><p><img src = "../Art/CacheHitIcon.jpg" alt = "Page Cache Hit" ><strong>Page Cache Hit</strong>— A memory-resident but unmapped page was touched.</p></li><li><p><img src = "../Art/Guard.jpg" alt = "Callstack Button" ><strong>Guard Fault</strong>— A page fault to a “guard” page. These pages are inserted just past the end of memory buffers allocated using the special MacOS X “guard malloc” routines, which can be used in place of normal memory allocations during debugging to test for buffer overrun errors. One of these faults is generated when the buffer overruns.</p></li><li><p><img src = "../Art/Failed.jpg" alt = "Callstack Button" ><strong>Failed Fault</strong>— Any page fault (regardless of type) that started and could not be completed. User processes will usually die when these occur, but the kernel usually handles them more gracefully in order to avoid a panic.</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW20" title="Figure 3-16Timeline View: VM Faults"></a><p><strong>Figure 3-16&nbsp;&nbsp;</strong>Timeline View: VM Faults</p><img src = "../Art/VMFaultDetail.jpg" alt = "Timeline View: VM Faults" ></div><br/><p>Three of these types of faults are visible in <span class="content_text">Figure 3-16</span>. A zero-fill fault is circled to highlight it. Clicking on a VM Fault Icon will bring up the VM Fault Inspector, as seen in <span class="content_text">Figure 3-17</span>. This inspector functions much like the System Call Inspector, except instead of listing arguments and return values, the VM Fault Inspector lists the fault address, size, and — for code faults — the library in which it occurred.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW10" title="Figure 3-17VM Fault Inspector"></a><p><strong>Figure 3-17&nbsp;&nbsp;</strong>VM Fault Inspector</p><img src = "../Art/VMFaultInspector.jpg" alt = "VM Fault Inspector" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW39" title="Interrupts"></a><h4>Interrupts</h4><p>Interrupts are asynchronous signals that external hardware devices use to communicate to the processor that they require servicing. Most are associated with I/O devices, and signal either that new data has been received by an input device or that an output device needs more data to send. However, there are also other sources of interrupts inside of the computer system, such as DMA controllers and clock timers.</p><p>Here is an interrupt icon: <img src = "../Art/InterruptIcon.jpg" alt = "Interrupt" ></p><p>Because interrupts occur asynchronously, there is no correlation between the source of the interrupt and the thread being interrupted. As a result, and because most users of System Trace are primarily interested in examining the threading behavior of their own programs, the display of interrupt events in the <em>Timeline View</em> is disabled by default. See <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW22">“Timeline View Advanced Settings”</a></span> for instructions on how to enable these.</p><p>Clicking on an Interrupt icon will bring up the Interrupt Inspector. This inspector lists the amount of time the interrupt consumed, broken down by CPU and wait time.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW40" title="Figure 3-18Interrupt Inspector"></a><p><strong>Figure 3-18&nbsp;&nbsp;</strong>Interrupt Inspector</p><img src = "../Art/InterruptInspector.jpg" alt = "Interrupt Inspector" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW27" title="Sign Posts "></a><h4>Sign Posts </h4><p>You can often get a good idea of your application’s current state by inspecting the user callstacks associated with the built-in VM fault and system call events that occur in your application. But an even more precise technique is to instrument your application with <em>Sign Post</em> events at critical points in your code (see <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW1">“Sign Posts”</a></span> for instructions as to how you can do this). For example, if you are developing an application that operates on video frames, you can insert a sign post marker whenever the processing of a new frame starts.</p><p>Here is a sign post icon: <img src = "../Art/SignPostIcon.jpg" alt = "Sign Post" ></p><p>Sign posts are displayed in the timeline alongside the other events. You can inspect each sign post by clicking its icon in the timeline. The inspector will indicate which thread it came from, its event name, the 4 user-specified ancillary data values for both the begin and the end point, and the associated user callstack (if any). If the sign post is an “interval” sign post, an under-bar will indicate its duration on the timeline, and the inspector will list the amount of time spent on the CPU and time spent Waiting between the begin and end event. Since you can supply different arguments to the start and end points of an interval sign post, the inspector supplies “Begin” and “End” tabs that display the arguments supplied to the start and end points, respectively. </p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW41" title="Figure 3-19Sign Post Inspector"></a><p><strong>Figure 3-19&nbsp;&nbsp;</strong>Sign Post Inspector</p><img src = "../Art/SignPostInspector.jpg" alt = "Sign Post Inspector" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW22" title="Timeline View Advanced Settings"></a><h4>Timeline View Advanced Settings</h4><p>While you are in <em>Timeline View</em>, several options are available in the <em>Advanced Settings</em> drawer (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW9">“Advanced Settings Drawer”</a></span>), as seen in <span class="content_text">Figure 3-20</span>.</p><ol class="ol"><li class="li"><p><strong>Enable Thread Coloring</strong>— When enabled (the default), Shark attempts to color-code the threads in the timeline display using one of the algorithms selected below.</p></li><li class="li"><p><strong>Color By</strong>— Assuming that you do choose to use thread coloring, this menu allows you to choose from among several different color schemes that allow you to see different trends:</p><ul class="ul"><li class="li"><p><strong>CPU</strong>— Each CPU is assigned a different color, so you can see both how a processor is bouncing from one thread to another or, alternately, how a thread is bouncing from one processor to another. This is the default, and usually the most useful coloration.</p></li><li class="li"><p><strong>Priority</strong>— Thread priority is assigned a color on a gradient from deep blue-violet colors (low priority) to bright, hot yellows and oranges (high priority). Mac OS X changes thread priority dynamically, depending upon how much CPU time each thread gets, so this color scheme is useful to see the effects of these dynamic changes over time.</p></li><li class="li"><p><strong>Reason</strong>— Colors each thread run tenure based on the reason that it ended. See <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW23">“Thread Run Intervals”</a></span> for a list of the possible reasons that are used to color-code thread tenures.</p></li></ul></li><li class="li"><p><strong>Color Key</strong>— Displays the colors that Shark is currently using to display your threads.</p></li><li class="li"><p><strong>Draw Context Switch Lines</strong>— Check this to enable (default) or disable the thin gray lines that show context switches, linking the thread tenures before and after the switch that ran on the same CPU core.</p></li><li class="li"><p><strong>Detailed Event Icons</strong>— Deselecting this instructs Shark turn off the icons that identify the various types of VM faults and system calls and just replace them with generic “plain page” VM fault and “gray phone” system call icons.</p></li><li class="li"><p><strong>Label Events</strong>— These checkboxes allow you to enable or disable the display of event icons either entirely, by type group, or on an individual, type-by-type basis. For example, you can use them to enable interrupt icons or to remove icons for events, such as VM faults, that you may not be interested in at the present time.</p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH4-SW24" title="Figure 3-20Timeline View Advanced Settings Drawer"></a><p><strong>Figure 3-20&nbsp;&nbsp;</strong>Timeline View Advanced Settings Drawer</p><img src = "../Art/TimelineAdvanced.jpg" alt = "Timeline View Advanced Settings Drawer" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH4-SW1" title="Sign Posts"></a><h2>Sign Posts</h2><p>Even with all of the system-level instrumentation already included in Mac OS X, you may sometimes find that it is helpful or even necessary to further instrument your code. Whether to orient yourself within a long trace, or to time certain operations, <em>Sign Posts</em> can be inserted in your code to accomplish these and other tasks.</p><p>Shark supports two types of Sign Posts:</p><ul class="ul"><li class="li"><p>Point events (no duration)</p></li><li class="li"><p>Interval events (with beginning <em>and</em> ending points)</p></li></ul><p>Point events can be used to orient yourself within a larger trace. For example, if you are developing an application that operates on video frames, you can insert a sign post marker whenever the processing of a new frame has begun. Interval events can be used to time operations, such as the length a particular lock is held, or how long it takes to decode a frame of video.</p><p>In order to use Sign Posts, you must first make Shark aware of your Sign Posts’ definitions. Do so by creating a <em>Sign Post File</em>. In your home directory, Shark creates a folder in which you can place Sign Post Files: <code>~/Library/Application Support/Shark/KDebugCodes</code>. A Sign Post File is <em>any</em> file that contains specially formatted lines which associate a code value with a Sign Post name. This name can be anything you like. To create a Sign Post File, simply create a new text file in the above directory and edit it, adding one Sign Post definition per line. Each line should only contain a hexadecimal value followed by an event name, as illustrated in the following example:</p><a name="//apple_ref/doc/uid/TP40005233-CH4-SW42" title="Listing 3-1~/Library/Application Support/Shark/KDebugCodes/myFirstSignPosts"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>~/Library/Application Support/Shark/KDebugCodes/myFirstSignPosts</p><div class="codesample"><table><tr><td scope="row"><pre>0x31 LoopTimer<span></span></pre></td></tr><tr><td scope="row"><pre>0x32 LockHeld<span></span></pre></td></tr></table></div><p>Sign Post values can take any value from 0x0 to 0x3FFF, inclusive.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH4-DontLinkElementID_19" title="Note on changes to Sign Post Files"></a><p><strong>Note on changes to Sign Post Files:</strong>&nbsp;If you created your Sign Post File while Shark was running, you might need to relaunch Shark for your new Sign Posts to appear in a System Trace. If you’ve already taken a System Trace that generated Sign Posts, but no Sign Posts are displayed in the Viewers, then save your session and relaunch Shark with your Sign Post Definition file(s) in place.</p></div><p>Once you’ve added your Sign Post File(s) to the <code>KDebugCodes</code> directory, you can add Sign Posts to your code. There are two ways to accomplish this, depending on where your code runs: </p><ul class="ul"><li class="li"><p><strong>User Applications using CHUD Framework:</strong> User Applications that link with the <code>CHUD.framework</code>, and can simply call <code>chudRecordSignPost()</code>, which has the following API:</p><div class="codesample"><table><tr><td scope="row"><pre>int chudRecordSignPost(unsigned code, chud_signpost_t type,<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned arg1, unsigned arg2, unsigned arg3, unsigned arg4);<span></span></pre></td></tr></table></div></li><li class="li"><p><strong>User Applications not using CHUD Framework:</strong> User Applications for which you prefer not to link with the <code>CHUD.framework</code> can still create signposts using explicit system calls. You will need to include <code>&lt;sys/syscall.h></code> and <code>&lt;sys/kdebug.h></code>, and then use the following call (with a “type” suffix of <code>NONE</code> for a point signpost, <code>START</code> for begin interval, and <code>END</code> for end interval):</p><div class="codesample"><table><tr><td scope="row"><pre>syscall(SYS_kdebug_trace, APPSDBG_CODE(DBG_MACH_CHUD, &lt;your code number>) |<span></span></pre></td></tr><tr><td scope="row"><pre>    DBG_FUNC_&lt;&lt;type>>, arg1, arg2, arg3, arg4);<span></span></pre></td></tr></table></div></li><li class="li"><p><strong>Kernel Extensions:</strong> Kernel Extensions <em>must</em> call <code>kernel_debug()</code> directly, using the <code>APPS_DEBUG()</code> macro as the <code>debugid</code> argument. Using this function and macro requires you to include <code>&lt;sys/kdebug.h></code>, and then make your call like this (the “type” suffixes are the same as in the <code>syscall</code> case):</p><div class="codesample"><table><tr><td scope="row"><pre>KERNEL_DEBUG(APPSDBG_CODE(DBG_MACH_CHUD, &lt;your code number>) |<span></span></pre></td></tr><tr><td scope="row"><pre>    DBG_FUNC_&lt;&lt;type>>, arg1, arg2, arg3, arg4, 0);<span></span></pre></td></tr></table></div></li></ul><p>In both cases, the caller can record up to 4 values of user-defined data with each Sign Post that will be recorded and displayed with the session. </p><p>The Sign Post <code>type</code> must be one of the following:</p><ul class="ul"><li class="li"><p><code>chudPointSignPost</code> for a point event with no duration.</p></li><li class="li"><p><code>chudBeginIntervalSignPost</code> for the start point of an interval Sign Post.</p></li><li class="li"><p><code>chudEndIntervalSignPost</code> for the end point of an interval Sign Post. </p></li></ul><p>When using interval Sign Posts, the start and end points will be coalesced into one Sign Post with a duration equal to the elapsed time between the two events. You must ensure that the same <code>code</code> value is given for both the start and end points of the interval Sign Post. It is possible to “nest” sign posts - just be sure you match the code value for each start and end point.</p><p>The example uses the Sign Post defined in the above Sign Post File to create an interval Sign Post that times a loop in a user-space application:</p><a name="//apple_ref/doc/uid/TP40005233-CH4-SW43" title="Listing 3-2signPostExample.c"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>signPostExample.c</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;CHUD/CHUD.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;stdint.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* This corresponds to the sign post defined above, LoopTimer */<span></span></pre></td></tr><tr><td scope="row"><pre>#define LOOP_TIMER 0x31<span></span></pre></td></tr><tr><td scope="row"><pre>#define ITERATIONS 1000<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>uint32_t ii;<span></span></pre></td></tr><tr><td scope="row"><pre class="bold"> </pre><pre><span></span></pre></td></tr><tr><td scope="row"><pre>/* The last 4 arguments are user-defined, ancillary data */<span></span></pre></td></tr><tr><td scope="row"><pre class="bold">chudRecordSignPost(LOOP_TIMER, chudBeginIntervalSignPost, ITERATIONS, 0, 0, 0);</pre><pre><span></span></pre></td></tr><tr><td scope="row"><pre>for(ii = 0; ii &lt; ITERATIONS; ii++) {<span></span></pre></td></tr><tr><td scope="row"><pre>    do_some_stuff();<span></span></pre></td></tr><tr><td scope="row"><pre>    do_more_stuff();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* notice that the code value used here matches that used above */<span></span></pre></td></tr><tr><td scope="row"><pre class="bold">chudRecordSignPost(LOOP_TIMER, chudEndIntervalSignPost, 0, 0, 0, 0);</pre><pre><span></span></pre></td></tr></table></div>	<div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH4-DontLinkElementID_20" title="Note"></a><p><strong>Note:</strong>&nbsp;To compile the above example, you’ll need to instruct <code>gcc</code> to use the <code>CHUD.framework</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>gcc -framework CHUD -F/System/Library/PrivateFrameworks signPostExample.c<span></span></pre></td></tr></table></div></div><p>To accomplish the same task in a kernel extension, use <code>kernel_debug()</code> as follows:</p><a name="//apple_ref/doc/uid/TP40005233-CH4-SW44" title="Listing 3-3testKernelSignPost.c"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>testKernelSignPost.c</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;sys/kdebug.h><span></span></pre></td></tr><tr><td scope="row"><pre>#define LOOP_TIMER 0x31<span></span></pre></td></tr><tr><td scope="row"><pre>#define ITERATIONS 1000<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>uint32_t ii;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre> * Use the kernel_debug() method when in the kernel (arg5 is unused),<span></span></pre></td></tr><tr><td scope="row"><pre> * DBG_FUNC_START corresponds to chudBeginIntervalSignPost.<span></span></pre></td></tr><tr><td scope="row"><pre> */<span></span></pre></td></tr><tr><td scope="row"><pre class="bold">kernel_debug(APPS_DEBUG(DBG_MACH_CHUD, LOOP_TIMER) | DBG_FUNC_START,</pre><pre><span></span></pre></td></tr><tr><td scope="row"><pre class="bold">    ITERATIONS, 0, 0, 0, 0);</pre><pre><span></span></pre></td></tr><tr><td scope="row"><pre>for(ii = 0; ii &lt; ITERATIONS; ii++) {<span></span></pre></td></tr><tr><td scope="row"><pre>    do_some_stuff();<span></span></pre></td></tr><tr><td scope="row"><pre>    do_more_stuff();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* remember to use the same debugid value, with DBG_FUNC_END */<span></span></pre></td></tr><tr><td scope="row"><pre class="bold">kernel_debug(APPS_DEBUG(DBG_MACH_CHUD, LOOP_TIMER) | DBG_FUNC_END,</pre><pre><span></span></pre></td></tr><tr><td scope="row"><pre class="bold">    0, 0, 0, 0, 0);</pre><pre><span></span></pre></td></tr></table></div>	<p>You should note that when using Sign Posts in the kernel, it is not necessary to add CHUD to the list of linked frameworks. Adding the above code to your drivers will cause Sign Posts to be created in the System Trace session without it. Similar code using the <code>syscall(SYS_kdebug_trace,...</code> invocation instead of <code>kernel_debug</code> does exactly the same thing, but works from user code, instead.</p><a name="//apple_ref/doc/uid/TP40005233-CH4-SW45" title="Tips and Tricks"></a><h2>Tips and Tricks</h2><p>This section will list common things to look for in a <em>System Trace</em>, what they may mean, and how to improve your application’s code using the information presented. The tips and tricks listed herein are organized according to the view most commonly used to infer the associated behavior.</p><ul class="ul"><li class="li"><p><strong>Summary View</strong></p><ul class="nested"><li class="nested li"><p><em>Short average run intervals for worker threads:</em></p><p>This can indicate that the amount of work given to each worker thread is too small to amortize the cost of creating and synchronizing your threads. Try giving each thread more work to do, or dynamically tune the amount of work given to each thread based on the number and speed of processors present in the system (these values can be introspected at runtime using the <code>sysctl()</code> or <code>sysctlbyname()</code> APIs).</p><p>It can also indicate that your threads frequently block while waiting for locks. In this case, it is possible that the short intervals are inherent to your program’s locking needs. However, you may want to see if you can reduce the inter-thread contention for locks in your code so that the locks are not contested nearly as much.</p></li><li class="nested li"><p><em>Inordinate count of the same system call:</em></p><p>Sometimes, things like <code>select()</code> are called too often. For system calls such as this, try increasing the timeout value. You might also want to rethink your algorithm to reduce the number of system calls made, if possible. Because System Trace records the user callstack associated with each system call by default, it’s relatively easy to find the exact lines of code that cause the frequent system call(s) in question.</p></li><li class="nested li"><p><em>Large amount of time spent in Zero Fill Faults:</em></p><p>This can indicate that your application is frequently allocating and deallocating large chunks of temporary memory. If you correlate the time spent in Zero Fill Faults to allocation and deallocation of temporary memory, then try eliminating these allocation/deallocation pairs and just reuse the chunks of memory whenever possible. This optimization is especially useful with very large chunks of memory, since a large amount of time can be wasted on zero-fill faults after every reallocation.</p></li></ul></li><li class="li"><p><strong>Trace View</strong></p><ul class="nested"><li class="nested li"><p><em>System calls repeatedly failing:</em></p><p>As above, when system calls repeatedly return failure codes, inspect your algorithm and ensure that you still need to be calling them. The overhead of a system call is considerable, and any chance to avoid making a system call, such as checking for known failure conditions prior to making the call, can improve the performance of your code considerably.</p></li><li class="nested li"><p><em>System calls repeated too frequently (redundant system calls):</em></p><p>This can be indicated either by the same system call being called multiple times in a row as displayed in the Trace View, or by a large count value when <em>Weight By</em> is set to <em>Count</em> in the <em>Summary View</em>. Inspect your algorithm to ensure the repeated system call needs to be called as often as reported — there’s a good chance you could be doing redundant work.</p></li><li class="nested li"><p><em>Sign Posts were generated during session, but are not displayed:</em></p><p>If you’ve already taken a System Trace session in which your application or driver generated Sign Posts, but no Sign Posts are displayed in the Trace view, it is possible that the correct Sign Post definition file(s) were not in place when you launched Shark. First, save your session — if Sign Posts were generated, they will be saved in the session regardless of whether or not they are displayed. Ensure the correct Sign Post Files are in place in <code>~/Library/Application Support/Shark/KDebugCodes/</code> and relaunch Shark. Opening your session should now display the Sign Posts.</p></li></ul></li><li class="li"><p><strong>Timeline View</strong></p><ul class="nested"><li class="nested li"><p><em>Multi-threaded application only has only one thread running at a time:</em></p><p>First of all, ensure you’ve performed the System Trace on a multiprocessor machine. You can do this by pressing <em>Command+I</em> to bring up the session inspector, which will list the pertinent hardware information from the machine on which the session was created. Usually, this is not an issue.</p><p>Second, ensure your selected scope is not limited to a single CPU. </p><p>Once you’ve verified the session was taken on a multi-processor machine and is displaying data for all processors, look in the timeline for <em>Lock</em> icons (see <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW28">“System Calls”</a></span>). Their presence indicates <em>pthread mutex</em> operations that have resulted in a trap to the kernel, usually as a result of lock contention. This may indicate a serialization point in your algorithm. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH4-DontLinkElementID_21" title="Locking Note"></a><p><strong>Locking Note:</strong>&nbsp;Currently, only <em>pthread mutex</em> operations are given a distinct icon. However, you can still view semaphore system calls in the <em>Trace</em> and <em>Timeline</em> views under their Mach system calls. In either case, only contention that results in a trap to the kernel is indicated; user space contention will not show up in a System Trace. </p></div><p>Correlate the locking operations to your application’s code using the inspector (single-click the icon). If the serialization point is not necessary, remove it. Otherwise, try to reduce the amount of time spent holding the lock. You might also instrument your code with <span class="content_text"><a href="SystemTracing.html#//apple_ref/doc/uid/TP40005233-CH4-SW1">“Sign Posts”</a></span> in order to characterize the amount of time spent holding the lock.</p></li><li class="nested li"><p><em>Worker thread run intervals are shorter than expected:</em></p><p>Remember, the default scheduling quantum on Mac OS X is 10ms. If the thread run intervals are near 10ms, there may not be any benefit to continuing this investigation.</p><p>If the thread run intervals are much shorter than 10ms, single-click the short thread run intervals, making sure not to click any event icons. The resulting inspector will list the reason why the thread in question was switched out. If it blocked, the inspector will list the blocking event and its index. Use the trace view to correlate this event (usually a system call) to your application’s code. </p><p>An alternate approach is to look for event icons which have an underbar that extends past the end of the thread run intervals. This generally indicates that the event in question — such as an I/O system call or mutex lock — caused the thread to block. Clicking the event icon will display the associated user callstack (if any), allowing you to correlate it directly to your application’s code.</p><p>If you find your threads are frequently blocking on system calls such as <code>stat(2)</code>, <code>open(2)</code>, <code>lseek(2)</code>, and the like, you may be able to use smarter caching for file system actions.  If you see multiple threads context switching back and forth, identify their purpose. If they are CPU-bound, this is not necessarily a problem. However, if these threads are communicating with each other, it may be prudent to redesign your inter-thread communication protocol to reduce the amount of inter-thread communication.</p><p>Another possibility is that you’ve simply not given your worker threads enough work to do. Verify this theory using the tip from the summary view suggestions above.</p></li><li class="nested li"><p><em>One processor doesn’t show any thread run intervals until much later than another:</em></p><p>If this happens, chances are you are using the Windowed Time Facility. This is due to a fundamental difference in how the data is recorded when using this mode. When using <em>WTF</em> Mode, the user-specified number of events are right-aligned, as described in <span class="content_text"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html#//apple_ref/doc/uid/TP40005233-CH13-SW1">“Windowed Time Facility (WTF).”</a></span> Because of this right-alignment, you’ll notice that all the CPUs tend to end around the same point in time in the timeline, but may start at vastly different times.</p><p>This difference in start time is expected, and most likely means that any CPU which starts later in the timeline was generating system events at a higher rate (on average) than CPUs that start earlier.</p></li><li class="nested li"><p><em>My application is supposed to be creating and destroying more threads than are shown:</em></p><p>On Mac OS X, thread identifiers (thread IDs) are not always static, unique numbers for the duration of a profiling session. In fact, thread IDs are merely addresses in a zone of memory used by the kernel. When your application creates and destroys threads in rapid succession, the kernel must also allocate and free threads from this zone of memory. Not only is this a huge amount of overhead, but it makes it possible to create a new thread that will have the exact same thread ID as a thread which you just destroyed.</p><p>There are a couple of ways to avoid this confusion. The first, simple option is to “park” your threads when profiling. Simply don’t let your threads exit, and your thread IDs are guaranteed to be unique. A second, arguably better option is to utilize a work queue model for your threads. Create just enough worker threads to fully populate the number of processors in your system, and two queues: one to hold IDs of free threads and another to hold task records describing new “work” to be completed. When a worker thread completes a task, do not destroy it. Either assign it a new task from the task queue, or place it on the free thread queue until another task is available. This not only reduces the overhead of allocating and freeing memory in the kernel, but also ensures that your thread IDs will be unique while profiling.</p></li><li class="nested li"><p><em>I see an inordinate amount of interrupt icons:</em></p><p>If you see a large number of interrupt icons during the run intervals of your threads, you may be communicating with the underlying hardware inefficiently. Sometimes, it is possible to assemble your hardware requests into larger batch requests  for better performance. Inspect your algorithm and find any places to group hardware requests.</p></li><li class="nested li"><p><em>I need to return to a particular point X on the timeline:</em></p><p>If you might be returning to a location later, take a moment to note the index number and type of a nearby event, by clicking on that event and reading the event inspector. To return, or to send someone else there, look up that event in the <em>Trace View</em> and double-click on it. This will bring you directly back to the interesting spot.</p></li></ul></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../TimeProfiling/TimeProfiling.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../OtherProfilingandTracingTechniques/OtherProfilingandTracingTechniques.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-04-14<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/SystemTracing/SystemTracing.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/SystemTracing/SystemTracing.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/SystemTracing/SystemTracing.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>