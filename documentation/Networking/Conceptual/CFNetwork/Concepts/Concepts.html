<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>CFNetwork Programming Guide: CFNetwork Concepts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="CFNetwork Concepts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001132-CH4" title="CFNetwork Concepts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000429" target="_top">Networking</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30001132-CH1-DontLinkElementID_24">CFNetwork Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CFStreamTasks/CFStreamTasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001132-CH4-SW10" title="CFNetwork Concepts"></a><h1>CFNetwork Concepts</h1><p>CFNetwork is a low-level, high-performance framework that gives you the ability to have detailed control over the protocol stack. It is an extension to BSD sockets, the standard socket abstraction API that provides objects to simplify tasks such as communicating with FTP and HTTP servers or resolving DNS hosts. CFNetwork is based, both physically and theoretically, on BSD sockets.</p><p>Just as CFNetwork relies on BSD sockets, there are a number of Cocoa classes that rely on CFNetwork. <code>NSURL</code> is one such class used for communicating with servers using standard Internet protocols. In addition, the Web Kit is a set of Cocoa classes to display web content in windows. Both of these classes are very high level and implement most of the details of the networking protocols by themselves. Thus, the structure of the software layers looks like the image in <span class="content_text">Figure 1-1</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001132-CH4-SW1" title="Figure 1-1CFNetwork and other software layers on Mac OS X"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>CFNetwork and other software layers on Mac OS X</p><img src = "../Art/layers.gif" alt = "CFNetwork and other software layers on Mac OS X" width="197" height="120"></div><br/>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30001132-CH4-DontLinkElementID_13">When to Use CFNetwork</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30001132-CH4-DontLinkElementID_14">CFNetwork Infrastructure</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30001132-CH4-DontLinkElementID_15">CFNetwork API Concepts</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001132-CH4-DontLinkElementID_13" title="When to Use CFNetwork"></a><h2>When to Use CFNetwork</h2><p>CFNetwork has a number of advantages over BSD sockets. It provides run-loop integration, so if your application is run loop based you can use network protocols without implementing threads. CFNetwork also contains a number of objects to help you use network protocols without having to implement the details yourself. For example, you can use FTP protocols without having to implement all of the details with the CFFTP API. If you understand the networking protocols and need the low-level control they provide but don't want to implement them yourself, then CFNetwork is probably the right choice.</p><p>There are a number of advantages of using CFNetwork instead of the Cocoa framework <code>NSURL</code>. CFNetwork is focused more on the network protocols, whereas <code>NSURL</code> is focused more on data access, such as transferring data over HTTP or FTP. Although <code>NSURL</code> does provide some configurability, CFNetwork provides a lot more. Additionally, <code>NSURL</code> requires that you use Objective-C. If that is not feasible, then you should use CFNetwork. For more information on the Foundation networking frameworks, read <em><a href="../../../../Cocoa/Conceptual/URLLoadingSystem/index.html#//apple_ref/doc/uid/10000165i" target="_top">URL Loading System</a></em>.</p><p>Now that you understand how CFNetwork interacts with the other Mac OS X networking APIs, you're ready to become familiar with the CFNetwork APIs along with two APIs that form the infrastructure for CFNetwork.</p><a name="//apple_ref/doc/uid/TP30001132-CH4-DontLinkElementID_14" title="CFNetwork Infrastructure"></a><h2>CFNetwork Infrastructure</h2><p>Before learning about the CFNetwork APIs, you must first understand the APIs which are the foundation for the majority of CFNetwork. CFNetwork relies on two APIs that are part of the Core Foundation framework, CFSocket and CFStream. Understanding these APIs is essential to using CFNetwork.</p><a name="//apple_ref/doc/uid/TP30001132-CH4-SW13" title="CFSocket API"></a><h3>CFSocket API</h3><p>Sockets are the most basic level of network communications. A socket acts in a similar manner to a telephone jack. It allows you to connect to another socket (either locally or over a network) and send data to that socket.</p><p>The most common socket abstraction is BSD sockets. CFSocket is an abstraction for BSD sockets. With very little overhead, CFSocket provides almost all the functionality of BSD sockets, and it integrates the socket into a run loop. CFSocket is not limited to stream-based sockets (for example, TCP), it can handle any type of socket.</p><p>You could create a CFSocket object from scratch using the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/Reference/reference.html#//apple_ref/doc/c_ref/CFSocketCreate" target="_top">CFSocketCreate</a></code> function, or from a BSD socket using the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/Reference/reference.html#//apple_ref/doc/c_ref/CFSocketCreateWithNative" target="_top">CFSocketCreateWithNative</a></code> function. Then, you could create a run-loop source using the function <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/Reference/reference.html#//apple_ref/doc/c_ref/CFSocketCreateRunLoopSource" target="_top">CFSocketCreateRunLoopSource</a></code> and add it to a run loop with the function <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRunLoopAddSource" target="_top">CFRunLoopAddSource</a></code>. This would allow your CFSocket callback function to be run whenever the CFSocket object receives a message.</p><p>Read <em><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/doc/uid/20001445" target="_top">CFSocket Reference</a></em> for more information about the CFSocket API.</p><a name="//apple_ref/doc/uid/TP30001132-CH4-SW4" title="CFStream API"></a><h3>CFStream API</h3><p>Read and write streams provide an easy way to exchange data to and from a variety of media in a device-independent way. You can create streams for data located in memory, in a file, or on a network (using sockets), and you can use streams without loading all of the data into memory at once.</p><p>A stream is a sequence of bytes transmitted serially over a communications path. Streams are one-way paths, so to communicate bidirectionally an input (read) stream and output (write) stream are necessary. Except for ones that are file based, streams are nonseekable; after stream data has been provided or consumed, it cannot be retrieved again from the stream.</p><p>CFStream is an API that provides an abstraction for these streams with two new CFType objects: CFReadStream and CFWriteStream. Both types of stream follow all of the usual Core Foundation API conventions. For more information about Core Foundation types, read <em><a href="../../../../CoreFoundation/Conceptual/CFDesignConcepts/index.html#//apple_ref/doc/uid/10000122i" target="_top">Core Foundation Design Concepts</a></em>.</p><p>CFStream is built on top of CFSocket and is the foundation for CFHTTP and CFFTP. As you can see in <span class="content_text">Figure 1-2</span>, even though CFStream is not officially part of CFNetwork, it is the basis for almost all of CFNetwork.</p><br/><div><a name="//apple_ref/doc/uid/TP30001132-CH4-SW3" title="Figure 1-2CFStream API structure"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>CFStream API structure</p><img src = "../Art/framework_layers.gif" alt = "CFStream API structure" width="425" height="183"></div><br/><p>You can use read and write streams in much the same way as you do UNIX file descriptors. First, you instantiate the stream by specifying the stream type (memory, file, or socket) and set any options. Next, you open the stream and read or write any number of times. While the stream exists, you can get information about the stream by asking for its properties. A stream property is any information about the stream, such as its source or destination, that is not part of the actual data being read or written. When you no longer need the stream, close and dispose of it.</p><p>CFStream functions that read or write a stream will suspend, or <em>block</em>, the current process until at least one byte of the data can be read or written. To avoid trying to read from or write to a stream when the stream would block, use the asynchronous version of the functions and schedule the stream on a run loop. Your callback function is called when it is possible to read and write without blocking.</p><p>In addition, CFStream has built-in support for the Secure Sockets Layer (SSL) protocol. You can set up a dictionary containing the stream's SSL information, such as the security level desired or self-signed certificates. Then pass it to your stream as the <code>kCFStreamPropertySSLSettings</code> property to make the stream an SSL stream.</p><p>It is not possible to construct a custom flavor of CFStream. For example, if you want to stream data from an object embedded within a custom database file, you can't do this by creating your own CFStream flavor. Instead, you implement a custom subclass of NSStream (using Objective-C). Since NSStream is toll free bridged to CFStream, your NSStream subclass can be used wherever a CFStream is required. For more information about the NSStream classes, read <em><a href="../../../../Cocoa/Conceptual/Streams/index.html#//apple_ref/doc/uid/10000188i" target="_top">Stream Programming Guide for Cocoa</a></em>.</p><p>The chapter <span class="content_text"><a href="../CFStreamTasks/CFStreamTasks.html#//apple_ref/doc/uid/TP30001132-CH6-SW1">“Working with Streams”</a></span> describes how to use read and write streams. </p><a name="//apple_ref/doc/uid/TP30001132-CH4-DontLinkElementID_15" title="CFNetwork API Concepts"></a><h2>CFNetwork API Concepts</h2><p>To understand the CFNetwork framework, you need to be familiar with the building blocks that compose it. The CFNetwork framework is broken up into separate APIs, each covering a specific network protocol. These APIs can be used in combination, or separately, depending on your application. Most of the programming conventions are common among the APIs, so it's important to comprehend each of them.</p><a name="//apple_ref/doc/uid/TP30001132-CH4-SW5" title="CFFTP API"></a><h3>CFFTP API</h3><p>Communicating with an FTP server is made easier with CFFTP. Using the CFFTP API, you can create FTP read streams (for downloading) and FTP write streams (for uploading). Using FTP read and write streams you can perform functions such as:</p><ul class="spaceabove"><li class="li"><p>Download a file from an FTP server</p></li><li class="li"><p>Upload a file to an FTP server</p></li><li class="li"><p>Download a directory listing from an FTP server</p></li><li class="li"><p>Create directories on an FTP server</p></li></ul><p>An FTP stream works like all other CFNetwork streams. For example, you can create an FTP read stream by calling the function <code>CFReadStreamCreateWithFTPURL</code> function. Then, you can call the function <code>CFReadStreamGetError</code> at any time to check the status of the stream.</p><p>By setting properties on FTP streams, you can adapt your stream for its particular application. For example, if the server that the stream is connecting to requires a user name and password, you need to set the appropriate properties so the stream can work properly. For more information about the different properties available to FTP streams read <span class="content_text"><a href="../CFFTPTasks/CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW2">“Setting up the Streams.”</a></span></p><p>A CFFTP stream can be used synchronously or asynchronously. To open the connection with the FTP server that was specified when the FTP read stream was created, call the function <code>CFReadStreamOpen</code>. To read from the stream, use the  <code>CFReadStreamRead</code> function and provide the read stream reference, <code>CFReadStreamRef</code>, that was returned when the FTP read stream was created. The <code>CFReadStreamRead</code> function fills a buffer with the output from the FTP server.</p><p>For more information on using CFFTP, see <span class="content_text"><a href="../CFFTPTasks/CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW1">“Working with FTP Servers.”</a></span></p><a name="//apple_ref/doc/uid/TP30001132-CH4-SW12" title="CFHTTP API"></a><h3>CFHTTP API</h3><p>To send and receive HTTP messages, use the CFHTTP API. Just as CFFTP is an abstraction for FTP protocols, CFHTTP is an abstraction for HTTP protocols.</p><p>Hypertext Transfer Protocol (HTTP) is a request/response protocol between a client and a server. The client creates a request message. This message is then serialized, a process that converts the message into a raw byte stream. Messages cannot be transmitted until they are serialized first. Then the request message is sent to the server. The request typically asks for a file, such as a webpage. The server responds, sending back a string followed by a message. This process is repeated as many times as is necessary.</p><p>To create an HTTP request message, you specify the following:</p><ul class="spaceabove"><li class="li"><p>The request method, which can be one of the request methods defined by the Hypertext Transfer Protocol, such as <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, and <code>CONNECT</code></p></li><li class="li"><p>The URL, such as <code>http://www.apple.com</code></p></li><li class="li"><p>The HTTP version, such as version 1.0 or 1.1</p></li><li class="li"><p>The message’s headers, by specifying the header name, such as <code>User-Agent</code>, and its value, such as <code>MyUserAgent</code></p></li><li class="li"><p>The message’s body</p></li></ul><p>After the message has been constructed, you serialize it. Following serialization, a request might look like this:</p><div class="codesample"><table><tr><td scope="row"><pre>    GET / HTTP/1.0\r\nUser-Agent: UserAgent\r\nContent-Length: 0\r\n\r\n<span></span></pre></td></tr></table></div><p>Deserialization is the opposite of serialization. With deserialization, a raw byte stream received from a client or server is restored to its native representation. CFNetwork provides all of the functions needed to get the message type (request or response), HTTP version, URL, headers, and body from an incoming, serialized message.</p><p>More examples of using CFHTTP are available in <span class="content_text"><a href="../CFHTTPTasks/CFHTTPTasks.html#//apple_ref/doc/uid/TP30001132-CH5-SW2">“Communicating with HTTP Servers.”</a></span></p><a name="//apple_ref/doc/uid/TP30001132-CH4-SW7" title="CFHTTPAuthentication API"></a><h3>CFHTTPAuthentication API</h3><p>If you send an HTTP request to an authentication server without credentials (or with incorrect credentials), the server returns an authorization challenge (more commonly known as a 401 or 407 response). The CFHTTPAuthentication API applies authentication credentials to challenged HTTP messages. CFHTTPAuthentication supports the following authentication schemes:</p><ul class="spaceabove"><li class="li"><p>Basic</p></li><li class="li"><p>Digest</p></li><li class="li"><p>NT LAN Manager (NTLM)</p></li><li class="li"><p>Simple and Protected GSS-API Negotiation Mechanism (SPNEGO)</p></li></ul><p>New in Mac OS X v10.4 is the ability to carry persistency across requests. In Mac OS X v10.3 each time a request was challenged, you had to start the authentication dialog from scratch. Now, you maintain a set of CFHTTPAuthentication objects for each server. When you receive a 401 or 407 response, you find the correct object and credentials for that server and apply them. CFNetwork uses the information stored in that object to process the request as efficiently as possible.</p><p>By carrying persistency across request, this new version of CFHTTPAuthentication provides much better performance. More information about how to use CFHTTPAuthentication is available in <span class="content_text"><a href="../CFHTTPAuthenticationTasks/CFHTTPAuthenticationTasks.html#//apple_ref/doc/uid/TP30001132-CH8-SW1">“Communicating with Authenticating HTTP Servers.”</a></span></p><a name="//apple_ref/doc/uid/TP30001132-CH4-SW11" title="CFHost API"></a><h3>CFHost API</h3><p>You use the CFHost API to acquire host information, including names, addresses, and reachability information. The process of acquiring information about a host is known as <em>resolution</em>.</p><p>CFHost is used just like CFStream: </p><ul class="spaceabove"><li class="li"><p>Create a CFHost object.</p></li><li class="li"><p>Start resolving the CFHost object.</p></li><li class="li"><p>Retrieve either the addresses, host names, or reachability information.</p></li><li class="li"><p>Destroy the CFHost object when you are done with it.</p></li></ul><p>Like all of CFNetwork, CFHost is IPv4 and IPv6 compatible. Using CFHost, you could write code that handles IPv4 and IPv6 completely transparently.</p><p>CFHost is integrated closely with the rest of CFNetwork. For example, there is a CFStream function called <code><a href="../../../../CoreFoundation/Reference/CFSocketStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFStreamCreatePairWithSocketToCFHost" target="_top">CFStreamCreatePairWithSocketToCFHost</a></code> that will create a CFStream object directly from a CFHost object. For more information about the CFHost object functions, see <em><a href="../../../../CoreFoundation/Reference/CFHostRef/index.html#//apple_ref/doc/uid/TP40003333" target="_top">CFHost Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP30001132-CH4-SW6" title="CFNetServices API"></a><h3>CFNetServices API</h3><p>If you want your application to use Bonjour to register a service or to discover services, use the CFNetServices API. Bonjour is Apple's implementation of zero-configuration networking (ZEROCONF), which allows you to publish, discover, and resolve network services.</p><p>To implement Bonjour the CFNetServices API defines three object types: CFNetService, CFNetServiceBrowser, and CFNetServiceMonitor. A CFNetService object represents a single network service, such as a printer or a file server. It contains all the information needed for another computer to resolve that server, such as name, type, domain and port number. A CFNetServiceBrowser is an object used to discover domains and network services within domains. And a CFNetServiceMonitor object is used to monitor a CFNetService object for changes, such as a status message in iChat.</p><p>For a full description of Bonjour, see <em><a href="../../../../Cocoa/Conceptual/NetServices/index.html#//apple_ref/doc/uid/10000119i" target="_top">Bonjour Overview</a></em>. For more information about using CFNetServices and implementing Bonjour, see <em><a href="../../NSNetServiceProgGuide/index.html#//apple_ref/doc/uid/TP40002736" target="_top">NSNetServices and CFNetServices Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP30001132-CH4-SW8" title="CFNetDiagnostics API"></a><h3>CFNetDiagnostics API</h3><p>Applications that connect to networks depend on a stable connection. If the network goes down, this causes problems with the application. By adopting the CFNetDiagnostics API, the user can self-diagnose network issues such as:</p><ul class="spaceabove"><li class="li"><p>Physical connection failures (for example, a cable is unplugged)</p></li><li class="li"><p>Network failures (for example, DNS or DHCP server no longer responds)</p></li><li class="li"><p>Configuration failures (for example, the proxy configuration is incorrect)</p></li></ul><p>Once the network failure has been diagnosed, CFNetDiagnostics guides the user to fix the problem. You may have seen CFNetDiagnostics in action if Safari failed to connect to a website. The CFNetDiagnostics assistant can be seen in <span class="content_text">Figure 1-3</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001132-CH4-SW9" title="Figure 1-3Network diagnostics assistant"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Network diagnostics assistant</p><img src = "../Art/net_diagnostics.jpg" alt = "CFNetDiagnostics Assistant" ></div><br/><p>By providing CFNetDiagnostics with the context of the network failure, you can call the <code><a href="../../../../CoreFoundation/Reference/CFNetDiagnosticsRef/Reference/reference.html#//apple_ref/doc/c_ref/CFNetDiagnosticDiagnoseProblemInteractively" target="_top">CFNetDiagnosticDiagnoseProblemInteractively</a></code> function to lead the user through the prompts to find a solution. Additionally, you can use CFNetDiagnostics to query for connectivity status and provide uniform error messages to the user.</p><p>To see how to integrate CFNetDiagnotics into your application read <span class="content_text"><a href="../UsingNetworkDiagnostics/UsingNetworkDiagnostics.html#//apple_ref/doc/uid/TP30001132-CH7-SW1">“Using Network Diagnostics.”</a></span> CFNetDiagnostics is a new API in Mac OS X v10.4.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CFStreamTasks/CFStreamTasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Networking/Conceptual/CFNetwork/Concepts/Concepts.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Networking/Conceptual/CFNetwork/Concepts/Concepts.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Networking/Conceptual/CFNetwork/Concepts/Concepts.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>