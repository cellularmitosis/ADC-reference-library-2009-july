<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Memory Management Programming Guide for Cocoa: Object Ownership and Disposal</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Object Ownership and Disposal"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20000043" title="Object Ownership and Disposal"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ObjectiveCLanguage-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000856" target="_top">Objective-C Language</a> &gt; <a href="../index.html" target="_top">Memory Management Programming Guide for Cocoa</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../MemoryMgmt.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="mmPractical.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20000043-BEHDEDDB" title="Object Ownership and Disposal"></a><hr /><H1>Object Ownership and Disposal</H1><p>This document discusses the policy for ownership of Objective-C objects and how and when to dispose of objects. </p><p>To fully understand how the object ownership policy is implemented in Cocoa, you must also read <span class="content_text"><a href="mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI">“Autorelease Pools.”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-SW1">Object Ownership Policy</a>
				
			<br/>
			
        
			
			
				<a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1000580">Delayed Release</a>
				
			<br/>
			
        
			
			
				<a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1000698">Taking Ownership of Objects</a>
				
			<br/>
			
        
			
			
				<a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-SW4">Deallocating an Object</a>
				
			<br/>
			
        
			
			
				<a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-SW6">Resource Management</a>
				
			<br/>
			
        
			
			
				<a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1001064">Summary</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20000043-SW1" title="Object Ownership Policy"></a><h2>Object Ownership Policy</h2><p>In an Objective-C program, objects are constantly creating and disposing of other objects. It is important to dispose of objects when they are no longer needed to ensure that your application does not use more memory than necessary. Much of the time an object creates things for private use and can dispose of them as needed. However, when an object passes something to another object through a method invocation, the lines of ownership—and responsibility for disposal—blur. For example, suppose you have a Thingamajig object that contains a number of Sprocket objects, which other objects access using the following method:</p><div class="codesample"><table><tr><td scope="row"><pre>– (NSArray *)sprockets<span></span></pre></td></tr></table></div><p>This declaration says nothing about who should dispose of the returned array. It is reasonable to suggest, however, that if your Thingamajig object returns an instance variable, it is responsible for the array. If on the other hand you create a new Thingamajig object, then you are responsible for disposing of the new object. This, though, introduces a possible source of confusion. “Disposal” tends to imply “get rid of” or “deallocate”. </p><p>As noted earlier, it is possible (in fact common) for one object to create another object and then pass it to another. It is important not to get rid of the new object until the third party has finished using it. It is better, therefore, to think of memory management in terms of object ownership, where any object may have one or more owner. So long as an object has at least one owner, it continues to exist. If an object has no owners, the runtime system disposes of it (deallocates it) automatically.</p><p>To make sure it is clear when you own an object and when you do not, and what responsibilities you have as an owner, Cocoa sets the following policy:</p><ul class="ul"><li class="li"><p>You own any object you create.</p><p>You “create” an object using a method whose name begins with “alloc” or “new” or contains “copy” (for example, <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/alloc" target="_top">alloc</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSObjectController_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObjectController/newObject" target="_top">newObject</a></code>, or <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/mutableCopy" target="_top">mutableCopy</a></code>).</p></li><li class="li"><p>If you own an object, you are responsible for relinquishing ownership when you have finished with it.</p><p>You relinquish ownership of an object by sending it a <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">release</a></code> message or an <code>autorelease</code> message (autorelease is discussed in more detail in <span class="content_text"><a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1000580">“Delayed Release”</a></span>). In Cocoa terminology, relinquishing ownership of an object is typically referred to as “releasing” an object. </p></li><li class="li"><p>If you do not own an object, you must not release it.</p></li></ul><p>This policy applies both to GUI-based Cocoa applications and to command-line Foundation tools.  </p><p>Consider the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>Thingamajig *thingamajig = [[Thingamajig alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *sprockets = [thingamajig sprockets];<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>[thingamajig release];<span></span></pre></td></tr></table></div><p>This example properly adheres to the policy. You create the Thingamajig object using the <code>alloc</code> method, so you subsequently send it a <code>release</code> message. You obtain the sprockets array from the Thingamajig object—you do not “create” the array—so you do not send it a <code>release</code> message.</p><a name="//apple_ref/doc/uid/20000043-SW2" title="Creating Objects Using Convenience Methods"></a><h3>Creating Objects Using Convenience Methods</h3><p>Many classes provide methods of the form <code>+className...</code> that you can use to obtain a new instance of the class. Often referred to as “convenience constructors”, these methods create a new instance of the class, initialize it, and return it for you to use. Although you might think you are responsible for releasing objects created in this manner, that is not the case according to the policy Cocoa set—the method name does not contain "alloc" or "copy", or begin with "new". Because <em>the class</em> creates the new object, <em>it</em> is responsible for disposing of the new object. As an illustration, the following code example is <em>wrong</em>:</p><div class="codesample"><table><tr><td scope="row"><pre>Thingamajig *thingamajig = [Thingamajig thingamajig];<span></span></pre></td></tr><tr><td scope="row"><pre>[thingamajig release]; // wrong<span></span></pre></td></tr></table></div><p>Although if you try this you will not see an error as soon as the <code>release</code> message is sent, it will cause an exception later (for a discussion of what constitutes “later”, see <span class="content_text"><a href="mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI">“Autorelease Pools”</a></span>).</p><p>This does, though, raise the issue of how the <code>Thingamajig</code> class can abide by the ownership policy. It is responsible for releasing the new object, but it must not do so before the recipient has had a chance to claim ownership. To illustrate, consider two possible implementations of the <code>thingamajig</code> method.</p><ol class="ol"><li class="li"><p>This is <em>wrong</em> because after the new Thingamajig object is returned to the caller the class loses its reference to the new object so cannot send it a <code>release</code> message to relinquish ownership:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (Thingamajig *)thingamajig {<span></span></pre></td></tr><tr><td scope="row"><pre>    id newThingamajig = [[Thingamajig alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    return newThingamajig;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>This is also <em>wrong</em> because although the class properly relinquishes ownership of the new object, after the <code>release</code> message is sent the new Thingamajig object has no owner so is immediately disposed of by the system:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (Thingamajig *)thingamajig {<span></span></pre></td></tr><tr><td scope="row"><pre>    id newThingamajig = [[Thingamajig alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    [newThingamajig release];<span></span></pre></td></tr><tr><td scope="row"><pre>    return newThingamajig; // newThingamajig is invalid here<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li></ol><p>The Thingamajig class needs a way to mark an object for relinquish ownership at a later time, after the recipient has had a chance to use it. Cocoa provides a mechanism to do this, called “autoreleasing”, discussed in <span class="content_text"><a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1000580">“Delayed Release.”</a></span></p><a name="//apple_ref/doc/uid/20000043-SW3" title="Objects Returned by Reference"></a><h3>Objects Returned by Reference</h3><p>Some methods in Cocoa specify that an object is returned by reference. There are several examples that use an <code>NSError</code> object that contains information about an error if one occurs, such as: </p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSDocument_Class/Reference/Reference.html#//apple_ref/occ/instm/NSDocument/initWithContentsOfURL:ofType:error:" target="_top">initWithContentsOfURL:ofType:error:</a></code> (<code>NSDocument</code>)</p></li><li class="li"><p><code><a href="../../../Reference/Foundation/Classes/NSData_Class/Reference/Reference.html#//apple_ref/occ/instm/NSData/initWithContentsOfURL:options:error:" target="_top">initWithContentsOfURL:options:error:</a></code> (<code>NSData</code>)</p></li><li class="li"><p><code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/instm/NSString/initWithContentsOfFile:encoding:error:" target="_top">initWithContentsOfFile:encoding:error:</a></code> (<code>NSString</code>)</p></li></ul><p>In these cases, the same rules apply as have already been described. When you invoke any of these methods, you do not create the <code>NSError</code> object so you do not own it—there is therefore no need to release it. </p><div class="codesample"><table><tr><td scope="row"><pre>NSString *fileName = ... ;<span></span></pre></td></tr><tr><td scope="row"><pre>NSError *error;<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *string = [[NSString alloc] initWithContentsOfFile:fileName<span></span></pre></td></tr><tr><td scope="row"><pre>                        encoding:NSUTF8StringEncoding error:&amp;error];<span></span></pre></td></tr><tr><td scope="row"><pre>if (string == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // deal with error ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>[string release];<span></span></pre></td></tr></table></div><p>If for any reason ownership of returned object does not follow the basic rules, this is stated explicitly in the documentation for the method (see for example, <code><a href="../../../Reference/Foundation/Classes/NSPropertyListSerialization_Class/Reference/Reference.html#//apple_ref/occ/clm/NSPropertyListSerialization/dataFromPropertyList:format:errorDescription:" target="_top">dataFromPropertyList:format:errorDescription:</a></code>).</p><a name="//apple_ref/doc/uid/20000043-1000580" title="Delayed Release"></a><h2>Delayed Release</h2><p>The <code>autorelease</code> method, defined by <code>NSObject</code>, marks the receiver for later release. By autoreleasing an object—that is, by sending it an <code>autorelease</code> message—you declare that you don't want to own the object beyond the scope in which you sent <code>autorelease</code>. The scope is defined by the current autorelease pool—see <span class="content_text"><a href="mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI">“Autorelease Pools.”</a></span></p><p>The <code>sprockets</code> method mentioned above could be implemented in this way:</p><div class="codesample"><table><tr><td scope="row"><pre>– (NSArray *)sprockets {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray *array;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    array = [[NSArray alloc] initWithObjects:mainSprocket,<span></span></pre></td></tr><tr><td scope="row"><pre>                               auxiliarySprocket, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    return [array autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When another method gets the array of Sprocket objects, that method can assume that the array will be disposed of when it is no longer needed, but can still be safely used anywhere within its scope (see <span class="content_text"><a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1000922">“Validity of Shared Objects”</a></span>). It can even return the array to its invoker, since the application object defines the bottom of the call stack for your code. The <code>autorelease</code> method thus allows every object to use other objects without worrying about disposing of them.</p><p>Just as it is an error to release an object after it is already been deallocated, it’s an error to send so many <code>autorelease</code> messages that the object would later be released after it had already been deallocated. You should send <code>release</code> or <code>autorelease</code> to an object only as many times as are allowed by its creation (one) plus the number of <code>retain</code> messages you have sent it (<code>retain</code> messages are described below).</p><a name="//apple_ref/doc/uid/20000043-1000698" title="Taking Ownership of Objects"></a><h2>Taking Ownership of Objects</h2><p>There are times when you don’t want a received object to be disposed of; for example, you may need to cache the object in an instance variable. In this case, only you know when the object is no longer needed, so you need the power to ensure that the object is not disposed of while you are still using it. You do this with a <code>retain</code> message. A <code>retain</code> message is the opposite of a <code>release</code> of <code>autorelease</code> message. By retaining an object, (provided that everyone else plays by the same rules) you ensure that it won’t be deallocated until you are done with it. For example, if your object allows its main Sprocket to be set, you might want to retain that Sprocket like this:</p><div class="codesample"><table><tr><td scope="row"><pre>– (void)setMainSprocket:(Sprocket *)newSprocket {<span></span></pre></td></tr><tr><td scope="row"><pre>    [mainSprocket autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>    mainSprocket = [newSprocket retain]; /* Claim the new Sprocket. */<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Now, <code>setMainSprocket:</code> might get invoked with a Sprocket that the invoker intends to keep around, which means your object would be sharing the Sprocket with that other object. If that object changes the Sprocket, your object’s main Sprocket changes. You might want that, but if your Thingamajig needs to have its own Sprocket the method should make a private copy: </p><div class="codesample"><table><tr><td scope="row"><pre>– (void)setMainSprocket:(Sprocket *)newSprocket {<span></span></pre></td></tr><tr><td scope="row"><pre>    [mainSprocket autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>    mainSprocket = [newSprocket copy]; /* Get a private copy. */<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that both of these methods autorelease the original main sprocket, so they don’t need to check that the original main sprocket and the new one are the same. If they simply released the original when it was the same as the new one, that sprocket would be released and possibly deallocated, causing an error as soon as it was retained or copied. The following code solves that problem:</p><div class="codesample"><table><tr><td scope="row"><pre>– (void)setMainSprocket:(Sprocket *)newSprocket {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (mainSprocket != newSprocket) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [mainSprocket release];<span></span></pre></td></tr><tr><td scope="row"><pre>        mainSprocket = [newSprocket retain];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/20000043-1000922" title="Validity of Shared Objects"></a><a name="//apple_ref/doc/uid/20000043-1000922-BABBFBGJ" title="Validity of Shared Objects"></a><h3>Validity of Shared Objects</h3><p>Cocoa’s ownership policy specifies that received objects should remain valid throughout the scope of the calling method. It should also be possible to return a received object from the current scope without fear of it being released. It should not matter to your application that the getter method of an object returns a cached instance variable or a computed value. What matters is that the object remains valid for the time you need it.</p><p>There are exceptions to this rule. For example, collection classes do not attempt to extend the lifetime of objects placed inside them. Removing an object from a mutable array could invalidate any copies of the object previously acquired, as in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>value = [array objectAtIndex:n];<span></span></pre></td></tr><tr><td scope="row"><pre>[array removeObjectAtIndex:n];<span></span></pre></td></tr><tr><td scope="row"><pre>// value could now be invalid.<span></span></pre></td></tr></table></div><p>Another problem situation is when an object is deallocated after a call to one of its getter methods:</p><div class="codesample"><table><tr><td scope="row"><pre>sprocket = [thingamajig mainSprocket];<span></span></pre></td></tr><tr><td scope="row"><pre>[thingamajig release];<span></span></pre></td></tr><tr><td scope="row"><pre>// sprocket could now be invalid.<span></span></pre></td></tr></table></div><p>To protect against situations like this, you could retain <code>sprocket</code> upon receiving it and release it when you have finished with it. Because it may not always be obvious when a caller should retain an object in this manner, the objects themselves should strive to return results that are valid in the current calling scope. In many cases, understanding how accessor methods are implemented, and implementing accessor methods appropriately, will resolve any confusion—see <span class="content_text"><a href="mmAccessorMethods.html#//apple_ref/doc/uid/TP40003539-SW1">“Accessor Methods.”</a></span></p><a name="//apple_ref/doc/uid/20000043-1000810" title="Retain Cycles "></a><h3>Retain Cycles </h3><p>In some situations, two objects may have cyclical references; that is, each object contains an instance variable that refers to the other object. For example, consider a text program with the object relationships shown in <span class="content_text"><a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1000866-BBCJJJGB">Figure 1</a></span>. The Document object creates a Page object for each page in the document. Each Page object has an instance variable that keeps track of which document it is in. If the Document object retained the Page object and the Page object retained the Document object, neither object would ever be released. The Document’s reference count cannot become 0 until the Page object is released, and the Page object won’t be released until the Document object is deallocated.</p><br/><div><a name="//apple_ref/doc/uid/20000043-1000866-BBCJJJGB" title="Figure 1An illustration of retain cycles"></a><p><a name="//apple_ref/doc/uid/20000043-1000866" title="Figure 1An illustration of retain cycles"></a><strong>Figure 1&nbsp;&nbsp;</strong>An illustration of retain cycles</p><img src = "../Art/retaincycles.gif" alt = "An illustration of retain cycles" width="163" height="329"></div><br/><p>The solution to the problem of retain cycles is that the “parent” object should retain its “children,” but that the children should not retain their parents. So, in <span class="content_text"><a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1000866-BBCJJJGB">Figure 1</a></span> the document object retains its page objects but the page object does not retain the document object. The child’s reference to its parent is an example of a weak reference, which is described more fully in <span class="content_text"><a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1044135">“Weak References to Objects.”</a></span></p><a name="//apple_ref/doc/uid/20000043-1044135" title="Weak References to Objects"></a><a name="//apple_ref/doc/uid/20000043-1044135-BCICCFAE" title="Weak References to Objects"></a><h3>Weak References to Objects</h3><p>Retaining an object creates a “strong” reference to that object. An object cannot be deallocated until all of its strong references are released. An object’s lifetime is thereby determined by the owners of its strong references. In some cases, this behavior may not be desired. You may want to have a reference to an object without preventing the object from deallocating itself. For these cases, you can obtain a “weak” reference. A weak reference is created by storing a pointer to an object without retaining the object.</p><p>Weak references are essential in cases where a circular reference would otherwise be set up. For example, if Object A and Object B communicate with each other, each needs a reference to the other. If each retains the other, neither object ever gets deallocated until the connection is broken, but the connection is not broken until one of the objects is deallocated. Catch-22. To break the circle, one object takes a subordinate role and obtains a weak reference to the other. As a concrete example, in a view hierarchy, a parent view owns, and hence retains, its child views, but a child view does not own its parent; the child still needs to know who its parent is, so it keeps a weak reference to its parent.</p><p>Additional cases of weak references in Cocoa include, but are not restricted to, table data sources, outline view items, notification observers, and miscellaneous targets and delegates.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20000043-DontLinkElementID_3" title="Important:"></a><p><strong>Important:</strong>&nbsp;In Cocoa, references to table data sources, outline view items, notification observers, and delegates are all considered weak (for example, an <code>NSTableView</code> object does not retain its data source and the <code>NSApplication</code> object does not retain its delegate). The documentation only describes exceptions to this convention. </p><p></p></div><p>You need to be careful about sending messages to objects for which you only hold a weak reference. If you send a message to an object after it has been deallocated, your application will crash. You must have well-defined conditions for when the object is valid. In most cases, the weak-referenced object is aware of the other object’s weak reference to it, as is the case for circular references, and is responsible for notifying the other object when it deallocates. For example, when you register an object with a notification center, the notification center stores a weak reference to the object and sends messages to it when the appropriate notifications are posted. When the object is deallocated, you need to unregister it with the notification center to prevent the notification center from sending any further messages to the object, which no longer exists. Likewise, when a delegate object is deallocated, you need to remove the delegate link by sending a <code>setDelegate:</code> message with a <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/nil" target="_top">nil</a></code> argument to the other object. These messages are normally sent from the object’s <code>dealloc</code> method.</p><a name="//apple_ref/doc/uid/20000043-SW5" title="Retain Count"></a><h3>Retain Count</h3><p>Typically there should be no reason to explicitly ask an object what its retain count is (see <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/retainCount" target="_top">retainCount</a></code>). The result is often misleading, as you may be unaware of what framework objects have retained an object in which you are interested. In debugging memory management issues, you should be concerned only with ensuring that your code adheres to the ownership rules. </p><a name="//apple_ref/doc/uid/20000043-SW4" title="Deallocating an Object"></a><h2>Deallocating an Object</h2><p>Cocoa implements its ownership policy through a mechanism called “reference counting” or “retain counting.” When you create an object, it has a retain count of <code>1</code>. When you send an object a <code>retain</code> message, its retain count is increased by <code>1</code>. When you send an object a <code>release</code> message, its retain count is decreased by <code>1</code> (<code>autorelease</code> causes the retain count to be decremented in the future). </p><p>When its retain count drops to <code>0</code>, an object’s memory is reclaimed—in Cocoa terminology it is “freed” or “deallocated.” When an object is deallocated, its <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/dealloc" target="_top">dealloc</a></code> method is invoked automatically. The role of the <code>dealloc</code> method is to free the object's own memory, and dispose of any resources it holds, including its object instance variables.</p><p>If your class has object instance variables, you must implement a <code>dealloc</code> method that releases them, and then invokes super's implementation. For example, if the Thingamajig class had <code>name</code> and <code>sprockets</code> instance variables, you would implement its <code>dealloc</code> method as follows: </p><div class="codesample"><table><tr><td scope="row"><pre>- (void)dealloc<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [sprockets release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [name release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>You should never invoke another object’s <code>dealloc</code> method directly.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20000043-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;When an application terminates, objects may not be sent a <code>dealloc</code> message since the process’s memory is automatically cleared on exit—it is more efficient simply to allow the operating system to clean up resources than to invoke all the memory management methods. This has implications for how you implement a <code>dealloc</code> method—see <span class="content_text"><a href="mmObjectOwnership.html#//apple_ref/doc/uid/20000043-SW6">“Resource Management.”</a></span></p><p></p></div><a name="//apple_ref/doc/uid/20000043-SW6" title="Resource Management"></a><h2>Resource Management</h2><p>You should typically not manage scarce resources such as file descriptors, network connections, and buffers/caches in a <code>dealloc</code> method. In particular, you should not design classes such that you are assuming that <code>dealloc</code> will be invoked when you think it will be invoked. Invocation of <code>dealloc</code> might be delayed or sidestepped, either because of a bug or because of application tear-down.</p><p>Instead, if you have a class whose instances manage scarce resources, you should design your application such that you know when you no longer need the resources and can then tell the instance to “clean up” at that point. You would typically then release the instance and <code>dealloc</code> would follow, but you will not suffer additional problems if it does not.</p><p>Some of the problems that arise if you try to piggy-back resource management on top of <code>dealloc</code> include:</p><ol class="ol"><li class="li"><p>Order dependencies on object graph tear-down.</p><p>The object graph tear-down mechanism is inherently non-ordered. Although you might typically expect—and get—a particular order, you are introducing fragility. If an object falls in an autorelease pool unexpectedly, the tear-down order may change, which may lead to unexpected results.</p></li><li class="li"><p>Non-reclamation of scarce resources.</p><p>Memory leaks are of course bugs that should be fixed, but they are generally not immediately fatal. If scarce resources are not released when you expect them to be released, however, this can lead to much more serious problems. If your application runs out of file descriptors, for example, the user may not be able to save data.</p></li><li class="li"><p>Clean-up logic being executed on the wrong thread.</p><p>If an object falls into an autorelease pool at an unexpected time, it will be deallocated on whatever thread’s pool it happens to be in. This can easily be fatal for certain kinds of resource that should only ever be touched from one thread.</p></li></ol><a name="//apple_ref/doc/uid/20000043-1001064" title="Summary"></a><h2>Summary</h2><p>Now that the concepts behind the Cocoa’s object ownership policy have been introduced, they can be expressed as a short list of rules—see <span class="content_text"><a href="mmRules.html#//apple_ref/doc/uid/20000994-BAJHFBGH">“Memory Management Rules.”</a></span></p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../MemoryMgmt.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="mmPractical.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmObjectOwnership.html%3Fid%3D10000011i-3.8&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmObjectOwnership.html%3Fid%3D10000011i-3.8&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmObjectOwnership.html%3Fid%3D10000011i-3.8&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
