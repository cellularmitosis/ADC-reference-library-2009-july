/*	File:			PGPUAMmsgFormat.h	Description:		Written by:	Vinnie Moscaritolo	Copyright:	© 1998 by Apple Computer, Inc., all rights reserved.	Change History (most recent first):	You may incorporate this sample code into your applications without	restriction, though the sample code has been provided "AS IS" and the	responsibility for its operation is 100% yours.  However, what you are	not permitted to do is to redistribute the source as "DSC Sample Code"	after having made changes. If you're going to re-distribute the source,	we require that you make it clear in the source that the code was	descended from Apple Sample Code, but that you've made changes.*///------------------------------------------------------------------------------------#pragma mark Includes//------------------------------------------------------------------------------------#include <String.h>#include "AFPPackets.h"#include "ClientUAM.h" #include "machdepnetmacros.h"#include "PGPUAMmsgFormat.h"#include "PGPUAMclientProtocol.h"// ---------------------------------------------------------------------------#pragma mark Local Prototypes// ---------------------------------------------------------------------------static void*  FormatLoginContCmdHdr	(const void	*outbuf	);#pragma mark -#pragma mark PGPUAM Login Command // ---------------------------------------------------------------------------void*  FormatLoginCmd( const void       *outbuf, 							StringPtr 	serverVersion, 							StringPtr 	uamName, 							StringPtr 	userName,							StringPtr	challengeString	)// ---------------------------------------------------------------------------{	UByte1 *msgP  = (UByte1*) outbuf;	MOVE_TO_NET_1		(msgP,	 kFPLogin	)	PLstrcpy((StringPtr) msgP,	serverVersion);  		msgP += serverVersion[0]+1; 	PLstrcpy((StringPtr) msgP, 	uamName);				msgP += uamName[0]+1;	PLstrcpy((StringPtr) msgP, 	userName);				msgP += userName[0]+1;	PLstrcpy((StringPtr) msgP, 	challengeString);		msgP += challengeString[0]+1;	 	return (msgP);}// ---------------------------------------------------------------------------void*  ParseLoginCmd(const void *inbuf,  UInt32 *length, PUAM_LOGIN_CMD *vmsgP)// ---------------------------------------------------------------------------{	UByte1    *msgP  = (UByte1*)inbuf;	vmsgP->userName = msgP; 	SKIP_FROM_NET		(msgP,	 vmsgP->userName[0] + 1	);	vmsgP->challengeString = msgP; 	SKIP_FROM_NET		(msgP,	 vmsgP->challengeString[0] + 1	);	 	*length -= (UByte1*)inbuf - msgP; 	return (msgP);}// ---------------------------------------------------------------------------void*  FormatChallengeStr( const void   *outbuf, 							UInt8	  	*challengeBuffer,							UInt32	  	challengeBufferSize )// ---------------------------------------------------------------------------{	UByte1 *msgP  = (UByte1*) outbuf;	MOVE_TO_NET_1		(msgP,	challengeBufferSize	)	if(challengeBufferSize > 0)		{		MOVE_TO_NET_BLOCK	(msgP,	challengeBuffer, challengeBufferSize);		}	return (msgP);}#pragma mark - #pragma mark PGPUAM Login Response// ---------------------------------------------------------------------------void*  FormatLoginResp( const 	void       *outbuf, 								StringPtr	counterChallengePString,  								StringPtr	fingerPrintPString  )// ---------------------------------------------------------------------------{	UByte1 *msgP  = (UByte1*) outbuf;	PLstrcpy((StringPtr) msgP, 	counterChallengePString);	msgP += counterChallengePString[0]+1;	PLstrcpy((StringPtr) msgP, 	fingerPrintPString);		msgP += fingerPrintPString[0]+1;  	return (msgP);}// ---------------------------------------------------------------------------void*  ParseLoginResp(const void *inbuf,  UInt32 *length, PUAM_LOGIN_RESP *vmsgP)// ---------------------------------------------------------------------------{	UByte1    *msgP  = (UByte1*)inbuf;	vmsgP->CounterChallengePString = msgP; 	SKIP_FROM_NET		(msgP,	 vmsgP->CounterChallengePString[0] + 1	);	vmsgP->FingerPrintPString = msgP; 	SKIP_FROM_NET		(msgP,	 vmsgP->FingerPrintPString[0] + 1	);	 	*length -= (UByte1*)inbuf - msgP; 	return (msgP);}#pragma mark -#pragma mark PGPUAM Login Continue Command Header// ---------------------------------------------------------------------------void*  FormatLoginContCmdHdr( const 	void 	*outbuf)// ---------------------------------------------------------------------------{	UByte1 *msgP  = (UByte1*) outbuf;	MOVE_TO_NET_1		(msgP,	 kFPLoginCont	)	MOVE_TO_NET_1		(msgP,	 0	)// Alternate UAMs require that the client use a ID number of 1 when // performing a LoginContinue Packet, this is a hardcoded value..// I suspect this is a server bug!! 	SWAP_TO_NET_2		(msgP,	 1	)// this is a bug for now.. the sever requires at least 8 bytes of foo.// 	SKIP_TO_NET_8		(msgP); 	 	return (msgP);}// ---------------------------------------------------------------------------void*  FormatLoginContinueCmd( const 	void       *outbuf, 								StringPtr	counterChallengePString )// ---------------------------------------------------------------------------{	UByte1 *msgP  = (UByte1*) outbuf;	msgP = (UInt8*) FormatLoginContCmdHdr(msgP); 	PLstrcpy((StringPtr) msgP, 	counterChallengePString);	msgP += counterChallengePString[0]+1;  	return (msgP);}// ---------------------------------------------------------------------------void*  ParseLoginContinueCmd(const void *inbuf,  UInt32 *length, PUAM_LOGIN_CONT_CMD *vmsgP)// ---------------------------------------------------------------------------{	UByte1    *msgP  = (UByte1*)inbuf;	vmsgP->SigPString = msgP; 	SKIP_FROM_NET		(msgP,	 vmsgP->SigPString[0] + 1	);  	*length -= (UByte1*)inbuf - msgP; 	return (msgP);} 