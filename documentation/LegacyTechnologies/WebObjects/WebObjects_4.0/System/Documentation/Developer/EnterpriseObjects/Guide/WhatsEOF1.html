<html><head><title>What Is Enterprise Objects Framework?</title></head>
<body bgcolor="#ffffff">

<!--start of banner -->
<!--#include virtual="/includes/framesetheader" -->
<!-- end of banner -->

<!--start of path -->
<font face="Geneva,Helvetica,Arial" size="1">
<b>PATH<spacer type="horizontal" size="5">&nbsp;</b>
 <a href="../../../../../webobjects.html" target="_top">WebObjects 4.0 Documentation</a> <b>&gt;</b>
 <a href="GuideTOC.html" target="_top">EOF Developer's Guide</a>
</font>
<br><br>
<!--end of path -->

 
<a href="WhatsEOF.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="WhatsEOF.html"><IMG SRC="ArrowLeft.gif">Previous Section</a>
 
<a name="5848">
<h1> The Enterprise Objects Framework Difference	</h1>
</a><a name="6022">
Today's business applications must embody complex rules of the business, access heterogeneous corporate data in database systems from multiple vendors, and offer different front ends to meet the needs of users in all different parts of the business. This is a tall order to fill, but Enterprise Objects Framework meets all these needs. It provides database independence, transparently maps custom business objects to database tables, and binds business objects to user interfaces.<p>
</a><a name="6240">
<h2> Where Does Business Logic Go?</h2>
</a><a name="6242">
The biggest difference between Enterprise Objects Framework and other solutions is where you put business logic. One approach is to implement business rules in the user interface, as you do with 4GL tools. Problems with this approach include:<p>
</a><ul><a name="5963">
<p><li><em>It offers limited reuse.</em> You have to code your business logic into each application that accesses your database. In fact, within an application, you have to code your business logic into each screen. Consequently, you wind up duplicating your code.
</a><a name="5959">
<p><li><em>It's not maintainable.</em> Since you have to duplicate your business logic, even small modifications to your rules are difficult to implement. Finding and fixing every affected screen in every affected application is slow and error prone. Modifications to your database schema are equally problematic.
</a><a name="10230">
<p><li><em>Different user interfaces require different implementations.</em> For example, if you have a client/server application that you want to put on the web, you have to rewrite the application and maintain both versions.
</a><a name="6009">
<p><li><em>It provides poor data integrity.</em> You have to rely on all application developers to implement the business rules correctly. If any screen of any application has an error, the data in your database can be corrupted, impacting all applications.
</a><a name="5952">
<p><li><em>It doesn't scale well.</em> To improve your application's performance, you have to provide your users with faster systems. Contrast this with a solution in which you can move some computation-intensive processing to fast server machines.
</a></ul><a name="5966">
Another approach is to implement your business rules in the database-with stored procedures, rules, constraints, and triggers, for example. This approach also has problems:<p>
</a><ul><a name="5970">
<p><li><em>It offers limited interactivity.</em> To provide immediate feedback to a user, you have to make a round trip to the database every time the user performs an action, which can be very slow and inefficient. On the other hand, you can batch up changes, but then the user doesn't receive immediate feedback.
</a><a name="5971">
<p><li><em>No back-end portability.</em> Database vendors all have different ways to implement logic. If you have to support more than one database, you'll have to implement the logic multiple times, resulting in more maintenance problems.
</a><a name="6080">
<p><li><em>SQL is a poor development language.</em>
</a></ul><a name="6134">
A third approach-the one that Enterprise Objects Framework takes-is to put business rules in business objects, called <em>enterprise objects</em>. By applying good object-oriented design principles, this approach provides the advantages of encapsulation, reuse, and a more natural model of the real world. For example, suppose you're writing an application for managing a video rental store. The business logic for such an application might include the rules:<p>
</a><ul><a name="6147">
<li>A late fee is generated automatically when a rental becomes overdue.
</a><a name="6135">
<li>A customer can't rent more videos if they have any overdue rentals.
</a><a name="6122">
<li>The total replacement value of a customer's rentals can't exceed the amount of the customer's deposit.
</a></ul><a name="6099">
With Enterprise Objects Framework, you would implement these rules in enterprise objects such as Customer, VideoTape, Rental, and Fee.<p>
</a><a name="6257">
<h2> What Doesn't Go in an Enterprise Object</h2>
</a><a name="6158">
Deciding what code to leave out of your business objects is just as important as deciding what code you leave in. To maximize the reusability and extensibility of your objects, they shouldn't embed knowledge of the user interface or database alongside the business logic. For example, if you embed knowledge of your user interface, you can't reuse the objects because each application's user interface is different; and if you embed knowledge of your database, you have to update your objects every time you modify the database.<p>
</a><a name="6275">
If not in the business objects, then where does this knowledge go? It's &#32;handled by Enterprise Objects Framework as shown in <a href="WhatsEOF1.html#6282">Figure &#32;1</a>.<p>
</a><a name="6276">
<p><img src="WhatsEOF4.gif"><p>
</a><a name="6282">
<p>Figure 1.	  The Enterprise Objects Framework Approach<p>
</a><a name="6234">
The Framework provides a database-to-objects mapping so your objects &#32;are encapsulated from the database, and it provides an <br>objects-to-interface mapping so they are encapsulated from the user interface. This approach enables you to create libraries of enterprise objects that can be used in as many applications as you need, with any user interface, and with any database server. You're able to concentrate on &#32;coding the logic of &#32;your business while the Framework takes care of &#32;the rest.<p>
</a>
<P>
 
<a href="WhatsEOF.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="WhatsEOF2.html"><IMG SRC="ArrowRight.gif">Next Section</a>
<P>


<!--start of footer -->
<!--#include virtual="/includes/framesetfooter" -->
<!-- end of footer -->

</body>
</html>
