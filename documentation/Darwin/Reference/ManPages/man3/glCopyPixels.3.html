<html><head><title>Mac OS X
 Manual Page For glCopyPixels(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/glCopyPixels" title="Mac OS X
 Manual Page for glCopyPixels(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/glCopyPixels"; name=glCopyPixels(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
GLCOPYPIXELS(3G)                                                                            GLCOPYPIXELS(3G)



<b>NAME</b>
       <b>glCopyPixels</b> - copy pixels in the frame buffer


<b>C</b> <b>SPECIFICATION</b>
       void <b>glCopyPixels</b>( GLint <u>x</u>,
                          GLint <u>y</u>,
                          GLsizei <u>width</u>,
                          GLsizei <u>height</u>,
                          GLenum <u>type</u> )


<b>PARAMETERS</b>
       <u>x</u>, <u>y</u> Specify  the  window coordinates of the lower left corner of the rectangular region of pixels to
            be copied.

       <u>width</u>, <u>height</u>
            Specify the dimensions of the rectangular region of pixels to be copied.  Both must be  nonnega-<font color="#ffffff" class="whiteout">tive.&nbsp;nonnegative.</font>
            tive.

       <u>type</u> Specifies whether color values, depth values, or stencil values are to be copied.  Symbolic con-<font color="#ffffff" class="whiteout">stants&nbsp;constants</font>
            stants <b>GL_COLOR</b>, <b>GL_DEPTH</b>, and <b>GL_STENCIL</b> are accepted.

<b>DESCRIPTION</b>
       <b>glCopyPixels</b> copies a screen-aligned rectangle of pixels from the specified frame buffer location  to
       a  region  relative to the current raster position.  Its operation is well defined only if the entire
       pixel source region is within the exposed portion of the window.  Results of copies from outside  the
       window, or from regions of the window that are not exposed, are hardware dependent and undefined.

       <u>x</u>  and  <u>y</u>  specify  the  window  coordinates of the lower left corner of the rectangular region to be
       copied.  <u>width</u> and <u>height</u> specify the dimensions of the rectangular region to be copied.  Both  <u>width</u>
       and <u>height</u> must not be negative.

       Several  parameters control the processing of the pixel data while it is being copied.  These parame-<font color="#ffffff" class="whiteout">ters&nbsp;parameters</font>
       ters are set with three commands: <b>glPixelTransfer</b>, <b>glPixelMap</b>, and <b>glPixelZoom</b>.  This reference  page
       describes  the  effects  on  <b>glCopyPixels</b>  of most, but not all, of the parameters specified by these
       three commands.

       <b>glCopyPixels</b> copies values from each pixel with the lower left-hand corner at (<u>x</u> + i, <u>y</u> + j) for 0 &lt;=
       i  &lt;  <u>width</u>  and 0 &lt;= j &lt; <u>height</u>.  This pixel is said to be the ith pixel in the jth row.  Pixels are
       copied in row order from the lowest to the highest row, left to right in each row.

       <u>type</u> specifies whether color, depth, or stencil data is to be copied.  The details  of  the  transfer
       for each data type are as follows:

       <b>GL_COLOR</b>       Indices or RGBA colors are read from the buffer currently specified as the read source
                      buffer (see <b>glReadBuffer</b>).  If the GL is in color index mode, each index that is  read
                      from  this buffer is converted to a fixed-point  with an unspecified number of bits to
                      the right of the binary point.  Each index is  then  shifted  left  by  <b>GL_INDEX_SHIFT</b>
                      bits,  and  added  to <b>GL_INDEX_OFFSET</b>.  If <b>GL_INDEX_SHIFT</b> is negative, the shift is to
                      the right.  In either case, zero bits fill otherwise unspecified bit locations in  the
                      result.   If <b>GL_MAP_COLOR</b> is true, the index is replaced with the value that it refer-
                      ences in lookup table <b>GL_PIXEL_MAP_I_TO_I</b>.  Whether  the  lookup  replacement  of  the
                      index is done or not, the integer part of the index is then ANDed with (2^b) -1, where
                      b is the number of bits in a color index buffer.

                      If the GL is in RGBA mode, the red, green, blue, and alpha components  of  each  pixel
                      that  is read are converted to an internal floating-point  with unspecified precision.
                      The conversion maps the largest representable component value to  1.0,  and  component
                      value  0  to  0.0.   The  resulting floating-point color values are then multiplied by
                      <b>GL_c_SCALE</b> and added to <b>GL_c_BIAS</b>, where <u>c</u> is RED, GREEN,  BLUE,  and  ALPHA  for  the
                      respective  color  components.   The  results  are  clamped  to  the  range [0,1].  If
                      <b>GL_MAP_COLOR</b> is true, each color component is scaled  by  the  size  of  lookup  table
                      <b>GL_PIXEL_MAP_c_TO_c</b>,  then  replaced by the value that it references in that table.  <u>c</u>
                      is R, G, B, or A.

                      If the <b>GL_ARB_imaging</b> extension is supported, the color  values  may  be  additionally
                      processed  by  color-table lookups, color-matrix transformations, and convolution fil-<font color="#ffffff" class="whiteout">ters.&nbsp;filters.</font>
                      ters.

                      The GL then converts the resulting indices or RGBA colors to  fragments  by  attaching
                      the  current  raster position <u>z</u> coordinate and texture coordinates to each pixel, then
                      assigning window coordinates (xr + i , yr + j), where (xr , yr) is the current  raster
                      position,  and  the pixel was the ith pixel in the jth row.  These pixel fragments are
                      then treated just like the fragments generated by rasterizing points, lines, or  poly-<font color="#ffffff" class="whiteout">gons.&nbsp;polygons.</font>
                      gons.   Texture  mapping,  fog, and all the fragment operations are applied before the
                      fragments are written to the frame buffer.

       <b>GL_DEPTH</b>       Depth values are read from the depth buffer and  converted  directly  to  an  internal
                      floating-point  with  unspecified precision.  The resulting floating-point depth value
                      is then multiplied by <b>GL_DEPTH_SCALE</b>  and  added  to  <b>GL_DEPTH_BIAS</b>.   The  result  is
                      clamped to the range [0,1].

                      The GL then converts the resulting depth components to fragments by attaching the cur-<font color="#ffffff" class="whiteout">rent&nbsp;current</font>
                      rent raster position color or color index and texture coordinates to each pixel,  then
                      assigning  window coordinates (xr + i , yr + j), where (xr , yr) is the current raster
                      position, and the pixel was the ith pixel in the jth row.  These pixel  fragments  are
                      then  treated just like the fragments generated by rasterizing points, lines, or poly-<font color="#ffffff" class="whiteout">gons.&nbsp;polygons.</font>
                      gons.  Texture mapping, fog, and all the fragment operations are  applied  before  the
                      fragments are written to the frame buffer.

       <b>GL_STENCIL</b>     Stencil  indices  are read from the stencil buffer and converted to an internal fixed-<font color="#ffffff" class="whiteout">point&nbsp;fixedpoint</font>
                      point with an unspecified number of bits to the  right  of  the  binary  point.   Each
                      fixed-point  index  is  then  shifted  left  by  <b>GL_INDEX_SHIFT</b>  bits,  and  added  to
                      <b>GL_INDEX_OFFSET</b>.  If <b>GL_INDEX_SHIFT</b> is negative, the shift is to the right.  In either
                      case,  zero  bits  fill  otherwise  unspecified  bit  locations  in  the  result.   If
                      <b>GL_MAP_STENCIL</b> is true, the index is replaced with the value  that  it  references  in
                      lookup table <b>GL_PIXEL_MAP_S_TO_S</b>.  Whether the lookup replacement of the index is done
                      or not, the integer part of the index is then ANDed with (2^b)-1, where b is the  num-<font color="#ffffff" class="whiteout">ber&nbsp;number</font>
                      ber  of bits in the stencil buffer.  The resulting stencil indices are then written to
                      the stencil buffer such that the index read from the ith location of the  jth  row  is
                      written to location (xr + i , yr + j), where (xr , yr) is the current raster position.
                      Only the pixel ownership test, the scissor test,  and  the  stencil  writemask  affect
                      these write operations.

       The rasterization described thus far assumes pixel zoom factors of 1.0.  If
       <b>glPixelZoom</b>  is  used  to change the x and y pixel zoom factors, pixels are converted to fragments as
       follows.  If (xr, yr) is the current raster position, and a given pixel is in the ith location in the
       jth  row  of the source pixel rectangle, then fragments are generated for pixels whose centers are in
       the rectangle with corners at

                                           (xr + zoomx*i, yr + zoomy*j)

                                                        and

                                       (xr + zoomx*(i+1), yr + zoomy*(j+1))

       where zoomx is the value of <b>GL_ZOOM_X</b> and zoomy is the value of <b>GL_ZOOM_Y</b>.

<b>EXAMPLES</b>
       To copy the color pixel in the lower left corner of the window to the current  raster  position,  use
       glCopyPixels(0, 0, 1, 1, <b>GL_COLOR</b>);

<b>NOTES</b>
       Modes specified by <b>glPixelStore</b> have no effect on the operation of <b>glCopyPixels</b>.

<b>ERRORS</b>
       <b>GL_INVALID_ENUM</b> is generated if <u>type</u> is not an accepted value.

       <b>GL_INVALID_VALUE</b> is generated if either <u>width</u> or <u>height</u> is negative.

       <b>GL_INVALID_OPERATION</b> is generated if <u>type</u> is <b>GL_DEPTH</b> and there is no depth buffer.

       <b>GL_INVALID_OPERATION</b> is generated if <u>type</u> is <b>GL_STENCIL</b> and there is no stencil buffer.

       <b>GL_INVALID_OPERATION</b>  is  generated  if <b>glCopyPixels</b> is executed between the execution of <b>glBegin</b> and
       the corresponding execution of <b>glEnd</b>.

<b>ASSOCIATED</b> <b>GETS</b>
       <b>glGet</b> with argument <b>GL_CURRENT_RASTER_POSITION</b>
       <b>glGet</b> with argument <b>GL_CURRENT_RASTER_POSITION_VALID</b>

<b>SEE</b> <b>ALSO</b>
       <a href="glColorTable.3.html#//apple_ref/doc/man/3/glColorTable"><b>glColorTable</b>(3G)</a>, <a href="glConvolutionFilter1D.3.html#//apple_ref/doc/man/3/glConvolutionFilter1D"><b>glConvolutionFilter1D</b>(3G)</a>, <a href="glConvolutionFilter2D.3.html#//apple_ref/doc/man/3/glConvolutionFilter2D"><b>glConvolutionFilter2D</b>(3G)</a>, <a href="glDepthFunc.3.html#//apple_ref/doc/man/3/glDepthFunc"><b>glDepthFunc</b>(3G)</a>, <a href="glDrawBuffer.3.html#//apple_ref/doc/man/3/glDrawBuffer"><b>glDrawBuffer</b>(3G)</a>,  <a href="glDrawPixels.3.html#//apple_ref/doc/man/3/glDrawPixels"><b>glDrawPixels</b>(3G)</a>,
       <a href="glMatrixMode.3.html#//apple_ref/doc/man/3/glMatrixMode"><b>glMatrixMode</b>(3G)</a>,  <a href="glPixelMap.3.html#//apple_ref/doc/man/3/glPixelMap"><b>glPixelMap</b>(3G)</a>,  <a href="glPixelTransfer.3.html#//apple_ref/doc/man/3/glPixelTransfer"><b>glPixelTransfer</b>(3G)</a>,  <a href="glPixelZoom.3.html#//apple_ref/doc/man/3/glPixelZoom"><b>glPixelZoom</b>(3G)</a>,  <a href="glRasterPos.3.html#//apple_ref/doc/man/3/glRasterPos"><b>glRasterPos</b>(3G)</a>,  <a href="glReadBuffer.3.html#//apple_ref/doc/man/3/glReadBuffer"><b>glReadBuffer</b>(3G)</a>, <a href="glReadPixels.3.html#//apple_ref/doc/man/3/glReadPixels"><b>glReadPixels</b>(3G)</a>,
       <a href="glSeparableFilter2D.3.html#//apple_ref/doc/man/3/glSeparableFilter2D"><b>glSeparableFilter2D</b>(3G)</a>, <a href="glStencilFunc.3.html#//apple_ref/doc/man/3/glStencilFunc"><b>glStencilFunc</b>(3G)</a>




                                                                                            GLCOPYPIXELS(3G)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/glCopyPixels.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/glCopyPixels.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/glCopyPixels.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
