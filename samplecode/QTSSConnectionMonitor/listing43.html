<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTSSConnectionMonitor - /SmallSocketsClasses/AbstractSocket.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxStreaming-date.html">Streaming</a> &gt; <A HREF="javascript:location.replace('index.html');">QTSSConnectionMonitor</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTSSConnectionMonitor</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SmallSocketsClasses/AbstractSocket.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AdminProtocolAccessObj.h</option>
<option value="listing2.html">/AdminProtocolAccessObj.m</option>
<option value="listing3.html">/base64.c</option>
<option value="listing4.html">/base64.h</option>
<option value="listing5.html">/LoginWindowController.h</option>
<option value="listing6.html">/LoginWindowController.m</option>
<option value="listing7.html">/main.m</option>
<option value="listing8.html">/MOKit.framework/Headers/MOCompletionManager.h</option>
<option value="listing9.html">/MOKit.framework/Headers/MOCompletionStrategy.h</option>
<option value="listing10.html">/MOKit.framework/Headers/MOFileCompletionStrategy.h</option>
<option value="listing11.html">/MOKit.framework/Headers/MOFoundationExtras.h</option>
<option value="listing12.html">/MOKit.framework/Headers/MOKit.h</option>
<option value="listing13.html">/MOKit.framework/Headers/MOKitDefines.h</option>
<option value="listing14.html">/MOKit.framework/Headers/MORegexFormatter.h</option>
<option value="listing15.html">/MOKit.framework/Headers/MORegularExpression.h</option>
<option value="listing16.html">/MOKit.framework/Headers/MORESyntaxFormatter.h</option>
<option value="listing17.html">/MOKit.framework/Headers/MORuntimeUtilities.h</option>
<option value="listing18.html">/MOKit.framework/Versions/A/Headers/MOCompletionManager.h</option>
<option value="listing19.html">/MOKit.framework/Versions/A/Headers/MOCompletionStrategy.h</option>
<option value="listing20.html">/MOKit.framework/Versions/A/Headers/MOFileCompletionStrategy.h</option>
<option value="listing21.html">/MOKit.framework/Versions/A/Headers/MOFoundationExtras.h</option>
<option value="listing22.html">/MOKit.framework/Versions/A/Headers/MOKit.h</option>
<option value="listing23.html">/MOKit.framework/Versions/A/Headers/MOKitDefines.h</option>
<option value="listing24.html">/MOKit.framework/Versions/A/Headers/MORegexFormatter.h</option>
<option value="listing25.html">/MOKit.framework/Versions/A/Headers/MORegularExpression.h</option>
<option value="listing26.html">/MOKit.framework/Versions/A/Headers/MORESyntaxFormatter.h</option>
<option value="listing27.html">/MOKit.framework/Versions/A/Headers/MORuntimeUtilities.h</option>
<option value="listing28.html">/MOKit.framework/Versions/A.1/Headers/MOCompletionManager.h</option>
<option value="listing29.html">/MOKit.framework/Versions/A.1/Headers/MOCompletionStrategy.h</option>
<option value="listing30.html">/MOKit.framework/Versions/A.1/Headers/MOFileCompletionStrategy.h</option>
<option value="listing31.html">/MOKit.framework/Versions/A.1/Headers/MOFoundationExtras.h</option>
<option value="listing32.html">/MOKit.framework/Versions/A.1/Headers/MOKit.h</option>
<option value="listing33.html">/MOKit.framework/Versions/A.1/Headers/MOKitDefines.h</option>
<option value="listing34.html">/MOKit.framework/Versions/A.1/Headers/MORegexFormatter.h</option>
<option value="listing35.html">/MOKit.framework/Versions/A.1/Headers/MORegularExpression.h</option>
<option value="listing36.html">/MOKit.framework/Versions/A.1/Headers/MORESyntaxFormatter.h</option>
<option value="listing37.html">/MOKit.framework/Versions/A.1/Headers/MORuntimeUtilities.h</option>
<option value="listing38.html">/QTSSStatusController.h</option>
<option value="listing39.html">/QTSSStatusController.m</option>
<option value="listing40.html">/QTSSStatusView.h</option>
<option value="listing41.html">/QTSSStatusView.m</option>
<option value="listing42.html">/SmallSocketsClasses/AbstractSocket.h</option>
<option value="listing43.html">/SmallSocketsClasses/AbstractSocket.m</option>
<option value="listing44.html">/SmallSocketsClasses/Socket.h</option>
<option value="listing45.html">/SmallSocketsClasses/Socket.m</option></select>
				</p>
				</form>
				<p><strong><a href="QTSSConnectionMonitor.zip">Download Sample</a></strong> (&#147;QTSSConnectionMonitor.zip&#148;, 295.0K)<BR>
<strong><a href="QTSSConnectionMonitor.dmg">Download Sample</a></strong> (&#147;QTSSConnectionMonitor.dmg&#148;, 355.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//
// AbstractSocket.m
//
// SmallSockets Library (http://smallsockets.sourceforge.net/)
//
// Copyright (C) 2001 Steven Frank (stevenf@panic.com)
//
// This software is provided 'as-is', without any express or implied 
// warranty. In no event will the authors be held liable for any damages 
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose, 
// including commercial applications, and to alter it and redistribute it 
// freely, subject to the following restrictions:
//
//     1. The origin of this software must not be misrepresented; you must 
//        not claim that you wrote the original software. If you use this 
//        software in a product, an acknowledgment in the product 
//        documentation (and/or about box) would be appreciated but is not 
//        required.
//
//     2. Altered source versions must be plainly marked as such, and must
//        not be misrepresented as being the original software.
//
//     3. This notice may not be removed or altered from any source 
//        distribution.
//        
 
#import &quot;AbstractSocket.h&quot;

#import &lt;fcntl.h&gt;
#import &lt;netdb.h&gt;
#import &lt;netinet/in.h&gt;
#import &lt;sys/socket.h&gt;
#import &lt;sys/time.h&gt;
#import &lt;sys/types.h&gt;
#import &lt;arpa/inet.h&gt;
#import &lt;unistd.h&gt;


@implementation AbstractSocket

- (id)init
//
// Designated initializer
//
{    
    if ( ![super init] )
    return nil;

    connected = NO;
    listening = NO;
    readBuffer = NULL;
    readBufferSize = SOCKET_DEFAULT_READ_BUFFER_SIZE;
    remoteHostName = NULL;
    remotePort = SOCKET_INVALID_PORT;

    // Create socket

    if ( (socketfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0 )
        [NSException raise:SOCKET_EX_CANT_CREATE_SOCKET 
                        format:SOCKET_EX_CANT_CREATE_SOCKET_F, strerror(errno)];

    [self allocReadBuffer];
    
    return self;
}


- (void)dealloc
//
// Do not call this method directly!  Use retain &amp; release.
//
{
    [self close];

    if ( readBuffer )
    {
        free(readBuffer);
        readBuffer = NULL;
    }
    
    [super dealloc];
}


- (void)acceptConnection
//
// Accept a connection on this socket, if it is listening.  May block if
// no connections are pending.  The existing listening socket will be destroyed, and
// replaced with the socket that is connected to the remote host.
//
// If you want to keep the listening socket around, try acceptConnectionAndKeepListening
//
{
    struct sockaddr_in acceptAddr;
    int socketfd2 = SOCKET_INVALID_DESCRIPTOR;
    int addrSize = sizeof(acceptAddr);
  
    // Socket must be created, not connected, and listening
    
    if ( socketfd == SOCKET_INVALID_DESCRIPTOR )
        [NSException raise:SOCKET_EX_BAD_SOCKET_DESCRIPTOR 
                        format:SOCKET_EX_BAD_SOCKET_DESCRIPTOR];

    if ( connected )
        [NSException raise:SOCKET_EX_ALREADY_CONNECTED 
                        format:SOCKET_EX_ALREADY_CONNECTED];

    if ( !listening )
        [NSException raise:SOCKET_EX_NOT_LISTENING 
                        format:SOCKET_EX_NOT_LISTENING];
   
    // Accept a remote connection.  Raise on failure
    
    socketfd2 = accept(socketfd, (struct sockaddr*)&amp;acceptAddr, &amp;addrSize);
    
    if ( socketfd2 &lt; 0 )
        [NSException raise:SOCKET_EX_ACCEPT_FAILED 
                        format:SOCKET_EX_ACCEPT_FAILED_F, strerror(errno)];
    
    // Replace existing socket descriptor with newly obtained one
    
    [self close];

    remotePort = acceptAddr.sin_port;
    remoteHostName = [[AbstractSocket dottedIPFromAddress:&amp;acceptAddr.sin_addr] retain];
    
    socketfd = socketfd2;
    connected = YES;
    listening = NO;
}


- (void)allocReadBuffer
//
// Internal utility function.  You should not call this from client code.
//
{
    // Allocate readBuffer
    
    if ( readBuffer == NULL )
    {
        readBuffer = malloc(readBufferSize);
        if ( readBuffer == NULL )
            [NSException raise:SOCKET_EX_MALLOC_FAILED format:SOCKET_EX_MALLOC_FAILED];
    }
}


- (void)bindTo:(u_int32_t)address port:(unsigned short)port
//
// Bind an address to this socket.  You normally do not need to
// call this method.  See listenOnPort instead.
//
{
    struct sockaddr_in localAddr;
    int on = 1;

    // Set a flag so that this address can be re-used immediately after the connection
    // closes.  (TCP normally imposes a delay before an address can be re-used.)
    
    if ( setsockopt(socketfd, SOL_SOCKET, SO_REUSEADDR, (void*)&amp;on, sizeof(on)) &lt; 0 )
        [NSException raise:SOCKET_EX_SETSOCKOPT_FAILED 
                        format:SOCKET_EX_SETSOCKOPT_FAILED_F, strerror(errno)];

    // Bind the address to the socket

    localAddr.sin_family      = AF_INET;
    localAddr.sin_addr.s_addr = htonl(address);
    localAddr.sin_port        = htons(port);

    if ( bind(socketfd, (struct sockaddr*)&amp;localAddr, sizeof(localAddr)) &lt; 0 )
  [NSException raise:SOCKET_EX_BIND_FAILED 
                        format:SOCKET_EX_BIND_FAILED_F, strerror(errno)];
}


- (void)close
//
// Closes the socket.  You generally do not need to call this, as the socket
// will be automatically closed when it is released.
//
{
    if ( socketfd != SOCKET_INVALID_DESCRIPTOR )
    {
        close(socketfd);
        socketfd = SOCKET_INVALID_DESCRIPTOR;
    }
    
    if ( remoteHostName != NULL )
    {
        [remoteHostName release];
        remoteHostName = NULL;
    }

    connected = NO;
    listening = NO;
    remotePort = SOCKET_INVALID_PORT;
}


- (void)connectToHostName:(NSString*)hostName port:(unsigned short)port
//
// Connect the socket to the host specified by hostName, on the requested port.
//
{
    struct hostent* remoteHost;
    struct sockaddr_in remoteAddr;

    // Socket must be created, and not already connected

    if ( socketfd == SOCKET_INVALID_DESCRIPTOR )
        [NSException raise:SOCKET_EX_BAD_SOCKET_DESCRIPTOR 
                        format:SOCKET_EX_BAD_SOCKET_DESCRIPTOR];
    
    if ( connected )
        [NSException raise:SOCKET_EX_ALREADY_CONNECTED 
                        format:SOCKET_EX_ALREADY_CONNECTED];
    
    // Look up host 
    
    if ( (remoteHost = gethostbyname([hostName cString])) == NULL )
        [NSException raise:SOCKET_EX_HOST_NOT_FOUND 
                        format:SOCKET_EX_HOST_NOT_FOUND_F, strerror(errno)];
    
    // Copy host address and port into socket address structure
    
    bzero((char*)&amp;remoteAddr, sizeof(remoteAddr));
    remoteAddr.sin_family = AF_INET;
    bcopy((char*)remoteHost-&gt;h_addr, (char*)&amp;remoteAddr.sin_addr.s_addr, remoteHost-&gt;h_length);
    remoteAddr.sin_port = htons(port);

    // Request connection, raise on failure
    
    if ( (connect(socketfd, (struct sockaddr*)&amp;remoteAddr, sizeof(remoteAddr)) &lt; 0) )
        [NSException raise:SOCKET_EX_CONNECT_FAILED 
                        format:SOCKET_EX_CONNECT_FAILED_F, strerror(errno)];

    // Note successful connection
    
    remoteHostName = [[NSString alloc] initWithString:hostName];
    remotePort = port;

    connected = YES;
}


+ (NSString*)dottedIPFromAddress:(struct in_addr*)address;
//
// Utility function that returns a dotted IP address string from a
// 32-bit network address
//
{
    return [NSString stringWithCString:inet_ntoa(*address)];
}


- (id)initWithFD:(int)fd remoteAddress:(struct sockaddr_in*)remoteAddress 
//
// Inits a Socket with an existing, connected socket file descriptor.  This is really
// only intended for internal use (see -acceptConnectionAndKeepListening) 
//
{
    if ( ![super init] )
  return nil;

    connected = YES;
    listening = NO;
    readBuffer = NULL;
    readBufferSize = SOCKET_DEFAULT_READ_BUFFER_SIZE;
    remoteHostName = [[AbstractSocket dottedIPFromAddress:&amp;remoteAddress-&gt;sin_addr] retain];
    remotePort = remoteAddress-&gt;sin_port;
    socketfd = fd;    

    [self allocReadBuffer];

    return self;
}


- (BOOL)isConnected
//
// Returns whether the socket is connected
//
{
    return connected;
}


- (BOOL)isReadable
//
// Returns whether or not data is available at the Socket for reading
//
{
    int count;
    fd_set readfds;
    struct timeval timeout;
    
    // Socket must be created and connected
    
    if ( socketfd == SOCKET_INVALID_DESCRIPTOR )
        [NSException raise:SOCKET_EX_BAD_SOCKET_DESCRIPTOR 
                        format:SOCKET_EX_BAD_SOCKET_DESCRIPTOR];

    if ( !connected )
        [NSException raise:SOCKET_EX_NOT_CONNECTED 
                        format:SOCKET_EX_NOT_CONNECTED];

    // Create a file descriptor set for just this socket

    FD_ZERO(&amp;readfds);
    FD_SET(socketfd, &amp;readfds);
   
    // Create a timeout of zero (don't wait)
   
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
 
    // Check socket for data
 
    count = select(socketfd + 1, &amp;readfds, NULL, NULL, &amp;timeout);
    
    // Return value of less than 0 indicates error

    if ( count &lt; 0 )
        [NSException raise:SOCKET_EX_SELECT_FAILED 
                        format:SOCKET_EX_SELECT_FAILED_F, strerror(errno)];
    
    // select() returns number of descriptors that matched, so 1 == has data, 0 == no data
    
    return (count == 1);
}


- (BOOL)isWritable
//
// Returns whether or not the Socket can be written to
//
{
    int count;
    fd_set writefds;
    struct timeval timeout;
    
    // Socket must be created and connected
    
    if ( socketfd == SOCKET_INVALID_DESCRIPTOR )
        [NSException raise:SOCKET_EX_BAD_SOCKET_DESCRIPTOR 
                        format:SOCKET_EX_BAD_SOCKET_DESCRIPTOR];

    if ( !connected )
        [NSException raise:SOCKET_EX_NOT_CONNECTED 
                        format:SOCKET_EX_NOT_CONNECTED];

    // Create a file descriptor set for just this socket

    FD_ZERO(&amp;writefds);
    FD_SET(socketfd, &amp;writefds);
   
    // Create a timeout of zero (don't wait)
   
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
 
    // Check socket for data
 
    count = select(socketfd + 1, NULL, &amp;writefds, NULL, &amp;timeout);
    
    // Return value of less than 0 indicates error

    if ( count &lt; 0 )
        [NSException raise:SOCKET_EX_SELECT_FAILED 
                        format:SOCKET_EX_SELECT_FAILED_F, strerror(errno)];
    
    // select() returns number of descriptors that matched, so 1 == write OK
    
    return (count == 1);
}


- (void)listenOnPort:(unsigned short)port
//
// Start the socket listening on the given local port number
//
{
    [self listenOnPort:port maxPendingConnections:SOCKET_MAX_PENDING_CONNECTIONS];
}


- (void)listenOnPort:(unsigned short)port maxPendingConnections:(unsigned int)maxPendingConnections
//
// Start the socket listening on the given local port number,
// with the given maximum number of pending connections.
//
{
    [self bindTo:INADDR_ANY port:port];

    if ( listen(socketfd, maxPendingConnections) &lt; 0 )
        [NSException raise:SOCKET_EX_LISTEN_FAILED 
                        format:SOCKET_EX_LISTEN_FAILED_F, strerror(errno)];
        
    listening = YES;
}


- (unsigned int)readBufferSize
//
// Returns this Socket's readBuffer size
//
{
    return readBufferSize;
}


- (int)readData:(NSMutableData*)data
//
// Append any available data from the socket to the supplied buffer.
// Returns number of bytes received.  (May be 0)
//
{
    ssize_t count;
 
  // data must not be null ptr
  
  if ( data == NULL )
    [NSException raise:SOCKET_EX_INVALID_BUFFER 
            format:SOCKET_EX_INVALID_BUFFER];
 
    // Socket must be created and connected
    
    if ( socketfd == SOCKET_INVALID_DESCRIPTOR )
        [NSException raise:SOCKET_EX_BAD_SOCKET_DESCRIPTOR 
                        format:SOCKET_EX_BAD_SOCKET_DESCRIPTOR];

    if ( !connected )
        [NSException raise:SOCKET_EX_NOT_CONNECTED 
                        format:SOCKET_EX_NOT_CONNECTED];
    
    // Request a read of as much as we can.  Should return immediately if no data.
   
    count = recv(socketfd, readBuffer, readBufferSize, 0);
    
    if ( count &gt; 0 )
    {
        // Got some data, append it to user's buffer

        [data appendBytes:readBuffer length:count];
    }
    else if ( count == 0 )
    {
        // Other side has disconnected, so close down our socket

        [self close];
    }
    else if ( count &lt; 0 )
    {
        // recv() returned an error. 
                
        if ( errno == EAGAIN )
        {
            // No data available to read (and socket is non-blocking)
            count = 0;
        }
        else
            [NSException raise:SOCKET_EX_RECV_FAILED 
                            format:SOCKET_EX_RECV_FAILED_F, strerror(errno)];
    }
    
    return count;
}


- (NSString*)remoteHostName
//
// Returns the remote hostname that the socket is connected to,
// or NULL if the socket is not connected.
//
{
    return remoteHostName;
}


- (unsigned short)remotePort
//
// Returns the remote port number that the socket is connected to, 
// or 0 if not connected.
//
{
    return remotePort;
}


- (void)setBlocking:(BOOL)shouldBlock
//
// Switch the socket to blocking or non-blocking mode
//
{
    int flags;
    int result;
    
    flags = fcntl(socketfd, F_GETFL, 0);

    if ( flags &lt; 0 )
        [NSException raise:SOCKET_EX_FCNTL_FAILED 
                        format:SOCKET_EX_FCNTL_FAILED_F, strerror(errno)];

    if ( shouldBlock )
    {
        // Set it to blocking...
        result = fcntl(socketfd, F_SETFL, flags &amp; ~O_NONBLOCK );
    }
    else
    {
        // Set it to non-blocking...
        result = fcntl(socketfd, F_SETFL, flags | O_NONBLOCK);
    }

    if ( result &lt; 0 )
        [NSException raise:SOCKET_EX_FCNTL_FAILED 
                        format:SOCKET_EX_FCNTL_FAILED_F, strerror(errno)];
}


- (void)setReadBufferSize:(unsigned int)size
//
// Change the size of the read buffer at runtime
//
{
    readBufferSize = size;
  
    if ( readBuffer ) 
    {
        free(readBuffer);
        readBuffer = NULL;
    }
    
    [self allocReadBuffer];
}


- (void)writeData:(NSData*)data
//
// Writes the given data to the socket
//
{
    const char* bytes = [data bytes];    
    int len = [data length];
    int sent;
    
    // Socket must be created and connected
    
    if ( socketfd == SOCKET_INVALID_DESCRIPTOR )
        [NSException raise:SOCKET_EX_BAD_SOCKET_DESCRIPTOR 
                        format:SOCKET_EX_BAD_SOCKET_DESCRIPTOR];

    if ( !connected )
        [NSException raise:SOCKET_EX_NOT_CONNECTED 
                        format:SOCKET_EX_NOT_CONNECTED];
    
    // Send the data
    
    while ( len &gt; 0 )
    {
        sent = send(socketfd, bytes, len, 0);
        
        if ( sent &lt; 0 )
            [NSException raise:SOCKET_EX_SEND_FAILED 
                            format:SOCKET_EX_SEND_FAILED_F, strerror(errno)];    
        
        bytes += sent;
        len -= sent;
    }
}


- (void)writeString:(NSString*)string
//
// Writes the given string to the socket
//
{
    if ( [string length] &gt; 0 ) 
        [self writeData:[string dataUsingEncoding:NSUTF8StringEncoding]]; 
}


@end

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTSSConnectionMonitor/listing43.html%3Fid%3DDTS10001049-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTSSConnectionMonitor/listing43.html%3Fid%3DDTS10001049-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTSSConnectionMonitor/listing43.html%3Fid%3DDTS10001049-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>