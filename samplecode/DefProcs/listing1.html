<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DefProcs - /butcdef.a</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">DefProcs</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DefProcs</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/butcdef.a</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/butcdef.a</option>
<option value="listing2.html">/LDefProc0.A</option>
<option value="listing3.html">/mdefproc.a</option>
<option value="listing4.html">/rdocproc.a</option>
<option value="listing5.html">/Read Me â€¢ DefProcs.txt</option>
<option value="listing6.html">/sbarcdef.a</option>
<option value="listing7.html">/wprocasm.a</option></select>
				</p>
				</form>
				<p><strong><a href="DefProcs.zip">Download Sample</a></strong> (&#147;DefProcs.zip&#148;, 78.9K)<BR>
<strong><a href="DefProcs.dmg">Download Sample</a></strong> (&#147;DefProcs.dmg&#148;, 151.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">;EASE$$$ READ ONLY COPY of file &quot;butcdef.a&quot;; 1.0  CCH 11/16/1988 Added to EASE.; END EASE MODIFICATION HISTORY ;;File ButCDef.ASM;--------------------------------------------------------------------------;;  Standard Button Definition Procedure for the;  MacIntosh Control Manager;;  written by Andy Hertzfeld  August, 1982;;  (c) 1982 by Apple Computer, Inc.  All rights reserved.;;   This file contains the control definition procedures;   that define the standard &quot;button&quot; type controls.  These;   include PushButtons, CheckBoxes, and a checkBox variant called;   RadioButton;;  Modification History:;;   22-Aug-82  AJH  Added clipping, centering to PushButProc;   25-Aug-82  AJH  Fixed corner-clobber bug in pushButProc;   29-Aug-82  AJH  Added &quot;255&quot; hiliting,;   29-Sep-82  AJH  Added CheckBox control definition procedure;   03-Oct-82  AJH  Fixed bug in scrollBar positioning -- wasn't ctl relative;   05-Oct-82  AJH  Fixed checkBox flashing, added code saving optimizations;   10-Oct-82  AJH  Converted for QuickDraw Trap Interface;   17-Oct-82  AJH  Made controlProcs preserve A1;   14-Nov-82  AJH  Improved PushButton roundness scaling; removed box in arrowBits;   16-Nov-82  AJH  Made branch tables offset based;   28-Dec-82  AJH  Put button definitions in their own file;   11-Mar-83  AJH  fixed up check box drawing;   27-Mar-83  AJH  made it respect initial clip in button drawing;   01-Apr-83  AJH  made it use hardwired gray;   04-Apr-83  AJH  made it force size 12 for text;   07-Jun-83  AJH  fixed scrambling bug, changed check draw for new QuickDraw;   29-Aug-83  AJH  fixed scrambling bug in CalcPBut;   27-Sep-83  AJH  made variants &gt; 7 not force the system font;   12-Oct-83  AJH  changed button disabling;   17-Oct-83  AJH  back to &quot;gray-out&quot; button disabling;   31-Dec-83  AJH  made text of checkBox/radioButtons grayed  out if disabled;   14-Jan-85  JTC  convert to MDS;   14-Feb-85  JTC  added res name;   12-Mar-85  JTC  changed occurrences of LGlobals to GrafGlobals;v2  16-May-85  EHB  only return &quot;254&quot; if point in control!;v3  20-May-85  EHB  implemented Multi-Line buttons;v4  26-Aug-85  EHB  made variable sized fonts work (ROM85&gt;0 only);;--Post Lonely Heiffer Release----------------------------------------------;;   &lt;C59/30Jun86&gt;  DAF   added color support for nuMac (mucho chango);  &lt;C203/08Oct86&gt;  DAF   updated color support on nuMac for RGBColors;              changed textMode to srcOr.;  &lt;C407/16Nov86&gt;  DAF   changed textMode (again) to srcCopy, as per Cary's recommendation;   &lt;C424/18Nov86&gt;   DAF   converted a BSET/BCLR to an HLock/HUnlock, in CalcPBut;  &lt;C560/21Dec86&gt;  DAF   Added Mark Davis' code to allow reversed checkmarks for intl;  &lt;C637/14Jan87&gt;  DAF   Changed textMode back to srcOR from srcCopy (sigh...);  &lt;C700/26Jan87&gt;  DAF   Universal version of butCDEF.a (version 10);   &lt;C818/14Feb87&gt;  DAF   Converted nuMac PaintRoundRgn to be unified with other Macs' Erase;             stopped setting backColor when drawing text.;  &lt;SMAB156/30Mar87&gt;  DAF   Tested ROM version before using teSysJust.;      BLANKS    ON      STRING    ASIS      PRINT    OFF      LOAD    'inc.sum.d'      LOAD    'nEqu.d'      INCLUDE    'colorEqu.a'      PRINT    ON      ;CDEF0    PROC    EXPORT;; FUNCTION PushButProc( selector:  INTEGER;    18;      theControl: ControlHandle;        14;      message:  INTEGER;          12;      param:    LongInt): LongInt;       8 : 20;;  PushButProc is the control definition procedure for simple pushButtons, one of the; standard control types supported by the user interface toolBox.;;  And a stack frame definitionCtlHndl      EQU    14        ;incoming control handle param  &lt;C59/30Jun86&gt; DAFSavePen     EQU  -20Align      EQU   -21        ;a dead byte for IsColor    &lt;C700/26Jan87&gt; DAFIsColor      EQU   -22        ;do we have colorQD and toolbox [boolean]  &lt;C700/26Jan87&gt; DAFIndicatorRect  EQU  -30AuxCtlHndl    EQU   -34        ;handle of auxCtl ColorTable  &lt;C59/30Jun86&gt; DAFAuxCtlPtr    EQU   -38        ;ptr to auxCtl ColorTable    &lt;C59/30Jun86&gt; DAFContentRGB    EQU   -44        ;window content color      &lt;C59/30Jun86&gt; DAFSavFgCol    EQU   -50        ;window port's RGBFgColor    &lt;Cxxx/06Oct86&gt; DAFSavBkCol    EQU   -56        ;window port's RGBBkColor    &lt;Cxxx/06Oct86&gt; DAFFrameSize    EQU   -56        ;                &lt;C59/30Jun86&gt; DAF        ;      BRA.S  @0          ; skip header; standard header      DC.W  0          ; flags      DC.B  'CDEF'      DC.W  0      DC.W  10          ; version #@0      LINK  A6,#FrameSize     ; set up a stack frame to address parameters &lt;C59/30Jun86&gt; DAF            MOVEM.L D3-D7/A1-A4,-(SP)  ; save work registers;; buttons only handle messages 0,1 and 2;      CMP   #3,12(A6)      ; inspect message value      BGE    DoneP1        ; if &gt;2, nothing to do;; save the penState and set it our way;      PEA   SavePen(A6)     ; push pointer to savePenState      _GetPenState        ; remember current penState      _PenNormal          ; set the pen the way we want it      ; Determine type of system.  We need to know if we have color QuickDraw and a color;  window manager port.        CMP.W  #$3FFF,ROM85    ; do we have color QD?       SLS    IsColor(A6)      ; set boolean depending on color or B&amp;W system      BHI.S  @BWSys        ; no, this system has B&amp;W QD      ; save the current port's colors and textMode            &lt;C59/30Jun86&gt; DAF            MOVE.L  GrafGlobals(A5),A0  ; get pointer to grafGlobals  &lt;C407/16Nov86&gt; DAF      MOVE.L  thePort(A0),A0    ; get pointer to thePort    &lt;C407/16Nov86&gt; DAF      MOVE.W  txMode(A0),-(SP)  ; save the current text mode  &lt;C407/16Nov86&gt; DAF            MOVE.W  #srcOR,-(SP)    ; push text mode        &lt;C637/16Nov86&gt; DAF      _TextMode          ;                &lt;C407/16Nov86&gt; DAF            PEA    SavFgCol(A6)    ; save foreColor      _GetForeColor        ;      PEA    SavBkCol(A6)    ; save backColor too      _GetBackColor        ;;; get the CtlAuxRec for this guy and lock its colortable      &lt;C59/30Jun86&gt; DAF;      CLR.L  -(SP)        ; return the handle here      CLR.B  -(SP)        ; space for boolean func return      MOVE.L  CtlHndl(A6),-(SP)  ; push the control handle      PEA    6(SP)        ; push a pointer to placeholder      _GetAuxCtl          ; get its auxRec      ADDQ  #2,SP        ; don't need boolean result      MOVE.L  (SP)+,A0      ; get auxCtl handle      MOVE.L  (A0),A0        ; a pointer to the auxCtlRec      MOVE.L  ctlCTable(A0),A0  ; get colortable's handle      MOVE.L  A0,AuxCtlHndl(A6)  ; save the handle      _HLock            ; lock the handle      MOVE.L  (A0),AuxCtlPtr(A6)  ; save a pointer      ;; get the WinAuxRec that this control is in and copy its content color to;  the stack frame. ;            CLR.L  -(SP)        ; make a placeholder for a handle      CLR.B  -(SP)        ; room for a boolean result      MOVE.L  CtlHndl(A6),A0    ; get the controlHandle again      MOVE.L  (A0),A0        ; get a pointer      MOVE.L  contrlOwner(A0),-(SP) ; push the owning window pointer      PEA    6(SP)        ; pointer to the placeholder      _GetAuxWin          ; get the window auxRec      ADDQ  #2,SP        ; bag the boolean      MOVE.L  (SP)+,A0      ; get the WinAuxRec handle      MOVE.L  (A0),A0        ; handle-&gt;ptr      MOVE.L  winCTable(A0),A0  ; get the colortable handle      MOVE.L  (A0),A0        ; handle-&gt;ptr            MOVE.W  CTSize(A0),D0    ; get the table count      MULU.W  #8,D0        ; get a table index@1            TST.W  CTTable+value(A0,D0)  ; is it wContentColor (=0)?      BEQ.S  @2        ;       SUBQ  #8,D0        ; move to previous colorSpec      BGE.S  @1          ; and loop back      CLR.L  D0          ; if not found, just use the first one@2      MOVE.L  CTTable+rgb(A0,D0),ContentRGB(A6)  ; copy the color over      MOVE.W  CTTable+rgb+4(A0,D0),ContentRGB+4(A6) ;       @BWSys;; fetch the parameters into registers;      LEA   8(A6),A0      ; get ptr to first parameter      MOVE.L  (A0)+,D3      ; get param in D3      MOVE.W  (A0)+,D0      ; get message      MOVE.L  (A0)+,A3      ; get the control handle      MOVE.W  (A0)+,D6      ; get selection index      MOVE.W  D6,D7        ; remember raw selection code      AND   #7,D6        ; strip high part of selection code      CLR.L  (A0)        ; clear out function result      MOVE.L  (A3),A0       ; get control pointer in A0;; case out on the message number;      ADD   D0,D0        ; double for word index      LEA   GoPushBut,A1    ; get table address      ADD   0(A1,D0),A1     ; compute dispatch address      JSR   (A1)        ; dispatch to appropriate routine;; clean up color stuff                              TST.B  IsColor(A6)      ; are we on a color system?            BEQ.S  @NoColor1      ; if on B&amp;W, then skip            MOVE.L  AuxCtlHndl(A6),A0  ; unlock the CDEF      _HUnlock      PEA    SavFgCol(A6)    ; restore the port colors      _RGBForeColor        ;      PEA    SavBkCol(A6)    ;      _RGBBackColor        ;            _TextMode          ; restore the textMode      &lt;C407/16Nov86&gt; DAF      @noColor1                ; END OF A COLOR-ONLY SECTION;; restore original pen state;      PEA   SavePen(A6)     ; push savePenState      _SetPenState        ; restore original pen state;; we're done -- restore registers and return to caller;DoneP1      MOVEM.L (SP)+,D3-D7/A1-A4  ; restore work registers      UNLK  A6          ; unlink stack frameTenBytExit  MOVE.L  (SP)+,A0      ; get return address      ADD   #12,SP        ; strip parameters      JMP   (A0)        ; return to caller;; PushButProc dispatch table -- entries must be long branches!;GoPushBut      DC.W  DrawPBut-GoPushBut  ; draw is message 0      DC.W  HitPBut-GoPushBut  ; hit test is message 1      DC.W  CalcPBut-GoPushBut  ; calc regions is message 2ButStub   RTS; SetUpColor takes a window part identifier in D0, finds the corresponding;  part in the AuxWinTable (the part code is in the .value field) and returns;  a pointer to its RGB on the stack.  If the requested part is not found,;  the first color table element is used (I'd use frameColor, but that might;  not be there!).  Trashes A0/D0.SetUpColor      MOVE.L  D1,-(SP)      ; save a register      MOVE.L  AuxCtlPtr(A6),A0  ; get the color table pointer      MOVE.W  CTSize(A0),D1    ; get the color table size      MULU  #8,D1        ; convert to color table indexLegalIndex        CMP.W  CTTable+value(A0,D1),D0  ; is this the one?      BEQ.S  FoundIt        ; if equal, then done      SUB.W  #8,D1        ; try the previous one      BGE.S  LegalIndex      ; loop while index positive      MOVEQ  #0,D1        ; OK, use the first oneFoundIt          LEA    CTTable+rgb(A0,D1),A0 ; get the address of the color to use      MOVE.L  A0,D0        ; we'll need A0 in a second      MOVE.L  (SP)+,D1      ; restore the register      MOVE.L  (SP)+,A0      ; get the return address      MOVE.L  D0,-(SP)      ; push the rgb addr on the stack      JMP    (A0)        ; return to caller            ;;  DrawPBut draws the pushButton;DrawPBut      TST.B  ContrlVis(A0)    ; is it visible?      BEQ.S  ButStub       ; if not, we're done;; calculate roundness as function of rectangle size;      BSR   RoundCalc      ; compute roundNess factor in D4            TST.B  IsColor(A6)      ; are we on a color system?      BEQ.S  @NoColor2      ; if on B&amp;W, then skip    ;; if pushbutton, paint bk to body color; if checkmark then erase to window content &lt;C59/30Jun86&gt; DAF;@9      TST.B  D6          ; is it a pushButton?      BEQ.S  @4           ; ; set the window content color to the back for the eraseRRect    &lt;C59/30Jun86&gt; DAF            PEA    ContentRGB(A6)    ; push the pointer to content color      BRA.S  @5      ; set the body color for button                     &lt;C59/30Jun86&gt; DAF@4            MOVE.L  (A3),A0        ; get control rec pointer      MOVE.B  contrlHilite(A0),D0  ; get the hilite byte      SUBQ.B  #1,D0        ; make 0-&gt;$FF      CMP.B  #$FD,D0         ; is the control hilited?      BHS.S  @8          ; no, so continue      MOVEQ  #cTextColor,D0    ; if it is, paint the button in text color      BRA.S  @0@8      MOVEQ  #cBodyColor,D0    ; if its not, then paint body color@0      BSR.S  SetUpColor      ; get info on the stack;; erase the bounding rectangle (if necessary);@5      _RGBBackColor        ; set it      MOVE.L  (A3),A0        ; get controlHandle again@NoColor2                ; END OF A COLOR-ONLY SECTION      LEA   ContrlRect(A0),A4  ; get pointer to bounding rect      TST.B  D6          ; is it a pushButton?      BEQ.S  EraseCBound     ; push buttons are always erased      TST.B  D3          ; draw all?      BNE.S  SkipCErase      ; if not, don't bother to erase;EraseCBound      MOVE.L  A4,-(SP)      ; push rect      MOVE.L  D4,-(SP)      ; push rounding factor            _EraseRoundRect       ; paint it the background color      ;;  save the current font and force the system font;SkipCErase  MOVE.L  GrafGlobals(A5),A0  ; get GrafGlobals base      MOVE.L  ThePort(A0),A0    ; get current port      MOVE.L  txFont(A0),-(SP)  ; remember the font,face      MOVE.W  txSize(A0),-(SP)  ; remember the size      SUBQ  #8,D7        ; was code 8 or greater?      BGE.S  @1          ; if so, use window's font      CLR.L  txFont(A0)      ; force system font, normal face      MOVE  #12,D0        ; assume size = 12      TST.W  ROM85        ; new roms?             &lt;EHB 26Aug85&gt;      BMI.S  @0          ; =&gt; yes, use size = 12       &lt;EHB 26Aug85&gt;      MOVE.W  SysFontSize,D0    ; get default size          &lt;EHB 26Aug85&gt;      BNE.S  @0          ; =&gt; it's 0!                        &lt;EHB 26Aug85&gt;      MOVE.B  FMDefaultSize,D0  ; get default size          &lt;EHB 26Aug85&gt;@0      MOVE.W  D0,txSize(A0)    ; set size of font          &lt;EHB 26Aug85&gt;@1      MOVE.L  ClipRgn(A0),-(SP)  ; push the current clipRgn handle; save old clip region and clip to the bounding rectangle sected with oldClip      CLR.L  -(SP)        ; make space for region handle      _NewRgn           ; allocate a region      MOVE.L  (SP),A2       ; remember region but leave on stack      _GetClip          ; remember the current clipRgn      MOVE.L  (A3),A0       ; get control pointer      PEA   ContrlRect(A0)    ; push pointer to its bounding rect      _ClipRect          ; make that the clipping region      MOVE.L  A2,-(SP)      ; push the old ClipRgn      MOVE.L  4(SP),-(SP)     ; the answer goes into current clip      _SectRgn          ; intersect new and old; Save off some registers for mondo button title calculations, then; set them up for our use      MOVEM.L D4/A2-A3,-(SP)    ; save registers            &lt;EHB 20-May-85&gt;      MOVE.L  (A3),A0       ; get pointer to control      LEA   contrlTitle(A0),A2  ; get title into A2      LEA   contrlRect(A0),A4  ; get rect into A4            &lt;EHB 20-May-85&gt;      MOVEQ  #0,D7        ;                    &lt;EHB 20-May-85&gt;      MOVE.B  (A2),D7       ; get string length into D7       &lt;EHB 20-May-85&gt;      BEQ   NoTitle       ; quick check for nothing        &lt;EHB 20-May-85&gt;; now count the number of lines in the title.  Lines are separated by CR's      MOVEQ  #0,D4        ; save number of lines in D4      &lt;EHB 20-May-85&gt;@2      ADDQ  #1,D4        ; count next line            &lt;EHB 20-May-85&gt;      BSR   Pt2Next       ; point to next line (index in D7)    &lt;EHB 20-May-85&gt;      TST.B  D7          ; D7 &lt; 0 if done            &lt;EHB 20-May-85&gt;      BPL.S  @2          ; =&gt; get next line            &lt;EHB 20-May-85&gt;      MOVE.B  (A2),D7       ; get string length back        &lt;EHB 20-May-85&gt;; now get a font info record on stack, pointer to it in A3      SUBQ  #8,SP        ; make room for 4 INTEGERS        &lt;EHB 20-May-85&gt;      MOVE.L  SP,A3        ; save pointer in A3          &lt;EHB 20-May-85&gt;      MOVE.L  A3,-(SP)      ; push pointer to record        &lt;EHB 20-May-85&gt;      _GetFontInfo        ; and fill the record          &lt;EHB 20-May-85&gt;; Set up D5 to point to the baseline of the last line      BSR   GetHeight      ; get height of line into D0      &lt;EHB 20-May-85&gt;      MULU  D4,D0        ; #lines times height          &lt;EHB 20-May-85&gt;      MOVE.W  bottom(A4),D1    ; get bottom of rect          &lt;EHB 20-May-85&gt;      MOVE.W  D1,D5        ; D5 will be baseline          &lt;EHB 20-May-85&gt;      SUB.W  top(A4),D1      ; get height of rect          &lt;EHB 20-May-85&gt;      SUB.W  D0,D1        ; get unused space            &lt;EHB 20-May-85&gt;      ASR.W  #1,D1        ; and DIV by 2              &lt;EHB 20-May-85&gt;      SUB.W  D1,D5        ; move up from bottom          &lt;EHB 20-May-85&gt;      SUB.W  leading(A3),D5    ; to bottom of descender        &lt;EHB 20-May-85&gt;      SUB.W  descent(A3),D5    ; to first baseline           &lt;EHB 20-May-85&gt;DoNextLine; get the width of the current line into D0      BSR   Pt2Next       ; next line in D7, len in D3      &lt;EHB 20-May-85&gt;      CLR.W  -(SP)        ; make room for result          &lt;EHB 20-May-85&gt;      MOVE.L  A2,-(SP)      ; push title pointer          &lt;EHB 20-May-85&gt;      MOVE.W  D7,D0        ; get our offset into string      &lt;EHB 20-May-85&gt;      ADDQ.B  #2,D0        ; bump past length (or CR)        &lt;EHB 20-May-85&gt;      MOVE.W  D0,-(SP)      ; push true offset into string      &lt;EHB 20-May-85&gt;      MOVE.W  D3,-(SP)      ; push number of bytes          &lt;EHB 20-May-85&gt;      _TextWidth          ; get the string's width                &lt;EHB 20-May-85&gt;      MOVE.W  (SP)+,D0      ; and save result in D0       &lt;EHB 20-May-85&gt;; if it's a checkbox, don't center it, just move to right a little      TST.B  D6          ; is it a check box?      BEQ.S  ElCentro      ; =&gt; no, go center the string      &lt;EHB 20-May-85&gt;; adjust positioning for push button                TST.W  ROM85        ; are we on an old mac          &lt;DAF 30-Mar-87&gt;       BMI.S  LeftBox        ; old mac, so always do left side    &lt;DAF 30-Mar-87&gt;      tst.w   teSysJust               ; right to left?                        &lt;MED 27-Aug-86&gt;          beq.s   LeftBox                 ; no, normal case                       &lt;MED 27-Aug-86&gt;          MOVE.W  right(A4),D1            ; get the right edge                    &lt;MED 27-Aug-86&gt;          SUB.W   left(A4),D1             ; get the width                         &lt;MED 27-Aug-86&gt;          SUB.W   D0,D1                   ; subtract string's width               &lt;MED 27-Aug-86&gt;          sub.w   #18,d1                  ; subtract room for box                 &lt;MED 27-Aug-86&gt;          ADD.W   left(A4),D1             ; and add into left                     &lt;MED 27-Aug-86&gt;          BRA.S   DrawBTitle              ; back to common code                   &lt;MED 27-Aug-86&gt;LeftBox        MOVE.W  Left(A4),D1     ; get the left edge      ADD.W  #18,D1        ; leave room for check box      BRA.S  DrawBTitle      ; back to common codeElCentro      ; center the line in the rect      MOVE.W  right(A4),D1    ; get the right edge      SUB.W  left(A4),D1     ; get the width      SUB.W  D0,D1        ; subtract string's width      ASR.W  #1,D1        ; get centering offset      ADD.W  left(A4),D1     ; and add into leftDrawBTitle      MOVE.W  D1,-(SP)      ; push horizontal position      MOVE.W  D5,-(SP)      ; and vertical position         &lt;EHB 20-May-85&gt;      _MoveTo           ; move the pen there; now that registers are free, push colors on stack   &lt;C59/30Jun86&gt; DAF      TST.B  IsColor(A6)      ; are we on a color system?      BEQ.S  @NoColor4      ; if on B&amp;W, then skip            TST.B  D6          ; is it a check box?      BNE.S  @1          ;       MOVE.L  CtlHndl(A6),A0    ; get the control handle (not A3 in this section)  &lt;DAF 29Apr86&gt;      MOVE.L  (A0),A0       ; get control pointer      MOVE.B  ContrlHilite(A0),D0  ; need to handle the case of 254/5 hiliting      SUBQ  #1,D0        ; make 0 into 255      CMP.B  #$FD,D0        ; is it hilited?            &lt;DAF 29Apr86&gt;      BHS.S  @1          ; if not, go on              &lt;DAF 29Apr86&gt;      MOVE.W  #cBodyColor,D0    ; a button, so set body color      BRA.S  @4          ; go on@1            MOVE.W  #cTextColor,D0    ; set the text color      @4      BSR   SetUpColor      ; deposit appropriate values on stack      _RGBForeColor@NoColor4      MOVE.L  A2,-(SP)      ; point to string            &lt;EHB 20-May-85&gt;      MOVE.W  D7,D0        ; get our offset into string      &lt;EHB 20-May-85&gt;      ADDQ.B  #2,D0        ; bump past length (or CR)        &lt;EHB 20-May-85&gt;      MOVE.W  D0,-(SP)      ; push true offset into string      &lt;EHB 20-May-85&gt;      MOVE.W  D3,-(SP)      ; push length in bytes          &lt;EHB 20-May-85&gt;      _DrawText          ; this is where we draw the line; bump baseline point up to next line, test for end      BSR    GetHeight      ; get line height into D0        &lt;EHB 20-May-85&gt;      SUB.W  D0,D5        ; go up to next base line        &lt;EHB 20-May-85&gt;      TST.B  D7          ; done yet?               &lt;EHB 20-May-85&gt;      BPL    DoNextLine      ; =&gt; nope                &lt;EHB 20-May-85&gt;      ADDQ  #8,SP        ; strip font record           &lt;EHB 20-May-85&gt;NoTitle      MOVEM.L (SP)+,D4/A2-A3    ; and all those registers        &lt;EHB 20-May-85&gt;; restore original font, face and size      MOVE.L  GrafGlobals(A5),A0  ; get GrafGlobals base      MOVE.L  ThePort(A0),A0    ; get current port      MOVE.W  (SP)+,txSize(A0)  ; restore the size      MOVE.L  (SP)+,txFont(A0)  ; restore the font,face;; set the pen color to FrameColor      &lt;C59/30Jun86&gt; DAF;      TST.B  IsColor(A6)      ; are we on a color system?      BEQ.S  @NoColor5      ; if on B&amp;W, then skip            MOVEQ  #cFrameColor,D0    ;      BSR    SetUpColor      ;      _RGBForeColor        ;@NoColor5                ; END OF A COLOR-ONLY SECTION      TST.B   D6          ; is it a checkBox?      BNE   PlotCheck      ; if so, go draw it            MOVE.L  A4,-(SP)      ; push the rectangle pointer      MOVE.L  D4,-(SP)      ; push rounding factor      _FrameRoundRect       ; frame the button;; perform SpecialHilite if necessary;      TST.B  IsColor(A6)      ; are we on a color system?      BEQ.S  @NoColor6      ; if on B&amp;W, then skip            MOVE.L  (A3),A0       ; get control pointer      CMP.B  #$FE,ContrlHilite(A0) ; is it the special hilite state?      BHS.S  SpecialHilite    ; if so, go do it            BRA.S  @Common6      ; and continue...@NoColor6      ;; hilite the button if necessary;      MOVE.L  (A3),A0       ; get control pointer      MOVE.B  ContrlHilite(A0),D0 ; is it hilited?      BEQ.S  DoneDrwBut      ; if not, we're done;      CMP.B  #$FE,D0       ; is it the special hilite state?      BHS.S  SpecialHilite    ; if so, go do it;      MOVE.L  A4,-(SP)      ; push rectangle      MOVE.L  D4,-(SP)      ; push rounding factor      _InverRoundRect       ; hilite by inverting@Common6;; restore original clipping region and we're done;DoneDrwBut      _PenNormal          ; set the pen back to normal      MOVE.L  A2,-(SP)      ; push old clip region      _SetClip          ; restore it      MOVE.L  A2,-(SP)      ; dispose of temporary region      _DisposRgn          ; de-allocate it      RTS             ; all done!;------------; Utility Pt2Next -- Point to next line within the title;    On Entry:  A2    Title pointer;          D7    offset to end of next line to do;    On Exit:  D7    offset to next line-2 (D7&lt;0 if last line);          D3    length of next lineCR      EQU    $0D         ; CR = carriage returnPt2Next      MOVEQ  #0,D3        ; clear out count        &lt;EHB 20-May-85&gt;      TST.B  D7          ; pointing at count?      &lt;EHB 20-May-85&gt;      BEQ.S  @2          ; =&gt; yes, a leading CR      &lt;EHB 20-May-85&gt;@1      CMP.B  #CR,0(A2,D7)    ; is char a CR?         &lt;EHB 20-May-85&gt;      BEQ.S  @2          ; =&gt; yes, all done        &lt;EHB 20-May-85&gt;      ADDQ  #1,D3        ; else bump count by one    &lt;EHB 20-May-85&gt;      SUBQ.B  #1,D7        ; and move back in string    &lt;EHB 20-May-85&gt;      BNE.S  @1          ; =&gt; not end of string      &lt;EHB 20-May-85&gt;@2      SUBQ.B  #1,D7        ; prepare for next string    &lt;EHB 20-May-85&gt;      RTS             ; D7 &lt; 0 if last line      &lt;EHB 20-May-85&gt;;------------; Utility GetHeight -- return in D0 the height of on line;    On Entry:  A3    Font Record;    On Exit:  D0    Line heightGetHeight      MOVEQ  #0,D0        ; clear out height            &lt;EHB 20-May-85&gt;      ADD.W  ascent(A3),D0    ; height = ascent + descent + leading  &lt;EHB 20-May-85&gt;      ADD.W  descent(A3),D0    ;                    &lt;EHB 20-May-85&gt;      ADD.W  leading(A3),D0    ;                    &lt;EHB 20-May-85&gt;      RTS; SpecialHilite handles drawing the disabled buttonSpecialHilite      BSR.S  DisableText      BRA.S  DoneDrwButDisableText      TST.B  IsColor(A6)      ; are we on a color system?      BEQ.S  @NoColor7      ; if on B&amp;W, then skip            TST.B  D6          ; is it a pushbutton?        BNE.S  @NoColor7      ; a checkbox, so go      MOVEQ  #cTextColor,D0    ; set the colors apropos      BSR    SetUpColor      ;      _RGBForeColor        ;      MOVEQ  #cBodyColor,D0    ;      BSR    SetUpColor      ;      _RGBBackColor        ;      @NoColor7                ; END OF A COLOR-ONLY SECTION            MOVE.L  A4,-(SP)      ; push  rectangle      MOVE.L  #$00010003,-(SP)      _InsetRect      MOVE.L  A4,-(SP)      MOVE.L  (A5),A0      PEA   Gray(A0)      _PenPat      MOVE  #patBIC,-(SP)      _PenMode      _PaintRect          ; gray it out      _PenNormal      MOVE.L  A4,-(SP)      MOVE.L  #$FFFFFFFD,-(SP)      _InsetRect      RTS; RoundCalc calculates the rounding factor in D4 based on the control's rectRoundCalc      TST.B   D6          ; is it a checkBox?      BNE.S  CheckRound      ; if so,  special case it;      MOVE.W  ContrlRect+Bottom(A0),D4  ; get bottom coordinate      SUB.W  ContrlRect+Top(A0),D4  ; figure  out vertical height      LSR   #1,D4        ; scale it down by a factor of 2      MOVE  D4,D0        ; fill both halves with it      SWAP  D4          ; get in  high part      MOVE  D0,D4        ; and in  low part      RTS;CheckRound  MOVEQ  #0,D4        ; checkBoxes are  square!      RTS;; HitPBut handles the button hit-test;HitPBut      MOVE.B  ContrlHilite(A0),D4 ; get hiliteState  &lt;EHB 16-May-85&gt;      ADDQ.B  #1,D4        ; is it 255?    &lt;EHB 16-May-85&gt;      BEQ.S  @1          ; if so, skip      CLR.W  -(SP)        ; make room for function result      MOVE.L  D3,-(SP)      ; push the point      PEA   ContrlRect(A0)    ; push address of rect      _PtInRect          ; in the rectangle?      TST.B  (SP)+        ; examine result      BEQ.S  @1          ; if not, we're done      ADDQ.B  #1,D4        ; 254 hiliting?   &lt;EHB 16-May-85&gt;      BEQ.S  Return254      ; =&gt; say it is so  &lt;EHB 16-May-85&gt;      MOVE  #inButton,22(A6)  ; return that it was      TST.B   D6          ; a checkBox?      BEQ.S  @1          ; if not, we're done      ADDQ  #1,22(A6)      ; if so, flag it@1      RTSReturn254      MOVE  #254,22(A6)     ; indicate its 254-disabled      RTS;; CalcPBut returns the bounding region of the button;CalcPBut      TST.B   D6          ; is it a checkBox?      BNE.S  CalcSquare      ; check box bounds are just rects;      BSR.S  RoundCalc      ; calculate rounding factor      _HidePen          ; dont draw anything      _OpenRgn      MOVE.L  A3,A0        ; copy to A0 for HLock      &lt;C424/18Nov86&gt; DAF      _HLock            ; lock it down          &lt;C424/18Nov86&gt; DAF      MOVE.L  (A3),A0       ; get pointer to control      PEA   ContrlRect(A0)    ; push rectangle pointer      MOVE.L  D4,-(SP)      ; push rounding factor      _FrameRoundRect       ; frame the button      MOVE.L  D3,-(SP)      ; push the region      _CloseRgn          ; make the rounded rectangular region      _ShowPen      MOVE.L  A3,A0        ; copy to A0 for HLock      &lt;C424/18Nov86&gt; DAF      _HUnlock          ; unlock the control      &lt;C424/18Nov86&gt; DAF;; set the pattern for indicator dragging;DragGray      MOVE.L  (A5),A0       ; get qDraw globals      LEA   Gray(A0),A0     ; point to gray pattern      MOVE.L  (A0)+,DragPattern  ; move in the 1st half      MOVE.L  (A0),DragPattern+4  ; move in the 2nd half      RTS             ; all done!;CalcSquare      MOVE.L  D3,-(SP)      ; push the region      PEA   ContrlRect(A0)    ; push the rectangle pointer      _RectRgn          ; make a rectangular region      BRA.S  DragGray      ; all done -- go  set drag pattern;; PlotCheck takes care of drawing the actual check box of the check box button.  It; figures out where to draw the box, draws it, and then checks it or not based on; the current value and hilite state of the button;PlotCheck; first set the window content color    &lt;C59/30Jun86&gt; DAF      TST.B  IsColor(A6)      ; are we on a color system?      BEQ.S  @NoColor8      ; if on B&amp;W, then skip            PEA    ContentRGB(A6)      _RGBBackColor        ;@NoColor8                ; END OF A COLOR-ONLY SECTION      SUBQ  #8,SP        ; allocate a rectangle on the stack      MOVE.W  bottom(A4),D0    ; get rect height            &lt;EHB 20-May-85&gt;      MOVE.W  D0,D1        ; save a copy              &lt;EHB 20-May-85&gt;      SUB.W  top(A4),D0      ; get height              &lt;EHB 20-May-85&gt;      SUB.W  #12,D0        ; sub box height            &lt;EHB 20-May-85&gt;      ASR.W  #1,D0        ; div by 2                &lt;EHB 20-May-85&gt;      SUB.W  D0,D1        ; get offset from bottom        &lt;EHB 20-May-85&gt;      MOVE  D1,Bottom(SP)    ; set up the bottom           &lt;EHB 20-May-85&gt;      SUB   #12,D1        ; compute the top            &lt;EHB 20-May-85&gt;      MOVE  D1,Top(SP)      ; set up the top            &lt;EHB 20-May-85&gt;           TST.W  ROM85        ; are we on a 64K ROM Mac?        &lt;DAF 30-Mar-87&gt;      BMI.S  LeftBoxTitle    ; old mac, do it left to right      &lt;DAF 30-Mar-87&gt;      tst.w   teSysJust               ; right to left?                        &lt;MED 27-Aug-86&gt;           beq.s   LeftBoxTitle            ; no, normal case                       &lt;MED 27-Aug-86&gt;          MOVE    Right(A4),D1            ; get left edge of boundsRect           &lt;MED 27-Aug-86&gt;          subq    #2,D1                   ; indent 2 pixels                       &lt;MED 27-Aug-86&gt;          MOVE    D1,Right(SP)            ; that's the left of the checkRect      &lt;MED 27-Aug-86&gt;          sub     #12,D1                  ; compute right edge                    &lt;MED 27-Aug-86&gt;          MOVE    D1,Left(SP)             ; update the right edge                 &lt;MED 27-Aug-86&gt;          bra.s   EraseCheck              ; continue                              &lt;MED 27-Aug-86&gt;          LeftBoxTitle      MOVE  Left(A4),D1     ; get left edge of boundsRect      &lt;EHB 20-May-85&gt;      ADDQ  #2,D1        ; indent 2 pixels            &lt;EHB 20-May-85&gt;      MOVE  D1,Left(SP)     ; that's the left of the checkRect      &lt;EHB 20-May-85&gt;      ADD   #12,D1        ; compute right edge          &lt;EHB 20-May-85&gt;      MOVE  D1,Right(SP)    ; update the right edge         &lt;EHB 20-May-85&gt;EraseCheck;; erase the check box;      MOVE.L  SP,-(SP)      ; push rectangle pointer      _EraseRect          ; erase it;; OK, now we must fill in the checkBox rectangle based on the value and hilite state; of the control;      MOVE.L  (A3),A0       ; get control handle      MOVE.W  ContrlValue(A0),D5  ; get the value      MOVE.B  ContrlHilite(A0),D0 ; is it hilited?      BEQ.S  FrameCheck      ; if not, skip;; its hilited so up the penSize to indicate its hilited;      CMP.B  #$FE,D0       ; disabled?      BLO.S  SkipDis       ; if so,  skip doubling;      BSR   DisableText      BRA.S  FrameCheckSkipDis      MOVE.L  #$00020002,-(SP)      _PenSize          ; up the penSizeFrameCheck      MOVE.L  SP,-(SP)      ; push the rectangle      CMP.B  #2,D6        ; test for radio button      BEQ.S  @1          ; if its a radio button, go do it      _FrameRect          ; frame it      BRA.S  @2@1      _FrameOval@2      _PenNormal;; now we can draw the check if we're supposed to;      LSR   #1,D5        ; check out the low bit of D5      BCC.S  DonePCheck      ; if its off, we're done;      CMP.W  #2,D6        ; test for radio button      BEQ.S  DrawRButton     ; if its a radio button, go do it;      MOVE.L  SP,-(SP)      ; push the rectangle pointer      MOVE.L  OneOne,-(SP)    ; push the inset factor      _InsetRect          ; inset the rectangle      MOVE.L  TopLeft(SP),-(SP)  ; push top left      _MoveTo           ; move to it      MOVE.L  BotRight(SP),-(SP)  ; push bottom right      _LineTo           ; draw one line of the cross;      MOVE  Right(SP),-(SP)   ; push right      MOVE  Top+2(SP),-(SP)   ; push top      SUBQ  #1,(SP)       ; bias the top      _MoveTo           ; move to it      MOVE  Left(SP),-(SP)    ; push left      SUBQ  #1,(SP)       ; bias the left      MOVE  Bottom+2(SP),-(SP)  ; push bottom      _LineTo           ; draw the line      BRA.S  DonePCheck;;  draw the radio button check mark -- a little circle;DrawRButton      MOVE.L  SP,-(SP)      ; push pointer to rect      MOVE.L  #$00030003,-(SP)  ; push inset factor      _InsetRect          ; inset it      MOVE.L  SP,-(SP)      ; push rect again      _PaintOval          ; draw the circle?;DonePCheck      ADDQ  #8,SP        ; pop off the rectangle      BRA   DoneDrwBut      ; all done!      END                                                                                                                                                                                                                                                                                                                                                                           </pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DefProcs/listing1.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DefProcs/listing1.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DefProcs/listing1.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>