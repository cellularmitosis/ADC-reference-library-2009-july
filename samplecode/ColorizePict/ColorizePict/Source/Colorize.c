// routine to colorize a pixmap.  This puts up a dialog with two colored boxes,// click in the box to select a foreground a background image to used to colorize// the picture.//// The image colorization is done using copybits, the color selection is done using// the standard color picker.//// Nick Thompson, June '94#include <Dialogs.h>#include <QDOffscreen.h>#include <PictUtil.h>#include <picker.h>#include <Processes.h>void draw_image(CGrafPtr windowToColorize, RGBColor *fg, RGBColor *bg);pascal Boolean OurFilter(DialogPtr theColorSelectionDialog, EventRecord *event, short *itemHit);void ColorizeImage(WindowPtr imageToColorize);//------------------------// items in the color selection dialogenum {	kColorSelectionDialogOKBtn = 1,	kColorSelectionDialogCancelBtn,	kColorSelectionDialogInfoIcn,	kColorSelectionDialogStaticText1,	kColorSelectionDialogFGColorBox,	kColorSelectionDialogBGColorBox		// we don't care about the rest at this point} ;static const RGBColor	kRGBBlack = {0, 0, 0};static const RGBColor	kRGBWhite = {0xFFFF, 0xFFFF, 0xFFFF};static	RGBColor	theFGColor ;static	RGBColor	theBGColor ;//-----------------------------------------------------------------------------------------void draw_image(	CGrafPtr windowToColorize,     				RGBColor *fg,     				RGBColor *bg ){	CGrafPtr		savedPort ;	GDHandle		oldDevice ;	GWorldPtr		myNewWorld ;	PixMapHandle	myOffPixMap ;		GetGWorld( &savedPort, &oldDevice ) ;		// get the GWorld from the window refcon	if((myNewWorld = (GWorldPtr)GetWRefCon ( (GrafPtr)windowToColorize )) == nil)		return ;			if((myOffPixMap = GetGWorldPixMap( myNewWorld )) == nil )		return ;		// set up the foreground and background colors so 	// that we have everything as expecte.  These are 	// the values passed in.		SetGWorld( myNewWorld, nil ) ;	RGBForeColor( fg ) ;	RGBBackColor( bg ) ;	(void) LockPixels( myOffPixMap ) ;		CopyBits( &((GrafPtr)myNewWorld)->portBits,			  &((GrafPtr)myNewWorld)->portBits,			  &((GrafPtr)myNewWorld)->portRect,			  &((GrafPtr)myNewWorld)->portRect,			  srcCopy,			  nil ) ;			  	(void) UnlockPixels( myOffPixMap ) ;		RGBForeColor( &kRGBBlack ) ;		// ensure the fg and bg colors are 	RGBBackColor( &kRGBWhite ) ;		// as anticipated		SetGWorld( windowToColorize, nil ) ;		InvalRect( &windowToColorize->portRect ) ;	SetGWorld( savedPort, oldDevice ) ;}pascal Boolean OurFilter(DialogPtr theColorSelectionDialog, EventRecord *event, short *itemHit){	ModalFilterUPP 		theProc ;	Boolean				retVal ;		static	Boolean		isDisabled = false ;	OSErr				theErr = noErr ;		// stuff for getditems etc	/*Str255				theItem ;*/	short				iKind;	Handle				iHandle;	Rect				iRect;	Pattern				black;			// get the std filter proc, again this is system 7 specific	// we are usingthe standard filter proc to render the default button.	// in a real app we'd at least need to handle update events in the filter	// proc, in order to redraw the user item, however I'm not doing	// that here because I am very lazy.  You should if you use this approach.		theErr = GetStdFilterProc( &theProc ) ;		if( theErr != noErr )		ExitToShell() ;			// try to call the standard filter, if it handles the event, we don't	if( !(retVal = CallModalFilterProc(theProc, theColorSelectionDialog, event, itemHit)) )	{		switch (event->what) {				case nullEvent:				break;				case keyDown:			case autoKey:				retVal = false;				break ;				case updateEvt:				// set up the foreground color				GetDialogItem ( theColorSelectionDialog, kColorSelectionDialogFGColorBox, &iKind, &iHandle, &iRect) ;							RGBForeColor ( &theFGColor );				FillRect( &iRect, &black) ;								RGBForeColor ( &kRGBBlack );				PenSize( 1,1) ;				InsetRect( &iRect, -4, -4 ) ;				FrameRect( &iRect ) ;				PenNormal() ;				// set up the background color				GetDialogItem ( theColorSelectionDialog, kColorSelectionDialogBGColorBox, &iKind, &iHandle, &iRect) ;				RGBForeColor ( &theBGColor );				FillRect( &iRect , &black) ;								RGBForeColor ( &kRGBBlack );				PenSize( 1,1) ;				InsetRect( &iRect, -4, -4 ) ;				FrameRect( &iRect ) ;				PenNormal() ;								retVal = false;				break ;				default:				retVal = false;				break ;		}	}		return retVal ;}void ColorizeImage( WindowPtr imageToColorize ){	DialogPtr		theColorSelectionDialog ;	GrafPtr			savedPort ;		short			iKind;	Handle			iHandle;	Rect			iRect;	Pattern			black;		RGBColor		savedFGColor ;	RGBColor		savedBGColor ;		OSErr			theErr ;	short			itemHit ;   		Point			where = { 0, 0 } ;		GetPort(&savedPort ) ;			// post the all purpose color dialog!! use this to get the fg and bg colors	// as required by the user		// get the dialog	theColorSelectionDialog = GetNewDialog ( 129, nil, (WindowPtr)-1 );	SetPort( (GrafPtr)theColorSelectionDialog ) ;		// need to ensure the fg and bg colors are filled with approprite colors.	// just use the defaults.	 	GetForeColor( &theFGColor ) ;	savedFGColor = theFGColor ;		GetBackColor( &theBGColor ) ;	savedBGColor = theBGColor ;		GetDialogItem ( theColorSelectionDialog, kColorSelectionDialogFGColorBox, &iKind, &iHandle, &iRect) ;	RGBForeColor ( &theFGColor );	FillRect( &iRect, &black) ;		RGBForeColor ( &kRGBBlack );	PenSize( 1,1) ;	InsetRect( &iRect, -4, -4 ) ;	FrameRect( &iRect ) ;	PenNormal() ;		GetDialogItem ( theColorSelectionDialog, kColorSelectionDialogBGColorBox, &iKind, &iHandle, &iRect) ;	RGBForeColor ( &theBGColor );	FillRect( &iRect , &black) ;		RGBForeColor ( &kRGBBlack );	PenSize( 1,1) ;	InsetRect( &iRect, -4, -4 ) ;	FrameRect( &iRect ) ;	PenNormal() ;			// this is the system 7 way of handling the dialog default item,	// and the cancel button for the dialog.	//	// make sure we are on sys 7 before we get here, or highlight the 	// default item in the regular way and handle key presses for ok and	// cancel in the filterproc.		if((theErr =  SetDialogDefaultItem(theColorSelectionDialog, kColorSelectionDialogOKBtn)) != noErr )		ExitToShell() ;	if((theErr =  SetDialogCancelItem(theColorSelectionDialog, kColorSelectionDialogCancelBtn)) != noErr )		ExitToShell() ;		do {			ModalDialog ( NewModalFilterProc(OurFilter), &itemHit );				switch( itemHit ) {						case kColorSelectionDialogFGColorBox:							if( GetColor( where, "\pEnter the Background color:", &theFGColor, &theFGColor) ) {					// set up the foreground color					GetDialogItem ( theColorSelectionDialog, kColorSelectionDialogFGColorBox, &iKind, &iHandle, &iRect) ;									RGBForeColor ( &theFGColor );					FillRect( &iRect, &black) ;										RGBForeColor ( &kRGBBlack );					PenSize( 1,1) ;					InsetRect( &iRect, -4, -4 ) ;					FrameRect( &iRect ) ;					PenNormal() ;				}								break ;							case kColorSelectionDialogBGColorBox:				// get the users choice				if( GetColor( where, "\pEnter the Background color:", &theBGColor, &theBGColor) ) {									// set up the background color					GetDialogItem ( theColorSelectionDialog, kColorSelectionDialogBGColorBox, &iKind, &iHandle, &iRect) ;						RGBForeColor ( &theBGColor );					FillRect( &iRect , &black) ;										RGBForeColor ( &kRGBBlack );					PenSize( 1,1) ;					InsetRect( &iRect, -4, -4 ) ;					FrameRect( &iRect ) ;					PenNormal() ;				} 								break ;							default:					break ;							}			} while( itemHit != ok && itemHit != cancel) ;	DisposeDialog ( theColorSelectionDialog );			SetPort( (GrafPtr)imageToColorize);	if( itemHit == ok )		draw_image(	(CGrafPtr)imageToColorize,     				&theFGColor,     				&theBGColor) ;	SetPort( savedPort ) ;	}		