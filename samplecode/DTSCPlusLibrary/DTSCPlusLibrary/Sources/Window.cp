/*	File:		Window.cp	Contains:	TWindow is a Window wrapper class that handles most of the basic window functionality. 		 		Window.cp contains the TWindow member functions.	Written by: 		Copyright:	Copyright © 1992-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				8/18/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#ifndef _WINDOW_#include "Window.h"#endif // _________________________________________________________________________________________________________ //// TWindow class member function implementations.// CONSTRUCTORS AND DESTRUCTORS#pragma segment WindowTWindow::TWindow(){	this->Initialize();							// initialize fields to known values		// Create Window.	TEnvironment myEnvironment;					// check out our environment if Color QD is present	if (myEnvironment.HasColorQD())	{		fWindow = ::NewCWindow(NULL, &fRect, fWindowTitle, true, noGrowDocProc, (WindowPtr) - 1L, true, 0L);		fColorWindow = true;	}	else		fWindow = ::NewWindow(NULL, &fRect, fWindowTitle, true, noGrowDocProc, (WindowPtr) - 1L, true, 0L);	ASSERT(fWindow != NULL, "\pProblems with TWindow::TWindow, NewWindow");	fWindowRecord = (WindowPeek)fWindow;		// get ptr to the real window record		}#pragma segment WindowTWindow::TWindow(short windowID)// Create window based on resource ID.{	fColorWindow = false;						// can't assume anythingÉ	// Create Window.	TEnvironment myEnvironment;					// check out our environment if Color QD is present	if (myEnvironment.HasColorQD())	{		fWindow = ::GetNewCWindow(windowID, NULL, (WindowPtr) - 1);		fColorWindow = true;	}	else		fWindow = ::GetNewCWindow(windowID, NULL, (WindowPtr) - 1);	ASSERT(fWindow != NULL, "\pProblems with TWindow::TWindow(ResID), GetNewWindow");	fWindowRecord = (WindowPeek)fWindow;		// get ptr to the real window record		}#pragma segment WindowTWindow::~TWindow()// Default destructor -- get rid of the window memory allocations.{	::DisposeWindow(fWindow);					// dispose our WindowPtr}#pragma segment Windowvoid TWindow::Initialize()// Initialize the window to a known state (title, position).{	Pstrcpy(fWindowTitle, "\pUntitled");		// set default window title	fRect.top = TWindow::kTop;					// set default window rect	fRect.left = TWindow::kLeft;	fRect.bottom = TWindow::kBottom;	fRect.right = TWindow::kRight;	fColorWindow = false;						// can't assume anythingÉ}// MAIN INTERFACE#pragma segment Windowvoid TWindow::Draw()// Draw is an implementation dependent function, you need to override this one// and create your own drawing routines.{}#pragma segment Windowvoid TWindow::DoClick()// DoClick is an implementation dependent function, you need to override this one// and create your own mouse click routines.{}#pragma segment Windowvoid TWindow::Show()// Make window visible.{	::ShowWindow(fWindow);}#pragma segment Windowvoid TWindow::Hide()// Make window invisible.{	::HideWindow(fWindow);}// GET/SET FUNCTIONS#pragma segment WindowWindowPtr TWindow::GetWindowPtr() const// Get the actual windowPtr record.{	return fWindow;}#pragma segment Windowvoid TWindow::SetTitle(const Str255* title)// Set window title.{	Str255 oldTitle;	// Get old title, if still the same, don't bother changing it (less flicker)	::GetWTitle(fWindow, oldTitle);	if (!CompareStr255(&oldTitle, title))		::SetWTitle(fWindow, *title);}#pragma segment Windowvoid TWindow::GetTitle(Str255* result) const// Get window title.{	if (fWindow)								// we have a valid window?		::GetWTitle(fWindow, *result);	else		Pstrcpy(*result, "\p");					// copy in an empty string}#pragma segment WindowRect TWindow::GetExtent() const// Get the internal Rect of window.{	return fWindow->portRect;}#pragma segment WindowRect TWindow::GetFrame() const// Get the frame Rect of window.{	Rect frame;		frame.left = -1;	frame.top = -1;	// Include one pixel for the the frame itself!	frame.right = fWindow->portRect.right - fWindow->portRect.left + 1;	frame.bottom = fWindow->portRect.bottom - fWindow->portRect.top + 1;	return frame;}#pragma segment WindowBoolean TWindow::Contains(Point test) const// Check if point is inside window.{	return (::PtInRgn(test, fWindowRecord->contRgn));}#pragma segment WindowBoolean TWindow::IsColorWindow() const// Return true/false if window is a color grafport based one.{	return fColorWindow;}// _________________________________________________________________________________________________________ ///*	Change History (most recent last):  No		Init.	Date		Comment  1			khs		11/7/92		New file  2			khs		1/7/93		Cleanup*/