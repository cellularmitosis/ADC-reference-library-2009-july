<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Creating a Window(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING203></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-202.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-204.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-188.html"><B>Chapter 4 - Window Manager</B></A> / <A HREF="Toolbox-201.html"><B>Using the Window Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING203-0></A>
<H2><A NAME=MARKER-9-139></A>Creating a Window</H2>
 <A NAME=MARKER-2-63></A>You typically specify the characteristics of your windows--such as their initial size, location, title, and type--in window (<CODE>'WIND'</CODE>) resources. Once you have defined your window resources, you can call the function <CODE>GetNewCWindow</CODE> (or <CODE>GetNewWindow</CODE>) to create windows.<P>
<A NAME=HEADING203-2></A>
<H3>Defining a Window Resource</H3>
 <A NAME=MARKER-2-65></A>You <A NAME=MARKER-2-142></A>typically <A NAME=MARKER-2-88></A>define<A NAME=MARKER-2-361></A> a window resource for each type of window that your application creates. If, for example, your application creates both document windows and special-purpose windows, you would probably define two window resources. Defining your windows in window resources lets you localize your window titles for different languages by changing only the window resources. (You specify the characteristics of alert boxes and dialog boxes with the alert and dialog resources, described in the chapter "Dialog Manager" in this book.)<P>
 <A HREF=#MARKER-9-145>Listing 4-2</A> shows a window resource, in Rez input format, that an application might use to create a document window. The resource specifies the attributes for windows created from the resource of type <CODE>'WIND'</CODE> with resource ID 128. The system software loads the resource into memory immediately after opening the resource file, and the Memory Manager can purge the memory occupied by the resource.<P>
<B>Listing 4-2  <A NAME=MARKER-9-145></A>Rez input for a window (<CODE>'WIND'</CODE>) resource for a document window</B><P>
<PRE>
#define rDocWindow      128
resource 'WIND' (rDocWindow, preload, purgeable) {
      {64, 60, 314, 460},  /*initial window size and location*/
      zoomDocProc,         /*window definition ID: */
                           /* incorporates definition function */
                           /* and variation code*/
      invisible,           /*window is initially invisible*/
      goAway,              /*window has close box*/
      0x0,                 /*reference constant*/
      &quot;untitled&quot;,          /*window title*/
      staggerParentWindowScreen     
                           /*optional positioning specification*/
};
</PRE>
 The four numbers in the first element of this resource specify the upper-left and lower- right corners, in global coordinates, of a rectangle that defines the initial size and placement of the window's content region. Your application can change this rectangle before displaying the window, either programmatically or through an optional positioning code described later in this section. When specifying a window's position on the desktop, remember to leave room for the window's frame and, on the main screen, for the menu bar.<P>
 The second element contains the window's<DFN> definition ID</DFN><A NAME=MARKER-2-203></A><DFN>,</DFN> which specifies both the window definition function that will handle the window and an optional <DFN>variation code</DFN> that defines a window type. If you are using one of the standard window types (described in <A HREF=Toolbox-191.html#MARKER-9-26>"Types of Windows"</A> beginning on <A HREF=Toolbox-191.html#MARKER-9-26>page 4-7</A>), you need to specify only one of the window-type constants listed in <A HREF=Toolbox-293.html#MARKER-9-629>"The Window Resource"</A> beginning on <A HREF=Toolbox-293.html#MARKER-9-629>page 4-124</A>.<P>
 The third element in the window resource specifies whether the window is initially visible or invisible. This element determines only whether the Window Manager displays the window when it first creates it, not whether the window can be seen on the screen. (A window entirely covered by other windows, for example, might be "visible," even though the user cannot see it.) You typically create new windows in an invisible state, build the content area of the window, and then display the completed window by calling <CODE>ShowWindow</CODE> to make it visible.<P>
 The fourth element in the window resource specifies whether the window has a close box. Only some of the standard window types (<CODE>zoomDocProc</CODE>, <CODE>noGrowDocProc</CODE>, <CODE>documentProc</CODE>, <CODE>zoomNoGrow</CODE>, and <CODE>rDocProc</CODE>) support close boxes. The close-box element has no effect if the second field of the resource specifies a window type that does not support a close box. The Window Manager draws the close box when it draws the window frame.<P>
 The fifth element in the window resource is a reference constant, in which your application can store whatever data it needs. When it builds a new window record, the Window Manager stores in the <CODE>refCon</CODE> field whatever value you specify here. You can also put a placeholder here (such as <CODE>0x0</CODE>, in this example) and then set the <CODE>refCon</CODE> field yourself by calling the <CODE>SetWRefCon</CODE> procedure.<P>
 The sixth element in the window resource is a string that specifies the window title.<P>
 The optional seventh element in the window resource specifies a positioning rule that overrides the window position specified by the rectangle in the first element. In the window resource for a document window, you typically specify the positioning constant <CODE>staggerParentWindowScreen</CODE>. For a complete list of the positioning constants and their effects, see <A HREF=Toolbox-293.html#MARKER-9-629>"The Window Resource" beginning on page 4-124</A>.<P>
 The positioning constants are convenient when the user is creating a new document or when you're handling your own dialog boxes and alert boxes. When you're creating a new window to display a previously saved document, however, the new window should appear, if possible, in the same rectangle as the previous window (that is, the window used during the last save). For the rules of window placement, see <A HREF=#MARKER-9-156>"Positioning a Document Window on the Desktop" beginning on page 4-27</A>.<A NAME=MARKER-2-58></A><P>
 Use the function <CODE>GetNewCWindow</CODE> or <CODE>GetNewWindow</CODE> to create<CODE> </CODE>a window from<A NAME=MARKER-2-221></A> a <CODE>'WIND'</CODE> <A NAME=MARKER-9-147></A>resource.<A NAME=MARKER-2-66></A><P>
<A NAME=HEADING203-17></A>
<H3><A NAME=MARKER-9-151></A>Creating a Window From a Resource</H3>
 You typically create a new window every time the user creates a new document, opens a previously saved document, or issues a command that triggers a dialog box.<P>
 You create document windows from a window resource using the function <CODE>GetNewCWindow</CODE> or <CODE>GetNewWindow</CODE>. (Whenever Color QuickDraw is available, use <CODE>GetNewCWindow</CODE> to create color windows, whether or not a color monitor is currently installed. A color window record is the same size as a window record, and <CODE>GetNewCWindow</CODE> returns a pointer of type <CODE>WindowPtr</CODE>, so most code can handle color windows and monochrome windows identically.)<P>
 You can allow <CODE>GetNewCWindow</CODE> to allocate the memory for your window record. You can maintain more control over memory use, however, by allocating the memory yourself from a block allocated for such purposes during your own initialization routine, and then passing the pointer to <CODE>GetNewCWindow</CODE>.<P>
 You typically create the scroll bars from control (<CODE>'CNTL'</CODE>) resources at the time that you create a document window and then display them when you make the window visible.<P>
 <A HREF=#MARKER-9-153>Listing 4-3</A> illustrates an application-defined procedure, <CODE>DoNewCmd</CODE>, which SurfWriter calls when the user chooses New from the File menu. Windows are typically invisible when created and displayed only after all elements are in <A NAME=MARKER-2-152></A>place.<P>
<B>Listing 4-3  <A NAME=MARKER-9-153></A><A NAME=MARKER-21-154></A>Creating a new window</B><P>
<PRE>
PROCEDURE DoNewCmd (newDocument: Boolean; VAR window: WindowPtr);
VAR
   myData:        MyDocRecHnd;   {the document's data record}
   windStorage:   Ptr;           {memory for window record}
   destRect,                     {rectangles for creating }
   viewRect:      Rect;          { TextEdit edit record}
   good:          Boolean;       {success flag}
BEGIN
   window := NIL;                   {no window created yet}
   good := FALSE;                   {no success yet}
   {allocate memory for window record from previously allocated block}
   windStorage := MyPtrAllocationProc;
   IF windStorage &lt;&gt; NIL THEN       {memory allocation succeeded}
   BEGIN                            {create window}
      IF gColorQDAvailable THEN
         window := GetNewCWindow(rDocWindow, windStorage, WindowPtr(-1))
      ELSE
         window := GetNewWindow(rDocWindow, windStorage, WindowPtr(-1));
   END;
                                    {create document record}
   myData := MyDocRecHnd(NewHandle(SIZEOF(MyDocRec)));
   IF (window &lt;&gt; NIL) AND (myData &lt;&gt; NIL) THEN  {window record and document }
   BEGIN                                        { record both allocated}
      SetPort(window);              {set current port}
      HLock(Handle(myData));        {lock handle to doc record}
      SetWRefCon(window, LongInt(myData));   {link document record to window}
      WITH window^, myData^^ DO     {fill in document record}
      BEGIN
         MyGetTERect(window, viewRect); {set up a viewRect for TextEdit}
         destRect := viewRect;
         destRect.right := destRect.left + kMaxDocWidth;
         editRec := TENew(destRect, viewRect);
         IF editRec &lt;&gt; NIL THEN           {it's a good edit record}
         BEGIN
            good := TRUE;                    {set success flag}
            MyAdjustViewRect(editRec);       {set up edit record}
            TEAutoView(TRUE, editRec);
         END

         ELSE
            good := FALSE;             {clear success flag}
         IF good THEN
         BEGIN                         {create scroll bars}
            vScrollBar := GetNewControl(rVScroll, window);
            hScrollBar := GetNewControl(rHScroll, window);
            good := (vScrollBar &lt;&gt; NIL) AND (hScrollBar &lt;&gt; NIL);
         END;
         IF good THEN                  {it's a good document}
         BEGIN
            MyAdjustScrollBars(window, FALSE);  {adjust scroll bars}
            fileRefNum := 0;           {no file yet}
            windowDirty := FALSE;      {no changes yet}
            IF newDocument THEN        {if it's a new (empty) document, }
               ShowWindow(window);     { make it visible}
         END;
      END;     {end of WITH statement}
      HUnlock(Handle(myData));         {unlock document record}
   END;     {end of IF (window &lt;&gt; NIL) AND (myData &lt;&gt; NIL)}
   IF NOT good THEN
   BEGIN
      IF windStorage &lt;&gt; NIL THEN  {memory for window record was allocated}
         DisposePtr(windStorage); {dispose of it}
      IF myData &lt;&gt; NIL THEN       {memory for document record was allocated}
      BEGIN
         IF myData^^.editRec &lt;&gt; NIL THEN  {edit record was allocated}
            TEDispose(myData^^.editRec);  {dispose of it}
         DisposeHandle(Handle(myData));   {dispose of document record}
      END;
      IF window &lt;&gt; NIL THEN      {window pointer exists, but it's invalid}
         CloseWindow(window);    {clean up window pointer}
      window := NIL;             {set window to NIL to indicate failure}
   END;
END; {DoNewCmd}
</PRE>
 The <CODE>DoNewCmd</CODE> procedure first sets the window pointer and success flags to show <BR>that a valid window doesn't yet exist. Then it calls the application-defined function <CODE>MyPtrAllocationProc</CODE>, which allocates memory for a window record from a block <BR>set aside during program initialization for that purpose. If <CODE>MyPtrAllocationProc</CODE> successfully allocates memory and returns a valid pointer, <CODE>DoNewCmd</CODE> creates a window, specifying the <CODE>'WIND'</CODE> resource with resource ID 128, as specified by the constant <CODE>rDocWindow</CODE>. Using this window resource (defined in <A HREF=#MARKER-9-145>Listing 4-2</A> on <A HREF=#MARKER-9-145>page 4-22</A>), the Window Manager creates an invisible window of type <CODE>zoomDocProc</CODE>. Because <BR>the <CODE>behind</CODE> parameter to <CODE>GetNewCWindow</CODE> or <CODE>GetNewWindow</CODE> has the value <CODE>WindowPtr(-1)</CODE>, the Window Manager places the new window in front of all others <BR>on the desktop.<P>
 The <CODE>DoNewCmd</CODE> procedure then creates a document record. It locks the document record in memory while manipulating it, sets the <CODE>refCon</CODE> field in the window record so that it points to the document record, and fills in the document record. While filling in the document record, <CODE>DoNewCmd</CODE> sets up a TextEdit record to hold the user's data. If that succeeds, <CODE>DoNewCmd</CODE> sets up horizontal and vertical scroll bars. If that succeeds, <CODE>DoNewCmd</CODE> adjusts the scroll bars (see the chapter "Control Manager" in this book for the application-defined procedure <CODE>MyAdjustScrollbars</CODE>) and fills in the remaining parts of the document record. If the window is being created to display a new document, that is, if no user data needs to be read from a disk, <CODE>DoNewCmd</CODE> calls the <CODE>ShowWindow</CODE> procedure to make the window visible immediately. <P>
 If your window resource specifies that a new window is visible, <CODE>GetNewCWindow</CODE> displays the window immediately. If you're creating a document window, however, you're more likely to create the window in an invisible state and then make it visible when you're ready to display it.<P>
<UL>
<LI>If you're creating a window because the user is creating a new document, you can display the window immediately by calling the procedure <CODE>ShowWindow</CODE> to make the window frame visible. This change in visibility adds to the update region and triggers an update event. Your application then invokes its own procedure for drawing the content region in response to the update event.
<LI>If you're creating a new window to display a saved document, you must retrieve the user's data before displaying it. (See <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I> for information about reading saved files.) If possible, the size and location of the window that displays the document should be the same as when the document was last saved. (See the next section, <A HREF=#MARKER-9-156>"Positioning a Document Window on the Desktop,"</A> for a discussion of window placement.) Once you have positioned the window and set up its content region, you can make the window visible by calling <CODE>ShowWindow</CODE>, which triggers an update event. Your application then invokes its own procedure for drawing the content region.<A NAME=MARKER-2-64></A><P>
</UL>
<A NAME=HEADING203-30></A>
<H3><A NAME=MARKER-9-156></A>Positioning a Document Window on the Desktop</H3>
 <A NAME=MARKER-2-67></A>Your goal in <A NAME=MARKER-2-158></A>positioning a window on the desktop is to place it where the user expects it. For a new document, this usually means just below and to the right of the last document window in which the user was working. For a saved document, it usually means the location of the document window when the document was last saved (if it was saved on a computer with the same screen configuration). This section describes the placement of document windows. The chapter "Dialog Manager" in this book describes the placement of alert boxes and dialog boxes. See Macintosh Human Interface Guidelines for a complete description of window placement.<A NAME=MARKER-2-73></A><P>
 On Macintosh computers with a single screen of known size, positioning windows <BR>is fairly straightforward. You position the first new document window on the upper-left corner of the desktop. Open each additional new document window with its upper-<BR>left corner slightly below and to the right of the upper-left corner of its predecessor. <A HREF=#MARKER-9-160>Figure 4-15</A> illustrates how to position multiple documents on a single screen.<P>
<B>Figure 4-15  <A NAME=MARKER-9-160></A>Document window positions on a single screen</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/WM-L-18.jpg"><P>
 If the user closes one or more document windows, display subsequent windows in the "empty" positions before adding more positions below and to the right. <A HREF=#MARKER-9-161>Figure 4-16</A> illustrates how you fill in an empty position when the user opens a new document after closing one created earlier.<P>
<B>Figure 4-16  <A NAME=MARKER-9-161></A>"Filling in" an empty document window position</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/WM-L-22.jpg"><P>
 <A NAME=MARKER-9-162></A>On computers with multiple monitors, window placement depends on a number <BR>of factors:<P>
<UL>
<LI>the number of screens available and their dimensions
<LI>the location of the main screen--that is, the screen that contains the menu bar
<LI>the location of the screen on which the user was most recently working<P>
</UL>
 In general, you place the first new document window on the main screen, and you place subsequent document windows on the screen that contains the largest portion of the most recently active document window. That is, if you display a blank document window when the user starts up your application, you place the window on the main screen. If the user moves the window to another screen and then creates another new document, you place the new document window on the other screen. Although the user is free to place windows so that they cross screen boundaries, you should never display a new window that spans multiple screens.<P>
 When the user opens a saved document, you replicate the size and location of the window in which the document was last saved, if possible.<P>
 The Window Manager recognizes a set of positioning constants in the window <BR>resource that let you position new windows automatically. You typically use the <BR>constant <CODE>staggerParentWindowScreen</CODE> for positioning document windows. The<CODE> staggerParentWindowScreen</CODE> constant specifies the basic guidelines for document window placement: When creating windows from a template that includes <A NAME=MARKER-2-68></A><CODE>staggerParentWindowScreen</CODE>, the Window Manager places the first window in <BR>the upper-left corner of the main screen. It places subsequent windows with their upper-left corners 20 pixels to the right and 20 pixels below the upper-left corner <BR>of the last window in which the user was working. <A HREF=#MARKER-9-166>Figure 4-17</A> illustrates how <BR>the Window Manager positions a new document window when the <CODE>staggerParentWindowScreen</CODE> specification is in effect and the user has been <BR>working in a window off the main screen.<A NAME=MARKER-2-67></A><P>
 If the user moves or closes a window that occupies one of the interim positions, and the window template specifies <CODE>staggerParentWindowScreen</CODE>, the Window Manager uses the "empty" slot for the next new window created before moving further down and to the right.<P>
 For a complete list of the positioning constants and their effects, see <A HREF=Toolbox-293.html#MARKER-9-629>"The Window Resource" beginning on page 4-124</A>.<P>
 You can usually use the <CODE>staggerParentWindowScreen</CODE> positioning constant when creating a window that is to display a new document. You must perform your own window-placement calculations, however, when opening saved documents and when zooming windows.<A NAME=MARKER-9-213></A><P>
 When the user saves a document, the document window can be in one of two states: the <DFN>user state</DFN> or the <DFN>standard state.</DFN><P>
<B>Figure 4-17  <A NAME=MARKER-9-166></A>Document window positions on multiple screens</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/WM-L-21.jpg"><P>
 The <B>user state</B> is the last size and location the user established for the window.<P>
 <A NAME=MARKER-2-91></A>The <B>standard state</B> is what your application determines is the most convenient size for the window, considering the function of the document and the screen space available. For a more complete description of the standard state, see <A HREF=Toolbox-209.html#MARKER-9-225>"Zooming a Window" beginning on page 4-47</A>. Your application typically calculates the standard state each time the user zooms to that state.<A NAME=MARKER-2-26></A><P>
 The user and standard states are stored in the state data record, whose handle appears in the <CODE>dataHandle</CODE> field of the window record.<P>
<PRE>
TYPE WStateData = 
   RECORD
      userState:  Rect;    {size and location established by 
user}
      stdState:   Rect;    {size and location established by }
                           { application}
   END;
</PRE>
 When the user saves a document, you must save the user state rectangle and the state of the window (that is, whether the window is in the user state or the standard state). Then, when the user opens the document again later, you can replicate the window's status. You typically store the state data as a resource in the resource fork of the document file. <P>
 <A HREF=#MARKER-9-169>Listing 4-4</A> illustrates an application-defined data structure for storing the window's user rectangle and state.<P>
<B>Listing 4-4  Application-defined data structure for storing a window's state data<A NAME=MARKER-9-169></A></B><P>
<PRE>
TYPE MyWindowState =
   RECORD
      userStateRect: Rect;    {user state rectangle}
      zoomState:     Boolean; {window state: TRUE = standard; }
                              {              FALSE = user}
   END;
MyWindowStatePtr = ^MyWindowState;
MyWindowStateHnd = ^MyWindowStatePtr;
</PRE>
 This structure translates into an application-defined resource that is stored in the resource fork of the document when the user saves the document.<P>
 <EM><A HREF=#MARKER-9-171>Listing 4-5</A> shows an application-defined routine for saving a document's state data. The SurfWriter application calls the procedure <CODE>MySaveWindowPosition when the user saves a document.<A NAME=MARKER-2-170></A></CODE></EM><P>
<B>Listing 4-5  <A NAME=MARKER-9-171></A>Saving a document window's position</B><P>
<PRE>
PROCEDURE MySaveWindowPosition (myWindow: WindowPtr;
                                 myResFileRefNum: Integer);
VAR
   lastWindowState:  MyWindowState;
   myStateHandle:    MyWindowStateHnd;
   curResRefNum:     Integer;
BEGIN
   {Set user state provisionally and determine whether window is zoomed.}
   lastWindowState.userStateRect := WindowPeek(myWindow)^.contRgn^^.rgnBBox;
   lastWindowState.zoomState := EqualRect(lastWindowState.userStateRect,
                                           MyGetWindowStdState(myWindow));
   {if window is in standard state, then set the window's user state from }
   { the userState field in the state data record}
   IF lastWindowState.zoomState THEN      {window was in standard state}
      lastWindowState.userStateRect := MyGetWindowUserState(myWindow);
   curResRefNum := CurResFile;   {save the refNum of current resource file}
   UseResFile(myResFileRefNum);  {set the current resource file}
   myStateHandle := MyWindowStateHnd(Get1Resource(rWinState,
                                                   kLastWinStateID));

   IF myStateHandle &lt;&gt; NIL THEN        {a state data resource already exists}
   BEGIN                               {update it}
      myStateHandle^^ := lastWindowState;
      ChangedResource(Handle(myStateHandle));
   END
   ELSE                                {no state data has yet been saved}
   BEGIN                               {add state data resource}
      myStateHandle := MyWindowStateHnd(NewHandle(SizeOf(MyWindowState)));
      IF myStateHandle &lt;&gt; NIL THEN
      BEGIN
         myStateHandle^^ := lastWindowState;
         AddResource(Handle(myStateHandle), rWinState, kLastWinStateID,
                     'last window state');
      END;
   END;
   IF myStateHandle &lt;&gt; NIL THEN
   BEGIN
      UpdateResFile(myResFileRefNum);
      ReleaseResource(Handle(myStateHandle));
   END;
   UseResFile(curResRefNum);
END;
</PRE>
 The <CODE>MySaveWindowPosition</CODE> procedure first determines whether the window is in the user state or the standard state by setting its own user state field from the bounding rectangle of the window's content region and comparing that rectangle with the user state stored in the state data record. (If the two match, the window is in the user state; if not, the standard state.) If the window is in the standard state, the procedure replaces its own user state data with the rectangle stored in the <CODE>userState</CODE> field of the state data record. The rest of the procedure saves the application-defined state data record in the resource fork of the document.<P>
 When creating a new window to display a saved document, SurfWriter restores the saved user state data and recalculates the standard state. Before using the saved rectangle, however, SurfWriter verifies that the location is reachable on the desktop. (If the user saves a document on a computer equipped with multiple monitors and then opens it later on a system with only one monitor, for example, the saved window location could be entirely or partially off the screen.)<P>
 <A HREF=#MARKER-9-172>Listing 4-6</A> on the next page shows <CODE>MySetWindowPosition</CODE>, the application-<BR>defined routine that SurfWriter calls when the user opens a saved document. The <CODE>MySetWindowPosition</CODE> procedure retrieves the document's saved state data and <BR>then calls another application- defined routine, <CODE>MyVerifyPosition</CODE>, to verify <BR>that the saved location is practical.<P>
<B>Listing 4-6  <A NAME=MARKER-9-172></A>Positioning the window when the user opens a saved document</B><P>
<PRE>
PROCEDURE MySetWindowPosition (myWindow: WindowPtr);
VAR
   myData:              MyDocRecHnd;
   lastUserStateRect:   Rect;
   stdStateRect:        Rect;
   curStateRect:        Rect;
   myRefNum:            Integer;
   myStateHandle:       MyWindowStateHnd;
   resourceGood:        Boolean;
   savePort:            GrafPtr;
   myErr:               OSErr;
BEGIN
   myData := MyDocRecHnd(GetWRefCon(myWindow));    {get document record}
   HLock(Handle(myData));        {lock the record while manipulating it}
   {open the resource fork and get its file reference number}
   myRefNum := FSpOpenResFile(myData^^.fileFSSpec, fsRdWrPerm);
   myErr := ResError;
   IF myErr &lt;&gt; noErr THEN
      Exit(MySetWindowPosition);
   {get handle to rectangle that describes document's last window position}
   myStateHandle := MyWindowStateHnd(Get1Resource(rWinState,
                                                   kLastWinStateID));
   IF myStateHandle &lt;&gt; NIL THEN                 {handle to data succeeded}
   BEGIN    {retrieve the saved user state}
      lastUserStateRect := myStateHandle^^.userStateRect;
      resourceGood := TRUE;
   END
   ELSE
   BEGIN
      lastUserStateRect.top := 0;   {force MyVerifyPosition to calculate }
      resourceGood := FALSE;        { the default position}
   END;
   {verify that user state is practical and calculate new standard state}
   MyVerifyPosition(myWindow, lastUserStateRect, stdStateRect);
   IF resourceGood THEN                   {document had state resource}
      IF myStateHandle^^.zoomState THEN   {if window was in standard state }
         curStateRect := stdStateRect     { when saved, display it in }
                                          { newly calculated standard state}
      ELSE                 {otherwise, current state is the user state}
         curStateRect := lastUserStateRect
   ELSE                                   {document had no state resource}
      curStateRect := lastUserStateRect;  {use default user state}
   {move window}
   MoveWindow(myWindow, curStateRect.left, curStateRect.top, FALSE);
   {Convert to local coordinates and resize window.}
   GetPort(savePort);
   SetPort(myWindow);
   GlobalToLocal(curStateRect.topLeft);
   GlobalToLocal(curStateRect.botRight);
   SizeWindow(myWindow, curStateRect.right, curStateRect.bottom, TRUE);
   IF resourceGood THEN       {reset user state and standard }
   BEGIN                   { state--SizeWindow may have changed them}
      MySetWindowUserState(myWindow, lastUserStateRect);
      MySetWindowStdState(myWindow, stdStateRect);
   END;
   ReleaseResource(Handle(myStateHandle));         {clean up}
   CloseResFile(myRefNum);
   HUnLock(Handle(myData));
END;
</PRE>
 The <CODE>MyVerifyPosition</CODE> routine, not shown here, compares the saved location against available screen space. (See <A HREF=Toolbox-209.html#MARKER-9-231>Listing 4-12</A> on <A HREF=Toolbox-209.html#MARKER-9-231>page 4-48</A> for a strategy for comparing the saved rectangle with the available screen space.) <CODE>MyVerifyPosition</CODE> alters the user state rectangle, if necessary (using the same size, if possible, but placing it on available screen space) and calculates a new standard state for displaying the window on the screen containing the user state.<P>
 After determining valid user and standard state rectangles, the procedure <CODE>MySetWindowPosition</CODE> sets a temporary positioning rectangle to the appropriate <BR>size and location, based on the state of the document's window when the document <BR>was saved. The <CODE>MySetWindowPosition</CODE> procedure then calls the Window Manager procedures <CODE>MoveWindow</CODE> and <CODE>SizeWindow</CODE> to establish the window's location and <BR>size before cleaning up.<A NAME=MARKER-9-173></A><P>
 The SurfWriter application calls <CODE>MySetWindowPosition</CODE> from its routine for opening saved documents, after reading the document's data from its data fork. <A HREF=#MARKER-9-174>Listing 4-7</A> shows the application-defined <CODE>DoOpenFile</CODE> function that SurfWriter calls when the user opens a saved document.<P>
<B>Listing 4-7  <A NAME=MARKER-9-174></A>Opening a saved document</B><P>
<PRE>
FUNCTION DoOpenFile (mySpec: FSSpec): OSErr;
VAR
   myWindow:      WindowPtr;
   myData:        MyDocRecHnd;
   myFileRefNum:  Integer;
   myErr:         OSErr;

BEGIN
   DoNewCmd(FALSE, myWindow);    {FALSE tells DoNewCmd not to }
                                 { show the window}
   IF myWindow = NIL THEN
   BEGIN
      DoOpenFile := kOpenFileError;
      Exit(DoOpenFile);
   END;
   SetWTitle(myWindow, mySpec.name);
   {open the file's data fork, passing the file spec-- }
   { FSpOpenDF returns a file reference number}
   myErr := FSpOpenDF(mySpec, fsRdWrPerm, myFileRefNum);
   IF (myErr &lt;&gt; noErr) AND (myErr &lt;&gt; opWrErr) THEN {open failed}
   BEGIN                                           {clean up}
      DisposeWindow(myWindow);
      DoOpenFile := myErr;
      Exit(DoOpenFile);
   END;
   {get a handle to the window's document record}
   myData := MyDocRecHnd(GetWRefCon(myWindow));
   myData^^.fileRefNum := myFileRefNum;   {save file ref num}
   myData^^.fileFSSpec := mySpec;         {save fsspec}
   myErr := DoReadFile(myWindow);         {read file's data}
   {retrieve saved state data and establish valid position}
   MySetWindowPosition(myWindow);
   {MyResizeWindow invalidates the whole portRgn, guaranteeing }
   { an update event--the window's contents are redrawn then}
   MyResizeWindow(myWindow);
   ShowWindow(myWindow);                  {show window}
   DoOpenFile := myErr;
END;
</PRE>
 <CODE>DoOpenFile</CODE> first calls the application-defined procedure <CODE>DoNewCmd</CODE> to create a new window, suppressing the immediate display of the window. (<A HREF=#MARKER-9-153>Listing 4-3</A> on page <A HREF=#MARKER-9-153>page 4-24</A> illustrates the procedure <CODE>DoNewCmd</CODE>.) Then <CODE>DoOpenFile</CODE> sets the window <BR>title to the name of the document file and reads in the data. Then it calls <CODE>MySetWindowPosition</CODE> to determine where to place the new window. After establishing a valid position, <CODE>DoOpenFile</CODE> calls the application-defined routine <CODE>MyResizeWindow</CODE> (shown in <A HREF=Toolbox-210.html#MARKER-9-239>Listing 4-14</A> on <A HREF=Toolbox-210.html#MARKER-9-239>page 4-53</A>) to set up the content region <BR>in the new dimensions, and then it finally makes the window visible.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-202.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-204.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
