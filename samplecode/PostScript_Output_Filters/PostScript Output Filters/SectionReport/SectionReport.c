/***	File:			SectionReport.c****	Description:	C source for the SectionReport filter.	****	Version:		1.0		****	Copyright 1999 Apple Computer. All rights reserved.****	You may incorporate this sample code into your applications without**	restriction, though the sample code has been provided "AS IS" and the**	responsibility for its operation is 100% yours.  However, what you are**	not permitted to do is to redistribute the source as "ABC Sample Code"**	after having made changes. If you're going to re-distribute the source,**	we require that you make it clear in the source that the code was**	descended from Apple Sample Code, but that you've made changes.***/#include <FixMath.h>#include <stdio.h>#include <string.h>#include "PSOutputFilters.h"#include "PSSectionInfo.h"#include "PSLogFolder.h"#if qDebug#include <Types.h>#include <Traps.h>#include <stddef.h>#include <OSUtils.h>#define ckLine(line)	#line#define ckLine2(line)	ckLine(line)#define ckAssert(cond)	 	if(!(cond)) DebugStr("\pFailed " #cond ":"__FILE__ " " ckLine2(__LINE__))#else#define ckAssert(cond)		((void)0)			#endif/*** Private Macros ***/#define Unused(x)	((void) x)#define FixedToFloat(a) ((float)(a) / fixed1)#define FIXED2INT(i)		((short)((i)>>16))/*** Private Variable Types ***//**/typedef struct FilterData{	SInt32	lastFilteredMsgId;		// to keep track of the last PSPosition id that we've seen	SInt16	fileRef;				// the fRef of our our open log file}FilterData;/*** Private Prototypes ***/static OSStatus logDSC(SInt16 fRef, PSSection section, PSSubsection subsection, void *info);static void concatResourceData(char *theString, DSCStructuredResourceData *theData);static OSStatus myWrite(short fRef, char *formatString);/*** Private Variables ***//*** Code ***/OSStatus psOutputFilterPreFlight(PSOutputFilterRef filter, Collection jobInfo, Handle papaH, void **refconP)/*	psOutputFilterPreFlight is called by PrintingLib to see if the filter wants to be	included in the filter chain for the current job. For this filter,	as long as we can allocate open our log file and	allocate our private data we want to be part of the chain.*/{	OSStatus err = noErr;	FilterData *filterDataP;	FSSpec mySpec;	Unused(filter);	Unused(papaH);	filterDataP = (FilterData *)NewPtrClear(sizeof(FilterData));		// this initializes the lastFilteredMsgId to 0	if(filterDataP){		/*			Build a fileSpec corresponding to an appropriate name for our log file. We'll use			the suffix '.dsc'.		*/		err = psMakeLogFileSpec(jobInfo, &mySpec, "\p.dsc");					if(!err){			/*				This creates an appropriately serialized filename should a log file already				exist with the input name. We pass false to ensure that an existing file				is not deleted.			*/			err = psMakeNumberedFilename(&mySpec, NULL, false);			if(!err){				// create and open the data fork of the file.				err = HCreate(mySpec.vRefNum, mySpec.parID, 								mySpec.name, 'MPS ', 'TEXT');				if(!err)					err = HOpenDF(mySpec.vRefNum, mySpec.parID, mySpec.name, fsWrPerm, &(filterDataP->fileRef));			}		}		if(err){			if(filterDataP)				DisposePtr((Ptr)filterDataP);			filterDataP = NULL;			}	}else		err = MemError();		*refconP = filterDataP;			return err;	}OSStatus psOutputFilterPostFlight(PSOutputFilterRef filter, void *refcon)/*		PrintingLib calls this routine when our filter is being removed from 	the filter output chain. At this point we need to clean up.	Here we deallocate the memory we've allocated during our execution.*/{	FilterData *filterDataP = (FilterData *)refcon;	Unused(filter);		if (filterDataP) {		FSClose(filterDataP->fileRef);		DisposePtr((Ptr)filterDataP);	}		return noErr;}OSStatus psOutputFilterWrite(PSOutputFilterRef filter, void *refcon, const void *data, long nBytes, const PSPosition *pos)/*	Filter the PostScript data being sent through us.*/{	FilterData *filterDataP = (FilterData *)refcon;	OSStatus err = noErr;		// Only look at new message IDs. 	if (filterDataP->lastFilteredMsgId != pos->id) {		filterDataP->lastFilteredMsgId = pos->id;		err = logDSC(filterDataP->fileRef, pos->section, pos->subsection, pos->info);	}	if(!err)		err = psWriteNextFilter(filter, data, nBytes, pos);		return err;}static OSStatus logDSC(SInt16 fRef, PSSection section, PSSubsection subsection, void *info){	OSStatus err = noErr;	Boolean dataToWrite = true;	char formatString[256];	StringPtr p;	char *sectionStr;		switch(subsection){		case kSubPSAdobeEPS:		case kSubPSAdobeQuery:		case kSubPSAdobe:			ckAssert(info != NULL);			if(info){				switch(section){					case kSectAnon:						sectionStr = "Anon";						break;					case kSectQueryJob:						sectionStr = "Query";						break;					case kSectCoverPage:						sectionStr = "CoverPage";						break;					case kSectJob:						sectionStr = "Job";						break;					case kSectPeek:						sectionStr = "Peek";						break;					default:						sectionStr = "Unknown";						break;				}				if(subsection == kSubPSAdobe)					sprintf(formatString, "%%!PS-Adobe-%.1f		(%s)", FixedToFloat(*(Fixed *)info), sectionStr);				else{					if(subsection == kSubPSAdobeQuery)						sprintf(formatString, "%%!PS-Adobe-%.1f Query		(%s)", FixedToFloat(*(Fixed *)info), sectionStr);					else{						if(subsection == kSubPSAdobeEPS)							sprintf(formatString, "%%!PS-Adobe-%.1f EPSF-%.1f		(%s)", FixedToFloat(((EPSFVersion *)info)->dscVersion), 								FixedToFloat(((EPSFVersion *)info)->epsfVersion), sectionStr);						else							ckAssert(false);					}				}			}			break;		case kSubTitle:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%Title: (%#s)", info);			break;		case kSubTrailer:			ckAssert(info == NULL);			sprintf(formatString, "%%%%Trailer");			break;		case kSubBeginSetup:			ckAssert(info == NULL);			sprintf(formatString, "%%%%BeginSetup");			break;		case kSubEndSetup:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndSetup");			break; 		case kSubEndComments:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndComments");			break;		case kSubBoundingBox:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%BoundingBox: %hd %hd %hd %hd", 							((DSCBBox *)info)->llx, 							((DSCBBox *)info)->lly,							((DSCBBox *)info)->urx,							((DSCBBox *)info)->ury						);			}			break;		case kSubBeginFeature:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%BeginFeature: *%#s %#s", 							((DSCFeature *)info)->feature, 							((DSCFeature *)info)->option						);			}			break;		case kSubEndFeature:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndFeature");			break;		case kSubIncludeFeature:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%IncludeFeature: *%#s %#s", 							((DSCFeature *)info)->feature, 							((DSCFeature *)info)->option);			}			break;		case kSubRBIBeginNonPPDFeature:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%RBIBeginNonPPDFeature: %#s %#s", 							((DSCFeature *)info)->feature, 							((DSCFeature *)info)->option);			}			break;		case kSubRBIEndNonPPDFeature:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIEndNonPPDFeature");			break;		case kSubRBIIncludeNonPPDFeature:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%RBIIncludeNonPPDFeature: %#s %#s", 							((DSCFeature *)info)->feature, 							((DSCFeature *)info)->option);			}			break;		case kSubStartNup:		case kSubIncludeStartNup:			ckAssert(info != NULL);			if(info){				DSCNupData *nupdata = (DSCNupData *)info;				StringPtr directionStr;				StringPtr acrossStr;				StringPtr frameWidthStr;				Str63 rotationStr;				ckAssert(nupdata->size == sizeof(DSCNupData));				if(nupdata->numXpages != 1 || nupdata->numYpages != 1){					switch (nupdata->acrossBeforeDown){						case 0:							acrossStr = "\pDown Before Across";							break;													case 1:							acrossStr = "\pAcross Before Down";							break;						default:							ckAssert(false);							acrossStr = "\pUp Down: ¥¥¥BOGUS DATA";							break;							}										switch (nupdata->layoutDirection){						case 0:							directionStr = "\pLeft To Right, ";							break;													case 1:							directionStr = "\pRight To Left, ";							break;						default:							ckAssert(false);							directionStr = "\pDirection: ¥¥¥BOGUS DATA, ";							break;					}					sprintf((char *)rotationStr, " rotation %.1f degrees, ", FixedToFloat(nupdata->rotation));								}else{					acrossStr = "\p";					directionStr = "\p";					rotationStr[0] = 0;				}									if(nupdata->numframes > 0){					switch (nupdata->framewidth){						case -1:							frameWidthStr = "\p";							break;													case 1:							frameWidthStr = "\pThin frames, ";							break;						case 4:							frameWidthStr = "\pHairline frames, ";							break;						default:							ckAssert(false);							frameWidthStr = "\pFrame width: ¥¥¥BOGUS DATA, ";							break;					}				}else{					frameWidthStr = "\p";				}								if(subsection == kSubStartNup){					sprintf(formatString, "%% startNup invocation - numXPages %ld, numYPages %ld,%s %ld frames, %#s%#s%#s",						nupdata->numXpages, nupdata->numYpages, rotationStr, nupdata->numframes, 						frameWidthStr, directionStr, acrossStr 					);				}else{					sprintf(formatString, "%%RBIIncludeStartNup - numXPages %ld, numYPages %ld,%s %ld frames, %#s%#s%#s",						nupdata->numXpages, nupdata->numYpages, rotationStr, nupdata->numframes, 						frameWidthStr, directionStr, acrossStr 					);				}			}			break;				case kSubDocProcessColors:			ckAssert(info != NULL);			if(info){				DSCProcessColors *processColors = (DSCProcessColors *)info;				ckAssert(processColors->size == sizeof(DSCProcessColors));				sprintf(formatString, "%%%%DocumentProcessColors:%s%s%s%s", 					processColors->cyan ? " Cyan" : "",					processColors->magenta ? " Magenta" : "",					processColors->yellow ? " Yellow" : "",					processColors->black ? " Black" : "");			}			break;				case kSubNupFinalPage:			ckAssert(info == NULL);			sprintf(formatString, "%%finalpage");			break;				case kSubFor:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%For: (%#s)", info);			break;		case kSubPage:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%Page: %ld %#s", 						((DSCPage *)info)->ordinal, 						((DSCPage *)info)->label);			break;		case kSubIncludeFont:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%IncludeFont: %#s", 						((DSCData *)info)->u.structuredResourceData.u.instanceName);			break;		case kSubBeginFont:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%BeginFont: %#s", 						((DSCData *)info)->u.structuredResourceData.u.instanceName);			break;		case kSubEndFont:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndFont");			break;		case kSubIncludeResource:			ckAssert(info != NULL);			if(info){				if(!((DSCData *)info)->structured)					sprintf(formatString, "%%%%IncludeResource: %#s %#s", 					((DSCData *)info)->u.unstructuredResourceData.resourceType,					((DSCData *)info)->u.unstructuredResourceData.data);				else{					sprintf(formatString, "%%%%IncludeResource: %#s %#s",							((DSCData *)info)->u.structuredResourceData.resourceType, 							((DSCData *)info)->u.structuredResourceData.u.instanceName						);				}			}			break;		case kSubBeginResource:			ckAssert(info != NULL);			if(info){				if(!((DSCData *)info)->structured)					sprintf(formatString, "%%%%BeginResource: %#s %#s", 					((DSCData *)info)->u.unstructuredResourceData.resourceType,					((DSCData *)info)->u.unstructuredResourceData.data);				else{					sprintf(formatString, "%%%%BeginResource: %#s %#s",							((DSCData *)info)->u.structuredResourceData.resourceType, 							((DSCData *)info)->u.structuredResourceData.u.instanceName						);				}			}			break;		case kSubDocMedia:													ckAssert(info != NULL);			if(info){				if(!((DSCData *)info)->structured)					sprintf(formatString, "%%%%DocumentMedia: %#s", 					((DSCData *)info)->u.unstructuredData);				else{					ckAssert( ((DSCData *)info)->u.documentMedia.size == sizeof(DSCDocumentMedia));					sprintf(formatString, "%%%%DocumentMedia: (%#s) %.1f %.1f %.1f (%#s) (%#s)",							((DSCData *)info)->u.documentMedia.mediaName, 							FixedToFloat(((DSCData *)info)->u.documentMedia.width), 							FixedToFloat(((DSCData *)info)->u.documentMedia.height), 							FixedToFloat(((DSCData *)info)->u.documentMedia.weight), 							((DSCData *)info)->u.documentMedia.color, 							((DSCData *)info)->u.documentMedia.type 						);				}			}			break;		case kSubADOImageableArea:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%ADO_ImageableArea: %.1f %.1f %.1f %.1f",					FixedToFloat(((DSCFixedBBox *)info)->llx), 					FixedToFloat(((DSCFixedBBox *)info)->lly), 					FixedToFloat(((DSCFixedBBox *)info)->urx), 					FixedToFloat(((DSCFixedBBox *)info)->ury) );			break;																			case kSubBeginDoc:			ckAssert(info != NULL);			if(info){				if(!((DSCData *)info)->structured)					sprintf(formatString, "%%%%BeginDocument: %#s %#s", 					((DSCData *)info)->u.unstructuredResourceData.resourceType,					((DSCData *)info)->u.unstructuredResourceData.data);				else{					DSCDocument *theDocument = (DSCDocument *)&(((DSCData *)info)->u.structuredResourceData.u.document);					sprintf(formatString, "%%%%BeginDocument: (%#s) %.1f (%#s)",  theDocument->name,  								FixedToFloat(theDocument->version), theDocument->type);				}			}			break;		case kSubRouting:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%Routing: (%#s)", info);			break;		case kSubEndDoc:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndDocument");			break;		case kSubDocFonts:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%DocumentFonts: ");				myWrite(fRef, formatString);				concatResourceData(formatString, &( ((DSCData *)info)->u.structuredResourceData));			}			break;		case kSubDocFontsAtEnd:			ckAssert(info == NULL);			sprintf(formatString, "%%%%DocumentFonts: (atend)");			break;		case kSubDocNeededFonts:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%DocumentNeededFonts: ");				myWrite(fRef, formatString);				concatResourceData(formatString, &( ((DSCData *)info)->u.structuredResourceData));			}			break;		case kSubDocNeededFontsAtEnd:			ckAssert(info == NULL);			sprintf(formatString, "%%%%DocumentNeededFonts: (atend)");			break;		case kSubDocSuppliedFonts:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%DocumentSuppliedFonts: ");				myWrite(fRef, formatString);				concatResourceData(formatString, &( ((DSCData *)info)->u.structuredResourceData));			}			break;		case kSubDocSuppliedFontsAtEnd:			ckAssert(info == NULL);			sprintf(formatString, "%%%%DocumentSuppliedFonts: (atend)");			break;		case kSubDocSuppliedRes:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%DocumentSuppliedResources: ");				myWrite(fRef, formatString);				if( ((DSCData *)info)->structured){					// structured resource data. For now only structure data is the instanceName type of data (font or Font)					sprintf(formatString, "%#s ", &(((DSCData *)info)->u.structuredResourceData.resourceType));	// emit the resource type					myWrite(fRef, formatString);					concatResourceData(formatString, &( ((DSCData *)info)->u.structuredResourceData) );				}else{					//unstructured resource data					sprintf(formatString, "%#s %#s", 					((DSCData *)info)->u.unstructuredResourceData.resourceType,									(((DSCData *)info)->u.unstructuredResourceData.data));				}			}			break;		case kSubDocSuppliedResAtEnd:			ckAssert(info == NULL);			sprintf(formatString, "%%%%DocumentSuppliedResources: (atend)");			break;		case kSubDocNeededRes:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%DocumentNeededResources: ");				myWrite(fRef, formatString);				if( ((DSCData *)info)->structured){					// structured resource data. For now only structure data is the instanceName type of data (font or Font)					sprintf(formatString, "%#s ", &(((DSCData *)info)->u.structuredResourceData.resourceType));	// emit the resource type					myWrite(fRef, formatString);					concatResourceData(formatString, &( ((DSCData *)info)->u.structuredResourceData) );				}else{					//unstructured resource data					sprintf(formatString, "%#s %#s", 					((DSCData *)info)->u.unstructuredResourceData.resourceType,									(((DSCData *)info)->u.unstructuredResourceData.data));				}			}			break;		case kSubDocNeededResAtEnd:			ckAssert(info == NULL);			sprintf(formatString, "%%%%DocumentNeededResources: (atend)");			break;		case kSubRBIDocSuppliedFonts:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%RBIDocumentSuppliedFonts: ");				myWrite(fRef, formatString);				concatResourceData(formatString, &( ((DSCData *)info)->u.structuredResourceData));			}			break;		case kSubRBIDocSuppliedFontsAtEnd:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIDocumentSuppliedFonts: (atend)");			break;		/* this implementation of continue expects that the continued data is either structured or unstructured resource			data as opposed to any other type of data. To really do this correctly we'd need to look at the continuedSection			field of the DSCContinuationData to see what type of data it really is.				*/		case kSubContinue:			ckAssert(info != NULL);			if(info){				sprintf(formatString, "%%%%+ ");				myWrite(fRef, formatString);				if( ((DSCContinuationData *)info)->data.structured){					PSSubsection continuedSection = ((DSCContinuationData *)info)->continuedSection;					// structured resource data. For now only structure data is the instanceName type of data (font or Font)					if(continuedSection == kSubDocNeededRes || continuedSection == kSubDocSuppliedRes){						sprintf(formatString, "%#s ", &(((DSCContinuationData *)info)->data.u.structuredResourceData.resourceType));	// emit the resource type						myWrite(fRef, formatString);					}					concatResourceData(formatString, &( ((DSCContinuationData *)info)->data.u.structuredResourceData) );				}else{					//unstructured resource data					sprintf(formatString, "%#s %#s", 					&(((DSCContinuationData *)info)->data.u.unstructuredResourceData.resourceType),					&(((DSCContinuationData *)info)->data.u.unstructuredResourceData.data));				}			}			break;		case kSubPages:			ckAssert(info != NULL);			if(info){				if(*(SInt32 *)info > 0){					sprintf(formatString, "%%%%Pages: %ld", *(SInt32 *)info);				}else{					sprintf(formatString, "%%%%Pages: (atend)");							}			}			break;		case kSubBeginFile:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%BeginFile: %#s", info);			break;		case kSubEndFile:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndFile");			break;		case kSubRBINumCopies:			ckAssert(info != NULL);			if(info){				if(*(SInt32 *)info >= 0){					sprintf(formatString, "%%RBINumCopies: %ld", *(SInt32 *)info);				}			}			break;		case kSubLangLevel:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%LanguageLevel: %ld", *(SInt32 *)info);			break;		case kSubDocData:			ckAssert(info != NULL);			if(info){				switch(*(DSCDocumentData *)info){					default:					case kDSCUnknownDocumentData:						p = "\p¥¥¥ BAD DATA ¥¥¥";						break;					case kDSCClean7Bit:						p = "\pClean7Bit";						break;					case kDSCClean8Bit:						p = "\pClean8Bit";						break;										case kDSCBinary:						p = "\pBinary";						break;				}				sprintf(formatString, "%%%%DocumentData: %#s", p);			}			break;		case kSubPageOrder:			ckAssert(info != NULL);			if(info){				switch(*(DSCPageOrder *)info){					default:					case kDSCUknownPageOrder:						p = "\p¥¥¥ BAD DATA ¥¥¥";						break;										case kDSCAtEndPageOrder:						p = "\p(atend)";						break;					case kDSCPageOrderAscend:						p = "\pAscend";						break;					case kDSCPageOrderDescend:						p = "\pDescend";						break;										case kDSCPageOrderSpecial:						p = "\pSpecial";						break;				}				sprintf(formatString, "%%%%PageOrder: %#s", p);			}			break;		case kSubProofMode:			ckAssert(info != NULL);			if(info){				switch(*(DSCProofMode *)info){					case kDSCUknownProofMode:						p = "\p¥¥¥ BAD DATA ¥¥¥";						break;					case kDSCProofModeTrustMe:						p = "\pTrustMe";						break;					case kDSCProofModeSubstitute:						p = "\pSubstitute";						break;										case kDSCProofModeNotify:						p = "\pNotify";						break;				}				sprintf(formatString, "%%%%ProofMode: %#s", p);			}			break;		case kSubDate:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%CreationDate: (%#s)", info);			break;		case kSubCreator:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%Creator: (%#s)", info);			break;		case kSubBeginDefaults:			ckAssert(info == NULL);			sprintf(formatString, "%%%%BeginDefaults");			break;		case kSubEndDefaults:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndDefaults");					break;		case kSubBeginProlog:			ckAssert(info == NULL);			sprintf(formatString, "%%%%BeginProlog");			break;		case kSubEndProlog:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndProlog");					break;		case kSubPageTrailer:			if(info != NULL)				sprintf(formatString, "%%%%PageTrailer (for page number %ld)", *(SInt32 *)info);			else				sprintf(formatString, "%%%%PageTrailer");			break;		case kSubEOFNoJobTermination:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EOF    (with no job termination)");					break;		case kSubTerminateJob:			ckAssert(info == NULL);			sprintf(formatString, "%%job termination");					break;		case kSubEOF:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EOF    (with job termination)");					break;		case kSubRBIPCFileName:			ckAssert(info != NULL);			if(info){				StringPtr filename = (StringPtr)info;				sprintf(formatString, "%%RBIPCFileName: (%#s)", filename);			}			break;					case kSubRBINupNess:			ckAssert(info != NULL);			if(info){				DSCNupNess *nupness = (DSCNupNess *)info;				sprintf(formatString, "%%RBINupNess: %ld %ld",nupness->pagesX, nupness->pagesY);			}			break;		case kSubRBIProduct:			ckAssert(info != NULL);			if(info){				StringPtr filename = (StringPtr)info;				sprintf(formatString, "%%RBIPPDFileVersion: (%#s)", filename);			}			break;		case kSubViewOrientation:			ckAssert(info != NULL);			if(info){				DSCViewingOrientation *viewingOrientation = (DSCViewingOrientation *)info;				ckAssert(viewingOrientation->size == sizeof(DSCViewingOrientation));				if(viewingOrientation->isAtEnd)					sprintf(formatString, "%%%%ViewingOrientation: (atend)");				else					sprintf(formatString, "%%%%ViewingOrientation: %d %d %d %d", viewingOrientation->a,							viewingOrientation->b, viewingOrientation->c, viewingOrientation->d);			}			break;		case kSubBeginColorspace:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%%%BeginResource: ColorSpace (%#s)", info);			break;					case kSubEndResource:			ckAssert(info == NULL);			sprintf(formatString, "%%%%EndResource");			break;		case kSubInfoPages:																	ckAssert(info != NULL);			if(info)				sprintf(formatString, "/Pages %ld def", *(SInt32 *)info);			break;		case kSubInfoTitle:																	ckAssert(info != NULL);			if(info)				sprintf(formatString, "/Title(%#s)def", info);			break;					case kSubInfoCreator:																ckAssert(info != NULL);			if(info)				sprintf(formatString, "/Creator(%#s)def", info);			break;		case kSubInfoDate:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "/CreationDate(%#s)def", info);			break;		case kSubInfoFor:																	ckAssert(info != NULL);			if(info)				sprintf(formatString, "/For(%#s)def", info);			break;		case kSubBeginBitmapFont:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%RBIBeginBitmapFont: %#s", info);			break;		case kSubBeginTrueTypeFont:			ckAssert(info != NULL);			if(info)				sprintf(formatString, "%%RBIBeginTrueTypeFont: %#s", info);			break;		case kSubEndBitmapFont:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIEndBitmapFont");			break;		case kSubEndTrueTypeFont:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIEndTrueTypeFont");			break;		case kSubBeginTrueTypeScaler:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIBeginFontRasterizer: TrueType");			break;		case kSubEndTrueTypeScaler:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIEndFontRasterizer: TrueType");			break;		case kSubPageOrientation:		case kSubOrientation:			ckAssert(info != NULL);			if(info){				switch(*(DSCOrientation *)info){					default:					case kDSCUknownOrientation:						p = "\p¥¥¥ BAD DATA ¥¥¥";						break;					case kDSCAtEndOrientation:						p = "\p(atend)";						break;					case kDSCPortraitOrientation:						p = "\pPortrait";						break;										case kDSCLandscapeOrientation:						p = "\pLandscape";						break;				}				sprintf(formatString, "%%%%%s: %#s", (subsection == kSubOrientation) ? "Orientation" : "PageOrientation", p);			}			break;		case kSubBeginPageSetup:			if(info != NULL)				sprintf(formatString, "%%%%BeginPageSetup (for page number %ld)", *(SInt32 *)info);			else				sprintf(formatString, "%%%%BeginPageSetup");			break;		case kSubEndPageSetup:			if(info != NULL)				sprintf(formatString, "%%%%EndPageSetup (for page number %ld)", *(SInt32 *)info);			else				sprintf(formatString, "%%%%EndPageSetup");			break;		case kSubBeginPageSlotInvocation:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIBeginPageSlotInvocation");			break;		case kSubEndPageSlotInvocation:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIEndPageSlotInvocation");			break;		case kSubIncludePageSlotInvocation:			ckAssert(info == NULL);			sprintf(formatString, "%%RBIIncludePageSlotInvocation");			break;		case kSubPageGStateSetup:			ckAssert(info == NULL);			sprintf(formatString, "%%page gstate setup");			break;		case kSubPageMTSMatrixSetup:			ckAssert(info == NULL);			sprintf(formatString, "%%mTS matrix setup");			break;		case kSubPSBegin:			ckAssert(info == NULL);			sprintf(formatString, "psb");			break;		case kSubPSEnd:			ckAssert(info == NULL);			sprintf(formatString, "pse");			break;			case kSubPSBeginNoSave:			ckAssert(info == NULL);			sprintf(formatString, "%%psbegin-nosave");			break;		case kSubPSEndNoSave:			ckAssert(info == NULL);			sprintf(formatString, "%%psend-nosave");			break;			case kSubPageSaveLevelSetup:			ckAssert(info == NULL);			sprintf(formatString, "%%page level save");			break;		case kSubPageSaveLevelRestore:			ckAssert(info == NULL);			sprintf(formatString, "%%page level restore");			break;			case kSubShowpage:			ckAssert(info == NULL);			sprintf(formatString, "%%showpage");			break;			case kSubStatusSection:			dataToWrite = false;			break;		case kSubSetJobStatusStr:			ckAssert(info != NULL);			if(info){				DSCJobStatus *dscJobStatus = (DSCJobStatus *)info;				ckAssert(dscJobStatus->size == sizeof(DSCJobStatus));				if(dscJobStatus->currentPage <= 0)					sprintf(formatString, "(%#s)setjob", dscJobStatus->username);				else{					if(dscJobStatus->totalPages < 1)						sprintf(formatString, "(%#s; page: %ld)setjob", 									dscJobStatus->username, dscJobStatus->currentPage);					else						sprintf(formatString, "(%#s; page: %ld of %ld)setjob", 										dscJobStatus->username, 										dscJobStatus->currentPage, 										dscJobStatus->totalPages);				}			}			break;		case kSubAnnotateFontKey:			ckAssert(info != NULL);			if(info){				DSCFontAnnotation *dscFontAnnotation = (DSCFontAnnotation *)info;				ckAssert(dscFontAnnotation->size == sizeof(DSCFontAnnotation));				sprintf(formatString, "%%RBIFontKey: (%#s) %dpoint %#s", 								dscFontAnnotation->fontName, FIXED2INT(dscFontAnnotation->pointSize), 								dscFontAnnotation->styleString);			}			break;		default:			if(subsection == kSubAnon)				dataToWrite = false;			else				sprintf(formatString, "Subsection not handled: %ld, infofield: %ld", subsection, info);					break;	}	if(dataToWrite){		strcat(formatString, "\r");		err = myWrite(fRef, formatString);	}		ckAssert(err == noErr);			return err;}static OSStatus myWrite(short fRef, char *formatString){	OSStatus err = noErr;	SInt32 nBytes = (SInt32)strlen(formatString);	err = FSWrite(fRef, &nBytes, formatString);	return err;} static void concatResourceData(char *theString, DSCStructuredResourceData *theData){	short bytesRemaining = 255;			// the max of the string (leave room for last space)	Byte *nextByte = (unsigned char *)theString;	Str63 *nextInstance = (Str63*) &(theData->u.instanceName);	short count = theData->count;	while(count--){		short bytesToCopy = (*nextInstance)[0];		if(bytesToCopy <= bytesRemaining){			memcpy(nextByte, ((Byte *)nextInstance)+1, bytesToCopy);		// copy the data			nextByte += bytesToCopy;			memcpy(nextByte, " ", 1);		// add a space			nextByte++;						// include the space			bytesRemaining -= bytesToCopy + 1;			nextInstance++;		}	}	if(bytesRemaining > 0)*nextByte = 0;		// terminate the string with a NULL (it is a C string)}