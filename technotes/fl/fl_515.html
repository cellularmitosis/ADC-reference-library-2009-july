<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note FL515: File Manager File Handling Q&amp;As</title>    <meta name="keywords" content="Mac OS 8 File Manager AllocContig ioNamePtr Read PBHCopyFile dataVerErr">    <meta name="Description" content="Technical Note FL515: This Technical Note contains a collectionof archived Q&amp;As relating to File Manager File Handling--questionssent the Developer Support Center (DSC) along with answersfrom the DSC engineers. Archived questions include: The Limitson file locking and unlocking on the Macintosh; What happensto AllocContig if the logical EOF is moved to somewhere insidethe clump of a file which is evenly divided into clumps;How to open files with driver like names; Should ioNamePtrpoint to a Str255 or Str63; How to read from a non-Macintoshformatted disk; How to get an application to open any file;and Can the Macintosh File System be used at Interrupt Time."><meta name="categories" content="Files"><meta name="week-posted" content="Sep 27, 1999 - Oct 1, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002466" title="File Manager File Handling Q&As"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxFileManagement-date.html">File Management</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note FL515</div>
<div id="pageheadsub">File Manager File Handling Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext">   <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id ="introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specific topic--questions sent the Developer Support Center (DSC) along with answers from the DSC engineers. Current Q&amp;As can be found on the <a href="../../qa/index.html">Macintosh Technical Q&amp;As web site</A>.</P><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><a name="Section1"></a><h2>Locking and unlocking a Macintosh file</h2><P>Date Written: 3/12/92</P><P>Last reviewed: 6/14/93</P><P>Is there any way to lock or protect a file in such a way that theuser cannot unlock it with the Get Info window? I realize it's possible to set a resource map to be <code>readOnly</code>, and to (sort of) <code>resProtect</code> individualresources, and that you can lock the file name as part of the Finder attributes, but what about the File is Locked bit?</P><P>___</P><P>There really isn't a way to lock a file on the Macintosh so thatit can't be unlocked by a user with the right tools. All you can dois prevent someone from deleting or changing something by accident(they'll have to unlock the file or resource). It's kind of likelocking your house or car - it prevents the casual bypasser fromgetting in, but not someone who <I>really</I> wants in.</P><P>The Finder locks or unlocks a file (via the Get Info window) withthe File Manager <code>PBHSetFLock</code> or <code>PBHRstFLock</code> routines. <code>PBHSetFLock</code> and<code>PBHRstFLock</code> manipulate bit 0 (the file locked bit) in the <code>flFlags</code>byte of the file's directory entry. When you call the <code>PBGetFInfo</code>or <code>PBGetCatInfo</code> routines on a file, those routines return the stateof the file locked bit in the <code>ioFlAttrib</code> field of the parameterblock. The documentation for <code>PBSetFInfo</code> and <code>PBSetCatInfo</code> in <I>InsideMacintosh</I> Volume IV is wrong; you cannot set the attributes of afile or a folder (this is unrelated to your question, but you alsocannot set a file's clump size with <code>PBSetCatInfo</code>). The only fileattribute you can manipulate through the File Manager is the lockedbit. Some bits in a directory's attributes can be manipulatedwhen our file server software is running (see the next paragraph).</P><P>If Macintosh File Sharing or AppleShare 3.0 are running and avolume is sharable (it can be seen by the owner remotely), then thefile server software adds additional privileges to the File Managerprivileges. Under both versions of the file server software, you canlock folders so that they cannot be moved, renamed or deleted (seethe Macintosh Technote "File Sharing and Shared Folders" for moreinformation in this area) by remote users. With AppleShare 3.0, youcan also "copy protect" (or unprotect) files with one of two servercontrol calls. The copy protection only keeps the Finder from copyingthe file; any other copy utility can still copy the file.</P><P>You already know about resource locking, so that probably covers everything.</P><h2>Allocate, AllocContig, and Macintosh file allocation</h2><P>Date Written: 5/20/92</P><P>Last reviewed: 6/14/93</P><P>When we allocate space for a new file using <code>AllocContig</code> with anargument in multiples of clump size, we should be grabbing wholeclumps at a time so that file length (and physical EOF) will be amultiple of clump size. What happens if we truncate a file by movingthe logical EOF somewhere inside a clump? <I>Inside Macintosh</I>says disk sectors are freed at the allocation block level, so wecould have a file whose physical EOF isn't a multiple of clump size,right? Does <code>AllocContig</code> guarantee that the new bytes added arecontiguous with the end of the existing file, or only that the newlyadded bytes are contiguous among themselves? If the logical andphysical EOFs aren't the same, does AllocContig subtract thedifference before grabbing the new bytes, or do we get the extrabytes (between EOFs) as a bonus?</P><P>___</P><P>You can create a file whose physical size isn't a multiple of theclump size, if you try. When the file shrinks, the blocks are freedat the allocation level, without regard for the clump size.Therefore, if you set the logical EOF to a smaller value, you cancreate a file of any physical length.</P><P>There's no guarantee that the allocated bytes will becontiguous with the current end of the file. The decisions that fileallocation makes are as follows:</P><P>* It always attempts to allocate contiguously, regardless ofwhether you're explicitly doing a contiguous allocation. (If itcan't, it fails rather than proceeding if doing an AllocContig.)</P><P>* It always attempts to keep the added space contiguous with theexisting space, but it will forgo this before it will fragment thecurrent allocation request (regardless of whether you're callingAllocate or AllocContig).</P><P>So these are the actions that file allocation will take:</P><ol type="1">	<li>Allocate contiguous space immediately after the current physical end of file.</li>	<li>Allocate contiguous space separated from the current physical EOF.</li>	<li>Fail here if allocating contiguously.</li>	<li>Allocate fragmented space, where the first fragment follows the physical EOF.</li>	<li>Allocate fragmented space somewhere on the volume.</li></ol><P>You don't get "extra" space with AllocContig. It just does a basicallocation but makes sure any added blocks are contiguous.PBAllocContig does not guarantee that the space requested will beallocated contiguously. Instead, it first grabs all the roomremaining in the current extent, and then guarantees that theremaining space will be contiguous. For example, if you have a 1-bytefile with a chunk size of 10K and you try to allocate 20K, 10K-1bytes will be added to the current file; the remaining 10K+1 bytesare guaranteed to be contiguous.</P><h2>Use OpenDF to open files with driver-like names</h2><P>Date Written: 9/25/92</P><P>Last reviewed: 11/1/92</P><P>Our program has a problem with filenames that start with a period.During an Open call, if the filename starts with a period, the Opencode calls the Device Manager (for drivers and DAs) instead of theFile Manager. However, we've seen other applications that cansuccessfully open these files. What's the secret? How do weopen files that otherwise look (from the name) like drivers?</P><P>___</P><P>The Open trap is shared between the Device Manager and the FileManager. When Open is called, it checks first to see whether you'retrying to open a driver. Driver names always start with a period. Ifyou can, avoid using filenames that begin with a period. DTS Technote 1089 <a href="../tn/tn1089.html"> <U>HFS Elucidations Revisited</U></A> discusses this conflict. The secret to opening those files is using the new Open Data Fork functions available with System 7 -- <code>FSpOpenDF</code>, <code>HOpenDF</code>, and <code>PBHOpenDF</code>. These functions bypass the driver name check and go right to the File Manager. Here's the code we use to open a file:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>err := HOpenDF(vRefNum, dirID, fileName, permission, refNum);IF (err = paramErr) THEN {HOpenDF call isn't available}  err := HOpen(vRefNum, dirID, fileName, permission, refNum);                      {try again with old HOpen call}</pre>	</TD></TR></TABLE></CENTER><P>Try this and your problem should go away under System 7. The coderetries with the regular Open call (which uses the same inputparameters), so this code can be used in programs that run under bothSystem 6 and System 7.</P><h2>Should ioNamePtr point to Str255 or Str63?</h2><P>Date Written: 7/15/92</P><P>Last reviewed: 9/15/92</P><P>The Macintosh Technical Note <A HREF = "fl_23.html"><U>"Setting ioNamePtr in File Manager Calls"</U></A> says that <code>ioNamePtr</code> needs topoint either to nil or to storage for a Str255. This contradicts theTechnical Note "Searching Volumes--Solutions and Problems," whichgives an example of a recursive indexed search using <code>PBGetCatInfo</code>.The example uses a Str63. Which Technical Note is correct?</P><P>___</P><P>To be generically correct, <code>ioNamePtr</code> should point to a Str255.However, in the case of <code>PBGetCatInfo</code> and other calls that return afilename (or a directory name), a Str63 is sufficient. The reasonsare tied to the history of the Macintosh file system.</P><P>MFS, the original Macintosh file system, supported filenamelengths of up to 255 characters. However, the Finder on those systemssupported filename lengths up to only 63 characters and, in fact,developers were warned to limit filename lengths to fewer than 64characters (see page II-81 of <I>Inside Macintosh</I> Volume II).</P><P>HFS, the hierarchical file system (in every Macintosh ROM sincethe Macintosh Plus), further limited filename lengths to 31characters. If you mount an MFS disk while running HFS, the old MFScode is called to handle the operation. So, the file system can stillcreate and use files with long filenames on MFS volumes.</P><P>When the System 7 file system was being designed, Engineering hadto decide what size string to use in <code>FSSpec</code> records. The decision wasto use a Str63 instead of a Str31 to be able to support long MFSfilenames, and to use a Str63 instead of a Str255 because there wereprobably very few filenames with over 63 characters (remember, theold Finder limited filenames to 63 characters). Using a Str63 insteadof a Str255 saves 192 bytes per FSSpec record.</P><P>So, we recommend that you use at least a Str63 for filenames, asin "Searching Volumes--Solutions and Problems." If you need tomanipulate the filename in any way after you've gotten the name--forexample, to concatenate it with another string--you might want to usea Str255.</P><P><B>Note</B>: Even though the System 7 file system supportsfilenames longer than 31 characters on MFS volumes, the System 7Finder does not. In fact, the System 7 Finder currently crashes ifyou try to open an MFS volume (that is, open the volume window) thathas files with names longer than 31 characters.</P><h2>Macintosh file reference number (refNum) range</h2><P>Date Written: 11/13/90</P><P>Last reviewed: 05-October-1999</P><P>Can the <code>refNum</code> returned by <CODE>FSOpen</CODE> ever be 1? What isthe range or format of legal refNums?</P><P>___</P><P>File reference numbers are defined to be positive<CODE>SInt16</CODE>'s, that is in the range from 1 through32767. You should not rely on special characteristics of filereference numbers, such as the fact that they are currently alwayseven, or that the System file's file reference number is currently always 2. These characteristics may change on future systems.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The number 0 (zero) is suitable as both a nil file reference         number and a nil device reference number.</P></TD></TR></TABLE></CENTER><BR>         <P>X-Ref:</P><P>DTS Technote 1184 <a href="../tn/tn1184.html">"FCBs, Now andForever"</A></P><h2>Steps for duplicating a Macintosh file</h2><P>Date Written: 12/6/90</P><P>Last reviewed: 1/16/91</P><P>Is there a routine in the Macintosh operating system to duplicatea file? (Something that is similar to doing "File - Duplicate" ordragging a file from one disk to another.) We tried <code>PBHCopyFile</code> but,as <I>Inside Macintosh</I> Volume V implied, it did not work.</P><P>___</P><P>Unfortunately there isn't a routine in the Macintosh OS toduplicate a file. The only way to duplicate a file is by doing thefollowing:</P><ol type="1">	<li>Create a new file,</li>	<li>Open the old file,</li>	<li>Open the new file,</li>	<li>Check to see how long the old file is,</li>	<li>Read the old file,</li>	<li>Write everything you read to the new file, then</li>	<li>Close both files.</li></ol><P>The DTS sample code <A HREF = "ftp://ftp.apple.com/developer/Sample_Code/Files/MoreFiles.sit">MoreFiles</A>contains an example of this code.</P><h2>Macintosh filename cannot start with a period (.)</h2><P>Date Written: 12/18/90</P><P>Last reviewed: 5/21/90</P><P>Why do I get a bomb when I create a Macintosh filename startingwith a period (.)?</P><P>___</P><P>Macintosh filenames are not allowed to begin with a period, toavoid possible confusion with driver names, which must begin with aperiod. (This restriction does not apply to folder names.) Ideally,the Finder should catch this possible error and require the file tobe renamed, but it doesn't. Future versions of the Finder shouldcatch this potential problem, but until then users must remember notto begin a filename with a period. See the DTS <a href="../tn/tn1089.html">Technote 1089,"HFS Elucidations Revisited"</A> for details.</P><h2>Code for reading from a non-Macintosh-formatted floppy disk</h2><P>Date Written: 6/5/91</P><P>Last reviewed: 6/14/93</P><P>My Macintosh application needs to recognize, list the files of,and read files from a DOS disk in a Macintosh application, whilerunning under either System 6 or 7. Something akin to the way AppleFile Exchange works would be fine--starting the application and thenhaving the application recognize the DOS disk and listing its contents.</P><P>___</P><P>Assuming you want to start from scratch and write your own,instead of using a third-party software package such as DosMounter,you'll probably need to check out technical references on DOS floppyformats. Here's some code for the hard part--reading anarbitrary floppy in non-Macintosh format:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* pass driver name, e.g. ".Sony"  *//* returns driver Reference Number */OSErrOpen(fn, RefNum)StringPtr    fn;short        *RefNum;{    OSErr            result;    ParamBlockRec    pb;    pb.ioParam.ioNamePtr = fn;    pb.ioParam.ioCompletion = 0;    pb.ioParam.ioPermssn = fsRdPerm;    result = PBOpen(&amp;pb, false);    *RefNum = pb.ioParam.ioRefNum;    return result;}/* pass refNum gotten from Open    *//*      pointer to destination     *//*      bytes to read              *//*      offset from byte 0 of disk */OSErrRead(refNum, dest, count, offset)short    refNum;Ptr        dest;long    count;long    offset;{    OSErr result;    ParamBlockRec    io;    io.ioParam.ioCompletion = NULL;    io.ioParam.ioVRefNum = 1;    io.ioParam.ioRefNum = refNum;    io.ioParam.ioBuffer = dest;    io.ioParam.ioReqCount = count;    io.ioParam.ioPosMode = fsFromStart;    io.ioParam.ioPosOffset = offset;    result = PBRead(&amp;io, false);    if (result != noErr)        printf("PBRead failed. ioActCount = %d\n", io.ioParam.ioActCount);    return result;}</pre>	</TD></TR></TABLE></CENTER><h2>System 7 Finder and file duplication time</h2><P>Date Written: 6/13/91</P><P>Last reviewed: 6/14/93</P><P>Duplicating a large file under the System 7 Finder took four timesas long as under System 6. How can I make System 7 copy more blocksand larger sizes, to reduce duplication time?</P><P>___</P><P>Duplicating a file in the Finder is slower in System 7.0 than inprevious systems because the new system allows you to switch out ofthe Finder to another application for those really big fileduplications. This is a feature that was installed into the Finder.The Finder is constantly checking to see if it should be switched outand this takes time. Since you can't get something for nothing, evenin the Macintosh world, there is a speed loss when copying files inthe Finder.</P><P>This speed change will not happen from within an application. Infact, you may notice a small increase in the speed at whichapplications can duplicate files. Try using the "duplicate" commandin MPW and you'll see that it's considerably faster than the Finder.</P><h2>Copying a file or folder dragged to Macintosh application</h2><P>Date Written: 6/13/91</P><P>Last reviewed: 10/8/91</P><P>What do I need to do to have my Macintosh application copy anyfolder or file that is dragged to it?</P><P>___</P><P>One method is to create an application and have it reside on thedesktop. The user can then just drag files to that application, whichwill in turn receive an open event on the file and duplicate thefile. This is possible because when a document's icon is draggedon top of an application's icon, the Finder will tell theapplication to open the file if the application knows about thefile. The only catch is that you'll need to use the special 'FREF'type that will enable the Finder to send you an 'odoc' for ANY file.The key 'FREF's you'll need are:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  **** -- any file,  fold -- any folder,  disk -- any disk.</pre>	</TD></TR></TABLE></CENTER><P>The characters should be all lowercase letters. This should allowyour application to receive an open for anything that's draggedto it. It will be up to your application to handle possible errorconditions such as not enough disk space.</P><h2>Simulating PBExchangeFiles for System 6</h2><P>Date Written: 6/19/91</P><P>Last reviewed: 10/22/91</P><P>Here's how to do the equivalent of PBExchangeFiles (new inSystem 7) for System 6:</P><P>Create a new file. Copy the old files to the new one, do a<code>PBHGetFileInfo</code> on the old and new, and copy the Finder andcreation date from the old to the new. Then do a <code>PBHSetFileInfo</code>,renaming the new and deleting the old. The File Manager implements<code>PBExchangeFiles</code> as shown below:</P><P>Catmove file 1 to file 2's directory</P><P>Catmove file 2 to file 1's directory</P><P>rename file 2 to 1</P><P>rename file 1 to 2</P><P>Renaming and deleting require the filenames instead of refnums.The filename may have been changed by the user since the file wasopened because the Finder doesn't disallow changing names and movingfiles that are open. To get around this problem, use <code>GetFCBInfo</code> torecover the filename, <code>DirID</code> and <code>VRefNum</code> of an open file. In the caseof files, the FCB's <code>ioFCBParID</code> field is the <code>ioDirID</code> of the file,and <code>ioFCBVRefNum</code> is the <code>ioVRefNum</code>.</P><P>You may need to do an intermediate rename if there is file alreadyexists with the name of the moved file in the destination directory.The File Manager is able to pull this procedure off a little moregracefully because it manipulates the B-Tree entries instead of goingthrough the APIs.</P><P>The DTS sample code <A HREF = "ftp://ftp.apple.com/developer/Sample_Code/Files/MoreFiles.sit">MoreFiles</A>contains an example of this code.</P><h2>Macintosh open file maximums &amp; how to alter</h2><P>Date Written: 7/11/91</P><P>Last reviewed: 05-October-1999</P><P>This topic is now covered in depth in DTS <a href="../tn/tn1184.html">Technote 1184, "FCBs,Now and Forever."</A></P><P>The MPW linker tends to stretch the open file maximum. If you'rerunning into problems trying to link too many files at once, youmight consider using the lib utility to combine some of these files,thus requiring fewer file control blocks to be open at once duringthe link process.</P><h2>Where to get Macintosh third-party file formats</h2><P>Date Written: 8/30/91</P><P>Last reviewed: 8/30/91</P><P>How can I get the file format details on the likes of MacWrite,MacWrite II, and Microsoft Word?</P><P>___</P><P>Macintosh file formats are not published like Apple II fileformats. You must contact the developers of the Macintosh software inorder to obtain their file formats.</P><h2>FSSpec and SFReply information blocks</h2><P>Date Written: 8/19/91</P><P>Last reviewed: 10/8/91</P><P>How can I make <code>FSSpec</code> file information comply with what was an<code>SFReply</code> information block? Is there a way to convert <code>FSSpec</code>information--as passed, for example, via an Open Documents Appleevent--to a <code>vRefNum</code> as understood by an <code>SFReply</code> record? We want tokeep our tried-and-true non-System 7 file management logic andconvert from <code>FSSpec</code> to <code>SFReply</code>-type format.</P><P>___</P><P>Not wanting to make a good bit of file system code obsolete isunderstandable; however, while it's unlikely that Apple willdispense with support for old <code>SFGetFile</code> or <code>SFPutFile</code> functions in thenear future, the use of <code>SFReply</code>-style data structures in internalcalls has no development future.</P><P>The <code>vRefNum</code> field of the <code>SFReply</code> record was originally (in<I>Inside Macintosh</I> Volume II days) a volume reference number;later, with the creation of HFS in 1986, it became a workingdirectory reference number for purposes of backward compatibility. InHFS, a file or directory entity on a volume is specified with avolume reference number, a directory ID, and a name. An FSSpeccontains this latter information.</P><P>Converting from <code>FSSpec</code> to <code>SFReply</code> requires that your applicationmanage the manipulation of working directory entities, which hasdisadvantages from the point of view of the system and compatibility.There are several difficulties with working directory references:</P><P>* There's a system-wide limit on their number.</P><P>* If you have a working directory reference to which no filebuffers are open and some other application closes that workingdirectory without your knowledge of it, your internally storedreference number is invalid and you have no way of knowing about it.</P><P>* The documentation about where, when, and how to close a workingdirectory is somewhat ambiguous.</P><P>* An <code>FSSpec</code> can refer to either a file or a directory while anSFReply can refer only to a file.</P><P>Developer Technical Support urges you to take the time to removedependencies on SFReply data structures as soon as is feasible.</P><h2>How to search only nonserver mounted volumes</h2><P>Date Written: 8/29/91</P><P>Last reviewed: 6/14/93</P><P>If I don't want to search any AppleShare or File Sharing volumes,how can I tell which mounted volume to search?</P><P>___</P><P>You should be able to use the field <code>vMServerAdr</code> in the<code>GetVolParmsInfo</code> attributes buffer of <code>PBHGetVolParms</code> to determinewhether to search a volume. Since the <code>vMServerAdr</code> field specifies theinternet address of the server that manages an AppleTalk servervolume, checking for a zero internet address before searching thevolume would seem the way to go for you.</P><P>X-Ref:</P><P><I>Inside Macintosh </I>Volume VI, pages 25-37 to 25-40</P><h2>Using the Macintosh file system asynchronously at interrupt time</h2><P>Date Written: 11/19/91</P><P>Last reviewed: 6/14/93</P><P>Is it true that calls in the file system like <code>PBOpen</code> can movememory under all conditions? Can I create, open, write, and close afile completely at interrupt time? If not, which calls must be calledat a driver's accRun time? I need to be compatible with both6.0.x and 7.0.x.</P><P>___</P><P>The answer to your question is (drum roll...) 42. Oops, wrongquestion.</P><P>The answer to your question is yes, all this (and more) can bedone completely at interrupt time. Any call that can be madeasynchronously can be safely made at interrupt time, provided it ismade asynchronously. Glancing though <I>Inside Macintosh</I> VolumeIV, this includes just about all of the File Manager, except for theability to mount and unmount volumes.</P><P>One caveat: making a call asynchronously here means really makingit asynchronously; making the call and then sitting in a little loopwaiting for the <code>ioResult</code> field to change does not qualify. You musteither use completion routines to determine when a call hascompleted, or you must check the <code>ioResult</code> from time to time, neverwaiting for it at interrupt time. (And in this case, a deferred taskdoes qualify as being at interrupt time).</P><h2>Using Macintosh PBRead call asynchronously</h2><P>Date Written: 11/26/91</P><P>Last reviewed: 05-October-1999</P><P>Can <code>PBRead</code> be called asynchronously? I would like to start the"next" file read while processing the "previous" read's data.</P><P>___</P><P>You can certainly call <CODE>PBReadAsync</CODE>; however, theresults you get may be a little unexpected. For example, if thedevice you're reading from is accessed via the classic SCSI Manager(or any other synchronous-only technology, such as early versions ofthe ATA Manager), in certain respects the effect will be synchronous.Classic SCSI Manager does not support asynchronous operations, soonce the driver actually starts a classic SCSI Manager operation, itwon't return until that operation has completed.</P><P>It sounds from your question that you want to be able to doprocessing <I>while</I> the read is being serviced. This works aslong as the underlying device driver is asynchronous. You candetermine this by querying the driver with the <CODE>kdgSync</CODE>Driver Gestalt selector. Most modern Mac OS systems includeasynchronous disk drivers.</P><h2>Partition Macintosh volumes to work around 2 GB size limit</h2><P>Date Written: 11/26/91</P><P>Last reviewed: 05-October-1999</P><P>How do I create a Macintosh volume that is &gt;2 gigabytes insize? Up to 2 GB everything works OK. Since my driver and the FileManager work with disk/allocation blocks, 2 GB falls well within alongint. Is this limitation imposed by the Finder?</P><P>___</P><P>System 7.5 raised the maximum volume size limit to 4 GB, andSystem 7.5.2 raised it again to 2 TB. The following Q&amp;A containthe full story, from an application perspective.</P><P>DTS Q&amp;A FL 08, <a href="../../qa/fl/fl08.html">"Determiningthe Volume Size"</A></P><P>DTS Q&amp;A FL 09, <a href="../../qa/fl/fl07.html">"PBXGetVolInfoGlue"</A></P><P>The situation for disk device driver writers is somewhat morecomplex. Please write to <A HREF = "mailto:dts@apple.com">DTS</A> for acopy of the pre-release technote that explains the full story.</P><h2>Accessing files in a folder dropped onto an application</h2><P>Date Written: 12/5/91</P><P>Last reviewed: 6/14/93</P><P>How can I get to the files in a folder which was dropped onto mySystem 7 application? <code>PBGetCatInfo</code> doesn't work with the dirID fromthe FSSpec.</P><P>___</P><P>To determine if the <code>FSSpec</code> returned by <code>AEGetNthPtr</code> points to afolder (and if so, to find its dirID), call <code>PBGetCatInfo</code> and checkthe <code>ioFlAttrib</code> field of the CInfoPBRec after the call. If bit 4 isset, the item is a folder.</P><P>Remember that the <code>FSSpec</code> for a folder indicates its parent's<code>dirID</code>, not its own. Before the call to <code>PBGetCatInfo</code>, the <code>ioDrDirID</code>field of the <code>CInfoPBRec</code> should contain the folder'sparent's <code>dirID</code>, <code>ioNamePtr</code> must point to the name of the folder,and <code>ioFDirIndex</code> must be zero. Also assign the <code>ioVRefNum</code> and<code>ioCompletion</code> fields appropriately. When <code>PBGetCatInfo</code> returns,<code>ioDrDirID</code> will contain the folder's own dirID.</P><P>Use the folder's own dirID in calls to <code>PBHGetFInfo</code> (or<code>PBGetCatInfo</code>) with an increasing index parameter to identify all ofthe files (or files and directories) contained in the folder.</P><P>A sample function showing how to do this is pasted below.<code>PBGetCatInfo</code> is documented in the File Manager chapter of <I>InsideMacintosh</I> Volume IV, and in the Macintosh Technical Note "SettingioFDirIndex in <code>PBGetCatInfo</code> Calls." An application must also have a'fold' FREF resource included in its bundle to allow folders to bedropped onto it, as discussed in the Finder Interface chapter of<I>Inside Macintosh</I> Volume VI.</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION DoAEOpenDoc(theAEvent: AppleEvent; reply: AppleEvent;                     refcon: LONGINT): OSErr; { handle each item in each folder opened (only one folder deep - not   recursive) }  VAR   retCode: OSErr;   docList: AEDescList;   odocFSSpec: FSSpec;   index, itemsInList: LONGINT;   actualSize: Size;   keywd: AEKeyword;   retdType: DescType;&nbsp;   fileName: Str255;   folderContentsFSSpec: FSSpec;   folderDirID: LONGINT;   folderIndex: INTEGER;&nbsp;   myCInfoPBRec: CInfoPBRec;&nbsp;  BEGIN&nbsp;   retCode := AEGetParamDesc (theAEvent, keyDirectObject,                              typeAEList, docList);   IF retCode &lt;&gt; noErr THEN    BEGIN     { never ExitToShell from within an AE handler }     PostWarning('cannot get parameter descriptor', retCode);     DoAEOpenDoc := retCode;     EXIT(DoAEOpenDoc)    END;&nbsp;   retCode := AECountItems(docList, itemsInList);&nbsp;   FOR index := 1 TO itemsInList DO    BEGIN     retCode := AEGetNthPtr(docList, index, typeFSS, keywd,                            retdType, @odocFSSpec,      sizeof(odocFSSpec), actualSize);     IF retCode &lt;&gt; noErr THEN      BEGIN       PostWarning('cannot get nth document', retCode);       DoAEOpenDoc := retCode;       EXIT(DoAEOpenDoc)      END;&nbsp;     fileName := odocFSSpec.name;&nbsp;     myCInfoPBRec.ioCompletion := NIL;     myCInfoPBRec.ioNamePtr := @fileName;     myCInfoPBRec.ioVRefNum := odocFSSpec.vRefNum;     myCInfoPBRec.ioDrDirID := odocFSSpec.parID;     myCInfoPBRec.ioFDirIndex := 0; { use name and dirID }     retCode := PBGetCatInfoSync(@myCInfoPBRec);     IF retCode &lt;&gt; noErr THEN      BEGIN       PostWarning('cannot get cat info', retCode);       DoAEOpenDoc := retCode;       EXIT(DoAEOpenDoc)      END;&nbsp;     IF BTST(myCInfoPBRec.ioFlAttrib, 4) THEN { it's a directory }      BEGIN       { index through all items in the directory }&nbsp;       folderIndex := 0;&nbsp;       { myCInfoPBRec.ioDrDirID now contains the dirID of the folder        pointed to by odocFSSpec }       folderDirID := myCInfoPBRec.ioDrDirID;       REPEAT        folderIndex := folderIndex + 1;        fileName := ''; { reset name string }        myCInfoPBRec.ioCompletion := NIL;        myCInfoPBRec.ioNamePtr := @fileName;        myCInfoPBRec.ioVRefNum := odocFSSpec.vRefNum;        myCInfoPBRec.ioDrDirID := folderDirID;        myCInfoPBRec.ioFDirIndex := folderIndex;        retCode := PBGetCatInfoSync(@myCInfoPBRec);        IF retCode = noErr THEN        BEGIN         retCode := FSMakeFSSpec(odocFSSpec.vRefNum, folderDirID, fileName,          folderContentsFSSpec);         IF retCode &lt;&gt; noErr THEN          BEGIN           PostWarning('cannot make FSSpec', retCode);           DoAEOpenDoc := retCode;           EXIT(DoAEOpenDoc)          END;&nbsp;         { now do something with the item }         DoSomethingWithTheItem(folderContentsFSSpec);        END;&nbsp;       UNTIL retCode &lt;&gt; noErr; { exhausted folder contents }      END&nbsp;     ELSE { odoc entry for a file, not for a folder }      DoSomethingWithTheItem(odocFSSpec);&nbsp;    END; { for all items in docList }&nbsp;   retCode := AEDisposeDesc(docList);&nbsp;   DoAEOpenDoc := noErr;  END; { DoAEOpenDoc }</pre>	</TD></TR></TABLE></CENTER><h2>Ignore asynchronous low-level File Manager function results</h2><P>Date Written: 2/18/92</P><P>Last reviewed: 6/14/93</P><P>I'm making an asynchronous low-level File Manager call from insidea completion routine (for example, "error := PBxxx(@PB, TRUE);").Occasionally on some machines, the call immediately returns an errorin the function result even though everything appears to workcorrectly. Do I need to worry about the function result when I makethe call?</P><P>___</P><P>It sounds like you're making the mistake of testing the functionresult of an asynchronous File Manager call (the value of register D0is returned in the function result). There is no useful informationin the function result of an asynchronous call made to the FileManager; the call might not even have been looked at by the FileManager yet. It's only <code>ioResult</code> after the call completes, oreither DO or <code>ioResult</code> at the entry to the completion routine thatcontains the call's result status. If you're polling to checkfor the call's completion, <code>ioResult</code> will indicate the call hascompleted when it is less than or equal to 0.</P><P>In general, when making asynchronous I/O calls (reads or writes)there are only two types of function result errors that are of anypossible consequence: a driver not open error (<code>notOpenErr</code>) or adriver reference number error (<code>badUnitErr</code> or <code>unitEmptyErr</code>), whichindicate the call was not successfully unqueued by the driver and theioCompletion routine will not be called. Neither one of these errorconditions makes any sense for the File Manager (which isn't adriver); the File Manager will <I>always</I> call the completionroutine (if any) of a given asynchronous call.</P><P>Your program should just always ignore the function result of anasynchronous low-level File Manager call and leave it up to thecompletion routine or the routine polling ioResult to check for andhandle any errors that may have happened on the call.</P><h2>How to get Macintosh file label &amp; color strings</h2><P>Date Written: 3/2/92</P><P>Last reviewed: 4/7/92</P><P>We'd like to search for files by label or color, getting theactual string for the label/color field, so that the user can selectfrom a menu that looks like what they'd see in the Finder orResEdit.</P><P>___</P><P>In the Icon Utilities package is a call that will get you the RGBcolor and string for the Finder's labels. Information from theMacintosh Technote <a href="../qd/qd_18.html"><U>"Drawing Icons the System 7 Way"</U></A> draft is pasted below. It includes the glue code for the call in MPW C format.</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Function GetLabelColor(labelNumber:Integer; var labelColor:RGBColor;                       VAR LabelString:str255):OSErr;INLINE $303C, $050B, ABC9;</pre>	</TD></TR></TABLE></CENTER><P>This call returns the actual color and string used in the labelmenu of the Finder and the label's Control Panel. Thisinformation is provided in case you wish to include the label text orcolor when displaying a file's icon in your application.</P><P>In C the call looks like:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr GetLabelColor(short labelNumber,RGBColor *labelColor,                           Str255 labelString)={0x303C, 0x050B, 0xABC9};&nbsp;The assembly being:;         Push the usual stuff          Move.W  #$050B,D0          _IconDispatch                        ; $ABC9</pre>	</TD></TR></TABLE></CENTER><P>You can use this call to get both the string and the color.</P><P>X-Ref: Macintosh Technical Note "Drawing Icons the System 7 Way"</P><h2>_CatMove vs _HReName</h2><P>Date Written: 11/30/90</P><P>Last reviewed: 6/14/93</P><P>When using the Macintosh <code>_CatMove</code> trap, can I pass the <code>ioNewName</code>field and leave the <code>ioNewDirID</code> field nil? When tracing through a fewcalls to this trap, it seems that _CatMove works just fine when thereverse is true (<code>ioNewName</code> is nil).</P><P>___</P><P>It sounds like you are trying to get <code>_CatMove</code> to behave like<code>_HRename</code>. Leaving the <code>ioNewName</code> field nil is reasonable if you arejust changing the position of the file in the directory structurewithout affecting its name. In the case of filling in <code>ioNewName</code> andleaving <code>ioNewDirID</code> blank (if it were allowed), this would be likesaying "change the name and leave the directory unchanged." This isdefinitely a job for <code>_HRename</code>.</P><h2>Macintosh verified read error produces dataVerErr (-68)</h2><P>Date Written: 11/30/90</P><P>Last reviewed: 6/14/93</P><P>If I call _Read with "44-ioPosMode" <code>ORed</code> with $40 for a Macintoshverify, what error code is returned if the verify is notsuccessful?</P><P>___</P><P>An error in a verified read should produce an <code>dataVerErr</code> (-68).</P><h2>Determining the amount of free space on a Macintosh disk</h2><P>Date Written: 11/17/89</P><P>Last reviewed: 05-October -1999</P><P>How can I determine the amount of free space on my Macintosh disk?</P><P>___</P><P>This is covered in detail in DTS Q&amp;A FL 08, <a href="../../qa/fl/fl08.html">"DeterminingVolume Size."</A></P><h2>How to determine if a Mac file or resource file is already open</h2><P>Date Written: 5/3/89</P><P>Last reviewed: 05-October -1999</P><P>How can I tell if a Macintosh file or a resource file is already open?</P><P>___</P><P>Use the File Manager routines <code>PBGetFInfo</code> (IM IV: 148), PBHGetFInfo(IM IV:149), and <code>PBGetCatInfo</code> (IM IV: 155) to determine if a file isopen, and which forks (resource and data) of the file are open. Allthese routines return <code>ioFlAttrib</code> in the parameter block, which hasbits set or cleared to indicate if the file is locked, open, or adirectory, and which forks are open (IM IV:125).</P><P>Here's a fragment in C:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  /* uses a full pathname rather than vRefNum/dirId  */&nbsp;  HFileInfo  fParams;  ...  fParams.ioCompletion = NIL;  fParams.ioVRefNum = 0;  fParams.ioFDirIndex = 0;  fParams.ioDirID = 0L;  fParams.ioNamePtr := "\pVolume:Folder:Filename";  /* Pascal string */  err = PBGetCatInfo(fParams, FALSE);  if (fParams.ioFlAttrib &amp; 0x10)    /* pathname is a directory */  else if (fParams.ioFlAttrib &amp; 0x04)    /* resource fork is open */  else ...</pre>	</TD></TR></TABLE></CENTER><P>X-Refs:</P><P>"The File Manager," <I>Inside Macintosh </I>Volumes I, II, IV, and VI</P><P>Macintosh Technical Note "New High-Level File Manager Calls"</P><P>If you're trying to determine whether a file is open because youneed to know whether <code>OpenResFile</code> actually opened the resource fileand therefore you should close it, you should DTS <a href="../tn/tn1120.html">Technote 1120, "Opening Resource Files Twice Considered Hard?"</A> which explains the full story.</P><h2>How to get the correct size of a Macintosh file</h2><P>Date Written: 12/13/90</P><P>Last reviewed: 05-October -1999</P><P>How do I determine the size of a Macintosh file? I want to getexactly what the Finder reports when you do Get Info on a selectedfile. How do I use the <code>FileParam</code> fields, <code>ioFlLgLen</code>, <code>ioFlPyLen</code>,<code>ioFlRLgLen</code>, and <code>ioFlRPyLen</code> to find out the size of a disk file aftera call to <code>PBGetFInfo</code>?</P><P>___</P><P>I presume you want to determine the amount of disk space that thefile is consuming, in which case you need to calculate the physicalsize of the file. Prior to Mac OS 9.0, you should do this by calling<CODE>PBGetCatInfo</CODE> (or <CODE>PBHGetFInfo</CODE>) and thensumming the returned <CODE>ioFlPyLen</CODE> and <CODE>ioFlRPylen</CODE> fields. In Mac OS 9.0 or later, you shoulditerate through the file's forks (using<CODE>FSIterateForks</CODE>) and sum the returned<CODE>forkPhysicalSize</CODE> results.</P><h2>Retained Macintosh file reference requirements</h2><P>Date Written: 4/8/91</P><P>Last reviewed: 05-October-1999</P><P>How do I retain a persistent reference to a file? What can I storein a configuration file so I can find a specific file again at alater launch?</P><P>___</P><P>In System 7.0 and higher, you should maintain a persistentreference to a file using an alias. See <cite>Inside Macintosh: Files</cite>, Chapter 4 <a href="../../documentation/mac/Files/Files-340.html">Alias Manager</A> for details. The following discussion is only relevant to System 6 or earlier.</P><P>The Macintosh has two native file systems: the original (64K ROM)Macintosh File System (MFS) and the Hierarchical File System (HFS)(Macintosh Plus and newer). In an attempt to simplify this discussion, I'll assume you know the differences between them and base my explanation upon the HFS system as it is the current one.</P><P>To retain a reference to a file location that will persist acrossapplication launch and restarts, store its file name, volume name,and directory ID. With this information, you will be able to obtainthe volume reference number (a dynamic value based on mount order,subject to change because the addition of another drive can changethe mount order) and then use either the new high-level File Managercalls or the parameter block-based calls to operate on these files.If you happen to encounter an MFS volume, the HFS File Manager willdo the appropriate thing given that you use the calls correctly.</P><P>Only if you are supporting MFS for an old system will you need tocall the MFS functions for obtaining the correct reference values;MFS was a flat-file system.</P><P>Standard File's <code>reply.vRefNum</code> value when used with HFS isactually a working directory reference number, not a fixed reference;therefore it will usually change between launches of the applicationor across restarts.</P><P>Documentation for the File Manager is extensive and spread outbecause it was updated when the Macintosh Plus was released and hasbeen added to subsequently by Technical Notes. <I>InsideMacintosh</I> Volume II deals with the MFS File Manager, <I>InsideMacintosh</I> Volumes IV and V deal with the HFS File Manager throughSystem 6.0.x, and <I>Inside Macintosh</I> Volume VI (on your System7.0 CD-ROM) lists the new File Manager services available under System 7.0. The following Technical Notes should prove useful to you:</P><P>File Manager:</P><P><A HREF = "fl_01.html"><U>"Available Volumes"</U></A></P><P><A HREF = "fl_35.html"><U>"Determining Which File System isActive"</U></A></P><P><A HREF = "fl_22.html"><U>"HFS Ruminations"</U></A></P><P><a href="../tn/tn1089.html">Technote 1089, <U>HFSElucidations Revisited</U></A></P><P><A HREF = "fl_11.html"><U>"Why PBHSetVol is Dangerous"</U></A></P><P><A HREF = "fl_29.html"><U>"Problem with GetVInfo"</U></A></P><P><A HREF = "fl_23.html"><U>"Setting ioNamePtr in File ManagerCalls"</U></A></P><P><A HREF = "fl_14.html"><U>"Working Directories andMultiFinder"</U></A></P><P><A HREF = "fl_07.html"><U>"HFS Tidbits"</U></A></P><P>"New High-Level File Manager Calls"</P><P><A HREF = "fl_27.html"><U>"Mixing HFS and C File I/O"</U></A></P><P>&nbsp;</P><P>Standard File:</P><P><A HREF = "fl_33.html"><U>"Customizing Standard File"</U></A></P><P><A HREF = "fl_12.html"><U>"Standard File Tips"</U></A></P><h2>PBHCopyFile and Macintosh file copying</h2><P>Date Written: 3/18/91</P><P>Last reviewed: 05-October-1999</P><P>I was just about to write a Macintosh file copying function when Idecided to look up a definition in HFS.h (THINK C 4.0.2) and stumbledacross the following definition:</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    typedef struct {       STANDARD_PBHEADER       int ioDstVRefNum;       int filler8;       Ptr ioNewName;       Ptr ioCopyName;       longioNewDirID;       longfiller14;       longfiller15;       longioDirID;    } CopyParam;</pre>	</TD></TR></TABLE></CENTER><P>Isn't this a PB for a file copying function?</P><P>___</P><P>The <code>ParamBlock</code> structure that you found is indeed for the<code>PBHCopyFile</code> call. <code>PBHCopyFile</code> is documented in <I>InsideMacintosh</I> Volume V, the File Manager chapter. The hitch is thatit is an optional call for AppleShare file servers, and it works onlyintraserver (but can work across volumes that are on the sameserver). You can determine whether a particular volume supports<code>PBHCopyFile</code> by calling <code>PBHGetVolParms</code> on that volume and checking the<code>bHasCopyFile</code> flag (bit 14) of the <code>VMAttrib</code> field. Also, you candetermine whether two volumes are on the same server by calling<code>PBHGetVolParms</code> on them and comparing their internet addresses. Ifthey are the same, then they are on the same server.</P><P>Unfortunately, if what you are looking for is a single call tocopy a file on the Macintosh, there isn't one (oddly enough). Tohandle the general case of copying a file on the Macintosh, you stillhave to copy the file's data fork, resource fork, and FinderInfo flags, except for the INITed bit. The DTS sample code <A HREF = "ftp://ftp.apple.com/developer/Sample_Code/Files/MoreFiles.sit">MoreFiles</A> contains an example of this code.</P><h2>Copying a file from application folder to System Folder</h2><P>Date Written: 3/11/91</P><P>Last reviewed: 05-October-1999</P><P>My installer application should automatically copy known filesfrom either a floppy or a folder in the same directory or folder asthe application. How can I determine a reference number for thesource file in the directory without using the Standard File PackageSFGetFile?</P><P>___</P><P>The best way to do this is to include the following code early inyour application's startup sequence.</P><TABLE BORDER=0>   <TR>      <td bgcolor="#EEEEE0" align=left>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>// This snippet uses FSpGetFileLocation, which is part of// the DTS sample "MoreFiles".&nbsp;#include "MoreFilesExtra.h"&nbsp;static FSSpec gApplicationFSSpec;&nbsp;extern void main(void){    err = FSpGetFileLocation(CurResFile(), &amp;gApplicationFSSpec);}</pre>	</TD></TR></TABLE></CENTER>      </TD>   </TR></TABLE><BR><P>This gives you an <CODE>FSSpec</CODE> for your application. You can then navigate your way to the other items in your folder. Once you have an <CODE>FSSpec</CODE> for the source items, you can use the code in the DTS sample <A HREF = "ftp://ftp.apple.com/developer/Sample_Code/Files/MoreFiles.sit">MoreFiles</A> to copy them using standard File Manager calls.</P><P>Your application should not rely on the fact that the ProcessManager creates a working directory for your application and sets thecurrent "volume" to be that working directory. While this shouldcontinue to occur on traditional Mac OS, working directories are notsupported under Carbon.</P><h2>Macintosh Read calls at interrupt time</h2><P>Date Written: 9/26/91</P><P>Last reviewed: 6/14/93</P><P>Read calls at interrupt time often result in a "hang," waiting forthe parameter block to show "done." This happens if the interruptoccurred during another Read call. I've tried checking the low-memoryglobal <code>FSBusy</code>, and that decreases the occurrence of this problem butdoes not eliminate it. When is it safe to make the Read call?</P><P>___</P><P>The problem you're experiencing is a common one known as"deadlock." The good news is that you can <I>always</I> make Readcalls at interrupt time! The only requirement is that you make them<I>asynchronously</I> and provide a completion routine, rather thanloop, waiting for the ioResult field to indicate the call hascompleted. This will require that you use the lower-level <code>PBRead</code>call, rather than the high-level <code>FSRead</code>.</P><P>The low-memory global <code>FSBusy</code> is <I>not </I>a reliable indicator ofthe state of the File Manager. The File Manager's implementationhas changed over time, and new entities patch it and use the hooks itoffers to do strange and wonderful things. File Sharing really turnsit on its ear. The result is that when <code>FSBusy</code> is set, you can be surethe File Manager is busy, but when it's clear you can't be sureit's free. Therefore, it would be best if you ignore itsexistence.</P><P>If you need to have the Read calls execute in a particular order,you'll have to chain them through their completion routine. The basic concept is that the completion routine for the first Read request initiates the next Read request, and so on until you're done reading.</P><P>By the way, never make synchronous calls at interrupt time (and,contrary to the popular misconception, deferred tasks are stillconsidered to be run at interrupt time) or from ioCompletionroutines, which may get called at interrupt time.</P><h2>Should ioNamePtr point to Str255 or Str63?</h2><P>Date Written: 7/15/92</P><P>Last reviewed: 6/14/93</P><P>The Macintosh Technical Note <A HREF = "fl_23.html"><U>"Setting ioNamePtr in File Manager Calls"</U></A> says that <code>ioNamePtr</code> needs to point either to nil or to storage for a Str255. This contradicts the Technical Note <A HREF = "fl_31.html"><U>"Searching Volumes--Solutions and Problems,"</U></A>which gives an example of a recursive indexed search using <code>PBGetCatInfo</code>. The example uses a Str63. Which Technical Note is correct?</P><P>___</P><P>To be generically correct, <code>ioNamePtr</code> should point to a Str255. However, in the case of <code>PBGetCatInfo</code> and other calls that return a filename (or a directory name), a Str63 is sufficient. The reasons are tied to the history of the Macintosh file system.</P><P>MFS, the original Macintosh file system, supported filenamelengths of up to 255 characters. However, the Finder on those systemssupported filename lengths up to only 63 characters and, in fact,developers were warned to limit filename lengths to fewer than 64characters (see page II-81 of <I>Inside Macintosh</I> Volume II).</P><P>HFS, the hierarchical file system (in every Macintosh ROM sincethe Macintosh Plus), further limited filename lengths to 31 characters. If you mount an MFS disk while running HFS, the old MFS code is called to handle the operation. So, the file system can still create and use files with long filenames on MFS volumes.</P><P>When the System 7 file system was being designed, engineering hadto decide what size string to use in <code>FSSpec</code> records. The decision wasto use a Str63 instead of a Str31 to be able to support long MFSfilenames, and to use a Str63 instead of a Str255 because there wereprobably very few filenames with over 63 characters (remember, theold Finder limited filenames to 63 characters). Using a Str63 insteadof a Str255 saves 192 bytes per FSSpec record.</P><P>So, we recommend that you use at least a Str63 for filenames, asin <A HREF = "fl_31.html"><U>"Searching Volumes--Solutions andProblems</U></A>." If you need to manipulate the filename in any wayafter you've gotten the name--for example, to concatenate it withanother string--you might want to use a Str255.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Even though the System 7 file system supportsfilenames longer than 31 characters on MFS volumes, the System 7Finder does not. In fact, the System 7 Finder currently crashes ifyou try to open an MFS volume (that is, open the volume window) thathas files with names longer than 31 characters.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (80K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/fl_515.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/fl/fl_515.html%3Fid%3DDTS10002466-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/fl/fl_515.html%3Fid%3DDTS10002466-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/fl/fl_515.html%3Fid%3DDTS10002466-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>