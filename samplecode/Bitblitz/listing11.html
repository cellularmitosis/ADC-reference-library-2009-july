<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Bitblitz - /Source/BitBlitz.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Bitblitz</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Bitblitz</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/BitBlitz.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/LibHeaders/AlertDlogUtils.h</option>
<option value="listing2.html">/LibHeaders/AlrtDlogTools.h</option>
<option value="listing3.html">/LibHeaders/AutoCursor.h</option>
<option value="listing4.html">/LibHeaders/ColorTools.h</option>
<option value="listing5.html">/LibHeaders/MacHeaders.h</option>
<option value="listing6.html">/LibHeaders/MainUtils.h</option>
<option value="listing7.html">/LibHeaders/PictUtils.h</option>
<option value="listing8.html">/LibHeaders/WCenter.h</option>
<option value="listing9.html">/Resources/AlertDlogUtils.r</option>
<option value="listing10.html">/Resources/BitBlitz.r</option>
<option value="listing11.html">/Source/BitBlitz.c</option>
<option value="listing12.html">/Source/BitBlitz.h</option>
<option value="listing13.html">/Source/BlendUtils.c</option>
<option value="listing14.html">/Source/BlendUtils.h</option>
<option value="listing15.html">/Source/MainStuff.c</option>
<option value="listing16.html">/Source/MainStuff.h</option>
<option value="listing17.html">/Source/OffscreenUtils.c</option>
<option value="listing18.html">/Source/OffscreenUtils.h</option></select>
				</p>
				</form>
				<p><strong><a href="Bitblitz.zip">Download Sample</a></strong> (&#147;Bitblitz.zip&#148;, 92.9K)<BR>
<strong><a href="Bitblitz.dmg">Download Sample</a></strong> (&#147;Bitblitz.dmg&#148;, 169.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*--------------------------------------------------------------------------------------////  File:      BitBlitz.c////  Contents:  This files contains all of the main routines that comprise the BitBlitz tool.//        The tool was designed to be a learning/testing tool for the Copybits(), CopyMask(),//        and CopyDeepMask() QuickDraw calls.  It makes extensive use of GWorlds as well as//        the above mentioned QuickDraw bit tools.//////  By Georgiann (&quot;George&quot;) Delaney//  &copy;\xCA1989 - 1990, Apple Computer, Inc.////--------------------------------------------------------------------------------------*/    #include &quot;MacHeaders.h&quot;#include &quot;WCenter.h&quot;#include &quot;ColorTools.h&quot;#include &quot;MainStuff.h&quot;#include &quot;BlendUtils.h&quot;#include &quot;OffscreenUtils.h&quot;#include &quot;PICTUtils.h&quot;#include &quot;AlertDlogUtils.h&quot;#include &quot;AlrtDlogTools.h&quot;#include &quot;BitBlitz.h&quot;#pragma segment CopyTests/*--------------------------------------------------------------------------------------*//*  Constants  */#define  AttrbDlogID    300        /*  Attributes dialog constants  */#define  diDlogTitle    3#define  diLine1      4#define  diLine2        5#define  diLine3      10#define  diLine4      16#define  diBitmapButton    6#define  diGWorldButton    7#define   diDepthPopUp    8#define   diContentPopUp    9#define   diHeightText    14#define   diWidthText    15#define  TrapDlogID      301        /*  Trap selection dialog contents  */#define   diTrapLine1     4#define  diTrapLine2     5#define  diCopyMaskButton   6#define  diCopyDeepButton     7#define  diCopyBitsButton   8#define  Sys7DlogID      302        /*  Need 7.0 dialog constants  */#define  AboutBoxDlogID    303        #define  kDepthMenu      300        /*  Attributes dialog menu constants  */#define  kContentMenu    301      #define  kNone        0        /*  Buffer type constants  */#define  kBitMap      1#define  kPixMap      2#define  kGWorld      3  #define   km1bpp        1        /*  Constants for depth menu selecions  */ #define   km2bpp        2#define   km4bpp        3#define   km8bpp        4#define   km16bpp      5#define   km32bpp      6#define   kmMaxbpp      8#define  kTitleStrings    4000      /*  String resource constants  */#define  kErrorStrings    4001#define    kBootMemErr       1#define    kDepthMemErr     2#define    kResizeMemErr   3#define    kPICTReadErr     4#define  kAttribDlogStrings  4002#define  kHLSRectBlend    1        #define  kHLSHBlend      2#define  kHLSVBlend      3#define  kGrayRectBlend    5#define  kGrayHBlend      6#define  kGrayVBlend     7#define  kGrayPatRectBlend   9#define  kGrayPatHBlend    10#define  kGrayPatVBlend    11#define  kSolidRGB      13#define  kPICT        15/*--------------------------------------------------------------------------------------*//*  Global Variables  */RGBColor  gLastRGB;        /* The last RGB Color selected for a solid fill.                               Used as a starting color for the color picker for selection. */Point    gZeroPt;        /* Its just what you think - a point initialized to (0,0)       */                   /* Array containing the 8 standard colors  */long    gColorArray[8]  =  {blackColor, whiteColor, redColor, greenColor, blueColor, cyanColor, magentaColor, yellowColor};                    /* Array containing rgb equivalents of 8 standard colors &amp; gray*/RGBColor  gRGBArray[9];    /*======================================================================================*//*  Initialization Routines    *//*--------------------------------------------------------------------------------------*/Boolean myTrapAvailable(theNumber,theType)/*//  This procedure tests to see if the specified trap is available in the current system.*/  short    theNumber;  TrapType  theType;{  return NGetTrapAddress(theNumber,theType) != GetTrapAddress(_Unimplemented);} /*--------------------------------------------------------------------------------------*/Boolean HasGWorlds()/*//  This procedure tests to see if the GWorlds are available.*/{  #define _GWorldDispatch (short)0xAB1D  return(myTrapAvailable(_GWorldDispatch,ToolTrap));} /*--------------------------------------------------------------------------------------*/void InitTestGlobals()/*//  This procedure is called during the program's initialization to set the initial values//  of the app's constants.*/{  gColorAvail   = HasColorQD();  gGWorldsAvail = HasGWorlds();  gZeroPt.h    = gZeroPt.v  = 0;}/*--------------------------------------------------------------------------------------*/void  InitTestWindowAttributes()/*//  InitTestWindowAttributes() performs initialization of the global structs defining the  //  attributes of the source, mask, and destination bit images.*/{  register  i;        /*  initialize all of the common fields  */  for (i=kSrcWindow; i &lt;= kBitWindow; i++)  {    gWList[i].window      = nil;    gWList[i].buffer.gworld    = nil;        if (gGWorldsAvail)  {      gWList[i].bufferType  = kGWorld;      gWList[i].bufferDepth  = 0;      }    else  {      gWList[i].bufferType  = kBitMap;      gWList[i].bufferDepth  = 1;      }    }      /*  set initial window contents with respect to the availability of color.  */  if (gColorAvail)  {    gWList[kSrcWindow].contentType      = kHLSRectBlend;    gWList[kSrcWindow].content.saturation  = 65535;      gWList[kMskWindow].contentType      = kGrayVBlend;      gWList[kDstWindow].contentType      = kSolidRGB;    gWList[kDstWindow].content.RGB.red    = 0xFFFF;    gWList[kDstWindow].content.RGB.green   = 0xFFFF;    gWList[kDstWindow].content.RGB.blue    = 0x0000;    }  else  {    gWList[kSrcWindow].contentType      = kGrayPatRectBlend;    gWList[kMskWindow].contentType      = kGrayPatVBlend;    gWList[kDstWindow].contentType      = kGrayPatHBlend;    }}/*--------------------------------------------------------------------------------------*/void  InitColorSettings()/*//  InitColorSettings() initializes the values in the color array.*/{  gRGBArray[0].red   = 0x0000;  gRGBArray[0].green = 0x0000;  gRGBArray[0].blue  = 0x0000;  gRGBArray[1].red   = 0xFFFF;  gRGBArray[1].green = 0xFFFF;  gRGBArray[1].blue  = 0xFFFF;  gRGBArray[2].red   = 0xDD6B;  gRGBArray[2].green = 0x08C2;  gRGBArray[2].blue  = 0x06A2;  gRGBArray[3].red   = 0x0000;  gRGBArray[3].green = 0x8000;  gRGBArray[3].blue  = 0x11B0;  gRGBArray[4].red   = 0x0000;  gRGBArray[4].green = 0x0000;  gRGBArray[4].blue  = 0xD400;  gRGBArray[5].red   = 0x0241;  gRGBArray[5].green = 0xAB54;  gRGBArray[5].blue  = 0xEAFF;  gRGBArray[6].red   = 0xF2D7;  gRGBArray[6].green = 0x0856;  gRGBArray[6].blue  = 0x84EC;  gRGBArray[7].red   = 0xFC00;  gRGBArray[7].green = 0xF37D;  gRGBArray[7].blue  = 0x052F;  gRGBArray[8].red   = 0x7FFF;  gRGBArray[8].green = 0x7FFF;  gRGBArray[8].blue  = 0x7FFF;  gFGColor.menuIndex     = kBlack;  gFGColor.rgb        = gRGBArray[kBlack-1];    gBKColor.menuIndex     = kWhite;  gBKColor.rgb        = gRGBArray[kWhite-1];  gOPColor.menuIndex    = kGray;  gOPColor.rgb        = gRGBArray[kGray-1];  gHiliteColor.menuIndex  = kBlue;  gHiliteColor.rgb      = gRGBArray[kBlue-1];}/*--------------------------------------------------------------------------------------*/void  InitRgnSettings()/*//  InitRgnSettings() initializes all of the region settings to nil.*/{  register  i;    for (i=kClpRgn; i&lt;=kMskRgn; i++)  {    gRList[i].type = kNoRgn;    gRList[i].rgn  = nil;    }}/*--------------------------------------------------------------------------------------*/void  DisposeRgnSettings()/*//  DisposeRgnSettings() disposes any region settings that may have been set by the user.*/{  register  i;    for (i=kClpRgn; i&lt;=kMskRgn; i++)  {    if (gRList[i].rgn != nil)  {      DisposeRgn(gRList[i].rgn);      gRList[i].rgn = nil;      }    }}/*--------------------------------------------------------------------------------------*/void  MenuIndex2RGB(ColorAttributes colorSelect, RGBColor *theRGB){  if (colorSelect.menuIndex == kCustomColor)    *theRGB = colorSelect.rgb;  else    *theRGB = gRGBArray[colorSelect.menuIndex-1];}/*--------------------------------------------------------------------------------------*/void  DrawOval(){  Rect  tempRect;  tempRect = gWList[kBitWindow].window-&gt;portRect;    InsetRect(&amp;tempRect, 10, 10);  FrameOval(&amp;tempRect);}/*--------------------------------------------------------------------------------------*/void  DrawDiamond(){  Rect  tempRect;  Point  centerPt;  tempRect = gWList[kBitWindow].window-&gt;portRect;    InsetRect(&amp;tempRect, 10, 10);    centerPt.h = tempRect.left + ((tempRect.right  - tempRect.left)&gt;&gt;1);  centerPt.v = tempRect.top  + ((tempRect.bottom - tempRect.top )&gt;&gt;1);    MoveTo(centerPt.h,    tempRect.top);  LineTo(tempRect.right,  centerPt.v);  LineTo(centerPt.h,    tempRect.bottom);  LineTo(tempRect.left,  centerPt.v);  LineTo(centerPt.h,    tempRect.top);}/*--------------------------------------------------------------------------------------*/void  DrawHole(){  Rect  tempRect;  tempRect = gWList[kBitWindow].window-&gt;portRect;    InsetRect(&amp;tempRect, 10, 10);  FrameOval(&amp;tempRect);  InsetRect(&amp;tempRect, ((tempRect.right  - tempRect.left)&gt;&gt;2), ((tempRect.bottom - tempRect.top )&gt;&gt;2));  FrameOval(&amp;tempRect);}/*--------------------------------------------------------------------------------------*/void  DrawStar(){  Rect  tempRect;  Point  centerPt;  tempRect = gWList[kBitWindow].window-&gt;portRect;    InsetRect(&amp;tempRect, 10, 10);    centerPt.h = tempRect.left + ((tempRect.right  - tempRect.left)&gt;&gt;1);  centerPt.v = tempRect.top  + ((tempRect.bottom - tempRect.top )/3);    MoveTo(centerPt.h,    tempRect.top);  LineTo(tempRect.right,  tempRect.bottom);  LineTo(tempRect.left,  centerPt.v);  LineTo(tempRect.right,  centerPt.v);  LineTo(tempRect.left,  tempRect.bottom);  LineTo(centerPt.h,    tempRect.top);}/*--------------------------------------------------------------------------------------*/void  UpdateRgnSettings()/*//  UpdateRgnSettings() updates any region settings that the user has selected after the //  corresponding window has been resized.*/{  register  i;      DisposeRgnSettings();    for (i=kClpRgn; i&lt;=kMskRgn; i++)     if (gRList[i].type != kNoRgn)  {      gRList[i].rgn = NewRgn();      OpenRgn();        switch(gRList[i].type)  {        case kDiamondClip:  DrawDiamond();    break;        case kOvalClip:    DrawOval();      break;        case kStarClip:    DrawStar();      break;        case kHoleClip:    DrawHole();      break;        }        CloseRgn(gRList[i].rgn);      }}/*--------------------------------------------------------------------------------------*/void  SetEnv()/*//  SetEnv() is called to set the color environment and clip regions the user haa designated//  for use in the copy call.*/{  GrafPtr    thePort;    if (gColorAvail)  {    RGBForeColor(&amp;gFGColor.rgb);    RGBBackColor(&amp;gBKColor.rgb);    OpColor     (&amp;gOPColor.rgb);    HiliteColor (&amp;gHiliteColor.rgb);    }  else  {    ForeColor(gColorArray[gFGColor.menuIndex-1]);    BackColor(gColorArray[gBKColor.menuIndex-1]);    }    if (gRList[kClpRgn].rgn != nil)  {    gHoldClpRgn = NewRgn();    GetClip(gHoldClpRgn);    SetClip(gRList[kClpRgn].rgn);    }  if (gRList[kVisRgn].rgn != nil)  {    GetPort(&amp;thePort);    gHoldVisRgn     = thePort-&gt;visRgn;    thePort-&gt;visRgn = gRList[kVisRgn].rgn;    }}/*--------------------------------------------------------------------------------------*/void  RestoreEnv()/*//  RestoreEnv() restores the color and clip settings following the copy call.*/{  GrafPtr    thePort;    if (gColorAvail)  {    RGBForeColor(&amp;gRGBArray[kBlack-1]);    RGBBackColor(&amp;gRGBArray[kWhite-1]);    }  else  {    ForeColor(gColorArray[kBlack-1]);    BackColor(gColorArray[kWhite-1]);    }      if (gHoldClpRgn != nil)  {    SetClip(gHoldClpRgn);    DisposeRgn(gHoldClpRgn);    gHoldClpRgn = nil;    }  if (gHoldVisRgn != nil)  {    GetPort(&amp;thePort);    thePort-&gt;visRgn     = gHoldVisRgn;    }      }/*======================================================================================*//*  Routines to handle CopyMode selection  *//*--------------------------------------------------------------------------------------*/short  ModeMenuItem2CopyMode(short theItem)/*//  This routine is used to convert a copy mode menu selection to an actual QuickDraw //  copy mode.   The reason a switch statement is required here is because the //  QuickDraw copy mode constants are not contiguous.*/{  short  theMode;    switch(theItem)  {    case kSrcCopy:    if (gDither)                   theMode = ditherCopy;              else theMode = theItem -1;                  break;    case kSrcOr:    case kSrcXor:    case kSrcBic:    case kNotSrcCopy:    case kNotSrcOr:    case kNotSrcXor:    case kNotSrcBic:  theMode = theItem -1;    break;    case kBlend:    theMode = blend;      break;    case kAddPin:    theMode = addPin;      break;    case kAddOver:    theMode = addOver;      break;    case kAddMax:    theMode = addMax;      break;    case kAddMin:    theMode = adMin;      break;    case kSubOver:    theMode = subOver;      break;    case kSubPin:    theMode = subPin;      break;        case kTransparent:  theMode = transparent;    break;        case kHilite:    theMode = hilite;      break;    }    return(theMode);}/*--------------------------------------------------------------------------------------*/short  CopyMode2ModeMenuItem(short theMode)/*//  This routine is used to convert a QuickDraw copy mode to a copy mode menu selection.//  The reason a switch statement is required here is because the QuickDraw copy mode//  constants are not contiguous.*/{  short  theItem;    switch(theMode)  {    case ditherCopy:  theItem = srcCopy +1;     break;        case srcCopy:    case srcOr:    case srcXor:    case srcBic:    case notSrcOr:    case notSrcCopy:    case notSrcXor:    case notSrcBic:    theItem = theMode +1;    break;    case blend:      theItem = kBlend;      break;    case addPin:    theItem = kAddPin;      break;    case addOver:    theItem = kAddOver;      break;    case adMin  :    theItem = kAddMin;      break;    case addMax:    theItem = kAddMax;      break;    case subOver:    theItem = kSubOver;      break;    case subPin:    theItem = kSubPin;      break;        case transparent:  theItem = kTransparent;    break;        case hilite:    theItem = kHilite;      break;    }      return(theItem);}    /*======================================================================================*//*  Window Attribute PICT handle cleanup.  *//*--------------------------------------------------------------------------------------*/void  DisposePICTInfo(short windowCode)/*  //  DisposePICTInfo() tests to determine if the specified window has a PICT handle allocated //  for buffer updating and disposes it if it is not already nil.*/{  if ((gWList[windowCode].contentType == kPICT) &amp;&amp; (gWList[windowCode].content.pictInfo != nil))  {    DisposHandle((Handle)gWList[windowCode].content.pictInfo);    gWList[windowCode].content.pictInfo = nil;    }}/*======================================================================================*//*  Offscreen Buffer Maintainance Routines   *//*--------------------------------------------------------------------------------------*/Boolean  CreateWindowBuffer(short windowCode)/*  //  CreateWindowBuffer() creates an offscreen buffer of the designated size with respect to the//  attributes set in the window's attribute information.*/{  Boolean    bufferCreated  = false;    switch(gWList[windowCode].bufferType) {    case kBitMap:        bufferCreated = CreateOSBitmap(&amp;gWList[windowCode].buffer.bitmap, &amp;gWList[windowCode].window-&gt;portRect);      break;    case kGWorld:              bufferCreated = (NewGWorld(&amp;gWList[windowCode].buffer.gworld, gWList[windowCode].bufferDepth, &amp;gWList[windowCode].window-&gt;portRect, nil, nil, 0) == noErr);      break;    }    return(bufferCreated);}/*--------------------------------------------------------------------------------------*/Boolean  UpdateWindowBuffer(short windowCode, short depth)    /* //  This routine updates the specified window's offscreen buffer to the desired depth.*/{  Boolean  bufferChanged  = false;  long   gwError;    if (gWList[windowCode].bufferType == kGWorld) {      gWList[windowCode].bufferDepth = depth;        gwError = (UpdateGWorld(&amp;gWList[windowCode].buffer.gworld, depth, &amp;gWList[windowCode].buffer.gworld-&gt;portRect, 0, 0, 0) == noErr);    bufferChanged = (gwError &amp; gwFlagErr);    }      return(true);}/*--------------------------------------------------------------------------------------*/void  DisposeWindowBuffer(short windowCode)/*  //  DisposeWindowBuffer() determines the type of buffer that is associated with the specified //  window and performs the appropriate dispose.*/{  if (gWList[windowCode].buffer.gworld != nil)     switch(gWList[windowCode].bufferType) {      case kBitMap:  DisposeOSBitmap(gWList[windowCode].buffer.bitmap);  break;      case kGWorld:  DisposeGWorld  (gWList[windowCode].buffer.gworld);  break;      }}/*--------------------------------------------------------------------------------------*/Boolean  SetOffscreen(short windowCode, short type, short depth)    /*//  Hey, guess what, it does what you expect - sets the specified window's buffer to the//  specified offscreen type and depth.*/{  Boolean    bufferChanged   = false;          if (type != gWList[windowCode].bufferType) {    DisposeWindowBuffer(windowCode);        gWList[windowCode].bufferType  = type;    gWList[windowCode].bufferDepth = depth;    bufferChanged = CreateWindowBuffer(windowCode);    if (!bufferChanged)      OKRsrcAlert(kErrorStrings,kDepthMemErr);    }  else  {    if (depth != gWList[windowCode].bufferDepth)  {      gWList[windowCode].bufferDepth = depth;      bufferChanged = UpdateWindowBuffer(windowCode, depth);      if (!bufferChanged)        OKRsrcAlert(kErrorStrings,kDepthMemErr);      }    }    return(bufferChanged);}/*--------------------------------------------------------------------------------------*/Boolean  UpdateOffscreen(short windowCode, short type, short depth)/*//  UpdateOffscreen() tests to determine if the specified window's offscreen buffer has the //  specified type and depth attributes and  performs whatever buffer updating necessary.*/{  Boolean  depthChanged = false;    depthChanged = SetOffscreen(windowCode,type,depth);          /*  Since the dest and copy window must be the same depth, if the user changes         //  the depth of the dest window, the copy window should also be set to the         //  new selected depth/        */  if ((depthChanged) &amp;&amp; (windowCode == kDstWindow))  {    depthChanged = SetOffscreen(kBitWindow,type,depth);              /*  However, if an error occurs and the copy window can not be set to the        //  new depth then return the dest window to the original depth so that both are        //  equal.        */    if (!depthChanged)       SetOffscreen(kDstWindow,gWList[kBitWindow].bufferType,gWList[kBitWindow].bufferDepth);    }      if (depthChanged)  {    DrawBuffer(windowCode);    DrawBuffer(kBitWindow);    }          return(depthChanged);}/*======================================================================================*//*  Attributes Dialog Routines   *//*--------------------------------------------------------------------------------------*/void  SetDepthMenuSelection(DialogPtr  theDlog, short  theItem, short theDepth)/*//  This procedure initializes the attributes dialog's depth popup to the depth of the //  selected window's offscreen depth.*/{  short    itemType;  Handle    itemHdl;  Rect    itemRect;    short    selection;  MenuHandle  depthMenuHdl;    depthMenuHdl = GetMHandle(kDepthMenu);  if ((!gGWorldsAvail) || (!gColorAvail))  {    DisableItem(depthMenuHdl, km2bpp);    DisableItem(depthMenuHdl, km4bpp);    DisableItem(depthMenuHdl, km8bpp);    DisableItem(depthMenuHdl, km16bpp);    DisableItem(depthMenuHdl, km32bpp);    }      if (!gGWorldsAvail)      DisableItem(depthMenuHdl, kmMaxbpp);  GetDItem(theDlog,theItem,&amp;itemType,&amp;itemHdl,&amp;itemRect);    switch(theDepth)  {       case 1  : selection = km1bpp;  break;    case 2  : selection = km2bpp;  break;    case 4  : selection = km4bpp;  break;    case 8  : selection = km8bpp;  break;    case 16  : selection = km16bpp;  break;    case 32  : selection = km32bpp;  break;    case 0  : selection = kmMaxbpp;  break;    }    SetCtlValue((ControlHandle)itemHdl,selection);}/*--------------------------------------------------------------------------------------*/short  GetDepthMenuSelection(DialogPtr  theDlog, short  theItem)/*//  This procedure converts the attributes dialog's depth popup selection to its//  equivalent depth value.*/{  short    itemType;  Handle    itemHdl;  Rect    itemRect;    short    selection,depth;  GetDItem(theDlog,theItem,&amp;itemType,&amp;itemHdl,&amp;itemRect);  selection = GetCtlValue((ControlHandle)itemHdl);    switch(selection)  {       case km1bpp   : depth = 1;  break;    case km2bpp   : depth = 2;  break;    case km4bpp   : depth = 4;  break;    case km8bpp   : depth = 8;  break;    case km16bpp : depth = 16;  break;    case km32bpp : depth = 32;  break;    case kmMaxbpp: depth = 0;  break;    }    return(depth);}/*--------------------------------------------------------------------------------------*/void  SetContentMenuSelection(DialogPtr  theDlog, short  theItem, short theContent)/*//  This procedure initializes the attributes dialog's content popup to reflect the //  selected window's current content type.*/{  short    itemType;  Handle    itemHdl;  Rect    itemRect;  MenuHandle  contentMenuHdl;  contentMenuHdl = GetMHandle(kContentMenu);  if (!gColorAvail)  {    DisableItem(contentMenuHdl, kHLSRectBlend);    DisableItem(contentMenuHdl, kHLSHBlend);    DisableItem(contentMenuHdl, kHLSVBlend);    DisableItem(contentMenuHdl, kGrayRectBlend);    DisableItem(contentMenuHdl, kGrayHBlend);    DisableItem(contentMenuHdl, kGrayVBlend);    DisableItem(contentMenuHdl, kSolidRGB);    }  GetDItem(theDlog,theItem,&amp;itemType,&amp;itemHdl,&amp;itemRect);  SetCtlValue((ControlHandle)itemHdl,theContent);}/*--------------------------------------------------------------------------------------*/short  GetContentMenuSelection(DialogPtr  theDlog, short  theItem)/*//  This procedure returns the attributes dialog's content popup selection.*/{  short    itemType;  Handle    itemHdl;  Rect    itemRect;  GetDItem(theDlog,theItem,&amp;itemType,&amp;itemHdl,&amp;itemRect);  return(GetCtlValue((ControlHandle)itemHdl));}/*--------------------------------------------------------------------------------------*/pascal Boolean AttrbDlogFilter(DialogPtr theDlog, EventRecord *theEvent, short *theItem){ /* //  AttrbDlogFilter() is the dialog filter for the attributes  dialog. */            IBeamCursorAdjust(theDlog,(ValidTextProcPtr)StdValidDecTextProc);        /*  If we get a key down event, check to see if it is for the OK or Cancel        //  buttons.  If not, filter it for numeric input only (via EditNumText()).        */  if ((theEvent-&gt;what == autoKey) || (theEvent-&gt;what == keyDown))  {    short editItem = ((DialogPeek)theDlog)-&gt;editField + 1;        if (HandleOkayCancel(theDlog,theEvent,theItem))      return(true);    EditNumText(theDlog,theEvent,editItem,0L,1000L,decimalOnly);    }      return(false);}/*--------------------------------------------------------------------------------------*/Boolean  ChangeWindowAttributes(short windowCode)/*//  ChangeWindowAttributes() allows the user to change any of the attributes of the source, //  mask, or destination windows.////  This dialog is accessed by selecting the appropriate menu selection or by double-clicking //  in the content region of the desired window.*/{  DialogPtr  theDlog;  GrafPtr    holdPort;  short    itemHit;    Boolean    okHit      = false;  Boolean    done      = false;  Boolean    bufferChanged  = false;  Boolean    contentChanged  = false;  short    tempBufferType   = gWList[windowCode].bufferType;  short    tempBufferDepth  = gWList[windowCode].bufferDepth;  short    tempContentType  = gWList[windowCode].contentType;  PicHandle  tempPICT     = nil;    short    tempSaturation   = 65535;    RGBColor  tempRGB;    register   i;  short    contentSelect;  SFReply    reply;  Str255    tempStr;    Point    oldDimen, newDimen;            /*  Initialize temporary values that have not already been initialized during        //  variable declaration.        */  if (tempContentType == kSolidRGB)     tempRGB = gWList[windowCode].content.RGB;  else    tempRGB = gLastRGB;              /*  Allocate and center the dialog  */  CenterWRsrc(DLOG,AttrbDlogID,vThird);  theDlog = GetNewDialog(AttrbDlogID, nil, (WindowPtr)-1);    reply.good = false;          /*  If the dialog has been allocated successfully - process the user's selections  */  if (theDlog != nil)  {          /*  Save off the current port.  */    GetPort(&amp;holdPort);    SetPort(theDlog);            /*  Dialog item initialization.  */    SetDlogItemProc(theDlog,diLine1,(ProcPtr)FrameDlogItemRect);    SetDlogItemProc(theDlog,diLine2,(ProcPtr)FrameDlogItemRect);    SetDlogItemProc(theDlog,diLine3,(ProcPtr)FrameDlogItemRect);    SetDlogItemProc(theDlog,diLine4,(ProcPtr)FrameDlogItemRect);            /*  Set the appropriate dialog title  */      GetIndString (tempStr,kAttribDlogStrings,windowCode+1);      SetDlogString(theDlog, diDlogTitle, tempStr);    HandleRadioButtons(theDlog,diBitmapButton,diGWorldButton,((tempBufferType == kGWorld) ? diGWorldButton : diBitmapButton));    SetDepthMenuSelection  (theDlog, diDepthPopUp,  tempBufferDepth);    SetContentMenuSelection(theDlog, diContentPopUp,tempContentType);    oldDimen.v = gWList[windowCode].window-&gt;portRect.bottom - gWList[windowCode].window-&gt;portRect.top;    oldDimen.h = gWList[windowCode].window-&gt;portRect.right  - gWList[windowCode].window-&gt;portRect.left;    SetDlogShort(theDlog,diHeightText,oldDimen.v);    SetDlogShort(theDlog,diWidthText, oldDimen.h);    SelIText    (theDlog,diHeightText, 0, 32767);          /*  Display the dialog  */    ShowWindow(theDlog);            /*  Process the user's actions  */    do  {      ModalDialog((ProcPtr)AttrbDlogFilter, &amp;itemHit);            switch (itemHit)  {          case  ok:        okHit = true;              case  cancel:      done  = true;                      break;                  case  diBitmapButton:   HandleRadioButtons(theDlog,diBitmapButton,diGWorldButton,itemHit);                      tempBufferDepth = 1;                      tempBufferType  = kBitMap;                      break;                                case  diDepthPopUp:          case  diGWorldButton:  HandleRadioButtons(theDlog,diBitmapButton,diGWorldButton,diGWorldButton);                      tempBufferDepth = GetDepthMenuSelection(theDlog, diDepthPopUp);                      tempBufferType  = kGWorld;                      break;                    case  diContentPopUp:  contentSelect = GetContentMenuSelection(theDlog, diContentPopUp);                                          switch(contentSelect) {                        case kSolidRGB :                               GetColor(gZeroPt,&quot;\pSelect a color.&quot;,&amp;tempRGB,&amp;tempRGB);                            tempContentType = contentSelect;                            for(i=kSrcWindow; i &lt;= kBitWindow; i++)                              DrawWindow(i);                            break;                                                case kPICT:                              StdGetPictFile(&amp;reply);                            for(i=kSrcWindow; i &lt;= kBitWindow; i++)                              DrawWindow(i);                            if (reply.good)                              tempContentType = contentSelect;                            break;                                                    default:  tempContentType = contentSelect;                        }                      break;          }      }  while ( !done );    GetDlogShort(theDlog,diHeightText, &amp;newDimen.v);    GetDlogShort(theDlog,diWidthText,  &amp;newDimen.h);        if (newDimen.v &lt; 2)  newDimen.v = 2;    if (newDimen.h &lt; 2)  newDimen.h = 2;        DisposDialog(theDlog);    SetPort(holdPort);    }      if (okHit) {    SetCursor(*GetCursor(watchCursor));        for(i=kSrcWindow; i &lt;= kBitWindow; i++)      DrawWindow(i);              /* Reset the offscreen depth if it has been changed  */    bufferChanged = UpdateOffscreen(windowCode, tempBufferType, tempBufferDepth);                      /* Reset the content region if a new type has been selected */    if ((tempContentType != gWList[windowCode].contentType) ||      (tempContentType == kPICT) || (tempContentType == kSolidRGB)) {      if (tempContentType == kPICT) {        if (ReadPICTFile(&amp;reply, &amp;tempPICT) == noErr) {          if (gWList[windowCode].contentType == kPICT)            DisposePICTInfo(windowCode);          gWList[windowCode].contentType     = kPICT;          gWList[windowCode].content.pictInfo  = tempPICT;          DrawBuffer(windowCode);          contentChanged = true;          }        else          if (reply.good)            OKRsrcAlert(kErrorStrings,kPICTReadErr);        }      else  {        if (gWList[windowCode].contentType == kPICT)          DisposePICTInfo(windowCode);                  gWList[windowCode].contentType = tempContentType;                switch(tempContentType)  {          case kSolidRGB:   gWList[windowCode].content.RGB = gLastRGB = tempRGB;    break;          case kHLSRectBlend:           case kHLSHBlend:             case kHLSVBlend:   gWList[windowCode].content.saturation = tempSaturation;  break;          }                  DrawBuffer(windowCode);        contentChanged = true;        }      }            /*  Resize the window if the size has been altered.  Remember, the source and         //  mask windows (when available)  as well as the destination and copy windows        //  must be the same size so if one is altered its corresponding window must also        //  be sized.  It therefore follows that if there is not enough memory available to        //  enlarge both windows then neither should be changed.          */    if ( !EqualPt(oldDimen, newDimen) )  {      GetPort(&amp;holdPort);            if ((windowCode == kSrcWindow) || (windowCode == kMskWindow)) {        SetPort(gWList[kSrcWindow].window);        if (ResizeTestWindow(&amp;newDimen,kSrcWindow)) {           oldDimen.h = gWList[kSrcWindow].window-&gt;portRect.right  - gWList[kSrcWindow].window-&gt;portRect.left;          oldDimen.v = gWList[kSrcWindow].window-&gt;portRect.bottom - gWList[kSrcWindow].window-&gt;portRect.top;            SetPort(gWList[kMskWindow].window);          if (ResizeTestWindow(&amp;newDimen,kMskWindow))  {            SizeWindow(gWList[kMskWindow].window,newDimen.h,newDimen.v,false);            SizeWindow(gWList[kSrcWindow].window,newDimen.h,newDimen.v,false);            }          else {            SetPort(gWList[kSrcWindow].window);            ResizeTestWindow(&amp;oldDimen,kSrcWindow);            }          }        }        if ((windowCode == kDstWindow) || (windowCode == kBitWindow)) {        SetPort(gWList[kDstWindow].window);        if (ResizeTestWindow(&amp;newDimen,kDstWindow))  {          oldDimen.h = gWList[kDstWindow].window-&gt;portRect.right  - gWList[kDstWindow].window-&gt;portRect.left;          oldDimen.v = gWList[kDstWindow].window-&gt;portRect.bottom - gWList[kDstWindow].window-&gt;portRect.top;                    SetPort(gWList[kBitWindow].window);          if (ResizeTestWindow(&amp;newDimen,kBitWindow))  {            SizeWindow(gWList[kBitWindow].window,newDimen.h,newDimen.v,false);            SizeWindow(gWList[kDstWindow].window,newDimen.h,newDimen.v,false);            UpdateRgnSettings();            }          else {            SetPort(gWList[kDstWindow].window);            ResizeTestWindow(&amp;oldDimen,kDstWindow);            }          }        }              SetPort(holdPort);      bufferChanged = true;      }        /*  Update the screen with the new changes  */    if (bufferChanged || contentChanged)      DrawBuffer(kBitWindow);      for(i=kSrcWindow; i &lt;= kBitWindow; i++)        DrawWindow(i);        InitCursor();    }      return(okHit);}/*--------------------------------------------------------------------------------------*/void  SelectFGColor (short theItem){  register  i;  RGBColor  tempRGB;  if (theItem == kCustomColor)  {    tempRGB = gFGColor.rgb;    if (GetColor(gZeroPt,&quot;\pSelect a foreground color.&quot;,&amp;tempRGB,&amp;tempRGB))  {      for(i=kSrcWindow; i &lt;= kDstWindow; i++)        DrawWindow(i);      gFGColor.menuIndex   = kCustomColor;      gFGColor.rgb      = tempRGB;      DrawBuffer(kBitWindow);      DrawWindow(kBitWindow);      }    }  else  {    gFGColor.menuIndex   = theItem;    gFGColor.rgb      = gRGBArray[theItem-1];    DrawBuffer(kBitWindow);    DrawWindow(kBitWindow);    }}/*--------------------------------------------------------------------------------------*/void  SelectBKColor  (short theItem){  register  i;  RGBColor  tempRGB;    if (theItem == kCustomColor)  {    tempRGB = gBKColor.rgb;    if (GetColor(gZeroPt,&quot;\pSelect a background color.&quot;,&amp;tempRGB,&amp;tempRGB))  {      for(i=kSrcWindow; i &lt;= kDstWindow; i++)        DrawWindow(i);      gBKColor.menuIndex   = kCustomColor;      gBKColor.rgb      = tempRGB;      DrawBuffer(kBitWindow);      DrawWindow(kBitWindow);      }    }  else  {    gBKColor.menuIndex   = theItem;    gBKColor.rgb      = gRGBArray[theItem-1];    DrawBuffer(kBitWindow);    DrawWindow(kBitWindow);    }}/*--------------------------------------------------------------------------------------*/void  SelectOPColor (short theItem){  register  i;  RGBColor  tempRGB;  if (theItem == kCustomColor)  {    tempRGB = gOPColor.rgb;    if (GetColor(gZeroPt,&quot;\pSelect an OpColor.&quot;,&amp;tempRGB,&amp;tempRGB))  {      for(i=kSrcWindow; i &lt;= kDstWindow; i++)        DrawWindow(i);      gOPColor.menuIndex   = kCustomColor;      gOPColor.rgb      = tempRGB;      DrawBuffer(kBitWindow);      DrawWindow(kBitWindow);      }    }  else  {    gOPColor.menuIndex   = theItem;    gOPColor.rgb      = gRGBArray[theItem-1];    DrawBuffer(kBitWindow);    DrawWindow(kBitWindow);    }}/*--------------------------------------------------------------------------------------*/void  SelectHiliteColor  (short theItem){  register  i;  RGBColor  tempRGB;  if (theItem == kCustomColor)  {    tempRGB = gHiliteColor.rgb;    if (GetColor(gZeroPt,&quot;\pSelect a hilite color.&quot;,&amp;tempRGB,&amp;tempRGB))  {      for(i=kSrcWindow; i &lt;= kDstWindow; i++)        DrawWindow(i);      gHiliteColor.menuIndex   = kCustomColor;      gHiliteColor.rgb      = tempRGB;      DrawBuffer(kBitWindow);      DrawWindow(kBitWindow);      }    }  else  {    gHiliteColor.menuIndex   = theItem;    gHiliteColor.rgb      = gRGBArray[theItem-1];    DrawBuffer(kBitWindow);    DrawWindow(kBitWindow);    }}/*--------------------------------------------------------------------------------------*/void  SelectRgn(short rgnCode, short rgnType){  gRList[rgnCode].type = rgnType;    if (rgnType == kNoRgn)  {    if (gRList[rgnCode].rgn != nil)  {      DisposeRgn(gRList[rgnCode].rgn);      gRList[rgnCode].rgn = nil;      }    }  else  {    gRList[rgnCode].rgn = NewRgn();    OpenRgn();    switch(rgnType)  {      case kDiamondClip:  DrawDiamond();    break;      case kOvalClip:    DrawOval();      break;      case kStarClip:    DrawStar();      break;      case kHoleClip:    DrawHole();      break;      }    CloseRgn(gRList[rgnCode].rgn);    }    DrawBuffer(kBitWindow);  DrawWindow(kBitWindow);}/*--------------------------------------------------------------------------------------*/Boolean  SelectTrap()/*//  This call allows the user to select which of the two copymas traps he wishes to test. */{  DialogPtr  theDlog;  GrafPtr    holdPort;  short    itemHit;    Boolean    okHit      = false;  Boolean    done      = false;  Boolean    bufferChanged  = false;  Boolean    contentChanged  = false;  short    tempTrapSelect   = gTrapSelect;    register   i;  Str255    tempStr;            /*  Allocate and center the dialog  */  CenterWRsrc(DLOG,TrapDlogID,vThird);  theDlog = GetNewDialog(TrapDlogID, nil, (WindowPtr)-1);          /*  If the dialog has been allocated successfully - process the user's selections  */  if (theDlog != nil)  {          /*  Save off the current port.  */    GetPort(&amp;holdPort);    SetPort(theDlog);            /*  Set up user item divider lines */    SetDlogItemProc(theDlog,diTrapLine1,(ProcPtr)FrameDlogItemRect);    SetDlogItemProc(theDlog,diTrapLine2,(ProcPtr)FrameDlogItemRect);            /*  Init the radio buttons to reflect current selection.  */    HandleRadioButtons(theDlog,diCopyMaskButton,diCopyBitsButton,tempTrapSelect+diCopyMaskButton);          /*  Display the dialog  */    ShowWindow(theDlog);            /*  Process the user's actions  */    do  {      ModalDialog((ProcPtr)HandleOkayCancel, &amp;itemHit);            switch (itemHit)  {          case  ok:        okHit = true;              case  cancel:      done  = true;                      break;                  case  diCopyMaskButton:          case  diCopyDeepButton:          case  diCopyBitsButton: HandleRadioButtons(theDlog,diCopyMaskButton,diCopyBitsButton,itemHit);                      tempTrapSelect  = itemHit - diCopyMaskButton;                      break;          }      }  while ( !done );          DisposDialog(theDlog);    SetPort(holdPort);    }      if ((okHit) &amp;&amp; (gTrapSelect != tempTrapSelect))  {    for(i=kSrcWindow; i &lt;= kBitWindow; i++)      DrawWindow(i);          gTrapSelect = tempTrapSelect;    GetIndString(&amp;tempStr, kTitleStrings, gTrapSelect+4);    SetWTitle(gWList[kBitWindow].window,tempStr);         ShowHide(gWList[kMskWindow].window, !(gTrapSelect==kCopyBits));      DrawBuffer(kBitWindow);    DrawWindow(kBitWindow);    }      return(okHit);}/*--------------------------------------------------------------------------------------*/void  NeedSystem7Dlog()/*//  This dialog alerts the user that system 7.0 is needed for the app to run. */{  DialogPtr  theDlog;  GrafPtr    holdPort;  short    itemHit;  Boolean    done    = false;            /*  Allocate and center the dialog  */  CenterWRsrc(DLOG,Sys7DlogID,vThird);  theDlog = GetNewDialog(Sys7DlogID, nil, (WindowPtr)-1);          /*  If the dialog has been allocated successfully - process the user's selections  */  if (theDlog != nil)  {          /*  Save off the current port.  */    GetPort(&amp;holdPort);    SetPort(theDlog);    FrameDlogButton  (theDlog,ok);              /*  Display the dialog  */    ShowWindow(theDlog);            /*  Process the user's actions  */    do  {          ModalDialog((ProcPtr)HandleOkayCancel, &amp;itemHit);      done = (itemHit == ok);                 }  while ( !done );          DisposDialog(theDlog);    SetPort(holdPort);    }}/*--------------------------------------------------------------------------------------*/void  AboutBitBlitz(){   DialogPtr  theDlog;  GrafPtr    holdPort;  short    itemHit;  Boolean    done      = false;  CenterWRsrc(DLOG,AboutBoxDlogID,vThird);  theDlog = GetNewDialog(AboutBoxDlogID, nil, (WindowPtr)-1);  if (theDlog != nil)  {          /*  Save off the current port.  */    GetPort(&amp;holdPort);    SetPort(theDlog);              /*  Display the dialog  */    ShowWindow(theDlog);                /*  Display about box until mouseDown  */    do  {      ModalDialog((ProcPtr)HandleOkayCancel, &amp;itemHit);      done  = (itemHit == 1);      }  while ( !done );                  /*  Cleanup before returning  */    DisposDialog(theDlog);    SetPort(holdPort);    }}/*======================================================================================*//*  Offscreen buffer imaging routines   *//*--------------------------------------------------------------------------------------*/void  FillSolid(RGBColor *theRGB, Rect *boundRect)/*  //  FillSolid() preserves and restores the current foreground color setting while filling//  the specified Rect with the desired color.*/{  RGBColor  holdRGB;     GetForeColor(&amp;holdRGB);    RGBForeColor(theRGB);  PaintRect(boundRect);    RGBForeColor(&amp;holdRGB);}/*--------------------------------------------------------------------------------------*/  void  DoCopy()/*  //  DoCopy() updates the buffer associated with the copy window.  This update takes //  two steps.  Since the contents of the specified destination bitmap are overwritten by //  the copy result we keep both a destination window and the copy window.  Before performing //  the copy trap, the contents of the destination window's buffer are copied into the copy//  window's buffer.  This buffer is then passed along with the source and mask window's buffers//  to the copy routine.  */{  GrafPtr      holdPort;  GDHandle    holdDevice;  BitMap      *srcBits, *mskBits, *dstBits;  Rect      *srcRect, *mskRect, *dstRect;  PixMapHandle  srcBuffer, mskBuffer, dstBuffer, bitBuffer;      /*  If the user selects to use screen bits for the copy call the buffer pointer      //  that is passed to the copy call is set to the window's portbits.      */  if (gUseScreenBits) {    srcBits = &amp;gWList[kSrcWindow].window-&gt;portBits;    srcRect = &amp;gWList[kSrcWindow].window-&gt;portRect;    if (gWList[kMskWindow].bufferType == kBitMap) {      mskBits = &amp;gWList[kMskWindow].buffer.bitmap-&gt;portBits;      mskRect = &amp;gWList[kMskWindow].buffer.bitmap-&gt;portBits.bounds;      }    else  {      mskBuffer  = GetGWorldPixMap(gWList[kMskWindow].buffer.gworld);      LockPixels(mskBuffer);      mskBits     = *mskBuffer;      mskRect    = &amp;gWList[kMskWindow].buffer.gworld-&gt;portRect;      }          /* The cursor is hidded during the copy so as not to interfere with the image  */    HideCursor();    }          /* Otherwise, the offscreen gworld's portbits are passed  */  else  {    if (gWList[kSrcWindow].bufferType == kBitMap) {      srcBits = &amp;gWList[kSrcWindow].buffer.bitmap-&gt;portBits;      srcRect = &amp;gWList[kSrcWindow].buffer.bitmap-&gt;portBits.bounds;      }    else  {      srcBuffer  = GetGWorldPixMap(gWList[kSrcWindow].buffer.gworld);      LockPixels(srcBuffer);      srcBits     = *srcBuffer;      srcRect    = &amp;gWList[kSrcWindow].buffer.gworld-&gt;portRect;      }    if (gWList[kMskWindow].bufferType == kBitMap) {      mskBits = &amp;gWList[kMskWindow].buffer.bitmap-&gt;portBits;      mskRect = &amp;gWList[kMskWindow].buffer.bitmap-&gt;portBits.bounds;      }    else  {      mskBuffer  = GetGWorldPixMap(gWList[kMskWindow].buffer.gworld);      LockPixels(mskBuffer);      mskBits     = *mskBuffer;      mskRect    = &amp;gWList[kMskWindow].buffer.gworld-&gt;portRect;      }    }  switch(gWList[kBitWindow].bufferType) {    case kBitMap:        GetPort(&amp;holdPort);      SetPort(gWList[kBitWindow].buffer.bitmap);            CopyBits(&amp;gWList[kDstWindow].buffer.bitmap-&gt;portBits,      &amp;gWList[kBitWindow].buffer.bitmap-&gt;portBits,           &amp;gWList[kDstWindow].buffer.bitmap-&gt;portBits.bounds,     &amp;gWList[kBitWindow].buffer.bitmap-&gt;portBits.bounds, srcCopy, NULL);            if (gUseScreenBits) {        DrawWindow(kBitWindow);        dstBits = &amp;gWList[kBitWindow].window-&gt;portBits;        dstRect = &amp;gWList[kBitWindow].window-&gt;portRect;        }      else  {        dstBits = &amp;gWList[kBitWindow].buffer.bitmap-&gt;portBits;        dstRect = &amp;gWList[kBitWindow].buffer.bitmap-&gt;portBits.bounds;        }      SetEnv();      if (gTrapSelect == kCopyMask)        CopyMask(srcBits, mskBits, dstBits, srcRect, mskRect, dstRect);      else if (gTrapSelect == kCopyDeepMask)         CopyMask2(srcBits, mskBits, dstBits, srcRect, mskRect, dstRect, gCopyMode, gRList[kMskRgn].rgn);      else         CopyBits (srcBits, dstBits, srcRect, dstRect, gCopyMode, gRList[kMskRgn].rgn);      RestoreEnv();                              SetPort(holdPort);      break;          case kGWorld:      dstBuffer = GetGWorldPixMap(gWList[kDstWindow].buffer.gworld);      bitBuffer = GetGWorldPixMap(gWList[kBitWindow].buffer.gworld);      LockPixels(dstBuffer);      LockPixels(bitBuffer);            GetGWorld(&amp;(CGrafPtr)holdPort,&amp;holdDevice);      SetGWorld((CGrafPtr)gWList[kBitWindow].buffer.gworld,nil);      CopyBits(*dstBuffer,                   *bitBuffer,           &amp;gWList[kDstWindow].buffer.gworld-&gt;portRect, &amp;gWList[kBitWindow].buffer.gworld-&gt;portRect, srcCopy, nil);      if (gUseScreenBits) {        SetGWorld((CGrafPtr)holdPort,holdDevice);        GetPort(&amp;holdPort);        SetPort(gWList[kBitWindow].window);        DrawWindow(kBitWindow);        dstBits = &amp;gWList[kBitWindow].window-&gt;portBits;        dstRect = &amp;gWList[kBitWindow].window-&gt;portRect;        }      else  {        dstBits = *bitBuffer;        dstRect = &amp;gWList[kBitWindow].buffer.gworld-&gt;portRect;        }      SetEnv();      if (gTrapSelect == kCopyMask)        CopyMask(srcBits, mskBits, dstBits, srcRect, mskRect, dstRect);      else if (gTrapSelect == kCopyDeepMask)        CopyMask2(srcBits, mskBits, dstBits, srcRect, mskRect, dstRect, gCopyMode, gRList[kMskRgn].rgn);      else         CopyBits (srcBits, dstBits, srcRect, dstRect,  gCopyMode, gRList[kMskRgn].rgn);      RestoreEnv();      if (gUseScreenBits) {        SetPort(holdPort);                GetGWorld(&amp;(CGrafPtr)holdPort,&amp;holdDevice);        SetGWorld((CGrafPtr)gWList[kBitWindow].buffer.gworld,nil);        CopyBits(dstBits, *bitBuffer, dstRect, &amp;gWList[kBitWindow].buffer.gworld-&gt;portRect, srcCopy, nil);        }                   SetGWorld((CGrafPtr)holdPort,holdDevice);      UnlockPixels(dstBuffer);      UnlockPixels(bitBuffer);      break;    }  if (gUseScreenBits)     ShowCursor();  else {    if (gWList[kSrcWindow].bufferType == kGWorld)      UnlockPixels(srcBuffer);    if (gWList[kMskWindow].bufferType == kGWorld)      UnlockPixels(mskBuffer);      }}/*--------------------------------------------------------------------------------------*/  void  ImageBuffer(short windowCode)/*//  ImageBuffer() sets the current port in accordance with the buffer type, draws the image//  designated by the contentType, and restores current port to its original setting.*/{  GrafPtr    holdPort;  GDHandle  holdDevice;  Rect    bufferRect;  switch(gWList[windowCode].bufferType) {    case kBitMap:        GetPort(&amp;holdPort);      SetPort(gWList[windowCode].buffer.bitmap);      bufferRect = gWList[windowCode].buffer.bitmap-&gt;portBits.bounds;      break;          case kGWorld:      LockPixels(GetGWorldPixMap(gWList[windowCode].buffer.gworld));      GetGWorld(&amp;holdPort,&amp;holdDevice);      SetGWorld(gWList[windowCode].buffer.gworld,nil);      bufferRect = gWList[windowCode].buffer.gworld-&gt;portRect;      break;    }        switch (gWList[windowCode].contentType)  {    case kHLSRectBlend:    HLSRectBlend    (&amp;bufferRect,gWList[windowCode].content.saturation); break;    case kHLSHBlend:    HLSHLinearBlend    (&amp;bufferRect,gWList[windowCode].content.saturation); break;    case kHLSVBlend:    HLSVLinearBlend    (&amp;bufferRect,gWList[windowCode].content.saturation); break;    case kGrayRectBlend:  GrayRectBlend    (&amp;bufferRect);                     break;    case kGrayHBlend:    GrayHLinearBlend  (&amp;bufferRect);                     break;    case kGrayVBlend:    GrayVLinearBlend  (&amp;bufferRect);                     break;    case kGrayPatRectBlend: GrayPatRectBlend  (&amp;bufferRect);                      break;    case kGrayPatHBlend:  GrayPatHLinearBlend (&amp;bufferRect);                      break;    case kGrayPatVBlend:  GrayPatVLinearBlend (&amp;bufferRect);                      break;    case kSolidRGB:      FillSolid      (&amp;gWList[windowCode].content.RGB,&amp;bufferRect);     break;    case kPICT:        if (gWList[windowCode].content.pictInfo != nil)                  DrawPicture(gWList[windowCode].content.pictInfo,&amp;bufferRect);                              break;    }    switch(gWList[windowCode].bufferType) {    case kBitMap:  SetPort  (holdPort);                    break;    case kGWorld:  SetGWorld(holdPort,holdDevice);                UnlockPixels(GetGWorldPixMap(gWList[windowCode].buffer.gworld));            break;    }}/*--------------------------------------------------------------------------------------*/  void  DrawBuffer(short windowCode)/*  //  DrawBuffer() redraws the specified window's offscreen buffer.*/{    if (windowCode == kBitWindow)     DoCopy();  else    ImageBuffer(windowCode);}/*======================================================================================*//*  Offscreen-to-onscreen transferral   *//*--------------------------------------------------------------------------------------*/void  DrawWindow(short windowCode)/*  //  DrawWindow() draws the current contents of the specified window's buffer to that window.*/{  GrafPtr      holdPort;  PixMapHandle  windowBuffer;              /*  Save the current port setting and set the current port to the specified window  */  GetPort(&amp;holdPort);  SetPort(gWList[windowCode].window);          /*  Switch off the current buffer type setting to perform the appropriate copybits  */  switch(gWList[windowCode].bufferType) {    case kBitMap:        CopyBits(&amp;gWList[windowCode].buffer.bitmap-&gt;portBits,      &amp;gWList[windowCode].window-&gt;portBits,           &amp;gWList[windowCode].buffer.bitmap-&gt;portBits.bounds,     &amp;gWList[windowCode].window-&gt;portRect, srcCopy, NULL);      break;          case kGWorld:      windowBuffer = GetGWorldPixMap(gWList[windowCode].buffer.gworld);      LockPixels(windowBuffer);      CopyBits(*windowBuffer,                 &amp;gWList[windowCode].window-&gt;portBits,           &amp;gWList[windowCode].buffer.gworld-&gt;portRect, &amp;gWList[windowCode].window-&gt;portRect, srcCopy, NULL);      UnlockPixels(windowBuffer);      break;    }        /*  Restore the current port to its original setting.  */  SetPort(holdPort);}/*======================================================================================*//*  Window/Buffer resizing routines  *//*--------------------------------------------------------------------------------------*/Boolean  ResizeTestWindow(Point *newDimen, short windowCode)/*  //  ResizeWindow() sizes the specifed window to the new dimensions.*/{  Rect    tempRect, oldRect;  Boolean    bufferScaled;  GrafPtr    tempBits;  GWorldFlags  gwError;      switch(gWList[windowCode].bufferType) {    case kBitMap:            oldRect  =  tempRect = gWList[windowCode].buffer.bitmap-&gt;portBits.bounds;      tempRect.bottom     = tempRect.top  + newDimen-&gt;v;      tempRect.right      = tempRect.left + newDimen-&gt;h;        DisposeOSBitmap(gWList[windowCode].buffer.bitmap);            bufferScaled     = CreateOSBitmap(&amp;tempBits,&amp;tempRect);      if (bufferScaled)          gWList[windowCode].buffer.bitmap = tempBits;      else        CreateOSBitmap(&amp;gWList[windowCode].buffer.bitmap,&amp;oldRect);            break;        case kGWorld:      tempRect       = gWList[windowCode].buffer.gworld-&gt;portRect;      tempRect.bottom  = tempRect.top  + newDimen-&gt;v;      tempRect.right   = tempRect.left + newDimen-&gt;h;            gwError          = UpdateGWorld(&amp;gWList[windowCode].buffer.gworld, gWList[windowCode].bufferDepth, &amp;tempRect, nil, nil, clipPix);      bufferScaled     = ((gwError &amp; gwFlagErr) == 0);      break;    }  if (bufferScaled)  {    if (windowCode != kBitWindow)       DrawBuffer(windowCode);    }  else    OKRsrcAlert(kErrorStrings,kResizeMemErr);      return(bufferScaled);}/*======================================================================================*//*  Test Window allocation/disposal routines  *//*--------------------------------------------------------------------------------------*/  void  CalcWindowRect(Rect *windowRect, short windowCode)/*  //  This procedure calculates the window rect for the window designated by windowCode.//  It essentially divides the screen into 4 equal quadrants and insets the rect defining//  the window's rect appropriately in order to have it positioned correctly on whatever//  size screen the application is run.*/{  #define    kTitleBarHeight    20     #define    kWindowSep      10    /*  # pixels between windows and space between edge  */                      /*  of screen and window                */  Rect    screenRect;  Point    windowCenter;  screenRect = qd.screenBits.bounds;  screenRect.top += MBarHeight;  windowCenter.h    = screenRect.left  + (HRectLength(&amp;screenRect) &gt;&gt; 1);  windowCenter.v    = screenRect.top   + (VRectLength(&amp;screenRect) &gt;&gt; 1);    switch (windowCode)  {    case kSrcWindow:      SetRect(windowRect, screenRect.left+kWindowSep,                 screenRect.top+kWindowSep+kTitleBarHeight,                 windowCenter.h-(kWindowSep/2),                  windowCenter.v-(kWindowSep/2));      break;          case kMskWindow:      SetRect(windowRect, windowCenter.h+(kWindowSep/2),                screenRect.top+kWindowSep+kTitleBarHeight,                screenRect.right-kWindowSep,                windowCenter.v-(kWindowSep/2));      break;          case kDstWindow:      SetRect(windowRect, screenRect.left+kWindowSep,                windowCenter.v+(kWindowSep/2)+kTitleBarHeight,                windowCenter.h-(kWindowSep/2),                screenRect.bottom-kWindowSep);      break;          case kBitWindow:      SetRect(windowRect ,windowCenter.h+(kWindowSep/2),                windowCenter.v+(kWindowSep/2)+kTitleBarHeight,                screenRect.right-kWindowSep,                screenRect.bottom-kWindowSep);      break;    }}/*--------------------------------------------------------------------------------------*/  Boolean  CreateTestWindows(){/*  This function allocates, initializes, and displays the four test windows.  If an error //  occurs during this process and error message is displayed.  All memory allocated is //  disposed.  And false is returned so that the application will terminate from main. */    register  i;  Rect    tempRect;  Str255    title;      for (i = kSrcWindow; i &lt;= kBitWindow; i++)  {    CalcWindowRect(&amp;tempRect,i);      GetIndString(&amp;title, kTitleStrings, i+1);    if (gColorAvail)      gWList[i].window = NewCWindow(nil,&amp;tempRect,title,true,documentProc,(WindowPtr)-1, false,0);    else      gWList[i].window = NewWindow(nil,&amp;tempRect,title,true,documentProc,(WindowPtr)-1, false,0);    if  (gWList[i].window == nil)      goto handle_init_error;          if  (!CreateWindowBuffer(i))      goto handle_init_error;        DrawBuffer(i);        DrawWindow(i);    }      return(true);  handle_init_error:  DisposeTestWindows();            OKRsrcAlert(kErrorStrings,kBootMemErr);            return(false);}/*--------------------------------------------------------------------------------------*/void  DisposeTestWindows()/*//  This procedure takes care of disposing all memory allocated in association with any //  of the app windows before the application quits either normally or in response to an//  unrecoverable error.*/{    register i;    for (i = kSrcWindow; i &lt;= kBitWindow; i++)  {    if ((gWList[i].contentType == kPICT) &amp;&amp; (gWList[i].content.pictInfo != nil))      DisposHandle((Handle)gWList[i].content.pictInfo);    DisposeWindowBuffer(i);      if (gWList[i].window != nil)      DisposeWindow(gWList[i].window);    }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Bitblitz/listing11.html%3Fid%3DDTS10000066-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Bitblitz/listing11.html%3Fid%3DDTS10000066-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Bitblitz/listing11.html%3Fid%3DDTS10000066-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>