<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"            "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!--Template 06-20-02--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Q&amp;A GX07: Embedding a GX Picture into a PICT</title><meta name="keywords" content="Mac OS 8 QuickDraw GX embedding converting GX Picture PICT "><meta name="Description" content="Technical Q&amp;A GX07: Note:The latest Mac OS releases, MacOS 8.5.x and 8.6, will be the final operating system releasesfrom Apple to include support for QuickDraw GX. Q&amp;A showshow to convert a QuickDraw GX picture into a QuickDraw PICTby embedding the picture into the PICT using a Quicktimecodec. Q&amp;A also provides the sample code for using this codecwhich also works on embedding proxies for machines withoutQuickDraw GX."><meta name="categories" content="QuickDraw GX"><meta name="week-posted" content="Sep 11, 1995 - Sep 15, 1995"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10001212" title="Embedding a GX Picture into a PICT"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalqas/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A GX07</div>
<div id="pageheadsub">Embedding a GX Picture into a PICT</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment -->    <!-- begin_content --> <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=600><TR> <td align="left"><hr width=500 align=center><p id = p2>Q:  Is there a QuickTime codec for converting QuickDraw GX pictures to QuickDrawPICT format? If so, can you provide this?</p><p id=p4>A:  At a WWDC '95 session, a new technique for exporting GX pictures as QuickDrawPICT files was demonstrated. The method makes use of QuickTime and a new codec(COmpressor-DECompressor) which is included in the GX extension version 1.1 andgreater. By using this codec, one can embed a flattened GX picture into a PICTfile (or a QuickTime movie). We recommend that you use this method if you wantto allow your GX application to exchange pictures with existing QuickDrawapplications.</p><p id=p4>One important feature of this codec is that does not convert QuickDraw GXpictures to QuickDraw PICT in the traditional sense of the word "convert." Whatthis codec allows is the embedding of GX objects inside a PICT file format. Theadvantage of this is that it allows GX pictures to be viewed (but not edited)in any application that can open a PICT file. Although "embedding" is veryuseful, it is quite different from "conversion."</p><p id=p4>Strictly speaking, it is not possible "convert" QuickDraw GX pictures toQuickDraw PICTs without loss of information because GX has much greaterfunctionality than traditional QuickDraw. There is no way to represent complextransfer modes, perspective, advances typography, etc. using the QuickDrawimaging model. By using this codec, you do not lose any of these features.</p><p id=p4>If you looking for information on how to use the codec, here is sample code.This file (which was accidentally omitted from the last SDK) called"DecompressShape.c" contains all the code you need to embed a GX shape into aPICT using the new codec. The important routine in this file is:</p> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   PicHandle DecompressShape (gxShape theShape, PicHandle proxie,                  Boolean forPrintingOnly, Boolean eraseBackground)</pre>	</TD></TR></TABLE></CENTER><p id=p4>A proxie can also be embedded so that the PICT can be viewed on machineswithout GX. On the September 95 GX SDK, this source file will be added to theGX Libraries folder (it may be renamed however to give abetter indication ofits function). Note that the "DecompressShape.c" technique is quite differentfrom that used in the older "PicturesAndPICTLibrary.c" which embeds a GX shapeinto a PICT using picComments. We recommend you use <code>DecompressShape</code> because<code>picComments</code> have several weaknesses including:</p><ol><li>they are limited to 32K</li><li>many applications strip out any <code>picComments</code> they don't recognize.</li><li><code>DrawPicture()</code> ignores all <code>picComments</code></li></ol><P id = p4>By using the codec to embed the GX picture, all these problems are avoided.</p> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/*    File:       DecompressShape.h    Contains:   graphics libraries - shape decompression    Written by: Mike Reed    Copyright:  (c) 1995 by Apple Computer, Inc., all rights reserved.    Writers:        (jtd)   John Daggett    Change History (most recent first):         &lt;1&gt;   9/14/95    jtd     First checked in.*/#pragma once#ifndef decompressShapeIncludes    #define decompressShapeIncludes    #include &lt;QuickDraw.h&gt;    #include &lt;GXTypes.h&gt;    #ifdef __cplusplus    extern "C" {    #endif    Handle CreateQDGXStream(gxShape source, PicHandle proxie,         Boolean forPrintingOnly, Boolean eraseBackground);    PicHandle DecompressShape(gxShape theShape, PicHandle proxie,         Boolean forPrintingOnly, Boolean eraseBackground);    PicHandle ShapeToPICT(gxShape source);    void ShapeToScrap(gxShape source, Boolean addProxie,         Boolean forPrintingOnly, Boolean eraseBackground);    void DragAndDropShape(EventRecord* event, gxShape shape);    #ifdef __cplusplus    };    #endif#endif/*    File:       DecompressShape.c    Contains:   graphics libraries - shape decompression    Written by: Mike Reed    Copyright:  (c) 1995 by Apple Computer, Inc., all rights reserved.    Writers:        (jtd)   John Daggett    Change History (most recent first):         &lt;2&gt;   9/14/95    jtd     replaced boolean with Boolean         &lt;1&gt;   9/14/95    jtd     First checked in.*/#include &lt;Drag.h&gt;#include &lt;Gestalt.h&gt;#include &lt;ImageCompression.h&gt;#include &lt;Memory.h&gt;#include &lt;Scrap.h&gt;#include &lt;GXTypes.h&gt;#include &lt;GXMath.h&gt;#include &lt;GXGraphics.h&gt;#include &lt;GXEnvironment.h&gt;#include "StorageLibrary.h"#include "DecompressShape.h"#define LONGALIGN(n)        (((n) + 3) &amp; ~3L)#define kAtomHeaderSize     (sizeof(Size) + sizeof(OSType))static void RectangleToRect(const gxRectangle* gxr, Rect* qdr){    qdr-&gt;left = FixedRound(gxr-&gt;left);    qdr-&gt;top = FixedRound(gxr-&gt;top);    qdr-&gt;right = FixedRound(gxr-&gt;right);    qdr-&gt;bottom = FixedRound(gxr-&gt;bottom);}static long* AppendAtom(long stream[], Size size, OSType tag, const void* data){#ifdef debugging    if (size &amp; 3)        DebugStr("\patom size needs to be long aligned");#endif    *stream++   = size + kAtomHeaderSize;    *stream++   = tag;    BlockMove(data, (Ptr)stream, size);    return (long*)((char*)stream + size);}/* *  See the comment on DecompressShape for an explanation of the parameters. *  This routine is used by both DecompressShape for embedding shapes in PICTs, *  and AddQDGXRecorderFrame for making gx movies.*/Handle CreateQDGXStream(gxShape source, PicHandle proxie,    Boolean forPrintingOnly, Boolean eraseBackground){    #define         gxForPrintingOnlyAtom   'fpto'    #define         gxEraseBackgroundAtom   'erbg'    long atomCount, shapeSize, proxieSize;    long dataSize, fontListSize, eraseSize;    Handle dataHdl, shapeHdl;    gxFlatFontList* fontList;    gxTag fontListTag;#ifdef debugging    GXIgnoreGraphicsWarning(tags_of_type_flst_removed);#endif    shapeHdl = ShapeToHandleWithFlags(source, gxFontListFlatten             | gxFontGlyphsFlatten | gxFontVariationsFlatten);#ifdef debugging    GXPopGraphicsWarning();#endif    if (shapeHdl == nil)        return nil;    if (proxie)    {   atomCount = 2;        proxieSize = LONGALIGN(GetHandleSize((Handle)proxie));    }    else    {   atomCount = 1;        proxieSize = 0;    }    shapeSize = LONGALIGN(GetHandleSize(shapeHdl));    if (forPrintingOnly)        ++atomCount;    if (eraseBackground)        ++atomCount;    fontListSize = 0;    fontList = nil;    GXIgnoreGraphicsWarning(count_out_of_range);    if (GXGetShapeTags(source, gxFlatFontListItemTag, 1,            1, &amp;fontListTag) &gt; 0)    {   fontListSize = GXGetTag(fontListTag, nil, nil);        if (fontListSize &gt; 0)        {   fontList = (gxFlatFontList*)NewPtr(fontListSize);            if (fontList != nil)            {   GXGetTag(fontListTag, nil, fontList);                fontListSize = LONGALIGN(fontListSize);                ++atomCount;            }            else                fontListSize = 0;        }    }    GXPopGraphicsWarning();     // count_out_of_range    dataSize = atomCount * kAtomHeaderSize + shapeSize               + proxieSize + fontListSize + sizeof(long);    dataHdl = NewHandle(dataSize);    if (dataHdl == nil)    {   DisposHandle(shapeHdl);        if (fontList)            DisposPtr((Ptr)fontList);        return nil;    }    {   long* p = (long*)*dataHdl;        if (forPrintingOnly)            p = AppendAtom(p, 0, gxForPrintingOnlyAtom, nil);        if (eraseBackground)            p = AppendAtom(p, 0, gxEraseBackgroundAtom, nil);        if (proxie)            p = AppendAtom(p, proxieSize, 'PICT', *proxie);        if (fontList)            p = AppendAtom(p, fontListSize,                            gxFlatFontListItemTag, fontList);        p = AppendAtom(p, shapeSize, 'qdgx', *shapeHdl);        *p++ = 0;       // end of the atom-list        DisposHandle(shapeHdl);        if (fontList)            DisposPtr((Ptr)fontList);    }    return dataHdl;}static void GetRidOfAnyQDShapeTags(gxShape shape){    gxShapeType shapeType = GXGetShapeType(shape);    if (shapeType == gxPictureType)    {   long        index, count;        gxShape*    subShapes;        count = GXGetPicture(shape, nil, nil, nil, nil);        if (count &gt; 0)        {   subShapes = (gxShape*)NewPtr(count * sizeof(gxShape));            if (subShapes != nil)            {   GXGetPicture(shape, subShapes, nil, nil, nil);                for (index = 0; index &lt; count; index++)                    GetRidOfAnyQDShapeTags(subShapes[index]);                DisposPtr((Ptr)subShapes);            }        }    }    else if (shapeType == gxRectangleType &amp;&amp;             GXGetShapeTags(shape, gxQuickDrawPictTag,             1, gxSelectToEnd, nil) &gt; 0)        GXSetShapeType(shape, gxPictureType);}/* *  This guy returns a Quickdraw picture containing an embedded shape, and a proxie of the shape, if proxie is not nil. This is called by ShapeToScrap and DragAndDropShape. * *  theShape            * the shape you want to embedd in a PICT *  proxie          * a PICT to be drawn if theShape cannot be           drawn (optional but recommended) *  forPrintingOnly     * if TRUE, then the decompressor will           always look for the proxie and theShape will only be used           when printing. Use this setting if theShape might be too           large or too slow when drawn from other apps. If FALSE,           then the decompressor will draw theShape unless it           gets an error, in which case it will look for a proxie. *  eraseBackground * if TRUE, the decompressor will always erase           the background to WHITE before drawing the shape. This           is slower, but needed if the shape does not fill its           bounding rectangle. if FALSE, the decompressor will           just draw the shape. Use this setting if the shape           entirely fills its bounding rectangle.The shape [and proxie] is embedded by constructing a stream ofatoms. Each atom begins with a size (long) and a type (OSType)and then the data for that type. After the last atom, thereis a trailing zero (long) to mark the end of the stream. Forembedded shapes, the type is 'qdgx', and for the proxie thetype is 'PICT'. Note that the size fields are rounded up toa multiple of 4. Finally, to alert QuickTime that the datais in this parsable form with a possible PICT proxie, we adda 'prxy' extension to the ImageDescriptionHandle.Picture of this form will draw the embedded shape when anapplication calls DrawPicture if GX is around, and if not,the proxie will be drawn. When printed, the shape or theproxie will be printed. This is meant to replace thePicComment described in GX 1.0 for embedding shapes inpictures.If you want to include a flatFontList tag, be sure thattheShape is a picture, otherwise GX will not return thetag after GXFlattenShape. The flatFontList tag makescertain printing conditions more efficient (i.e. fontdownloading to postscript printers).Your shape must not contain a gxQuickDrawPictTag, meaningit contains embedded QD data, becuase this will potentiallycrash when it tries to print. To fix that, DecompressShapelooks for occurrances of the tag, and converts them to realgx data by calling GXSetShapeType(shape, gxPictureType).*/PicHandle DecompressShape(gxShape theShape, PicHandle proxie,                     Boolean forPrintingOnly, Boolean eraseBackground){    #define             kQuickTimeGestalt       'qtim'    PicHandle               thePicture;    ImageDescriptionHandle  descHdl;    ImageDescriptionPtr     descPtr;    Handle              dataHdl;    long                    version;    if (Gestalt(kQuickTimeGestalt, &amp;version) != noErr)        return nil;    GetRidOfAnyQDShapeTags(theShape);    /*     *  Move the shape's topLeft to 0,0 so that it draws neatly inside the picture frame.     *  Note that the qdgx movie library does not move the shape, since the shape may not     *  take up the whole frame.    */    {   gxRectangle bounds;        GXGetShapeLocalBounds(theShape, &amp;bounds);        if (bounds.left || bounds.top)            GXMoveShape(theShape, -bounds.left, -bounds.top);        dataHdl = CreateQDGXStream(theShape, proxie, forPrintingOnly, eraseBackground);        if (bounds.left || bounds.top)            GXMoveShape(theShape, bounds.left, bounds.top);    }    if (dataHdl == nil)        return nil;    descHdl = (ImageDescriptionHandle)NewHandleClear(sizeof(ImageDescription));    if (descHdl)    {   Rect            shortBounds;        gxRectangle bounds;        GXGetShapeLocalBounds(theShape, &amp;bounds);        RectangleToRect(&amp;bounds, &amp;shortBounds);        OffsetRect(&amp;shortBounds, -shortBounds.left,            -shortBounds.top);  // set the topLeft of the src to 0,0        thePicture = OpenPicture(&amp;shortBounds);        descPtr = *descHdl;        descPtr-&gt;idSize = sizeof(ImageDescription);        descPtr-&gt;cType = 'qdgx';        descPtr-&gt;vendor = 'appl';        descPtr-&gt;temporalQuality = codecLosslessQuality;        descPtr-&gt;width = shortBounds.right;        descPtr-&gt;height = shortBounds.bottom;        descPtr-&gt;hRes = descPtr-&gt;vRes = ff(72);        descPtr-&gt;dataSize = GetHandleSize(dataHdl);        descPtr-&gt;frameCount = 1;        descPtr-&gt;depth = 32;        descPtr-&gt;clutID = -1;        //  If there is a PICT proxie, add an image extension to        //  tell QuickTime, in case GX is not around.        if (proxie)        {   Handle prxyVersionHdl = NewHandle(sizeof(long));            if (prxyVersionHdl != nil)            {   *(long*)*prxyVersionHdl = 0;        // version number for 'prxy' extension                SetImageDescriptionExtension(descHdl, prxyVersionHdl, 'prxy');            }        }        HLock(dataHdl);        DecompressImage(*dataHdl, descHdl,            ((CGrafPtr)qd.thePort)-&gt;portPixMap, &amp;shortBounds,            &amp;shortBounds, srcCopy, nil);        DisposeHandle((Handle)descHdl);        ClosePicture();    }    else        thePicture = nil;    DisposHandle(dataHdl);    return thePicture;}/* *  This guy returns a Quickdraw picture containing a 1-bit bitmap of the shape. *  This is used by ShapeToScrap to create a proxie when calling DecompressShape. *  If you want to make the proxie prettier (and larger), change the bitmap to 8-bit. *  However, if you're using this in conjunction with DecompressShape to place a *  gxShape on the clipboard, 1-bit should be enough, since the actual shape will be *  drawn, rather than the proxie (unless forPrintingOnly is true).*/PicHandle ShapeToPICT(gxShape source){    gxRectangle bounds;    gxShape     bitShape;    gxBitmap        bitmap;    PicHandle       thePicture;    Rect            shortBounds;    /*     *  GetShapeLocalBounds doesn't accurately report the bounds of a gxQuickDrawPictTag.     *  One option is to convert the tags to real GX pictures.    */    GetRidOfAnyQDShapeTags(source);    GXGetShapeLocalBounds(source, &amp;bounds);    RectangleToRect(&amp;bounds, &amp;shortBounds);    OffsetRect(&amp;shortBounds, -shortBounds.left, -shortBounds.top);    bitmap.width        = shortBounds.right;    bitmap.height       = shortBounds.bottom;    bitmap.rowBytes = bitmap.width + 31 &gt;&gt; 5 &lt;&lt; 2;    bitmap.pixelSize    = 1;    bitmap.space        = gxIndexedSpace;    bitmap.set          = nil;    bitmap.profile      = nil;    bitmap.image        = NewPtrClear(bitmap.rowBytes * bitmap.height);    if (bitmap.image == nil)        return nil;    bitShape = GXNewBitmap(&amp;bitmap, nil);    if (bitShape != nil)    {   gxViewGroup group   = GXNewViewGroup();        gxViewDevice device = GXNewViewDevice(group, bitShape);        gxViewPort port = GXNewViewPort(group);        gxTransform trans   = GXCloneTransform(GXGetShapeTransform(source));        GXSetShapeAttributes(source, GXGetShapeAttributes(source) | gxMapTransformShape);        GXMoveShape(source, -bounds.left, -bounds.top);        GXSetViewPortDither(port, 4);        GXSetShapeViewPorts(source, 1, &amp;port);        GXDrawShape(source);        GXSetShapeTransform(source, trans);        GXDisposeTransform(trans);        GXDisposeViewGroup(group);  /* this disposes the gxViewPort and gxViewDevice */        GXDisposeShape(bitShape);    }    {   GrafPtr thePort;        BitMap  srcBits;        GetPort(&amp;thePort);        srcBits.baseAddr = bitmap.image;        srcBits.rowBytes = bitmap.rowBytes;        srcBits.bounds = shortBounds;        thePicture = OpenPicture(&amp;shortBounds);        CopyBits(&amp;srcBits, &amp;thePort-&gt;portBits,                &amp;shortBounds, &amp;shortBounds, srcOr, nil);        ClosePicture();    }    DisposPtr((Ptr)bitmap.image);    return thePicture;}/* *  This guy puts a Quickdraw picture on the clipboard containing an embedded shape *  and, if addProxie is true, a 1-bit bitmap of the shape. Call this in response to *  the user choosing "Copy" or "Cut" from the Edit menu. See comment for DecompressShape *  to explain forPrintingOnly.*/void ShapeToScrap(gxShape source, Boolean addProxie,    Boolean forPrintingOnly, Boolean eraseBackground){    PicHandle   picture, proxie;    proxie = addProxie ? ShapeToPICT(source) : nil;    picture = DecompressShape(source, proxie, forPrintingOnly, eraseBackground);    if (proxie)        KillPicture(proxie);    if (picture)    {   HLock((Handle)picture);        ZeroScrap();        PutScrap(GetHandleSize((Handle)picture), 'PICT', (Ptr)*picture);        KillPicture(picture);    }}/* *  The ItemReference is the gxShape to be sent. The dragSendRefCon is ignored.*/static pascal OSErr LibrarySendDataProc(FlavorType theType, void *dragSendRefCon,                                ItemReference theItem, DragReference theDrag){    OSErr   result = noErr;    gxShape shape = (gxShape)theItem;    switch (theType) {    case 'qdgx':    {   Handle flat = ShapeToHandle(shape);        if (flat)        {   HLock(flat);            result = SetDragItemFlavorData(theDrag, theItem,                'qdgx', *flat, GetHandleSize(flat), 0);            DisposHandle(flat);        }        break;    }    case 'PICT':    {   PicHandle proxie = ShapeToPICT(shape);        PicHandle pict = DecompressShape(shape, proxie, false, true);        if (proxie)            KillPicture(proxie);        if (pict)        {   HLock((Handle)pict);            result = SetDragItemFlavorData(theDrag, theItem,                'PICT', (Ptr)*pict, GetHandleSize((Handle)pict), 0);            KillPicture(pict);        }        break;    }    default:        result = badDragFlavorErr;</pre>	</TD></TR></TABLE></CENTER></td></tr></table></center><!-- end_content --><!-- begin_date --><H4 ALIGN=center>[Sep 15 1995]</H4><!-- end_date --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/gx/gx07.html%3Fid%3DDTS10001212-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/gx/gx07.html%3Fid%3DDTS10001212-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/gx/gx07.html%3Fid%3DDTS10001212-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --> <hr width=500 align=center> </BODY> </HTML>