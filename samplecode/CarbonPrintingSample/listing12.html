<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Cocoa PDE with Carbon Printing - /UIHandling.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">Cocoa PDE with Carbon Printing</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Cocoa PDE with Carbon Printing</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/UIHandling.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AESupport.r</option>
<option value="listing2.html">/AppCustomPDE/AppCustomPDE.h</option>
<option value="listing3.html">/AppCustomPDE/AppCustomPDE.m</option>
<option value="listing4.html">/AppDrawing.c</option>
<option value="listing5.html">/AppDrawing.h</option>
<option value="listing6.html">/MyCarbonPrinting.c</option>
<option value="listing7.html">/MyCarbonPrinting.h</option>
<option value="listing8.html">/NavServicesHandling.c</option>
<option value="listing9.html">/NavServicesHandling.h</option>
<option value="listing10.html">/PDECommon.h</option>
<option value="listing11.html">/Readme.txt</option>
<option value="listing12.html">/UIHandling.c</option>
<option value="listing13.html">/UIHandling.h</option></select>
				</p>
				</form>
				<p><strong><a href="CarbonPrintingSample.zip">Download Sample</a></strong> (&#147;CarbonPrintingSample.zip&#148;, 83.9K)<BR>
<strong><a href="CarbonPrintingSample.dmg">Download Sample</a></strong> (&#147;CarbonPrintingSample.dmg&#148;, 126.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
File: UIHandling.c

Abstract: Basic RunApplicationEventLoop-based UI handling, Carbon API.

Version: 1.0

Disclaimer: IMPORTANT:  This Apple software is supplied to you by 
Apple Inc. (&quot;Apple&quot;) in consideration of your agreement to the
following terms, and your use, installation, modification or
redistribution of this Apple software constitutes acceptance of these
terms.  If you do not agree with these terms, please do not use,
install, modify or redistribute this Apple software.

In consideration of your agreement to abide by the following terms, and
subject to these terms, Apple grants you a personal, non-exclusive
license, under Apple's copyrights in this original Apple software (the
&quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
Software, with or without modifications, in source and/or binary forms;
provided that if you redistribute the Apple Software in its entirety and
without modifications, you must retain this notice and the following
text and disclaimers in all such redistributions of the Apple Software. 
Neither the name, trademarks, service marks or logos of Apple Inc. 
may be used to endorse or promote products derived from the Apple
Software without specific prior written permission from Apple.  Except
as expressly stated in this notice, no other rights or licenses, express
or implied, are granted by Apple herein, including but not limited to
any patent rights that may be infringed by your derivative works or by
other works in which the Apple Software may be incorporated.

The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.

IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

Copyright (C) 2007 Apple Inc. All Rights Reserved.

*/

#include &quot;MyCarbonPrinting.h&quot;
#include &quot;AppDrawing.h&quot;
#include &quot;NavServicesHandling.h&quot;
#include &quot;UIHandling.h&quot;

#define kMyApplicationSignature    'DGPT'
#define kMyPrintInfoProperty    'CGDT'

static OSStatus Initialize(void);
static OSErr QuitAppleEventHandler(const AppleEvent *appleEvt, AppleEvent* reply, long refcon);
static OSErr PrintDocumentAppleEventHandler( const AppleEvent *inputEvent, AppleEvent *outputEvent, SInt32 handlerRefCon);
static OSStatus InstallAppEvents(void);

static OSStatus MyDrawEventHandler(EventHandlerCallRef nextHandler, EventRef event, void *userData);
static OSStatus MyWindowEventHandler(EventHandlerCallRef nextHandler, EventRef event, void* userData);
static OSStatus DoAppCommandProcess(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);

static void setUseSheets(Boolean doSheets);
static void setShowStatusDialogOnSave(Boolean doStatus);
static IBNibRef getOurNibRef(void);

int main(int argc, char* argv[])
{
#pragma unused (argc, argv)
    OSStatus    err = noErr;
    IBNibRef    nibRef = getOurNibRef();
  require( nibRef, CantGetNib );

  // Once the nib reference is created, set the menu bar. &quot;MainMenu&quot; is the name of the menu bar
  // object. This name is set in InterfaceBuilder when the nib is created.
  err = SetMenuBarFromNib(nibRef, CFSTR(&quot;MenuBar&quot;));
  require_noerr( err, CantSetMenuBar );

  SetMenuCommandMark(NULL, kHICommandUseSheets, useSheets() ? checkMark : noMark);
  SetMenuCommandMark(NULL, kHICommandShowStatusDialogOnSave, showStatusDialogOnSave() ? checkMark : noMark);
  
  // Install our apple event handlers
  err = Initialize();
  require_noerr( err, CantInitialize );

  // open a document
  err = MakeNewDocument();
  require_noerr( err, CantOpenDocument );
  
  // Call the event loop
  RunApplicationEventLoop();

CantGetNib:
CantSetMenuBar:
CantInitialize:
CantOpenDocument:

  return err;
}

static IBNibRef getOurNibRef(void)
{
    /* the nibRef is a static local global and is only created the first
  time this routine is called but is needed repeatedly during the life
  of our application. getOurNibRef is an accessor for that data.
    */
    static IBNibRef nibRef = NULL;
    if(nibRef == NULL) {
        /* Create a Nib reference passing the name of the nib file (without the .nib extension)
            CreateNibReference only searches into the application bundle.
            
            We need this nib for the life of our application
        */
        OSStatus err = CreateNibReference(CFSTR(&quot;main&quot;), &amp;nibRef);
        if(err)
            nibRef = NULL;
    }
    return nibRef;
}

static OSStatus Initialize()
{
    OSErr err = noErr;
    
 // install AE handlers
    if(!err)
    err = AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, NewAEEventHandlerUPP(PrintDocumentAppleEventHandler), 0, false);
    if(!err)
    err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(QuitAppleEventHandler), 0, false);
    if (!err)
        err = InstallAppEvents();
                
    return err;
}

// Declare the signature and field ID for our HIView. These must
// match what you assigned to the HIView in Interface Builder.
#define kMyHIViewSignature  'vFpd'
#define kMyHIViewFieldID     135

WindowRef MakeWindow(const DrawDataRef ourData)
{
  OSStatus err = noErr;
  WindowRef  window = NULL;  // initialize to NULL
  HIViewRef  myView;
  static EventHandlerUPP windowEventHandler = NULL;
  static EventHandlerUPP viewEventHandler = NULL;
  
  if( !windowEventHandler)
    windowEventHandler = NewEventHandlerUPP(MyWindowEventHandler);
    
  if( !viewEventHandler )
    viewEventHandler = NewEventHandlerUPP(MyDrawEventHandler);

  static const HIViewID    myViewID = { kMyHIViewSignature, kMyHIViewFieldID };
  // Declare the event class and kind for the Carbon events of interest.
  static const EventTypeSpec  kMyViewEvents[] = {{ kEventClassControl, kEventControlDraw }};          
  static const EventTypeSpec  myWindowEvents[] = {{ kEventClassWindow, kEventWindowClose }};
  // window event handler
  // view event handler

  if(!err)
      err = CreateWindowFromNib(getOurNibRef(), CFSTR(&quot;Window&quot;), &amp;window);

  if(!err) {
      EventHandlerRef  ref;
      err = InstallWindowEventHandler(window, windowEventHandler, GetEventTypeCount(myWindowEvents), myWindowEvents, NULL, &amp;ref);
      if(!err) {
      // Get the HIView of the requested ID associated with the window.
      HIViewFindByID( HIViewGetRoot( window ), myViewID, &amp;myView );
    
      // Install the event handler for the HIView.                              
      err = HIViewInstallEventHandler(myView, viewEventHandler, GetEventTypeCount(kMyViewEvents), kMyViewEvents, ourData, NULL);
      }

      // attach our document data to the window
      if(!err)
      err = SetWindowProperty(window, kMyApplicationSignature, kMyPrintInfoProperty, sizeof(ourData), &amp;ourData);

      if(err) {
      DisposeWindow(window);
      window = NULL;
      }
  }
    return window;
}

static OSStatus InstallAppEvents(void)
{
  EventTypeSpec  eventType = { kEventClassCommand, kEventCommandProcess };
  OSStatus    err = noErr;
  // Command-process event handler
  EventHandlerUPP appCommandProcess = NewEventHandlerUPP(DoAppCommandProcess);    
  err = InstallApplicationEventHandler(appCommandProcess, 1, &amp;eventType, NULL, NULL);

  return err;
}

static OSStatus MyWindowEventHandler(EventHandlerCallRef nextHandler, 
                                                EventRef event, void* userData)
{
#pragma unused (nextHandler, userData)
    WindowRef  window;
    OSStatus  result = eventNotHandledErr;
    
    GetEventParameter(event, kEventParamDirectObject, typeWindowRef, NULL, sizeof(window), NULL, &amp;window);

    switch(GetEventKind(event))
  {
        case kEventWindowClose:
            (void)DisposeWindowPrivateData(GetMyWindowProperty(window));
            DisposeWindow(window);
            result = noErr;
            break;
      
    default:
      break;
    }
    return result;
}

// Handle command-process events at the application level
static OSStatus DoAppCommandProcess(EventHandlerCallRef nextHandler, 
                                            EventRef theEvent, void* userData)
{
#pragma unused (nextHandler, userData)
    HICommand    aCommand;
    OSStatus  result = eventNotHandledErr;
  WindowRef  w;
  void    *ourDataP;

    GetEventParameter(theEvent, kEventParamDirectObject, typeHICommand, NULL, 
            sizeof(HICommand), NULL, &amp;aCommand);
    
    switch (aCommand.commandID)
    {
    case kHICommandNew:
      (void)MakeNewDocument();
      result = noErr;
      break;

    case kHICommandSave:
      {
        w = ActiveNonFloatingWindow();
        ourDataP = GetMyWindowProperty(w);
        if(ourDataP) {
          // Save as PDF
          (void)DoSaveAsFile(w, ourDataP, false );
          result = noErr;
        }
      }
      break;

    case kHICommandSaveAsPostScript:
      {
        w = ActiveNonFloatingWindow();
        ourDataP = GetMyWindowProperty(w);
        if(ourDataP) {
          // Save as PDF
          (void)DoSaveAsFile(w, ourDataP, true );
          result = noErr;
        }
      }
      break;

    case kHICommandPageSetup:
    {
      w = ActiveNonFloatingWindow();
      ourDataP = GetMyWindowProperty(w);
      if(ourDataP) {
        (void)DoPageSetup(w, ourDataP);
        result = noErr;
      }
    }
      break;

    case kHICommandPrint:
    {
      w = ActiveNonFloatingWindow();
      ourDataP = GetMyWindowProperty(w);
      if(ourDataP) {
        (void)DoPrint(w, ourDataP, kDoPrintWithPrintDialog);
        result = noErr;
      }
    }
      break;

    case kMyMenuCommandPrintOne:
    {
      w = ActiveNonFloatingWindow();
      ourDataP = GetMyWindowProperty(w);
      if(ourDataP) {
        (void)DoPrint(w, ourDataP, kDoPrintOne);
        result = noErr;
      }
    }
      break;


    case kHICommandUseSheets:
    {
      Boolean doSheets = useSheets();
      doSheets = !doSheets;
      setUseSheets(doSheets);
      SetMenuCommandMark(NULL, kHICommandUseSheets, doSheets ? checkMark : noMark);
    }
      break;
      
    case kHICommandShowStatusDialogOnSave:
    {
      Boolean doStatus = showStatusDialogOnSave();
      doStatus = !doStatus;
      setShowStatusDialogOnSave(doStatus);
      SetMenuCommandMark(NULL, kHICommandShowStatusDialogOnSave, doStatus ? checkMark : noMark);
    }
      break;

    case kHICommandQuit:
      QuitApplicationEventLoop();
      result = noErr;
      break;
    
    default:
      break;
    }
    return result;
}

static OSStatus MyDrawEventHandler(EventHandlerCallRef nextHandler, EventRef event, void *userData)
{
#pragma unused (nextHandler)
  OSStatus status = noErr;
  CGContextRef myContext;
  
  if(userData) {
      HIRect  bounds;
      // Get the bounding rectangle
      HIViewRef theView;
    status = GetEventParameter( event, kEventParamDirectObject, typeControlRef, NULL, sizeof(theView), NULL, &amp;theView );
    require_noerr( status, CantGetView );

    HIViewGetBounds (theView, &amp;bounds);
      
      // Get the CGContextRef for the view.
      if(status == noErr)
      status = GetEventParameter(event, kEventParamCGContextRef, typeCGContextRef, NULL, sizeof (CGContextRef), NULL, &amp;myContext );    

      if(status != noErr) {
      fprintf(stderr, &quot;Got error %d getting the context!\n&quot;, (int)status);
      return status;
      }
      
      // HIView's have a 'flipped' coordinate system. We'll unflip to get correct
      // text.
      
      // Flip the coordinates by translating and scaling. This produces a
      // coordinate system that matches the Quartz default coordinate system
      // with the origin in the lower-left corner with the +y axis pointing up.
      CGContextTranslateCTM(myContext, 0, bounds.size.height);
      CGContextScaleCTM(myContext, 1.0, -1.0);

      // this code always draws page 1 on screen
      DrawPage(myContext, &amp;bounds, 1, false, (DrawDataRef)userData);
  }
  
CantGetView:
  return status;   
}

/*------------------------------------------------------------------------------

    Function:  PrintDocumentAppleEventHandler
    
    Parameters:
        inputEvent  -  Apple Event to process
        outputEvent  -  returned event
        handlerRefCon - ref con
    Description:
       Process the high level kAEPrintDocuments Apple Event. A Print Settings is
       extracted from the Apple Event and coerced to a PMPrintSettings and a PMPrinter. 
       The coerced PMPrintSettings is used to print each document in the document list.
       The PMPrinter, if any, represents the desired target printer. We set the sessions
       printer to be that printer.
       
       This sample is limited to processing only the first 1024 bytes of a text file.

------------------------------------------------------------------------------*/
static OSErr
PrintDocumentAppleEventHandler( const AppleEvent *inputEvent, AppleEvent *outputEvent, SInt32 handlerRefCon)
{
#pragma unused (outputEvent, handlerRefCon)

    OSStatus  err = noErr;
    AEDesc    printSettingsDesc = {};
    AEDesc    printerDesc = {};
    AEDesc    aePrintSettingsDesc = {};
    PMPrintSettings  coercePrintSettings = kPMNoPrintSettings;
    PMPrinter  coercePrinter = NULL;
    SInt16    fileRefNum = 0;
    Boolean    showPrintDialog = false;
    AEDesc    booleanDesc = {};

    // See if we need to show the print dialog.
    err = AEGetParamDesc(inputEvent, kPMShowPrintDialogAEType, typeBoolean, &amp;booleanDesc);
    if( !err )
        err = AEGetDescData( &amp;booleanDesc, &amp;showPrintDialog, sizeof( Boolean));

    // Get the AE print record.
    err = AEGetParamDesc(inputEvent, keyAEPropData, typeAERecord, &amp;aePrintSettingsDesc);

    // Coerce it to a PMPrintSettings.
    if(!err)
        err = AECoerceDesc(&amp;aePrintSettingsDesc, kPMPrintSettingsAEType, &amp;printSettingsDesc);

    // Retrieve the coerced PMPrintSettings from the AEDesc.
    if(!err) {
        err = AEGetDescData( &amp;printSettingsDesc, &amp;coercePrintSettings, sizeof( void*));
        // We can now get rid of the AEDesc.
        err = AEDisposeDesc(&amp;printSettingsDesc);
    }

    // Coerce it to a PMPrinter.
    if(!err) {
        err = AECoerceDesc(&amp;aePrintSettingsDesc, kPMPrinterAEType, &amp;printerDesc);

        // They may not have requested a target printer. But thats ok, so reset the error .
        if( !err ) {
            err = AEGetDescData( &amp;printerDesc, &amp;coercePrinter, sizeof( void*));
            // We can now get rid of the AEDesc.
            err = AEDisposeDesc(&amp;printerDesc);
        } else
            err = noErr;
    }

    if( !err ) {
        long    index, itemsInList = 0;
        AEDescList  docList;
        char    buffer[96];
        ByteCount  readCount, count=sizeof(buffer);
        PMPrintSession session = NULL;
        PMPageFormat pageFormat = kPMNoPageFormat;

        // Create the session we'll use to print.
        PMCreateSession( &amp;session );
        
        // Set the output to the target printer.
        if( coercePrinter )
            PMSessionSetCurrentPMPrinter( session, coercePrinter );

        // Create a default pageformat.
        PMCreatePageFormat(&amp;pageFormat);
        PMSessionDefaultPageFormat(session, pageFormat);
            
         // Get the file list.
        err = AEGetParamDesc( inputEvent, keyDirectObject, typeAEList, &amp;docList);
    if(!err)
      err = AECountItems( &amp;docList, &amp;itemsInList);      // how many files passed in
        
       // Walk the list of files.
        for (index = 1; !err &amp;&amp; index &lt;= itemsInList; index++)
        {
            FSRef      fileRef;
            AEKeyword    keywd;
            DescType    returnedType;
            Size      actualSize;
            CFStringRef    fileNameRef=NULL;
            Boolean      printIt = true;
            
            // Get the file ref.
            err = AEGetNthPtr( &amp;docList, index, typeFSRef, &amp;keywd, &amp;returnedType, &amp;fileRef, sizeof( fileRef ), &amp;actualSize );

            // Get the file name to use in the window's title.
      if( !err )
        err = LSCopyDisplayNameForRef( &amp;fileRef, &amp;fileNameRef );

            // Open the file for reading.
            if( !err )
            {
                err = FSOpenFork(&amp;fileRef, 0, NULL, fsRdPerm, &amp;fileRefNum);
                if( !err )
                {
          count = sizeof(buffer);
                    // read the data (1024 max)
          FSReadFork(fileRefNum, fsFromStart, 0, count, &amp;buffer[0], &amp;readCount);
                    // Close file.
                    FSCloseFork(fileRefNum);
                
                    // Show the print dialog?
                    printIt = true;
                    if( showPrintDialog )
                        PMSessionPrintDialog( session, coercePrintSettings, pageFormat, &amp;printIt );
        
                    // Print the file.
                    if( printIt )
                    {
                        CGContextRef printContext = NULL;
            PMSessionBeginCGDocument(session, coercePrintSettings, pageFormat);
            PMSessionBeginPage(session, pageFormat, NULL);
          
            PMSessionGetCGGraphicsContext(session, &amp;printContext);
            CGContextSelectFont(printContext, &quot;Helvetica&quot;, 20, kCGEncodingMacRoman);
            CGContextShowTextAtPoint(printContext, 72.0, 792 - 72, &amp;buffer[0], count);
      
            PMSessionEndPage(session);
                        PMSessionEndDocument(session);
                    }
                }
            }
        }
       
        // Clean up.
        if( pageFormat != kPMNoPageFormat )
            PMRelease( pageFormat );
        if( session != NULL )
            PMRelease( session );
    }

    // We're done so get rid of everything.
    if( coercePrintSettings != kPMNoPrintSettings )
        PMRelease( coercePrintSettings );
    if( coercePrinter != NULL )
        PMRelease( coercePrinter );
    return err;
}

static OSErr QuitAppleEventHandler(const AppleEvent *appleEvt, AppleEvent* reply, long refcon)
{
#pragma unused (appleEvt, reply, refcon)
  QuitApplicationEventLoop();
  return noErr;
}

void *GetMyWindowProperty(WindowRef window)
{
    void *ourDataP = NULL;
    if(window) {
        UInt32 infoSize = sizeof(void *);
    OSStatus err = GetWindowProperty(window, kMyApplicationSignature, kMyPrintInfoProperty, infoSize, NULL, &amp;ourDataP);
        if( err ) {
            ourDataP = NULL;
        }
    }
    return ourDataP;
}

void DoErrorAlert(OSStatus status, CFStringRef errorFormatString)
{  
    CFStringRef formatStr = NULL, printErrorMsg = NULL;
    SInt16      alertItemHit = 0;

  if ((status != noErr) &amp;&amp; (status != kPMCancel))           
  {
    formatStr =  CFCopyLocalizedString(errorFormatString, NULL);  
    if (formatStr != NULL)
    {
      printErrorMsg = CFStringCreateWithFormat(NULL, NULL, formatStr, status);
      if (printErrorMsg != NULL)
      {
        DialogRef alert;
        AlertStdCFStringAlertParamRec alertParams = { 0 };
        alertParams.version = kStdCFStringAlertVersionOne;
        alertParams.movable = true;
        alertParams.defaultText = (CFStringRef)kAlertDefaultOKText;
        alertParams.defaultButton = kAlertStdAlertOKButton;
        alertParams.position = kWindowDefaultPosition;
        OSStatus err = CreateStandardAlert(kAlertStopAlert, printErrorMsg, NULL, &amp;alertParams, &amp;alert);
        if( !err )
          RunStandardAlert( alert, NULL, &amp;alertItemHit );
        CFRelease (printErrorMsg);                     
      }
      CFRelease (formatStr);                             
    }
  }
}

static Boolean gDoSheets = false;

Boolean useSheets(void) {
    return gDoSheets;
}

static void setUseSheets(Boolean doSheets) {
    gDoSheets = doSheets;
}

static Boolean gDoStatusSaveDialog = false;

Boolean showStatusDialogOnSave(void) {
    return gDoStatusSaveDialog;
}

static void setShowStatusDialogOnSave(Boolean doStatus) {
    gDoStatusSaveDialog = doStatus;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CarbonPrintingSample/listing12.html%3Fid%3DDTS10004209-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CarbonPrintingSample/listing12.html%3Fid%3DDTS10004209-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CarbonPrintingSample/listing12.html%3Fid%3DDTS10004209-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>