<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Xsan Programming Guide: Xsan Tasks</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Xsan Tasks"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001165-CH205" title="Xsan Tasks"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../Storage/index.html#//apple_ref/doc/uid/TP30000440-TP40001898" target="_top">Storage</a> &gt; <a href="../../../../Storage/FileManagement-date.html#//apple_ref/doc/uid/TP30000440-TP40001898-TP30000448" target="_top">File Management</a> &gt; <a href="../introduction/intro.html#//apple_ref/doc/uid/TP40001165-CH203-TPXREF101">Xsan Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../concepts/concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001165-CH205-SW1" title="Xsan Tasks"></a><h1><a name="//apple_ref/doc/uid/TP40001165-CH205-TPXREF101" title="Xsan Tasks"></a>Xsan Tasks</h1>
<p>The Xsan API macros for use with the <code>fnctl</code>(2) system call to complete the following tasks:</p>
<ul class="ul"><li class="li"><p>get and set a file’s affinity</p></li>
<li class="li"><p>allocate space in a file and get information about a file’s allocated space</p></li>
<li class="li"><p>enable and disable real-time I/O for a storage pool and individual files</p></li>
<li class="li"><p>get and set quota limits for users and groups</p></li></ul>

<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP40001165-CH205-BBCDCHHI">Before You Start</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP40001165-CH205-BCIBBHDE">Working With Real-Time I/O</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001165-CH205-222966" title="Before You Start"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BBCDCHHI" title="Before You Start"></a><h2>Before You Start</h2>
<p>The next few paragraphs describe some things you should know about this API before attempting any of the tasks.</p>
<p>This API uses the <code>fcntl</code>(2) system call to send requests to the Xsan system. With a few exceptions, each <code>fcntl</code>(2) call takes as parameters a file descriptor, a macro name that identifies the type of request, and a union of a request and a reply structure. Some requests don’t require a request structure and some requests don’t require a reply structure.</p>
<p>Except where noted, zero is returned on success. Failure is indicated when an <code>fcntl
</code>(2) call returns –1 and <code>errno</code> is set to indicate the error.</p>
<p>All offsets and sizes are given in byte terms and are rounded up, if necessary, to the next Xsan file system block size.</p>
<p>For requests that return variable length buffers (such as extent lists), the request returns the total number of items available, as well as the number of items returned by this particular request. If more data is available than can be returned in the user’s buffer, as much as possible will be copied into the buffer, and no error will be returned. For subsequent requests, the user can specify a different starting location (ordinal for storage pools, starting offset for extents). If the list changes while the list is being retrieved, inconsistent results may be returned. When there are no more entries available, <code>ENOENT</code> is returned.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-223827" title="Working With Real-Time I/O"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIBBHDE" title="Working With Real-Time I/O"></a><h2>Working With Real-Time I/O</h2>
<p>Real-time I/O mode is a major feature of Xsan. When a storage pool is in real-time I/O mode, non-real-time I/O requests are gated so they do not hinder the speed of real-time I/O operations. The activity of processes doing real-time I/O is not monitored or scheduled in any special way to ensure that real-time I/O processes receive the bandwidth they requested. Real-time I/O processes are responsible for gating their own I/O requests to the desired rate, such as the frame rate for a specific video format.</p>
<p>The Xsan real-time I/O implementation is storage-pool-centric; all configuration and operations act on a specific storage pool. This allows storage pools with differing access characteristics to use different real-time settings. When a file system client successfully requests a certain amount of real-time I/O, the metadata controller sends a callback and a token to all connected clients to inform all connected file system clients of the amount of non-real-time I/O remaining and available for access. The token can also be thought of as a capability that allows the client to perform I/O without contacting the metadata controller.</p>
<p>In both the file system client and the metadata controller, real-time I/O is implemented as a state machine. Each state has a set of events and allowable actions. In this document, the term “state” refers to the internal state machine.</p>
<p>Applications that operate in real-time I/O mode do so by opening a file using the <code>open</code>(2) system call and obtaining a file descriptor.</p>
<p>Real-time I/O is configured in the metadata controller configuration file, and no configuration is required on file system clients. There is a real-time I/O tuning parameter that can be specified when a file system client mounts a file system.</p>
<p>For the purposes of determining bandwidth rates, well-formed real-time I/O is the stripe breadth multiplied by the number of LUNs in the storage pool in size. This size makes the best utilization of the disks in the storage pool and maximizes the transfer rate. Internally, non-real-time I/O is tracked by number of I/O operations per second. An I/O operation is a minimum of a file system block size, and a maximum of the file system block size multiplied by the stripe breadth, as shown in the following comparison:</p>
<div class="codesample"><table><tr><td scope="row"><pre>FsBlockSize &lt;= I/O &lt;=(FsBlockSize * StripeBreadth)<span></span></pre></td></tr></table></div>
<p>Typically, it is easier to qualify an I/O subsystem in terms of sustainable megabytes per second. However, internally, the file system tracks everything on an I/O per second basis. Note that the file system only tracks and gates non-real-time I/O. An I/O is a minimum of the file system block size and is typically the point at which the file system hands the request off to the disk driver.</p>
<p>The file system counts the number of non-real-time I/O operations that occurred during a given second. If the count exceeds the amount of I/O that has been allotted for non-real-time I/O operations, the I/O request is pended until non-real-time  I/O becomes available again (typically in the next second). Non-real-time I/O operations are honored in first in, first out (FIFO) fashion, and no priority is assigned to them.</p>
<p>To convert between I/O operations and megabytes per second, Xsan uses a formula that quantifies I/O as well-formed. The reason for this is due to the way in which many video applications make real-time I/O requests. To optimize the disk subsystem, real-time I/O operations are well-formed in order to saturate the disks. In Xsan terminology, this would be an I/O that covers all of the disks in a stripe. This can be expressed as follows:</p>
<div class="codesample"><table><tr><td scope="row"><pre>ios_sec = mb_sec / (StripeBreadth * StripeDepth * FsBlockSize);<span></span></pre></td></tr></table></div>
<p>For example, with a file system block size of 4KB, a stripe breadth of 384, and a stripe depth of 4, the equivalent number of I/O operations per second for each well-formed I/O would be 216 MB per second / (384 * 4 * 4KB). This is equivalent to 221184 KB per second / 6144KB = 36 I/O operations per second.</p>
<p>All storage subsystems are different, so the user must qualify the I/O subsystem and determine the maximum amount of I/O bandwidth that is available. Xsan relies on the correct setting in the configuration file. If the storage system changes, for example, because a new disk array is installed, the user must re-qualify the I/O subsystem to determine the amount of bandwidth that is now available. This amount is specified in the metadata controller configuration file. The user can also specify the minimum amount of bandwidth to be provided to non-real-time I/O processes.</p>
<p>To maximize performance, most real-time I/O requests are made a stripe line at a time. Non-real-time I/O operations are a minimum of a file system block in size.</p>
<p>The calculations of available real-time and non-real-time I/O are discussed in the section <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP40001165-CH205-224440">“Calculating Available Real-Time I/O Operations”</a></span> and <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP40001165-CH205-224742">“Non-Real-Time I/O Tokens,”</a></span> respectively.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-223938" title="Configuring Real-Time I/O"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIBEFGF" title="Configuring Real-Time I/O"></a><h3>Configuring Real-Time I/O</h3>
<p>Real-time I/O is configured in the configuration file on the metadata controller located at <code>/Library/Filesystems/Xsan/config</code>. No configuration is required on file system clients, but a <code>mount</code> option is available on file system clients for performance tuning.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-223955" title="Configuring the Metadata Controller"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIJBHIJ" title="Configuring the Metadata Controller"></a><h4>Configuring the Metadata Controller</h4>
<p>The five keywords listed in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP40001165-CH205-223971">Table 2-1</a></span> configure real-time I/O in the metadata controller configuration file.</p><a name="//apple_ref/doc/uid/TP40001165-CH205-223971" title="Table 2-1Real-time I/O configuration keywords"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJEDJEF" title="Table 2-1Real-time I/O configuration keywords"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Real-time I/O configuration keywords</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Keyword</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Default</p></th>
</tr>


<tr>
<td  scope="row"><p><code>Rtios</code></p></td>
<td ><p>Maximum number of real-time I/O operations of any size allowed on the storage pool during any one second period</p></td>
<td ><p>Zero (no real-time I/O)</p></td>
</tr>
<tr>
<td  scope="row"><p><code>Rtmb</code></p></td>
<td ><p>Maximum number of real-time megabytes per second allowed on the storage pool during any one second period.</p></td>
<td ><p>Zero (no real-time I/O)</p></td>
</tr>
<tr>
<td  scope="row"><p><code>RtiosReserve</code></p></td>
<td ><p>Amount to reserve in I/O operations per second from the maximum allowed for non-real-time  I/O operations. This value must be greater than the equivalent of one megabyte per second or the amount that can be transferred to a single stripe line, where a stripe line is the stripe breadth multiplied by the number of LUNs in the storage pool.</p></td>
<td ><p>Equivalent of one megabyte per second</p></td>
</tr>
<tr>
<td  scope="row"><p><code>RtmbReserve</code></p></td>
<td ><p>Amount to reserve in megabytes per second from the maximum allowed for non-real-time  I/O operations. This value must be greater than one.</p></td>
<td ><p>One megabyte per second</p></td>
</tr>
<tr>
<td  scope="row"><p><code>RtTokenTimeout</code></p></td>
<td ><p>Time, in seconds, to wait for file system clients to respond to a token callback.</p></td>
<td ><p>2 seconds</p></td>
</tr>

</table></div>
<p>All keywords in the metadata controller configuration file are case-insensitive.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224068" title="Rtios and Rtmb Keywords"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIHBECA" title="Rtios and Rtmb Keywords"></a><h5>Rtios and Rtmb Keywords</h5>
<p>One of <code>Rtios</code> or <code>Rtmb</code>, or both may be specified in the metadata controller configuration file. Both keywords refer to the total amount of sustained bandwidth available on the disk subsystem. Any I/O operations, whether real-time or non-real-time, are ultimately deducted from this overall limit. If both <code>Rtios</code> and <code>Rtmb</code> are specified, the lower limit is used to throttle non-real-time I/O. For example, setting <code>Rtios</code> to 2048 and <code>Rtmb</code> to 10 specifies that the storage system can support a maximum of 2048 I/O operations per second, aggregate among all file system clients at any instant, or 10 megabytes per second, whichever is lower. If <code>Rtios</code> and <code>rtmb</code> are not specified, real-time I/O is not available on the storage pool.</p>
<p>Specifying <code>Rtmb</code> in the metadata controller configuration file is only recommended if all of the I/O operations are well-formed in size (that is, the stripe breadth multiplied by the number of LUNs in the storage pool). If not, using the well-formed I/O calculation to convert between megabytes per second and I/O operations per second can lead to unexpected results.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224123" title="RtiosReserve and RtmbReserve Keywords"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIEHAAG" title="RtiosReserve and RtmbReserve Keywords"></a><h5>RtiosReserve and RtmbReserve Keywords</h5>
<p>The <code>RtiosReserve</code> and the <code>RtmbReserve</code> keywords allow the administrator to increase the amount of bandwidth reserved for non-real-time I/O. This bandwidth is shared by all non-real-time applications on each client.</p>
<p>The default is one megabyte and cannot be decreased. If it were possible to configure zero I/O operations per second for non-real-time I/O, a system could block with many critical file system resources held waiting for I/O to become available. </p>
<p>If values for both the <code>RtiosReserve</code> and the <code>RtmbReserve</code> keywords are specified, the lower of the two amounts is used.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224163" title="RtTokenTimeout Keyword"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJFFCJG" title="RtTokenTimeout Keyword"></a><h5>RtTokenTimeout Keyword</h5>
<p>The <code>RtTokenTimeout</code> keyword configures the amount of time that the metadata controller waits for file system clients to respond to callbacks. For example, if the metadata controller fails, file system clients attempt to re-establish their connections to the metadata controller when the metadata controller becomes available again. In most SANs, the default setting of two seconds is sufficient. To cause the metadata controller to wait longer for callback responses and avoid unnecessary timeouts, this value is typically increased for SANs that have a mixture of client machine types (Mac OS X, Linux, Windows NT, and Irix) whose differing TCP/IP characteristics cause re-connection times to vary or for SANs that have more than 32 clients.</p>
<p>If a file system client times out on a token retraction, the file system client that make the original request receives an error from the metadata controller that includes the IP address of the offending client. This information is logged to <code>syslog</code> and to the desktop on Windows clients, which can help in diagnosing reconnect failures and in determining if the setting for the <code>RtTokenTimeout</code> keyword should be increased.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224194" title="Sample Configuration"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIEFIBI" title="Sample Configuration"></a><h5>Sample Configuration</h5>
<p>For this sample configuration, consider a video playback application that requires a constant rate of 186 megabytes per second in order to display images correctly and without dropping any frames. The application gates itself; that is, it requests I/O at a rate to satisfy the requirements for correctly displaying an image.</p>
<p>In this example, assume the I/O subsystem has been qualified at 216 megabytes per second. The file system block size is 4KB. The disk subsystem is actually a large RAID array that internally maps many drives to a single LUN. There are four LUNs in the storage pool; each LUN is optimized for a 1.5 megabyte transfer. This corresponds to the following in the metadata controller configuration file: </p>
<div class="codesample"><table><tr><td scope="row"><pre>[StripeGroup MyStripeGroup]<span></span></pre></td></tr><tr><td scope="row"><pre>StripeBreadth 384<span></span></pre></td></tr><tr><td scope="row"><pre>Node CvfsDisk0 0<span></span></pre></td></tr><tr><td scope="row"><pre>Node CvfsDisk1 1<span></span></pre></td></tr><tr><td scope="row"><pre>Node CvfsDisk2 2<span></span></pre></td></tr><tr><td scope="row"><pre>Node CvfsDisk3 3<span></span></pre></td></tr><tr><td scope="row"><pre>Rtmb 216<span></span></pre></td></tr></table></div>
<p>This example assumes there is only one storage pool for user data in the file system. There may be other storage pools for metadata and journal that are not shown.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224262" title="Configuring the File System Client"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJDFEID" title="Configuring the File System Client"></a><h4>Configuring the File System Client</h4>
<p>The only available file system client configuration option controls the length of time for which a non-real-time I/O token is valid. When a file system client obtains a non-real-time I/O token from the metadata controller, the token gives that client access to a specific amount of non-real-time I/O. If the file system client is inactive for a period of time, the token is relinquished and the non-real-time I/O is released back to the metadata controller for distribution to other file system clients.</p>
<p>The length of time for which a non-real-time I/O token is valid is controlled by the <code>nrtiotokenhold</code> option to the <code>mount</code> command. The default is 60 seconds, which means that after 60 seconds in which no non-real-time I/O occurs on the storage pool, the non-real-time token times out and the non-real-time I/O is released back to the metadata controller.</p>
<p>The timeout period should be specified in five second increments. If not, the timeout period is automatically rounded up to the next five second interval. If the <code>syslog</code> level is set to debug, the file system client writes its <code>mount</code> parameters in the <code>syslog</code> file so that the timeout period can be noted.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224307" title="Enabling Real-Time I/O Mode"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCICAAAF" title="Enabling Real-Time I/O Mode"></a><h3>Enabling Real-Time I/O Mode</h3>
<p>Initially, all storage pools in the file system are in non-real-time I/O mode, and all processes make their requests directly to the I/O subsystem without being gated. </p>
<p>The <code>F_SETRTIO</code> request enables real-time I/O mode. Depending on the type of file descriptor that is passed to the <code>F_SETRTIO</code> request, the <code>FSETRTIO</code> request places an entire storage pool or an individual file within a storage pool in real-time I/O mode. </p>
<p>The <code>F_SETRTIO</code> request accepts two different types of file descriptor:</p>
<ul class="spaceabove"><li class="li"><p>A file descriptor for the root directory. When the file descriptor passed to an <code>F_SETRTIO</code> request is for the root directory and the <code>RT_SET</code> flag is set, the entire storage pool is put into real-time I/O mode, but no specific file descriptor is tagged as being ungated. The application is responsible for making a subsequent <code>F_ENABLERTIO</code> request on a specific file descriptor. The real-time I/O parameters that were specified when the <code>F_SETRTIO</code> request was made apply every file descriptor opened on a file on the storage pool for which an <code>F_ENABLERTIO</code> request is made.</p></li>
<li class="li"><p>A file descriptor for a regular file. When the file descriptor passed to an <code>F_SETRTIO</code> request is for a regular file and the <code>RT_SET</code> flag is set, the result is equivalent to making an <code>F_SETRTIO</code> request on the root directory followed by an<code> F_ENABLERTIO</code> request on a file descriptor for a regular file in that storage pool.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224396" title="Sharing Access to Files"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCICFBJJ" title="Sharing Access to Files"></a><h4>Sharing Access to Files</h4>
<p>Real-time I/O is enabled at the file descriptor level, not the file level, so different processes can share a file in real-time I/O and non-real-time I/O mode at the same time. As shown in <span class="content_text">Figure 2-1</span>, sharing allows a real-time process to perform ingest of material (such as video data) at the same time that non-real-time processes perform other operations on a file.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40001165-CH205-224413" title="Figure 2-1Real-time I/O and non-real-time I/O share access to a file"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJHEGGJ" title="Figure 2-1Real-time I/O and non-real-time I/O share access to a file"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Real-time I/O and non-real-time I/O share access to a file</p><img src = "../art/xsan_05.gif" alt = "" width="402" height="170"></div><br/>
<p>In <span class="content_text">Figure 2-1</span>, process A has ungated access to the file <code>foo</code>. Process B and process C are accessing the same file, but the file system client gates their I/O accesses.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-225231" title="Sharing Disk Resources"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIIIADB" title="Sharing Disk Resources"></a><h4>Sharing Disk Resources</h4>
<p>In this example, consider the case of a full-featured disk subsystem (Redundant Array of Very Expensive Disks, or RAVED) using a very high speed interconnect. Many clients can share these disk arrays, but it is sometimes desirable to limit a file system client’s access to the array. Real-time I/O provides a mechanism for “political bandwidth management” so that no one file system client can consume all bandwidth resources.In such a scenario, the storage pool is always in real-time I/O mode. Each file system client has a token specifying the number of permissible non-real-time I/O operations per second. Unfortunately it is not possible to assign a different non-real-time I/O limit to different clients. The foundation of such an approach is a simple program that puts the storage pool into real-time I/O mode as soon as the metadata controller is up and servicing requests. When the storage pool enters real-time I/O mode, the bandwidth as specified in the metadata controller’s configuration file is shared by all clients. In cases such as this, the real-time limit (<code>rtios</code> or <code>rtmb</code>) is calculated to be the total bandwidth desired to each file system client multiplied by the number of possible file system clients. As each file system client attempts to access the disk subsystem, it obtains a non-real-time I/O token. The metadata controller sends out callbacks adjusting down the amount of available bandwidth. No one file system client is allowed to exceed the threshold specified by the non-real-time I/O token, thereby assuring fairness to all file system clients.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224440" title="Calculating Available Real-Time I/O Operations"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJIJFDE" title="Calculating Available Real-Time I/O Operations"></a><h4>Calculating Available Real-Time I/O Operations</h4>
<p>When the metadata controller receives a request for real-time I/O, it considers the amount of real-time I/O that is being held in reserve. The metadata controller uses the reserve amount as a soft limit that it will not exceed. The calculation for available real-time I/O is as follows:</p>
<div class="codesample"><table><tr><td scope="row"><pre>avail_rtio = rtio_limit - rtio_current;<span></span></pre></td></tr><tr><td scope="row"><pre>avail_rtio -= rtio_reserve;<span></span></pre></td></tr></table></div>
<p>All internal calculations are made in terms of I/O operations per second.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224472" title="Ungated Non-Real-Time I/O"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIGIDGB" title="Ungated Non-Real-Time I/O"></a><h4>Ungated Non-Real-Time I/O</h4>
<p>Setting the <code>RT_NOGATE</code> flag when making an <code>F_SETRTIO</code> request causes I/O with the specified file descriptor request to be ungated without using any amount of real-time I/O or non-real-time I/O. This is useful for infrequently accessed files, such as index files, that should not be counted against available non-real-time I/O. System designers typically allow for some amount of overage in their I/O subsystem to account for ungated files.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224498" title="Getting the Requested Amount of Real-Time I/O"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIIBIFA" title="Getting the Requested Amount of Real-Time I/O"></a><h4>Getting the Requested Amount of Real-Time I/O</h4>
<p>Setting the <code>RT_MUST</code> flag when making an <code>F_SETRTIO</code> request causes the <code>F_SETRTIO</code> request to fail if the requested amount of real-time I/O cannot be provided. System designers that require a specific amount of real-time I/O should use the <code>RT_MUST</code> flag, and, if necessary, repeat the request until the requested amount of real-time I/O bandwidth becomes available.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224525" title="Disabling Real-Time I/O Mode"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIHDADH" title="Disabling Real-Time I/O Mode"></a><h3>Disabling Real-Time I/O Mode</h3>
<p>Once enabled for a storage pool, real-time I/O mode remains in effect until a process explicitly makes an <code>F_SETRTIO</code> request with the <code>RT_CLEAR</code> flag set on the file descriptor for the root directory. Real-time I/O mode is implicitly disabled if the file system is unmounted or the system is rebooted.</p>
<p>Once enabled for an individual file descriptor, real-time I/O mode remains in effect until the process passes the file descriptor to <code>RT_SETRTIO</code> with the <code>RT_CLEAR</code> flag set, passes the file descriptor to <code>F_DISABLERTIO</code>, or closes the file. In any case, all real-time I/O that was allocated to the file descriptor is released back to the system. However, if multiple file descriptors are open on the file, only the last close of the file triggers the releasing action. This is because the file system is not informed of the close until the last close of a file.</p>
<p>The file system client automatically issues a call to the metadata controller with the specifying the amount of real-time I/O that is being released. The release of real-time I/O for a file causes the metadata controller to issue callbacks to all file system clients to adjust the amount of bandwidth available to them.</p>
<p>If the metadata controller cannot be reached for some reason, the request is enqueued on a daemon and the process that is closing the file is allowed to continue. In the background, the daemon attempts to inform the metadata controller that the real-time I/O has been released.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224578" title="Callbacks"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIDIICB" title="Callbacks"></a><h3>Callbacks</h3>
<p>The metadata controller uses callbacks and tokens to communicate with file system clients. A <strong>callback</strong> is an unsolicited message from the metadata controller to a file system client requesting that the client adjust its non-real-time I/O parameters. The callback is accompanied by a <strong>token</strong> that specifies the amount of non-real-time I/O available on the storage pool.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224599" title="Transition from Non-Real-Time I/O to Real-Time I/O Mode"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJDJABJ" title="Transition from Non-Real-Time I/O to Real-Time I/O Mode"></a><h4>Transition from Non-Real-Time I/O to Real-Time I/O Mode</h4>
<p>Initially, all storage pools in a file system are in non-real-time I/O mode. When the metadata controller receives the initial request for real-time I/O on a storage pool, it first issues callbacks to all file system clients informing them that the storage pool is now in real-time I/O mode. The token that accompanies the message specifies that no non-real-time I/O is available. File system clients must now obtain a non-real-time I/O token before they can do any non-real-time I/O on the storage pool. </p>
<p>After sending out all callbacks, the metadata controller sets a timer based on the value of the <code>RtTokenTimeout</code> keyword. If each file system client responds to its callback within the value of <code>RtTokenTimeout</code>, the request for real-time I/O succeeds, and a reply indicating success is sent to the requesting client. <span class="content_text">Figure 2-2</span> summarizes this process.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40001165-CH205-224629" title="Figure 2-2Successful transition to real-time I/O mode"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJBBCBI" title="Figure 2-2Successful transition to real-time I/O mode"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>Successful transition to real-time I/O mode</p><img src = "../art/xsan_06.gif" alt = "" width="577" height="263"></div><br/>
<p>In step 1 of <span class="content_text">Figure 2-2</span>, a process on client A requests some amount of real-time I/O. This is the first request, so the metadata controller issues callbacks to all connected file system clients (steps 2 through 5) informing them that the storage pool is now in real-time I/O mode. The file system clients respond to the metadata controller in steps 6 through 9. When all of the file system clients have responded, the metadata controller sends a reply to the file system client that made the original request (step 10) indicating success.</p>
<p>The next section, <span class="content_text">“Token Retraction”</span> describes what happens when one or more of the file system clients do not respond to the callbacks sent in steps 2 through 5.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224661" title="Token Retraction"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJEBCFF" title="Token Retraction"></a><h4>Token Retraction</h4>
<p>If the <code>RtTokenTimeout</code> timer expires before one or more clients has not responded, the metadata controller must assume that a serious problem has occurred. The metadata controller enters the token retraction state and does not honor any real-time I/O or token requests until it receives positive acknowledgement from all file system clients to which it originally sent callbacks.</p>
<p>In token retraction state, the metadata controller sends a response to the requesting file system client with the IP address of the first client that did not respond to the callback. This response allows the requesting client to log the error and the IP address so that system administrators can start to diagnose the failure. The metadata controller then sends callbacks to all file system clients that it previously sent callbacks to, retracting them to their original state, and it sets the storage pool back to its original state — in this case, non-real-time I/O mode. </p>
<p>If a file system client does not respond within the value of the <code>RtTokenTimeout </code>keyword, the token retraction callbacks are retracted and sent out again. This process is repeated until all file system clients respond. During this time, real-time I/O requests are not honored and are enqueued. </p>
<p><span class="content_text">Figure 2-3</span> shows the flow of callbacks and responses in the token retraction state.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40001165-CH205-224701" title="Figure 2-3Token retraction state"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJEDFBB" title="Figure 2-3Token retraction state"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>Token retraction state</p>
<img src = "../art/xsan_07.gif" alt = "" width="577" height="263"></div><br/>
<p>In <span class="content_text">Figure 2-3</span>, client A requests some amount of real-time I/O, as it did in <span class="content_text">Figure 2-2</span>. However, in <span class="content_text">Figure 2-3</span>, client C did not respond to the initial callback in time (step 7). The metadata controller returns a failure code as its reply to client A’s initial real-time I/O request and sends callbacks to all file system clients indicating the storage pool is no longer in real-time I/O mode (steps 11-14). In the example, client C responds to the second callback (step 17), so the metadata controller stops sending out callbacks. The storage pool is returned to non-real-time I/O mode. </p>
<p>Note that token retraction sequence can have an unintended effect on soft-mounted file systems. If a request times out because other file system clients are not responding, failure is returned to the application, and then at some point the metadata controller is able to process the real-time I/O request successfully, the storage pool is put into real-time I/O mode after the original requester has received an error code. The metadata controller and file system clients log their actions extensively to <code>syslog</code>, so if this situation arises, it can be detected.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224742" title="Non-Real-Time I/O Tokens"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJGFFFI" title="Non-Real-Time I/O Tokens"></a><h3>Non-Real-Time I/O Tokens</h3>
<p>A token grants a client some amount of non-real-time I/O for storage pool and is encapsulated in a callback message from the metadata controller. Initially, no tokens are required to perform non-real-time I/O. Once a storage pool is put into real-time I/O mode, the metadata controller sends callbacks to all clients informing them that they now need a token to perform any non-real-time I/O, as described in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP40001165-CH205-224599">“Transition from Non-Real-Time I/O to Real-Time I/O Mode.”</a></span></p>
<p>The file system client requests a non-real-time I/O token from the metadata controller when the client receives its next non-real-time I/O request. Once a file system client has a token, it can perform as much I/O per second as is allowed by that token until the token expires, and it does not need to contact the metadata controller on every I/O request.</p>
<p>The metadata controller calculates the amount of available non-real-time I/O bandwidth using the following formula:</p>
<div class="codesample"><table><tr><td scope="row"><pre>avail_nrtio = rtio_limit - rtio_current;<span></span></pre></td></tr><tr><td scope="row"><pre>avail_nrtio /= current_num_nonrtio_clients + 1;<span></span></pre></td></tr></table></div>
<p>In the above calculation, the amount of the reserve parameter (<code>RtiosReserve</code> or <code>RtmbReserve</code>, whichever is lower) has already been subtracted from the amount of existing real-time I/O (<code>rtio_current</code>). As each file system client requests a non-real-time I/O token, the number of current non-real-time I/O file system clients (<code>current_num_nonrtio_clients</code>) increases and the amount of available non-real-time I/O decreases. </p>
<p>Each time the amount of available non-real-time I/O changes, the metadata controller sends a callback to each file system client that has an existing non-real-time I/O token, as shown in <span class="content_text">Figure 2-4</span>.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40001165-CH205-224817" title="Figure 2-4Non-real-time I/O token adjustments"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BAJFJBEC" title="Figure 2-4Non-real-time I/O token adjustments"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>Non-real-time I/O token adjustments</p>
<img src = "../art/xsan_08.gif" alt = "" width="524" height="263"></div><br/>
<p></p>
<p>In <span class="content_text">Figure 2-4</span>, assume the storage pool is already in real-time I/O mode as a result of a <code>F_SETRTIO</code> request from client A. Clients B and D are doing non-real-time I/O to the storage pool and each has a token specifying the amount of available non-real-time I/O. Then in step 1, client C requests a non-real-time I/O token. In steps 2 and 3, the metadata controller sends callbacks to clients B and D specifying the new token amount. The file system clients respond in steps 4 and 5, acknowledging the new token amount. In step 6, the metadata controller sends the new token to client C. Notice that in steps 2 and 3, the metadata controller only sends callbacks to file system clients that already have non-real-time I/O tokens.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224849" title="Failure Scenarios"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIHFBCD" title="Failure Scenarios"></a><h3>Failure Scenarios</h3>
<p>Two major failure scenarios can affect real-time I/O:</p>
<ul class="spaceabove"><li class="li"><p>metadata controller failures</p></li>
<li class="li"><p>file system client failures</p></li></ul>
<p>For metadata controller and file system client failures, Xsan attempts to return to the state it was in before the failure without manual intervention.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224886" title="Metadata Controller Failures"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIJFICE" title="Metadata Controller Failures"></a><h4>Metadata Controller Failures</h4>
<p>If the metadata controller crashes, become unavailable due to a network outage, or is stopped, there is no immediate affect on real-time (ungated) I/O. As long as there is no need to contact the metadata controller, for example to update an attribute or make an extent request, I/O proceeds as if the metadata controller were still available. If there is a need to make real-time I/O requests, the request hangs for 5 seconds. All other Xsan requests hang as controlled by the options that were specified to the <code>mount</code> command when the file system was mounted.</p>
<p>Non-real-time I/O is pended until the file system client reconnects to the metadata controller. The reason for making non-real-time I/O pended is that because the storage pool is in real-time I/O mode, there is no way to know when non-real-time I/O parameters change while the metadata controller is disconnected. When the file system client reconnects to the metadata controller, the file system client must re-request any real-time I/O that it requested previously. This is because the metadata controller does not log real-time I/O parameters across reboots. Therefore, it is up to file system clients to inform the metadata controller of the amount of required real-time I/O and to restore the metadata controller to its state as it was before the failure. In most cases, this strategy results in the amount of real-time and non-real-time  I/O being exactly the same as it was before the failure. The exception is when the aggregate of processes request more real-time I/O than is configured, a condition known as <strong>oversubscription</strong>. Oversubscription comes about when, before the crash, processes requested more real-time I/O than was actually available so the metadata controller adjusted the requested amounts down. When oversubscription occurs, it is not deterministically possible to re-create the amount of real-time I/O exactly as it was before the failure. Therefore, if the amount of real-time I/O is required to be the same across reboots of the metadata controller or metadata failover, all processes should use the <code>RT_MUST</code> flag to ensure they get the amount of real-time  I/O bandwidth that they need, both at the time and in case a recovery from a metadata controller crash is required.The process of each file system client re-requesting real-time I/O is exactly the same as the initial process of requesting real-time I/O. When each file system client re-establishes its real-time I/O parameters, non-real-time I/O processes are allowed to request non-real-time I/O tokens. Several seconds may elapse before the SAN settles back to its previous state. It may be necessary to adjust the value of the <code>RtTokenTimeout</code> parameter in the configuration file on the metadata controller to allow enough time for file system clients that are slow to reconnect to reconnect. </p>
<p>If a metadata failover is available, the clients reconnect to the metadata failover and reestablish their real-time I/O requirements as if the primary metadata controller had just come back online.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224908" title="File System Client Failures"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIHAGHB" title="File System Client Failures"></a><h4>File System Client Failures</h4>
<p>When a file system client disconnects from the metadata controller abruptly (a crash or a network outage) or in a controlled manner (an unmount), the metadata controller releases the file system client’s resources back to the SAN. If the file system client had real-time I/O in progress on the storage group, that amount of real-time I/O is released back to the system. The metadata controller sends callbacks to those file system clients that have non-real-time I/O tokens informing them of the new amount of available non-real-time I/O, or, if the storage pool is transitioning from real-time to non-real-time I/O mode, the metadata controller sends callbacks to all file system clients. </p>
<p>If the disconnected file system client had a non-real-time I/O token, the token is released and the metadata controller recalculates the amount of available non-real-time I/O. The metadata controller sends callbacks to all file system clients that have non-real-time I/O tokens informing them of the new amount of available non-real-time I/O.</p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224927" title="File System Client Token Releases"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIJBFBB" title="File System Client Token Releases"></a><h4>File System Client Token Releases</h4>
<p>Although it is not a failure case, the handling of a file system client token release is exactly the same as the handling of file system client failures. If no I/O occurs within the fixed amount of time that non-real-time I/O tokens are valid, the client releases the token back to the metadata controller. The metadata controller re-calculates the amount of available non-real-time bandwidth and sends callbacks to other file system clients to let them know of the new amount. </p>
<p>To reduce system and SAN overhead in a situation in which an I/O operation occurs, for example, every 70 seconds, the <code>nrtiotokenhold</code> option to the <code>mount</code> command should be set to a value greater than or equal to 70 seconds. For details, see <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP40001165-CH205-224262">“Configuring the File System Client.”</a></span></p>
<a name="//apple_ref/doc/uid/TP40001165-CH205-224959" title="Monitoring"></a><a name="//apple_ref/doc/uid/TP40001165-CH205-BCIGDEGA" title="Monitoring"></a><h3>Monitoring</h3>
<p></p>
<p>The current real-time I/O statistics are available through the <code>cvadmin</code> utility. The utility’s <code>show long</code> command provides information as to the current limit, the minimum amount reserved for non-real-time I/O, the number of active clients, the amount currently committed, and the amount of I/O a non-real-time application could expect to get when requesting I/O.Whenever the status of the storage pool changes (such as from non-real-time I/O to real-time I/O mode), an event is logged to <code>syslog</code>.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../concepts/concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-05-23<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Networking/Conceptual/Xsan/tasks/tasks.html%3Fid%3DTP40001165-1.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Networking/Conceptual/Xsan/tasks/tasks.html%3Fid%3DTP40001165-1.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Networking/Conceptual/Xsan/tasks/tasks.html%3Fid%3DTP40001165-1.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>