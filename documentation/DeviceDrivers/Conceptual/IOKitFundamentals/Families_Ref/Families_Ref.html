<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Fundamentals: I/O Kit Family Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="I/O Kit Family Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP0000021" title="I/O Kit Family Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP0000011-CH204-TPXREF101">I/O Kit Fundamentals</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Glossary/Glossary.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory/RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP0000021-BABCCBIJ" title="I/O Kit Family Reference"></a><h1>I/O Kit Family Reference</h1><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_447"></a><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_448"></a><p>This appendix describes each of the I/O Kit families in detail, paying particular attention to client/provider relationships. For most families, it provides a class hierarchy chart. It also tells you if a family exports a device interface, thereby allowing applications to access devices represented by the family. You should seriously consider taking the device-interface approach before attempting to write a kernel-resident driver. For information on using device interfaces, see the document <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>.</p><p>Some categories of devices are not currently supported by an I/O Kit family. If your device falls into an unsupported category, you might be able to write a “family-less” driver, use an SDK other than the I/O Kit, or create a new family. See <span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABHIGFE">“Devices Without I/O Kit Families”</a></span> for details.</p><p>You may find it helpful to examine the source code for an I/O Kit family or a specific device driver. To do this, visit <span class="content_text"><a href="http://www.opensource.apple.com/darwinsource/" target="_blank">Darwin Releases</a></span>, select the appropriate version of Mac OS X, and click Source to view the available source projects.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-TPXREF101">ADB</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABCJFID">ATA and ATAPI</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABJHDJH">Audio</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABIAGJE">FireWire</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABIGAIA">Graphics</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABFEIAC">HID</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABFBCFG">Network</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABIBHJB">PC Card</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABBIFFH">PCI and AGP</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-TPXREF106">SBP-2</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BEBBEBGD">SCSI Parallel</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABECGBG">SCSI Architecture Model</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABGJEIC">Serial</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABFHDGE">Storage</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABJBGJA">USB</a>
				
			<br/>
			
        
			
			
				<a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABHIGFE">Devices Without I/O Kit Families</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP0000021-TPXREF101" title="ADB"></a><h2>ADB</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_449"></a>ADB family provides support for, and access to, devices attached to the Apple Desktop Bus (ADB). It provides an abstraction for ADB bus controller drivers (<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_450"></a>IOADBController) and another for drivers of ADB devices (<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_451"></a>IOADBDevice). </p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOADBFamily</code></p></li></ul><p><strong>Headers at: </strong></p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/adb/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/adb</code></p></li></ul><p><strong>References and specifications</strong>: </p><ul class="ul"><li class="li"><p>Chapter 5 — “ADB Manager” of <em>Inside Macintosh: Devices</em> (<span class="content_text"><a href="../../../../../documentation/Hardware/DeviceManagers/adb/adb.html" target="_top">http://developer.apple.com/documentation/Hardware/DeviceManagers/adb/adb.html</a></span>)</p></li><li class="li"><p>Technical note HW01 (<span class="content_text"><a href="../../../../../technotes/hw/hw_01.html" target="_top">http://developer.apple.com/technotes/hw/hw_01.html</a></span>)</p></li><li class="li"><p><em>Guide to the Macintosh Family Hardware</em>, second edition, Apple Computer.</p></li></ul><p><strong>Class hierarchy:</strong> </p><br/><div><img src = "../art/adbfamily.gif" alt = "image: ../art/adbfamily.gif" width="291" height="51"></div><br/><p><strong>Device Interface</strong>:</p><ul class="ul"><li class="li"><p>Exports an interface for reading and writing registers on ADB devices. The interface is defined in <code>IOADBLib.h</code>. Only polled mode operations are supported through this library. Interrupt operations are only supported for kernel-resident clients.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF112" title="Table A-1Clients and providers of the ADB family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-1&nbsp;&nbsp;</strong>Clients and providers of the ADB family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p>Drives devices that plug into an ADB port.</p></td><td ><p>Drives an ADB bus controller</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p>A driver for an ADB mouse is a <em>client</em> of the ADB family but is a <em>member</em> of the HID family (in the IOHIPointing class).</p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p>An instance of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_452"></a>IOADBDevice matches your driver and loads it into the kernel. Your driver communicates with its family through an instance of IOADBDevice.</p></td><td ><p>ADB bus controller drivers should inherit from the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_453"></a>IOADBController class as defined in the header file <code>IOADBController.h</code></p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>Common client families include the HID family (<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_454"></a>IOHIPointing and, <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_455"></a>IOHIKeyboard classes) and the Graphics family (<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_456"></a>IODisplay class).</p></td><td ><p>All current ADB bus hardware produced by Apple is well supported by drivers that are included with Mac OS X. Third-party developers should not need to write drivers for the ADB family, except for ADB-USB adaptors.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-BABCJFID" title="ATA and ATAPI"></a><h2>ATA and ATAPI</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_457"></a>ATA and ATAPI family provides support for ATA controllers, and access to ATA and ATAPI devices on the ATA bus.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_16" title="Important:"></a><p><strong>Important:</strong>&nbsp;The ATA and ATAPI family is still under development. The information in this section is subject to change.</p><p></p></div><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOATAFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/ata</code></p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>American National Standards Institute (ANSI)—<span class="content_text"><a href="http://www.ansi.org" target="_blank">http://www.ansi.org</a></span></p></li><li class="li"><p>National Committee for Information Technology Standards (NCITS)—<span class="content_text"><a href="http://www.ncits.org" target="_blank">http://www.ncits.org</a></span></p></li><li class="li"><p>Technical Committee 13 (T13)—<span class="content_text"><a href="http://www.t13.org" target="_blank">http://www.t13.org</a></span></p></li></ul><p><strong>Class hierarchy</strong>: </p><br/><div><img src = "../art/atafamily.gif" alt = "image: ../art/atafamily.gif" width="375" height="136"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>Although this family does not itself export device interfaces, the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_458"></a><span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABECGBG">“SCSI Architecture Model”</a></span> family does provide device-interface support for ATAPI devices.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF113" title="Table A-2Clients and providers of the ATA and ATAPI family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-2&nbsp;&nbsp;</strong>Clients and providers of the ATA and ATAPI family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p>Drives a device that is connected to an ATA bus.</p></td><td ><p>Drives an ATA bus controller.</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p>An ATA hard drive or an ATAPI DVD-ROM drive. The Storage family is the most common family for clients.</p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p>Clients of this family match against an instance of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_459"></a>IOATADevice, one of which is created and published by the controller driver for every ATA or ATAPI device that is detected on the bus. They use the services provided by that object to communicate with the physical device on the bus.</p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>Clients of the ATA family must issue ATA/ATAPI commands encapsulated by an <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_460"></a>IOATACommand object. This command object encapsulates all the information necessary to encode a single ATA/ATAPI command as well as the results of the command’s execution.</p></td><td ><p>Third-party developers should never need to create a member of the ATA/ATAPI family.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-BABJHDJH" title="Audio"></a><h2>Audio</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_461"></a>Audio family provides support to enable access to devices that record or play back audio signals. It provides a flexible abstraction for audio devices that permits an unlimited number of channels as well as arbitrary sample rates, bit depths, and sample formats. The Audio family utilizes a high-resolution time base that is used as the basis for timing information for the entire audio and <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_462"></a>MIDI system in Mac OS X. (The Audio family itself does not provide any MIDI services; these are provided by the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_463"></a>Core MIDI framework.)</p><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_464"></a>Audio Hardware Abstraction Layer (<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_465"></a>Audio HAL) provides all audio services to applications in Mac OS X. The Audio HAL is accessed through the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_466"></a>Core Audio framework and has its programmatic interface defined in <code>AudioHardware.h</code> in that framework. The Audio family provides the link between an audio driver and the Audio HAL. Because the Audio HAL is a client of the Audio family, all audio device functionality is available to clients of the Audio HAL.</p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOAudioFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/audio/</code></p></li></ul><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>Although this family does not directly export device interfaces, the Audio family does provide a device interface that is used by the Audio Hardware Abstraction Layer (Audio HAL) to access all of the abstractions provided by the Audio family (see description above). </p></li></ul><p><strong>Power management</strong>:</p><ul class="ul"><li class="li"><p>The Audio family performs most power management tasks for subclassed device drivers. An audio driver does not have to call  <code><!--a-->PMinit<!--/a--></code>, <code><!--a-->joinPMtree<!--/a--></code>, <code><!--a-->registerPowerDriver<!--/a--></code>, or <code><!--a-->PMstop<!--/a--></code>, because the Audio family takes care of initializing power management, attaching the driver into the power plane and registering it with power management, and terminating power management.</p><p>Although an audio driver does not have to implement the <code>IOService</code> method <code><!--a-->setPowerState<!--/a--></code>, it does need to implement the <code>IOAudio</code> method <code><!--a target="_top" -->performPowerStateChange<!--/a--></code> to do the work of changing its device’s power state.</p></li><li class="li"><p>The Audio family implements idleness determination by keeping track of active audio engines, so a custom audio driver never needs to call <code><!--a-->activityTickle<!--/a--></code> or determine idleness on its own.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF114" title="Table A-3Clients and providers of the Audio family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-3&nbsp;&nbsp;</strong>Clients and providers of the Audio family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p>A kernel-resident client is not necessary. Use the Core Audio framework to access Audio HAL.</p></td><td ><p>Either records or plays back audio signals.</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p></p></td><td ><p>PCI audio cards, external USB or FireWire audio devices and any other device that produces or consumes audio.</p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p></p></td><td ><p>An audio driver must contain subclasses of both <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_467"></a>IOAudioDevice and <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_468"></a>IOAudioEngine.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p></p></td><td ><p>An audio driver is a client of other families that provide access to the hardware that the driver supports. For example, a driver for a PCI audio card will be a client of the PCI family.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-BABIAGJE" title="FireWire"></a><h2>FireWire</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_469"></a>FireWire family provides support for, and access to, devices attached to the FireWire bus (FireWire is an Apple trademark applied to the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_470"></a>IEEE 1394 standard, also sometimes known as <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_471"></a>i.LINK™).</p><p>The FireWire family has strong affinities with the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_472"></a>SBP2 family. A driver that uses the SBP-2 transport protocol is the most common client of the FireWire family. </p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOFireWireFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel-resident: <code>Kernel.framework/Headers/IOKit/firewire/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/firewire</code></p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>1394 Trade Association—<span class="content_text"><a href="http://www.1394ta.org" target="_blank">http://www.1394ta.org</a></span></p></li><li class="li"><p>IEEE—<span class="content_text"><a href="http://www.ieee.org/portal/site" target="_blank">http://www.ieee.org/portal/site</a></span>. Copies of the IEEE 1394 specification can be purchased here.</p></li><li class="li"><p>Apple Developer Connection—<span class="content_text"><a href="http://developer.apple.com/hardwaredrivers/firewire/index.html" target="_top">http://developer.apple.com/hardwaredrivers/firewire/index.html</a></span></p></li></ul><p><strong>Class hierarchy</strong></p><br/><div><img src = "../art/firewirefamily.gif" alt = "image: ../art/firewirefamily.gif" width="507" height="410"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>Provides a device interface exporting an interface for sending and receiving packets on the FireWire bus and for adding entries into the computer’s own <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_473"></a>FireWire config ROM.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF115" title="Table A-4Clients and providers of the FireWire family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-4&nbsp;&nbsp;</strong>Clients and providers of the FireWire family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p><em>Unit drivers:</em> Drives communication with a unit of a device that plugs into the FireWire bus.   <em>Protocol drivers:</em> Adds support for a protocol enabling peer-to-peer communication or emulation over FireWire.</p></td><td ><p>Drives a FireWire bus controller. </p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p><em>Unit drivers:</em> A driver for a FireWire speakers.  <em>Protocol drivers:</em> A driver that provides TCP/IP over FireWire.</p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p><em>Unit drivers:</em> An instance of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_474"></a>IOFireWireUnit, representing a unit found in a device’s configuration ROM, is matched against the driver and it is loaded into the kernel. The driver communicates with the FireWire family through this instance.  <em>Protocol drivers:</em> An instance of IOFireWireController matches a protocol driver and loads it into the kernel. The driver communicates with the FireWire family through this instance. </p></td><td ><p>Driver classes should inherit from the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_475"></a>IOFireWireController class as defined in the header file <code>IOFireWireController.h</code>.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>The most common client family is the SBP2 family.</p></td><td ><p>Mac OS X ships drivers for all <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_476"></a>Open Host Controller Interface (OHCI) bus controllers. Third-party developers generally should not need to write bus-controller drivers for the FireWire family.</p></td></tr></table></div><p>In some cases, you can write a driver for a FireWire device instead of for a unit. An example might be a driver for a device with a minimal config ROM (that is, with just a vendor ID). However, use of the minimal config ROM is strongly discouraged by Apple. Also, if your driver matches against a FireWire unit, it is often possible to do some things with the device.</p><a name="//apple_ref/doc/uid/TP0000021-BABIGAIA" title="Graphics"></a><h2>Graphics</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_477"></a>Graphics family provides support for <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_478"></a>frame buffers and <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_479"></a>display devices (monitors).</p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOGraphicsFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/graphics/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/graphics</code></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/graphicsfamily.gif" alt = "image: ../art/graphicsfamily.gif" width="289" height="131"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>The Graphics family exports several device interfaces since most access of graphics devices is from user space. However, the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_480"></a>Quartz layer arbitrates access to frame buffers from user space through the windowing system or the CGDirectDisplay API. Other layers, such as <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_481"></a>Carbon Draw Sprockets, provide application access to graphics.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_482"></a>Graphics acceleration is supplied by modules loaded into user address space. A <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_483"></a>CFPlugIn interface, defined in <code>IOGraphicsInterface.h</code>, implements two-dimensional acceleration. Similarly, <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_484"></a>OpenGL defines a loadable-bundle interface for three-dimensional rendering. Because there is no standard way to implement this functionality, hardware-specific code can exist in both user-space code and in a kernel-loaded driver.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF116" title="Table A-5Clients and providers of the Graphics family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-5&nbsp;&nbsp;</strong>Clients and providers of the Graphics family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p></p></td><td ><p>Implements support for a frame buffer.</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p></p></td><td ><p>Frame-buffer drivers must be subclasses of the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_485"></a>IOFramebuffer class. The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_486"></a>IONDRVFramebuffer class supports native Power PC Mac OS graphics drivers (known as “<code>ndrv</code>"s); this support is automatic, provided the drivers are written correctly to the specification.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>Support for kernel-resident clients is limited. Because the Quartz layer owns the display, the kernel generally does not render graphics directly.</p></td><td ><p>Apple provides generic support for displays and so displays should not generally require third-party drivers.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-TPXREF110" title="A Note on NDRV Compatibility"></a><h3>A Note on NDRV Compatibility</h3><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_487"></a>NDRV graphics drivers should function in OS X if they are correctly written. If they are not correctly written, the many differences in Mac OS X’s runtime environment could cause them to fail, be ignored, or even cause a crash. If you are writing an NDRV driver, follow these rules:</p><ul class="spaceabove"><li class="li"><p>Access the card hardware using virtual addressing. Do not assume the card is mapped into its physically assigned address. In Mac OS 9, NDRV cards are mapped one-to-one, but in Mac OS X, this is not guaranteed. Obtain the virtual addresses for your card's hardware via the <code>AAPL,address</code> property as documented in “Designed Cards and Drivers for PCI Power Macintosh.”</p></li><li class="li"><p>Link only on the native driver libraries, which are NameRegistryLib, DriverServicesLib, and VideoServicesLib. If your card links on InterfaceLib or any other application-level library, it probably won’t work on Mac OS X.</p></li><li class="li"><p>Do not access low memory; doing so causes a crash (kernel panic) in Mac OS X.</p></li><li class="li"><p>Name registry calls are not supported from interrupt level in Mac OS 9 or Mac OS X. They return errors in Mac OS X.</p></li><li class="li"><p>Secondary interrupts are not supported in Mac OS X. There is no need to fake vertical blank interrupts if your card does not support them—simply do not create a VBL service. Mac OS 9 continues to require a VBL service to be installed to move the cursor on your device.</p></li><li class="li"><p>Stack size is limited to 16K on Mac OS X; any NDRV invocation should consume no more than 4K of stack.</p></li></ul><p>If you want to make runtime conditional changes to your NDRV code, the property <code>AAPL,iokit-ndrv</code> is set in the PCI device properties before OS X uses your driver.</p><p>Mac OS X supports 32 bits-per-pixel, alpha-blended cursors in hardware. If your device supports an alpha-blended direct color cursor, it should call <code><!--a-->VSLPrepareCursorForHardwareCursor<!--/a--></code> with these fields set in the <code>HardwareCursorDescriptor</code> record:</p><div class="codesample"><table><tr><td scope="row"><pre>bitDepth = 32 maskBitDepth = 0 numColors = 0colorEncodings = NULL<span></span></pre></td></tr></table></div><p>The <code>hardwareCursorData</code> buffer in the <code>HardwareCursorInfo</code> should point to a buffer of 32 bits per pixel, ARGB data. The data is not premultiplied by the alpha channel.</p><a name="//apple_ref/doc/uid/TP0000021-BABFEIAC" title="HID"></a><h2>HID</h2><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_488"></a><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_489"></a>Human Interface Device (HID) class is one of several device classes described by the USB (Universal Serial Bus) architecture. The HID class consists primarily of devices humans use to control a computer system’s operations. Examples of such HID class devices include: </p><ul class="ul"><li class="li"><p>Keyboards and pointing devices such as mice, trackballs, and joysticks</p></li><li class="li"><p>Front-panel controls such as knobs, switches, sliders, and buttons</p></li><li class="li"><p>Controls that might be found on games or simulation devices such as data gloves, throttles, and steering wheels</p></li></ul><p>Currently, Mac OS X provides the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_490"></a>HID Manager to allow applications to access joysticks, audio devices, and non-Apple displays. You can also use the HID Manager to get information from another type of HID class device, a <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_491"></a>UPS (uninterruptible power supply) device. UPS devices share the same report descriptor structure as other HID class devices and provide information such as voltage, current, and frequency. The Mac OS X HID Manager consists of three layers:</p><ul class="ul"><li class="li"><p>The HID Manager client API that provides definitions and functions your application can use to work with HID class devices</p></li><li class="li"><p>the HID family that provides the in-kernel HID infrastructure such as the base classes, the kernel-user space memory mapping and queueing code, and the HID parser</p></li><li class="li"><p>the HID drivers provided by Apple</p></li></ul><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOHIDFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/hid/</code> and <code>Kernel.framework/Headers/IOKit/hidsystem/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/hid/</code> and <code>IOKit.framework/Headers/hidsystem/</code></p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>HID Information section of USB.org—Developers website (<span class="content_text"><a href="http://www.usb.org/developers/hidpage" target="_blank">http://www.usb.org/developers/hidpage</a></span>)</p></li><li class="li"><p><em><a href="../../HID/index.html#//apple_ref/doc/uid/TP40000970" target="_top">HID Class Device Interface Guide</a></em></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/hidfamily.gif" alt = "image: ../art/hidfamily.gif" width="360" height="99"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>The HID family exports a device interface through the HID Manager client API. The HID Manager includes <code>IOHIDLib.h</code> and <code>IOHIDKeys.h</code> (located in <code>/System/Library/Frameworks/IOKit.framework/Headers/hid</code> ) which define the property keys that describe a device, the element keys that describe a device’s elements, and the device interface functions and data structures you use to communicate with a device. After you’ve created a device interface for a selected HID class device, you can use the device interface functions to open and close the device, get the most recent value of an element, or set an element value.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF117" title="Table A-6Clients and providers of the HID family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-6&nbsp;&nbsp;</strong>Clients and providers of the HID family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p></p></td><td ><p>Drives an input device such as a multi-button mouse, trackball, or joystick.</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p></p></td><td ><p>Support for most simple input devices is provided by the generic driver.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-BABFBCFG" title="Network"></a><h2>Network</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_492"></a>Network family provides support for network controllers. The Network family consists of two logical layers:</p><ul class="ul"><li class="li"><p>Controller layer—this layer represents the network controller.</p></li><li class="li"><p>Interface layer—this layer represents the network interface published by the network controller.</p></li></ul><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IONetworkingFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/network/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/network/</code></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/networkfamily.gif" alt = "image: ../art/networkfamily.gif" width="445" height="244"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>The device interface for this family is usually the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_493"></a>BSD network stack. Applications use the socket interface provided by the network stack to access indirectly the services provided by the Network family.</p></li></ul><p><strong>Power management</strong>: </p><p>The Network family performs most of the power-management set-up and tear-down tasks for subclassed device drivers. If you’re developing a driver for a network device that can be passively power managed (which describes most network devices), you can meet most of your basic power-management needs by overriding the <code>IONetworkController</code> method <code><!--a target="_top" -->registerWithPolicyMaker<!--/a--></code> and calling the <code>IOService</code> method <code><!--a-->registerPowerDriver<!--/a--></code>.</p><p>In your implementation of <code><!--a-->registerWithPolicyMaker<!--/a--></code>, create an array of <code>IOPMPowerState</code> structures to define your device’s power states and pass them in to <code><!--a-->registerPowerDriver<!--/a--></code>. Then, return <code>kIOReturnSuccess</code> from <code><!--a-->registerWithPolicyMaker<!--/a--></code> to tell the Network family that your driver can respond to power-management calls. (The default implementation of <code><!--a-->registerPowerDriver<!--/a--></code> returns <code>kIOReturnUnsupported</code>.) The following code snippet shows one way to do this:</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn MyEthernetDriver::registerWithPolicyMaker( IOService * policyMaker )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn ioreturn;<span></span></pre></td></tr><tr><td scope="row"><pre>static IOPMPowerState powerStateArray[ kPowerStateCount ] = {<span></span></pre></td></tr><tr><td scope="row"><pre>   { 1,0,0,0,0,0,0,0,0,0,0,0 },<span></span></pre></td></tr><tr><td scope="row"><pre>   { 1,kIOPMDeviceUsable,kIOPMPowerOn,kIOPMPowerOn,0,0,0,0,0,0,0,0 }<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>fCurrentPowerState = kPowerStateOn;<span></span></pre></td></tr><tr><td scope="row"><pre>ioreturn = policyMaker->registerPowerDriver( this, powerStateArray, kPowerStateCount );<span></span></pre></td></tr><tr><td scope="row"><pre>return ioreturn;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Most network device drivers handle power changes related to sleep and wake in their implementations of the <code>IONetworkController</code> methods <code><!--a-->enable<!--/a--></code> and <code><!--a-->disable<!--/a--></code>. Note that the Network family enables a device when it transitions to a power state for which the <code>kIOPMDeviceUsable</code> flag is set. When a currently enabled device moves to a power state for which the <code>kIOPMDeviceUsable</code> flag is not set, the Network family disables it.</p><p>If you need to perform additional tasks to handle sleep and wake, you can override the <code>IOService</code> method <code><!--a-->setPowerState<!--/a--></code>. Be aware, however, that the Network family will call <code><!--a-->disable<!--/a--></code> <em>before</em> you receive a call to your <code><!--a-->setPowerState<!--/a--></code> implementation if the new power state puts the device into an unusable state. Conversely, the Network family calls <code><!--a-->enable<!--/a--></code> <em>after</em> you receive a <code><!--a-->setPowerState<!--/a--></code> call to move the device to a usable state.</p><p>If your network device driver performs DMA, you should override the <code>IOService</code> method <code><!--a-->systemWillShutdown<!--/a--></code>, which was introduced in Mac OS X v10.5. This is especially important for drivers that run in Intel-based Macintosh computers. In your implementation of <code><!--a-->systemWillShutdown<!--/a--></code>, you should make sure that the DMA engine is shut off, which results in the necessary disabling of the port.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_17" title="Important:"></a><p><strong>Important:</strong>&nbsp;As described in <span class="content_text"><a href="../PowerMgmt/PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW8">“Receiving Shutdown and Restart Notifications”</a></span> the <code><!--a-->systemWillShutdown<!--/a--></code> call is made to drivers in the power plane, in leaf-to-root order. If your driver returns <code>kIOReturnUnsupported</code> from <code><!--a-->registerWithPolicyMaker<!--/a--></code>, it will not be attached to the power plane and will not receive a <code><!--a-->systemWillShutdown<!--/a--></code> call.</p><p></p></div><a name="//apple_ref/doc/uid/TP0000021-TPXREF118" title="Table A-7Clients and providers of the Network family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-7&nbsp;&nbsp;</strong>Clients and providers of the Network family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p></p></td><td ><p>Drives a network controller.</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p></p></td><td ><p>Controllers on Ethernet, Token Ring, and FDDI adapters.</p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p></p></td><td ><p>Driver must be an instance of a subclass of a controller class that implements generic network controller functionality, such as IONetworkController or of a controller class that builds upon <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_494"></a>IONetworkController to specialize for Ethernet controller support (IOEthernetController). See discussion on Network family classes below for more information.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>Drivers are typically not clients of the Network family. The primary system client of this family is the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_495"></a>DLIL (Data Link Interface Layer) module in the BSD network stack. </p></td><td ><p></p></td></tr></table></div><p>Member drivers must also create IONetworkInterface objects that are registered with the DLIL; such registration associates the driver with a network interface (for example, <code>en0</code>) in the system. You can create a <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_496"></a>Network Kernel Extension (NKE) and insert it at various locations above the IOKit/DLIL boundary to intercept the packets, commands, or other event traffic between an IONetworkInterface object and the upper layers.</p><p>Another client of this family is the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_497"></a>KDP (Kernel Debugger Protocol) module in the kernel. A driver can create an IOKernelDebugger object that vends debugging services and allows kernel debugging through the network hardware managed by the driver. Only drivers that drive a built-in network controller are required to provide this support.</p><p>Other classes of the Network family include:</p><ul class="simple"><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_498"></a>IOOutputQueue—assists in queuing outbound packets.</p></li><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_499"></a>IOPacketQueue—represents a generic <code>mbuf</code> packet FIFO queue.</p></li><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_500"></a>IOMbufMemoryCursor—translates  <code>mbuf</code> packets into a scatter-gather list of physical addresses and length pairs.</p></li><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_501"></a>IONetworkData—represents a container for a single group of statistics counters.</p></li><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_502"></a>IONetworkMedium—represents a single network medium supported by the network device.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-BABIBHJB" title="PC Card"></a><h2>PC Card</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_503"></a>PC Card family supports 32-bit PC cards (<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_504"></a>CardBus), <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_505"></a>16-bit PC cards (I/O and memory), and <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_506"></a>Zoom Video cards. This support encompasses controllers that are compatible with ExCA (Intel 82365) and Yenta register sets. Apple’s PC Card family’s Card Services are, for the most part, compliant with the 1997 PC Card™ standard. </p><p>CardBus cards are essentially PCI devices in a different form factor. If you are writing a driver for a CardBus card, you can choose to subclass from either <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_507"></a>IOPCIDevice or <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_508"></a>IOCardBusDevice. See the reference section <code><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABBIFFH">“PCI and AGP”</a></code> for more information about the PCI family.</p><p>Other classes provided by the family include:</p><ul class="simple"><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_509"></a>IOPCCard16Device—represents a 16-bit PC card device.</p></li><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_510"></a>IOPCCard16Enabler—allows you to override the card configuration process for 16-bit cards. It is used mainly for cards with broken or missing CIS entries.</p></li><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_511"></a>IOZoomVideoDevice—represents a Zoom Video device.</p></li><li><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_512"></a>IOPCCardBridge—represents a PC Card bridge; this class is a subclass of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_513"></a>IOPCI2PCIBridge which is a subclass of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_514"></a>IOPCIBridge. </p></li></ul><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOPCCardFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/pccard/</code></p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>Documentation for Card Services can be found in the <code>doc</code> directory of the PC Card family source (available via Darwin CVS). You can also find in the same location a sample 16-bit driver.</p></li><li class="li"><p>Apple Developer Connection—<span class="content_text"><a href="http://developer.apple.com/hardwaredrivers/pci/" target="_top">http://developer.apple.com/hardwaredrivers/pci/</a></span></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/pccardfamily.gif" alt = "image: ../art/pccardfamily.gif" width="368" height="123"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>None.</p></li></ul><p><strong>Power management</strong>: </p><ul class="ul"><li class="li"><p>Classes <code>IOPCCardBridge</code>, <code>IOPCCard16Device</code>, <code>IOPCCard16Enabler</code>, and <code>IOCardBusDevice</code> provide some power-management support.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-BABBIFFH" title="PCI and AGP"></a><h2>PCI and AGP</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_515"></a>PCI and AGP family provides support for, and access to, devices attached to PCI and AGP buses and PCI bridges. </p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOPCIFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p><code>Kernel.framework/Headers/IOKit/pci/</code></p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>This family supports all major features of the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_516"></a>PCI Localbus 2.1 specification.</p></li><li class="li"><p>PCI Special Interest Group—<span class="content_text"><a href="http://www.pcisig.com" target="_blank">http://www.pcisig.com</a></span></p></li><li class="li"><p>Apple Developer Connection—<span class="content_text"><a href="http://developer.apple.com/hardwaredrivers/pci/" target="_top">http://developer.apple.com/hardwaredrivers/pci/</a></span></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/pcifamily.gif" alt = "image: ../art/pcifamily.gif" width="293" height="52"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>None. Applications are not permitted direct access to PCI bus hardware for security reasons. Instead, applications should interact with higher-level services, such as those provided by device interfaces of the USB or other families.</p></li></ul><p><strong>Matching properties</strong>: </p><ul class="ul"><li class="li"><p>The PCI/AGP family permits matching based on <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_517"></a>Open Firmware or on PCI registers. See the description of the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_518"></a>IOPCIDevice class in the reference documentation for details.</p></li></ul><p>Check the Darwin Open Source project for example PCI drivers.</p><a name="//apple_ref/doc/uid/TP0000021-TPXREF119" title="Table A-8Clients and providers of the PCI and AGP family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-8&nbsp;&nbsp;</strong>Clients and providers of the PCI and AGP family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p>Drives a device that plugs into a PCI bus.</p></td><td ><p>Drives a PCI bus controller or a PCI bridge.</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p>A driver for a PCI SCSI controller card is a <em>client</em> of the PCI family but is a <em>member</em> of the SCSI Parallel family.</p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p>The driver communicates with its family via an instance of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_519"></a>IOPCIDevice or <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_520"></a>IOAGPDevice. An instance of one of these classes matches your driver and loads it into the kernel.</p></td><td ><p>PCI family member drivers should inherit from the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_521"></a>IOPCIBridge class.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>The most common client families are the USB, Network, SCSI, Graphics, and Audio families. </p></td><td ><p>Mac OS X supports most PCI bus hardware with a set of generic drivers. In general, third-party developers do not need to write drivers for the PCI and <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_522"></a>AGP family unless they are building a PCI expansion chassis or developing drivers for a PCI bridge with special characteristics not addressed by the generic drivers.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-TPXREF106" title="SBP-2"></a><h2>SBP-2</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_523"></a>SBP2 family (Serial Bus Protocol 2) provides support for, and access to, devices attached to the FireWire bus that use the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_524"></a>SBP-2 transport protocol. The SBP2 family is a client of the FireWire family. SBP-2 devices require FireWire to run.</p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOFireWireSBP2</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/sbp2/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/sbp2</code></p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>T10 Technical Committee —<span class="content_text"><a href="http://www.t10.org" target="_blank">http://www.t10.org</a></span></p></li><li class="li"><p>SBP-2 standard: <span class="content_text"><a href="ftp://ftp.t10.org/t10/drafts/sbp2/" target="_blank">ftp://ftp.t10.org/t10/drafts/sbp2/</a></span></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/sbp2family.gif" alt = "image: ../art/sbp2family.gif" width="411" height="164"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>The SBP2 family provides a device interface that exports an interface for sending SBP-2 ORBs to a device. </p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF120" title="Table A-9Clients and providers of the SBP2 family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-9&nbsp;&nbsp;</strong>Clients and providers of the SBP2 family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p>Drives a device that uses the SBP-2 transport protocol.</p></td><td ><p>Provides SBP-2 transport services</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p>A driver for a typical FireWire hard disk drive is a <em>client</em> of the SBP2 family but is a <em>member</em> of the mass storage family.</p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p>A client driver communicates with the SBP2 family through an instance of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_525"></a>IOFireWireSBP2LUN. An instance of this class is created for each LUN (Logical Unit Number) found in a configuration ROM unit directory; this instance matches your driver and loads it into the kernel.</p></td><td ><p>SBP2 family-member drivers should inherit from the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_526"></a>IOFireWireSBP2Target class.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>The most common client family is the Storage family.</p></td><td ><p></p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-BEBBEBGD" title="SCSI Parallel"></a><h2>SCSI Parallel</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_527"></a>SCSI Parallel family provides support for, and access to, devices attached to a parallel SCSI bus. This family supports all major features of the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_528"></a>SCSI Parallel Interface-5 (SPI-5<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_529"></a>) specification for parallel buses.</p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOSCSIParallelFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/scsi/spi</code>. The header file <code>IOSCSIParallelInterfaceController.h</code> supports the development of a driver for a SCSI card.</p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>T10 Technical Committee —<span class="content_text"><a href="http://www.t10.org" target="_blank">http://www.t10.org</a></span></p></li><li class="li"><p>SCSI Technical Library of Information—<span class="content_text"><a href="http://www.scsilibrary.com/" target="_blank">http://www.scsilibrary.com/</a></span></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/scsifamily.gif" alt = "image: ../art/scsifamily.gif" width="510" height="78"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>Device interface support for parallel SCSI devices is provided by the SCSI Architecture Model family. See <span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABECGBG">“SCSI Architecture Model”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF121" title="Table A-10Clients and providers of the SCSI Parallel family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-10&nbsp;&nbsp;</strong>Clients and providers of the SCSI Parallel family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p>Drives a device that plugs into a SCSI bus.</p></td><td ><p>Drives a SCSI host adapter or controller chip.</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p>A driver for a SCSI disk drive is a <em>client</em> of the SCSI Parallel family but a <em>member</em> of the Storage family.</p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p>A client driver communicates with the SCSI Parallel family through an instance of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_530"></a>IOSCSIDevice. Your driver would match on this instance and be loaded into the kernel. Another class of interest is <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_531"></a>IOSCSICommand.</p></td><td ><p>Because the SCSI Parallel family presently supports parallel buses, member drivers use the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_532"></a>IOSCSIParallelInterfaceController class.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>Common client families include the Transport Drivers for storage devices.</p></td><td ><p>Mac OS X includes generic drivers for most built-in SCSI hardware. In general, third-party developers do not need to write drivers that are members of the SCSI Parallel family unless they are developing drivers for an expansion card.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-BABECGBG" title="SCSI Architecture Model"></a><h2>SCSI Architecture Model</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_533"></a>SCSI Architecture Model family provides common client support for SCSI, USB (Storage), FireWire SBP-2 and ATAPI devices. Many of the classes of this family belong to the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_534"></a>Transport Driver layer, which is summarized in <span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BAJCJJFJ">Table A-11</a></span></p><a name="//apple_ref/doc/uid/TP0000021-BAJCJJFJ" title="Table A-11SCSI Architecture Model family&acirc;&#128;&#148;Transport Driver layer"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-11&nbsp;&nbsp;</strong>SCSI Architecture Model family—Transport Driver layer</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Classes</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Comments</p></th></tr><tr><td  scope="row"><p>Device Services Linkage</p></td><td ><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_535"></a>IOBlockStorageServices <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_536"></a>IOReducedBlockServices <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_537"></a>IOCompactDiscServices <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_538"></a>IODVDServices</p></td><td ><p>Linkage objects that understand the APIs from the Device Services layer (Storage family) and export APIs that the Logical Unit drivers (in the Transport Driver layer) understand.</p></td></tr><tr><td  scope="row"><p>Logical Unit drivers</p></td><td ><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_539"></a>IOSCSIPeripheralDeviceType00 IOSCSIPeripheralDeviceType05 IOSCSIPeripheralDeviceType07 IOSCSIPeripheralDeviceType0E</p></td><td ><p>Drive mass storage devices that have file systems or are bootable.</p></td></tr><tr><td  scope="row"><p>Peripheral Device Type Nub</p></td><td ><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_540"></a>IOSCSIPerpheralDeviceNub</p></td><td ><p>Not really an I/O Kit nub, but an object that queries the device and determines which Logical Unit driver is needed.</p></td></tr><tr><td  scope="row"><p>SCSI Protocol drivers</p></td><td ><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_541"></a>IOUSBMassStorageClass <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_542"></a>IOATAPIProtocolTransport <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_543"></a>IOFireWireSerialBusProtocol- Transport <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_544"></a>IOSCSIParallelInterface- ProtocolTransport</p></td><td ><p>Classes for bus-specific drivers. Although these classes belong to other families, they are part of the SCSI Architecture Model layering.</p></td></tr></table></div><p>The Logical Unit drivers and the Peripheral Device Type Nub are in the SCSI Application layer, which inherits (ultimately) from <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_545"></a>IOSCSIPrimaryCommandsDevice. The SCSI Protocol drivers are in the SCSI Protocol layer, which inherits from <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_546"></a>IOSCSIProtocolServices.</p><p>The SCSI Architecture Model family supports multimedia command set devices, such as CD-RW drives.</p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOSCSIArchitectureModelFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel-resident: <code>Kernel.framework/Headers/IOKit/scsi-commands/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/scsi-commands</code></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/scsiarchmodelfamily.gif" alt = "image: ../art/scsiarchmodelfamily.gif" width="458" height="477"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>The library for the SCSI Architecture Model family is called <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_547"></a>SCSITaskLib. It includes three interfaces: <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_548"></a>MMCDeviceInterface, <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_549"></a>SCSITaskDeviceInterface, and <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_550"></a>SCSITaskInterface. The user-client class is <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_551"></a>SCSITaskUserClient. If you need to access a SCSI Parallel device <em>and</em> your application must run in versions of Mac OS X prior to v10.2, see <span class="content_text"><a href="../../WorkingWithSAM/WWS_ParaSCSI/WWS_ParallelSCSI.html#//apple_ref/doc/uid/TP30000386" target="_top">Accessing SCSI Parallel Devices</a></span> for information on how to do this. Otherwise, you should use the device interfaces in the SCSITaskLib to access your device (see <span class="content_text"><a href="../../WorkingWithSAM/WWS_SAMDevInt/WWS_SAM_DevInt.html#//apple_ref/doc/uid/TP30000387" target="_top">Accessing SCSI Architecture Model Devices</a></span> for information on how to do this).</p></li></ul><p><strong>Power management</strong>:</p><p>The SCSI Architecture Model family performs most of the power-management set-up and tear-down tasks for both protocol services drivers and logical unit drivers. In general, a protocol services driver, such as IOATAPIProtocolTransport, must be able to transition the physical interconnect device between the off and on states. On the other hand a logical unit driver, such as IOSCSIPeripheralDeviceType05, must be able to manage a multimedia device that supports all the power states defined by the SCSI multimedia commands specification. In addition, a logical unit driver might need to determine if a power-state change is needed, block incoming I/O when the device is not in an appropriate power state, and specify the power state a device should enter at boot time.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_18" title="Note"></a><p><strong>Note:</strong>&nbsp;The SCSI Architecture Model family defines the system sleep power state, which is in addition to the power states defined by the command-set specifications. System sleep corresponds to the sleep that occurs when the user chooses Sleep in the Apple menu or closes the lid of a laptop. The sleep state defined in the command-set specifications corresponds to the sleep that occurs when the device is idle. Because power can be removed from devices in system sleep, the SCSI Architecture Model family handles it differently than sleep. </p></div><p>As shown in the class hierarchy diagram above, the SCSI Architecture Model family defines a common superclass for both types of drivers: <code>IOSCSIProtocolInterface</code>. The <code>IOSCSIProtocolInterface</code> class defines a number of power-management methods that subclass drivers can call or, less frequently, override.</p><ul class="ul"><li class="li"><p>If you’re developing a custom protocol services driver, you do not need to perform the steps outlined in <span class="content_text"><a href="../PowerMgmt/PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span> Instead, you must call the <code>IOSCSIProtocolInterface</code> method <code><!--a-->InitializePowerManagement<!--/a--></code> in your driver’s <code><!--a-->start<!--/a--></code> routine. Then, if there is device-specific work to do to handle power-state changes, you can implement the methods <code><!--a-->HandlePowerOn<!--/a--></code> and <code><!--a-->HandlePowerOff<!--/a--></code>.</p></li><li class="li"><p>Similarly, if you’re developing a custom logical unit driver, you do not need to perform the steps outlined in <span class="content_text"><a href="../PowerMgmt/PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span> If your device complies with the appropriate command-set specification, you do not need to override any methods in your driver unless you want to implement custom power-management functionality. For example, you might want your device to transition from the active state directly to the sleep state, instead of through the intermediate states between active and sleep.</p><p>In the <code>IOSCSIProtocolInterface</code> class, the SCSI Architecture Model family provides the following methods a logical unit driver subclass can implement:</p><ul class="nested"><li class="nested li"><p><code>InitializePowerManagement</code>. The superclass implementation of this method performs power-management setup tasks. A subclass driver can override this method to provide information about the power states the device supports.</p></li><li class="nested li"><p><code>TicklePowerManager</code>. The superclass implementation of <code><!--a-->TicklePowerManager<!--/a--></code> calls the <code><!--a target="_top" -->activityTickle<!--/a--></code> method, which results in a request to change your device to its active power state. A subclass driver can override this method to specify a state different from the active one.</p></li><li class="nested li"><p><code>GetInitialPowerState</code>. This method is used to specify the default state (usually active) a device should be in when the system boots. If a device should enter a different state when the system boots, the subclass driver can override this method and specify that state.</p></li><li class="nested li"><p><code>GetNumberOfPowerStateTransitions</code>. A subclass driver can override this method to report the number of transitions between the lowest and highest specification-defined power states the device supports. Note that system sleep is not counted in the transitions because it is not a power state the device enters voluntarily.</p></li><li class="nested li"><p><code>HandlePowerChange</code>. A subclass driver overrides this method to perform the work of changing the device’s power state.</p></li></ul></li></ul><a name="//apple_ref/doc/uid/TP0000021-BABGJEIC" title="Serial"></a><h2>Serial</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_552"></a>Serial family provides support for serial byte character streams. </p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOSerialFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/serial/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/serial/</code></p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>See <code><a href="../../../../Darwin/Reference/ManPages/man4/termios.4.html#//apple_ref/doc/man/4/termios" target="_top">termios(4)</a></code>. <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_553"></a>Also see the related header file <code>Kernel.framework/Headers/sys/termios.h</code></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/serialfamily.gif" alt = "image: ../art/serialfamily.gif" width="343" height="88"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>Applications can access the Serial family through the BSD device nodes, the most common client of this family. An application can read and write data using the BSD device nodes in <code>/dev</code>. Data is also routed through to <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_554"></a>PPP via these device nodes. You can find keys and other properties for use in device access in <code>IOKit.framework/Headers/serial/IOSerialKeys.h</code>.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-TPXREF122" title="Table A-12Clients and providers of the Serial family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-12&nbsp;&nbsp;</strong>Clients and providers of the Serial family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p><em>Requires</em> a single-banded data streaming service with elementary flow control.</p></td><td ><p><em>Provides</em> a single-banded streaming service; in other words, it cannot be packet-based. although it may be bi-directional. The driver may also implement flow control. The driver must describe the services it is capable of providing.</p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p></p></td><td ><p>Serial port writers should subclass <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_555"></a>IOSerialDriverSync for their drivers, then publish as nubs objects of the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_556"></a>IOModemSerialStreamSync or <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_557"></a>IORS232SerialStreamSync classes, or (if neither of these suffices) a concrete subclass of <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_558"></a>IOSerialStreamSync. The I/O Kit uses these objects to create the appropriate user-client interface for user-space access via BSD.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>Developers should use the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_559"></a>BSD device file mechanism documented in <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>.</p></td><td ><p></p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000021-BABFHDGE" title="Storage"></a><h2>Storage</h2><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_560"></a><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_561"></a>Storage family provides high-level support for random-access mass storage devices. It is separate from the underlying technology that transports the data to and from the represented storage space. The interface to the underlying transport technology is declared in the abstract class <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_562"></a>IOBlockStorageDevice. Storage driver objects communicate all mass-storage requests across this interface, without having to have knowledge of, or involvement with, the commands and mechanisms used to communicate with the device or bus. </p><p>The scope of the Storage Family encompasses the IOBlockStorageDevice interface, at one end (provider direction), and the BSD interface at the other end (client direction), with various driver and media layers in the between. <span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BAJDABEF">Figure A-1</a></span> illustrates this stack.</p><br/><div><a name="//apple_ref/doc/uid/TP0000021-BAJDABEF" title="Figure A-1Storage family driver stack"></a><p><strong>Figure A-1&nbsp;&nbsp;</strong>Storage family driver stack</p><img src = "../art/storgaestack.gif" alt = "Storage family driver stack" width="258" height="334"></div><br/><p>Each layer consists of a set of two objects—a driver object and the child media object (or objects) it publishes. The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_563"></a>IOStorage class is the common base class for both driver and media objects. It is an abstract class that declares the basic open, close, read, and write interfaces that subclasses are to implement. It establishes the protocol with which media objects can talk to driver objects without needing to be subclassed for each driver. The read and write interfaces provide byte-level access to the storage space.</p><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_564"></a>IOBlockStorageDriver class is the common base class for generic block storage drivers. It matches and communicates via an <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_565"></a>IOBlockStorageDevice interface, and connects to the remainder of the storage framework via the IOStorage protocol. It extends the IOStorage protocol by implementing the appropriate open and close semantics, deblocking for unaligned transfers, polling for ejectable media, implementing locking and ejection policies, creating and tearing down media object, and gathering and reporting statistics. The Storage family supports other basic types of drives, such as CD drives and DVD drives, through subclasses of the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_566"></a>IOBlockStorageDriver. You rarely, if ever, need to subclass the generic block storage driver to handle device idiosyncrasies; rather, you should change the underlying transport drivers to correct any non-conforming behavior.</p><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_567"></a>IOMedia class is an abstraction of a random-access disk device. It is equivalent to the “device object” or “interface object” in other I/O Kit families. </p><ul class="ul"><li class="li"><p>It represents the presence of a device, or a piece thereof.</p></li><li class="li"><p>It presents an programmatic interface to that device.</p></li><li class="li"><p>It is backed by a separate driver that implements the required functionality.</p></li></ul><p>IOMedia provides a consistent interface for both real and virtual disk devices, for subdivisions of disks such as partitions, for supersets of disks such as RAID volumes, and so on. It extends the IOStorage class by implementing the appropriate open, close, read, write, and matching semantics for media objects. Its properties reflect the properties of real disk devices, including natural block size and writability.</p><p>The other driver and media layers in the Storage Family are known as <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_568"></a>filter schemes. These optional layers separate media objects, providing some kind of data manipulation or offset manipulation between media objects. These layers may stack arbitrarily on top one another, as they are both a client and a provider of media objects. Most third-parties will develop drivers for the filter scheme layer, if not for the underlying transport technology. Refer to <span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BAJCHHDD">“IOMedia Filter Schemes”</a></span> for more information on developing filter scheme drivers. </p><p>For more information on developing drivers for the underlying transport technology, refer to SCSI Architecture Model Family documentation. The SCSI Architecture Model Family is the common underlying transport technology for ATAPI, FireWire, SCSI, and USB. It provides a consistent CDB-based access model for application writers and driver writers, and a simple infrastructure for correcting device idiosyncrasies.</p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOStorageFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/storage/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/storage</code></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/storagefamily.gif" alt = "image: ../art/storagefamily.gif" width="431" height="260"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>See <span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BAJEDHHH">“Accessing IOMedia From Applications”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP0000021-BAJCHHDD" title="IOMedia Filter Schemes"></a><h3>IOMedia Filter Schemes</h3><p>A <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_569"></a>filter scheme is a driver for <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_570"></a>IOMedia objects. It acts as both as a client and a provider of media objects. The filter-scheme driver receives mass storage requests through its abstract <code>read</code> and <code>write</code> member-function interfaces, in which it can perform the data manipulation or offset manipulation before passing the request on to its provider IOMedia object (or objects). There are several different kinds of media filter schemes:</p><ul class="spaceabove"><li class="li"><p>One-to-one—A block-level compression or encryption scheme, for example, would match against one IOMedia object and produce one child IOMedia object representing the uncompressed or unencrypted content.</p></li><li class="li"><p>One-to-many—A partition scheme, for example, would match against one IOMedia object and produce multiple child IOMedia objects representing the content of each distinct partition (see <span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BAJBFABI">“Partition Schemes”</a></span> for more information).</p></li><li class="li"><p>Many-to-one—A RAID scheme, for example, would match against multiple IOMedia objects and produce one child IOMedia object representing the RAIDed content.</p></li><li class="li"><p>Many-to-many—A many-to-many scheme would match against multiple IOMedia objects and produce multiple child IOMedia objects.</p></li></ul><p>A filter-scheme driver inherits from the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_571"></a>IOStorage class and necessarily participates in the IOStorage match category (IOMatchCategory’s value in personality).</p><a name="//apple_ref/doc/uid/TP0000021-BAJBFABI" title="Partition Schemes"></a><h4>Partition Schemes</h4><p>Mac OS X includes two standard <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_572"></a>partition schemes:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_573"></a>IOApplePartitionScheme, the standard Apple partition scheme driver</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_574"></a>IOFDiskPartitionScheme, the standard PC partition scheme driver</p></li></ul><p>A partition-scheme driver inherits from the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_575"></a>IOPartitionScheme class (which inherits from IOStorage), matches against a single IOMedia parent, and produces one or more IOMedia child objects for each partition it must represent. It participates in the IOStorage match category, as with all filter scheme drivers.</p><p>A partition scheme need not be subclassed in order to make use of developer-defined content within a partition. A partition’s contents is represented by a distinct IOMedia object, published as a child of the partition-scheme driver. Each child media object has properties that further identify information known about the partition, such the content hint, size, and natural block size. The content hint field is a string formed similarly to the well-known "Apple_Driver" and "Apple_HFS" strings, or by definition, in the form "MyCompany_MyContent". It permits partitions with developer-defined contents to be identified uniquely (when the partition is created), and permits filter-scheme drivers to match against such content automatically without ever probing a disk.</p><a name="//apple_ref/doc/uid/TP0000021-TPXREF109" title="IOMedia Properties"></a><h3>IOMedia Properties</h3><p><span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BAJCCHJE">Table A-13</a></span> lists the standard set of properties for all <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_576"></a>IOMedia objects. These properties can be used as matching properties in I/O Kit’s search and notification APIs, as well as for filter scheme driver matching purposes.</p><a name="//apple_ref/doc/uid/TP0000021-BAJCCHJE" title="Table A-13Storage family (IOMedia) properties "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-13&nbsp;&nbsp;</strong>Storage family (IOMedia) properties </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Key</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code><!--a  -->kIOMediaEjectableKey<!--/a--></code></p></td><td ><p>Boolean</p></td><td ><p>Is the media ejectable?</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOMediaLeafKey<!--/a--></code></p></td><td ><p>Boolean</p></td><td ><p>Is the media a leaf in the media tree? This is false whenever a client filter-scheme driver has matched against the media object.</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOMediaPreferredBlockSizeKey<!--/a--></code></p></td><td ><p>Number</p></td><td ><p>The media’s natural block size in bytes.</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOMediaSizeKey<!--/a--></code></p></td><td ><p>Number</p></td><td ><p>The media’s entire size in bytes.</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOMediaWholeKey<!--/a--></code></p></td><td ><p>Boolean</p></td><td ><p>Is the media at the root of the media tree? This is true for the physical media representation, a RAID media representation, and similar representations.</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOMediaWritableKey<!--/a--></code></p></td><td ><p>Boolean</p></td><td ><p>Is the media writable?</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOMediaContentKey<!--/a--></code></p></td><td ><p>String</p></td><td ><p>The media’s content description, as forced upon by the client filter-scheme driver. (This content description is copied automatically from the client filter-scheme driver’s <code><!--a  -->kIOMediaContentMaskKey<!--/a--></code> property.) The string’s format follows the "MyCompany_MyContent" convention, and defaults to the Content Hint string should no client filter scheme have matched against the object. Used for informational purposes in user disk utilities.</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOMediaContentHintKey<!--/a--></code></p></td><td ><p>String</p></td><td ><p>The media’s content description, as hinted at the time of the object’s creation. The string’s format follows the “MyCompany_MyContent” convention. Used for matching purposes in filter scheme drivers.</p></td></tr><tr><td  scope="row"><p><code><!--a  -->kIOBSDNameKey<!--/a--></code></p></td><td ><p>String</p></td><td ><p>The media’s BSD device node name. The name is dynamically assigned at the time of the object’s creation. Used for read and write access to the media’s contents (see <span class="content_text"><a href="Families_Ref.html#//apple_ref/doc/uid/TP0000021-BAJEDHHH">“Accessing IOMedia From Applications”</a></span>).</p></td></tr></table></div><p>A media object also has a unique I/O Kit path, which can be obtained via standard I/O Kit APIs. </p><a name="//apple_ref/doc/uid/TP0000021-BAJEDHHH" title="Accessing IOMedia From Applications"></a><h3>Accessing IOMedia From Applications</h3><p>The standard user-space mechanism for accessing data on a piece of media is the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_577"></a>BSD device interface. The BSD device interface is abstracted at the file-system layer through distinct read and write APIs, while general user application access is provided via the <code><!--a-->read<!--/a--></code> and <code><!--a-->write<!--/a--></code> system calls (see the corresponding man pages for more documentation). The properties and structure of a physical disk are represented in the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_578"></a>I/O Kit Registry object hierarchy and in each media object’s properties, including the BSD device interface name assigned to the media object.</p><p>A specific media object can be found via the standard I/O Kit search and notification APIs. The dictionary used to describe the IOMedia might refer to specific property values, to a specific service path or device tree path, or to a specific subclass of media. A CD, for example, appears as an <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_579"></a>IOCDMedia subclass, with properties appropriate to a CD, such as <code><!--a  -->kIOCDMediaTOCKey<!--/a--></code>. Such properties can be combined to describe a media object uniquely in the system, or generalized to identify a certain kind of media with multiple possible matches (returned in an iterator).</p><p>The Carbon APIs and Cocoa APIs provide mechanisms for sending notifications of file system mount and unmount events, as well as for file access within the file system. An application can obtain the associated BSD device interface name for a given file system through <code><!--a-->GetVolParms<!--/a--></code> (<code><!--a  -->vMDeviceID<!--/a--></code>) in Carbon and through <code><!--a-->getmntinfo<!--/a--></code> in BSD. The associated IOMedia object can be obtained for a given BSD device interface name through I/O Kit APIs using the <code><!--a  -->kIOBSDNameKey<!--/a--></code> property.</p><a name="//apple_ref/doc/uid/TP0000021-BABJBGJA" title="USB"></a><h2>USB</h2><p>The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_580"></a>USB family provides support for, and access to, devices attached to a Universal Serial Bus (USB). </p><p>Two basic types of drivers are clients of this family: kernel-mode drivers and user-mode drivers. Kernel-mode drivers are required when the clients of the driver also reside in the kernel (such as HID devices, mass storage devices, or networking devices). User-mode drivers are preferred when only one process has access to the device (for example printers and scanners).</p><p><strong>Bundle identifier</strong>:</p><ul class="ul"><li class="li"><p><code>com.apple.iokit.IOUSBFamily</code></p></li></ul><p><strong>Headers in</strong>:</p><ul class="ul"><li class="li"><p>Kernel resident: <code>Kernel.framework/Headers/IOKit/usb/</code></p></li><li class="li"><p>Device interface: <code>IOKit.framework/Headers/usb</code></p></li></ul><p><strong>References and specifications</strong>:</p><ul class="ul"><li class="li"><p>USB.org—<span class="content_text"><a href="http://www.usb.org" target="_blank">http://www.usb.org</a></span>; see especially USB Common Class Specification, revision 1.0, available for download at <span class="content_text"><a href="http://www.usb.org/developers/devclass_docs/usbccs10.pdf" target="_blank">http://www.usb.org/developers/devclass_docs/usbccs10.pdf</a></span></p></li><li class="li"><p>Apple Developer Connection—<span class="content_text"><a href="http://developer.apple.com/hardwaredrivers/usb/index.html" target="_top">http://developer.apple.com/hardwaredrivers/usb/index.html</a></span></p></li></ul><p><strong>Class hierarchy</strong>:</p><br/><div><img src = "../art/usbfamily.gif" alt = "image: ../art/usbfamily.gif" width="377" height="150"></div><br/><p><strong>Device interface</strong>:</p><ul class="ul"><li class="li"><p>User mode clients use an API which is part of the I/O Kit framework; this API is defined in <code>IOKit/usb/IOUSBLib.h</code>. Clients use user mode abstractions of the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_581"></a>IOUSBDevice and <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_582"></a>IOUSBInterface classes found in the kernel in order to communicate with the USB device or USB interface. </p></li></ul><p><strong>Kernel-resident drivers</strong>:</p><ul class="ul"><li class="li"><p>Kernel drivers for physical USB devices can be written for either USB devices or for USB interfaces. A physical USB device consists of a device descriptor that can describe any number of interfaces. When writing a kernel-resident driver, you need to decide if the driver is to control the whole USB device or if it is to control only an interface of a USB device.</p></li></ul><p>The USB family for kernel-resident drivers consists of three main classes:</p><ul class="ul"><li class="li"><p><strong>IOUSBDevice</strong>: The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_583"></a>IOUSBDevice class is an abstraction of a physical USB device. There is one IOUSBDevice class instantiated for every USB device connected to the bus. The provider for an IOUSBDevice object is an <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_584"></a>IOUSBController object (which is an abstraction of a USB controller).</p></li><li class="li"><p><strong>IOUSBInterface</strong>: The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_585"></a>IOUSBInterface class is an abstraction of one of the interfaces of a USB device. There is one of these classes instantiated for every interface in a device. When it is created, the IOUSBInterface creates IOUSBPipe objects for each endpoint described in the interface descriptor of the interface. The provider for an IOUSBInterface object is an IOUSBDevice object.</p></li><li class="li"><p><strong>IOUSBPipe</strong>: The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_586"></a>IOUSBPipe class contains the methods that are used for communicating with a USB device or a USB interface. There is one IOUSBPipe object created for the default control endpoint and an additional one for each endpoint described in the interface descriptor. The provider for an IOUSBPipe object is an IOUSBInterface object.</p></li></ul><p>Kernel-resident USB drivers are clients of the family that provides the transport services and are members of the family from which they get their class inheritance. For example, a driver for a USB keyboard is a client of the IOUSBInterface object (that is, the IOUSBInterface object is the provider for the driver) but the keyboard driver is a member of the IOHIDFamily. The USB family provides the mechanism for getting at the key presses in the keyboard. The keyboard driver supports methods from the HID family for sending those key presses to the event system.</p><p>As mentioned above, you can write a driver to match against a USB device or a USB interface. The <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_587"></a>IOUSBDevice or <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_588"></a>IOUSBInterface classes are the providers for the drivers. The drivers themselves can be members of a separate family (such as the IOHIDFamily or IOAudioFamily) or can be members of the IOService family.</p><p><strong>Power management</strong>:</p><p>All in-kernel USB device drivers should implement at least basic power management to increase power saving in the system. In Mac OS X v10.5, the USB family introduced the <code>IOUSBHubPolicyMaker</code> object, which is an abstraction of a USB hub that includes power-management capabilities. When you develop a USB device driver to run in Mac OS X v10.5 and later and you call <code><!--a-->joinPMtree<!--/a--></code>, your driver is attached into the power plane as a power child of an <code>IOUSBHubPolicyMaker</code> object. (In earlier versions of Mac OS X, the power parent of a USB device driver was an <code>IOUSBController</code> object representing the controller to which the device was attached.) </p><p>Your USB device driver can communicate with its <code>IOUSBHubPolicyMaker</code> object to determine the power state of its hub. This can be useful if, for example, you need to handle an imminent shutdown differently from a restart. The <code>IOUSBHubPolicyMaker</code> object supports the following five power states for a hub:</p><ul class="ul"><li class="li"><p>On. The hub is fully functional and at least one of its ports is active (that is, not suspended).</p></li><li class="li"><p>Sleep. If the hub supports sleep, its ports are inactive and it is not supplying power to any attached devices; if not, the sleep state is identical to the off state.</p></li><li class="li"><p>Doze. This is an idle power-saving state a hub can enter when all its ports are suspended or disconnected and all attached devices are in either the off or doze state. Not all hubs support the doze state.</p></li><li class="li"><p>Off. The hub enters this state when the system is about to shut down.</p></li><li class="li"><p>Restart. This state is identical to the off state, except that a hub enters it when the system is about to restart.</p></li></ul><p>USB devices seldom support more than the first four of these power states, and many support only on, sleep, and off. If you’re developing a driver for a USB device that supports doze, you should call <code><!--a target="_top" -->SuspendDevice<!--/a--></code> when you switch the device’s power state to doze, so the hub can suspend the port to which the device is attached. If the drivers for all the devices attached to a hub do this, the hub can enter the doze state, which can result in significant power saving for the system. However, if your driver calls <code><!--a-->SuspendDevice<!--/a--></code> without also changing the device’s power state to doze, you prevent the hub from entering the doze state and saving power. </p><p>If the hub to which your device is attached does not support sleep, the device must go to its off state when the system goes to sleep. Of course, if your device does not support sleep, it must also go to its off state when the system goes to sleep, even if its hub does support sleep.</p><p>During a power-state change, note that a USB hub's power state is not updated until the hub receives a <code><!--a-->powerChangeDone<!--/a--></code> call, which does not happen until after all downstream hubs and devices have received their <code><!--a-->powerChangeDone<!--/a--></code> calls. This means that if you use the <code><!--a-->getPowerState<!--/a--></code> call introduced in Mac OS X v10.5 to get an upstream hub’s current power state, you might receive stale power-state information. However, if your device is changing to its on state, you can assume that the upstream hubs are actually on, even if their power-state values haven’t yet been updated.</p><a name="//apple_ref/doc/uid/TP0000021-TPXREF123" title="Table A-14Clients and providers of the USB family"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-14&nbsp;&nbsp;</strong>Clients and providers of the USB family</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Client of the nub</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider for the nub</p></th></tr><tr><td  scope="row"><p><strong>Action</strong></p></td><td ><p>Drives a device that plugs into a USB port. </p></td><td ><p>Drives a USB bus controller.</p></td></tr><tr><td  scope="row"><p><strong>Example</strong></p></td><td ><p>A keyboard driver is an interface driver; its provider is the driver for the USB <em>device</em>. The keyboard driver inherits from the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_589"></a>IOHIKeyboard class—it’s a member of the HID family.</p></td><td ><p></p></td></tr><tr><td  scope="row"><p><strong>Classes</strong></p></td><td ><p>IOUSBDevice drivers can only communicate with the USB device through the default control pipe. IOUSBInterface drivers have IOUSBPipe objects created for all the endpoints that are described in the interface descriptor for the current configuration. The driver uses these objects to communicate with the device.</p></td><td ><p>USB family-member drivers should inherit from the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_590"></a>IOUSBController class.</p></td></tr><tr><td  scope="row"><p><strong>Notes</strong></p></td><td ><p>Common client families include the HID family (<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_591"></a>IOHIPointing and IOHIKeyboard classes) and the Transport Drivers for Storage family devices. Most kernel-mode clients of the USB family are interface drivers, and only occasionally device drivers.</p></td><td ><p>Mac OS X includes generic drivers that support all <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_592"></a>Open Host Controller Interface (OHCI) bus controllers. In general, third-party developers do not need to write drivers for the USB family.</p></td></tr></table></div><p><strong>Driver matching</strong>: The USB family uses the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_593"></a>USB Common Class Specification, revision 1.0 to match devices and interfaces to drivers (for a link to this specification, see the section above titled “References and specifications”). The driver should use the keys defined in this specification to create a matching dictionary that defines a particular driver personality. There are two tables of keys in the specification. The first table contains keys for finding devices and the second table contains keys for finding interfaces. Both tables present the keys in order of specificity: the first key in each table defines the most specific search and the last key defines the broadest search. Each key consists of the combination of elements listed in the left column of the table.</p><p>For a successful match, you must add the elements of exactly one key to your personality. If your personality contains a combination of elements not defined by any key, the matching process will not find your driver. For example, if you’re attempting to match a device and you add values representing that device’s vendor, product, and protocol to your matching dictionary, the matching process is unsuccessful even if a device with those same values in its device descriptor is currently represented by an IOUSBDevice nub in the I/O Registry. This is because there is no key that combines the elements of vendor number, product number, and protocol.<a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_594"></a></p><a name="//apple_ref/doc/uid/TP0000021-BABHIGFE" title="Devices Without I/O Kit Families"></a><h2>Devices Without I/O Kit Families</h2><p>Some categories of devices do not have family support from <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_595"></a>I/O Kit. In general, there are three reasons why a particular device may not be supported by an I/O Kit family.</p><ul class="ul"><li class="li"><p>Support for certain devices is provided by other frameworks. The I/O Kit is not the most appropriate place for the abstractions that represent these devices. Examples of such devices include printers, scanners, digital cameras, and other imaging devices. If you are developing a driver for this category of device, you should use the appropriate imaging SDK.</p></li><li class="li"><p>For some devices, it is not possible to provide a set of useful, common abstractions. Such devices might include USB security dongles, data acquisition cards, and other vendor-specific devices. These devices do not share a sufficiently large number of characteristics to make creation of I/O Kit families worthwhile. For example, although security dongles all connect via USB, there is no easily defined set of abstractions common to all such devices. An I/O Kit family would not provide substantial assistance to developers. It should not be assumed, however, that a family is required to write a new driver. In many cases, the <code>IOService</code> class provides everything a driver requires to write a “family-less” driver.</p></li><li class="li"><p>For many devices, it is possible to define a set of useful abstractions; however, Apple has not chosen to create a family for one or more reasons. These devices may be part of a technology that is not a common Macintosh market. Or, Apple’s engineers may not have sufficient in-house expertise with certain devices to create the best family definition. In these cases, an opportunity exists for third-party developers to extend the I/O Kit model by developing families of their own. In addition, families developed under the Apple Public Source License can be sent back to Apple for possible inclusion in future releases of Mac OS X.</p></li></ul><a name="//apple_ref/doc/uid/TP0000021-BABCIHGB" title="Imaging Devices"></a><h3>Imaging Devices</h3><p>There is no I/O Kit family for <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_596"></a>imaging devices (cameras, printers, and scanners). Instead, support for particular imaging device characteristics is handled by user-space code (see <span class="content_text"><a href="../ArchitectOverview/ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BEHEGHEG">“Controlling Devices From Outside the Kernel”</a></span> for further discussion). Developers who need to support imaging devices should employ the appropriate imaging SDK.</p><a name="//apple_ref/doc/uid/TP0000021-TPXREF111" title="Digital Video"></a><h3>Digital Video</h3><p>To add <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_597"></a>digital video capabilities to your software, use the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_598"></a>QuickTime APIs.</p><a name="//apple_ref/doc/uid/TP0000021-TPXREF103" title="Sequential Access Devices (Tape Drives)"></a><h3>Sequential Access Devices (Tape Drives)</h3><p>There is, at present, no I/O Kit family specifically designed for <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_599"></a>sequential access devices, such as tape drives. However, third-party developers can use the <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_600"></a>SAM device interface to create plug-in components for such devices.</p><a name="//apple_ref/doc/uid/TP0000021-TPXREF104" title="Telephony Devices"></a><h3>Telephony Devices</h3><p>There is, at present, no I/O Kit family for <a name="//apple_ref/doc/uid/TP0000021-DontLinkElementID_601"></a>telephony devices. Apple is evaluating plans for a Telephony family for the future.</p><a name="//apple_ref/doc/uid/TP0000021-TPXREF105" title="Vendor-Specific Devices"></a><h3>Vendor-Specific Devices</h3><p>For some devices, it is not possible to provide a set of useful, common abstractions. Because families define the set of abstractions shared by all devices within the family, it is not feasible to create a family for these devices.</p><p>In most cases, however, a family is not necessary in order to write a driver for these devices. Developers should start by inheriting functionality from <code>IOService</code>, then use the <code>GetProperty</code> and <code>SetProperty</code> calls to communicate with their driver. In many cases, this should suffice. In some cases, however, such as data acquisition cards requiring high bandwidth, the developer should create their own user client (for a device-interface plug-in). Such objects can provide shared memory and procedure-call interfaces to a user-space library (see <code>IOUserClient.h</code>). You can find several good examples in IOKitExamples on the Darwin Open Source site.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Glossary/Glossary.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory/RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-17<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Families_Ref/Families_Ref.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Families_Ref/Families_Ref.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Families_Ref/Families_Ref.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>