<html>
<BODY bgcolor=#FFFFFF>
<!-- converted by Dan Grillo's rtf-html 960214 on 96-10-09 at 14:25:00 -->
<!-- substantial amount of tweaking afterwards by Terry Donoghue -->
<head>
<title>WebObjects 3.0: Changes from 2.0</title>
</head>
<body>
<h1>WebObjects Release 3.0</h1>
<strong><big>Changes from Release 2.0</strong></big> <br>
10/20/96<br>
 <br>
 <br>
<h3>Topics</h3><br>
<hr>
<table border=0>
<tr><td scope="row"><a href="#Introduction">Introduction</a></td><td><a href="#ClassHierarchy">WOF Class Hierarchy</a></td><td><a href="#DevTools">Development Tools</a></td></tr>
<tr><td scope="row"><a href="#Java">Java Client-Side Components</a></td><td><a href="#WOPro">Changes to WebObjects Pro</a></td><td><a href="#DBIntegration">Database Integration</a></td></tr>
<tr><td scope="row"><a href="#DynEl">Dynamic Element Enhancements</a></td><td><a href="#StateMgmt">State Management</a></td><td><a href="#WebScript">WebScript Changes</a></td></tr>
<tr><td scope="row"><a href="#Init">Initialization and Request Handling</a></td><td><a href="#WOApp">WOApp Usage Discouraged</a></td><td><a href="#URL">URL Syntax</a></td></tr>
<tr><td scope="row"><a href="#AppDir">Application Directory Name</a></td><td><a href="#Timeout">Application Timeout</a></td><td><a href="#Resource">Resource Management/Localization</a></td></tr>
<tr><td scope="row"><a href="#Reuse">Reusable Components</a></td><td><a href="#Porting">Porting Checklist</a></td></tr>
</table>
 <br>
<br>
<a name="Introduction"><h3>Introduction</h3></a>
<hr>
The 3.0 release of the WebObjects family of products differs in a number of ways from the 2.0 release.  Changes were made to support new features (support for Java, enchanced interfaces to some dynamic elements, and so on), to make it easier to use WebObjects (improved design for state management, simplification of the WebScript syntax, and so on), and to make WebObjects integrate better with NeXT's Enterprise Objects Framework. <br>
<br>
If you developed applications based on WebObject Release 2.0, you'll find this document a useful summary of the differences between the two releases. With the information summarized here and described in detail in the <i>WebObjects Developer's Guide</i>, we hope you'll find the transition to WebObjects Release 3.0 relatively easy and clearly worth the effort.<br>
<br>
For a checklist of steps to complete for porting WOF 2.0 applications to WOF 3.0, see <a href="#Porting">Porting to WebObjects 3.0: A Checklist.</a><br>
<P>
<B>NOTE: </B>All changes described in this document also apply to WOF Release 3.1.
<br>
<br>
<a name="ClassHierarchy"><h3>WebObjects Framework Class Hierarchy</h3><a/>
<hr>
The class hierarchy in WebObjects 3.0 has changed somewhat from that in WebObjects 2.0.  This diagram summarizes the changes.<br>
<br>
<img src="Images/WebObjectsClasses.gif"> <br>
 <br>
 <br>
 <br>
 <br>
<a name="DevTools"><h3>Development Tools </h3></a>
<hr>
<h4>WebObjects Builder</h4>
The WebObjects Builder application has markedly changed since the prerelease version that was distributed with WebObjects 2.0. In particular, the following improvements have been made to the user interface:<br>
<br>
<ul type=disc>
<li>You can now display a component's script file at the same time as its HTML template. The main display of the component window always shows you the component's variables and methods as well as the HTML template. Choose Tools-&gt;Script-&gt;Script or press the script button on the component window's toolbar to see the entire script file. <br>
<br>
<li>To bind an element, you can simply select the element and double-click a variable or method. You no longer have to type the name of the variable in the inspector window.<br>
<br>
<li>The bindings inspector now lists all of a dynamic element's attributes instead of listing only the required attributes.<br>
<br>
<li>You can create a dictionary type (or class) without first having to create variables. Choose Classes from the Tools menu, enter a name for the class, and then enter names for the class's attributes.<br>
<br>
<li>Drag-and-drop database support and a wizard for creating applications that access a database have been added. These are described in more detail later in this document.<br>
<br>
<li>Support for creating reusable components has been improved. The page inspector now lists all of a component's variables. Using this interface, you can select which variables should be <i>exported</i>, meaning that the parent component can bind to them. <br>
</ul>
<br>
<br>
<h4>Project Builder</h4>
Project Builder now includes a project type for compiled WebObjects applications. When you create a new application with a project type of "WebObjects," Project Builder populates the project directory with the necessary files (<b>PB.project</b>, makefiles, template files, and <b>main.m</b>). In addition, you can add component files (".wo"), and they will appear under Interfaces; when you double-click the icon for these files, they are opened in WebObjects Builder.<br>
<br>
You can use Project Bulder to build, edit, and search WebObjects applications, just as you can with any other type of application. The <b>WebObjectsApplication.projectType</b> bundle is installed in <i>NEXT_ROOT<b></i>/NextDeveloper/ProjectTypes</b> when WebObjects is installed.<br>
<br>
<b>Note</b>: Currently there is no synchonization with WebObjects Builder. For example, if you create a new component in WebObjects Builder, Project Builder does not automatically add it to the project. You must add each new component yourself.<br>
 <br>
   <br>
<a name="Java"><h3>Java Client-Side Component Integration</h3></a>
<hr>
WebObjects Framework 3.0 supports the synchronization of state between Java applets in the client browser and a WebObjects application in the server without requiring a page reload. It also enables client-side applets to trigger actions in an object on the server side of the connect. This capability is new.<br>
  <br>
A Java applet can invoke an action in the server-side WebObjects application that results in a new page loaded into a browser. But this feature also  permits the client browser and server to exchange data without the need for page reloads. Browser applets can use this feature to synchronize state with the server or to request and receive small amounts of extra data or state. For example, if a user incorrectly enters a password in a Login page, the browser can simply display an "Incorrect password" message on the same page.<br>
 <br>
Java applets form controls on the client's page: text fields, buttons, browsers, check boxes, and so on. The WOApplet dynamic element, which "represents" these applets on the server side, is extended to you to specify the class of an applet, its association class, and bindings or initial values for the applet's keys and actions.  An applet's association object serves as an intermediary in passing values back and forth between the WebObjects application and the applet.<br>
<br>
For example, you can specify a text field applet in a WOApplet dynamic element in a "wod" file as in the example below:<br>
<br>
<pre>PASSWORD : WOApplet {
    code = "next.wo.client.controls.TextFieldApplet.class";
    codebase = "/WebObjects/Java";
    width = "200";
    height = "20";
    associationClass = "next.wo.client.SimpleAssociation";
    stringValue = nameString;
    echoCharacter = "*";
    action = "validateUser";
};
</pre><br>
<b>Note</b>: WebObjects Builder now integrates support for this feature; check future versions of WebObjects Builder documentation for details.<br>
<br>
This code specifies that the WebObjects application should download the TextFieldApplet Java class to the client.  It will also download the class SimpleAssociation, the standard Association subclass for NeXT-provided applet controls, which will serve as an intermediary in synchronizing the value (in this case, the <b>stringValue</b>) between the WebObjects application and the TextFieldApplet.  It also specifies that the action "validateUser" is to be invoked when the user presses Return.<br>
<br>
For 3.0, essentially each Java client-side control on the browser page will be an applet.  Several other Java objects (not visible on the browser page) coordinate the actions of the individual applets, synchronize their values as needed, and communicate with the WebObjects application on the server side.  <br>
<br>
Currently, only a handful of Java Client-Side Component classes are public. One of these classes, Association, is an abstract class that defines the behavior of Association objects. Another public class is SimpleAssociation, a concrete subclass of Association. If you want to use any of the applets provided by NeXT, you can use SimpleAssociation. If you have created your own applet control or have "found" one, you can make your applet work with SimpleAssociation, or you can make a custom subclass of Association that "pushes and pulls" values from the keys and actions of the applet. Association subclasses must also invoke action messages when it is time to trigger that action.<br>
	<br>
A simple example of Java client-side communication is CapitalizeString.woa, an example application provided with WebObjects.  This application uses three applets. It lets a user enter a word in one text field, and when the user clicks a button, returns an uppercase version of the word in another text field.  This is done without a page reload.<br>
<br>
One limitation to Java client-side support is that the data received from a request cannot derive from both applets and HTML forms on the same page. <br>
 <br>
 <br>
<a name="WOPro"><h3>Changes to WebObjects Pro</h3></a>
<hr>
WebObjects Pro 3.0 has been redesigned for developing dynamic, web-based applications for low-traffic sites.  It now includes:<br>
<br>
<ul type=disc>
<li>Built-in support for two-tier database access
<li>Rapid database application development with WebObjects Builder
<li>Integration of existing C or C++ libraries
<li>Support for compiled C, C++, or Objective-C code, as well as WebScript
</ul>
<br>
Because WebObjects Pro is intended for smaller sites, scalability and performance features that were in previous releases are not included in WebObjects Pro 3.0.  For a complete description of the features in WebObjects Pro, see 

<!-- morphDoc substitution for tag EODifferencesDoc-->
<A HREF="../EnterpriseVsPro.html">Differences Between WebObjects Enterprise and Pro</A>.
<br>
<br>
<a name="DBIntegration"><h3>Database Integration</h3></a>
<hr>
<h4>Enhancements</h4>
WebObjects 3.0 provides two enhancements to Enterprise Objects Framework integration:<br>
<br>
<ul type=disc>
<li>Built-in support for minimal enterprise object state archiving. To store state in the page (or in cookies) in WebObjects 2.0, you had to provide custom implementations of the methods <b>initWithCoder: </b>and <b>encodeWithCoder:</b>.  In WebObjects 3.0, this is no longer necessary.<br>
<br>
<li>Per-session object graphs.<br>
</ul>
<br>
Some applications require that each session has its own object graph.  For example, consider an application that updates customer data.  Suppose one user changes a customer's credit limit.  Other users shouldn't see the new credit limit until it's successfully saved in the database.  To ensure that uncommitted changes are only visible to the user who made the change, each session (user) needs its own object graph to operate on.<br>
<br>
In WebObjects 1.0 and 2.0, an application required a database connection for each object graph.  If you limited your application to one database connection, uncommitted changes made by one user were visible to all the other users too.  In WebObjects 3.0, you can have an object graph for each session using a single database connection .<br>
<br>
<br>
<h4>New Features Summary</h4>
<p>WebObjects 3.0 provides graphical development tools for creating web-based database applications.  With little or no coding you can map database records to objects and then bind the objects to elements in your web pages.<br>
<br>
In WebObjects 2.0, WebObjects Enterprise included Enterprise Objects Framework database integration technology, but you had to write scripts or compiled code to use it.  In WebObjects 3.0, WebObjects Builder provides drag-and-drop support for:<br>
<ul>
<li>Displaying data from a database in your web pages
<li>Updating database records
<li>Searching the database based on arbitrary criteria
</ul>
<p>Both WebObjects Enterprise and WebObjects Pro include EOModeler (an application for defining a database-to-object mapping) and the Enterprise Objects Framework library of classes.  For information on EOModeler and Enterprise Objects Framework classes, see the <i>Enterprise Objects Framework Developer's Guide</i> and <i>Reference</i>.<br>
<br>
Note that some of the Enterprise Objects Framework capabilities are limited in WebObjects Pro.  For a complete description of the features in WebObjects Pro, see "Differences between WebObjects Enterprise and Pro," accessible from the WebObjects home page.<br>
 <br>
<br>
<h4>More On New Features</h4>
<p>The emphasis of WebObjects 3.0 is on providing an easy-to-use, graphical development environment for integrating databases with web applications.  WebObjects Builder delivers the bulk of this environment by providing the following database integration features:<br>
<ul>
<li>The Database Wizard
<li>Display Groups
<li>An Editing Context
</ul>
<p>Each of these features is described below.<br>
<br>
<br>
<b>The Database Wizard<br>
</b><br>
The Database Wizard is the simplest way to define how a WebObjects application interacts with a database.  Running the wizard performs all the setup necessary to fetch database records and display them in a web page.  Depending on the configuration you choose, the wizard may also provide database search forms in which users can specify record-matching criteria and forms for inserting, updating, and deleting database records.<br>
<br>
To use the Database Wizard, choose Database Wizard from the Tools menu and perform the steps as the wizard prompts you.  When the Database Wizard finishes, simply save your WebObjects application, and run it.  If the web page created by the wizard doesn't have all the features you want, use WebObjects Builder to extend or modify it.  Pages created by the Database Wizard provide great jumping off points for web-based database applications.<br>
<br>
<br>
<b>Display Groups</b><br>
<br>
The WebObjects Framework includes a new class, WODisplayGroup, whose instances provide a simple interface for interacting with relational databases in terms of objects.  WODisplayGroup objects--also referred to as display groups--use classes defined in Enterprise Objects Framework to:<br>
<ul>
<li>Fetch from the database.
<li>Insert, update, and delete database records.
<li>Build qualifiers from user input and order search results.
<li>Manage batches of search results.
</ul>
<p>In your code, you work with objects.  WODisplayGroup and Enterprise Objects Framework take care of converting operations on objects to database operations on records.<br>
<br>
As part of its tasks, the Database Wizard creates a display group object and adds it to your application as a component variable.  To create a display group without using the wizard, perform the following steps:<br>
<ol>
<li>Open a model file in EOModeler.<br>
<br>
<li>Select an entity in the Model Editor.<br>
<br>
<blockquote>A display group manages objects associated with a single entity.  For example, if you choose the Movie entity, the resulting WODisplayGroup operates on Movie objects.  Note, however, that you can also access other kinds of objects through a Movie object's relationships.  For example, if a relationship between a MOVIE table and a STUDIO table can be expressed with an join, you could access Studio objects associated with a particular Movie object.  For information on creating relationships, see the chapter "Using EOModeler" in the <i>Enterprise Objects Framework Developer's Guide</i>.<br>
</blockquote>
<br>
<li>Drag the entity into the component window to which you want to add a display group.<br>
<br>
</ol>
In most cases, you can use the Database Wizard to create a display group for you, but you might add one as described above if you don't want to use the wizard's layouts.<br>
<br>
<br>
<b>Editing Context</b><br>
<br>
The WebObjects WOSession class provides access to an EOEditingContext object.  You generally can't see the EOEditingContext object in WebObjects Builder, but some of the scripts created by the Database Wizard reference it.  For example, if you run the Database Wizard specifying the "Selected Record" layout, the Database Wizard creates a <b>saveChanges</b> method in the component script that includes the following expression:<br>
<pre>	[[[self session] defaultEditingContext] tryToSaveChanges]
</pre><br>
Depending on your language preference (set in the Preferences panel), the expression may have the following form instead:<br>
<pre>	self.session.defaultEditingContext.tryToSaveChanges(); 
</pre><br>
This expression sends a <b>tryToSaveChanges</b> message to the <b>session</b>'s <b>defaultEditingContext</b> variable.  This default EOEditingContext object manages graphs of objects fetched from the database, and all changes to the database are saved through it.  For more information, see the EOEditingContext class specification in the <i>Enterprise Objects Framework Reference</i>.<br>
<br>
<br>
<br>
<a name="DynEl"><h3>Dynamic Element Enhancements</h3></a>
<hr>
<h4>Templates for Dynamic Elements</h4>
Optional templates for dynamic elements are no longer allowed.  For example, with WebObjects 2.0 you could position a dynamic element in the HTML page using either of these approaches:<br>
<br>
<b><a href="#top-withouttemplate" name="withouttemplate">Without template</a><tt></b> &lt;WEBOBJECT NAME="MY_TEXTFIELD"&gt;&lt;/WEBOBJECT&gt;<br>
</tt>
<b> <a href="#top-withtemplate" name="withtemplate">With template</a><tt></b> &lt;WEBOBJECT NAME="MY_TEXTFIELD"&gt;<br>
	&lt;INPUT TYPE="TEXT"&gt;<br>
&lt;/WEBOBJECT&gt;<br>
</tt><br>
Now, only the first approach is allowed.  <br>
<br>
In WebObjects 2.0 the optional template was merged with its associated dynamic element, so it was possible to declare some attributes in the template and other attributes in the dynamic element:<br>
<br>
<pre>&lt;WEBOBJECT NAME="MYFORM"&gt;
    &lt;FORM TARGET=MYTARGET&gt;
    ...
    &lt;/FORM&gt;
&lt;/WEBOBJECT&gt;
</pre><br>
In WebObjects 2.0 the MYFORM dynamic element would take its action from associated declarations file and its target from the template declared above.  In WebObjects 3.0, this no longer happens, so the target attribute (if present) must now be assigned in the declarations file and the FORM template removed from the HTML file.<br>
<br>
In WebObjects 2.0, using a template was recommended so that you could check the layout of elements in a browser, even though the HTML page was not part of a running WebObjects application.  In WebObjects 3.0, WebObjects Builder lets you see the layout of the dynamic elements directly; the optional template is no longer needed.  Removing this feature helps improve the overall performance of dynamic element generation and it reduces the code complexity for better quality.<br>
<br>
Note:  You can still provide templates for static elements that are contained within a dynamic element.  For example:<br>
<br>
<pre>&lt;WEBOBJECT NAME="MY_FORM."&gt;
	&lt;INPUT TYPE="TEXT"&gt;
&lt;/WEBOBJECT&gt;
</pre><br>
The only restriction is that you can no longer provide a template for the dynamic element itself.<br>
 <br>
 <br>
<h4>New or Revised Elements</h4>
Here's a summary of the changes and additions made to the roster of dynamic elements in release 3.0.  See the section "Dynamic Elements" in the  <i>WebObjects Developer's Reference </i> for more complete details.<br>
<br>
<br>
<b> New WOJavaScript and WOVBScript elements<br>
</b>These new elements let you embed scripts written in JavaScript and VBScript code in dynamically generated pages.  Each element give you the option of hiding the script in an HTML comment so that older browsers that don't support these languages can ignore the scripts without error.<br>
<br>
<br>
<b>Change to WOApplet<br>
</b>WOApplet's attribute list has changed only superficially (with the addition of   <b>associationClass </b> and  <b>codeBase </b>), but its capabilities are now vastly expanded. See "<a href="#Java">Java Client-Side Component Integration</a>" above for the details.<br>
<br>
<br>
<b>Change to WOForm<br>
</b>WOForm now has a  <b>multipleSubmit </b> attribute, that lets you put more than one WOSubmitButton elements in the same form, each with its own action.<br>
<br>
<br>
<b>Change to WOFrame<br>
</b>For convenience, WOFrame now has a  <b>pageName </b> attribute, which lets you specify the name of the component that will provide the frame's content.<br>
<br>
<br>
<b>Changes to WOString <br>
</b>WOString has three new optional attributes:  <b>escapeHTML </b>,  <b>dateformat </b>, and  <b>numberformat </b>.  <br>
<br>
<b>escapeHTML </b> lets you control whether WebObjects will try to prevent a browser from interpreting HTML tags or not.  With this attribute, you can control whether WOString containing "&lt;B&gt;a bold idea&lt;/B&gt;" is displayed in the browser as "&lt;B&gt;a bold idea&lt;/B&gt;" or " <b>a bold idea </b>".<br>
<br>
<b>dateformat </b>, and  <b>numberformat </b> specify the format used to express a WOString's value.  Using  <b>dateformat </b>, you can control whether a date appears as 12/01/96; Sunday, December, 1, 1996; or some other format, for example. With  <b>numberformat </b>, you can express a number in a monetary format ($10,000.00), determine how negative numbers will appear, and so on.<br>
<br>
<br>
<b>Change to WOTextField<br>
</b>WOTextField, like WOString,  has these new optional attributes:   <b>dateformat </b>and  <b>numberformat </b>.  <br>
<br>
<b>dateformat </b>, and  <b>numberformat </b> specify the format used to express a WOString's value.  Using  <b>dateformat </b>, you can control whether a date appears as 12/01/96; Sunday, December, 1, 1996; or some other format, for example. With  <b>numberformat </b>, you can express a number in a monetary format ($10,000.00), determine how negative numbers will appear, and so on.<br>
<br>
<br>
<b>Change to WOConditional<br>
</b>WOConditional now has an optional <b>negate</b> attribute:<br>
 <br>
<pre>WOConditional { 	
    condition = YES|NO; 
    <b>[negate=YES|NO;]
</b>};
</pre>
 <br>
</tt> The <b>negate</b> attribute lets you use the same test to display mutually exclusive information:<br>
 <br>
<tt>&lt;HTML&gt;<br>
&lt;WEBOBJECTS NAME="PAYING_CUSTOMER"&gt;Thank you for your order!&lt;/WEBOBJECTS&gt;<br>
&lt;WEBOBJECTS NAME="WINDOW_SHOPPER"&gt;Thanks for visiting!&lt;/WEBOBJECTS&gt;<br>
&lt;/HTML&gt;<br>
</tt><br>
<hr>
<br>
<tt>PAYING_CUSTOMER: WOConditional {condition=payingCustomer;};<br>
WINDOW_SHOPPER: WOConditional {condition=payingCustomer; negate=YES;};<br>
</tt>
<hr>
<pre>- payingCustomer {
    if (/* ordered something */) {
	return YES;
    }
    return NO;
}
</pre> <br>
In WebObjects 2.0, you had to define two methods (for example <b>payingCustomer</b> and <b>browser</b>) to accomplish what in WebObjects 3.0 only takes one method.<br>
 <br>
 <br>
<b>Change to WOHyperlink<br>
</b>WOHyperlink has an optional <b>fragmentIdentifier</b> attribute:<br>
<br>
<pre>WOHyperlink { 
    [string=aString;] 
    action=aMethod | href=aURL | pageName=aString; 
    <b>[fragmentIdentifier=anchorFragment;] </b>
    [target=frameName;] 
    [disabled=YES|NO;] 
    ... 
};
</pre>
<br>
This attribute lets you specify a location within the destination document.  For example,<br>
<br>
<tt>&lt;HTML&gt;<br>
&lt;WEBOBJECT NAME=ALINK&gt;&lt;/WEBOBJECT&gt;<br>
&lt;/HTML&gt;<br></tt>
<hr>
<pre>ALINK: WOHyperlink {
    string = "[ Book of all Knowledge ]"; 
    pageName = "IRS1040"; 
    fragmentIdentifier= "ScheduleA";
};
</pre><br>
The location in the destination document is marked in the standard way (for example, &lt;A name="ScheduleA"&gt; ScheduleA &lt;/A&gt; ).  The URL generated by the WOHyperlink has the format, "http://<i>url#fragmentIdentifier</i>".<br>
<br>
<br>
<a name="StateMgmt"><h3>State Management</h3></a>
<hr>
WebObjects 3.0, with the new WOSession class, introduces a simplified system for maintaining session state in an application. The <b>session</b> and <b>persistent</b> keywords from WebObjects 2.0 are now obsolete. Thus, a component no longer stores persistent state directly, as it did in Release 2.0. Instead, it saves and restores persistent state to and from a WOSession object. <br>
<br>
In Release 3.0, each client session within an application has a WOSession object to hold its state. The state is encapsulated in the instance variables of the WOSession object. You can script the WOSession object by adding a <b>Session.wos</b> script file to your application (just as you script the WOApplication object by adding an <b>Application.wos</b> file).  Alternatively, you can create a subclass of WOSession for your session's state. See CyberWind for an example of how to use the new state management facilities.<br>
<br>
Global variables--that is, variables that are global to all sessions of the application--are declared the same way in Release 3.0 as in Release 2.0.  (That is, they are declared as instance variables of the application class, either in the <b>Application.wos</b> script or in the compiled subclass of WOApplication.)
<br>
<br>
The WOSession class declares an <b>awake</b> method where you can put code you want to have executed at the beginning of each transaction the session is involved in.
  <br>
In Release 3.0, WOSession objects are stored in a WOSessionStore object.  The WOSessionStore class supports the storing of state in the server, in the client (using archiving and hidden fields--known as "state in the page"), or by using cookies.  A WOSessionStore object is smart, storing state in the server if the client does not support cookies, for example.<br>
 <br>
 <br>
<a name="WebScript"><h3>WebScript Changes</h3></a>
<hr>
The following changes have been made to WebScript:<br>
<ul type=disc>
<li>The keywords <b>persistent</b>, <b>session</b>, and <b>action</b> have been dropped. 
<li>A syntax variation similar to Visual Basic is now supported.
<li>Scripts can now implement <b>init</b> and <b>dealloc</b> to initialize and deallocate associated objects.
<li>Objective-C-style categories and scripted classes have been added. 
</ul>
<br>
Because of page caching and the new classes provided for storing and managing state (WOSession and WOSessionStore), there is no longer a need for the <b>session</b> and <b>persistent</b> variables in an application or component. See the <a href="#StateMgmt">State Management</a> section of this document for more on this subject.<br>
<br>
The <b>action</b> keyword in WOF 2.0 was used to identify an instance of the WOAction class for child-parent component callbacks. Because this class has been removed for 3.0, the keyword is no longer needed. For parent action invocation, use instead WOComponent's <b>performParentAction:</b>. See <a href="#Reuse">Better Support for Reusable Components</a> in this document for an example.<br>
<br>
WebScript supports a syntactical variation similar to Visual Basic and Java. This "modern syntax"  is emitted by WebObjects Builder when you set the appropriate Language preference. <br>
<br>
The <b>init</b> and <b>dealloc</b> methods are identical in purpose to their Objective-C counterparts. In them you initialize and deallocate the WOApplication, WOSession, or WOComponent object associated with the script. Note that <b>init</b> is invoked only once during an object "lifetime": when an application is created, when a session begins, and when a page or component is created (but not when it is restored).  The <b>awake</b> method, on the other hand, is invoked in an object when it begins participating in a cycle of the request-response loop.<br>
<br>
You can add methods to WOF 3.0 classes (and derived classes) using categories. The syntax for creating categories is similar to Objective-C's.  You can also create subclasses of Objective-C classes in your scripts. See "Categories" and "Scripted Classes" in the "<a href="../DevGuide/WebScript/WebScript.mif.book.html">Using WebScript</a>" chapter.<br>
 <br>
 <br>
<a name="Init"><h3>Initialization and Request Handling</h3></a>
<hr>
<h4>Summary</h4>
WebObjects 2.0 provided the following delegate-style methods as "hooks" into the request-response loop:<br>
<br>
<dl>
<dd>willPrepareForRequest:inContext:<br>
<dd>didPrepareForRequest:inContext:<br>
<dd>willGenerateResponse:inContext:<br>
<dd>didGenerateResponse:inContext:<br>
</dl>
<br>
WebObjects 3.0 functionally replaces the above methods with two WOComponent methods that scripts can implement and subclasses can override:<br>
<br>
<dl>
<dd>takeValuesFromRequest:inContext:<br>
<dd>appendToResponse:inContext:<br>
</dl>
<br>
Subclasses of WOComponent can also override the (previously private) <b>invokeActionForRequest:inContext:</b> to implement special behavior during the action-invocation phase of the request-response loop.<br>
<br>
In addition, the <b>awake</b> method implemented by applications and components can now also be implemented by WOSession objects (in a <b>Session.wos</b> script at the top level).  The session <b>awake</b> performs initializations for the session object that are in effect for a cycle of the request-response loop. <br>
<br>
A <b>sleep</b> method now complements the <b>awake</b> method, and is invoked at the end of each request-response loop in the application and session objects, and in the component objects involved in request handling.  It permits the receiving object to perform any clean-up tasks, such as deallocating variables initialized in <b>awake</b>. <br>
<br>
 <br>
<h4>Discussion</h4>
</b>A major design change between WebObjects 2.0 and WebObjects 3.0 motivates the shift from delegate-style to overriden methods for request handling.  WOComponent objects are now their own controllers, and do not rely on external "controller" objects to inform them of phases in the request-response loop.   <br>
<br>
Every component in a WebObjects application is an instance of a  WOComponent subclass. If a component is implemented in WebScript, the application at run time instantiates an object from a special WOComponent subclass and adds to it the code in the ".wos" file. Objective-C and Java components must be implemented explicitly as subclasses of WOComponent.<br>
	<br>
The <b>takeValuesFromRequest:inContext:</b> method is invoked before the application stores user input for the request (and hence is functionally related to <b>willPrepareForRequest:inContext:</b>). A common purpose for overriding this method is to get request and context information, especially information that might affect how the request is to be handled.  If, however, in your implementation of this method you invoke <b>super</b>'s <b>takeValuesFromRequest:inContext:</b> first, you can manipulate the user input after it has been assigned to variables of the request component.  Thus:<br>
<br>
<pre>- willPrepareForRequest:r inContext:c {
    // code A
}
- didPrepareForRequest:r inContext:c {
    // code B
}
</pre>	<br>
is equivalent to:<br>
	<br>
<pre>- takeValuesFromRequest:r inContext:c {
    // code A
    [super takeValueFromRequest:r inContext:c];
    // code B
}
</pre>	<br>
The effect of invoking <b>super</b> in the other request-handling methods is similar. After any such invocation, the work intended (taking values from the request page, invoking the request page's action method, and completion of the HTML response) is largely completed.<br>
<br>
The <b>appendToResponse:inContext:</b> method is invoked before the application generates HTML code for the response. (Of course, if you invoke <b>super</b>'s method first, you can have the HTML code generated first.) In your implementation of this method, you could add to or modify the HTTP headers or otherwise manipulate the response. As the method name suggests, you can also append text and HTML code to the response.  You can also do some pre-response calculations bound to fields in the response page, as does the following CyberWind example, which computes the total amount of a sale:<br>
<br>
<pre>- appendToResponse:aResponse inContext:aContext
{
    id sailboards = [[self session] selectedSailboards];
    id count = [sailboards count];
    id i;

    total = 0;
    for (i = 0; i &lt; count; i++) {
	sailboard = [sailboards objectAtIndex:i];
	total = total + [[sailboard 
		objectForKey:@"price"] intValue];
    }
    [super appendToResponse:aResponse inContext:aContext];
}
</pre><br>
Note that <b>appendToResponse:inContext: </b>as implemented here fulfills a purpose similar to <b>willGenerateResponse:inContext:</b>.  The invocation of <b>super</b>'s method should occur as the last thing.<br>
<br>
The default behavior of <b>invokeActionForRequest:inContext: </b>is to execute an action and return the requested page. Override this method if you want to modify this behavior, such as substituting a page other than the requested one. (This substitution, however, cannot happen on an initial request because in that case neither <b>takeValuesFromRequest:inContext:</b> or <b>invokeActionForRequest:inContext:</b> is invoked.)<br>
<br>
<br>
<a name="WOApp"> <h3>Use of WOApp Global Discouraged</h3></a>
<hr>
WebObjects Release 3.0 includes expanded language support, including support for Java.  Since the Java language does not recognize global variables, the use of the WOApp global (which represents an application's instance of WOApplication) is now discouraged.  The use of WOApp in components that are scripted in WebScript is still allowed, but  is also discouraged.<br>
<br>
The WOComponent class declares the <b>application</b>, <b>session</b>, and <b>context</b> convenience methods that make it easy to refer to these global resources from a declarations file or a script.  For example (from the Footer component of the CyberWind example):<br>
<br>
<tt>TOTAL_REQUESTS:WOString {value = application.requestCount};<br>
SESSION_REQUESTS:WOString {value = session.requestCount};<br>
<br>
</tt>The values of the WOStrings are being set to the number of requests stored in the application's <b>requestCount</b> variable and the session's <b>requestCount</b> variable.	<br>
 <br>
 <br>
<a name="URL"><h3>URL Syntax for WebObjects Applications</h3></a>
The URL syntax for WebObjects applications in Release 3.0 is:<br>
<br>
 <tt>http://&lt;HTTP_server_name&gt;/&lt;CGI_scripts_directory&gt; /WebObjects[- &lt;WebObjects_version&gt;][.exe|.dll]/     &lt;Application_name&gt;[.woa][[/-/&lt;Page_name&gt;.wo | /&lt;Session_ID&gt;/ &lt;Page_name&gt;.wo/&lt;Context_ID&gt;/&lt;Element_ID&gt;      [/&lt;Application-instance_number&gt;][/ &lt;application_server_name&gt;]]][?Query_string]
</tt><br>
 <br>
 <br>
<a name="AppDir"><h3>Application Directory Name</a></h3>
<hr>
<br>
WebObjects application directories now have the suffix ".woa".  This change allows application directories to be associated with the WebObjects Builder application.  On platforms that support it, double-clicking the directory name will cause WebObjects Builder to open the application for editing.<br>
<br>
 <br>
<a name="Timeout"><h3>Application Timeout</h3></a>
<hr>
WOApplication now has a <b>setTimeOut:</b> method to set the period of inactivity within an application before it terminates execution.  It also offers a <b>timeOut</b> method to return this period. <br>
<br>
<br>
<a name="Resource"><h3>Better Support for Resource Management and Localization</h3></a>
<hr>
<h4>Resource Paths and URLs</h4>
WOApplication and WOComponent include two methods for obtaining the paths and URLs of components and other resources:<br>
<br>
<dl>
<dd>pathForResourceNamed:ofType:
<dd>urlForResourceNamed:ofType:
</dl>
<br>
The first argument is the name of the resource and the second (the "type") is its extension.  For example:<br>
<br>
<tt>    id anImagePath = [otherComponent pathForResource:@"CompanyLogo" ofType:@"gif"];</tt><br>
<br>
<h4>Component Templates</h4>
WOComponent incorporates support for obtaining component templates: object graphs of static and dynamic elements that is associated with a particular component. The method <b>templateWithName:</b>  returns a template cached by the application for a component.  WOComponent also includes the method <b>templateWithHTMLString:declarationString:</b> that, given the contents (as NSStrings) of an ".html" file and a ".wod" file,  creates and returns a template. <br>
<br>
<h4>Localization</h4>
Localization in WebObjects works off an array of languages stored in the WOSession object (using <b>setLanguages:</b>). The order of languages in the array indicates the preferred order. The language names in the array should map to <i>Language</i>.lproj subdirectories of component directories . Thus, if there is a @"French" item in the array, there should be a French.lproj subdirectory.  The ".lproj" directories should contain everything that has localized content: ".html" files, ".wod" files, ".strings" tables, and images. Currently, you must manually create ".lproj" subdirectories.<br>
<br>
The ".strings" file contains a simple property list mapping common keys to words, phrases, or sentences in a particular language. For instance, a Main.strings file in English.lproj might have the following content:<br>
<br>
<pre>{
    buttonTitle = "Submit your request";
}
</pre><br>
The Main.strings file in French.lproj would have the following:<br>
<br>
<pre>{
    buttonTitle = "Soumettez votre requete";
}
</pre><br>
To access a localized string from a string table, use the <b>stringForKey:inTableNamed:withDefaultValue: </b>method.  (The last argument allows you to substitute a default value in case there is no value for a particular key.)  The application first looks for resources in non-localized, then in localized ".lproj" directories, so be sure you don't have duplicate files in non-localized locations when localization is supposed to occur.<br>
<br>
<b>Note</b>: You can determine the language of the request sender by getting the value of the WORequest object's "accept-language" header.  This returns a two-character value ("en", "fr", and so on) that you can then map to the language subdirectory.<br>
<br>
<br>
<a name="Reuse"><h3>Better Support for Reusable Components</h3></a>
<hr>
The mechanism whereby a reusable component invokes a method in its parent component has been improved and simplified.  These changes obsolete the WOAction class and the WebScript <b>action</b> keyword.<br>
<br>
For Release 3.0, a child component can invoke its parent's action method by using the <b>performParentAction:</b> method declared by WOComponent.  For example (see the Component example for the complete code):<br>
 <br>
<b>Parent Component<br></b>
<pre>
&lt;HTML&gt;
&lt;WEBOBJECT NAME = "PALETTE"&gt;&lt;/WEBOBJECT&gt;
&lt;/HTML&gt;
</pre>
<br>
--------------------------------------------------------------
<br>
<pre>PALETTE: Palette {
    selection = number;
    callBack = "displaySelection";
 };
</pre>
<br>
--------------------------------------------------------------
<br>
<pre>- displaySelection  
{
    /* display the selection identified by <b>number</b> */
}
</pre>
<br>
--------------------------------------------------------------
<br>
<b>Child Component</b><br>
<pre>- click             /* this is the child's action */
{
    selection = /* some value */;
    /* now invoke the parent's action */
    return [self performParentAction: callBack];
}
</pre>
 <br>
 <br>
<br>
<a name="Porting"><h3>Porting to WebObjects 3.0: A Checklist</h3></a>
<hr>
The following checklist serves as a guide to the major porting tasks you must complete when you're converting WebObjects 2.0 applications to WebObjects 3.0. <br>
<br>
<h4>Application Extension</h4>

Add the extension ".woa" to the application directory name. For example, "MyCoolApp" would become "MyCoolApp.woa".<br>
<br>
<h4>Initialization</h4>
WebScript now supports <b>init</b> in addition to <b>awake</b> as an initialization method in application, session, and component scripts. You may find it convenient to convert many of your <b>awake</b> methods in your scripts to <b>init</b>. Each <b>init</b> method must have the following structure:<br>
<br>
<ul>
<li>The first message should be an invocation of <b>super</b>'s <b>init</b> method.<br>
<li>The last statement should be" return self".<br>
</ul>
<br>
An example:<br>
<br>
<pre>- init {
    [super init];
    someVar = aValue;
    return self;
}
</pre><br>
References: <a href="#Init">Initialization and Request Handling</a> <br>
<br>
<br>
<h4>Parent-Child Callbacks (action Keyword)</h4>
The WOAction class and WebScript's <b>action</b> keyword are obsolete in 3.0, so you should change the code that uses them. See <a href="#Reuse">Better Support for Reusable Components</a> for an example.<br>
<br>
<br>
<h4>persistent Variables</h4>
In WebObjects 1.0 and 2.0, you could use the <b>persistent</b> keyword in scripts to mark page or component variables whose values you want WebObjects to maintain for the life of a session. WebObjects 3.0 obsoletes WebScript's <b>persistent</b> keyword and provides a simpler system for maintaining component variables. <br>
<br>
In 3.0, as a user navigates from page to page in a WebObjects application, a certain number of previously visited pages are automatically cached on the server.  If the user requests a previously visited page, WebObjects returns the page from its cache instead of creating a new instance of the page. This, in effect, makes all component variables "persistent".  When a session is terminated or times out, its page cache is destroyed.  API is provide to let you control the timeout period for a session and the size of the cache. <br>
<br>
In most cases, the porting procedure is quite simple:<br>
<ol>
<li>Locate each component variable declared with a <b>persistent</b> keyword.
<li>Delete the keyword.
</ol>
In rare cases, you may decide to set the page cache to zero, in which case you'll need to use a different strategy for making component variables persistent.  One approach is to use WOSession's  <b>setObject:ForKey: </b> and  <b>objectForKey: </b> methods to make component variables persistent.  If the variable must be scoped to a particular component (rather than shared by all instances of the component), it can be stored under a key that combines the component name with its elementID (see WOElement.h).<br>
<br>
References: <a href="#StateMgmt">State Management</a> <br>
<br>
<br>
<h4>session Variables</h4>
WebScript no longer supports the <b>session</b> keyword for variables.  Instead, with 3.0, applications use WOSession objects to store variables with session-wide scope and implement behavior that affects an entire session.  In scripted applications, you can declare session variables and define session behavior in the <b>Session.wos </b>script file (at the top directory level).  So the porting procedure in this case is:<br>
<br>
<ol>
<li>Create a <b>Session.wos</b> file if one doesn't exist.
<li>Locate each component variable declared with a <b>session</b> keyword.
<li>Delete the keyword.
<li>Copy the declaration to the <b>Session.wos</b> file.
<li>In <b>Session.wos</b>, initialize these variables (if necessary) in <b>init</b>.
</ol>
<br>
In your component scripts, you can obtain and modify the values of session variables using accessor methods (which are automatically implemented for you) invoked on the session object. You can always obtain this object by sending <b>session</b> to <b>self</b>. You can also use WOSession's <b>objectForKey</b> and <b>setObject:forKey:</b> to store component state in the session object "on the fly."<br>
<br>
References: <a href="#StateMgmt">State Management</a> <br>
<br>
<br>
<h4>Request-Handling Methods</h4>
The request-handling methods of WebObjects 2.0 map directly to their 3.0 counterparts, but with the provision that the contents of some 2.0 methods should go before the invocation of <b>super</b> and some after that invocation. For example, the code in a <b>didPrepareForRequest:inContext:</b> method would go as indicated here:<br>
<br>
<pre>- takeValuesFromRequest:r inContext:c {
    [super takeValueFromRequest:r inContext:c];
    // code goes here
}
</pre><br>
The mappings are: <br>
<br>
<dl>
<dd>willPrepareForRequest:inContext:		--&gt;	takeValuesFromRequest:inContext: (before <b>super</b> invocation)<br>
<dd>didPrepareForRequest:inContext:		--&gt;	takeValuesFromRequest:inContext: (after <b>super</b> invocation)<br>
<dd>willGenerateResponse:inContext:		--&gt;	appendToResponse:inContext: (before <b>super</b> invocation)<br>
<dd>didGenerateResponse:inContext:		--&gt; 	appendToResponse:inContext: (after <b>super</b> invocation)<br>
<br>
</dl>
In addition, WebObjects 3.0 has a new request-handling method, <b>invokeActionForRequest:inContext:</b>. If any of your 2.0 request-handling methods substitutes another page for the requested page (but only after an initial request), that code should go in this method after the invocation of <b>super</b>.<br>
<br>
References: <a href="#Init">Initialization and Request Handling</a><br>
<br>
</body>
</html> 
