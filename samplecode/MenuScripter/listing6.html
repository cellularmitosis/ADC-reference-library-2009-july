<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MenuScripter - /Sources/MSAccessors.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MenuScripter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MenuScripter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/MSAccessors.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Resources/MenuScripterAETE.r</option>
<option value="listing2.html">/Sources/DebugUtils.c</option>
<option value="listing3.html">/Sources/DebugUtils.h</option>
<option value="listing4.html">/Sources/MenuScripter.r</option>
<option value="listing5.html">/Sources/MenuScripterPPC.r</option>
<option value="listing6.html">/Sources/MSAccessors.c</option>
<option value="listing7.html">/Sources/MSAccessors.h</option>
<option value="listing8.html">/Sources/MSAEClone.c</option>
<option value="listing9.html">/Sources/MSAEClone.h</option>
<option value="listing10.html">/Sources/MSAEClose.c</option>
<option value="listing11.html">/Sources/MSAEClose.h</option>
<option value="listing12.html">/Sources/MSAECoercions.c</option>
<option value="listing13.html">/Sources/MSAECoercions.h</option>
<option value="listing14.html">/Sources/MSAECompare.c</option>
<option value="listing15.html">/Sources/MSAECompare.h</option>
<option value="listing16.html">/Sources/MSAECopy.c</option>
<option value="listing17.html">/Sources/MSAECopy.h</option>
<option value="listing18.html">/Sources/MSAECountElements.c</option>
<option value="listing19.html">/Sources/MSAECountElements.h</option>
<option value="listing20.html">/Sources/MSAECreate.c</option>
<option value="listing21.html">/Sources/MSAECreate.h</option>
<option value="listing22.html">/Sources/MSAECut.c</option>
<option value="listing23.html">/Sources/MSAECut.h</option>
<option value="listing24.html">/Sources/MSAEDelete.c</option>
<option value="listing25.html">/Sources/MSAEDelete.h</option>
<option value="listing26.html">/Sources/MSAEGetData.c</option>
<option value="listing27.html">/Sources/MSAEGetData.h</option>
<option value="listing28.html">/Sources/MSAEGetDataSize.c</option>
<option value="listing29.html">/Sources/MSAEGetDataSize.h</option>
<option value="listing30.html">/Sources/MSAEMenuUtils.c</option>
<option value="listing31.html">/Sources/MSAEMenuUtils.h</option>
<option value="listing32.html">/Sources/MSAEMove.c</option>
<option value="listing33.html">/Sources/MSAEMove.h</option>
<option value="listing34.html">/Sources/MSAEObjectsExist.c</option>
<option value="listing35.html">/Sources/MSAEObjectsExist.h</option>
<option value="listing36.html">/Sources/MSAEPaste.c</option>
<option value="listing37.html">/Sources/MSAEPaste.h</option>
<option value="listing38.html">/Sources/MSAERecording.c</option>
<option value="listing39.html">/Sources/MSAERecording.h</option>
<option value="listing40.html">/Sources/MSAERevert.c</option>
<option value="listing41.html">/Sources/MSAERevert.h</option>
<option value="listing42.html">/Sources/MSAESave.c</option>
<option value="listing43.html">/Sources/MSAESave.h</option>
<option value="listing44.html">/Sources/MSAESelect.c</option>
<option value="listing45.html">/Sources/MSAESelect.h</option>
<option value="listing46.html">/Sources/MSAESetData.c</option>
<option value="listing47.html">/Sources/MSAESetData.h</option>
<option value="listing48.html">/Sources/MSAETextUtils.c</option>
<option value="listing49.html">/Sources/MSAETextUtils.h</option>
<option value="listing50.html">/Sources/MSAEUtils.c</option>
<option value="listing51.html">/Sources/MSAEUtils.h</option>
<option value="listing52.html">/Sources/MSAEWindowUtils.c</option>
<option value="listing53.html">/Sources/MSAEWindowUtils.h</option>
<option value="listing54.html">/Sources/MSAppleEvents.c</option>
<option value="listing55.html">/Sources/MSAppleEvents.h</option>
<option value="listing56.html">/Sources/MSASSubroutines.c</option>
<option value="listing57.html">/Sources/MSASSubroutines.h</option>
<option value="listing58.html">/Sources/MSDrag.c</option>
<option value="listing59.html">/Sources/MSDrag.h</option>
<option value="listing60.html">/Sources/MSFile.c</option>
<option value="listing61.html">/Sources/MSFile.h</option>
<option value="listing62.html">/Sources/MSGlobals.c</option>
<option value="listing63.html">/Sources/MSGlobals.h</option>
<option value="listing64.html">/Sources/MSGXPrinting.c</option>
<option value="listing65.html">/Sources/MSGXPrinting.h</option>
<option value="listing66.html">/Sources/MSMain.c</option>
<option value="listing67.html">/Sources/MSMain.h</option>
<option value="listing68.html">/Sources/MSResultWind.c</option>
<option value="listing69.html">/Sources/MSResultWind.h</option>
<option value="listing70.html">/Sources/MSScript.c</option>
<option value="listing71.html">/Sources/MSScript.h</option>
<option value="listing72.html">/Sources/MSToken.h</option>
<option value="listing73.html">/Sources/MSUtils.c</option>
<option value="listing74.html">/Sources/MSUtils.h</option>
<option value="listing75.html">/Sources/MSWindow.c</option>
<option value="listing76.html">/Sources/MSWindow.h</option>
<option value="listing77.html">/Sources/Offscreen.c</option>
<option value="listing78.html">/Sources/Offscreen.h</option>
<option value="listing79.html">/Sources/PLStrs.c</option>
<option value="listing80.html">/Sources/PLStrs.h</option></select>
				</p>
				</form>
				<p><strong><a href="MenuScripter.zip">Download Sample</a></strong> (&#147;MenuScripter.zip&#148;, 288.0K)<BR>
<strong><a href="MenuScripter.dmg">Download Sample</a></strong> (&#147;MenuScripter.dmg&#148;, 355.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">// MSAEAccessors.c//// Original version by Jon Lansdell and Nigel Humphreys.// 4.0 and 3.1 updates by Greg Sutton.// &copy;Apple Computer Inc 1996, all rights reserved./*  Changes for 3.1  14-Nov-95 : GS : Removed reliance on compiler setting local variable to zero            in WindowFormAbsolutePosition() and TextFormAbsolutePosition().  Changes for 4.0  29-Feb-96 : GS : Added differentiation between windows and documents.  29-Feb-96 : GS : Added resolution of menus and menu items.*/#include &quot;MSAccessors.h&quot;#include &lt;Menus.h&gt;#ifdef THINK_C  #include &quot;PLStrs.h&quot;#else  #include &lt;PLStringFuncs.h&gt;#endif#include &lt;Scrap.h&gt;#include &lt;TextEdit.h&gt;#include &lt;AEObjects.h&gt;#include &lt;AEPackObject.h&gt;#include &lt;AERegistry.h&gt;#include &quot;MSGlobals.h&quot;#include &quot;MSUtils.h&quot;#include &quot;MSAEUtils.h&quot;#include &quot;MSWindow.h&quot;#include &quot;MSFile.h&quot;#include &quot;MSAppleEvents.h&quot;#include &quot;MSToken.h&quot;#include &quot;MSAETextUtils.h&quot;#include &quot;MSAEWindowUtils.h&quot;#include &quot;MSAEMenuUtils.h&quot;#pragma segment AppleEvent// Install accessors that are used when AEResolve is called to convert// object specifiers into internal representations (tokens).OSErr  InstallAccessors(void){  OSErr  err;  err = AEInstallObjectAccessor(cApplication, typeNull,      NewOSLAccessorProc(ApplicationFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cWindow,      typeNull,      NewOSLAccessorProc(WindowFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cDocument,    typeNull,      NewOSLAccessorProc(DocumentFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,    typeNull,       NewOSLAccessorProc(PropertyFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cMenu,      typeNull,       NewOSLAccessorProc(MenuFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cWindow,      typeMyAppl,      NewOSLAccessorProc(WindowFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cDocument,    typeMyAppl,      NewOSLAccessorProc(DocumentFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,    typeMyAppl,     NewOSLAccessorProc(PropertyFromApplAccessor), 0, false);  err = AEInstallObjectAccessor(cMenu,      typeMyAppl,     NewOSLAccessorProc(MenuFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,  typeMyWndw,      NewOSLAccessorProc(PropertyFromWndwAccessor), 0, false);      // Handle text from a window      // e.g. some character of last document  err = AEInstallObjectAccessor(cInsertionPoint,typeMyDocument,  NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cChar,    typeMyDocument,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cText,     typeMyDocument,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cWord,    typeMyDocument,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cParagraph,  typeMyDocument,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,  typeMyDocument,    NewOSLAccessorProc(PropertyFromDocumentAccessor), 0, false);      // Handle text items within text items      // e.g. last word of first paragraph of front document  err = AEInstallObjectAccessor(cInsertionPoint,typeMyText,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cChar,    typeMyText,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cText,     typeMyText,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cWord,    typeMyText,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cParagraph,  typeMyText,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,  typeMyText,      NewOSLAccessorProc(PropertyFromTextAccessor), 0, false);      // Menus  err = AEInstallObjectAccessor(cMenuItem,    typeMyMenu,     NewOSLAccessorProc(MenuItemFromMenuAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,    typeMyMenu,     NewOSLAccessorProc(PropertyFromMenuAccessor), 0, false);      // Menu Items  err = AEInstallObjectAccessor(cProperty,    typeMyMenuItem,   NewOSLAccessorProc(PropertyFromMenuItemAccessor), 0, false);      // Handle text items from lists (of hopefully text items) also      //  e.g. every word of every paragraph of front document      //  or even - every word of every character of every paragraph of front document  err = AEInstallObjectAccessor(cInsertionPoint,typeAEList,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cChar,     typeAEList,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cText,     typeAEList,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cWord,    typeAEList,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cParagraph,  typeAEList,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,    typeAEList,     NewOSLAccessorProc(PropertyFromListAccessor), 0, false);      // This is for 'select insertion point before contents of document 1'  err = AEInstallObjectAccessor(cInsertionPoint,   typeMyWindowProp,  NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);      // This accessor is for getting properties of window properties      //  e.g. font of contents of document 1      // Relies on ability to coerce from a window property to text      //  for certain properties.  err = AEInstallObjectAccessor(cProperty,   typeMyDocumentProp,  NewOSLAccessorProc(PropertyFromTextAccessor), 0, false);  return(err);}// Given selectionData of formAbsolutePosition for a window this routine returns//  a WindowToken descriptor for specified window.//// e.g.  tell application &quot;MenuScripter&quot;//      window 1//      --first document//      --some window//      --every window//    end tellOSErr  WindowFormAbsolutePosition(const AEDesc  *selectionData, AEDesc* result){  AEDesc  itemDesc = {typeNull, NULL};  short  windowCount,      index;  OSErr  err;  windowCount = CountWindows();    if (! windowCount)    return(errAEIllegalIndex);    if (typeAbsoluteOrdinal == selectionData-&gt;descriptorType)  {    err = noErr;      switch (*(DescType *)*selectionData-&gt;dataHandle)    {      case kAEFirst:        index = 1;        break;        case kAELast:        index = windowCount;        break;        case kAEMiddle:        index = (windowCount + 1) / 2;        break;        case kAEAny:        index = (Random() % windowCount) + 1;        break;        case kAEAll:        err = AECreateList(NULL, 0 , false, result);        if (noErr != err) goto done;                for (index = 1; index &lt;= windowCount; index++)        {          err = GetDescOfNthWindow(index, &amp;itemDesc);          if (noErr != err) goto done;                    err = AEPutDesc(result, 0, &amp;itemDesc);          if (noErr != err) goto done;                    if (itemDesc.dataHandle)            AEDisposeDesc(&amp;itemDesc);        }                goto done;    // We have created our list descriptor        break;      // so we can just tidy up and return.              default:        err = errAETypeError;    }  }  else    err = GetIntegerFromDescriptor(selectionData, &amp;index);  if (noErr != err) goto done;    if (index &lt; 0)    // Handle negative indexes    index = windowCount + index + 1;      if (index &gt; windowCount || index &lt;= 0)    err = errAEIllegalIndex;  else    err = GetDescOfNthWindow(index, result);done:    if (itemDesc.dataHandle)    AEDisposeDesc(&amp;itemDesc);  return(err);} // WindowFormAbsolutePosition// Given a formName descriptor in selectionData, this routine returns a// WindowToken descriptor for the window with that name.//// e.g.  tell application &quot;MenuScripter&quot;//      document &quot;Untitled&quot;//    end tellOSErr  WindowFormName(const AEDesc  *selectionData, AEDesc* result){  Str255    name;  OSErr    err;          // This tries to coerce it first  err = GetPStringFromDescriptor(selectionData, name);  if (noErr != err) goto done;  err = GetDescOfNamedWindow(name, result);done:  return(err);}// Get a WindowToken descriptor for a window or document object specifier// from NULL (or the application). Only handles formAbsolutePosition and formName//// e.g.  tell application &quot;MenuScripter&quot;//      window 1//      --first document//      --document &quot;Untitled&quot;//      --every window//    end tellpascal OSErr  WindowFromNullAccessor(DescType      wantClass,                    const AEDesc  *container,                    DescType      containerClass,                    DescType    form,                     const AEDesc  *selectionData,                    AEDesc      *value,                    long      theRefCon){#ifdef __MWERKS__  #pragma unused(container,theRefCon)#endif  OSErr       err;      // Can only handle cWindow and cDocument  if ( wantClass != cWindow )    return errAEWrongDataType;        // Can only handle typeNull and typeMyAppl  if ( containerClass != typeNull &amp;&amp; containerClass != typeMyAppl )    return errAENoSuchObject;    switch (form)  {    case formAbsolutePosition:      err = WindowFormAbsolutePosition(selectionData, value);      break;          case formName:      err = WindowFormName(selectionData, value);      break;          default:      err = errAEBadTestKey;  }        return err;} // WindowFromNullAccessorOSErr  DocumentFormAbsolutePosition(const AEDesc  *selectionData, AEDesc* result){  AEDesc  itemDesc = {typeNull, NULL};  short  aCount,      index;  OSErr  err;  aCount = CountDocuments();    if ( ! aCount )    return(errAEIllegalIndex);    if ( typeAbsoluteOrdinal == selectionData-&gt;descriptorType )  {    err = noErr;      switch (*(DescType *)*selectionData-&gt;dataHandle)    {      case kAEFirst:        index = 1;        break;        case kAELast:        index = aCount;        break;        case kAEMiddle:        index = ( aCount + 1 ) / 2;        break;        case kAEAny:        index = ( Random() % aCount ) + 1;        break;        case kAEAll:        err = AECreateList( NULL, 0 , false, result );        if (noErr != err) goto done;                for ( index = 1; index &lt;= aCount; index++ )        {          err = GetDescOfNthDocument( index, &amp;itemDesc );          if (noErr != err) goto done;                    err = AEPutDesc( result, 0, &amp;itemDesc );          if (noErr != err) goto done;                    (void)AEDisposeDesc( &amp;itemDesc );        }                goto done;    // We have created our list descriptor        break;      // so we can just tidy up and return.              default:        err = errAETypeError;    }  }  else    err = GetIntegerFromDescriptor(selectionData, &amp;index);  if (noErr != err) goto done;    if (index &lt; 0)    // Handle negative indexes    index = aCount + index + 1;      if (index &gt; aCount || index &lt;= 0)    err = errAEIllegalIndex;  else    err = GetDescOfNthDocument(index, result);done:    (void)AEDisposeDesc(&amp;itemDesc);  return(err);} // DocumentFormAbsolutePositionOSErr  DocumentFormName(const AEDesc *selectionData, AEDesc* result){  Str255    name;  OSErr    err;        // This tries to coerce it first  err = GetPStringFromDescriptor(selectionData, name);  if (noErr != err) goto done;  err = GetDescOfNamedDocument(name, result);done:  return(err);}pascal OSErr  DocumentFromNullAccessor(DescType      wantClass,                      const AEDesc  *container,                      DescType      containerClass,                      DescType    form,                       const AEDesc  *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused (container,theRefCon)#endif  OSErr       err;      // Can only handle cWindow and cDocument  if ( wantClass != cDocument )    return errAEWrongDataType;        // Can only handle typeNull and typeMyAppl  if ( containerClass != typeNull &amp;&amp; containerClass != typeMyAppl )    return errAENoSuchObject;    switch (form)  {    case formAbsolutePosition:      err = DocumentFormAbsolutePosition( selectionData, value );      break;          case formName:      err = DocumentFormName( selectionData, value );      break;          default:      err = errAEBadTestKey;  }        return err;} // DocumentFromNullAccessorpascal OSErr   ApplicationFromNullAccessor(DescType    wantClass,                      const AEDesc  *container,                      DescType    containerClass,                      DescType    form,                       const AEDesc  *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused(container,selectionData,theRefCon)#endif  OSErr    myErr;  AppToken theApp;  AEDesc   resultDesc;    value-&gt;dataHandle     = nil;  resultDesc.dataHandle = nil;    /*     should only be called with wantClass = cWindow and    with containerClass = typeNull.    Currently accept as either formName or formAbsolutePosition  */    if ((wantClass != cApplication) || (containerClass != typeNull) ||      !((form == formName) || (form == formAbsolutePosition)))    return(errAEWrongDataType);    if ((form == formName) || (form == formAbsolutePosition))  {    theApp.highLongOfPSN = 0;    theApp.lowLongOfPSN  = kCurrentProcess;  }      myErr = AECreateDesc(typeMyAppl, (Ptr)&amp;theApp, sizeof(theApp), value);        return(myErr);}  /* ApplicationFromNullAccessor */// Given a formAbsolutePosition selectionData descriptor and a TextToken from// which to index from. This routine returns a TextToken descriptor for the// text specified.//// e.g.  tell application &quot;MenuScripter&quot;//      first word of window 1  -- window one will be dealt with in//                  -- WindowFromNullAccessor().//      --some character of middle paragraph of last document//                  -- container token will be a paragraph//    end tellOSErr  TextFormAbsolutePosition(TextToken* containerToken, AEDesc* selectionData,                          DescType wantClass, AEDesc* result){  DPtr    docPtr;  short    elementCount;  AEDesc    aDesc = {typeNull, NULL};  long    index;  OSErr    err;    docPtr = DPtrFromWindowPtr(containerToken-&gt;tokenWindow);  if (! docPtr)  {    err = errAENoSuchObject;    goto done;  }  err = CountTextElements(docPtr-&gt;theText, containerToken-&gt;tokenOffset,                containerToken-&gt;tokenLength, wantClass, &amp;elementCount);  if (noErr != err) goto done;  if (typeAbsoluteOrdinal == selectionData-&gt;descriptorType)  {    err = noErr;      switch (*(DescType *)*selectionData-&gt;dataHandle)    {      case kAEFirst:        index = 1;        break;        case kAELast:        index = elementCount;        break;        case kAEMiddle:        index = (elementCount + 1) / 2;        break;        case kAEAny:        index = (Random() % elementCount) + 1;        break;        case kAEAll:        err = AECreateList(NULL, 0 , false, result);                for (index = 1; index &lt;= elementCount; index++)        {          if (noErr == (err = GetDescOfNthTextElement(index, wantClass,                                containerToken, &amp;aDesc)))          {            err = AEPutDesc(result, 0, &amp;aDesc);            AEDisposeDesc(&amp;aDesc);          }        }        goto done;    // Created our result - clean up and return        break;        default:        err = errAETypeError;    }  }  else    // Try and get an index out of the descriptor    err = GetLongIntFromDescriptor(selectionData, &amp;index);    if (noErr != err) goto done;          // kAEAll has already created it's list  err = GetDescOfNthTextElement(index, wantClass,      // Checks for negatives and                containerToken, result);  // out of range.                    done:  if (aDesc.dataHandle)    AEDisposeDesc(&amp;aDesc);  return(err);}// Given a TextToken container and a formRange descriptor. This routine// creates a TextToken descriptor starting at the the beginning of the// first item in the range and ending at the end of the last item in the range.//// e.g.  tell application &quot;MenuScripter&quot;//      paragraphs 2 thru 3 of document 1//    end tellOSErr  TextFormRange(TextToken* containerToken, AEDesc* selectionData,                          DescType wantClass, AEDesc* result){#ifdef __MWERKS__  #pragma unused(wantClass)#endif  AEDesc    selectionRecord = {typeNull, NULL};  TextToken  startToken,        stopToken;  DescType  returnedType;  Size    actualSize;  OSErr    err;    // coerce the selection data into an AERecord  err = AECoerceDesc(selectionData, typeAERecord, &amp;selectionRecord);  if (noErr != err) goto done;      // get the start object as a text token this will reenter    // TextElemFromTextAccessor() but as formAbsolutePosition via     // our installed coercion handler CoerceObjToAnything()    // because the keyAERangeStart parameter is actually an object specifier.  err = AEGetKeyPtr(&amp;selectionRecord, keyAERangeStart, typeMyText,              &amp;returnedType, (Ptr)&amp;startToken, sizeof(startToken), &amp;actualSize);  if (noErr != err) goto done;      // now do the same for the stop object  err = AEGetKeyPtr(&amp;selectionRecord, keyAERangeStop, typeMyText,              &amp;returnedType, (Ptr)&amp;stopToken, sizeof(stopToken), &amp;actualSize);  if (noErr != err) goto done;    if (containerToken-&gt;tokenWindow != startToken.tokenWindow      || containerToken-&gt;tokenWindow != stopToken.tokenWindow)  {    err = errAECorruptData;    // or whatever    goto done;  }        // Use startToken to create result descriptor  startToken.tokenLength = stopToken.tokenOffset + stopToken.tokenLength - startToken.tokenOffset;                               err = AECreateDesc(typeMyText, (Ptr)&amp;startToken, sizeof(startToken), result);done:  if (selectionRecord.dataHandle)    AEDisposeDesc(&amp;selectionRecord);  return(err);}// Given a container TextToken and a formRelativePosition selectionData descriptor// this routine returns a TextToken descriptor to the reative wantClass object// specified.// This routine currently only handles relative positions for a wantClass// of cInsertionPoint.//// e.g.  tell application &quot;MenuScripter&quot;//      insertion point after word 5 of document 1//    end tellOSErr  TextFormRelativePosition(TextToken* containerToken, AEDesc* selectionData,                          DescType wantClass, AEDesc* result){  TextToken  aTextToken;  DescType   aPosition;  OSErr    err;    aTextToken.tokenWindow = containerToken-&gt;tokenWindow;  switch (wantClass)  {    case cInsertionPoint:      err = GetEnumeratedFromDescriptor(selectionData, &amp;aPosition);            switch (aPosition)      {        case kAEPrevious:        case kAEBefore:        case kAEBeginning:          // No change to offset - just 0 length now          // containerToken.tokenOffset = containerToken.tokenOffset;          aTextToken.tokenOffset = containerToken-&gt;tokenOffset;          aTextToken.tokenLength = 0;          break;              case kAENext:        case kAEAfter:        case kAEEnd:          aTextToken.tokenOffset = containerToken-&gt;tokenOffset + containerToken-&gt;tokenLength;          aTextToken.tokenLength = 0;          break;                  default:          err = errAEIllegalIndex;      }      break;          default:      err = errAEWrongDataType;  // Could do cChar, cWord\xC9 but this is only a sample  }    if (noErr != err) goto done;  err = AECreateDesc(typeMyText, (Ptr)&amp;aTextToken, sizeof(aTextToken), result);done:  return(err);}// Tries to create a TextToken descriptor given a container which may// be a TextToken descriptor or a WindowToken descriptor. A// selectionData descriptor which can be of formAbsolutePosition,// formRange or formRelativePosition, and a wantClass which should// be cInsertionPoint, cChar, cText, cWord or cParagraph.//// e.g.  tell application &quot;MenuScripter&quot;//      first word of document 1 -- document 1 will go through WindowFromNullAccessor()//                   -- which will return a WindowToken descriptor. This//                   -- descriptor will then be coerced to a TextToken//                   -- descriptor and used as the container.//    end tellpascal OSErr  TextElemFromTextAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                      AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused(containerClass)#endif  TextToken   containerToken;  long        index;  long    itemCount;  AEDesc    aDesc = {typeNull, NULL},        resultDesc = {typeNull, NULL};  DescType  returnedType;  Size    actualSize;  OSErr       myErr;          // If it's a list then we need to call this accessor for every        // item within the list (which could of course be more lists).  if (typeAEList == container-&gt;descriptorType)  {    myErr = AECreateList(NULL, 0 , false, value);  // Result will also be a list of items    if (noErr != myErr) goto done;    myErr = AECountItems(container, &amp;itemCount);    if (noErr != myErr) goto done;    for (index = 1; index &lt;= itemCount; index++)  // Do in forward order    {      myErr = AEGetNthDesc(container, index, typeWildCard, &amp;returnedType, &amp;aDesc);      if (noErr == myErr)    // Call this function recursively if necessary        myErr = TextElemFromTextAccessor(wantClass, &amp;aDesc, returnedType,                      form, selectionData, &amp;resultDesc, theRefCon);            if (noErr == myErr)    // Add item to the end of our list        myErr = AEPutDesc(value, 0, &amp;resultDesc);            if (aDesc.dataHandle)        AEDisposeDesc(&amp;aDesc);      if (resultDesc.dataHandle)        AEDisposeDesc(&amp;resultDesc);    }  }  else  {        // We have a coercion handler from document to text    myErr = AECoerceDesc(container, typeMyText, &amp;aDesc);    if (noErr != myErr) goto done;        // Get the containing TextToken    GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;containerToken, sizeof(containerToken), &amp;actualSize);        switch (form)    {      case formAbsolutePosition:        myErr = TextFormAbsolutePosition(&amp;containerToken, selectionData,                                  wantClass, value);        break;                                  case formRange:        myErr = TextFormRange(&amp;containerToken, selectionData,                              wantClass, value);        break;              case formRelativePosition:        myErr = TextFormRelativePosition(&amp;containerToken, selectionData,                                wantClass, value);        break;              default:        myErr = errAEBadKeyForm;    }  }done:  if (aDesc.dataHandle)    AEDisposeDesc(&amp;aDesc);      return(myErr);}  // TextElemFromTextAccessor// Given a TextToken descriptor as a container convert this into // a TextPropToken descriptor for the property.pascal OSErr  PropertyFromTextAccessor(DescType      wantClass,                      const AEDesc  *container,                      DescType    containerClass,                      DescType    form,                       const AEDesc  *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused (theRefCon, containerClass)#endif  AEDesc      textDesc = {typeNull, NULL},          propertyDesc = {typeNull, NULL};  Size      actualSize;  TextToken    aTextToken;  TextPropToken  aTextPropToken;  DescType    aProperty;  OSErr      err;    if (cProperty != wantClass || formPropertyID != form)    return(errAEWrongDataType);            // Try and coerce to a TextToken descriptor  err = AECoerceDesc(container, typeMyText, &amp;textDesc);  if (noErr != err) goto done;          // Get the TextToken  GetRawDataFromDescriptor(&amp;textDesc, (Ptr)&amp;aTextToken,              sizeof(aTextToken), &amp;actualSize);              // Make sure the selection data is typeType  err = AECoerceDesc(selectionData, typeType, &amp;propertyDesc);  if (noErr != err) goto done;        // Get the property  GetRawDataFromDescriptor(&amp;propertyDesc, (Ptr)&amp;aProperty,                  sizeof(aProperty),  &amp;actualSize);              //  Combine the two into single token  aTextPropToken.tokenTextToken = aTextToken;  aTextPropToken.tokenProperty  = aProperty;    err = AECreateDesc(typeMyTextProp, (Ptr)&amp;aTextPropToken,                sizeof(aTextPropToken), value);done:      (void)AEDisposeDesc(&amp;textDesc);  (void)AEDisposeDesc(&amp;propertyDesc);      return(err);} // PropertyFromTextAccessor// Given a WindowToken descriptor as a container convert this into // a WindowPropToken descriptor for the property.pascal OSErr  PropertyFromWndwAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                       AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused(containerClass)#endif  long        itemCount,            index;  AEDesc        resultDesc = {typeNull, NULL},            windowDesc = {typeNull, NULL},            propDesc = {typeNull, NULL};  Size              actualSize;  DescType          returnedType;  WindowToken       theWindowToken;  WindowPropToken   myWindowProp;  OSErr             err;    if (typeAEList == container-&gt;descriptorType)  {    err = AECreateList(NULL, 0 , false, value);    // Result will also be a list of items    if (noErr != err) goto done;    err = AECountItems(container, &amp;itemCount);    if (noErr != err) goto done;      for (index = 1; index &lt;= itemCount; index++)  // Do in forward order    {      err = AEGetNthDesc(container, index, typeWildCard, &amp;returnedType, &amp;windowDesc);        if (noErr == err)              // Recursively call this routine                            // - could be another list.        err = PropertyFromWndwAccessor(wantClass, &amp;windowDesc, windowDesc.descriptorType,                            form, selectionData, &amp;resultDesc, theRefCon);            if (noErr == err)              // Add item to the end of our list        err = AEPutDesc(value, 0, &amp;resultDesc);            if (windowDesc.dataHandle)        AEDisposeDesc(&amp;windowDesc);      if (resultDesc.dataHandle)        AEDisposeDesc(&amp;resultDesc);    }  }  else  {    // get the window token - it's the container        err = AECoerceDesc(container, typeMyWndw, &amp;windowDesc);    GetRawDataFromDescriptor(&amp;windowDesc, (Ptr)&amp;theWindowToken,                    sizeof(theWindowToken), &amp;actualSize);                                    // Check the window exists        if (theWindowToken.tokenWindow == NULL)      err = errAEIllegalIndex;    else    {    // get the property - it's in the selection data            err = AECoerceDesc(selectionData, typeType, &amp;propDesc);      GetRawDataFromDescriptor(&amp;propDesc, (Ptr)&amp;returnedType,                      sizeof(returnedType), &amp;actualSize);              // Combine the two into single token      myWindowProp.tokenWindowToken = theWindowToken;      myWindowProp.tokenProperty    = returnedType;            err = AECreateDesc(typeMyWindowProp, (Ptr)&amp;myWindowProp,                        sizeof(myWindowProp), value);    }  }  done:  if (windowDesc.dataHandle)    AEDisposeDesc(&amp;windowDesc);  if (propDesc.dataHandle)    AEDisposeDesc(&amp;propDesc);  if (resultDesc.dataHandle)    AEDisposeDesc(&amp;resultDesc);      return(err);} // PropertyFromWndwAccessorpascal OSErr  PropertyFromDocumentAccessor(DescType      wantClass,                        AEDesc      *container,                        DescType    containerClass,                        DescType    form,                         AEDesc      *selectionData,                        AEDesc      *value,                        long      theRefCon){#ifdef __MWERKS__  #pragma unused(containerClass)#endif  long        itemCount,            index;  AEDesc        resultDesc = {typeNull, NULL},            windowDesc = {typeNull, NULL},            propDesc = {typeNull, NULL};  Size              actualSize;  DescType          returnedType;  WindowToken       theWindowToken;  WindowPropToken   myWindowProp;  OSErr             err;    if (typeAEList == container-&gt;descriptorType)  {    err = AECreateList(NULL, 0 , false, value);    // Result will also be a list of items    if (noErr != err) goto done;    err = AECountItems(container, &amp;itemCount);    if (noErr != err) goto done;      for (index = 1; index &lt;= itemCount; index++)  // Do in forward order    {      err = AEGetNthDesc(container, index, typeWildCard, &amp;returnedType, &amp;windowDesc);        if (noErr == err)              // Recursively call this routine                            // - could be another list.        err = PropertyFromDocumentAccessor(wantClass, &amp;windowDesc, windowDesc.descriptorType,                            form, selectionData, &amp;resultDesc, theRefCon);            if (noErr == err)              // Add item to the end of our list        err = AEPutDesc(value, 0, &amp;resultDesc);            (void)AEDisposeDesc(&amp;windowDesc);      (void)AEDisposeDesc(&amp;resultDesc);    }  }  else  {    // get the window token - it's the container        err = AECoerceDesc(container, typeMyDocument, &amp;windowDesc);    GetRawDataFromDescriptor(&amp;windowDesc, (Ptr)&amp;theWindowToken,                    sizeof(theWindowToken), &amp;actualSize);                                    // Check the window exists        if (theWindowToken.tokenWindow == NULL)      err = errAEIllegalIndex;    else    {    // get the property - it's in the selection data            err = AECoerceDesc(selectionData, typeType, &amp;propDesc);      GetRawDataFromDescriptor(&amp;propDesc, (Ptr)&amp;returnedType,                      sizeof(returnedType), &amp;actualSize);              // Combine the two into single token      myWindowProp.tokenWindowToken = theWindowToken;      myWindowProp.tokenProperty    = returnedType;            err = AECreateDesc(typeMyDocumentProp, (Ptr)&amp;myWindowProp,                        sizeof(myWindowProp), value);    }  }  done:  (void)AEDisposeDesc(&amp;windowDesc);  (void)AEDisposeDesc(&amp;propDesc);  (void)AEDisposeDesc(&amp;resultDesc);      return(err);} // PropertyFromDocumentAccessorpascal OSErr  PropertyFromNullAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                       AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused (container, containerClass)#endif  AEDesc    aDesc = {typeNull, NULL};  OSErr    err;  if ((wantClass != cProperty) || (form != formPropertyID))    return(errAEWrongDataType);  switch (*(DescType *)*selectionData-&gt;dataHandle)  {    case pSelection:  // The selection defaults to the front window              // selection.      err = GetDescOfNthDocument( 1, &amp;aDesc );  // Disposed of at end      if (noErr != err) goto done;      err = PropertyFromDocumentAccessor(wantClass, &amp;aDesc, typeMyDocument, form,                           selectionData, value, theRefCon);      break;          default:      // Otherwise try an application property - it is fron NULL      err = PropertyFromApplAccessor(wantClass, &amp;aDesc, typeMyWndw, form,                           selectionData, value, theRefCon);  }  done:  (void)AEDisposeDesc( &amp;aDesc );    return err;}// Convert a list of Token descriptors to a list of Property Token descriptors.// Only TextTokens and WindowTokens are supported in this version.OSErr  TokenListToPropertyList(AEDesc* tokenList, DescType aProperty, AEDesc* result){  AEDesc        aDesc = {typeNull, NULL},            resultDesc = {typeNull, NULL};  DescType      returnedType;  long        itemCount,            index;  WindowPropToken    aWindowPropToken;  TextPropToken    aTextPropToken;  Size        actualSize;  OSErr        err;  err = AECreateList(NULL, 0 , false, result);    // Result will also be a list of items  if (noErr != err) goto done;  err = AECountItems(tokenList, &amp;itemCount);    // Will return an error if not of type typeAEList  if (noErr != err) goto done;  for (index = 1; index &lt;= itemCount; index++)  // Do in forward order  {    err = AEGetNthDesc(tokenList, index, typeWildCard, &amp;returnedType, &amp;aDesc);    if (noErr == err)              // Create appropriate property token      switch (aDesc.descriptorType)      {        case typeMyWndw:          GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;aWindowPropToken,                          sizeof(WindowToken), &amp;actualSize);          aWindowPropToken.tokenProperty = aProperty;          err = AECreateDesc(typeMyWindowProp, (Ptr)&amp;aWindowPropToken,                          sizeof(aWindowPropToken), &amp;resultDesc);          break;                  case typeMyText:          GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;aTextPropToken,                          sizeof(TextToken), &amp;actualSize);          aTextPropToken.tokenProperty = aProperty;          err = AECreateDesc(typeMyTextProp, (Ptr)&amp;aTextPropToken,                          sizeof(aTextPropToken), &amp;resultDesc);          break;                  case typeAEList:          // Recursive call if a list          err = TokenListToPropertyList(&amp;aDesc, aProperty, &amp;resultDesc);          break;                  default:    // May already be a property token          err = errAEBadListItem;      }        if (noErr == err)    // Add item to the end of our list      err = AEPutDesc(result, 0, &amp;resultDesc);        if (aDesc.dataHandle)      AEDisposeDesc(&amp;aDesc);    if (resultDesc.dataHandle)      AEDisposeDesc(&amp;resultDesc);          err = noErr;      // Try and do all the items we can in the list  }      done:  return(err);}// Given a container that is a list of Token descriptors, this routine// returns a list of PropToken descriptors.pascal OSErr  PropertyFromListAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                       AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused(containerClass, theRefCon)#endif  OSErr    err;    if (wantClass != cProperty &amp;&amp; form != formPropertyID)    return(errAEBadKeyForm);    err = TokenListToPropertyList(container, *(DescType *)*selectionData-&gt;dataHandle, value);  return(err);}// Given a AppToken descriptor as a container convert this into // a WindowPropToken descriptor for the property.pascal OSErr  PropertyFromApplAccessor(DescType      wantClass,                      const AEDesc  *container,                      DescType    containerClass,                      DescType    form,                       const AEDesc  *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused (theRefCon, containerClass)#endif  OSErr         myErr;  OSErr         ignoreErr;  AppToken      theApplToken;  DescType      theProperty;  AEDesc        applDesc;  AEDesc        propDesc;  Size          actualSize;  AppPropToken myApplProp;      value-&gt;dataHandle     = nil;  applDesc.dataHandle   = nil;  propDesc.dataHandle   = nil;    if ((wantClass != cProperty) ||      (form != formPropertyID))  {    return(errAEWrongDataType);  }    // get the application token - it's the container    myErr = AECoerceDesc(container, typeMyAppl, &amp;applDesc);  GetRawDataFromDescriptor(&amp;applDesc, (Ptr)&amp;theApplToken,                sizeof(theApplToken), &amp;actualSize);        // get the property - it's in the selection data    myErr = AECoerceDesc(selectionData, typeType, &amp;propDesc);  GetRawDataFromDescriptor(&amp;propDesc, (Ptr)&amp;theProperty,                sizeof(theProperty), &amp;actualSize);  //  Combine the two into single token  myApplProp.tokenAppToken = theApplToken;  myApplProp.tokenProperty = theProperty;    myErr = AECreateDesc(typeMyApplProp, (Ptr)&amp;myApplProp,                    sizeof(myApplProp), value);      if (applDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;applDesc);      if (propDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;propDesc);      return(myErr);} // PropertyFromApplAccessorpascal OSErr  PropertyFromWinPropertyAccessor(DescType    wantClass,                        const AEDesc  *container,                        DescType    containerClass,                        DescType    form,                         const AEDesc  *selectionData,                        AEDesc      *value,                        long      theRefCon){#ifdef __MWERKS__  #pragma unused(wantClass, containerClass, form, theRefCon)#endif  OSErr           myErr;  OSErr           ignoreErr;  WindowPropToken theWindowPropToken;  AEDesc          newDesc, propDesc;  Size            tokenSize;  DPtr            theDocument;  TextToken       theTextToken;  DescType        theProperty;  Size            actualSize;  TextPropToken   myTextProp;    // the container is a window property token. Get the token for this  // and check that it is valid to get a property of this property    myErr = AECoerceDesc(container, typeMyWindowProp, &amp;newDesc);    if (myErr)   return(myErr);  GetRawDataFromDescriptor(&amp;newDesc, (Ptr)&amp;theWindowPropToken,                sizeof(theWindowPropToken), &amp;tokenSize);                             // if the property is pSelection, we then want to convert this to a text token  // and then return a text property token    if (theWindowPropToken.tokenProperty == pSelection)   {    theDocument = DPtrFromWindowPtr(theWindowPropToken.tokenWindowToken.tokenWindow);        // build a text token to represent the selection    theTextToken.tokenOffset = (**(theDocument-&gt;theText)).selStart + 1;    theTextToken.tokenLength = ((**(theDocument-&gt;theText)).selEnd -                               (**(theDocument-&gt;theText)).selStart) -1;    theTextToken.tokenWindow = theWindowPropToken.tokenWindowToken.tokenWindow;          // now get the property- it's in the selection data    myErr = AECoerceDesc(selectionData, typeType, &amp;propDesc);    GetRawDataFromDescriptor(&amp;propDesc, (Ptr)&amp;theProperty,                    sizeof(theProperty), &amp;actualSize);        // Combine the two into single token    myTextProp.tokenTextToken = theTextToken;    myTextProp.tokenProperty  = theProperty;      myErr = AECreateDesc(typeMyTextProp,(Ptr)&amp;myTextProp,                     sizeof(myTextProp),value);                                              if (propDesc.dataHandle) ignoreErr = AEDisposeDesc(&amp;propDesc);    if (newDesc.dataHandle)  ignoreErr = AEDisposeDesc(&amp;newDesc);    return myErr;                                                    }    if (newDesc.dataHandle)     ignoreErr = AEDisposeDesc(&amp;newDesc);    return errAEWrongDataType;}OSErr  MenuFormAbsolutePosition( const AEDesc *selectionData, AEDesc* result ){  AEDesc  itemDesc = {typeNull, NULL};  short  aCount,      index;  OSErr  err;  aCount = CountMenus();    if (! aCount)    return(errAEIllegalIndex);    if ( typeAbsoluteOrdinal == selectionData-&gt;descriptorType )  {    err = noErr;      switch (*(DescType *)*selectionData-&gt;dataHandle)    {      case kAEFirst:        index = 1;        break;        case kAELast:        index = aCount;        break;        case kAEMiddle:        index = (aCount + 1) / 2;        break;        case kAEAny:        index = (Random() % aCount) + 1;        break;        case kAEAll:        err = AECreateList(NULL, 0 , false, result);        if (noErr != err) goto done;                for (index = 1; index &lt;= aCount; index++)        {          err = GetDescOfNthMenu(index, &amp;itemDesc);          if (noErr != err) goto done;                    err = AEPutDesc(result, 0, &amp;itemDesc);          if (noErr != err) goto done;                    if (itemDesc.dataHandle)            AEDisposeDesc(&amp;itemDesc);        }                goto done;    // We have created our list descriptor        break;      // so we can just tidy up and return.              default:        err = errAETypeError;    }  }  else    err = GetIntegerFromDescriptor( selectionData, &amp;index );  if (noErr != err) goto done;    if (index &lt; 0)    // Handle negative indexes    index = aCount + index + 1;      if ( index &gt; aCount || index &lt;= 0 )    err = errAEIllegalIndex;  else    err = GetDescOfNthMenu( index, result );done:    (void)AEDisposeDesc( &amp;itemDesc );  return err;} // MenuFormAbsolutePositionOSErr  MenuFormName( const AEDesc *selectionData, AEDesc* result ){  Str255    name;  OSErr    err;        // This tries to coerce it first  err = GetPStringFromDescriptor( selectionData, name );  if ( noErr != err ) goto done;  err = GetDescOfNamedMenu( name, result );done:  return(err);}pascal OSErr  MenuFromNullAccessor( DescType      wantClass,                    const AEDesc  *container,                    DescType      containerClass,                    DescType    form,                     const AEDesc  *selectionData,                    AEDesc      *value,                    long      theRefCon){#ifdef __MWERKS__  #pragma unused (container,theRefCon)#endif  OSErr       err;      // Can only handle cWindow and cDocument  if ( wantClass != cMenu )    return errAEWrongDataType;        // Can only handle typeNull and typeMyAppl  if ( containerClass != typeNull &amp;&amp; containerClass != typeMyAppl )    return errAENoSuchObject;    switch (form)  {    case formAbsolutePosition:      err = MenuFormAbsolutePosition( selectionData, value );      break;          case formName:      err = MenuFormName( selectionData, value );      break;          default:      err = errAEBadTestKey;  }        return err;}pascal OSErr  PropertyFromMenuAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                       AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused(containerClass)#endif  long        itemCount,            index;  AEDesc        resultDesc = {typeNull, NULL},            aDesc = {typeNull, NULL},            propDesc = {typeNull, NULL};  Size              actualSize;  DescType          returnedType;  MenuToken         theToken;  MenuPropToken     thePropertyToken;  OSErr             err;    if (typeAEList == container-&gt;descriptorType)  {    err = AECreateList( NULL, 0 , false, value );  // Result will also be a list of items    if (noErr != err) goto done;    err = AECountItems( container, &amp;itemCount );    if (noErr != err) goto done;      for ( index = 1; index &lt;= itemCount; index++ )  // Do in forward order    {      err = AEGetNthDesc( container, index, typeWildCard, &amp;returnedType, &amp;aDesc );      if ( noErr != err ) goto done;                            // Recursively call this routine                            // - could be another list.      err = PropertyFromMenuAccessor( wantClass, &amp;aDesc, aDesc.descriptorType,                          form, selectionData, &amp;resultDesc, theRefCon );            err = AEPutDesc( value, 0, &amp;resultDesc );  // Add item to the end of our list      if ( noErr != err ) goto done;            (void)AEDisposeDesc( &amp;aDesc );      (void)AEDisposeDesc( &amp;resultDesc );    }  }  else  {    // get the window token - it's the container        err = AECoerceDesc( container, typeMyMenu, &amp;aDesc );    if ( noErr != err ) goto done;    GetRawDataFromDescriptor( &amp;aDesc, (Ptr)&amp;theToken,                    sizeof(theToken), &amp;actualSize );                                    // get the property - it's in the selection data        err = AECoerceDesc( selectionData, typeType, &amp;propDesc );    if ( noErr != err ) goto done;    GetRawDataFromDescriptor( &amp;propDesc, (Ptr)&amp;returnedType,                    sizeof(returnedType), &amp;actualSize );          // Combine the two into single token    thePropertyToken.token = theToken;    thePropertyToken.tokenProperty = returnedType;        err = AECreateDesc( typeMyMenuProp, (Ptr)&amp;thePropertyToken,                    sizeof( thePropertyToken ), value );  }  done:  (void)AEDisposeDesc( &amp;aDesc );  (void)AEDisposeDesc( &amp;propDesc );  (void)AEDisposeDesc( &amp;resultDesc );      return(err);} // PropertyFromMenuAccessorOSErr  MenuItemFormAbsolutePosition( MenuToken* containerToken, const AEDesc *selectionData, AEDesc* result ){  AEDesc  itemDesc = {typeNull, NULL};  short  aCount,      index;  OSErr  err;  aCount = CountMenuTokenItems( containerToken );    if (! aCount)    return(errAEIllegalIndex);    if ( typeAbsoluteOrdinal == selectionData-&gt;descriptorType )  {    err = noErr;      switch (*(DescType *)*selectionData-&gt;dataHandle)    {      case kAEFirst:        index = 1;        break;        case kAELast:        index = aCount;        break;        case kAEMiddle:        index = (aCount + 1) / 2;        break;        case kAEAny:        index = (Random() % aCount) + 1;        break;        case kAEAll:        err = AECreateList(NULL, 0 , false, result);        if (noErr != err) goto done;                for (index = 1; index &lt;= aCount; index++)        {          err = GetDescOfNthMenuItem( containerToken, index, &amp;itemDesc );          if (noErr != err) goto done;                    err = AEPutDesc(result, 0, &amp;itemDesc);          if (noErr != err) goto done;                    if (itemDesc.dataHandle)            AEDisposeDesc(&amp;itemDesc);        }                goto done;    // We have created our list descriptor        break;      // so we can just tidy up and return.              default:        err = errAETypeError;    }  }  else    err = GetIntegerFromDescriptor( selectionData, &amp;index );  if (noErr != err) goto done;    if (index &lt; 0)    // Handle negative indexes    index = aCount + index + 1;      if ( index &gt; aCount || index &lt;= 0 )    err = errAEIllegalIndex;  else    err = GetDescOfNthMenuItem( containerToken, index, result );done:    (void)AEDisposeDesc( &amp;itemDesc );  return err;} // MenuFormAbsolutePositionOSErr  MenuItemFormName( MenuToken* containerToken, const AEDesc* selectionData, AEDesc* result ){  Str255    name;  OSErr    err;        // This tries to coerce it first  err = GetPStringFromDescriptor( selectionData, name );  if ( noErr != err ) goto done;  err = GetDescOfNamedMenuItem( containerToken, name, result );done:  return(err);}pascal OSErr  MenuItemFromMenuAccessor( DescType      wantClass,                      const AEDesc  *container,                      DescType      containerClass,                      DescType    form,                       const AEDesc  *selectionData,                      AEDesc      *value,                      long      theRefCon){#ifdef __MWERKS__  #pragma unused ( containerClass, theRefCon )#endif  MenuToken  containerToken;  Size    actualSize;  OSErr       err;      // Can only handle cMenu  if ( wantClass != cMenuItem )    return errAEWrongDataType;        // Can only handle typeMyMenu  if ( container-&gt;descriptorType != typeMyMenu )    return errAENoSuchObject;    // Get the containing MenuToken  GetRawDataFromDescriptor( container, (Ptr)&amp;containerToken,                    sizeof( containerToken ), &amp;actualSize );  switch (form)  {    case formAbsolutePosition:      err = MenuItemFormAbsolutePosition( &amp;containerToken, selectionData, value );      break;          case formName:      err = MenuItemFormName( &amp;containerToken, selectionData, value );      break;          default:      err = errAEBadTestKey;  }        return err;}pascal OSErr  PropertyFromMenuItemAccessor(DescType    wantClass,                        AEDesc    *container,                        DescType  containerClass,                        DescType  form,                         AEDesc    *selectionData,                        AEDesc    *value,                        long    theRefCon){#ifdef __MWERKS__  #pragma unused(containerClass)#endif  long        itemCount,            index;  AEDesc        resultDesc = {typeNull, NULL},            aDesc = {typeNull, NULL},            propDesc = {typeNull, NULL};  Size              actualSize;  DescType          returnedType;  MenuItemToken       theToken;  MenuItemPropToken   thePropertyToken;  OSErr             err;    if (typeAEList == container-&gt;descriptorType)  {    err = AECreateList( NULL, 0 , false, value );  // Result will also be a list of items    if ( noErr != err ) goto done;    err = AECountItems( container, &amp;itemCount );    if ( noErr != err ) goto done;      for ( index = 1; index &lt;= itemCount; index++ )  // Do in forward order    {      err = AEGetNthDesc( container, index, typeWildCard, &amp;returnedType, &amp;aDesc );      if ( noErr != err ) goto done;                            // Recursively call this routine                            // - could be another list.      err = PropertyFromMenuItemAccessor( wantClass, &amp;aDesc, aDesc.descriptorType,                        form, selectionData, &amp;resultDesc, theRefCon );      if ( noErr != err ) goto done;                                err = AEPutDesc( value, 0, &amp;resultDesc );  // Add item to the end of our list      if ( noErr != err ) goto done;            (void)AEDisposeDesc( &amp;aDesc );      (void)AEDisposeDesc( &amp;resultDesc );    }  }  else  {    err = AECoerceDesc(container, typeMyMenuItem, &amp;aDesc);    if ( noErr != err ) goto done;    GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;theToken,                    sizeof(theToken), &amp;actualSize);                                    // get the property - it's in the selection data        err = AECoerceDesc( selectionData, typeType, &amp;propDesc );    if ( noErr != err ) goto done;    GetRawDataFromDescriptor( &amp;propDesc, (Ptr)&amp;returnedType,                    sizeof(returnedType), &amp;actualSize );          // Combine the two into single token    thePropertyToken.token = theToken;    thePropertyToken.tokenProperty = returnedType;        err = AECreateDesc( typeMyMenuItemProp, (Ptr)&amp;thePropertyToken,                    sizeof( thePropertyToken ), value );  }  done:  (void)AEDisposeDesc(&amp;aDesc);  (void)AEDisposeDesc(&amp;propDesc);  (void)AEDisposeDesc(&amp;resultDesc);      return(err);} // PropertyFromMenuItemAccessor</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MenuScripter/listing6.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MenuScripter/listing6.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MenuScripter/listing6.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>