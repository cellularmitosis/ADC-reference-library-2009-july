<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html><head>
<!-- BEGIN META TAG INFO -->
<link rel="home" href="http://developer.apple.com/">
<link rel="find" href="http://developer.apple.com/search/">
<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
<script language="JavaScript" type="text/javascript" src="../../documentation/js/busnav.js"></script>
<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- END META TAG INFO -->
<!-- BEGIN TITLE -->
<title>Technical Note TN2123: CrashReporter</title>
<!-- END TITLE -->
</head>
<!-- BEGIN BODY OPEN -->
<body bgcolor="#ffffff"><a name="//apple_ref/doc/uid/DTS10003386" title="CrashReporter"></a>
<!--END BODY OPEN -->
<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->
<a name="top"></a>
<!-- BEGIN LOGO AND SEARCH -->
<!--#include virtual="/includes/adcnavbar"-->
<!-- END LOGO AND SEARCH -->
<!-- START BREADCRUMB -->
<div id="breadcrumb"><table width="680" border="0" cellpadding="0" cellspacing="0"><tr>
<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
<td><img width="340" height="10" src="images/1dot.gif" alt=""></td></tr><tr valign="middle"><td align="left" colspan="2">
<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/DeveloperTools/index.html">Tools</a> &gt; <a href="../../technicalnotes/DeveloperTools/idxCompilersDebuggers-date.html">Compiling & Debugging</a> &gt; 
</td></tr><tr><td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td></tr></table></div>
<!-- END BREADCRUMB -->

<!-- START MAIN CONTENT -->
<!-- START TITLE GRAPHIC AND INTRO-->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top">
<td><h1>
<div id="pagehead">Technical Note TN2123</div>
<div id="pageheadsub">CrashReporter</div>
</h1></td></tr></table>
<!-- END TITLE GRAPHIC AND INTRO -->
<!-- BEGIN WIDE COLUMN -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td align="left" width="680">
<!-- BEGIN CONTENTS -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td><p>CrashReporter is a debugging facility in Mac OS X that logs information about all programs that crash.  This technote describes CrashReporter in detail.  It includes a description of the crash logs generated by CrashReporter, and how you can use these logs to debug your program.</p><p>This technote is useful for anyone who develops Mac OS X user space software.</p></td></tr><tr><td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td width="680"><ul><li><a href="#SECINTRODUCTION">Introduction</a><ul><li><a href="#SETCRASHLOGPLACEMENT">Crash Log Placement</a></li><li><a href="#SETCRASHREPORTERLOGGING">CrashReporter Logging</a></li><li><a href="#SECCRASHLOGVERSIONS">Crash Log Versions</a></li></ul></li><li><a href="#SECANATOMY">Anatomy of a Crash Log</a><ul><li><a href="#SECCRASHLOGPROCESS">Process Information</a></li><li><a href="#SECCRASHLOGBASIC">Basic Information</a></li><li><a href="#SECCRASHLOGEXCEPTION">Exception Information</a></li><li><a href="#SECCRASHLOGBACKTRACES">Backtrace Information</a></li><li><a href="#SECCRASHLOGSTATE">Thread State</a><ul><li><a href="#SECPOWERPC">PowerPC Architecture</a><li><a href="#SECINTEL">32-bit Intel Architecture</a><li><a href="#SECINTEL64">64-bit Intel Architecture</a></li></ul></li><li><a href="#SECCRASHLOGIMAGES">Binary Images</a></li><li><a href="#SECCRASHLOGROSETTA">Rosetta Extras</a></li></ul></li><li><a href="#SECNOSYMBOLS">Crash Logs Without Symbols</a><ul><li><a href="#SECSYMBOLSDIVIDED">Symbols Divided</a></li><li><a href="#SECSTRIPPINGDEBUGGERSYMBOLS">Stripping Debugger Symbols</a></li><li><a href="#SECSTRIPPINGMACHOSYMBOLS">Stripping Mach-O Symbols</a></li><li><a href="#SECUSINGDSYM">Symbols and CrashReporter</a><ul><li><a href="#SECPOSDEP">Position-Dependent Code</a><li><a href="#SECPOSINDEP">Position-Independent Code</a></li></ul></li></ul></li><li><a href="#SECCRASHREPORTERPREFS">CrashReporterPrefs</a></li><li><a href="#SECLIMITATIONS">CrashReporter Limitations</a></li><li><a href="#SECREFERENCES">Further Reading</a></li><li><a href="#SECDOWNLOADABLES">Downloadables</a></li><li><a href="#TNT_HISTORY_TAG">Document Revision History</a></li></ul></td></tr><tr><td colspan="3" scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><A NAME="SECINTRODUCTION"></A><H2>Introduction</H2><p>Mac OS X's CrashReporter is a useful facility for learning about problems your application is experiencing in the field.  CrashReporter performs two useful actions:</p><ul><li><p>When a program crashes, CrashReporter will record a <strong>crash log</strong> (typically into <code>~/Library/Logs/CrashReporter/</code>), and inform the user by logging a message to the system logging facility.</p></li><li><p>In addition, if the program that crashed is running as a logged in GUI user, CrashReporter will present the user with a dialog asking them whether they want to submit a bug report to Apple (see <A HREF="#FIGCRASHREPORTER1">Figure 1</A>).  If the user clicks the Report button, CrashReporter displays another dialog that shows the details of the report (see <A HREF="#FIGCRASHREPORTER2">Figure 2</A>) and allows them to comment it before submission.</p></li></ul><A NAME="FIGCRASHREPORTER1"></A><p class="caption"><strong>Figure 1:</strong> First CrashReporter dialog</p><p><img  src="images/tn2123_CrashReporter105f1.png" width="531" height="255" alt="Figure 1, First CrashReporter dialog"></p><A NAME="FIGCRASHREPORTER2"></A><p class="caption"><strong>Figure 2:</strong> Second CrashReporter dialog</p><p><img  src="images/tn2123_CrashReporter105f2.png" width="680" height="502" alt="Figure 2, Second CrashReporter dialog"></p><p>In this technote I explain how to interpret crash logs that you have obtained from end users.  In the first section I <A HREF="#SECANATOMY">explain each part of the crash log</A> in detail.  Following that I show you how you can get useful information from a crash log even if your program ships <A HREF="#SECNOSYMBOLS">without debugging symbols</A>.  Then I explain how to use CrashReporterPrefs to <A HREF="#SECCRASHREPORTERPREFS">customize CrashReporter's behavior</A>.  Finally, I explain some <A HREF="#SECLIMITATIONS">limitations</A> of the current implementation.</p><div class="notebox"><p><strong>IMPORTANT:</strong> This technote describes CrashReporter as it's implemented in Mac OS X 10.5.  CrashReporter has evolved over time, and there are numerous differences between the current version and earlier ones.  I've called out these changes where they are significant.</p></div><div class="notebox"><p><strong>Note:</strong> CrashReporter has limited support for some deprecated technologies, most notably the PEF binary image format.  This technote does not describe that support.</p></div><A NAME="SETCRASHLOGPLACEMENT"></A><H3>Crash Log Placement</H3><p>CrashReporter usually places the crash log in the user's home directory, as explained above. However, under some circumstances it will put the crash log in <code>/Library/Logs/CrashReporter/</code>.  These include:</p><ul><li><p>if it can't determine the ownership of the crashed process</p></li><li><p>if the crashed process was owned by root</p></li><li><p>if the user's home directory is not available or not writable</p></li></ul><p>Each crash log is written to a separate file.  The file name is of the form <code>PPP_YYYY-MM-DD-HHMMSS_NNN.crash</code>, where PPP is the process name; YYYY, MM, DD, HH, MM, and SS are the date and time of the crash; and NNN is the host name.  For example, <code>TextEdit_2008-01-29-143702_guy-smiley.crash</code> is a TextEdit crash from 29 Jan 2008 at 14:37:02 on the machine &quot;guy-smiley&quot;.  To prevent unbounded disk use, CrashReporter limits the number of crash log files for any given combination of user, process name and host name.  The current limit is 20.</p><div class="notebox"><p><strong>IMPORTANT:</strong> CrashReporter also creates other files within the CrashReporter directory.  Specifically, it creates files of the form <code>.PPP_NNN_CrashHistory.plist</code> (for example, <code>.TextEdit_guy-smiley_CrashHistory.plist</code>).  These files are invisible in the Finder.  You must not rely on the presence or format of these files.</p></div><div class="notebox"><p><strong>Note:</strong> Prior to Mac OS X 10.5 CrashReporter created files of the form <code>PPP.crash.log</code>, where PPP is the process name.  All crash logs for a given process name were appended to that file.  For example, all TextEdit crashes were logged in <code>TextEdit.crash.log</code>.  There was nothing to prevent these files from growing without bound.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SETCRASHREPORTERLOGGING"></A><H3>CrashReporter Logging</H3><p>CrashReporter logs via <A HREF="x-man-page://3/asl">Apple System Log</A>.  All CrashReporter log entries have the Facility set to &quot;Crash Reporter&quot;.  You can display all such message with the command shown in <A HREF="#LISTCRASHLOGGING1">Listing 1</A>.</p><A NAME="LISTCRASHLOGGING1"></A><p class="smalltext"><strong>Listing 1:</strong> Displaying all CrashReporter log entries</p><pre class="sourcecodebox">
$ syslog -k Facility eq &quot;Crash Reporter&quot;
[&hellip;]
[&hellip;] Formulating crash report for process TextEdit[9803]
[&hellip;] Saved crashreport to /Users/quinn/Library/Logs/CrashReporter/\
TextEdit_2008-01-29-204411_guy-smiley.crash using uid: 2000 gid: 2000, \
euid: 2000 egid: 2000
</pre><p>You can display recent log entries and wait for more to show up (much like <code>tail -f</code>), with the command shown in <A HREF="#LISTCRASHLOGGING2">Listing 2</A>.</p><A NAME="LISTCRASHLOGGING2"></A><p class="smalltext"><strong>Listing 2:</strong> Waiting for new CrashReporter log entries</p><pre class="sourcecodebox">
$ syslog -w -k Facility eq &quot;Crash Reporter&quot;
[&hellip;]
</pre><p>You can do the same thing from the Console application by choosing New Log Database Query from the File menu and then configuring the query to search for log messages where the Facility is &quot;Crash Reporter&quot;.</p><div class="notebox"><p><strong>Note:</strong> Prior to Mac OS X 10.5 CrashReporter logged to both the system log (<code>/var/log/system.log</code>) and its own specific log file (<code>/var/log/crashreporter.log</code>).</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECCRASHLOGVERSIONS"></A><H3>Crash Log Versions</H3><p>Crash logs include a <A HREF="#SECCRASHLOGBASIC">version number</A> that you can use to interpret the information contained in the log.  This version number is loosely related to the system version.  <A HREF="#TABCRASHLOGVERSIONS">Table 1</A> shows that relationship.</p><A NAME="TABCRASHLOGVERSIONS"></A><p class="smalltext"><strong>Table 1:</strong> Crash Log Versions</p><table cellspacing="0" class="graybox"><tr><th><strong>Crash Log Version</strong></th><th><strong>Mac OS X Versions</strong></th></tr><tr><td scope="row">1</td><td>prior to 10.3.2</td></tr><tr><td scope="row">2</td><td>10.3.2 through 10.3.9</td></tr><tr><td scope="row">3</td><td>10.4.x on PowerPC</td></tr><tr><td scope="row">4</td><td>10.4.x on Intel</td></tr><tr><td scope="row">5</td><td>none</td></tr><tr><td scope="row">6</td><td>10.5 and later</td></tr></table><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECANATOMY"></A><H2>Anatomy of a Crash Log</H2><p>A crash log has a number of different parts; in the following sections I describe each part in detail.</p><A NAME="SECCRASHLOGPROCESS"></A><H3>Process Information</H3><p>The first part of the crash log contains information about the process that crashed, as illustrated in <A HREF="#LISTCRASHLOGPROCESS">Listing 3</A>.</p><A NAME="LISTCRASHLOGPROCESS"></A><p class="smalltext"><strong>Listing 3:</strong> Process information</p><pre class="sourcecodebox">
Process:         TextEdit [8752]
Path:            /Applications/TextEdit.app/Contents/MacOS/TextEdit
Identifier:      com.apple.TextEdit
Version:         1.5 (244)
Build Info:      TextEdit-2440000~2
Code Type:       X86 (Native)
Parent Process:  launchd [241]
</pre><p>The most important thing to note here is the name of the process that crashed.  In some cases the actual process that died is not what you think.  For example, if your application uses a helper tool to do some work, and that helper tool dies, you want to focus on the helper tool's code and not waste time debugging the application code.</p><p>The &quot;Process&quot; field includes the name and PID (in square brackets) of the crashed process.  The &quot;Path&quot; field is the path to the process's executable.</p><p>The &quot;Identifier&quot; field contains the bundle identifier, if any, of the crashed process.</p><p>CrashReporter gets the &quot;Version&quot; field from the process's executable.  If the process is a packaged application, the version is composed of the <code>CFBundleShortVersionString</code> and <code>CFBundleVersion</code> properties from its <code>Info.plist</code> file.  If the process is single file application, the version is derived from its <code>'vers'</code> ID=1 resource.</p><p>The &quot;Build Info&quot; field shows information extracted from the <code>version.plist</code> file in the application's bundle, if any.  This file, and hence this field, is typically only present for Apple applications.</p><p>The &quot;Code Type&quot; field shows the type of code that was executing.  If your program is a universal binary, you should check this field to see which architecture was actually being run (for example, the user might have accidentally run your program using Rosetta).</p><p>The &quot;Parent Process&quot; field includes the name and the PID (in square brackets) of the parent process.  It's worth checking that this is what you'd expect it to be.</p><div class="notebox"><p><strong>Note:</strong> In crash logs prior to version 6 the &quot;Process&quot; field was known as the &quot;Command&quot; field, and the process ID was included in a separate &quot;PID&quot; field.</p></div><div class="notebox"><p><strong>Note:</strong> The &quot;Path&quot; and &quot;Version&quot; fields were introduced with version 2 crash logs.</p></div><div class="notebox"><p><strong>Note:</strong> The &quot;Identifier&quot; field was introduced with version 6 crash logs.</p></div><div class="notebox"><p><strong>Note:</strong> In crash logs prior to version 6 the information in the &quot;Build Info&quot; field was split across three separate fields: &quot;Build Version&quot;, &quot;Project Name&quot; and &quot;Source Version&quot;.  These fields were introduced with version 3 crash logs.</p></div><div class="notebox"><p><strong>Note:</strong> The &quot;Code Type&quot; field was introduced with version 6 crash logs.</p></div><div class="notebox"><p><strong>Note:</strong> In crash logs prior to version 6 the &quot;Parent Process&quot; field was named &quot;Parent&quot;.  It was first included in version 3 crash logs.</p></div><div class="notebox"><p><strong>Note:</strong> In crash logs prior to version 6 the process information part of the crash log was placed after the basic information part.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECCRASHLOGBASIC"></A><H3>Basic Information</H3><p>The next part of the crash log contains information about the crash log itself.  You can see an example in <A HREF="#LISTCRASHLOGBASIC">Listing 4</A>.</p><A NAME="LISTCRASHLOGBASIC"></A><p class="smalltext"><strong>Listing 4:</strong> Basic information</p><pre class="sourcecodebox">
Date/Time:       2008-01-29 12:32:46.239 +0000
OS Version:      Mac OS X 10.5.1 (9B18)
Report Version:  6
</pre><p>The most important piece of information here is the OS version. You should pay particular attention to the build number; each user-visible version of Mac OS X can have multiple variants distinguished only by their build numbers (this typically happens for hardware-specific system releases).  In addition, make sure to look at the time and date to see if there are any suspicious patterns: if you get lots of crash logs that all occur at 12:00, you probably need to investigate your time handling code.</p><p>The &quot;Report Version&quot; field is discussed in <A HREF="#SECCRASHLOGVERSIONS">Crash Log Versions</A>.</p><div class="notebox"><p><strong>Note:</strong> Version 2 crash logs included a &quot;Host Name&quot; field in this section; this is not present in later versions.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECCRASHLOGEXCEPTION"></A><H3>Exception Information</H3><p>The third part of the crash log shows information about the processor exception that was the immediate cause of the crash.  <A HREF="#LISTCRASHLOGEXCEPTION">Listing 5</A> shows a typical example.</p><A NAME="LISTCRASHLOGEXCEPTION"></A><p class="smalltext"><strong>Listing 5:</strong> Exception information</p><pre class="sourcecodebox">
Exception Type:  EXC_BAD_ACCESS (SIGBUS)
Exception Codes: KERN_PROTECTION_FAILURE at 0x0000000000000000
Crashed Thread:  0
</pre><p>The &quot;Crashed Thread&quot; field denotes the thread that crashed; it is redundant because the <A HREF="#SECCRASHLOGBACKTRACES">backtrace section</A> highlights the crashing thread.</p><div class="notebox"><p><strong>Note:</strong> The &quot;Crashed Thread&quot; field was introduced in version 2 crash logs.  Prior to version 6 crash logs it was called &quot;Thread&quot; and it appeared in the process information section.</p></div><p>The most common forms of exception are:</p><ul><li><p><code>EXC_BAD_ACCESS</code>/<code>KERN_INVALID_ADDRESS</code> &mdash; This is caused by the thread accessing unmapped memory.  It may be triggered by either a data access or an instruction fetch; the <A HREF="#SECCRASHLOGSTATE">Thread State</A> section describes how to tell the difference.</p></li><li><p><code>EXC_BAD_ACCESS</code>/<code>KERN_PROTECTION_FAILURE</code> &mdash; This is caused by the thread trying to write to read-only memory.  This is always caused by a data access.</p></li><li><p><code>EXC_BAD_INSTRUCTION</code> &mdash; This is caused by the thread executing an illegal instruction.</p></li><li><p><code>EXC_ARITHMETIC</code>/<code>EXC_I386_DIV</code> &mdash; This is caused by the thread doing an integer divide by zero on an Intel-based computer.</p></li></ul><p>For <strong>memory access exceptions</strong> (<code>EXC_BAD_ACCESS</code>) the exception part of the crash log contains the address that triggered the exception (the <strong>exception address</strong>).  In <A HREF="#LISTCRASHLOGEXCEPTION">Listing 5</A> that address is 0x0000000000000000.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECCRASHLOGBACKTRACES"></A><H3>Backtrace Information</H3><p>The fourth part of the crash log, which displays a backtrace for all of the threads in the crashed process, is typically the most interesting.  <A HREF="#LISTCRASHLOGBACKTRACES">Listing 6</A> shows an example.</p><A NAME="LISTCRASHLOGBACKTRACES"></A><p class="smalltext"><strong>Listing 6:</strong> Backtrace information</p><pre class="sourcecodebox">
Thread 0 Crashed:
0   ???                             0000000000 0 + 0
1   com.apple.CoreFoundation        0x942cf0fe CFRunLoopRunSpecific + 18&hellip;
2   com.apple.CoreFoundation        0x942cfd38 CFRunLoopRunInMode + 88
3   com.apple.HIToolbox             0x919e58a4 RunCurrentEventLoopInMode&hellip;
4   com.apple.HIToolbox             0x919e56bd ReceiveNextEventCommon + &hellip;
5   com.apple.HIToolbox             0x919e5531 BlockUntilNextEventMatchi&hellip;
6   com.apple.AppKit                0x9390bd5b _DPSNextEvent + 657
7   com.apple.AppKit                0x9390b6a0 -[NSApplication nextEvent&hellip;
8   com.apple.AppKit                0x939046d1 -[NSApplication run] + 79&hellip;
9   com.apple.AppKit                0x938d19ba NSApplicationMain + 574
10  com.apple.TextEdit              0x00001df6 0x1000 + 3574
</pre><p>In this example there is only one thread, so there's only one backtrace.  In a multi-threaded process, there is one backtrace per thread.  Thus, it's critical that you identify the thread that crashed.  CrashReporter makes this easy by tagging that backtrace with the text &quot;Thread &lt;ThreadNumber&gt; Crashed:&quot;.  However, it's easy to overlook this text and erroneously assume that the Thread 0 is the one that crashed.</p><div class="notebox"><p><strong>Note:</strong> Your process may be multi-threaded even if you don't explicitly create any threads.  Various frameworks can create threads on your behalf.  For example, CFSocket creates a thread to integrate sockets with the runloop.</p></div><p>Each line of the backtrace describes a nested function invocation (a <strong>frame</strong>), with the most recently executed function at the top and the least recently executed at the bottom.  For each frame, the columns in the backtrace are as follows.</p><ul><li><p>The first column is the frame number, starting at 0 (indicating the function that crashed) and incrementing for each nested function call.</p></li><li><p>The second column is the name of the binary image containing the code executing in this frame; this is derived by cross referencing the program counter address (from the next column) with the list of <A HREF="#SECCRASHLOGIMAGES">loaded binary images</A>.</p></li><li><p>The third column is the program counter address within the frame.  For frame 0 this is typically the address of the instruction that caused the exception.  For higher frames this is the return address for that frame.  That is, for frame N it points to the next instruction that will execute when the function referenced by frame N - 1 returns.</p></li><li><p>The fourth column is the symbolic name for the program counter address given in the third column.  If you strip debugging symbols before shipping your application to end users, this column will just contain a hex number.  You can work out the corresponding symbolic name using the technique <A HREF="#SECNOSYMBOLS">described later in this document</A>.</p></li></ul><p>Finally, if your program is multi-threaded, you can often identify which thread is which by looking at the symbolic names deep within the backtrace.  For example, in <A HREF="#LISTCRASHLOGBACKTRACES">Listing 6</A>, frame 9 lists <code>NSApplicationMain</code> as its symbolic address, indicating that this thread is the main thread.  In contrast, the deepest frame for a pthread is always the routine <code>_pthread_start</code>.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECCRASHLOGSTATE"></A><H3>Thread State</H3><p>The next part of the crash log contains a dump of the processor state of the thread that crashed. <A HREF="#LISTCRASHLOGSTATEPPC">Listing 7</A> shows an example of this for PowerPC.</p><A NAME="LISTCRASHLOGSTATEPPC"></A><p class="smalltext"><strong>Listing 7:</strong> PowerPC thread state</p><pre class="sourcecodebox">
Thread 0 crashed with PPC Thread State 64:
  srr0: 0x0000000000000000 srr1: 0x000000004000d030                  &hellip;
    cr: 0x44022282           &hellip;                 lr: 0x000000009000a6bc&hellip;
    r0: 0x00000000ffffffe1   r1: 0x00000000bfffeb10   r2: 0x00000000a&hellip;
    r4: 0x0000000003000006   r5: 0x0000000000000000   r6: 0x000000000&hellip;
    r8: 0x0000000000000000   r9: 0x0000000000000000  r10: 0x000000000&hellip;
   r12: 0x000000009000a770  r13: 0x0000000000000000  r14: 0x000000000&hellip;
   r16: 0x0000000000000000  r17: 0x0000000000000000  r18: 0x000000000&hellip;
   r20: 0x00000000101a7026  r21: 0x00000000be5b19d8  r22: 0x000000000&hellip;
   r24: 0x0000000000000450  r25: 0x0000000000001203  r26: 0x000000000&hellip;
   r28: 0x0000000000000000  r29: 0x0000000003000006  r30: 0x000000000&hellip;
</pre><p>To get the most out of this information, you need a good understanding of the Mac OS X application binary interface (ABI) for the processor.  For a detailed description, see <A HREF="../../documentation/DeveloperTools/Conceptual/LowLevelABI/index.html">Mac OS X ABI Function Call Guide</A>.  However, there are some simple ways get useful results without a full understanding of the ABI.</p><A NAME="SECPOWERPC"></A><H4>PowerPC Architecture</H4><p>For PowerPC-based computers, you should consider the following points:</p><ul><li><p>Focus on three values: <code>srr0</code>, <code>lr</code>, and the exception address (described <A HREF="#SECCRASHLOGEXCEPTION">earlier</A>).</p></li><li><p><code>srr0</code> is the program counter at the time that the exception occurred. That is, it's the address of the instruction that caused the exception.  For most non-memory access exceptions (for example, <code>EXC_BAD_INSTRUCTION</code> caused by executing an illegal instruction), this is the key value.  For memory access exceptions, it's only part of the equation.</p></li><li><p><code>lr</code> is typically used to hold the return address of a function call.</p></li><li><p>For memory access exceptions:</p><ul><li><p>If <code>srr0</code> is equal to the exception address, the exception was caused by fetching instructions. Typically this means that you've called a bogus function pointer (or, equivalently, called a method on a bogus object). In this case the return address is typically in <code>lr</code>, which tells you the address of the code that called the bogus function pointer.</p></li><li><p>Furthermore, if <code>srr0</code> is equal to <code>lr</code> which is equal to the exception address, your program has crashed returning from a function.  This typically means that you've corrupted the stack (the return address is typically saved on the stack during the execution of a function) and then died returning to a bogus address.</p></li><li><p>If <code>srr0</code> is not equal to the exception address, the exception was caused by a memory access instruction (in terms of C, this means that you're dereferencing an invalid pointer).</p></li></ul></li><li><p>The function call ABI for PowerPC code is registered based; thus, if you crash early in the execution of a function, you may be able to see its parameters in the registers.  See <A HREF="../../documentation/DeveloperTools/Conceptual/LowLevelABI/index.html">Mac OS X ABI Function Call Guide</A> for details.</p></li><li><p>Finally, it can be helpful to look through the other registers for telltale signs.  For example, if a register contains ASCII characters whose value only appear in one place in your program, that's a clue as to what code has executed recently.  Alternatively, if a register contains a well known error value (for example, <code>dskFulErr</code>, which means &quot;disk full error&quot; in the Core Services File Manager, whose value is -34, or 0xffffffde in hex), that might be a clue as to why your program failed.</p></li></ul><p>In the example in <A HREF="#LISTCRASHLOGSTATEPPC">Listing 7</A> (which is the thread state for a memory access exception), you can see that <code>srr0</code> is 0x00000000, which is equal to the exception address (see <A HREF="#SECCRASHLOGEXCEPTION">Exception Information</A>) but is not equal to <code>lr</code>.  Thus, the program has crashed by calling a <code>NULL</code> function pointer and the caller's address is in <code>lr</code>.</p><div class="notebox"><p><strong>Note:</strong> Prior to version 3, crash logs only include the bottom 32-bits of each PowerPC register.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECINTEL"></A><H4>32-bit Intel Architecture</H4><p><A HREF="#LISTCRASHLOGSTATEINTEL">Listing 8</A> shows the thread state for an Intel-based computer running 32-bit code.</p><A NAME="LISTCRASHLOGSTATEINTEL"></A><p class="smalltext"><strong>Listing 8:</strong> 32-bit Intel thread state</p><pre class="sourcecodebox">
Thread 0 crashed with X86 Thread State (32-bit):
  eax: 0x00000000  ebx: 0x942cea07  ecx: 0xbfffed1c  edx: 0x94b3a8e6
  edi: 0x00000000  esi: 0x00000000  ebp: 0xbfffed58  esp: 0xbfffed1c
   ss: 0x0000001f  efl: 0x00010206  eip: 0x00000000   cs: 0x00000017
   ds: 0x0000001f   es: 0x0000001f   fs: 0x00000000   gs: 0x00000037
  cr2: 0x00000000
</pre><p>For Intel-based computers running 32-bit code, you should consider the following points:</p><ul><li><p>Focus on two values: <code>eip</code> and the exception address (described <A HREF="#SECCRASHLOGEXCEPTION">earlier</A>).</p></li><li><p><code>eip</code> is the program counter at the time that the exception occurred. That is, it's the address of the instruction that caused the exception.  For most non-memory access exceptions (for example, <code>EXC_ARITHMETIC</code>/<code>EXC_I386_DIV</code> caused by an integer division by zero), this is the key value.</p></li><li><p>For memory access exceptions:</p><ul><li><p>If <code>eip</code> is equal to the exception address, the exception was caused by fetching instructions. Typically this means:</p><ul><li><p>you've called a bogus function pointer (or, equivalently, called a method on a bogus object)</p></li><li><p>you've returned to a bad address which, in turn, means that you've corrupted the stack</p></li></ul></li><li><p>If <code>eip</code> is not equal to the exception address, the exception was caused by a memory access instruction (in terms of C, this means that you're dereferencing an invalid pointer).</p></li></ul></li><li><p>Finally, as with <A HREF="#SECPOWERPC">PowerPC</A>, it can be helpful to look through the other registers for telltale signs.</p></li></ul><div class="notebox"><p><strong>Note:</strong> Because of the way the Intel architecture works, it's harder to get useful results from the thread state than it is on PowerPC.  For example, on the PowerPC architecture the return address is stored in a register (<code>lr</code>), while on Intel it's stored on the stack.</p></div><div class="notebox"><p><strong>Note:</strong> The 32-bit Intel thread state in crash logs prior to version 6 did not include the <code>cr2</code> register.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECINTEL64"></A><H4>64-bit Intel Architecture</H4><p><A HREF="#LISTCRASHLOGSTATEINTEL64">Listing 9</A> shows the thread state for an Intel-based computer running 64-bit code.</p><A NAME="LISTCRASHLOGSTATEINTEL64"></A><p class="smalltext"><strong>Listing 9:</strong> 64-bit Intel thread state</p><pre class="sourcecodebox">
Thread 0 crashed with X86 Thread State (64-bit):
  rax: 0x0000000000000000  rbx: 0x0000000000000000  rcx: 0x00007fff5fbfec48&hellip;
  rdi: 0x00007fff5fbfed40  rsi: 0x0000000003000006  rbp: 0x00007fff5fbfeca0&hellip;
   r8: 0x0000000000001003   r9: 0x0000000000000000  r10: 0x0000000000000450&hellip;
  r12: 0x0000000000001003  r13: 0x0000000000000450  r14: 0x00007fff5fbfed40&hellip;
  rip: 0x0000000000000000  rfl: 0x0000000000010206  cr2: 0x0000000000000000
</pre><p>In general you should interpret this thread state in much the same way as you would a 32-bit Intel thread state.  The key differences are:</p><ul><li><p>The PC address is in <code>rip</code>, not <code>eip</code>.</p></li><li><p>As with PowerPC, the function call ABI for 64-bit Intel code is registered based; thus, if you crash early in the execution of a function, you may be able to see its parameters in the registers.  See <A HREF="../../documentation/DeveloperTools/Conceptual/LowLevelABI/index.html">Mac OS X ABI Function Call Guide</A> for details.</p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECCRASHLOGIMAGES"></A><H3>Binary Images</H3><p>The next part of the crash log is a description of all of the binary images loaded into the process.  <A HREF="#LISTCRASHLOGIMAGES">Listing 10</A> is an example of this.</p><A NAME="LISTCRASHLOGIMAGES"></A><p class="smalltext"><strong>Listing 10:</strong> Binary Images</p><pre class="sourcecodebox">
Binary Images:
    0x1000 -    0x18feb  com.apple.TextEdit 1.5 (244) &lt;e1480af78e2746195aa&hellip;
 0xc648000 -  0xc72eff7  com.apple.RawCamera.bundle 2.0 (2.0) /System/Libr&hellip;
0x8fe00000 - 0x8fe2d883  dyld 95.3 (???) &lt;81592e798780564b5d46b988f7ee1a6a&hellip;
0x90046000 - 0x9004efff  com.apple.DiskArbitration 2.2 (2.2) &lt;1551b2af557f&hellip;
0x9004f000 - 0x9004fff8  com.apple.ApplicationServices 34 (34) &lt;8f910fa65f&hellip;
0x90056000 - 0x900affff  libGLU.dylib ??? (???) /System/Library/Frameworks&hellip;
0x900b0000 - 0x900b0ffc  com.apple.audio.units.AudioUnit 1.5 (1.5) /System&hellip;
0x900b1000 - 0x90163ffb  libcrypto.0.9.7.dylib ??? (???) &lt;330b0e48e67faffc&hellip;
[&hellip;]
</pre><p>This list is particularly useful because you can use it to determine a symbolic backtrace in a <A HREF="#SECNOSYMBOLS">program without symbols</A>.  It can also be useful if your program makes extensive use of plug-ins because it will show you exactly what plug-ins were loaded in your process.  Finally, you can look through this list for libraries that you don't expect to be loaded into your process, such as those used by common application patching (or 'enhancement') technologies.</p><div class="notebox"><p><strong>Note:</strong> This section was introduced with version 2 crash logs.</p></div><div class="notebox"><p><strong>IMPORTANT:</strong> The value in angle brackets is the UUID of the image, if present.  Image UUIDs are important when looking at crash logs <A HREF="#SECNOSYMBOLS">without symbols</A>.</p></div><div class="notebox"><p><strong>Note:</strong> Binary image UUIDs were first included in version 6 crash logs.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECCRASHLOGROSETTA"></A><H3>Rosetta Extras</H3><p>If the crashed process was run using Rosetta, extra information is added to the crash log.  To start with, the &quot;Code Type&quot; field in the <A HREF="#SECCRASHLOGPROCESS">Process Information</A> part indicates that Rosetta was in use; an example of this is shown in <A HREF="#LISTROSETTAPROCINFO">Listing 11</A>.</p><A NAME="LISTROSETTAPROCINFO"></A><p class="smalltext"><strong>Listing 11:</strong> Process information with Rosetta</p><pre class="sourcecodebox">
Process:         TextEdit [9031]
Path:            /Applications/TextEdit.app/Contents/MacOS/TextEdit
Identifier:      com.apple.TextEdit
Version:         1.5 (244)
Code Type:       PPC (Translated)
Parent Process:  launchd [241]
</pre><p>In addition, a &quot;Translated Code Information&quot; part is added after the <A HREF="#SECCRASHLOGIMAGES">Binary Images</A> section.  This section includes:</p><ul><li><p>the Rosetta version number</p></li><li><p>the process's command line arguments</p></li><li><p>a limited form of <A HREF="#SECCRASHLOGEXCEPTION">exception information</A></p></li><li><p>for each thread, a <A HREF="#SECCRASHLOGBACKTRACES">backtrace</A> and the <A HREF="#SECCRASHLOGSTATE">PowerPC thread state</A>, albeit in a slightly different format</p></li></ul><p><A HREF="#LISTROSETTAINFO">Listing 12</A> shows an example of this information.</p><A NAME="LISTROSETTAINFO"></A><p class="smalltext"><strong>Listing 12:</strong> Translated code information</p><pre class="sourcecodebox">
Translated Code Information:
Rosetta Version:  20.44
Args:    /Applications/TextEdit.app/Contents/MacOS/TextEdit -psn_0_2761378
Exception: EXC_BAD_ACCESS (0x0001)

Thread 0: Crashed (0xb7fff9d0, 0xb80bc8c8)
0x40400000: No symbol
0x90a9b35c: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x90a9b290: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x90a9a7a8: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x90a9a0e0: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x90a99a1c: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x90a98458: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x90a6b8f4: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x909d8ed8: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x909a9930: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit&hellip;
0x00001e18: /Applications/TextEdit.app/Contents/MacOS/TextEdit : start + &hellip;
0x00000000: /Applications/TextEdit.app/Contents/MacOS/TextEdit :   + 0

PPC Thread State
srr0: 0x00000000  srr1: 0x00000000                 vrsave: 0x00000000
cr:  0xXXXXXXXX    xer: 0x00000000     lr: 0x90a9b35c    ctr: 0x0000e814
r00: 0x90a9b35c   r01: 0xbfffe5d0   r02: 0xa0bcf924   r03: 0x00234840
r04: 0x00020000   r05: 0x002adce0   r06: 0x002adce0   r07: 0x002adce0
r08: 0xa1b1c1d3   r09: 0x00000000   r10: 0x00000004   r11: 0x00000001
r12: 0x0000e814   r13: 0xa01da174   r14: 0xa01da174   r15: 0xa01da174
r16: 0xa01da174   r17: 0xa01da174   r18: 0x00000000   r19: 0x002c00b0
r20: 0xbfffe760   r21: 0xa01da174   r22: 0xa01da174   r23: 0xa01da174
r24: 0xa01ea174   r25: 0x002adce0   r26: 0x002475c0   r27: 0x00015dd4
r28: 0x00234840   r29: 0x00020000   r30: 0x00234840   r31: 0x90a9b2f0
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECNOSYMBOLS"></A><H2>Crash Logs Without Symbols</H2><p>Symbols have always presented a conundrum for developers:</p><ul><li><p>You want to remove all symbols from your program because this makes the code smaller, and potentially faster.</p></li><li><p>However, if you remove all symbols, your crash log backtraces will contain just hex values, which makes it significantly harder to interpret them.</p></li></ul><p>Modern versions of Xcode make it easy to have your cake and eat it to.  You can remove all symbols from your program before shipping it to end users, and still have easy access to symbolic debugger information when interpreting crash logs.  This section explains how to do this.</p><A NAME="SECSYMBOLSDIVIDED"></A><H3>Symbols Divided</H3><p>When you build a program with Xcode, you must deal with two very different types of symbols:</p><ul><li><p><strong>Mach-O Symbols</strong> &mdash; These symbols may be interpreted by the linker (either static, <A HREF="x-man-page://1/ld">ld</A>, or dynamic, <A HREF="x-man-page://1/dyld">dyld</A>).</p></li><li><p><strong>Debugger Symbols</strong> &mdash; These symbols are interpreted by the debugger.</p></li></ul><p>Mach-O symbols are subdivided into two groups:</p><ul><li><p><strong>local symbols</strong> &mdash; These symbols are ignored by the linker, and are solely present for the benefit of tools like CrashReporter.  When you declare a function as <code>static</code> in C, it gets recorded as a local symbol.</p></li><li><p><strong>global symbols</strong> &mdash; These symbols are interpreted by both the static and dynamic linker.  When you declare a function as <code>extern</code> in C, it gets recorded as a global symbol.</p></li></ul><p>Xcode supports two forms of debugger symbols:</p><ul><li><p>DWARF &mdash; This is the modern debugger symbols format, supported by Xcode 2.3 and later.  DWARF symbols have numerous advantages, not the least being the nice integration with CrashReporter, as described below.</p></li><li><p>STABS &mdash; This older debugger symbols format is now deprecated.</p></li></ul><div class="notebox"><p><strong>Note:</strong> STABS debugger symbols are actually stored in the Mach-O symbol table.  This made the process of managing symbols more confusing because it conflated two very different concepts (that is, Mach-O symbols and debugger symbols).</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECSTRIPPINGDEBUGGERSYMBOLS"></A><H3>Stripping Debugger Symbols</H3><p>Xcode's DWARF implementation makes it very easy to strip debugger symbols from your released program.  All you need to do is set the &quot;Debug Information Format&quot; build setting for your release build to &quot;DWARF with dSYM File&quot; (<code>DEBUG_INFORMATION_FORMAT = dwarf-with-dsym</code>).  When you build your program Xcode will extract all of the debugging information and place it in a <code>.dSYM</code> document, which it places right next to your program in the build folder.  You can then:</p><ul><li><p>package up your program and ship it to your users</p></li><li><p>archive the <code>.dSYM</code> file</p></li></ul><p>If, at any time in the future, you need to debug your released program, you can just put it and the <code>.dSYM</code> file in the same directory and GDB will automatically find and use the debugger symbols.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECSTRIPPINGMACHOSYMBOLS"></A><H3>Stripping Mach-O Symbols</H3><p>Stripping Mach-O symbols is a more complicated issue.  The problem is that some Mach-O symbols are interpreted at runtime by the dynamic linker, and you must ensure that those symbols are not stripped.  There's one overall approach, but you have modify it depending on the type of program you are building.</p><p>The first step is to enable the &quot;Deployment Postprocessing&quot; build setting (<code>DEPLOYMENT_POSTPROCESSING = YES</code>) for your release build.  This will cause Xcode to automatically remove some symbols from your program.  The exact behavior depends on the &quot;Strip Style&quot; build setting.  You have three choices for this setting:</p><ul><li><p>All Symbols (<code>STRIP_STYLE = all</code>) &mdash; Xcode will strip all symbols that are not specifically marked as being needed at runtime.  This is equivalent to running <A HREF="x-man-page://1/strip">strip</A> tool with the &quot;-u&quot; and &quot;-r&quot; flags.</p></li><li><p>Non-Global Symbols (<code>STRIP_STYLE = non-global</code>) &mdash; Xcode will strip all local symbols.  This is equivalent to running <A HREF="x-man-page://1/strip">strip</A> tool with the &quot;-x&quot; flags.</p></li><li><p>Debugging Symbols (<code>STRIP_STYLE = debugging</code>) &mdash; Xcode will strip no symbols!  Actually, it runs the <A HREF="x-man-page://1/strip">strip</A> tool with the &quot;-S&quot; flag, which causes it to remove all debugger symbols.  This is relevant if you're using STABS debugger symbols.  However, if you're sensible and are using DWARF, your debugger symbols will not be affected by this; <code>strip</code> will remove some information from your program (notably the debug map used by <A HREF="x-man-page://1/dsymutil">dsymutil</A>) but this will not affect the <code>.dSYM</code> file that Xcode has already created.</p></li></ul><p>Critically, the default value for the &quot;Strip Style&quot; build setting depends on your target type.  <A HREF="#TABSTRIPSTYLE">Table 2</A> shows this relationship.</p><A NAME="TABSTRIPSTYLE"></A><p class="smalltext"><strong>Table 2:</strong> Default strip style by target type</p><table cellspacing="0" class="graybox"><tr><th><strong>Target Type</strong></th><th><strong>Mach-O Type</strong></th><th><strong>Default Strip Style</strong></th></tr><tr><td scope="row">Application, Command-Line Tool</td><td><code>MH_EXECUTE</code></td><td>All Symbols</td></tr><tr><td scope="row">Bundle</td><td><code>MH_BUNDLE</code></td><td>Non-Global Symbols</td></tr><tr><td scope="row">Framework, Dynamic Library</td><td><code>MH_DYLIB</code></td><td>Debugging Symbols</td></tr><tr><td scope="row">Static Library</td><td><code>MH_OBJECT</code></td><td>Debugging Symbols</td></tr></table><div class="notebox"><p><strong>IMPORTANT:</strong> If you do not set the &quot;Strip Style&quot; build setting at the project layer, Xcode will display a value of All Symbols.  This is misleading.  The actual value you get depends on the target type, as shown above.  If you open the target build settings, you will set the actual value that will be used.</p><p>On the other hand, if you do set a value for the &quot;Strip Style&quot; build setting at the project layer, this will apply to all targets (unless you override it at the target layer).  If your project has multiple targets of different types, this is unlikely to be useful.  In this case you will probably want to set the &quot;Strip Style&quot; build setting at the target layer for all targets.</p><p>For more information about how Xcode's build settings are layered, see the Build Setting Evaluation section section of the <A HREF="../../documentation/DeveloperTools/Conceptual/XcodeUserGuide/Contents/Resources/en.lproj/00_00_intro/chapter_1_section_1.html">Xcode User Guide</A>.</p></div><p>There are two common approaches to stripping Mach-O symbols:</p><ul><li><p><strong>typical</strong> &mdash; In most cases it's reasonable to leave all Mach-O global and local symbols in your release program.  They don't bloat the program too much, and their presence can be useful.  For example:</p><ul><li><p>your CrashReporter logs will include basic symbols in the backtrace</p></li><li><p>you can set DTrace probe points on these symbols</p></li></ul></li><li><p><strong>restricted</strong> &mdash; In some cases it's necessary to remove all non-essential symbols from a program.  For example:</p><ul><li><p>when you want to reduce the program's size as much as possible</p></li><li><p>when you don't want users seeing your symbol names</p></li></ul></li></ul><p>Implementing the typical approach is trivial.  Set the &quot;Strip Style&quot; build setting to Debugging Symbols, and Xcode will leave all of your global and local Mach-O symbols in the program.  This approach works for all target types.</p><p>Implementing the restricted approach is a bit trickier.  You have to do different things depending on your target type.  For an application or command-line tool, you can simply set the &quot;Strip Style&quot; build setting to &quot;All Symbols&quot;.</p><div class="notebox"><p><strong>Note:</strong> This will not remove all symbols from your program.  Some symbols, like <code>_NXArgc</code>, are exported as part of the C runtime system and your program will not work correctly if you strip them.</p></div><p>For a bundle, framework, or dynamic library, you should strip all local symbols by setting the &quot;Strip Style&quot; build setting to &quot;Non-Global Symbols&quot;.  You cannot, in general, strip global symbols because they may be referenced dynamically.</p><div class="notebox"><p><strong>IMPORTANT:</strong> It is possible to restrict the list of global symbols by passing various arguments to <A HREF="x-man-page://1/strip">strip</A>.  However, in most cases it's easier to do this at the link stage.  For example, you can explicitly control the list of exported symbols by setting the &quot;Exported Symbols File&quot; build setting (<code>EXPORTED_SYMBOLS_FILE</code>).  Alternatively, you can use the <A HREF="../../documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html">visibility attribute</A> to explicitly declare the visibility of symbols in your source code.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECUSINGDSYM"></A><H3>Symbols and CrashReporter</H3><p>Once you've set up your build system correctly, it's actually pretty easy to get meaningful results from a crash log.  If you don't strip local Mach-O symbols, the backtraces in your crash log will already be decorated with the correct function names.  In many cases that's all you need.</p><p>However, there are situations where you need more information.</p><ul><li><p>If you eliminate all non-essential Mach-O symbols from your program (the restricted approach, described in the previous section), the backtrace will not be decorated at all.</p></li><li><p>Because CrashReporter does not have access to your debugger symbols, it knows nothing about your source code.  Thus, when it decorates a backtrace, it can only include an offset, in bytes, from the beginning of the function.  In many cases it can be hard to map that byte offset to your a line in your source code.</p></li></ul><p>Fortunately, it's easy to use your <code>.dSYM</code> file to get source-level information from a crash log backtrace.  The process is slightly different for position-dependent and position-independent code.</p><A NAME="SECPOSDEP"></A><H4>Position-Dependent Code</H4><p>For position dependent code (applications and command-line tools) the process is trivial: put your release build and your <code>.dSYM</code> file in the same directory and use GDB to get symbolic information for numeric addresses.  <A HREF="#LISTPOSDEP">Listing 13</A> shows an example of this.</p><A NAME="LISTPOSDEP"></A><p class="smalltext"><strong>Listing 13:</strong> Using GDB for position-dependent code</p><pre class="sourcecodebox">
$ # Get the numeric values from the backtrace...
$ grep &quot;Thread 0 Crashed:&quot; -A 19 NoSymbolsTest_[&hellip;]_guy-smiley.crash
Thread 0 Crashed:
0   ...le.dts.NoSymbolsTest.Bundle  0x107cbf99 0x107cb000 + 3993
1   ...le.dts.NoSymbolsTest.Bundle  0x107cbfcb 0x107cb000 + 4043
2   ...dts.NoSymbolsTest.Framework  0x10005f2e 0x10005000 + 3886
3   ...dts.NoSymbolsTest.Framework  0x10005f59 0x10005000 + 3929
4   com.apple.dts.NoSymbolsTest     0x10000edf 0x10000000 + 3807
5   com.apple.AppKit                0x939dcf94 -[NSApplication sendAction&hellip;
6   com.apple.AppKit                0x939dced4 -[NSControl sendAction:to:&hellip;
7   com.apple.AppKit                0x939dcd5a -[NSCell _sendActionFrom:]&hellip;
8   com.apple.AppKit                0x939dc3bb -[NSCell trackMouse:inRect&hellip;
9   com.apple.AppKit                0x939dbc12 -[NSButtonCell trackMouse:&hellip;
10  com.apple.AppKit                0x939db4cc -[NSControl mouseDown:] + &hellip;
11  com.apple.AppKit                0x939d9d9b -[NSWindow sendEvent:] + 5&hellip;
12  com.apple.AppKit                0x939a6a2c -[NSApplication sendEvent:&hellip;
13  com.apple.AppKit                0x93904705 -[NSApplication run] + 847&hellip;
14  com.apple.AppKit                0x938d19ba NSApplicationMain + 574
15  com.apple.dts.NoSymbolsTest     0x10000e36 0x10000000 + 3638
16  com.apple.dts.NoSymbolsTest     0x10000e02 0x10000000 + 3586
17  com.apple.dts.NoSymbolsTest     0x10000d29 0x10000000 + 3369

$ # Run GDB to get the symbolic information for the address in frame 4.
$ gdb NoSymbolsTest.app
GNU gdb 6.3.50-20050815 (Apple version gdb-768) [&hellip;]
(gdb) info line *0x10000edf
Line 86 of &quot;/Users/quinn/Crash Reporter/NoSymbolsTest/AppDelegate.m&quot; \
starts at address
0x10000edf &lt;-[AppDelegate testAction:]+104&gt; and ends at \
0x10000ee1 &lt;-[AppDelegate testAction:]+106&gt;.
</pre><p>There are a number of things to consider when doing this mapping.</p><ul><li><p>In <A HREF="#LISTPOSDEP">Listing 13</A> I used GDB to map from address to symbol.  Another option is to use <A HREF="x-man-page://1/atos">atos</A>.  However, <code>atos</code> will not work correctly if you've stripped all non-essential Mach-O symbols from a program <A HREF="rdar://problem/4851020">(r. 4851020)</A>.</p></li><li><p>For the technique in <A HREF="#LISTPOSDEP">Listing 13</A> to work correctly, you must have access to the program that the user is running, and to the matching <code>.dSYM</code> file.  All three must match exactly.  You can confirm this match using the program's UUID.  <A HREF="#LISTUUID">Listing 14</A> shows how to get the UUID from the binary images part of the crash log, from the program itself (using <A HREF="x-man-page://1/dwarfdump">dwarfdump</A>), and from the <code>.dSYM</code> file (also using <code>dwarfdump</code>).</p></li><li><p>The examples in this text assume that you're using the same runtime architecture as the user of your program.  If that's not the case, you can use a command line option to force the tools to use the appropriate architecture.  The option is typically <code>-arch xxx</code>, where <code>xxx</code> is the desired architecture (for example, <code>i386</code> or <code>ppc</code>), although for <code>dwarfdump</code> it is <code>--arch xxx</code>.</p></li></ul><A NAME="LISTUUID"></A><p class="smalltext"><strong>Listing 14:</strong> Using the UUID to confirm that your symbols match the user's program</p><pre class="sourcecodebox">
$ # Get the UUID from the binary images part of the crash log.
$ # The UUID is displayed in angle brackets.
$ grep &quot;0x.*com.apple.dts.NoSymbolsTest .*&lt;&quot; NoSymbolsTest_[&hellip;]_guy-smiley.crash
0x10000000 - 0x10000ffe  com.apple.dts.NoSymbolsTest ??? (1.0) \
&lt;6264534bd26d5d39f7960cea770c4ea8&gt; /Users/quinn/Crash Reporter/NoSymbolsTest/\
build/Release/NoSymbolsTest.app/Contents/MacOS/NoSymbolsTest
$ # Get the UUID from the binary that we have.
$ dwarfdump --uuid NoSymbolsTest.app/Contents/MacOS/NoSymbolsTest
UUID: 6264534B-D26D-5D39-F796-0CEA770C4EA8 (i386) NoSymbolsTest.app[&hellip;]
UUID: AA201B24-D09B-49E2-55E5-AB15AF63B12A (ppc) NoSymbolsTest.app[&hellip;]
$ # Get the UUIDs from the .dSYM file.
$ dwarfdump --uuid NoSymbolsTest.app.dSYM
UUID: 6264534B-D26D-5D39-F796-0CEA770C4EA8 (i386) NoSymbolsTest.app.dSYM
UUID: AA201B24-D09B-49E2-55E5-AB15AF63B12A (ppc) NoSymbolsTest.app.dSYM
$ # Note that all three UUIDs match!
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECPOSINDEP"></A><H4>Position-Independent Code</H4><p>Things are a little more complication for position-independent code, like frameworks, dynamic libraries or bundles.  In this case you need to work out the difference between where the code was meant to be loaded and where the code was actually loaded.  This value is known as the <strong>slide</strong>.</p><p>To find the address that the program was actually loaded, look in the <A HREF="#SECCRASHLOGIMAGES">binary images</A> part of the crash log.  In the example in <A HREF="#LISTACTUALLOADADDR">Listing 15</A>, the program has three relevant binary images (the main program, a framework, and a bundle) and, for each image, the first column of the output is the address where the <code>__TEXT</code> segment was loaded.</p><A NAME="LISTACTUALLOADADDR"></A><p class="smalltext"><strong>Listing 15:</strong> Getting the actual load address</p><pre class="sourcecodebox">
$ # Determine the addresses that the programs were loaded.
$ grep &quot;0x.*com.apple.dts&quot; NoSymbolsTest_[&hellip;]_guy-smiley.crash
0x10000000 - 0x10000ffe  com.apple.dts.NoSymbolsTest ??? (1.0) [&hellip;]
0x10005000 - 0x10005ffd  com.apple.dts.NoSymbolsTest.Framework ??? (1.0) [&hellip;]
0x107cb000 - 0x107cbffc  com.apple.dts.NoSymbolsTest.Bundle ??? (1.0) [&hellip;]
</pre><p>You can then use <A HREF="x-man-page://1/otool">otool</A> to get the intended load address of the <code>__TEXT</code> segment.  <A HREF="#LISTINTENDEDLOADADDR">Listing 16</A> shows an example of this.</p><A NAME="LISTINTENDEDLOADADDR"></A><p class="smalltext"><strong>Listing 16:</strong> Getting the intended load address</p><pre class="sourcecodebox">
$ otool -l NoSymbolsTest.app/Contents/MacOS/NoSymbolsTest \
| grep -B 3 -A 2 -m 1 &quot;__TEXT&quot;
Load command 1
      cmd LC_SEGMENT
  cmdsize 192
  segname __TEXT
   vmaddr 0x10000000
   vmsize 0x00001000
$ otool -l NoSymbolsTest.app/Contents/Frameworks/Framework.framework/Framework \
| grep -B 3 -A 8 -m 1 &quot;__TEXT&quot;
Load command 0
      cmd LC_SEGMENT
  cmdsize 192
  segname __TEXT
   vmaddr 0x01000000
   vmsize 0x00001000
$ otool -l NoSymbolsTest.app/Contents/Resources/Bundle.bundle/Contents/MacOS/Bundle \
| grep -B 3 -A 8 -m 1 &quot;__TEXT&quot;
Load command 0
      cmd LC_SEGMENT
  cmdsize 192
  segname __TEXT
   vmaddr 0x00000000
   vmsize 0x00001000
</pre><p>Calculating the slide is now a matter of basic arithmetic.</p><p class="smalltext"><strong>Table 3:</strong> Calculating The Slide</p><table cellspacing="0" class="graybox"><tr><th><strong>Program</strong></th><th><strong>Actual Load Address (A)</strong></th><th><strong>Intended Load Address (I)</strong></th><th><strong>Slide (A - I)</strong></th></tr><tr><td scope="row">main executable</td><td>0x10000000</td><td>0x10000000</td><td>0</td></tr><tr><td scope="row">framework</td><td>0x10005000</td><td>0x01000000</td><td>0x0F005000</td></tr><tr><td scope="row">bundle</td><td>0x107cb000</td><td>0x00000000</td><td>0x107cb000</td></tr></table><div class="notebox"><p><strong>IMPORTANT:</strong> The main executable is almost always position-dependent and thus its slide is zero.  This is what makes the technique described in <A HREF="#SECPOSDEP">Position-Dependent Code</A> so much simpler.</p></div><p>If you're mapping symbols using <code>atos</code>, you can feed this slide into the program using the <code>-s</code> option.  If you're using GDB, the situation is more complicated.  <A HREF="#LISTPOSINDEP">Listing 17</A> shows one technique for doing this.</p><A NAME="LISTPOSINDEP"></A><p class="smalltext"><strong>Listing 17:</strong> Using GDB for position-independent code</p><pre class="sourcecodebox">
$ # Get the addresses from the backtrace.
$ grep &quot;Thread 0 Crashed:&quot; -A 5 NoSymbolsTest_2008-02-04-111412_guy-smiley.crash
Thread 0 Crashed:
0   ...le.dts.NoSymbolsTest.Bundle  0x107cbf99 0x107cb000 + 3993
1   ...le.dts.NoSymbolsTest.Bundle  0x107cbfcb 0x107cb000 + 4043
2   ...dts.NoSymbolsTest.Framework  0x10005f2e 0x10005000 + 3886
3   ...dts.NoSymbolsTest.Framework  0x10005f59 0x10005000 + 3929
4   com.apple.dts.NoSymbolsTest     0x10000edf 0x10000000 + 3807
$ # Now map the addresses for the frames in the bundle (0 and 1).
$ # Run GDB with no arguments.
$ gdb
GNU gdb 6.3.50-20050815 (Apple version gdb-768) [&hellip;]
(gdb) # Disable shared library preloading.  See below for why.
(gdb) set sharedlibrary preload-libraries off
(gdb) # Target the bundle.
(gdb) file Bundle.bundle/Contents/MacOS/Bundle
Reading symbols from [&hellip;]
(gdb) # Subtract the bundle slide from the frame 0 address and then map it.
(gdb) p/x 0x107cbf99-0x107cb000
$1 = 0xf99
(gdb) info line *$1
Line 28 of &quot;/Users/quinn/Crash Reporter/NoSymbolsTest/Bundle.m&quot; starts at address \
0xf94 &lt;-[Bundle testInner]+50&gt; and ends at \
0xfa5 &lt;-[Bundle testInner]+67&gt;.
(gdb) # Subtract the bundle slide from the frame 1 address and then map it.
(gdb) p/x 0x107cbfcb-0x107cb000
$2 = 0xfcb
(gdb) info line *$2
Line 34 of &quot;/Users/quinn/Crash Reporter/NoSymbolsTest/Bundle.m&quot; starts at address \
0xfcb &lt;-[Bundle testOuter]+36&gt; and ends at \
0xfd1 &lt;-[Bundle testOuter]+42&gt;.
(gdb) quit
$ # Now do the same for the framework.
$ gdb
GNU gdb 6.3.50-20050815 (Apple version gdb-768) [&hellip;]
(gdb) # Disable shared library preloading.
(gdb) set sharedlibrary preload-libraries off
(gdb) # Target the framework.
(gdb) file Framework.framework/Framework
Reading symbols from [&hellip;]
(gdb) # Subtract the framework slide from the frame 2 address and then map it.
(gdb) p/x 0x10005f2e-0x0F005000
$1 = 0x1000f2e
(gdb) info line *$1
Line 39 of &quot;/Users/quinn/Crash Reporter/NoSymbolsTest/Framework.m&quot; starts at address \
0x1000f2e &lt;-[Framework testInner]+308&gt; and ends at
0x1000f35 &lt;-[Framework testOuter]&gt;.
(gdb) # Subtract the framework slide from the frame 3 address and then map it.
(gdb) p/x 0x10005f59-0x0F005000
$2 = 0x1000f59
(gdb) info line *$2
Line 44 of &quot;/Users/Crash Reporter/NoSymbolsTest/Framework.m&quot; starts at address \
0x1000f59 &lt;-[Framework testOuter]+36&gt; and ends at \
0x1000f5f &lt;-[Framework testOuter]+42&gt;.
</pre><div class="notebox"><p><strong>IMPORTANT:</strong> By default, when you target a file in GDB (using the <code>file</code> command), GDB will load the symbols for that file and for all of the shared libraries that it references.  This can cause problems in situations like this, where the shared libraries might overlap the program whose symbols you care about.  The <code>set sharedlibrary preload-libraries off</code> command prevents GDB from loading symbols from shared libraries.  This has the added benefit of making things go faster.</p></div><div class="notebox"><p><strong>Note:</strong> The program used in the examples in this section was carefully constructed to exercise some interesting edge cases.  However, that produces some effects that are quite atypical.  Most notably, when building a framework you typically set its intended load address to zero, or a value that does not overlap your main executable.  Thus, a framework typically has either a zero intended load address or a zero slide.</p></div><div class="notebox"><p><strong>Note:</strong> This section focuses on the <code>__TEXT</code> segment because the symbols in a backtrace typically come from that segment.  For most Mach-O images the <code>__TEXT</code> and <code>__DATA</code> segments slide together; once you work out the slide for the <code>__TEXT</code> segment, you can apply the same slide to map symbols in the <code>__DATA</code> segment.  However, in Mac OS X 10.5 and later it's possible for these segments to slide independently.  This typically only happens for commonly-used system frameworks.</p><p>The bad news is that the crash log does not contain the base address of the <code>__DATA</code> segment, so it's impossible to calculate the data slide of an image purely from the crash log <A HREF="rdar://problem/5734989">(r. 5734989)</A>.  The good news is that this is rarely necessary because:</p><ul><li><p>this issue only affects frameworks that are placed in the dyld shared region (that is, commonly-used system frameworks)</p></li><li><p>it is rare for data segment addresses to appear in a backtrace</p></li><li><p>if they do, and the address is in a system framework, CrashReporter will have already mapped the address to a symbol</p></li></ul></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECCRASHREPORTERPREFS"></A><H2>CrashReporterPrefs</H2><p>The CrashReporterPrefs application (installed as part of the Xcode developer tools) allows you to control how CrashReporter operates.  <A HREF="#FIGCRASHREPORTERPREFS">Figure 3</A> shows its primary user interface.</p><A NAME="FIGCRASHREPORTERPREFS"></A><p class="caption"><strong>Figure 3:</strong> CrashReporterPrefs user interface</p><p><img  src="images/tn2123_CrashReporterPrefs105.png" width="557" height="328" alt="Figure 3, CrashReporterPrefs user interface"></p><p>There are three modes:</p><ul><li><p>Basic &mdash; This is the default mode, <A HREF="#SECINTRODUCTION">described earlier</A>.</p></li><li><p>Developer &mdash; This mode is designed for software developers. In this mode CrashReporter will display a more detailed crash report dialog in more cases.  <A HREF="#FIGDEVELOPER">Figure 4</A> shows an example of the first CrashReporter dialog when running in Developer mode.</p></li><li><p>Server &mdash; This mode is designed for unattended servers. The CrashReporter user interface is never shown, although crash logs are still written to disk.</p></li></ul><A NAME="FIGDEVELOPER"></A><p class="caption"><strong>Figure 4:</strong> CrashReporter in Developer mode</p><p><img  src="images/tn2123_Developer105.png" width="531" height="465" alt="Figure 4, CrashReporter in Developer mode"></p><div class="notebox"><p><strong>Note:</strong> CrashReporterPrefs was introduced with Mac OS X 10.4 (Xcode 2.0).  Prior to Mac OS X 10.4, there was no equivalent to Developer mode.  You could, however, modify some CrashReporter behavior using hidden preferences, as described in <A HREF="../../qa/qa2001/qa1288.html">Technical Q&amp;A QA1288, 'Suppressing the &quot;unexpectedly quit&quot; alert'</A>.</p><p>In Mac OS X 10.4.x Developer mode would offer you the option of attaching to the crashed process using GDB.  This feature was removed because architectural changes in the system, designed to make crash reporting more reliable in general, made it very hard to implement.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECLIMITATIONS"></A><H2>CrashReporter Limitations</H2><p>CrashReporter currently has a number of limitations.</p><ul><li><p>There is currently no way for third party developers to access the reports submitted via CrashReporter. Apple is aware that there is strong demand for such a facility <A HREF="rdar://problem/3356232">(r. 3356232)</A>. In fact, various third party developers have implemented their own crash reporting mechanisms: these range from the simple (have the application look at its own crash log file at launch time; if it has changed, offer to submit it to the developer) to the exceeding complex (completely reimplement CrashReporter).</p></li><li><p>Adding some stack information to the crash log would make it more useful when debugging certain types of crashes <A HREF="rdar://problem/3310695">(r. 3310695)</A>.</p></li></ul><p>A number of issues that affected previous versions of CrashReporter were were addressed in Mac OS X 10.5.</p><ul><li><p>Prior to Mac OS X 10.5, CrashReporter did not generate a crash log if your program terminated because of an <code>abort</code> system call <A HREF="rdar://problem/3291139">(r. 3291139)</A>.</p></li><li><p>Prior to Mac OS X 10.5, if you wrote a program that cause an exception but handled that exception via a <A HREF="x-man-page://3/signal">signal handler</A>, CrashReporter would erroneously generate a crash log for your program <A HREF="rdar://problem/2941263">(r. 2941263)</A>.</p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECREFERENCES"></A><H2>Further Reading</H2><ul><li><p><A HREF="../../qa/qa2001/qa1288.html">Technical Q&amp;A QA1288, 'Suppressing the &quot;unexpectedly quit&quot; alert'</A></p></li><li><p><A HREF="../../documentation/DeveloperTools/Conceptual/LowLevelABI/index.html">Mac OS X ABI Function Call Guide</A></p></li><li><p><A HREF="../../documentation/DeveloperTools/Conceptual/XcodeUserGuide/Contents/Resources/en.lproj/00_00_intro/chapter_1_section_1.html">Xcode User Guide</A></p></li><li><p><A HREF="../../documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html">Controlling Symbol Visibility</A></p></li><li><p><A HREF="../../documentation/DeveloperTools/gdb/gdb/gdb_toc.html">Debugging with GDB</A></p></li><li><p><A HREF="x-man-page://8/ReportCrash">ReportCrash man page</A></p></li><li><p><A HREF="x-man-page://3/asl">Apple System Log (ASL) man page</A></p></li><li><p><A HREF="x-man-page://1/atos">atos man page</A></p></li><li><p><A HREF="x-man-page://1/strip">strip man page</A></p></li><li><p><A HREF="x-man-page://1/otool">otool man page</A></p></li><li><p><A HREF="x-man-page://1/dwarfdump">dwarfdump man page</A></p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECDOWNLOADABLES"></A><H2>Downloadables</H2><ul><li><p><a href="downloads/tn2123_SampleCrashLogs.zip">Sample crash logs</a> ("tn2123_SampleCrashLogs.zip", 26.2K)</p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNT_HISTORY_TAG"></A><H2>Document Revision History</H2><table cellspacing="0" class="graybox" width="680"><tr><th width="100">Date</th><th width="580">Notes</th></tr><tr><td scope="row">2008-04-01</td><td>Corrected a long-standing mistyping of the srr0 register name.</td></tr><tr><td scope="row">2008-02-27</td><td>Updated for Mac OS X 10.5, including a description of version 6 crash logs and a complete rewrite of the &quot;Crash Logs Without Symbols&quot; section to account for DWARF.</td></tr><tr><td scope="row">2006-02-28</td><td>Updated for Mac OS X 10.4.4 on both PowerPC- and Intel-based computers.  Included a description of version 3 and version 4 crash logs, and CrashReporterPrefs.</td></tr><tr><td scope="row">2004-09-09</td><td>Describes CrashReporter and how to debug with crash logs.</td></tr></table><p><b>Posted:</b> 2008-04-01</p>
<!-- END CONTENTS -->
</td></tr></table>
<!-- END WIDE COLUMN -->
<!-- END MAIN CONTENT -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn2004/tn2123.html%3Fid%3DDTS10003386-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn2004/tn2123.html%3Fid%3DDTS10003386-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn2004/tn2123.html%3Fid%3DDTS10003386-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

<!-- START BOTTOM APPLE NAVIGATION -->
<!--#include virtual="/includes/footer"-->
<!-- END BOTTOM APPLE NAVIGATION -->
<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->
</body></html>