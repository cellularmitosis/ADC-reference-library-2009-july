<html><head><title>Mac OS X
 Manual Page For perlfaq3(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlfaq3" title="Mac OS X
 Manual Page for perlfaq3(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlfaq3"; name=perlfaq3(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLFAQ3(1)                           Perl Programmers Reference Guide                           PERLFAQ3(1)



<b>NAME</b>
       perlfaq3 - Programming Tools ($Revision: 1.56 $, $Date: 2005/12/31 00:54:37 $)

<b>DESCRIPTION</b>
       This section of the FAQ answers questions related to programmer tools and programming support.

       <b>How</b> <b>do</b> <b>I</b> <b>do</b> <b>(anything)?</b>

       Have you looked at CPAN (see perlfaq2)?  The chances are that someone has already written a module
       that can solve your problem.  Have you read the appropriate manpages?  Here's a brief index:

               Basics          perldata, perlvar, perlsyn, perlop, perlsub
               Execution       perlrun, perldebug
               Functions       perlfunc
               Objects         perlref, perlmod, perlobj, perltie
               Data Structures perlref, perllol, perldsc
               Modules         perlmod, perlmodlib, perlsub
               Regexes         perlre, perlfunc, perlop, perllocale
               Moving to perl5 perltrap, perl
               Linking w/C     perlxstut, perlxs, perlcall, perlguts, perlembed
               Various         <a href="http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz">http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz</a>
                               (not a man-page but still useful, a collection
                                of various essays on Perl techniques)

       A crude table of contents for the Perl manpage set is found in perltoc.

       <b>How</b> <b>can</b> <b>I</b> <b>use</b> <b>Perl</b> <b>interactively?</b>

       The typical approach uses the Perl debugger, described in the <a href="perldebug.1.html#//apple_ref/doc/man/1/perldebug"><u>perldebug</u>(1)</a> manpage, on an "empty"
       program, like this:

           perl -de 42

       Now just type in any legal Perl code, and it will be immediately evaluated.  You can also examine the
       symbol table, get stack backtraces, check variable values, set breakpoints, and other operations typ-
       ically found in symbolic debuggers.

       <b>Is</b> <b>there</b> <b>a</b> <b>Perl</b> <b>shell?</b>

       The psh (Perl sh) is currently at version 1.8. The Perl Shell is a shell that combines the interac-
       tive nature of a Unix shell with the power of Perl. The goal is a full featured shell that behaves as
       expected for normal shell activity and uses Perl syntax and functionality for control-flow statements
       and other things. You can get psh at <a href="http://sourceforge.net/projects/psh/">http://sourceforge.net/projects/psh/</a> .

       Zoidberg is a similar project and provides a shell written in perl, configured in perl and operated
       in perl. It is intended as a login shell and development environment. It can be found at <a href="http://zoidberg.sf.net/">http://zoid-</a>
       <a href="http://zoidberg.sf.net/">berg.sf.net/</a> or your local CPAN mirror.

       The Shell.pm module (distributed with Perl) makes Perl try commands which aren't part of the Perl
       language as shell commands.  perlsh from the source distribution is simplistic and uninteresting, but
       may still be what you want.

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>which</b> <b>modules</b> <b>are</b> <b>installed</b> <b>on</b> <b>my</b> <b>system?</b>

       You can use the ExtUtils::Installed module to show all installed distributions, although it can take
       awhile to do its magic.  The standard library which comes with Perl just shows up as "Perl" (although
       you can get those with Module::CoreList).

               use ExtUtils::Installed;

               my $inst    = ExtUtils::Installed-&gt;new();
               my @modules = $inst-&gt;modules();

       If you want a list of all of the Perl module filenames, you can use File::Find::Rule.

               use File::Find::Rule;

               my @files = File::Find::Rule-&gt;file()-&gt;name( '*.pm' )-&gt;in( @INC );

       If you do not have that module, you can do the same thing with File::Find which is part of the stan-
       dard library.

           use File::Find;
           my @files;

           find(
             sub {
               push @files, $File::Find::name
                       if -f $File::Find::name &amp;&amp; /\.pm$/
               },

             @INC
             );

               print join "\n", @files;

       If you simply need to quickly check to see if a module is available, you can check for its documenta-
       tion.  If you can read the documentation the module is most likely installed.  If you cannot read the
       documentation, the module might not have any (in rare cases).

               prompt% perldoc Module::Name

       You can also try to include the module in a one-liner to see if perl finds it.

               perl -MModule::Name -e1

       <b>How</b> <b>do</b> <b>I</b> <b>debug</b> <b>my</b> <b>Perl</b> <b>programs?</b>

       Have you tried "use warnings" or used "-w"?  They enable warnings to detect dubious practices.

       Have you tried "use strict"?  It prevents you from using symbolic references, makes you predeclare
       any subroutines that you call as bare words, and (probably most importantly) forces you to predeclare
       your variables with "my", "our", or "use vars".

       Did you check the return values of each and every system call?  The operating system (and thus Perl)
       tells you whether they worked, and if not why.

         open(FH, "&gt; /etc/cantwrite")
           or die "Couldn't write to /etc/cantwrite: $!\n";

       Did you read perltrap?  It's full of gotchas for old and new Perl programmers and even has sections
       for those of you who are upgrading from languages like <u>awk</u> and <u>C</u>.

       Have you tried the Perl debugger, described in perldebug?  You can step through your program and see
       what it's doing and thus work out why what it's doing isn't what it should be doing.

       <b>How</b> <b>do</b> <b>I</b> <b>profile</b> <b>my</b> <b>Perl</b> <b>programs?</b>

       You should get the Devel::DProf module from the standard distribution (or separately on CPAN) and
       also use Benchmark.pm from the standard distribution.  The Benchmark module lets you time specific
       portions of your code, while Devel::DProf gives detailed breakdowns of where your code spends its
       time.

       Here's a sample use of Benchmark:

         use Benchmark;

         @junk = `cat /etc/motd`;
         $count = 10_000;

         timethese($count, {
                   'map' =&gt; sub { my @a = @junk;
                                  map { s/a/b/ } @a;
                                  return @a },
                   'for' =&gt; sub { my @a = @junk;
                                  for (@a) { s/a/b/ };
                                  return @a },
                  });

       This is what it prints (on one machine--your results will be dependent on your hardware, operating
       system, and the load on your machine):

         Benchmark: timing 10000 iterations of for, map...
                for:  4 secs ( 3.97 usr  0.01 sys =  3.98 cpu)
                map:  6 secs ( 4.97 usr  0.00 sys =  4.97 cpu)

       Be aware that a good benchmark is very hard to write.  It only tests the data you give it and proves
       little about the differing complexities of contrasting algorithms.

       <b>How</b> <b>do</b> <b>I</b> <b>cross-reference</b> <b>my</b> <b>Perl</b> <b>programs?</b>

       The B::Xref module can be used to generate cross-reference reports for Perl programs.

           perl -MO=Xref[,OPTIONS] scriptname.plx

       <b>Is</b> <b>there</b> <b>a</b> <b>pretty-printer</b> <b>(formatter)</b> <b>for</b> <b>Perl?</b>

       Perltidy is a Perl script which indents and reformats Perl scripts to make them easier to read by
       trying to follow the rules of the perlstyle. If you write Perl scripts, or spend much time reading
       them, you will probably find it useful.  It is available at <a href="http://perltidy.sourceforge.net">http://perltidy.sourceforge.net</a>

       Of course, if you simply follow the guidelines in perlstyle, you shouldn't need to reformat.  The
       habit of formatting your code as you write it will help prevent bugs.  Your editor can and should
       help you with this.  The perl-mode or newer cperl-mode for emacs can provide remarkable amounts of
       help with most (but not all) code, and even less programmable editors can provide significant assis-
       tance.  Tom Christiansen and many other VI users  swear by the following settings in vi and its
       clones:

           set ai sw=4
           map! ^O {^M}^[O^T

       Put that in your <u>.exrc</u> file (replacing the caret characters with control characters) and away you go.
       In insert mode, ^T is for indenting, ^D is for undenting, and ^O is for blockdenting-- as it were.  A
       more complete example, with comments, can be found at
       <a href="http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz">http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz</a>

       The a2ps <a href="http://www-inf.enst.fr/%7Edemaille/a2ps/black+white.ps.gz">http://www-inf.enst.fr/%7Edemaille/a2ps/black+white.ps.gz</a> does lots of things related to
       generating nicely printed output of documents, as does enscript at <a href="http://people.ssh.fi/mtr/genscript/">http://people.ssh.fi/mtr/gen-</a>
       <a href="http://people.ssh.fi/mtr/genscript/">script/</a> .

       <b>Is</b> <b>there</b> <b>a</b> <b>ctags</b> <b>for</b> <b>Perl?</b>

       (contributed by brian d foy)

       Exuberent ctags supports Perl: <a href="http://ctags.sourceforge.net/">http://ctags.sourceforge.net/</a>

       You might also try pltags: <a href="http://www.mscha.com/pltags.zip">http://www.mscha.com/pltags.zip</a>

       <b>Is</b> <b>there</b> <b>an</b> <b>IDE</b> <b>or</b> <b>Windows</b> <b>Perl</b> <b>Editor?</b>

       Perl programs are just plain text, so any editor will do.

       If you're on Unix, you already have an IDE--Unix itself.  The UNIX philosophy is the philosophy of
       several small tools that each do one thing and do it well.  It's like a carpenter's toolbox.

       If you want an IDE, check the following (in alphabetical order, not order of preference):

       Eclipse
           <a href="http://e-p-i-c.sf.net/">http://e-p-i-c.sf.net/</a>

           The Eclipse Perl Integration Project integrates Perl editing/debugging with Eclipse.

       Enginsite
           <a href="http://www.enginsite.com/">http://www.enginsite.com/</a>

           Perl Editor by EngInSite is a complete integrated development environment (IDE) for creating,
           testing, and  debugging  Perl scripts; the tool runs on Windows 9x/NT/2000/XP or later.

       Komodo
           <a href="http://www.ActiveState.com/Products/Komodo/">http://www.ActiveState.com/Products/Komodo/</a>

           ActiveState's cross-platform (as of October 2004, that's Windows, Linux, and Solaris), multi-lan-
           guage IDE has Perl support, including a regular expression debugger and remote debugging.

       Open Perl IDE
           <a href="http://open-perl-ide.sourceforge.net/">http://open-perl-ide.sourceforge.net/</a>

           Open Perl IDE is an integrated development environment for writing and debugging Perl scripts
           with ActiveState's ActivePerl distribution under Windows 95/98/NT/2000.

       OptiPerl
           <a href="http://www.optiperl.com/">http://www.optiperl.com/</a>

           OptiPerl is a Windows IDE with simulated CGI environment, including debugger and syntax high-
           lighting editor.

       PerlBuilder
           <a href="http://www.solutionsoft.com/perl.htm">http://www.solutionsoft.com/perl.htm</a>

           PerlBuidler is an integrated development environment for Windows that supports Perl development.

       visiPerl+
           <a href="http://helpconsulting.net/visiperl/">http://helpconsulting.net/visiperl/</a>

           From Help Consulting, for Windows.

       Visual Perl
           <a href="http://www.activestate.com/Products/Visual_Perl/">http://www.activestate.com/Products/Visual_Perl/</a>

           Visual Perl is a Visual Studio.NET plug-in from ActiveState.

       Zeus
           <a href="http://www.zeusedit.com/lookmain.html">http://www.zeusedit.com/lookmain.html</a>

           Zeus for Window is another Win32 multi-language editor/IDE that comes with support for Perl:

       For editors: if you're on Unix you probably have vi or a vi clone already, and possibly an emacs too,
       so you may not need to download anything. In any emacs the cperl-mode (M-x cperl-mode) gives you per-
       haps the best available Perl editing mode in any editor.

       If you are using Windows, you can use any editor that lets you work with plain text, such as NotePad
       or WordPad.  Word processors, such as Microsoft Word or WordPerfect, typically do not work since they
       insert all sorts of behind-the-scenes information, although some allow you to save files as "Text
       Only". You can also download text editors designed specifically for programming, such as Textpad (
       <a href="http://www.textpad.com/">http://www.textpad.com/</a> ) and UltraEdit ( <a href="http://www.ultraedit.com/">http://www.ultraedit.com/</a> ), among others.

       If you are using MacOS, the same concerns apply.  MacPerl (for Classic environments) comes with a
       simple editor. Popular external editors are BBEdit ( <a href="http://www.bbedit.com/">http://www.bbedit.com/</a> ) or Alpha (
       <a href="http://www.his.com/~jguyer/Alpha/Alpha8.html">http://www.his.com/~jguyer/Alpha/Alpha8.html</a> ). MacOS X users can use Unix editors as well. Neil Bow-
       ers (the man behind Geekcruises) has a list of Mac editors that can handle Perl ( <a href="http://www.neilbowers.org/macperleditors.html">http://www.neilbow-</a>
       <a href="http://www.neilbowers.org/macperleditors.html">ers.org/macperleditors.html</a> ).

       GNU Emacs
           <a href="http://www.gnu.org/software/emacs/windows/ntemacs.html">http://www.gnu.org/software/emacs/windows/ntemacs.html</a>

       MicroEMACS
           <a href="http://www.microemacs.de/">http://www.microemacs.de/</a>

       XEmacs
           <a href="http://www.xemacs.org/Download/index.html">http://www.xemacs.org/Download/index.html</a>

       Jed <a href="http://space.mit.edu/~davis/jed/">http://space.mit.edu/~davis/jed/</a>

       or a vi clone such as

       Elvis
           <a href="ftp://ftp.cs.pdx.edu/pub/elvis/">ftp://ftp.cs.pdx.edu/pub/elvis/</a> <a href="http://www.fh-wedel.de/elvis/">http://www.fh-wedel.de/elvis/</a>

       Vile
           <a href="http://dickey.his.com/vile/vile.html">http://dickey.his.com/vile/vile.html</a>

       Vim <a href="http://www.vim.org/">http://www.vim.org/</a>

       For vi lovers in general, Windows or elsewhere:

               <a href="http://www.thomer.com/thomer/vi/vi.html">http://www.thomer.com/thomer/vi/vi.html</a>

       nvi ( <a href="http://www.bostic.com/vi/">http://www.bostic.com/vi/</a> , available from CPAN in src/misc/) is yet another vi clone, unfortu-
       nately not available for Windows, but in UNIX platforms you might be interested in trying it out,
       firstly because strictly speaking it is not a vi clone, it is the real vi, or the new incarnation of
       it, and secondly because you can embed Perl inside it to use Perl as the scripting language.  nvi is
       not alone in this, though: at least also vim and vile offer an embedded Perl.

       The following are Win32 multilanguage editor/IDESs that support Perl:

       Codewright
           <a href="http://www.borland.com/codewright/">http://www.borland.com/codewright/</a>

       MultiEdit
           <a href="http://www.MultiEdit.com/">http://www.MultiEdit.com/</a>

       SlickEdit
           <a href="http://www.slickedit.com/">http://www.slickedit.com/</a>

       There is also a toyedit Text widget based editor written in Perl that is distributed with the Tk mod-
       ule on CPAN.  The ptkdb ( <a href="http://world.std.com/~aep/ptkdb/">http://world.std.com/~aep/ptkdb/</a> ) is a Perl/tk based debugger that acts as
       a development environment of sorts.  Perl Composer ( <a href="http://perlcomposer.sourceforge.net/">http://perlcomposer.sourceforge.net/</a> ) is an IDE
       for Perl/Tk GUI creation.

       In addition to an editor/IDE you might be interested in a more powerful shell environment for Win32.
       Your options include

       Bash
           from the Cygwin package ( <a href="http://sources.redhat.com/cygwin/">http://sources.redhat.com/cygwin/</a> )

       Ksh from the MKS Toolkit ( <a href="http://www.mks.com/">http://www.mks.com/</a> ), or the Bourne shell of the U/WIN environment (
           <a href="http://www.research.att.com/sw/tools/uwin/">http://www.research.att.com/sw/tools/uwin/</a> )

       Tcsh
           <a href="ftp://ftp.astron.com/pub/tcsh/">ftp://ftp.astron.com/pub/tcsh/</a> , see also <a href="http://www.primate.wisc.edu/software/csh-tcsh-book/">http://www.primate.wisc.edu/software/csh-tcsh-book/</a>

       Zsh <a href="ftp://ftp.blarg.net/users/amol/zsh/">ftp://ftp.blarg.net/users/amol/zsh/</a> , see also <a href="http://www.zsh.org/">http://www.zsh.org/</a>

       MKS and U/WIN are commercial (U/WIN is free for educational and research purposes), Cygwin is covered
       by the GNU Public License (but that shouldn't matter for Perl use).  The Cygwin, MKS, and U/WIN all
       contain (in addition to the shells) a comprehensive set of standard UNIX toolkit utilities.

       If you're transferring text files between Unix and Windows using FTP be sure to transfer them in
       ASCII mode so the ends of lines are appropriately converted.

       On Mac OS the MacPerl Application comes with a simple 32k text editor that behaves like a rudimentary
       IDE.  In contrast to the MacPerl Application the MPW Perl tool can make use of the MPW Shell itself
       as an editor (with no 32k limit).

       Affrus
           is a full Perl development environment with full debugger support ( <a href="http://www.latenightsw.com">http://www.latenightsw.com</a> ).

       Alpha
           is an editor, written and extensible in Tcl, that nonetheless has built in support for several
           popular markup and programming languages including Perl and HTML (
           <a href="http://www.his.com/~jguyer/Alpha/Alpha8.html">http://www.his.com/~jguyer/Alpha/Alpha8.html</a> ).

       BBEdit and BBEdit Lite
           are text editors for Mac OS that have a Perl sensitivity mode ( <a href="http://web.barebones.com/">http://web.barebones.com/</a> ).

       Pepper and Pe are programming language sensitive text editors for Mac OS X and BeOS respectively (
       <a href="http://www.hekkelman.com/">http://www.hekkelman.com/</a> ).

       <b>Where</b> <b>can</b> <b>I</b> <b>get</b> <b>Perl</b> <b>macros</b> <b>for</b> <b>vi?</b>

       For a complete version of Tom Christiansen's vi configuration file, see
       <a href="http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz">http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz</a> , the standard benchmark file for
       vi emulators.  The file runs best with nvi, the current version of vi out of Berkeley, which inciden-
       tally can be built with an embedded Perl interpreter--see <a href="http://www.cpan.org/src/misc/">http://www.cpan.org/src/misc/</a> .

       <b>Where</b> <b>can</b> <b>I</b> <b>get</b> <b>perl-mode</b> <b>for</b> <b>emacs?</b>

       Since Emacs version 19 patchlevel 22 or so, there have been both a perl-mode.el and support for the
       Perl debugger built in.  These should come with the standard Emacs 19 distribution.

       In the Perl source directory, you'll find a directory called "emacs", which contains a cperl-mode
       that color-codes keywords, provides context-sensitive help, and other nifty things.

       Note that the perl-mode of emacs will have fits with "main'foo" (single quote), and mess up the
       indentation and highlighting.  You are probably using "main::foo" in new Perl code anyway, so this
       shouldn't be an issue.

       <b>How</b> <b>can</b> <b>I</b> <b>use</b> <b>curses</b> <b>with</b> <b>Perl?</b>

       The Curses module from CPAN provides a dynamically loadable object module interface to a curses
       library.  A small demo can be found at the directory <a href="http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz">http://www.cpan.org/authors/Tom_Chris-</a>
       <a href="http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz">tiansen/scripts/rep.gz</a> ; this program repeats a command and updates the screen as needed, rendering
       <b>rep</b> <b>ps</b> <b>axu</b> similar to <b>top</b>.

       <b>How</b> <b>can</b> <b>I</b> <b>use</b> <b>X</b> <b>or</b> <b>Tk</b> <b>with</b> <b>Perl?</b>

       Tk is a completely Perl-based, object-oriented interface to the Tk toolkit that doesn't force you to
       use Tcl just to get at Tk.  Sx is an interface to the Athena Widget set.  Both are available from
       CPAN.  See the directory <a href="http://www.cpan.org/modules/by-category/08_User_Interfaces/">http://www.cpan.org/modules/by-category/08_User_Interfaces/</a>

       Invaluable for Perl/Tk programming are the Perl/Tk FAQ at <a href="http://phaseit.net/claird/comp.lang.perl.tk/ptkFAQ.html">http://pha-</a>
       <a href="http://phaseit.net/claird/comp.lang.perl.tk/ptkFAQ.html">seit.net/claird/comp.lang.perl.tk/ptkFAQ.html</a> , the Perl/Tk Reference Guide available at
       <a href="http://www.cpan.org/authors/Stephen_O_Lidie/">http://www.cpan.org/authors/Stephen_O_Lidie/</a> , and the online manpages at
       <a href="http://www-users.cs.umn.edu/%7Eamundson/perl/perltk/toc.html">http://www-users.cs.umn.edu/%7Eamundson/perl/perltk/toc.html</a> .

       <b>How</b> <b>can</b> <b>I</b> <b>make</b> <b>my</b> <b>Perl</b> <b>program</b> <b>run</b> <b>faster?</b>

       The best way to do this is to come up with a better algorithm.  This can often make a dramatic dif-
       ference.  Jon Bentley's book <u>Programming</u> <u>Pearls</u> (that's not a misspelling!)  has some good tips on
       optimization, too.  Advice on benchmarking boils down to: benchmark and profile to make sure you're
       optimizing the right part, look for better algorithms instead of microtuning your code, and when all
       else fails consider just buying faster hardware.  You will probably want to read the answer to the
       earlier question "How do I profile my Perl programs?" if you haven't done so already.

       A different approach is to autoload seldom-used Perl code.  See the AutoSplit and AutoLoader modules
       in the standard distribution for that.  Or you could locate the bottleneck and think about writing
       just that part in C, the way we used to take bottlenecks in C code and write them in assembler.  Sim-
       ilar to rewriting in C, modules that have critical sections can be written in C (for instance, the
       PDL module from CPAN).

       If you're currently linking your perl executable to a shared <u>libc.so</u>, you can often gain a 10-25%
       performance benefit by rebuilding it to link with a static libc.a instead.  This will make a bigger
       perl executable, but your Perl programs (and programmers) may thank you for it.  See the <u>INSTALL</u> file
       in the source distribution for more information.

       The undump program was an ancient attempt to speed up Perl program by storing the already-compiled
       form to disk.  This is no longer a viable option, as it only worked on a few architectures, and
       wasn't a good solution anyway.

       <b>How</b> <b>can</b> <b>I</b> <b>make</b> <b>my</b> <b>Perl</b> <b>program</b> <b>take</b> <b>less</b> <b>memory?</b>

       When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem.
       Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even
       more.  While there's still a lot to be done, recent releases have been addressing these issues.  For
       example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no
       reallocation.

       In some cases, using <u>substr()</u> or <u>vec()</u> to simulate arrays can be highly beneficial.  For example, an
       array of a thousand booleans will take at least 20,000 bytes of space, but it can be turned into one
       125-byte bit vector--a considerable memory savings.  The standard Tie::SubstrHash module can also
       help for certain types of data structure.  If you're working with specialist data structures (matri-
       ces, for instance) modules that implement these in C may use less memory than equivalent Perl mod-
       ules.

       Another thing to try is learning whether your Perl was compiled with the system malloc or with Perl's
       builtin malloc.  Whichever one it is, try using the other one and see whether this makes a differ-
       ence.  Information about malloc is in the <u>INSTALL</u> file in the source distribution.  You can find out
       whether you are using perl's malloc by typing "perl -V:usemymalloc".

       Of course, the best way to save memory is to not do anything to waste it in the first place. Good
       programming practices can go a long way toward this:

       * Don't slurp!
           Don't read an entire file into memory if you can process it line by line. Or more concretely, use
           a loop like this:

                   #
                   # Good Idea
                   #
                   while (&lt;FILE&gt;) {
                      # ...
                   }

           instead of this:

                   #
                   # Bad Idea
                   #
                   @data = &lt;FILE&gt;;
                   foreach (@data) {
                       # ...
                   }

           When the files you're processing are small, it doesn't much matter which way you do it, but it
           makes a huge difference when they start getting larger.

       * Use map and grep selectively
           Remember that both map and grep expect a LIST argument, so doing this:

                   @wanted = grep {/pattern/} &lt;FILE&gt;;

           will cause the entire file to be slurped. For large files, it's better to loop:

                   while (&lt;FILE&gt;) {
                           push(@wanted, $_) if /pattern/;
                   }

       * Avoid unnecessary quotes and stringification
           Don't quote large strings unless absolutely necessary:

                   my $copy = "$large_string";

           makes 2 copies of $large_string (one for $copy and another for the quotes), whereas

                   my $copy = $large_string;

           only makes one copy.

           Ditto for stringifying large arrays:

                   {
                           local $, = "\n";
                           print @big_array;
                   }

           is much more memory-efficient than either

                   print join "\n", @big_array;

           or

                   {
                           local $" = "\n";
                           print "@big_array";
                   }

       * Pass by reference
           Pass arrays and hashes by reference, not by value. For one thing, it's the only way to pass mul-
           tiple lists or hashes (or both) in a single call/return. It also avoids creating a copy of all
           the contents. This requires some judgment, however, because any changes will be propagated back
           to the original data. If you really want to mangle (er, modify) a copy, you'll have to sacrifice
           the memory needed to make one.

       * Tie large variables to disk.
           For "big" data stores (i.e. ones that exceed available memory) consider using one of the DB mod-
           ules to store it on disk instead of in RAM. This will incur a penalty in access time, but that's
           probably better than causing your hard disk to thrash due to massive swapping.

       <b>Is</b> <b>it</b> <b>safe</b> <b>to</b> <b>return</b> <b>a</b> <b>reference</b> <b>to</b> <b>local</b> <b>or</b> <b>lexical</b> <b>data?</b>

       Yes. Perl's garbage collection system takes care of this so everything works out right.

           sub makeone {
               my @a = ( 1 .. 10 );
               return \@a;
           }

           for ( 1 .. 10 ) {
               push @many, makeone();
           }

           print $many[4][5], "\n";

           print "@many\n";

       <b>How</b> <b>can</b> <b>I</b> <b>free</b> <b>an</b> <b>array</b> <b>or</b> <b>hash</b> <b>so</b> <b>my</b> <b>program</b> <b>shrinks?</b>

       (contributed by Michael Carman)

       You usually can't. Memory allocated to lexicals (i.e. <u>my()</u> variables) cannot be reclaimed or reused
       even if they go out of scope. It is reserved in case the variables come back into scope. Memory allo-
       cated to global variables can be reused (within your program) by using <u>undef()</u>ing and/or <u>delete()</u>.

       On most operating systems, memory allocated to a program can never be returned to the system. That's
       why long-running programs sometimes re- exec themselves. Some operating systems (notably, systems
       that use <a href="../man2/mmap.2.html#//apple_ref/doc/man/2/mmap"><u>mmap</u>(2)</a> for allocating large chunks of memory) can reclaim memory that is no longer used,
       but on such systems, perl must be configured and compiled to use the OS's malloc, not perl's.

       In general, memory allocation and de-allocation isn't something you can or should be worrying about
       much in Perl.

       See also "How can I make my Perl program take less memory?"

       <b>How</b> <b>can</b> <b>I</b> <b>make</b> <b>my</b> <b>CGI</b> <b>script</b> <b>more</b> <b>efficient?</b>

       Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program
       has additional issues.  It may be run several times per second.  Given that each time it runs it will
       need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a
       killer.  Compiling into C <b>isn't</b> <b>going</b> <b>to</b> <b>help</b> <b>you</b> because the process start-up overhead is where the
       bottleneck is.

       There are two popular ways to avoid this overhead.  One solution involves running the Apache HTTP
       server (available from <a href="http://www.apache.org/">http://www.apache.org/</a> ) with either of the mod_perl or mod_fastcgi plugin
       modules.

       With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an
       embedded Perl interpreter which pre-compiles your script and then executes it within the same address
       space without forking.  The Apache extension also gives Perl access to the internal server API, so
       modules written in Perl can do just about anything a module written in C can.  For more on mod_perl,
       see <a href="http://perl.apache.org/">http://perl.apache.org/</a>

       With the FCGI module (from CPAN) and the mod_fastcgi module (available from <a href="http://www.fastcgi.com/">http://www.fastcgi.com/</a> )
       each of your Perl programs becomes a permanent CGI daemon process.

       Both of these solutions can have far-reaching effects on your system and on the way you write your
       CGI programs, so investigate them with care.

       See <a href="http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/">http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/</a> .

       <b>How</b> <b>can</b> <b>I</b> <b>hide</b> <b>the</b> <b>source</b> <b>for</b> <b>my</b> <b>Perl</b> <b>program?</b>

       Delete it. :-) Seriously, there are a number of (mostly unsatisfactory) solutions with varying levels
       of "security".

       First of all, however, you <u>can't</u> take away read permission, because the source code has to be read-
       able in order to be compiled and interpreted.  (That doesn't mean that a CGI script's source is read-
       able by people on the web, though--only by people with access to the filesystem.)  So you have to
       leave the permissions at the socially friendly 0755 level.

       Some people regard this as a security problem.  If your program does insecure things and relies on
       people not knowing how to exploit those insecurities, it is not secure.  It is often possible for
       someone to determine the insecure things and exploit them without viewing the source.  Security
       through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.

       You can try using encryption via source filters (Starting from Perl 5.8 the Filter::Simple and Fil-
       ter::Util::Call modules are included in the standard distribution), but any decent programmer will be
       able to decrypt it.  You can try using the byte code compiler and interpreter described below, but
       the curious might still be able to de-compile it.  You can try using the native-code compiler
       described below, but crackers might be able to disassemble it.  These pose varying degrees of diffi-
       culty to people wanting to get at your code, but none can definitively conceal it (true of every lan-
       guage, not just Perl).

       It is very easy to recover the source of Perl programs.  You simply feed the program to the perl
       interpreter and use the modules in the B:: hierarchy.  The B::Deparse module should be able to defeat
       most attempts to hide source.  Again, this is not unique to Perl.

       If you're concerned about people profiting from your code, then the bottom line is that nothing but a
       restrictive license will give you legal security.  License your software and pepper it with threaten-
       ing statements like "This is unpublished proprietary software of XYZ Corp.  Your access to it does
       not give you permission to use it blah blah blah."  We are not lawyers, of course, so you should see
       a lawyer if you want to be sure your license's wording will stand up in court.

       <b>How</b> <b>can</b> <b>I</b> <b>compile</b> <b>my</b> <b>Perl</b> <b>program</b> <b>into</b> <b>byte</b> <b>code</b> <b>or</b> <b>C?</b>

       (contributed by brian d foy)

       In general, you can't do this.  There are some things that may work for your situation though.  Peo-
       ple usually ask this question because they want to distribute their works without giving away the
       source code, and most solutions trade disk space for convenience.  You probably won't see much of a
       speed increase either, since most solutions simply bundle a Perl interpreter in the final product
       (but see "How can I make my Perl program run faster?").

       The Perl Archive Toolkit ( <a href="http://par.perl.org/index.cgi">http://par.perl.org/index.cgi</a> ) is Perl's analog to Java's JAR.  It's
       freely available and on CPAN ( <a href="http://search.cpan.org/dist/PAR/">http://search.cpan.org/dist/PAR/</a> ).

       The B::* namespace, often called "the Perl compiler", but is really a way for Perl programs to peek
       at its innards rather than create pre-compiled versions of your program.  However. the B::Bytecode
       module can turn your script  into a bytecode format that could be loaded later by the ByteLoader mod-
       ule and executed as a regular Perl script.

       There are also some commercial products that may work for you, although you have to buy a license for
       them.

       The Perl Dev Kit ( <a href="http://www.activestate.com/Products/Perl_Dev_Kit/">http://www.activestate.com/Products/Perl_Dev_Kit/</a> ) from ActiveState can "Turn
       your Perl programs into ready-to-run executables for HP-UX, Linux, Solaris and Windows."

       Perl2Exe ( <a href="http://www.indigostar.com/perl2exe.htm">http://www.indigostar.com/perl2exe.htm</a> ) is a command line program for converting perl
       scripts to executable files.  It targets both Windows and unix platforms.

       <b>How</b> <b>can</b> <b>I</b> <b>compile</b> <b>Perl</b> <b>into</b> <b>Java?</b>

       You can also integrate Java and Perl with the Perl Resource Kit from O'Reilly Media.  See
       <a href="http://www.oreilly.com/catalog/prkunix/">http://www.oreilly.com/catalog/prkunix/</a> .

       Perl 5.6 comes with Java Perl Lingo, or JPL.  JPL, still in development, allows Perl code to be
       called from Java.  See jpl/README in the Perl source tree.

       <b>How</b> <b>can</b> <b>I</b> <b>get</b> <b>"#!perl"</b> <b>to</b> <b>work</b> <b>on</b> <b>[MS-DOS,NT,...]?</b>

       For OS/2 just use

           extproc perl -S -your_switches

       as the first line in "*.cmd" file ("-S" due to a bug in cmd.exe's "extproc" handling).  For DOS one
       should first invent a corresponding batch file and codify it in "ALTERNATE_SHEBANG" (see the <u>dosish.h</u>
       file in the source distribution for more information).

       The Win95/NT installation, when using the ActiveState port of Perl, will modify the Registry to asso-
       ciate the ".pl" extension with the perl interpreter.  If you install another port, perhaps even
       building your own Win95/NT Perl from the standard sources by using a Windows port of gcc (e.g., with
       cygwin or mingw32), then you'll have to modify the Registry yourself.  In addition to associating
       ".pl" with the interpreter, NT people can use: "SET PATHEXT=%PATHEXT%;.PL" to let them run the pro-
       gram "install-linux.pl" merely by typing "install-linux".

       Under "Classic" MacOS, a perl program will have the appropriate Creator and Type, so that double-
       clicking them will invoke the MacPerl application.  Under Mac OS X, clickable apps can be made from
       any "#!" script using Wil Sanchez' DropScript utility: <a href="http://www.wsanchez.net/software/">http://www.wsanchez.net/software/</a> .

       <u>IMPORTANT!</u>: Whatever you do, PLEASE don't get frustrated, and just throw the perl interpreter into
       your cgi-bin directory, in order to get your programs working for a web server.  This is an EXTREMELY
       big security risk.  Take the time to figure out how to do it correctly.

       <b>Can</b> <b>I</b> <b>write</b> <b>useful</b> <b>Perl</b> <b>programs</b> <b>on</b> <b>the</b> <b>command</b> <b>line?</b>

       Yes.  Read perlrun for more information.  Some examples follow.  (These assume standard Unix shell
       quoting rules.)

           # sum first and last fields
           perl -lane 'print $F[0] + $F[-1]' *

           # identify text files
           perl -le 'for(@ARGV) {print if -f &amp;&amp; -T _}' *

           # remove (most) comments from C program
           perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

           # make file a month younger than today, defeating reaper daemons
           perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *

           # find first unused uid
           perl -le '$i++ while getpwuid($i); print $i'

           # display reasonable manpath
           echo $PATH | perl -nl -072 -e '
               s![^/+]*$!man!&amp;&amp;-d&amp;&amp;!$s{$_}++&amp;&amp;push@m,$_;END{print"@m"}'

       OK, the last one was actually an Obfuscated Perl Contest entry. :-)

       <b>Why</b> <b>don't</b> <b>Perl</b> <b>one-liners</b> <b>work</b> <b>on</b> <b>my</b> <b>DOS/Mac/VMS</b> <b>system?</b>

       The problem is usually that the command interpreters on those systems have rather different ideas
       about quoting than the Unix shells under which the one-liners were created.  On some systems, you may
       have to change single-quotes to double ones, which you must <u>NOT</u> do on Unix or Plan9 systems.  You
       might also have to change a single % to a %%.

       For example:

           # Unix
           perl -e 'print "Hello world\n"'

           # DOS, etc.
           perl -e "print \"Hello world\n\""

           # Mac
           print "Hello world\n"
            (then Run "Myscript" or Shift-Command-R)

           # MPW
           perl -e 'print "Hello world\n"'

           # VMS
           perl -e "print ""Hello world\n"""

       The problem is that none of these examples are reliable: they depend on the command interpreter.
       Under Unix, the first two often work. Under DOS, it's entirely possible that neither works.  If 4DOS
       was the command shell, you'd probably have better luck like this:

         perl -e "print &lt;Ctrl-x&gt;"Hello world\n&lt;Ctrl-x&gt;""

       Under the Mac, it depends which environment you are using.  The MacPerl shell, or MPW, is much like
       Unix shells in its support for several quoting variants, except that it makes free use of the Mac's
       non-ASCII characters as control characters.

       Using <u>qq()</u>, q(), and <u>qx()</u>, instead of "double quotes", 'single quotes', and `backticks`, may make
       one-liners easier to write.

       There is no general solution to all of this.  It is a mess.

       [Some of this answer was contributed by Kenneth Albanowski.]

       <b>Where</b> <b>can</b> <b>I</b> <b>learn</b> <b>about</b> <b>CGI</b> <b>or</b> <b>Web</b> <b>programming</b> <b>in</b> <b>Perl?</b>

       For modules, get the CGI or LWP modules from CPAN.  For textbooks, see the two especially dedicated
       to web stuff in the question on books.  For problems and questions related to the web, like "Why do I
       get 500 Errors" or "Why doesn't it run from the browser right when it runs fine on the command line",
       see the troubleshooting guides and references in perlfaq9 or in the CGI MetaFAQ:

               <a href="http://www.perl.org/CGI_MetaFAQ.html">http://www.perl.org/CGI_MetaFAQ.html</a>

       <b>Where</b> <b>can</b> <b>I</b> <b>learn</b> <b>about</b> <b>object-oriented</b> <b>Perl</b> <b>programming?</b>

       A good place to start is perltoot, and you can use perlobj, perlboot, perltoot, perltooc, and perlbot
       for reference.

       A good book on OO on Perl is the "Object-Oriented Perl" by Damian Conway from Manning Publications,
       or "Learning Perl References, Objects, &amp; Modules" by Randal Schwartz and Tom Phoenix from O'Reilly
       Media.

       <b>Where</b> <b>can</b> <b>I</b> <b>learn</b> <b>about</b> <b>linking</b> <b>C</b> <b>with</b> <b>Perl?</b>

       If you want to call C from Perl, start with perlxstut, moving on to perlxs, xsubpp, and perlguts.  If
       you want to call Perl from C, then read perlembed, perlcall, and perlguts.  Don't forget that you can
       learn a lot from looking at how the authors of existing extension modules wrote their code and solved
       their problems.

       You might not need all the power of XS. The Inline::C module lets you put C code directly in your
       Perl source. It handles all the magic to make it work. You still have to learn at least some of the
       perl API but you won't have to deal with the complexity of the XS support files.

       <b>I've</b> <b>read</b> <b>perlembed,</b> <b>perlguts,</b> <b>etc.,</b> <b>but</b> <b>I</b> <b>can't</b> <b>embed</b> <b>perl</b> <b>in</b> <b>my</b> <b>C</b> <b>program;</b> <b>what</b> <b>am</b> <b>I</b> <b>doing</b> <b>wrong?</b>

       Download the ExtUtils::Embed kit from CPAN and run `make test'.  If the tests pass, read the pods
       again and again and again.  If they fail, see perlbug and send a bug report with the output of "make
       test TEST_VERBOSE=1" along with "perl -V".

       <b>When</b> <b>I</b> <b>tried</b> <b>to</b> <b>run</b> <b>my</b> <b>script,</b> <b>I</b> <b>got</b> <b>this</b> <b>message.</b> <b>What</b> <b>does</b> <b>it</b> <b>mean?</b>

       A complete list of Perl's error messages and warnings with explanatory text can be found in perldiag.
       You can also use the splain program (distributed with Perl) to explain the error messages:

           perl program 2&gt;diag.out
           splain [-v] [-p] diag.out

       or change your program to explain the messages for you:

           use diagnostics;

       or

           use diagnostics -verbose;

       <b>What's</b> <b>MakeMaker?</b>

       This module (part of the standard Perl distribution) is designed to write a Makefile for an extension
       module from a Makefile.PL.  For more information, see ExtUtils::MakeMaker.

<b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b>
       Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and other authors as noted. All rights
       reserved.

       This documentation is free; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       Irrespective of its distribution, all code examples here are in the public domain.  You are permitted
       and encouraged to use this code and any derivatives thereof in your own programs for fun or for
       profit as you see fit.  A simple comment in the code giving credit to the FAQ would be courteous but
       is not required.



perl v5.8.8                                      2006-01-07                                      PERLFAQ3(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq3.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq3.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq3.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
