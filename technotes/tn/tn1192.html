<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1192: ATA Interface Modules</title><meta name="keywords" content="have creator list relevant keywords here"><meta name="Description" content="Technical Note TN1192: This Technote describes how to writea device driver for an ATA host  bus controller, known asan ATA Interface Module, or AIM. An AIM is  the ATA equivalentof the SCSI Interface Module (SIM). It does not  controla device on the ATA bus, but implements a standard hardware abstraction for the bus itself."><meta name="categories" content="Devices"><meta name="week-posted" content="Nov 29, 1999 - Dec 3, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003031" title="ATA Interface Modules"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/HardwareDrivers/index.html">Hardware & Drivers</a> &gt; <a href="../../technicalnotes/HardwareDrivers/idxATA-date.html">ATA</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1192</div>
<div id="pageheadsub">ATA Interface Modules</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">         <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>        </tr>        <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <span id="menutitle">CONTENTS   <br>  <br>       </span>   </td>        </tr>        <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <!-- begin_toc -->         <P id ="menutext">         <A HREF = "#Introduction">Introduction</A><BR>         <BR>         <A HREF = "#CoreConcepts">Core Concepts</A><BR>         <BR>         <A HREF = "#ATAManagerAdditions">ATA Manager Additions</A><BR>         <BR>         <A HREF = "#AIMPackaging">AIM Packaging</A><BR>         <BR>         <A HREF = "#AIMEntryPoints">AIM Entry Points</A><BR>         <BR>         <A HREF = "#AIMActionFunctionCodes">AIM Action Function         Codes</A><BR>         <BR>         <A HREF = "#AIMSupportRoutines">AIM Support Routines</A><BR><BR><A HREF = "#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></p>  <!-- end_toc --></td>        </tr>        <tr>   <td width=300 align=left scope="row">       <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>        </tr>    </table></td>        <td width=300 valign="top" align=left><!-- begin_intro_text -->         <P id ="introtext">This Technote describes how to         write a device driver for an ATA host bus controller, known         as an ATA Interface Module, or AIM. An AIM is the ATA         equivalent of the SCSI Interface Module (SIM). It does not         control a device on the ATA bus, but implements a standard         hardware abstraction for the bus itself.</P>                  <P id = "introtext">AIMs operate at the very lowest level of the traditional         Mac OS I/O subsystem, which makes them hard to write and         hard to debug. Only experienced Mac OS device driver writers         should consider developing an AIM.</P>                  <P id = "introtext">This Note is directed at developers of ATA host bus         controller cards (typically PCI or CardBus).</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Dec 06 1999]</h3><!-- end_date --></TD>             </TR>          </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content -->         <P><A NAME="Introduction"></A></P>                  <H2>Introduction</H2>                  <P>This technote describes how to write a Mac OS device         driver for ATA host bus controller hardware. Such a driver         is known as an ATA Interface Module, or AIM. In some         respects it is the ATA equivalent to the more commonly known         SCSI Interface Module (SIM).</P>                  <P>This technote is divided into two sections. This section,         and the <A HREF = "#CoreConcepts">Core Concepts</A> sections         which follows it, represent the introductory material. They         describe high-level issues with writing AIMs; understanding         these sections is critical to writing a reliable AIM. The         remaining sections are reference material. They describe how         you can <A HREF = "#ATAManagerAdditions">register an ATA         bus</A> with ATA Manager, how you should         <A HREF = "#AIMPackaging">package your AIM</A> so that it is         recognized by ATA Manager, what         <A HREF = "#AIMEntryPoints">entry points</A> ATA Manager         expects you AIM to implement, the list of         <A HREF = "#AIMActionFunctionCodes">function codes</A> your         AIM's action routine must support, and some         <A HREF = "#AIMSupportRoutines">support routines</A> that ATA         Manager exports to support AIM implementation.</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                                    AIMs are only supported by ATA Manager 4.0 and                  above. Development of third-party ATA buses is not                  supported on older versions of ATA Manager. Device                  0/1 support is not available on some early ATA                  Manager 4.0 systems; however, your AIM should always                  support device 0/1 operations.</P>               </TD>            </TR>         </TABLE></CENTER>         <BR>         <H3>Before You Begin</H3>                  <P>Before you consider developing an AIM, you should be         familiar with the following concepts:</P>                  <UL>            <LI>The native driver model, as described in            <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/pci_srvcs/pci_srvcs.html">Designing            PCI Cards and Drivers for Power Macintosh Computers</A>.</li>                        <LI>The Mac OS ATA programming interface, as described in            <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATA            Device Software for Macintosh Computers</A> and amended            by the            <a href="http://developer.apple.com/documentation/hardware/Developer_Notes/System_Software/ATA_Device_Zero_One.pdf">ATA            Device 0/1 Software Developer's Guide</A> and DTS            Technote 1098            <A HREF = "tn1098.html">ATA            Device Software Guide Additions and Corrections</A>.</li>                        <LI>The ATA bus protocol; ANSI NCITS 317-1998 <CITE>AT            Attachment - 4 with Packet Interface Extension</CITE> is            a good reference.</li>         </UL>                  <P>You will also need the following:</P>                  <UL>            <LI>"ATA.h" from the latest version of Universal Headers.</li>                        <LI>If that version of "ATA.h" does not include the            AIM-related declarations described in this technote, you            will need the "ATAExtras.h" header file that is            <A HREF = "#Downloads">included with this technote</A>.            [2404935]</li>                        <LI>Similarly, if the libraries included with Universal            Headers does not include ATAManager stub library, you            will need the one included here.</li>                        <LI>Information about your bus controller from your            hardware vendor.</li>         </UL>     <P><A HREF = "#top">Back to top</A></P><A NAME="CoreConcepts"></A>                  <H2>Core Concepts</H2>                  <P>Before starting your AIM, you should be familiar with         some fundamental concepts, as described in the following         sections.</P>                  <H3>Theory of Operation</H3>                  <P>AIMs represent an abstraction of an ATA bus. Your AIM         isolates the ATA Manager and its clients from the         specific details of your ATA bus controller hardware. For         instance, an ATA bus may be part of a PC Card slot, or         perhaps reside on a PCI card, or may even be integrated as         part of a system chipset. Each physical ATA controller will         have specific requirements for how it is addressed, what         cycle times are supported and how they are programmed, how         interrupts from the controller are routed to the system, and         so on. By bundling the hardware-specific details of the ATA         controller in a plug-in software module, the ATA Manager         presents a consistent interface for drivers and applications         to communicate with ATA and ATAPI devices.</P>                  <P>All of the operations which directly touch the hardware         in any manner are handled by your AIM. This includes:</P>                  <UL>            <LI>describing the features of the bus controller,            primarily the supported <A HREF = "#ATAIOModes">I/O            modes</A> and cycle times, and controlling those features</li>                        <LI>preparing physical DMA transfer buffers and building            DMA programs for those buffers</li>                        <LI>alignment issues</li>                        <LI>reading and writing the device's task file registers</li>                        <LI>writing ATAPI command packets</li>                        <LI>handling ATA and ATAPI transfer operations</li>                        <LI>servicing hardware interrupts</li>                        <LI>timing out failed bus transactions            </li>            <LI>resetting the bus</li>         </UL>                  <P>Current versions of ATA Manager will only dispatch a         single request for a single device on the bus controlled by         your AIM at any given time. Overlapped ATA/ATAPI features         are not currently supported. AIMs written to the         specification in this document will never be expected to         handle concurrent requests.</P>                  <P>In general, your AIM should be interrupt-driven. It         should do as much work as it can on a request, then return         to the ATA Manager pending an interrupt from the hardware.         For instance, when you receive a request to read data, you         would set your AIM's internal flags as needed, write the         task file to the device, and then return to ATA Manager.         When the device is ready to transfer data, it will assert an         interrupt which will call your AIM's hardware interrupt         handler. Your AIM would then call         <CODE><A HREF = "#ATAFamBusEventForAIM">ATAFamBusEventForAIM</A></CODE>         to queue a secondary handler and return from the hardware         interrupt handler. ATA Manager will then call your AIM's         <CODE><A HREF = "#MyAIMHandleBusEvent">MyHandleBusEvent</A></CODE>         function where you would complete the data transfer, clear         your AIM's internal flags, and call         <CODE><A HREF = "#ATAFamIODone">ATAFamIODone</A></CODE>. It is         important that all your cleanup be done before calling         <CODE>ATAFamIODone</CODE>, because ATA Manager may call you         with another request during <CODE>ATAFamIODone</CODE>. Also,         your AIM's <CODE>MyHandleBusEvent</CODE> function may be         called immediately when calling         <CODE>ATAFamBusEventForAIM</CODE>. Other than these two         cases, the AIM will not be called reentrantly.</P>                  <P>There are some limits on the controller hardware that can         be supported by an AIM:</P>                  <UL>            <LI>Each ATA bus must be capable of simultaneous            operation, independent of any other ATA bus. If an ATA            controller chip implements two bus controllers, but they            share common wiring or a DMA engine such that only one            bus can be active at a time, then only one bus may be            supported under ATA Manager. ATA Manager has no            synchronization mechanism between buses.</li>                        <LI>ATA controllers incapable of generating interrupts            are not supported.</li>                        <LI>PCI ATA controllers which operate only in x86 "legacy            mode" (that is, they hard-decode only the lower-address            bits and cannot be relocated in PCI space) are not            supported. However, it is possible to support addressing            the controller in either memory or PCI I/O space.</li>         </UL>                  <A NAME="GlobalVariables"></A><H3>Global Variables</H3>                  <P>Your AIM should allocate its per-bus global variables in         a memory block (typically allocated use         <CODE>PoolAllocateResident</CODE>) and use ATA Manager's         per-AIM <CODE>refCon</CODE> facility to track its globals.         </P>                  <P>The reason to use the <CODE>refCon</CODE> (rather than C         <CODE>extern</CODE> and <CODE>static</CODE> variables, which         are stored in your fragment's data section) is that the ATA         Manager has a facility to update your AIM to a newer version         "on the fly." The process,         <A HREF = "#AIMUpdateProcess">described below</A>, involves         closing the CFM connection to the older version of your AIM         and replacing it with a connection to the newer version. If         you had important data in the older AIM's data section, that         data is lost when the data section is disposed as part of         closing the CFM connection. In contrast, ATA Manager         explicitly passes the <CODE>refCon</CODE> to the new version         of your AIM.</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note:</B><BR>                                    An AIM is a native driver (<CODE>'ndrv'</CODE>) and                  shares many of the properties of native drivers in                  general. One of these properties is that your AIM                  is instantiated once for each instance of your ATA                  hardware on the machine (technically, one per ATA                  node in the Name Registry). Therefore you can store                  per-bus global variables in your data section, and                  you will automatically get one copy of these global                  variables per bus.</P></TD>            </TR>         </TABLE></CENTER>         <BR>                                    <P>However, you should avoid using this strategy                  for per-bus global variables for the reason                  described above.</P>                                    <P>It is acceptable to use your data section for                  global variables as long as you have a strategy for                  passing them between versions. You could, for                  example, store the data primarily in you data                  section, push it into the AIM's <CODE>refCon</CODE>                  memory block when your AIM is suspended, and                  restore it to your data section when your AIM is                  resumed. Or you might choose to pass data between                  versions of your AIM via Name Registry properties.                  However, both of these techniques are significantly                  more convoluted than using the AIM's                  <CODE>refCon</CODE>, hence the recommendation to                  just use the <CODE>refCon</CODE> approach.</p>                                 <P>Regardless of how you allocate your global variables, you         must ensure that they are held resident in memory (in the         virtual memory sense). All of the techniques described above         guarantee this.</P>                  <P>Finally, your AIM should use PowerPC structure alignment         for its global variables. This has two advantages:</P>                  <OL>            <LI>If you do atomic operations on a global variable,            PowerPC alignment ensures that the variable is aligned            appropriate.</li>                        <LI>PowerPC alignment yields better performance for            native code than 68K alignment.</li>         </OL>                  <H3><A NAME="AIMUpdateProcess"></A>AIM Update Process</H3>                  <P>As mentioned above, the ATA Manager has a process for         updating your AIM to a newer version "on the fly," without         shutting the bus down. The ATA Manager accomplishes this in         a 7 step process:</P>                  <OL>            <LI>Open a CFM connection to the new AIM</li>                        <LI>Wait for all pending AIM requests to terminate</li>                        <LI>Block any new AIM requests from starting</li>                        <LI>Call the old AIM's suspend routine            (<CODE><A HREF = "#MyAIMSuspend">MyAIMSuspend</A></CODE>)</li>                        <LI>Call the new AIM's resume routine            (<CODE><A HREF = "#MyAIMResume">MyAIMResume</A></CODE>),            passing it the <CODE>refCon</CODE> from the old AIM</li>                        <LI>Unblock the AIM to allow bus operations to continue</li>                        <LI>Close the CFM connection to the old AIM</li>         </OL>                 <P>There are a number of important things about this process to keep in mind.</P>    <UL>            <LI>The ATA Manager finds replacement AIMs by matching            the Name Registry node name to the            <CODE>nameInfoStr</CODE> field of the            <CODE>DriverType</CODE> structure of its            <A HREF = "#TheDriverDescription">driver description</A>.            In order for your AIM to be updated, these names much            match exactly.</li>                        <LI>In addition, the ATA Manager will only update an AIM            if the <CODE>version</CODE> field of the            <CODE>DriverType</CODE> structure of its            <A HREF = "#TheDriverDescription">driver description</A> is            newer than the version of the existing AIM.</li>                        <LI>You must structure your per-bus globals such that            they can be passed from one version of your AIM to the            next. Some suggested techniques are:</li></ul>                        <BLOCKQUOTE><UL>               <LI>Using your AIM's <CODE>refCon</CODE> to store a               pointer to your per-bus storage simplifies the process               of passing this information between versions. See the               <A HREF = "#GlobalVariables">previous section</A> for               more details.</li>                              <LI>Put the version number of your AIM in your per-bus               storage so that the newer AIM knows which older               version it is taking over from (and can compensate for               known bugs, oversights, and so on).</li>                              <LI>Include some "reserved" fields in your per-bus               storage to give future versions of your AIM some room               for expansion.</li>                              <LI>You can also use Name Registry properties to pass               information between versions of your AIM.</li></ul>           </BLOCKQUOTE>            <UL>             <LI>AIM resume routines are not defined to return an            error code. You should design your AIM so that its resume            routine cannot fail.</li>         </UL>                  <H3><A NAME="AIMSynchronizationModel"></A>AIM         Synchronization Model</H3>                  <P>As long as you follow one simple rule, the ATA Manager         takes care of most of the synchronization problems in         writing an AIM. The rule is:</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note:</B><BR>When your AIM is called by anyone other than         ATA Manager, you must synchronize with ATA Manager by         posting a bus event.</P></TD>            </TR>         </TABLE></CENTER>         <BR>                     <P>Posting a bus event         (<CODE><A HREF = "#ATAFamBusEventForAIM">ATAFamBusEventForAIM</A></CODE>)         is a the way your AIM informs ATA Manager that its bus event         handler         (<CODE><A HREF = "#MyAIMHandleBusEvent">MyAIMHandleBusEvent</A></CODE>)         should be called. ATA Manager queues the bus event and         eventually calls the bus event handler when it is safe to do         so.</P>                  <P>If you follow this rule, ATA Manager guarantees that it         will never call your AIM on more than one thread of         execution at a time. So as long as you're executing within         the context of a routine that is called by ATA Manager, you         can access global variables without worrying about         synchronization issues.</P>                  <P>An obvious example of where this is useful is for         handling interrupts. As a rule, your AIM will service I/O         requests as a state machine. When ATA Manager calls your AIM         to start a request         (<CODE><A HREF = "#MyAIMAction">MyAIMAction</A></CODE>), your         AIM will start an asynchronous I/O operation and then return         to ATA Manager. When the asynchronous operation completes,         your hardware will interrupt the processor, and system         software will execute your interrupt service routine. This         interrupt service routine executes at hardware interrupt         time. If you access your global variables from it, you must         worry about synchronizing that access with lower execution         levels. The solution is for your AIM to post a bus event.         ATA Manager will defer calling your bus event handler         (<CODE><A HREF = "#MyAIMHandleBusEvent">MyAIMHandleBusEvent</A></CODE>)         until it can guarantee that it is the only thread of         execution running inside your AIM. Your bus event handler         can therefore safely access global variables without         worrying about synchronization.</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                                    Your interrupt service routine must perform the                  following tasks as quickly as possible:</P>               </TD>            </TR>         </TABLE></CENTER>         <BR>                                    <UL>                     <LI>Identify the source of the interrupt.</LI>                                          <LI>If the interrupt is from your device, clear                     the source of the interrupt and post a bus                     event.</LI>                  </UL>                                    <P>The bulk of the work in handling an interrupt                  should be done in your bus event handler.</P>                                    <P>If your AIM's hardware is hosted on a PCI bus,                  you must be sure to handle hardware interrupts in                  an expansion chassis friendly fashion. See DTS                  Technote 1135                  <A HREF = "tn1135.html">Dealing                  with PCI Expansion Chassis Problems</A> for                  details.</P>                                    <P>Controllers which contain two ATA buses which                  share a single PCI interrupt must extend the                  interrupt source tree so that each ATA bus has a                  separate interrupt node. Typically this is done in                  your AIM's <A HREF = "#MyAIMInit">initialization                  routine</A>.</p>                  <P>A less obvious example of the use of bus events is to         handle timeouts. If your AIM implements timeouts using the         system timer service (<CODE>SetInterruptTimer</CODE>), the         timer routine will be executed at hardware interrupt time.         Your AIM can avoid synchronization problems by posting this         event as a bus event as well.</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note:</B><BR>                  ATA Manager uses the bus event mechanism to both                  guarantee synchronization and to defer the                  processing of bus events until interrupts are                  enabled (by way of a secondary interrupt). You                  should not rely on ATA Manager's use of secondary                  interrupts. Older versions of ATA Manager                  implemented this using a deferred task, and the                  implementation might change again in the future.</p></TD>            </TR>         </TABLE></CENTER>         <BR>               <P>In addition to guaranteeing that only one thread of         execution can be running inside your AIM at any point in         time, the ATA Manager also guarantees to dispatch only a         single request to your AIM at a time. Between the point when         ATA Manager dispatches a request (by calling         <CODE><A HREF = "#MyAIMAction">MyAIMAction</A></CODE>) and the         point when your AIM completes it (by calling         <CODE><A HREF = "#ATAFamIODone">ATAFamIODone</A></CODE>), ATA         Manager will not dispatch any further requests to your AIM.         Instead, it will queue these requests on its internal         queues. This "one request at a time" guarantee is in         recognition of the fact that the ATA bus architecture does         not support parallel overlapped requests and that, by         guaranteeing this, ATA Manager simplifies your life.</P>                  <P>Both of the synchronization guarantees described in this         section are defined on a bus-by-bus basis. If your AIM is         multiply instantiated on the system, and those instances         share common data, you must be careful to synchronize access         to that common data.</P>                  <P>Finally, ATA Manager also handles enabling and disabling         of user code (in the virtual memory sense) for you. Readers         who are familiar with SIMs (the equivalent to AIMs for SCSI         buses) know that they are required to call         <CODE>EnteringSIM</CODE> and <CODE>ExitingSIM</CODE>         whenever they enter or leave the SIM. AIM developers are not         required to jump through that particular hoop because the         ATA Manager knows when non-reentrant portions of the AIM are         executing (because the non-reentrant parts of the AIM are         always executed as a result of the ATA Manager calling the         AIM) and so it can enable and disable user code         appropriately.</P>                  <H3><A NAME="ATAIOModes"></A>ATA I/O Modes</H3>                  <P>This section explains one of the trickier aspects of the         ATA Manager's API for setting transfer modes and timings. In         addition to the discussion here, you should read the         <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATA         Device Software for Macintosh Computers</A> (and its errata,         DTS Technote 1098         <A HREF = "tn1098.html">ATA         Device Software Guide Additions and Corrections</A>)         carefully to fully understand how ATA client software         expects your AIM to handle transfer modes and timings.</P>                  <P>Prior to ATA Manager 3.0, which was the first version of         the ATA Manager to support DMA transfers, transfer modes         were specified as absolute numbers. Thus, a value of 2 for a         transfer mode meant PIO mode 2. Starting with ATA Manager         3.0, transfer modes were specified as bitmaps. Thus a value         of 1 meant transfer mode 0, a value of 2 meant transfer mode         1, and so on. The <CODE>ataModeType</CODE> field of the         <CODE>ATAReqBlock</CODE> determines which mode this request         is in.</P>                  <P>This is important to remember when trying to establish         the correct timing mode on the ATA bus. For example, the         flag bit <CODE>mATAFlagUseConfigSpeed</CODE> has different         meanings depending on the value of the         <CODE>ataModeType</CODE> field. If the         <CODE>ataModeType</CODE> field is set to         <CODE>kATAModeAbsolute</CODE> (pre-ATA Manager 3.0) then the         flag bit <CODE>mATAFlagUseConfigSpeed</CODE> indicates         whether to use timing values for the mode last set with a         <A HREF = "#kATAFnSetDriveConfig">Set Driver Configuration</A>         request, or to use timing values for the PIO mode specified         in the field <CODE>ataPBIOSpeed</CODE>. If the         <CODE>ataModeType</CODE> field is set to         <CODE>kATAModeBitmap</CODE> (ATA Manager 3.0 and above) then         the flag bit <CODE>mATAFlagUseConfigSpeed</CODE> should         <EM>always</EM> be set. If so, your AIM must use the bus         mode (PIO, singleword DMA, multiword DMA, UltraDMA) and         timing values that were stored from the last         <A HREF = "#kATAFnSetDriveConfig">Set Driver Configuration</A>         request. If <CODE>mATAFlagUseConfigSpeed</CODE> is not set,         your AIM should execute the request at the slowest possible         transfer speed.</P>                  <H3>AIMs versus SIMs</H3>                  <P>In many respects, AIMs are architecturally similar to         SCSI Interface Modules (SIMs), the name given to host bus         controller drivers in the Mas OS SCSI architecture. The         following table compares various features of AIMs and SIMs.         </P>                  <BR><Table BORDER=1>            <TR>               <td align="left">                  <B>Feature</B>               </TD><td align="left">                  <B>AIM</B>               </TD><td align="left">                  <B>SIM</B>               </TD></TR>            <TR>               <td align="left">Single Thread               </TD><td align="left">Yes               </TD><td align="left">No               </TD></TR>            <TR>               <td align="left">Single Request               </TD><td align="left">Yes               </TD><td align="left">No               </TD></TR>            <TR>               <td align="left">Interrupt Polling               </TD><td align="left">Yes               </TD><td align="left">Yes               </TD></TR>            <TR>               <td align="left">Enable/Disable User Code               </TD><td align="left">No               </TD><td align="left">Yes               </TD></TR>            <TR>               <td align="left">Per-Bus Storage               </TD><td align="left">Maintained by ATA Manager               </TD><td align="left">Maintained by SCSI Manager               </TD></TR>            <TR>               <td align="left">Per-Request Storage               </TD><td align="left">Single request, therefore put per-request data                  in per-bus globals               </TD><td align="left">Allocated by client as part of SCSI parameter                  block               </TD></TR>            <TR>               <td align="left">Update "on the fly"               </TD><td align="left"><A HREF = "#AIMUpdateProcess">Yes</A>               </TD><td align="left">Not provided by SCSI Manager               </TD></TR>            <TR>               <td align="left"><CODE>'ndrv'</CODE>               </TD><td align="left">Required               </TD><td align="left">Possible, but not required               </TD></TR>         </TABLE><BR><P><A HREF = "#top">Back to top</A></P>         <P><A NAME="ATAManagerAdditions"></A></P>                  <H2>ATA Manager Additions</H2>                  <P>ATA Manager 4.0 defines two new ATA Manager function         codes to be used with the <CODE>ataManager</CODE> system         call. The new functions are defined below. The codes are         used to add and remove ATA buses, respectively.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kATAMgrAddATABus            = 0x93,    kATAMgrRemoveATABus         = 0x94};</pre></TD></TR></TABLE></CENTER><BR><BR>         <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                                    If your AIM is loaded from an expansion ROM on a                  card, you do not need to register it manually with                  ATA Manager. At startup time, ATA Manager will                  search the Name Registry for ATA nodes and                  automatically register an ATA bus for any node with                  an available AIM. ATA Manager considers any node                  whose "device_type" property is                  <CODE>kATADeviceType</CODE> ("ata\15\0") to be an                  ATA node.</P>               </TD>            </TR>         </TABLE></CENTER>         <BR>                                    <P>For compatibility reasons, ATA Manager also                  recognizes nodes of type "ide\0". New AIMs should                  use always <CODE>kATADeviceType</CODE>.</p>                   <H4><A NAME="AddATABus"></A>Adding an ATA Bus</H4>                  <P>To add an ATA bus to ATA Manager, you must call the         <CODE>ataManager</CODE> system call, passing in a parameter         block of type <CODE>ataAddATABus</CODE>.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ataAddATABus {    ataPBHeader *                   ataPBLink;    UInt16                          ataPBQType;    UInt8                           ataPBVers;    UInt8                           ataPBReserved;    Ptr                             ataPBReserved2;    ProcPtr                         ataPBCallbackPtr;    OSErr                           ataPBResult;    UInt8                           ataPBFunctionCode;    UInt8                           ataPBIOSpeed;    UInt16                          ataPBFlags;    SInt16                          ataPBReserved3;    UInt32                          ataPBDeviceID;    UInt32                          ataPBTimeOut;    Ptr                             ataPBClientPtr1;    Ptr                             ataPBClientPtr2;    UInt16                          ataPBState;    UInt16                          ataPBSemaphores;    SInt32                          ataPBReserved4;    RegEntryIDPtr                   ataNameRegEntry;    CFragConnectionID               connID;    UInt32                          busID;    UInt8                           flags;    UInt8                           socketType;    Ptr                             iconData;    Ptr                             stringData;};typedef struct ataAddATABus ataAddATABus;</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>ataPBLink<BR>                        ataPBQType<BR>                        ataPBVers<BR>                        ataPBReserved<BR>                        ataPBReserved2<BR>                        ataPBCallbackPtr<BR>                        ataPBResult<BR>                        ataPBFunctionCode<BR>                        ataPBIOSpeed<BR>                        ataPBFlags<BR>                        ataPBReserved3<BR>                        ataPBDeviceID<BR>                        ataPBTimeOut<BR>                        ataPBClientPtr1<BR>                        ataPBClientPtr2<BR>                        ataPBState<BR>                        ataPBSemaphores<BR>                        ataPBReserved4</CODE></dt>                        <DD>Standard ATA Manager parameter block header. See            <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATA            Device Software for Macintosh Computers</A> for details.            You must initialize <CODE>ataPBFunctionCode</CODE> to            <CODE>kATAMgrAddATABus</CODE>, <CODE>ataPBVers</CODE> to            <CODE>kATAPBVers2</CODE>.</dd>                        <DT><CODE>ataNameRegEntry</CODE></dt>                        <DD>You must set this to the Name Registry node of the            ATA bus which you wish to add. The ATA Manager will use            Driver Loader Library to locate your native driver (AIM)            for this bus. See <A HREF = "#AIMPackaging">AIM            Packaging</A> for more information about how your native            driver must be structured.</dd>                        <DT><CODE>connID</CODE></dt>                        <DD>Reserved. You must set this field to zero and ignore            any value returned.</dd>                        <DT><CODE>busID</CODE></dt>                        <DD>On successful completion of the request, the ATA            Manager sets this field to the ATA bus ID of the newly            created ATA bus.</dd>                        <DT><CODE>flags</CODE></dt>                        <DD>You must set this to the bus flags for this bus. The            possible flags are <A HREF = "#AddBusFlags">defined            below</A>. The undefined flag bits are reserved; you must            set them to zero.</dd>                        <DT><CODE>socketType</CODE></dt>                        <DD>You must set this to the ATA socket type of the bus            using one of the constants defined in "ATA.h" (currently            one of <CODE>kATASocketInternal</CODE>,            <CODE>kATASocketMB</CODE>, or            <CODE>kATASocketPCMCIA</CODE>).</dd>                        <DT><CODE>iconData</CODE></dt>                        <DD>You must set this to either a pointer to a black and            white icon (256 bytes of data in <CODE>'ICN#'</CODE>            format) that represents the ATA bus, or to            <CODE>nil</CODE> if there is no such icon. ATA Manager            makes a copy of the data, so you can dispose of it when            the call completes.</dd>                        <DT><CODE>stringData</CODE></dt>                        <DD>You must set this to either a pointer to a string            that describes the location of the ATA bus, or to            <CODE>nil</CODE> if you do not wish to supply a location.            The string is a C string (zero terminated) of at most 31            characters in the system script encoding; longer strings            will be truncated by ATA Manager. ATA Manager makes a            copy of the data, so you can dispose of it when the call            completes.</dd>         </DL>                  <P>In response to this request, the ATA Manager opens your         AIM and creates the internal data structures necessary for         it to track the AIM and its attached devices. As part of         processing this call, the ATA Manager calls your AIM's         initialization routine         (<CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>), which         must probe your bus for attached devices. If your AIM's         initialization routine returns an error, the ATA Manager         cleans up and completes the request with that error. If your         AIM's initialization routine succeeds and indicates that         devices are attached to the bus, ATA Manager will issue         <CODE>kATAUpdateEvent</CODE> and         <CODE>kATAOnlineEvent</CODE> events for each device.</P>                  <P><A NAME="AddBusFlags"></A>The possible flags for the         <CODE>flags</CODE> field of the <CODE>ataAddATABus</CODE>         structure are defined below.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    mATANoDMAOnBus              = 0x80};</pre></TD></TR></TABLE></CENTER><BR><BR>                        <P>The meaning of these flags is:</P>                  <DL>            <DT><CODE>mATANoDMAOnBus</CODE></dt>                        <DD>If this flag is set, the bus the ATA Manager's            <CODE><A HREF = "#kATAFnBusInquiry">kATAMgrBusInquiry</A></CODE>            function will indicate that the bus does not support DMA,            even if your AIM indicates that it does. This allows the            bus expert which registers this bus to override AIM            defaults for DMA support. The actual effect of this flag            is that the ATA Manager clears the            <CODE>ataSingleDMAModes</CODE>,            <CODE>ataMultiDMAModes</CODE> and            <CODE>ataUltraDMAModes</CODE> fields returned by your AIM            in response to a <CODE>kATAFnBusInquiry</CODE> request            before returning those fields as part of the client's            <CODE>kATAMgrBusInquiry</CODE> request.</dd>         </DL>                  <P>You must issue this request at system task time.</P>                  <H4><A NAME="RemoveATABus"></A>Removing an ATA Bus</H4>                  <P>To remove an ATA bus, you must call the         <CODE>ataManager</CODE> system call, passing in a parameter         block of type <CODE>ataAddATABus</CODE>.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ataRemoveATABus {    ataPBHeader *                   ataPBLink;    UInt16                          ataPBQType;    UInt8                           ataPBVers;    UInt8                           ataPBReserved;    Ptr                             ataPBReserved2;    ProcPtr                         ataPBCallbackPtr;    OSErr                           ataPBResult;    UInt8                           ataPBFunctionCode;    UInt8                           ataPBIOSpeed;    UInt16                          ataPBFlags;    SInt16                          ataPBReserved3;    UInt32                          ataPBDeviceID;    UInt32                          ataPBTimeOut;    Ptr                             ataPBClientPtr1;    Ptr                             ataPBClientPtr2;    UInt16                          ataPBState;    UInt16                          ataPBSemaphores;    SInt32                          ataPBReserved4;    UInt32                          busID;    RegEntryIDPtr                   ataNameRegEntry;};typedef struct ataRemoveATABus ataRemoveATABus;</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>ataPBLink<BR>                        ataPBQType<BR>                        ataPBVers<BR>                        ataPBReserved<BR>                        ataPBReserved2<BR>                        ataPBCallbackPtr<BR>                        ataPBResult<BR>                        ataPBFunctionCode<BR>                        ataPBIOSpeed<BR>                        ataPBFlags<BR>                        ataPBReserved3<BR>                        ataPBDeviceID<BR>                        ataPBTimeOut<BR>                        ataPBClientPtr1<BR>                        ataPBClientPtr2<BR>                        ataPBState<BR>                        ataPBSemaphores<BR>                        ataPBReserved4</CODE></dt>                        <DD>Standard ATA Manager parameter block header. See            <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATA            Device Software for Macintosh Computers</A> for details.            You must initialize <CODE>ataPBFunctionCode</CODE> to            <CODE>kATAMgrRemoveATABus</CODE>, <CODE>ataPBVers</CODE>            to <CODE>kATAPBVers2</CODE>.</dd>                        <DT><CODE>busID</CODE></dt>                        <DD>Reserved. You must set this field to zero and ignore            any value returned.</dd>                        <DT><CODE>ataNameRegEntry</CODE></dt>                        <DD>You must set this to the Name Registry node of the            ATA bus which you wish to add.</dd>         </DL>                  <P>In response to this request the ATA Manager will remove         the ATA bus associated with the Name Registry node specified         in <CODE>ataNameRegEntry</CODE>. The ATA Manager executes         the following steps:</P>                  <OL>            <LI>It calls your AIM's action routine            (<CODE><A HREF = "#MyAIMAction">MyAIMAction</A></CODE>)            with the <CODE>kATAFnKillIO</CODE> function code, to            indicate that your AIM should stop processing the current            request.</li>                        <LI>It completes any pending I/O requests (including the            current one) for your AIM with the <CODE>nsDrvErr</CODE>            error code.</li>                        <LI>It calls your AIM's device light routine            (<CODE><A HREF = "#MyAIMDeviceLight">MyAIMDeviceLight</A></CODE>)            to turn off the device's light.</li>                        <LI>It issues the <CODE>kATARemovedEvent</CODE> event for            each device on your bus.</li>                        <LI>It calls your AIM's close routine            (<CODE><A HREF = "#MyAIMClose">MyAIMClose</A></CODE>),            ignoring any error result.</li>                        <LI>It disposes of the resources it used to track the bus            and releases its CFM connection to your AIM.</li>         </OL>                  <P>You may issue this request at any execution level,         although if you issue it at anything other than system task         level the ATA Manager's connection to the AIM is not closed         until a future system task time.</p>      <P><A HREF = "#top">Back to top</A></P><A NAME="AIMPackaging"></A>                  <H2>AIM Packaging</H2>                  <P>An AIM is packaged as a native driver         <CODE>('ndrv'</CODE>). For ATA Manager to load your AIM, it         must be available to the Driver Loader Library. See         <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/pci_srvcs/pci_srvcs.html">Designing         PCI Cards and Drivers for Power Macintosh Computers</A> for         more information on how Driver Loader Library finds native         drivers.</P>                  <P>Your AIM must export two named entry global variables:         </P>                  <UL>            <LI>TheDriverDescription -- This is the standard native            driver description.</li>                        <LI>ThePluginDispatchTable -- This contains information            specific to ATA Manager.</li>         </UL>                  <P>The structure of these global variables is described in         the following sections.</P>                  <H4><A NAME="TheDriverDescription"></A>TheDriverDescription         </H4>                  <P>An AIM must export the standard native driver description         structure under the name "TheDriverDescription". An example         of how your AIM should fill out this structure is given         below.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>01 extern DriverDescription TheDriverDescription = {0203     // Signature0405     kTheDescriptionSignature,06     kInitialDriverDescriptor,0708     // Driver Type0910     {11         "\pMyAIMName",12         kmajorRev, kminorAndBugRev, kstage, knonRelRev,13     },1415     // OS Runtime Requirements of Driver1617     {18         kDriverIsUnderExpertControl,19         "\pMyAIMName",20     },2122     // Service Category List2324     // Only one service category required2526     1,2728     // First Service Category2930     kServiceCategoryATA,31     0,32     1, 0, 0, 033 };</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>Some parts of this definition deserve further         explanation.</P>                  <DL>            <DT>Line 11</dt>                        <DD>You must set the <CODE>nameInfoStr</CODE> field of            the <CODE>DriverType</CODE> structure to the name of the            Name Registry node your driver controls. This allows the            Driver Loader Library, and hence the ATA Manager, to            associate your driver with the appropriate hardware.</dd>                        <DT><A NAME="AIMVersion"></A>Line 12</dt>                        <DD>You must set the <CODE>version</CODE> field of the            <CODE>DriverType</CODE> structure the version number of            your driver. This allows the Driver Loader Library to            load the latest version of your driver if more than one            happens to be installed. It also allows the ATA Manager            to replace an initial ROM-based AIM with a newer            file-based AIM once the File Manager is available.</dd>                        <DT>Line 18</dt>                        <DD>AIMs are explicitly loaded by the ATA Manager (the            expert), so you must set the <CODE>driverRuntime</CODE>            flags of the <CODE>DriverOSRuntime</CODE> structure to            <CODE>kDriverIsUnderExpertControl</CODE>.</dd>                        <DT>Line 19</dt>                        <DD>The driverName field of the            <CODE>DriverOSRuntime</CODE> structure is typically used            to hold the unit table name of the driver. As AIMs are            not installed in unit table, this field is not            significant. You should set to the same string you            used in Line 11.</dd>                        <DT>Lines 26 through 32</dt>                        <DD>AIMs are required to export at least one service            category, namely <CODE>kServiceCategoryATA</CODE>. This            allows the ATA Manager to check that it correctly matched            the AIM to the Name Registry node. The other fields of            the <CODE>DriverServiceInfo</CODE> structure are reserved            for future versions of the ATA Manager; you must            initialize them as shown.</dd>         </DL>                  <H4>ThePluginDispatchTable</H4>                  <P>In addition to the standard drive description, you AIM         must export a plugin dispatch table under the name         "ThePluginDispatchTable". The         <CODE>ATAPluginDispatchTable</CODE> type describes the         format of this table.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATAPluginDispatchTable {    ATAPluginHeader                 header;    ATAPluginInit                   init;    ATAPluginClose                  close;    ATAPluginAction                 action;    ATAPluginHandleBusEvent         busEvent;    ATAPluginPoll                   poll;    ATAPluginEjectDevice            eject;    ATAPluginDeviceLight            light;    ATAPluginDeviceLock             lock;    ATAPluginSuspend                suspend;    ATAPluginResume                 resume;};typedef struct ATAPluginDispatchTable ATAPluginDispatchTable;&nbsp;typedef OSStatus ATAPluginInit(ATAInitInfo *pb);typedef OSStatus ATAPluginClose(UInt32 refCon, RegEntryIDPtr aimRegEntry);typedef void ATAPluginAction(UInt32 refCon, ATAReqBlock *pb);typedef void ATAPluginHandleBusEvent(UInt32 refCon, UInt32 aimData);typedef Boolean ATAPluginPoll(UInt32 refCon, UInt32 interruptLevel, UInt32 *aimData);typedef void ATAPluginEjectDevice(UInt32 refCon);typedef void ATAPluginDeviceLight(UInt32 refCon, UInt32 whichDevice, UInt32 lightState);typedef void ATAPluginDeviceLock(UInt32 refCon, UInt32 whichDevice, UInt32 lockState);typedef void ATAPluginSuspend(UInt32 refCon);typedef void ATAPluginResume(UInt32 refCon);</pre></TD></TR></TABLE></CENTER><BR><BR>                                <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>header</CODE></dt>                        <DD>A header which describes the version of the overall            plugin dispatch table. See below.</dd>                        <DT><CODE>init</CODE></dt>                        <DD>You must set this to a pointer to your AIM's            initialization routine            (<CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>).</dd>                        <DT><CODE>close</CODE></dt>                        <DD>You must set this to a pointer to your AIM's close            routine            (<CODE><A HREF = "#MyAIMClose">MyAIMClose</A></CODE>).</dd>                        <DT><CODE>action</CODE></dt>                        <DD>You must set this to a pointer to your AIM's action            routine            (<CODE><A HREF = "#MyAIMAction">MyAIMAction</A></CODE>).</dd>                        <DT><CODE>busEvent</CODE></dt>                        <DD>You must set this to a pointer to your AIM's bus            event handler routine            (<CODE><A HREF = "#MyAIMHandleBusEvent">MyAIMHandleBusEvent</A></CODE>).</dd>                        <DT><CODE>poll</CODE></dt>                        <DD>You must set this to a pointer to your AIM's            interrupt poll routine            (<CODE><A HREF = "#MyAIMPoll">MyAIMPoll</A></CODE>).</dd>                        <DT><CODE>eject</CODE></dt>                        <DD>You must set this to a pointer to your AIM's eject            routine            (<CODE><A HREF = "#MyAIMEjectDevice">MyAIMEjectDevice</A></CODE>)            or <CODE>nil</CODE> if your AIM does not have an eject            routine.</dd>                        <DT><CODE>light</CODE></dt>                        <DD>opt You must set this to a pointer to your AIM's            device light routine            (<CODE><A HREF = "#MyAIMDeviceLight">MyAIMDeviceLight</A></CODE>)            or <CODE>nil</CODE> if your AIM does not have an eject            routine.</dd>                        <DT><CODE>lock</CODE></dt>                        <DD>You must set this to a pointer to your AIM's device            lock routine            (<CODE><A HREF = "#MyAIMDeviceLock">MyAIMDeviceLock</A></CODE>)            or <CODE>nil</CODE> if your AIM does not have an eject            routine.</dd>                        <DT><CODE>suspend</CODE></dt>                        <DD>You must set this to a pointer to your AIM's suspend            routine            (<CODE><A HREF = "#MyAIMSuspend">MyAIMSuspend</A></CODE>).</dd>                        <DT><CODE>resume</CODE></dt>                        <DD>You must set this to a pointer to your AIM's resume            routine            (<CODE><A HREF = "#MyAIMResume">MyAIMResume</A></CODE>).</dd>         </DL>                  <P>The <CODE>ATAPluginHeader</CODE>, as defined below,         structure describes the version of the overall plugin         dispatch table.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATAPluginHeader {    NumVersion                      headerVersion;    NumVersion                      dispatchVersion;    UInt32                          reservedA;    UInt32                          reservedB;};typedef struct ATAPluginHeader ATAPluginHeader;&nbsp;enum {    kATAPluginVersion           = 0x00000001,    kATAPluginCurrentVersion    = kATAPluginVersion};</pre></TD></TR></TABLE></CENTER><BR><BR>                               <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>headerVersion</CODE></dt>                        <DD>You must set this to the version number of your AIM,            as <A HREF = "#AIMVersion">defined above</A>.</dd>                        <DT><CODE>dispatchVersion</CODE></dt>                        <DD>If your AIM conforms to this version of the            specification, you must set this field to            <CODE>kATAPluginVersion</CODE>.</dd>                        <DT><CODE>reservedA</CODE></dt>                        <DD>Reserved. You must set this to zero.</dd>                        <DT><CODE>reservedB</CODE></dt>                        <DD>Reserved. You must set this to zero.</dd>         </DL>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note:</B><BR>                                    ATA Manager does not currently look at the                  <CODE>dispatchVersion</CODE> field. Moreover,                  Apple's AIMs do not currently set this field                  correctly. Because of this confusion, any future                  version of ATA Manager that implements an extended                  plug-in interface will not use this field to                  determine which version of the plug-in interface                  that your AIM conforms to.</p></TD>            </TR>         </TABLE></CENTER>         <BR><P><A HREF = "#top">Back to top</A></P><A NAME="AIMEntryPoints"></A>                  <H2>AIM Entry Points</H2>                  <P>Your AIM must implement a number of routines and export         those routines to the ATA Manager via the plugin dispatch         table. This section describes these routines in detail.</P>                  <H4><A NAME="MyAIMInit"></A>MyAIMInit</H4>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern OSStatus MyAIMInit(ATAInitInfo *aimInit);</pre></TD></TR></TABLE></CENTER><BR><BR>                              <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>aimInit</CODE>               </TD><td align="left">                  <P>A pointer to an <CODE>ATAInitInfo</CODE>                  parameter block, described below.</p>               </TD></TR>            <TR>               <td width=134 align=left>                  <I>result</I>               </TD><td align="left">An error code; see below for details.               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's initialization routine         to commence operations on the ATA bus controlled by your         AIM. This routine is called when an <A HREF = "#AddATABus">ATA         bus is registered</A> with ATA Manager. Your AIM must         allocate any private resources it needs (typically per-bus         storage), install its interrupt handler, initialize its         hardware, probe the bus for attached devices (and determine         whether they are ATA or ATAPI), and return information about         those devices to the ATA Manager. Depending on your         hardware, your AIM may need to reset the ATA bus to         determine if any devices are attached.</P>                  <P>Your AIM must also create child Name Registry nodes for         the attached ATA devices. The nodes must have at least the         following properties:</P>                  <UL>            <LI>The "name" property must be set to either "ata-disk"            or "atapi-disk".</li>                        <LI>The "device_type" property must be set to "block".</li>                        <LI>The "device_id" property must be set to a            <CODE>UInt32</CODE> that contains the ATA bus ID and            device ID (in the same format as the            <CODE>ataPBDeviceID</CODE> field of ATA Manager parameter            blocks).</li>         </UL>                  <P>Your AIM initialization routine must not issue any         commands to the ATA device.</P>                  <P>Your AIM's initialization routine receives the address of         an <CODE>ATAInitInfo</CODE> parameter block as a parameter.         The parameter block contains both input and output fields.         </P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATAInitInfo {    UInt32                          busID;    ATADevInfo                      FirstDevice;    ATADevInfo                      SecondDevice;    RegEntryIDPtr                   aimRegEntry;    UInt32                          refCon;};typedef struct ATAInitInfo ATAInitInfo;</pre></TD></TR></TABLE></CENTER><BR><BR>                               <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>busID</CODE></dt>                        <DD>ATA Manager sets this to the ATA bus ID it has            assigned to the new bus that is being registered.</DD>                        <DT><CODE>FirstDevice</CODE></dt>                        <DD>Your AIM must initialize this structure to hold            information about the first device on the ATA bus. See            below for a description of the <CODE>ATADevInfo</CODE>            structure. If the bus supports ATA devices 0 and 1, and            device 1 is present but device 0 isn't, your AIM should            set this structure to represent device 1 and set            <CODE>SecondDevice</CODE> to indicate that no second            device is attached.</DD>                        <DT><CODE>SecondDevice</CODE></dt>                        <DD>Your AIM must initialize this structure to hold            information about the second device on the ATA bus.</DD>                        <DT><CODE>aimRegEntry</CODE></dt>                        <DD>The ATA Manager sets this to the Name Registry node            of the ATA bus which is being registered.</DD>                        <DT><CODE>refCon</CODE></dt>                        <DD>Your AIM may set this field to any 32-bit value,            typically a pointer to your per-bus storage. The ATA            Manager will pass this value as a parameter (typically            named <CODE>refCon</CODE>) whenever it calls your other            AIM entry points.</DD>         </DL>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                                    The <CODE>AIMInitInfo</CODE> data structure and the                  structures it points to are deallocated as soon as                  your AIM returns from <CODE>MyAIMInit</CODE>. If                  you wish to retain access to this data, you must                  copy it to your own storage. Specifically, you                  should make a copy of the <CODE>RegEntryID</CODE>                  pointed to by <CODE>aimRegEntry</CODE>.                  <STRONG>Copying the <CODE>RegEntryIDPtr</CODE> is                  not sufficient!</STRONG></p>         </TD>            </TR>         </TABLE></CENTER>         <BR>         <P>The <CODE>ATADevInfo</CODE> structure holds information         about a specific ATA device on a bus. Your</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATADevInfo {    UInt8                           devType;    SInt8                           devID;};typedef struct ATADevInfo ATADevInfo;&nbsp;enum {    kATAInvalidDeviceID         = -1,    kATADevice0DeviceID         =  0,    kATADevice1DeviceID         =  1};</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>devType</CODE></dt>                        <DD>Your AIM must set this field to indicate the type of            the attached device. Possible ATA device types are listed            in "ATA.h" (current <CODE>kATADeviceUnknown</CODE>,            <CODE>kATADeviceATA</CODE>, <CODE>kATADeviceATAPI</CODE>,            and <CODE>kATADeviceReserved</CODE>).</DD>                        <DT><CODE>devID</CODE></dt>                        <DD>Your AIM must set this field to indicate the ATA            device ID of the attached device. Possible device IDs are            <CODE>kATAInvalidDeviceID</CODE>,            <CODE>kATADevice0DeviceID</CODE> and            <CODE>kATADevice1DeviceID</CODE>.</DD>         </DL>                  <P>If your AIM wants to indicate that no ATA device is         attach, it must set devType to         <CODE>kATADeviceUnknown</CODE> and <CODE>devID</CODE> to         <CODE>kATAInvalidDeviceID</CODE>.</P>                  <P>If your AIM initialization routine returns an error, or         it indicates that there are no devices on the bus, ATA         Manager fails the request to register the ATA bus, unloads         your AIM, and dispose of all references to it.</P>         <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                                    It is especially important to take note of the                  circumstances under which your AIM will be unloaded                  when extending the interrupt source tree for                  multiple bus controllers that share an interrupt.                  Remember, your buses may be initialized in any                  order. The first instance of an AIM that                  successfully initializes should extend the                  interrupt tree and store the child interrupt nodes                  for each bus in the Name Registry. When the second                  bus is initialized, it can look in the Name                  Registry to determine whether the interrupt tree                  has been extended or not.</p></TD>            </TR>         </TABLE></CENTER>         <BR>         <P>Suggested result codes include:</P>                  <UL>            <LI><CODE>noErr</CODE> Initialization successful.</li>                        <LI><CODE>memFullErr</CODE> Unable to allocate private            data.</li>                        <LI><CODE>nsDrvErr</CODE> No device detected on node</li>                        <LI><CODE>paramErr</CODE> Bad parameter</li>                        <LI><CODE>nrInvalidNodeErr</CODE> Invalid Name Registry            node</li>                        <LI><CODE>nrNotFoundErr</CODE> A required property was            not found in the Name Registry node</li>                        <LI><CODE>ATAInitFail</CODE> Initialization failed         </li>         </UL>                  <P>This routine is always be called at system task time.         </P>                  <H4><A NAME="MyAIMClose"></A>MyAIMClose</H4>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern OSStatus MyAIMClose(UInt32 refCon, RegEntryIDPtr aimRegEntry);</pre></TD></TR></TABLE></CENTER><BR><BR>                            <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>aimRegEntry</CODE>               </TD><td align="left">                  The Name Registry node of the ATA bus which is                  being deregistered.               </TD></TR>            <TR>               <td width=134 align=left>                  <I>result</I>               </TD><td align="left">                  An error code; see below for details.               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's close routine to         terminate operations on the ATA bus controlled by your AIM.         This routine is called when an <A HREF = "#RemoveATABus">ATA         bus is deregistered</A> with ATA Manager. Your AIM must shut         down its hardware, remove any interrupt handlers, and         release any resources it owns. This will be the last request         that a particular instance of your AIM will receive.</P>                  <P>Any error code returned by your AIM is ignored. You         should structure your AIM such that its close routine can         not fail.</P>                  <P>This routine will always be called at system task time.         </P>                  <H4><A NAME="MyAIMAction"></A>MyAIMAction</H4>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void     MyAIMAction(UInt32 refCon, ATAReqBlock *pb);</pre></TD></TR></TABLE></CENTER><BR><BR>                              <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>pb</CODE>               </TD><td align="left">                  A pointer to an <CODE>ATAReqBlock</CODE>                  parameter block, described below.               </TD></TR>         </TABLE><BR>          <P>The ATA Manager calls your AIM's action routine to         perform a transaction on the ATA bus. The         <CODE>ATAReqBlock</CODE> parameter block specifies the         action to perform and the place to store the results. The         meaning of many of the fields is dependent on the         <CODE>ataFunctionCode</CODE> field, which specifies exactly         what operation is to be performed. Each function code is         described in detail in <A HREF = "#AIMActionFunctionCodes">AIM         Action Function Codes</A>.</P>         <A NAME="ATAReqBlock"></A>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATAReqBlock {    UInt32                          connectionID;    UInt32                          MsgID;    ATAResult *                     result;    ATADiagResult *                 DiagResult;    ATABusInfo *                    busInfo;    ATADevConfig *                  devConfig;    ATADataObject                   ioObject;    ataTaskFile                     ataPBTaskFile;    ATAPICmdPacket                  packetCBD;    Duration                        Timeout;    UInt32                          BusID;    SInt8                           DevID;    UInt8                           ataFunctionCode;    UInt32                          AbortID;    UInt32                          ataPBLogicalBlockSize;    UInt32                          ataPBFlags;    UInt32                          reserved;    struct ATAReqBlock *            nextREQ;    OSStatus                        ataPBResult;    UInt8                           ataPBErrorRegister;    UInt8                           ataPBStatusRegister;    UInt32                          ataPBactualXferCount;    UInt32                          ataPBState;    UInt32                          ataPBSemaphores;    UInt8                           XferType;    UInt8                           ataModeType;    UInt8                           ataPBIOSpeed;    UInt8                           reserved2;    UInt16                          reserved3;};typedef struct ATAReqBlock ATAReqBlock;</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>Unless otherwise stated, a field is has the same meaning         for all function codes (except         <CODE><A HREF = "#kATAFnKillIO">kATAFnKillIO</A></CODE>). The         fields have the following meaning:</P>                  <DL>            <DT><CODE>connectionID</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</DD>                        <DT><CODE>MsgID</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</DD>                        <DT><CODE>result</CODE></dt>                        <DD>This field is used to hold the result of an AIM            action. This field is a structure            (<CODE><A HREF = "#ATAResult">ATAResult</A></CODE>), not a            simple '<CODE>ioResult</CODE>' value, but the fields of            the structure are only relevant to <CODE>the            <A HREF = "#kATAFnExecIO">kATAFnExecIO</A></CODE> function            code. The only field relevant to the other function codes            is <CODE>ataResult</CODE> field, but your AIM does not            need to explicitly set this field because            <CODE><A HREF = "#ATAFamIODone">ATAFamIODone</A></CODE>            does it for you.</dd>                        <DT><CODE>DiagResult</CODE></Dt>                        <DD>This field is significant only for the            <CODE><A HREF = "#kATAFnRegAccess">kATAFnRegAccess</A></CODE>            function code and is described along with that function            code.</DD>                        <DT><CODE>busInfo</CODE></dt>                        <DD>This field is significant only for the            <CODE><A HREF = "#kATAFnBusInquiry">kATAFnBusInquiry</A></CODE>            function code and is described along with that function            code.</DD>                        <DT><CODE>devConfig</CODE></dt>                        <DD>This field is significant only for the            <CODE><A HREF = "#kATAFnGetDriveConfig">kATAFnGetDriveConfig</A></CODE>            and            <CODE><A HREF = "#kATAFnSetDriveConfig">kATAFnSetDriveConfig</A></CODE>            function codes and is described along with those function            codes.</DD>                        <DT><CODE>ioObject</CODE></dt>                        <DD>This field is significant only for the            <CODE><A HREF = "#kATAFnExecIO">kATAFnExecIO</A></CODE> and            <CODE><A HREF = "#kATAFnDriveIdentify">kATAFnDriveIdentify</A></CODE>            function codes and is described along with those function            codes.</DD>                        <DT><CODE>ataPBTaskFile</CODE></dt>                        <DD>This field is significant only for the            <CODE><A HREF = "#kATAFnExecIO">kATAFnExecIO</A></CODE>            function code and is described along with that function            code.</DD>                        <DT><CODE>packetCBD</CODE></dt>                        <DD>This field is significant only for the            <CODE><A HREF = "#kATAFnExecIO">kATAFnExecIO</A></CODE>            function code and is described along with that function            code.</DD>                        <DT><CODE>Timeout</CODE></dt>                        <DD>The ATA Manager sets this field to a timeout (in            milliseconds) for the request. It derives the value from            the <CODE>ataPBTimeOut</CODE> field of the client's            request, or sets it to a default value (currently 31000)            if <CODE>ataPBTimeOut</CODE> was zero.</DD>                        <DT><CODE>BusID</CODE></dt>                        <DD>ATA Manager sets up this field to the bus ID of the            ATA bus on which to perform the action. It derives this            value from <CODE>ataPBDeviceID</CODE> field of the            client's request. Typically your AIM ignores this field            because the bus is already uniquely identified by the            per-bus storage pointed to by the <CODE>refCon</CODE>            passed to <CODE>AIMAction</CODE>.</DD>                        <DT><CODE>DevID</CODE></dt>                        <DD>ATA Manager sets up this field to either            <CODE>kATADevice0DeviceID</CODE> or            <CODE>kATADevice1DeviceID</CODE> to describe which device            on the ATA bus to act upon. It derives this value from            the <CODE>ataPBDeviceID</CODE> field of the client's            request.</DD>                        <DT><CODE>ataFunctionCode</CODE></dt>                        <DD>ATA Manager sets up this field to describe the action            that the AIM should take.            <A HREF = "#AIMActionFunctionCodes">AIM Action Function            Codes</A> lists the defined function codes.</DD>                        <DT><CODE>AbortID</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit.</DD>                        <DT><CODE>ataPBLogicalBlockSize</CODE></dt>                        <DD>This field is significant only for the            <CODE><A HREF = "#kATAFnExecIO">kATAFnExecIO</A></CODE>            function code and is described along with that function            code.</DD>                        <DT><CODE>ataPBFlags</CODE></dt>                        <DD>The ATA Managers sets this field to the value of the            <CODE>ataPBFlags</CODE> field of the client's request.            Your AIM is expected to read this field and act on the            flags it contains.</DD>                        <DT><CODE>reserved</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</DD>                        <DT><CODE>nextREQ</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit.</DD>                        <DT><CODE>ataPBResult</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit, although typically it is used to hold a            temporary result.</DD>                        <DT><CODE>ataPBErrorRegister</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit, although typically it is used as temporary            storage for the error register.</DD>                        <DT><CODE>ataPBStatusRegister</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit, although typically it is used as temporary            storage for the status register.</DD>                        <DT><CODE>ataPBactualXferCount</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit, although typically it is used as temporary            storage for the transfer count.</DD>                        <DT><CODE>ataPBState</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit, although typically it is used to track the            state of the request.</DD>                        <DT><CODE>ataPBSemaphores</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit, although typically it is used to hold flags            that indicate the status of the request.</DD>                        <DT><CODE>XferType</CODE></dt>                        <DD>ATA Manager does not use this field except insofar as            to initialize it to zero. Your AIM can use this field as            it sees fit, although typically it is used to hold the            I/O transfer type (PIO, single-word DMA, multi-word DMA).</DD>                        <DT><CODE>ataModeType</CODE></dt>                        <DD>ATA Manager sets up this field to indicate whether            the <CODE>ataPBIOSpeed</CODE> field contains an absolute            value (<CODE>kATAModeAbsolute</CODE>) or a bitmap of            possible values (<CODE>kATAModeBitmap</CODE>). It derives            this value from the <CODE>ataPBVers</CODE> field of the            client request; absolute mode is used only if the            parameter block is less than version 3. See            <A HREF = "#ATAIOModes">ATA I/O Modes</A> for more            information about how your AIM should interpret this and            the <CODE>ataPBIOSpeed</CODE> field.</DD>                        <DT><CODE>ataPBIOSpeed</CODE></dt>                        <DD>ATA Manager sets this field to the            <CODE>ataPBIOSpeed</CODE> field of the client's request.</DD>                        <DT><CODE>reserved2</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</DD>                        <DT><CODE>reserved3</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</DD>         </DL>                  <P>Each field is described in more detail with the         appropriate <A HREF = "#AIMActionFunctionCodes">function         code</A>.</P>                  <P>Your AIM typically processes an action request using a         state machine. When it receives the action request, it         initializes the state machine and starts the first         (asynchronous) step of processing the request. It then         returns control to the ATA Manager. When the first step is         complete, the hardware generates an interrupt and the AIM's         interrupt service routine is called. It notifies ATA Manager         of the bus event by calling         <CODE><A HREF = "#ATAFamBusEventForAIM">ATAFamBusEventForAIM</A></CODE>.         ATA Manager then calls the AIM's bus event handler routine         (<CODE><A HREF = "#MyAIMHandleBusEvent">MyAIMHandleBusEvent</A></CODE>),         which starts the next (asynchronous) step of processing the         request. When the last step is done, the AIM calls         <CODE><A HREF = "#ATAFamIODone">ATAFamIODone</A></CODE>. ATA         Manager completes the original client's request and then         calls the AIM to start the next request.</P>                  <P>This routine may be called at any execution level.</P>                  <H4><A NAME="MyAIMHandleBusEvent"></A>MyAIMHandleBusEvent         </H4><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void     MyAIMHandleBusEvent(UInt32 refCon, UInt32 aimData);</pre></TD></TR></TABLE></CENTER><BR><BR>         <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>aimData</CODE>               </TD><td align="left">The bus event type, as passed in to                  <CODE><A HREF = "#ATAFamBusEventForAIM">ATAFamBusEventForAIM</A></CODE>                  or returned from                  <CODE><A HREF = "#MyAIMPoll">MyAIMPoll</A></CODE>;                  <A HREF = "#AIMSynchronizationModel">AIM                  Synchronization Model</A> for more details               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's bus event handler         routine to handle events detected on your bus. Typically         these events are interrupts from your bus's interrupt         hardware. Your AIM informs ATA Manager of these events in         one of two ways:</P>                  <UL>            <LI>When an interrupt occurs (and is not masked), your            interrupt service routine is called. Your interrupt            service routine must inform ATA Manager of the bus event            by calling            <CODE><A HREF = "#ATAFamBusEventForAIM">ATAFamBusEventForAIM</A></CODE>            and then return.</li>                        <LI>When interrupts are masked (or otherwise deferred),            ATA Manager calls your AIM's interrupt poll routine            (<CODE><A HREF = "#MyAIMPoll">MyAIMPoll</A></CODE>) to poll            for masked interrupts. If the interrupt poll routine            detects an interrupt, it returns an indicative status to            ATA Manager.</li>         </UL>                  <P>Regardless of how it informs ATA Manager of the bus         event, your AIM can provide a bus event type which indicates         what type of bus event occurred. The ATA Manager passes the         same bus event type back to the bus event handler in the         <CODE>aimData</CODE> parameter. Typically this bus event         type is used to distinguish the type of bus event that has         occurred. For example, your AIM might use a value of 1 to         indicate that a DMA interrupt has occurred and a value of 2         to indicate that an I/O interrupt has occurred. ATA Manager         does not interrupt this value.</P>                  <P>Typically your AIM responds to a bus event by moving the         current I/O request to the next state. For example, if the         current I/O request is waiting for an I/O completion bus         event, your AIM would respond to that bus event by calling         <CODE><A HREF = "#ATAFamIODone">ATAFamIODone</A></CODE> to         inform ATA Manager that the I/O request is complete. On the         other hand, if the current I/O request is not complete, your         AIM would respond by setting up the next asynchronous I/O         operation.</P>                  <P>This routine may be called at any execution level. It is         typically executed with interrupts enabled (either from a         deferred task or a secondary interrupt) but that is not         guaranteed.</P>                  <H4><A NAME="MyAIMPoll"></A>MyAIMPoll</H4>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern Boolean  MyAIMPoll(UInt32 refCon,                          UInt32 interruptLevel,                          UInt32 *aimDataPtr);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">                  <P>A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>.</p>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>interruptLevel</CODE>               </TD><td align="left">                  <P>The current 68K interrupt mask: a value from 0                  to 7.</p>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>aimDataPtr</CODE>               </TD><td align="left">                  <P>If your AIM detected a bus event, it should set                  the value pointed to by this parameter to the type                  of bus event that occurred; see                  <A HREF = "#AIMSynchronizationModel">AIM                  Synchronization Model</A> for more details.</p>               </TD></TR>            <TR>               <td width=134 align=left>                  <I>result</I>               </TD><td align="left">                  <P>True if the AIM detected a bus event, otherwise                  false.</p>               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's interrupt poll routine         when it detects that a synchronous I/O request is blocked         because interrupts are masked (or otherwise deferred). Your         AIM must look at its interrupt hardware to determine if         there is an interrupt pending. If there is, your AIM must         set the memory pointed to by <CODE>aimDataPtr</CODE> to the         type of bus event associated with that interrupt (see         <A HREF = "#AIMSynchronizationModel">AIM Synchronization         Model</A> for more details on bus event types) and return         true. If there is no interrupt pending, your AIM must return         false.</P>                  <P>The <CODE>interruptLevel</CODE> parameter is a         convenience only. Your AIM may use this value to determine         which interrupt sources to check. For example, if your AIM         receives device interrupts at level 2 and DMA interrupts at         level 4, and the current <TT>interruptLevel</TT> is 3, it         need not check the status of the DMA interrupt line because         that interrupt is not being masked.</P>                  <P>This routine may be called at any execution level.</P>                  <H4>Background Material</H4>                  <P>Under the Mac OS I/O system architecture, it is possible         for the system to take a page fault in three hard-to-handle         cases:</P>                  <UL>            <LI>inside an interrupt handler (for example, Sound            Manager callbacks are made directly from a sound hardware            interrupt handler, but applications must be able to take            page faults in these callbacks)</li>                        <LI>when interrupts are masked (for example, the OS            Utilities routine Enqueue will set the interrupt mask to            7 and then manipulate queue headers, which may be paged            out)</li>                        <LI>when critical system resources are busy (for example,            the ATA Manager typically defers processing of bus events            until secondary interrupt time, but secondary interrupts            are serialized and a page fault from a hardware interrupt            handler while an unrelated secondary interrupt was            running would deadlock the system)</li>         </UL>                  <P>Page faults result in synchronous disk driver I/O         requests. If the underlying I/O hardware requires interrupts         to complete an I/O request, and interrupts are masked or         otherwise deferred when the page fault happens, the system         will deadlock.</P>                  <P>In order to avoid this deadlock, the system polls for         interrupts during any "sync wait" loop which occurs while         interrupts are masked (or otherwise deferred). Given that         the system has no knowledge of your AIM's interrupt         architecture, it calls your AIM's interrupt poll routine to         accomplish this polling.</P>                  <P>See DTS Technote 1094         <A HREF = "tn1094.html">Virtual         Memory Application Compatibility</A> and DTS Q&amp;A DV 34         <a href="../../qa/dv/dv34.html">Secondary         Interrupts on the Page Fault Path</A> for more details about         this technique.</P>                  <H4><A NAME="MyAIMEjectDevice"></A>MyAIMEjectDevice</H4>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void     MyAIMEjectDevice(UInt32 refCon);</pre></TD></TR></TABLE></CENTER><BR><BR>                            <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's eject routine in         response to a <CODE>kATAMgrDriveEject</CODE> request.</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                  This routine ejects the entire ATA bus, not simply                  the media from a device on the bus. The distinction                  is a subtle but important one. An example of an AIM                  that implements the eject routine is the built-in                  PC Card AIM, which ejects the PC Card in response                  to this call.</p></TD>            </TR>         </TABLE></CENTER>         <BR>                              <P>If your ejection hardware is asynchronous, this operation         should simply start the ejection operation. If an         asynchronous ejection operation is not complete by the time         the ATA bus is deregistered, your close routine         (<CODE><A HREF = "#MyAIMClose">MyAIMClose</A></CODE>) is         responsible for waiting until it is.</P>                  <P>This routine is optional. If your AIM does not support         this function, it should set the appropriate plugin dispatch         table entry to <CODE>nil</CODE>.</P>                  <P>This routine may be called at any execution level.</P>                  <H4><A NAME="MyAIMDeviceLight"></A>MyAIMDeviceLight</H4>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void     MyAIMDeviceLight(UInt32 refCon,                                 UInt32 whichDevice,                                 UInt32 lightState);</pre></TD></TR></TABLE></CENTER><BR><BR>              <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>whichDevice</CODE>               </TD><td align="left">The ATA socket type of the device, derived from                  the <CODE>socketType</CODE> field of the                  <CODE>ataAddATABus</CODE> structure used to                  <A HREF = "#AddATABus">register the bus</A>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>lightState</CODE>               </TD><td align="left">The state in which to set the light: one of the                  constants given below               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's device light routine to         turn on and off the activity light, if any, associated with         your AIM. Typically the ATA Manager enables the activity         light in response to a device driver request (the driver         sets the <CODE>mATAFlagLEDEnable</CODE> flag in the         <CODE>ataPBFlags</CODE> field of the parameter block it         passes to the <CODE>ataManager</CODE> system call).</P>                  <P>The constants for the <CODE>lightState</CODE> parameter         are defined below.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kATADeviceLightOff          = 0x00,    kATADeviceLightOn           = 0x01};</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>An example of an AIM that implements this routine is the         media bay AIM for PowerBook computers, where it controls the         LED on the media bay device.</P>                  <P>This routine is optional. If your AIM does not support         this function, it should set the appropriate plugin dispatch         table entry to <CODE>nil</CODE>.</P>                  <P>This routine may be called at any execution level.</P>                  <H4><A NAME="MyAIMDeviceLock"></A>MyAIMDeviceLock</H4>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void     MyAIMDeviceLock(UInt32 refCon,                                UInt32 whichDevice,                                UInt32 lockState);</pre></TD></TR></TABLE></CENTER><BR><BR>                            <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>whichDevice</CODE>               </TD><td align="left">The ATA socket type of the device, derived from                  the <CODE>socketType</CODE> field of the                  <CODE>ataAddATABus</CODE> structure used to                  <A HREF = "#AddATABus">register the bus</A>               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>lockState</CODE>               </TD><td align="left">Whether the device is locked or not; one of the                  constants given below               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's device lock routine to         lock and unlock the hardware associated with your AIM. A         locked device cannot be ejected by the user. The ATA Manager         locks and unlocks the AIM based on the         <CODE>mATApcLockUnlock</CODE>&nbsp;flag in the         <CODE>atapcValid</CODE> field of the         <CODE>ataDevConfiguration</CODE> parameter block supplied to         a <CODE>kATAMgrSetDrvConfiguration</CODE> request.</P>                  <P>The constants for the <CODE>lockState</CODE> parameter         are defined below.</P>            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kATADeviceUnlock            = 0x00,    kATADeviceLock              = 0x01};</pre></TD></TR></TABLE></CENTER><BR><BR>                               <P>An example of an AIM that implements this routine is the         built-in PC Card AIM, which prevents users from ejecting the         PC Card if it has been locked.</P>                  <P>This routine is optional. If your AIM does not support         this function, it should set the appropriate plugin dispatch         table entry to <CODE>nil</CODE>.</P>                  <P>This routine may be called at any execution level.</P>                  <H4><A NAME="MyAIMSuspend"></A>MyAIMSuspend</H4>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void     MyAIMSuspend(UInt32 refCon);</pre></TD></TR></TABLE></CENTER><BR><BR>                              <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's suspend routine as part         of the process of updating an AIM to a newer version. See         <A HREF = "#AIMUpdateProcess">AIM Update Process</A> for more         details.</P>                  <P>Your AIM must "disconnect" itself from all system         callbacks except those directly associated with the ATA         Manager. This includes:</P>                  <UL>            <LI>interrupt handlers</li>                        <LI>timer tasks</li>                        <LI>power management callbacks</li>         </UL>                  <P>This allows the ATA Manager to unload the code associated         with the older version of your AIM. Your AIM must not         dispose of the per-bus storage associated with         <CODE>refCon</CODE>. ATA Manager will pass the same         <CODE>refCon</CODE> to the resume routine of the newer AIM,         which is responsible for "reconnecting" the AIM to the         system.</P>                  <P>The ATA Manager guarantees that it will not call your AIM         from the beginning of your suspend routine until your resume         routine returns.</P>                  <P>This routine will always be called at system task time.         </P>                  <A NAME="MyAIMResume"></A><H4>MyAIMResume</H4>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void     MyAIMResume(UInt32 refCon);</pre></TD></TR></TABLE></CENTER><BR><BR>                                          <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>refCon</CODE>               </TD><td align="left">A pointer to your per-bus storage, as returned                  by <CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>               </TD></TR>         </TABLE><BR>                  <P>The ATA Manager calls your AIM's resume routine as part         of the process of updating an AIM to a newer version. See         <A HREF = "#AIMUpdateProcess">AIM Update Process</A> for more         details.</P>                  <P>Your AIM must "redisconnect" itself to all system         callbacks which were disconnected by the suspend routine.         This includes:</P>                  <UL>            <LI>interrupt handlers</li>                        <LI>timer tasks</li>                        <LI>power management callbacks</li>         </UL>                  <P>Your AIM is required to continue operations using the         per-bus storage inherited from the older version and pointed         to by <CODE>refCon</CODE>. If the format of your per-bus         storage changes between versions, your resume routine must         convert from the old to the new format.</P>                  <P>The ATA Manager guarantees that it will not call your AIM         from the beginning of your suspend routine until your resume         routine returns.</P>                  <P>This routine will always be called at system task time.</p>     <P><A HREF = "#top">Back to top</A></P>        <A NAME="AIMActionFunctionCodes"></A>                  <H2>AIM Action Function Codes</H2>                  <P>When ATA Manager calls your AIM's action routine         (<CODE><A HREF = "#MyAIMAction">MyAIMAction</A></CODE>), it         sets the <CODE>ataFunctionCode</CODE> field of the         <CODE>ATAReqBlock</CODE> parameter block to a value which         identifies the type of operation to be performed. The         possible function codes are listed below:</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kATAFnNOP                   = 0x00,    kATAFnExecIO                = 0x01,    kATAFnBusInquiry            = 0x02,    kATAFnQRelease              = 0x03,    kATAFnCmd                   = 0x04,    kATAFnAbort                 = 0x05,    kATAFnBusReset              = 0x06,    kATAFnRegAccess             = 0x07,    kATAFnDriveIdentify         = 0x08,    kATAPIFnExecIO              = 0x09,    kATAPIFnCmd                 = 0x0A,    kATAFnGetDriveConfig        = 0x0B,    kATAFnSetDriveConfig        = 0x0C,    kATAFnKillIO                = 0x0D};</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>The following sections describe each function code in         detail. If your AIM receives a request with a function code         it does not recognize, it should fail the request with a         status of <CODE>paramErr</CODE>.</P>                  <H4>No Operation (kATAFnNOP)</H4>                  <P>This is a "no operation" request. ATA Manager should         never issue this request to your AIM. If it does, your AIM         should immediately complete the request successfully by         calling         <CODE><A HREF = "#ATAFamIODone">ATAFamIODone</A></CODE> with a         status of <CODE>noErr</CODE>.</P>                  <H4><A NAME="kATAFnExecIO"></A>Execute I/O (kATAFnExecIO)         </H4>                  <P>ATA Manager issues this request to your AIM as the result         of a client's <CODE>kATAMgrExecIO</CODE> request. Your AIM         is expected to execute the specified I/O transaction to the         specified device on the specified bus. The bulk of the         <CODE>ATAReqBlock</CODE> is set up <A HREF = "#ATAReqBlock">as         described above</A>; only the fields specific to this         request are described here.</P>                  <P><A NAME="ATAResult"></A>The structure of the         <CODE>result</CODE> field of the <CODE>ATAReqBlock</CODE> is         shown below.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATAResult {    OSStatus                        ataResult;    SInt8                           ataStatusRegister;    SInt8                           ataErrorRegister;    UInt32                          actualXferCount;    ataTaskFile *                   TaskFile;};typedef struct ATAResult ATAResult;</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>ataResult</CODE></dt>                        <DD>The overall error result for the request. Unlike the            other fields in the <CODE>ATAResult</CODE> structure,            this field is relevant for all function codes. Your AIM            must not explicitly set this field because            <CODE><A HREF = "#ATAFamIODone">ATAFamIODone</A></CODE>            does it for you.</DD>                        <DT><CODE>ataStatusRegister</CODE></dt>                        <DD>For execute I/O requests, your AIM must set this            field to the contents of the ATA status register. When            you complete the request, ATA Manager copies this field            to the <CODE>ataPBStatusRegister</CODE> field of the            client's parameter block.</DD>                        <DT><CODE>ataErrorRegister</CODE></dt>                        <DD>For execute I/O requests, your AIM must set this            field to the contents of the ATA error register. When you            complete the request, ATA Manager copies this field to            the <CODE>ataPBErrorRegister</CODE> field of the client's            parameter block.</DD>                        <DT><CODE>actualXferCount</CODE></dt>                        <DD>For execute I/O requests, your AIM must set this            field to number of bytes actually transferred. When you            complete the request, ATA Manager copies this field to            the <CODE>ataPBActualTxCount</CODE> field of the client's            parameter block.</DD>                        <DT><CODE>TaskFile</CODE></dt>                        <DD>For execute I/O requests, your AIM must copy the            current contents of the ATA task file to the structure            pointed to by this field, if it is not <CODE>nil</CODE>.            Typically you copy this directly from the            <CODE>ataPBTaskFile</CODE> field of the            <CODE>ATAReqBlock</CODE>. ATA Manager does not currently            look at this field.</DD>         </DL>                  <P>The structure of the <CODE>ioObject</CODE> field of the         <CODE>ATAReqBlock</CODE> is shown below.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATADataObject {    UInt8 *                         ioBuf;    UInt32                          Count;};typedef struct ATADataObject ATADataObject;&nbsp;</pre></TD></TR></TABLE></CENTER><BR><BR>                   <P>The meaning of the fields in the         <CODE>ATADataObject</CODE> structure are dependent on         whether scatter/gather is enabled for this request.         Scatter/gather is enabled if         <CODE>mATAFlagUseScatterGather</CODE> is set in the         <CODE>ataPBFlags</CODE> for the request. If scatter/gather         is not enabled, the fields have the following meaning:</P>                  <DL>            <DT><CODE>ioBuf</CODE></dt>                        <DD>ATA Manager sets this field to point to the start of            the data buffer for the transfer.</DD>                        <DT><CODE>Count</CODE></dt>                        <DD>ATA Manager sets this field to the count of the            number of bytes to transfer.</DD>         </DL>                  <P>If scatter/gather is enabled, the fields have the         following meaning:</P>                  <DL>            <DT><CODE>ioBuf</CODE></dt>                        <DD>ATA Manager sets this field to point to an array of            <CODE>IOBlock</CODE> structures (defined in "ATA.h").            Your AIM should transfer the data between the device and            the scatter/gather buffer defined by this array.</DD>                        <DT><CODE>Count</CODE></dt>                        <DD>ATA Manager sets this field to the number of            <CODE>IOBlock</CODE> structures in the array pointed to            by <CODE>ioBuf</CODE>.</DD>         </DL>                  <P>The <CODE>ataPBTaskFile</CODE> field of the         <CODE>ATAReqBlock</CODE> has the same structure as the         <CODE>ataPBTaskFile</CODE> field of the <CODE>ataIOPB</CODE>         (defined in "ATA.h"). Before issuing an execute I/O request         to your AIM, ATA Manager copies, without interpretation, the         task file from the client's <CODE>ataIOPB</CODE> to the         <CODE>ataPBTaskFile</CODE> field of the         <CODE>ATAReqBlock</CODE>. [It does, however, force the         <CODE>mATADriveSelect</CODE> bit of the         <CODE>ataTFSDH</CODE> field of the task file based on the         <CODE>devID</CODE> field of the <CODE>ATAReqBlock</CODE>.]         When your AIM completes the request, the ATA Manager copies         the <CODE>ataPBTaskFile</CODE> field back to the client's         <CODE>ataIOPB</CODE>.</P>                  <P>The <CODE>packetCBD</CODE> field of the         <CODE>ATAReqBlock</CODE> has the same structure as the         <CODE>ATAPICmdPacket</CODE> type defined in "ATA.h". By         default, the ATA Managers clears this field before issuing         an execute I/O request to your AIM. However, if the client         issued an ATAPI request (<CODE>mATAFlagProtocolATAPI</CODE>         was set in the <CODE>ataPBFlags</CODE> and         <CODE>ataPBPacketPtr</CODE> was not nil), ATA Manager copies         the <CODE>ATAPICmdPacket</CODE> pointed to by         <CODE>ataPBPacketPtr</CODE> into the <CODE>packetCBD</CODE>         field of the <CODE>ATAReqBlock</CODE>.</P>                  <P>For execute I/O requests, the ATA Manager sets the         <CODE>ataPBLogicalBlockSize</CODE> field of the         <CODE>ATAReqBlock</CODE> to         <CODE>ataPBLogicalBlockSize</CODE> field of the client's         request.</P>                  <H4><A NAME="kATAFnBusInquiry"></A>Bus Inquiry         (kATAFnBusInquiry)</H4>                  <P>ATA Manager issues this request to your AIM as the result         of a client's <CODE>kATAMgrBusInquiry</CODE> request. Your         AIM is expected to return information about the specified         ATA bus. The bulk of the <CODE>ATAReqBlock</CODE> is set up         <A HREF = "#ATAReqBlock">as described above</A>; only the         fields specific to this request are described here.</P>                  <P>The structure of the <CODE>busInfo</CODE> field of the         <CODE>ATAReqBlock</CODE> is shown below:</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATABusInfo {    UInt8                           ataPIOModes;    UInt8                           ataSingleDMAModes;    UInt8                           ataMultiDMAModes;    UInt8                           ataUltraDMAModes;    UInt32                          ataIOPBsize0;    UInt32                          ataIOPBsize1;    SInt8                           ataContrlType[16];    NumVersion                      ataHBAversion;    UInt32                          reserved3;};typedef struct ATABusInfo ATABusInfo;</pre></TD></TR></TABLE></CENTER><BR><BR>                               <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>ataPIOModes</CODE></dt>                                    <DD>Your AIM must set this field to a bit mask            representing the PIO transfer modes it supports. On            completion of the request, ATA Manager copies this field            into the <CODE>ataPIOModes</CODE> field of the client's            request.</DD>                        <DT><CODE>ataSingleDMAModes</CODE></dt>                        <DD>Your AIM must set this field to a bit mask            representing the singleword DMA transfer modes it            supports. On completion of the request, ATA Manager            copies this field into the <CODE>ataSingleDMAModes</CODE>            field of the client's request (unless the bus was            registered with the            <CODE><A HREF = "#AddBusFlags">mATANoDMAOnBus</A></CODE>&nbsp;flag,            in which case this field is ignored and the ATA Manager            clears the <CODE>ataSingleDMAModes</CODE> field of the            client's request).</DD>                        <DT><CODE>ataMultiDMAModes</CODE></dt>                        <DD>Your AIM must set this field to a bit mask            representing the multiword DMA transfer modes it            supports. On completion of the request, ATA Manager            copies this field into the <CODE>ataMultiDMAModes</CODE>            field of the client's request (unless the bus was            registered with the            <CODE><A HREF = "#AddBusFlags">mATANoDMAOnBus</A></CODE>&nbsp;flag,            in which case this field is ignored and the ATA Manager            clears the <CODE>ataMultiDMAModes</CODE> field of the            client's request).</DD>                        <DT><CODE>ataUltraDMAModes</CODE></dt>                        <DD>Your AIM must set this field to a bit mask            representing the UltraDMA transfer modes it supports. On            completion of the request, ATA Manager copies this field            into the <CODE>ataUltraDMAModes</CODE> field of the            client's request (unless the bus was registered with the            <CODE><A HREF = "#AddBusFlags">mATANoDMAOnBus</A></CODE>&nbsp;flag,            in which case this field is ignored and the ATA Manager            clears the <CODE>ataUltraDMAModes</CODE> field of the            client's request).</DD>                        <DT><CODE>ataIOPBsize0</CODE></dt>                        <DD>Your AIM must set this field to            <CODE>kATADefaultBlockSize</CODE> (512). This field was            originally intended to hold the size of an ATA sector on            device 0, but developments in the ATA standard (namely            ATAPI) have obviated the need for this information.</DD>                        <DT><CODE>ataIOPBsize1</CODE></dt>                        <DD>Your AIM must set this field to            <CODE>kATADefaultBlockSize</CODE> (512). This field was            originally intended to hold the size of an ATA sector on            device 1, but developments in the ATA standard (namely            ATAPI) have obviated the need for this information.</DD>                        <DT><CODE>ataContrlType</CODE></dt>                        <DD>Your AIM may set this field to any value, including            characters or binary data. The field is intended as a            mechanism to report a vendor or model name, or other data            for identification or diagnostic purposes. If you do not            implement this functionality, you should clear the entire            field. On completion of the request, ATA Manager copies            this field into the <CODE>ataContrlType</CODE> field of            the client's request.</DD>                        <DT><CODE>ataHBAversion</CODE></dt>                        <DD>Your AIM must put its version number in this field.            On completion of the request, ATA Manager copies this            field into the <CODE>ataHBAversion</CODE> field of the            client's request.</DD>                        <DT><CODE>reserved3</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</dd>         </DL>                  <H4>I/O Queue Release (kATAFnQRelease)</H4>                  <P>Requests of this type should never be passed through to         your AIM. Your AIM should treat this as an unrecognized         function code.</P>                  <H4>ATA Command (kATAFnCmd)</H4>                  <P>Requests of this type should never be passed through to         your AIM. Your AIM should treat this as an unrecognized         function code.</P>                  <H4>Abort Command (kATAFnAbort)</H4>                  <P>Requests of this type should never be passed through to         your AIM. Your AIM should treat this as an unrecognized         function code.</P>                  <H4><A NAME="kATAFnBusReset"></A>Reset ATA Bus         (kATAFnBusReset)</H4>                  <P>ATA Manager issues this request to your AIM as the result         of a client's <CODE>kATAMgrBusReset</CODE> request. Your AIM         is expected to reset the specified ATA bus. The         <CODE>ATAReqBlock</CODE> is set up <A HREF = "#ATAReqBlock">as         described above</A>; there are no fields specific to this         request.</P>                  <H4><A NAME="kATAFnRegAccess"></A>Register Access         (kATAFnRegAccess)</H4>                  <P>ATA Manager issues this request to your AIM as the result         of a client's <CODE>kATAMgrRegAccess</CODE> request. Your         AIM is expected to read or write the specified ATA         registers. The bulk of the <CODE>ATAReqBlock</CODE> is set         up <A HREF = "#ATAReqBlock">as described above</A>; only the         fields specific to this request are described here.</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                                    Your AIM must determine whether to read or write                  the ATA registers based on the                  <CODE>mATAFlagIOWrite</CODE> flag in the                  <CODE>ataPBFlags</CODE> field of the                  <CODE>ATAReqBlock</CODE>.</p></TD>            </TR>         </TABLE></CENTER>         <BR>                                 <P>The structure of the <CODE>DiagResult</CODE> field of the         <CODE>ATAReqBlock</CODE> is shown below.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATADiagResult {    UInt16                          ataRegMask;    OSStatus                        ataResult;    UInt16                          ataDataReg;    UInt8                           ataTFFeatures;    UInt8                           ataTFCount;    UInt8                           ataTFSector;    UInt8                           ataTFCylinderLo;    UInt8                           ataTFCylinderHi;    UInt8                           ataTFSDH;    UInt8                           ataTFCommand;    UInt8                           ataAltStatDevCnt;};typedef struct ATADiagResult ATADiagResult;</pre></TD></TR></TABLE></CENTER><BR><BR>         <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>ataRegMask</CODE></dt>                        <DD>The ATA Manager sets bits in this field to indicate            which registers to read or write. The bit mask are            defined in "ATA.h" (<CODE>mATAAltSDevCValid</CODE>,            <CODE>mATAStatusCmdValid</CODE>,            <CODE>mATASDHValid</CODE>, and so on).</dd>                        <DT><CODE>ataResult</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</dd>                        <DT><CODE>ataDataReg</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA data register (always a 16-bit write) if            <CODE>mATADataValid</CODE> is set in            <CODE>ataRegMask</CODE>. For a read operation, your AIM            must read the ATA data register (always a 16-bit read)            and put it in this field if <CODE>mATADataValid</CODE> is            set in <CODE>ataRegMask</CODE>.</dd>                        <DT><CODE>ataTFFeatures</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA error register if            <CODE>mATAErrFeaturesValid</CODE> is set in            <CODE>ataRegMask</CODE>. For a read operation, your AIM            must read the ATA features register and put it in this            field if <CODE>mATAErrFeaturesValid</CODE> is set in            <CODE>ataRegMask</CODE>.</dd>                        <DT><CODE>ataTFCount</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA sector count register if            <CODE>mATASectorCntValid</CODE> is set in            <CODE>ataRegMask</CODE>. For a read operation, your AIM            must read the ATA sector count register and put it in            this field if <CODE>mATASectorCntValid</CODE> is set in            <CODE>ataRegMask</CODE>.</dd>                        <DT><CODE>ataTFSector</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA sector number register if            <CODE>mATASectorNumValid</CODE> is set in            <CODE>ataRegMask</CODE>. For a read operation, your AIM            must read the ATA sector number register and put it in            this field if <CODE>mATASectorNumValid</CODE> is set in            <CODE>ataRegMask</CODE>.</dd>                        <DT><CODE>ataTFCylinderLo</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA cylinder low register if            <CODE>mATACylinderLoValid</CODE> is set in            <CODE>ataRegMask</CODE>. For a read operation, your AIM            must read the ATA cylinder low register and put it in            this field if <CODE>mATACylinderLoValid</CODE> is set in            <CODE>ataRegMask</CODE>.</dd>                        <DT><CODE>ataTFCylinderHi</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA cylinder high register if            <CODE>mATACylinderHiValid</CODE> is set in            <CODE>ataRegMask</CODE>. For a read operation, your AIM            must read the ATA cylinder high register and put it in            this field if <CODE>mATACylinderHiValid</CODE> is set in            <CODE>ataRegMask</CODE>.</dd>                        <DT><CODE>ataTFSDH</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA SDH register if <CODE>mATASDHValid</CODE> is            set in <CODE>ataRegMask</CODE>. For a read operation,            your AIM must read the ATA SDH register and put it in            this field if <CODE>mATASDHValid</CODE> is set in            <CODE>ataRegMask</CODE>.</dd>                        <DT><CODE>ataTFCommand</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA command register if            <CODE>mATAStatusCmdValid</CODE> is set in            <CODE>ataRegMask</CODE>. For a read operation, your AIM            must read the ATA status register and put it in this            field if <CODE>mATAStatusCmdValid</CODE> is set in            <CODE>ataRegMask</CODE>.</dd>                        <DT><CODE>ataAltStatDevCnt</CODE></dt>                        <DD>For a write operation, your AIM must write this field            to the ATA device control register if            <CODE>mATAAltSDevCValid</CODE> is set in            <CODE>ataRegMask</CODE>. For a read operation, your AIM            must read the ATA alternate status register and put it in            this field if <CODE>mATAAltSDevCValid</CODE> is set in            <CODE>ataRegMask</CODE>.</dd>         </DL>                  <H4><A NAME="kATAFnDriveIdentify"></A>Drive Identify         (kATAFnDriveIdentify)</H4>                  <P>ATA Manager issues this request to your AIM as the result         of a client's <CODE>kATAMgrDriveIdentify</CODE> request.         Your AIM is expected to execute an ATA drive identify         command (<CODE>kATAcmdDriveIdentify</CODE>). This request is         very similar to a standard <A HREF = "#kATAFnExecIO">execute         I/O request</A> except for the following:</P>                  <UL>            <LI>Your AIM must force the I/O to be byte swapped            (typically by setting <CODE>mATAFlagByteSwap</CODE> in            <CODE>ataPBFlags</CODE>).</li>                        <LI>Your AIM must always attempt to transfer 512 bytes            (typically by overwriting the <CODE>Count</CODE> field of            the <CODE>ioObject</CODE> with 512).</li>                        <LI>Your AIM must always use a 512 byte logical block            size (typically be overwriting            <CODE>ataPBLogicalBlockSize</CODE> with 512).</li>                        <LI>Your AIM must issue an ATA drive identify command            (typically by overwriting the <CODE>ataTFCommand</CODE>            field of the <CODE>ataPBTaskFile</CODE> with            <CODE>kATAcmdDriveIdentify</CODE> and the            <CODE>ataTFSDH</CODE> of the <CODE>ataPBTaskFile</CODE>            with <CODE>mATASectorSize</CODE>).</li>         </UL>                  <P>Once it has modified the parameter block in this way,         your AIM can simply pass this request through to the execute         I/O logic.</P>                  <H4>Execute ATAPI I/O (kATAPIFnExecIO)</H4>                  <P>Requests of this type should never be passed through to         your AIM. Your AIM should treat this as an unrecognized         function code.</P>                  <H4>ATAPI Command (kATAPIFnCmd)</H4>                  <P>Requests of this type should never be passed through to         your AIM. Your AIM should treat this as an unrecognized         function code.</P>                  <H4><A NAME="kATAFnGetDriveConfig"></A>Get Drive         Configuration (kATAFnGetDriveConfig)</H4>                  <P>ATA Manager issues this request to your AIM as the result         of a client's <CODE>kATAMgrGetDrvConfiguration</CODE>         request. Your AIM is expected to return information about a         device's current configuration. The bulk of the         <CODE>ATAReqBlock</CODE> is set up <A HREF = "#ATAReqBlock">as         described above</A>; only the fields specific to this         request are described here.</P>                  <P>The structure of the <CODE>devConfig</CODE> field of the         <CODE>ATAReqBlock</CODE> is shown below.</P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ATADevConfig {    SInt32                          ataConfigSetting;    UInt8                           ataPIOSpeedMode;    UInt8                           reserved;    UInt16                          atapcValid;    UInt16                          ataRWMultipleCount;    UInt16                          ataSectorsPerCylinder;    UInt16                          ataHeads;    UInt16                          ataSectorsPerTrack;    UInt16                          ataSocketNumber;    UInt8                           ataSocketType;    UInt8                           ataDeviceType;    UInt8                           atapcAccessMode;    UInt8                           atapcVcc;    UInt8                           atapcVpp1;    UInt8                           atapcVpp2;    UInt8                           atapcStatus;    UInt8                           atapcPin;    UInt8                           atapcCopy;    UInt8                           atapcConfigIndex;    UInt8                           ataSingleDMASpeed;    UInt8                           ataMultiDMASpeed;    UInt16                          ataPIOCycleTime;    UInt16                          ataMultiCycleTime;    UInt8                           ataUltraDMASpeed;    UInt8                           reserved2;    UInt16                          ataUltraCycleTime;    UInt16                          Reserved1[5];};typedef struct ATADevConfig ATADevConfig;</pre></TD></TR></TABLE></CENTER><BR><BR>                      <P>The fields have the following meaning:</P>                  <DL>            <DT><CODE>ataConfigSetting</CODE></dt>                        <DD>Your AIM must set this field to indicate the device            configuration settings currently in use. The possible            values are defined in            <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATA            Device Software for Macintosh Computers</A>. On            completion of the request, ATA Manager copies this field            into the <CODE>ataConfigSetting</CODE> field of the            client's request.</dd>                        <DT><CODE>ataPIOSpeedMode</CODE></dt>                        <DD>Your AIM must set this field to indicate which PIO            models are enabled for this device. On completion of the            request, ATA Manager copies this field into the            <CODE>ataPIOSpeedMode</CODE> field of the client's            request.</dd>                        <DT><CODE>reserved</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</dd>                        <DT><CODE>atapcValid</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents. On completion of the request, ATA Manager            updates the <CODE>mATApcLockUnlock</CODE> flag to            indicate whether the device is currently locked.</dd>                        <DT><CODE>ataRWMultipleCount<BR>                        ataSectorsPerCylinder<BR>                        ataHeads<BR>                        ataSectorsPerTrack</CODE></dt>                        <DD>Reserved. <STRONG>Your AIM must set these fields to            zero.</STRONG> On completion of the request, ATA Manager            copies this field into the corresponding fields of the            client's request.</dd>                        <DT><CODE>ataSocketNumber</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents. This field was used in previous versions of            ATA Manager (which handled much of the PC Card socket            configuration internally) but is now obsolete, replaced            by functionality in PC Card Manager.</dd>                        <DT><CODE>ataSocketType</CODE></dt>                        <DD>Your AIM should ignore this field; on completion, ATA            Manager will set it based on your AIM's socket type.</dd>                        <DT><CODE>ataDeviceType</CODE></dt>                        <DD>Your AIM must set this to the type of the device (for            example, <CODE>kATADeviceATA</CODE> or            <CODE>kATADeviceATAPI</CODE>) specified by the            <CODE>devID</CODE> and <CODE>busID</CODE> fields of the            <CODE>ATAReqBlock</CODE>. Typically your AIM returns a            copy of the information it derived during initialization            (<CODE><A HREF = "#MyAIMInit">MyAIMInit</A></CODE>) On            completion of the request, ATA Manager copies this field            into the <CODE>ataDeviceType</CODE> field of the client's            request.</dd>                        <DT><CODE>atapcAccessMode</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents. This field is obsolete with ATA Manager            4.0. It was previously defined to support different            access modes for PC Card devices but that support was            never implemented.</dd>                        <DT><CODE>atapcVcc<BR>                        atapcVpp1<BR>                        atapcVpp2<BR>                        atapcStatus<BR>                        atapcPin<BR>                        atapcCopy<BR>                        atapcConfigIndex</CODE></dt>                        <DD>Reserved. You must not modify these fields or depend            on their contents. These fields were used in previous            versions of ATA Manager (which handled much of the PC            Card socket configuration internally) but are now            obsolete, replaced by functionality in PC Card Manager.</dd>                        <DT><CODE>ataSingleDMASpeed</CODE></dt>                        <DD>Your AIM must set this field to indicate which            singleword DMA speeds are enabled for this device. On            completion of the request, ATA Manager copies this field            into the <CODE>ataSingleDMASpeed</CODE> field of the            client's request.</dd>                        <DT><CODE>ataMultiDMASpeed</CODE></dt>                        <DD>Your AIM must set this field to indicate which            multiword DMA speeds are enabled for this device. On            completion of the request, ATA Manager copies this field            into the <CODE>ataMultiDMASpeed</CODE> field of the            client's request.</dd>                        <DT><CODE>ataPIOCycleTime</CODE></dt>                        <DD>Your AIM must set this field to the current minimum            cycle time (in milliseconds) for mode 3 or greater PIO            transfers. On completion of the request, ATA Manager            copies this field into the <CODE>ataPIOCycleTime</CODE>            field of the client's request.</dd>                        <DT><CODE>ataMultiCycleTime</CODE></dt>                        <DD>Your AIM must set this field to the current minimum            cycle time (in milliseconds) for multiword DMA transfers.            On completion of the request, ATA Manager copies this            field into the <CODE>ataMultiCycleTime</CODE> field of            the client's request.</dd>                        <DT><CODE>ataUltraDMASpeed</CODE></dt>                        <DD>Your AIM must set this field to indicate which            UltraDMA speeds are enabled for this device. On            completion of the request, ATA Manager copies this field            into the <CODE>ataUltraDMASpeed</CODE> field of the            client's request.</dd>                        <DT><CODE>reserved2</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</dd>                        <DT><CODE>ataUltraCycleTime</CODE></dt>                        <DD>Your AIM must set this field to the current minimum            cycle time (in milliseconds) for UltraDMA transfers. On            completion of the request, ATA Manager copies this field            into the <CODE>ataUltraCycleTime</CODE> field of the            client's request.</dd>                        <DT><CODE>Reserved1</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</dd>         </DL>                  <H4><A NAME="kATAFnSetDriveConfig"></A>Set Drive         Configuration (kATAFnSetDriveConfig)</H4>                  <P>ATA Manager issues this request to your AIM as the result         of a client's <CODE>kATAMgrSetDrvConfiguration</CODE>         request. Your AIM is expected to set the device's current         configuration based on the supplied parameter block. The         bulk of the <CODE>ATAReqBlock</CODE> is set up         <A HREF = "#ATAReqBlock">as described above</A>; only the         fields specific to this request are described here.</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                                    To understand how your AIM should interpret the                  various I/O mode and cycle time fields of this                  request, see the <A HREF = "#ATAIOModes">ATA I/O</A>                  section, earlier in this document.</p></TD>            </TR>         </TABLE></CENTER>         <BR>                                 <P>The <CODE>devConfig</CODE> field of the         <CODE>ATAReqBlock</CODE> is         <A HREF = "#kATAFnGetDriveConfig">defined above</A>. For a         <CODE>kATAFnSetDriveConfig</CODE> request, the fields have         the following meaning:</P>                  <DL>            <DT><CODE>ataConfigSetting</CODE></dt>                        <DD>The ATA Manager sets this field to required device            configurations settings. The value is derived from the            <CODE>ataConfigSetting</CODE> field of the client            request. The possible values are defined in            <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATA            Device Software for Macintosh Computers</A>. Your AIM            must act on these configuration settings for all            subsequent I/O operations.</dd>                        <DT><CODE>ataPIOSpeedMode</CODE></dt>                        <DD>The ATA Manager sets this field to required PIO speed            mode for the device. The value is derived from the            <CODE>ataPIOSpeedMode</CODE> field of the client request.            Your AIM must use this PIO speed for all subsequent PIO            transfers.</dd>                        <DT><CODE>reserved</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</dd>                        <DT><CODE>atapcValid</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents. This field was used in previous versions of            ATA Manager (which handled much of the PC Card socket            configuration internally) but is now obsolete, replaced            by functionality in PC Card Manager. Note that ATA            Manager still honors the <CODE>mATApcLockUnlock</CODE>            flag in this field by calling your device lock            (<A HREF = "#MyAIMDeviceLock">MyAIMDeviceLock</A>) routine            as part of handling a            <CODE>kATAMgrSetDrvConfiguration</CODE> request.</DD>                        <DT><CODE>ataRWMultipleCount<BR>                        ataSectorsPerCylinder<BR>                        ataHeads<BR>                        ataSectorsPerTrack</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</DD>                        <DT><CODE>ataSocketNumber</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents. This field was used in previous versions of            ATA Manager (which handled much of the PC Card socket            configuration internally) but is now obsolete, replaced            by functionality in PC Card Manager.</DD>                        <DT><CODE>ataSocketType</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</DD>                        <DT><CODE>ataDeviceType</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</DD>                        <DT><CODE>atapcAccessMode</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents. This field is obsolete with ATA Manager            4.0. It was previously defined to support different            access modes for PC Card devices but that support was            never implemented.</DD>                        <DT><CODE>atapcVcc<BR>                        atapcVpp1<BR>                        atapcVpp2<BR>                        atapcStatus<BR>                        atapcPin<BR>                        atapcCopy<BR>                        atapcConfigIndex</CODE></dt>                        <DD>Reserved. You must not modify these fields or depend            on their contents. These fields were used in previous            versions of ATA Manager (which handled much of the PC            Card socket configuration internally) but are now            obsolete, replaced by functionality in PC Card Manager.</dd>                        <DT><CODE>ataSingleDMASpeed</CODE></dt>                        <DD>The ATA Manager sets this field to the required            singleword DMA speed modes for the device. The value is            derived from the <CODE>ataSingleDMASpeed</CODE> field of            the client request. It is only valid if            <CODE>ataModeType</CODE> is <CODE>kATAModeBitmap</CODE>.            Your AIM may use these speeds for all subsequent            singleword DMA transfers.</dd>                        <DT><CODE>ataMultiDMASpeed</CODE></dt>                        <DD>The ATA Manager sets this field to the required            multiword DMA speed modes for the device. The value is            derived from the <CODE>ataMultiDMASpped</CODE> field of            the client request. It is only valid if            <CODE>ataModeType</CODE> is <CODE>kATAModeBitmap</CODE>.            Your AIM may use these speeds for all subsequent            multiword DMA transfers.</dd>                        <DT><CODE>ataPIOCycleTime</CODE></dt>                        <DD>The ATA Manager sets this field to the required            maximum PIO cycle time for the device. The value is            derived from the <CODE>ataPIOCycleTime</CODE> field of            the client request. It is only valid if            <CODE>ataModeType</CODE> is <CODE>kATAModeBitmap</CODE>.            Your AIM may use this, or a slower time, for subsequent            PIO transfers.</dd>                        <DT><CODE>ataMultiCycleTime</CODE></dt>                        <DD>The ATA Manager sets this field to the required            maximum multiword DMA cycle time for the device. The            value is derived from the <CODE>ataMultiCycleTime</CODE>            field of the client request. It is only valid if            <CODE>ataModeType</CODE> is <CODE>kATAModeBitmap</CODE>.            Your AIM may use this, or a slower time, for subsequent            multiword DMA transfers.</dd>                        <DT><CODE>ataUltraDMASpeed</CODE></dt>                        <DD>The ATA Manager sets this field to the required            UltraDMA speed modes for the device. The value is derived            from the <CODE>ataUltraDMASpeed</CODE> field of the            client request. It is only valid if            <CODE>ataModeType</CODE> is <CODE>kATAModeBitmap</CODE>.            Your AIM may use these speeds for all subsequent UltraDMA            transfers.</dd>                        <DT><CODE>reserved2</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</dd>                        <DT><CODE>ataUltraCycleTime</CODE></dt>                        <DD>The ATA Manager sets this field to the required            maximum UltraDMA cycle time for the device. The value is            derived from the <CODE>ataUltraCycleTime</CODE> field of            the client request. It is only valid if            <CODE>ataModeType</CODE> is <CODE>kATAModeBitmap</CODE>.            Your AIM may use this, or a slower time, for subsequent            UltraDMA transfers.</dd>                        <DT><CODE>Reserved1</CODE></dt>                        <DD>Reserved. You must not modify this field or depend on            its contents.</dd>         </DL>                  <H4><A NAME="kATAFnKillIO"></A>Kill Current I/O         (kATAFnKillIO)</H4>                  <P>The ATA Manager issues this request to your AIM as part         of the process of <A HREF = "#RemoveATABus">removing your ATA         bus</A>. You AIM must respond to this request by terminating         any hardware transaction on the ATA bus. This is an         immediate request: your AIM must complete the request before         returning from its action routine         (<CODE><A HREF = "#MyAIMAction">MyAIMAction</A></CODE>) and         must not call         <CODE><A HREF = "#ATAFamIODone">ATAFamIODone</A></CODE> for         the request.</P>                  <CENTER><TABLE BORDER=0 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                                    <CODE>kATAFnKillIO</CODE> is different from other                  action requests in that none of the standard                  <CODE>ATAReqBlock</CODE> fields are set up for                  <CODE>kATAFnKillIO</CODE>. The only valid field in                  the <CODE>ATAReqBlock</CODE> for a                  <CODE>kATAFnKillIO</CODE> request is the function                  code itself (<CODE>ataFunctionCode</CODE>).</p></TD>            </TR>         </TABLE></CENTER>         <BR>               <P><A HREF = "#top">Back to top</A></P>        <A NAME="AIMSupportRoutines"></A>                  <H2>AIM Support Routines</H2>                  <P>This section describes the AIM support routines exported         by the ATA Manager for convenience of AIMs. Your AIM must         use the routines described below to signal the ATA Manager         that certain events have occurred.</P>                  <H4><A NAME="ATAFamIODone"></A>ATAFamIODone</H4>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void ATAFamIODone(ATAReqBlock *theReq, OSStatus result);</pre></TD></TR></TABLE></CENTER><BR><BR>                                             <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>theReq</CODE>               </TD><td align="left">The action request to complete               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>result</CODE>               </TD><td align="left">The final status of the request, either                  <CODE>noErr</CODE> or a negative error code               </TD></TR>         </TABLE><BR>                  <P>Your AIM must call this routine to inform ATA Manager         that the AIM action request is complete. ATA Manager         executes the following steps:</P>                  <OL>            <LI>It copies information from the AIM request block            (<CODE>theReq</CODE>) into the client's ATA request            block.</li>                        <LI>If stores <CODE>result</CODE> in the            <CODE>ataResult</CODE> field of the client's request            block.</li>                        <LI>It calls the client's completion routine, if one was            supplied.</li>                        <LI>It dispatches the next ATA request, if any, to the            AIM's action routine.</li>         </OL>                  <P>You must call this routine from the context of your AIM's         action routine         (<CODE><A HREF = "#MyAIMAction">MyAIMAction</A></CODE>) or its         bus event handler         (<CODE><A HREF = "#MyAIMHandleBusEvent">MyAIMHandleBusEvent</A></CODE>).         </P>                  <H4><A NAME="ATAFamBusEventForAIM"></A>ATAFamBusEventForAIM         </H4>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern void ATAFamBusEventForAIM(UInt32 busID, UInt32 aimData);</pre></TD></TR></TABLE></CENTER><BR><BR>                        <Table BORDER=1>            <TR>               <td width=134 align=left>                  <CODE>busID</CODE>               </TD><td align="left">The ATA bus on which the event occurred               </TD></TR>            <TR>               <td width=134 align=left>                  <CODE>aimData</CODE>               </TD><td align="left">                  The bus event type; the ATA Manager does not                  interpret this value, it simply passes it back to                  your AIM's bus event handler                  (<CODE><A HREF = "#MyAIMHandleBusEvent">MyAIMHandleBusEvent</A></CODE>)                              </TD></TR>         </TABLE><BR>                  <P>Your AIM must call this routine when it wants to         scheduled its bus event handler         (<CODE><A HREF = "#MyAIMHandleBusEvent">MyAIMHandleBusEvent</A></CODE>)         to be executed. Typically it does this from a hardware         interrupt handler. ATA queues the bus event and calls your         AIM's bus event handler at the next opportune moment.</P>                  <P>See <A HREF = "#AIMSynchronizationModel">AIM         Synchronization Model</A> for an in-depth discussion of why         this is both necessary and convenient.</P>                  <P>You may call this routine at any execution level.</p>      <a name="References"></a><H2>References</H2>            <p><a href="http://developer.apple.com/documentation/hardware/DeviceManagers/pci_srvcs/pci_srvcs.html">Designing            PCI Cards and Drivers for Power Macintosh Computers</A></p>                        <p><a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/frameset.html">ATA            Device Software for Macintosh Computers</A></p>                        <p><a href="http://developer.apple.com/documentation/hardware/Developer_Notes/System_Software/ATA_Device_Zero_One.pdf">ATA            Device 0/1 Software Developer's Guide</A></p>                        <p>DTS Technote 1098            <A HREF = "tn1098.html">ATA            Device Software Guide Additions and Corrections</A>.</p>                        <p>ANSI NCITS 317-1998 <CITE>AT Attachment - 4 with            Packet Interface Extension</CITE></p>                        <p>DTS Technote 1094            <A HREF = "tn1094.html">Virtual            Memory Application Compatibility</A></p>                        <p>DTS Q&amp;A DV 34            <a href="../../qa/dv/dv34.html">Secondary            Interrupts on the Page Fault Path</A></p><BR><P><A HREF="#top">Back to top</A></P><A NAME="Downloads"></A> <h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">         <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (128K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1192.pdf">Download</A></P>            </TD>          </TR>                    <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/bluebook.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>AIM Interfaces and Libraries (8 KB)</P>            </TD>            <td width=60 align=left>               <p><A HREF="downloads/tn1192.1.hqx">Download</A></P>            </TD>          </TR> </table></center><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1192.html%3Fid%3DDTS10003031-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1192.html%3Fid%3DDTS10003031-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1192.html%3Fid%3DDTS10003031-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>