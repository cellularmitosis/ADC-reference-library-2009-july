<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shell Scripting Primer: Performance Tuning</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Performance Tuning"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004268-TP40003520" title="Performance Tuning"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP40003594" target="_top">Open Source</a> &gt; <a href="../../../Scripting-date.html#//apple_ref/doc/uid/TP30000440-TP40003594-TP30000569" target="_top">Scripting &amp; Automation</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004268-TP40003516-SW1">Shell Scripting Primer</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AdvancedTechniques/AdvancedTechniques.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ForMoreInformation/ForMoreInformation.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW20" title="Performance Tuning"></a><h1>Performance Tuning</h1><p>Shell scripts, when compared with compiled languages, generally do not perform well. However, most shell scripts also do not perform as well as they could with a bit of performance tuning. This chapter shows some common pitfalls of shell scripting and demonstrates how to fix these mistakes.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="performance.html#//apple_ref/doc/uid/TP40004268-TP40003520-SW1">Avoiding Unnecessary External Commands</a>
				
			<br/>
			
        
			
			
				<a href="performance.html#//apple_ref/doc/uid/TP40004268-TP40003520-SW7">Other Performance Tips</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW1" title="Avoiding Unnecessary External Commands"></a><h2>Avoiding Unnecessary External Commands</h2><p>Every line of code in a shell script takes time to execute. This section shows two examples in which <a name="//apple_ref/doc/uid/TP40004268-TP40003520-DontLinkElementID_436"></a>avoiding unnecessary external commands results in a significant performance improvement.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW6" title="Finding the Ordinal Rank of a Character (More Quickly)"></a><h3>Finding the Ordinal Rank of a Character (More Quickly)</h3><p>The Monte Carlo method sample code, found in <span class="content_text"><a href="../AnExtremeExample/AnExtremeExample.html#//apple_ref/doc/uid/TP40004268-TP40003515-SW4">“An Extreme Example: The Monte Carlo (Bourne) Method for Pi,”</a></span> shows a number of ways to calculate the ordinal value of a byte. The version written using a pure shell approach is painfully slow, in large part because of the loops required.</p><p>The best way to optimize performance is to find an external utility written in a compiled language that can perform the same task more easily. Thus, the solution to that performance problem was to use the <code><a href="../../../../Darwin/Reference/ManPages/man1/perl.1.html#//apple_ref/doc/man/1/perl" target="_top">perl</a></code> or <code><a href="../../../../Darwin/Reference/ManPages/man1/awk.1.html#//apple_ref/doc/man/1/awk" target="_top">awk</a></code> interpreter to do the heavy lifting. Although they are not compiled languages, both Perl and AWK have compiled routines (<code><!--a-->ord<!--/a--></code> and <code><!--a-->index<!--/a--></code>, respectively) to find the index of a character within a string.</p><p>However, when using outside utilities is not possible, you can still reduce the complexity by executing outside tools less frequently. For example, once you have an initialized array containing all of the characters from 1–255 (skipping null), you can reduce the number of iterations by removing more than one character at a time until the character disappears, then going back by one batch of characters and working your way forward again, one character at a time.</p><p>The following code runs more than twice as fast (on average) as the purely linear search:</p><div class="codesample"><table><tr><td scope="row"><pre>function ord2()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    local CH="$1"<span></span></pre></td></tr><tr><td scope="row"><pre>    local STRING=""<span></span></pre></td></tr><tr><td scope="row"><pre>    local OCCOPY=$ORDSTRING<span></span></pre></td></tr><tr><td scope="row"><pre>    local COUNT=0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Delete ten characters at a time.  When this loop<span></span></pre></td></tr><tr><td scope="row"><pre>    # completes, the decade containing the character<span></span></pre></td></tr><tr><td scope="row"><pre>    # will be stored in LAST.<span></span></pre></td></tr><tr><td scope="row"><pre>    CONT=1<span></span></pre></td></tr><tr><td scope="row"><pre>    BASE=0<span></span></pre></td></tr><tr><td scope="row"><pre>    LAST="$OCCOPY"<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ $CONT = 1 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>        LAST=`echo "$OCCOPY" | sed 's/^\(..........\)/\1/'`<span></span></pre></td></tr><tr><td scope="row"><pre>        OCCOPY=`echo "$OCCOPY" | sed 's/^..........//'`<span></span></pre></td></tr><tr><td scope="row"><pre>        CONT=`echo "$OCCOPY" | grep -c "$CH"`<span></span></pre></td></tr><tr><td scope="row"><pre>        BASE=`expr $BASE + 10`<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre>    BASE=`expr $BASE - 10`<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Search for the character in LAST.<span></span></pre></td></tr><tr><td scope="row"><pre>    CONT=1;<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ $CONT = 1 ]; do<span></span></pre></td></tr><tr><td scope="row"><pre>        # Copy the string so we know if we've stopped finding<span></span></pre></td></tr><tr><td scope="row"><pre>        # nonmatching characters.<span></span></pre></td></tr><tr><td scope="row"><pre>        OCTEMP="$LAST"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # echo "CH WAS $CH"<span></span></pre></td></tr><tr><td scope="row"><pre>        # echo "ORDSTRING: $ORDSTRING"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # If it's a close bracket, quote it; we don't want to<span></span></pre></td></tr><tr><td scope="row"><pre>        # break the regexp.<span></span></pre></td></tr><tr><td scope="row"><pre>        if [ "x$CH" = "x]" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>                CH='\]'<span></span></pre></td></tr><tr><td scope="row"><pre>        fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # Delete a character if possible.<span></span></pre></td></tr><tr><td scope="row"><pre>        LAST=$(echo "$LAST" | sed "s/^[^$CH]//");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # On error, we're done.<span></span></pre></td></tr><tr><td scope="row"><pre>        if [ $? != 0 ] ; then CONT=0 ; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # If the string didn't change, we're done.<span></span></pre></td></tr><tr><td scope="row"><pre>        if [ "x$OCTEMP" = "x$LAST" ] ; then CONT=0 ; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # Increment the counter so we know where we are.<span></span></pre></td></tr><tr><td scope="row"><pre>        COUNT=$((COUNT + 1)) # or COUNT=$(expr $COUNT '+' 1)<span></span></pre></td></tr><tr><td scope="row"><pre>        # echo "COUNT: $COUNT"<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    COUNT=$(($COUNT + 1 + $BASE)) # or COUNT=$(expr $COUNT '+' 1)<span></span></pre></td></tr><tr><td scope="row"><pre>    # If we ran out of characters, it's a null (character 0).<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ "x$OCTEMP" = "x" ] ; then COUNT=0; fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "ORD IS $COUNT";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # Return the ord of the character in question....<span></span></pre></td></tr><tr><td scope="row"><pre>    echo $COUNT<span></span></pre></td></tr><tr><td scope="row"><pre>    # exit 0<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As you tune, you should be cognizant of the average case time. In the case of a linear search, assuming all possible character values are equally likely, the average time is half of the number of items in the list, or about 127 comparisons. Searching in units of 10, the average is about 1/10 of that plus half of 10, or about 17.69 comparisons, with a worst case of 34 comparisons. The optimal value is 16, with an average of 15.9375 comparisons, and a worst case of 30 comparisons.</p><p>Of course, you could write the code as a binary search. Because splitting a string is not easy to do quickly, a binary search works best with strings of known length in which you can cache a series of strings containing some number of periods. If you are searching a string of arbitrary length, this technique would probably be much, much slower than a linear search (unless you use BASH-specific substring expansion, as described in <span class="content_text"><a href="../AdvancedTechniques/AdvancedTechniques.html#//apple_ref/doc/uid/TP40004268-TP40003521-SW16">“Truncating Strings”</a></span>).</p><p>Caching the strings of periods used in the splitting process increases initialization time slightly, but after that, the execution time of the search itself improves by about a factor of 2 compared to the “skip 16” version. Whether that tradeoff is appropriate depends largely on how many times you need to perform this operation. If the answer is once, then the extra initialization time will likely erase any performance gain from using the binary search. If the answer is more than once, the binary search is preferable.</p><p><span class="content_text">Listing 8-1</span> contains the binary search version.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW2" title="Listing 8-1A binary search version of the Bourne shell ord function"></a><p class="codesample"><strong>Listing 8-1&nbsp;&nbsp;</strong>A binary search version of the Bourne shell <code>ord</code> function</p><div class="codesample"><table><tr><td scope="row"><pre># Initialize the split strings.  This code should be added to ord_init.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SPLIT=128<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ $SPLIT -ge 1 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>        COUNT=$SPLIT<span></span></pre></td></tr><tr><td scope="row"><pre>        STRING=""<span></span></pre></td></tr><tr><td scope="row"><pre>        while [ $COUNT -gt 0 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>                STRING="$STRING""."<span></span></pre></td></tr><tr><td scope="row"><pre>                COUNT=$((COUNT - 1))<span></span></pre></td></tr><tr><td scope="row"><pre>        done<span></span></pre></td></tr><tr><td scope="row"><pre>        eval "SPLIT_$SPLIT=\"$STRING\"";<span></span></pre></td></tr><tr><td scope="row"><pre>        SPLIT=$((SPLIT / 2))<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function split_str()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        STR="$1"<span></span></pre></td></tr><tr><td scope="row"><pre>        NUM="$2"<span></span></pre></td></tr><tr><td scope="row"><pre>        SPLIT="$(eval "echo \"\$SPLIT_$NUM\"")"<span></span></pre></td></tr><tr><td scope="row"><pre>        LEFT="$(echo "$STR" | sed "s/^\\($SPLIT\\).*$/\\1/")"<span></span></pre></td></tr><tr><td scope="row"><pre>        RIGHT="$(echo "$STR" | sed "s/^$SPLIT//")"<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function ord3()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    local CH="$1"<span></span></pre></td></tr><tr><td scope="row"><pre>    OCCOPY="$ORDSTRING"<span></span></pre></td></tr><tr><td scope="row"><pre>    FIRST=1;<span></span></pre></td></tr><tr><td scope="row"><pre>    LAST=257<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ord3_sub "$CH" "$ORDSTRING" $FIRST $LAST<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function ord3_sub()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    local CH="$1"<span></span></pre></td></tr><tr><td scope="row"><pre>    OCCOPY="$2"<span></span></pre></td></tr><tr><td scope="row"><pre>    FIRST=$3<span></span></pre></td></tr><tr><td scope="row"><pre>    LAST=$4<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    # echo "FIRST: $FIRST, LAST: $LAST"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if [ $FIRST -ne $(($LAST - 1)) ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>        SPLITWIDTH=$((($LAST - $FIRST) / 2))<span></span></pre></td></tr><tr><td scope="row"><pre>        split_str "$OCCOPY" $SPLITWIDTH<span></span></pre></td></tr><tr><td scope="row"><pre>        if [ $(echo "$LEFT" | grep -c "$CH") -eq 1 ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>                # echo "left"<span></span></pre></td></tr><tr><td scope="row"><pre>                ord3_sub "$CH" "$LEFT" $FIRST $(( $FIRST + $SPLITWIDTH ))<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>                # echo "right"<span></span></pre></td></tr><tr><td scope="row"><pre>                ord3_sub "$CH" "$RIGHT" $(( $FIRST + $SPLITWIDTH )) $LAST<span></span></pre></td></tr><tr><td scope="row"><pre>        fi<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        echo $(( $FIRST + 1 ))<span></span></pre></td></tr><tr><td scope="row"><pre>    fi<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As expected, this performs significantly better, decreasing execution time by about ten percent in this case. The improved performance, however, is almost precisely offset by the extra initialization costs to enable you to split the list. That is why you should never assume that a theoretically optimal algorithm will perform better than a theoretically less optimal algorithm. In shell scripting, the performance impact of constant cost differences can and often do easily outweigh improvements in algorithmic complexity.</p><p>Of course, using a Perl or AWK script to find the ordinal rank is much faster than any of these methods. The purpose of this example is to demonstrate methods for improving efficiency of similar operations, not to show the best way to find the ordinal rank of a character.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW3" title="Reducing Use of the eval Builtin"></a><h3>Reducing Use of the eval Builtin</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-DontLinkElementID_437"></a>The <code><a href="../../../../Darwin/Reference/ManPages/man1/eval.1.html#//apple_ref/doc/man/1/eval" target="_top">eval</a></code> builtin is a very powerful tool. However, it adds considerable overhead when you use it.</p><p>If you are executing the <code>eval</code> builtin repeatedly in a loop and do not need to use the results for intermediate calculations, it is significantly faster to store each expression as a series of semicolon-separated commands, then execute them all in a single pass at the end.</p><p>For example, the following code shifts the entries in a pseudo-array by one row:</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function test1()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        X=1; XA=0<span></span></pre></td></tr><tr><td scope="row"><pre>        while [ $X -lt 5 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>                Y=1;<span></span></pre></td></tr><tr><td scope="row"><pre>                while [ $Y -lt 5 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>                        eval "FOO_$X""_$Y=FOO_$XA""_$Y"<span></span></pre></td></tr><tr><td scope="row"><pre>                        Y=`expr $Y + 1`<span></span></pre></td></tr><tr><td scope="row"><pre>                done<span></span></pre></td></tr><tr><td scope="row"><pre>                X=`expr $X + 1`<span></span></pre></td></tr><tr><td scope="row"><pre>                XA=`expr $XA + 1`<span></span></pre></td></tr><tr><td scope="row"><pre>        done<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>You can speed up this function by about 20% by concatenating the assignment statements into a single string and running <code>eval</code> only once, as show in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function test3()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        X=1; XA=0<span></span></pre></td></tr><tr><td scope="row"><pre>        LIST=""<span></span></pre></td></tr><tr><td scope="row"><pre>        while [ $X -lt 5 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>                Y=1;<span></span></pre></td></tr><tr><td scope="row"><pre>                while [ $Y -lt 5 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>                        LIST="$LIST$SEMI""FOO_$X""_$Y=\$FOO_$XA""_$Y"<span></span></pre></td></tr><tr><td scope="row"><pre>                        SEMI=";"<span></span></pre></td></tr><tr><td scope="row"><pre>                        Y=`expr $Y + 1`<span></span></pre></td></tr><tr><td scope="row"><pre>                done<span></span></pre></td></tr><tr><td scope="row"><pre>                X=`expr $X + 1`<span></span></pre></td></tr><tr><td scope="row"><pre>                XA=`expr $XA + 1`<span></span></pre></td></tr><tr><td scope="row"><pre>        done<span></span></pre></td></tr><tr><td scope="row"><pre>        # echo $LIST<span></span></pre></td></tr><tr><td scope="row"><pre>        eval $LIST<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>An even more dramatic performance improvement comes when you can precache these commands into a variable. If you need to repeatedly execute a fairly well-defined series of statements in this way (but don’t want to waste hundreds of lines of space in your code), you can create the list of commands once, then use it repeatedly.</p><p>By caching the list of commands, the second and subsequent executions improve by about a factor of 200, which puts its performance at or near the speed of a function call with all of the assignment statements written out.</p><p>Another useful technique is to precache a dummy version of the commands, with placeholder text instead of certain values. For example, in the above code you could cache a series of statements in the form <code>ROW_X_COL_1=ROW_Y_COL_1;</code>, repeating for each column value. Then, when you needed to copy one row to another, you could do this:</p><div class="codesample"><table><tr><td scope="row"><pre>eval `echo $ROWCOPY | sed "s/X/$DEST_ROW/g" | sed "s/Y/$SRC_ROW/g"`<span></span></pre></td></tr></table></div><p>If you don’t have separate variables for source and destination rows, you might write something like the following:</p><div class="codesample"><table><tr><td scope="row"><pre>eval `echo $ROWCOPY | sed "s/X/$ROW/g" | sed "s/Y/$(expr $ROW + 1)/g"`<span></span></pre></td></tr></table></div><p>By writing the code in this way, you have replaced several lines of iterator code and dozens of <code>eval</code> instructions with a single <code>eval</code> instruction and two executions of <code>sed</code>. The resulting performance improvement is dramatic.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW7" title="Other Performance Tips"></a><h2>Other Performance Tips</h2><p>Here are a few more performance tuning tips.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW8" title="Background or Defer Output"></a><h3>Background or Defer Output</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-DontLinkElementID_438"></a>Output to files takes time, output to the console doubly so. If you are writing code where performance is a consideration, you should either execute output commands in the background by adding an ampersand (<code>&amp;</code>) to the end of the command or group multiple output statements together.</p><p>For example, if you are drawing a game board, the fastest way is to store your draw commands in a single variable and output the data at once. In this way, you avoid taking multiple execution penalties. A very fast way to do this is to disable buffering and set newline to shift down a line without returning to the left edge (run <code>stty raw</code> to set both of these parameters), then store the first row into a variable, followed by a newline, followed by backspace characters to shift left to the start of the next row, followed by the next row, and so on.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW9" title="Defer Potentially Unnecessary Work"></a><h3>Defer Potentially Unnecessary Work</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-DontLinkElementID_439"></a>If the results of a series of instructions may never be used, do not perform those instructions.</p><p>For example, consider code that uses the <code>eval</code> builtin to obtain the values from a series of variables in a pseudo-array. Suppose that the code returns immediately if any of the variables has a value of 2 or more.</p><p>Unless you are accumulating multiple assignment statements into a single call to <code>eval</code> (as described in <span class="content_text"><a href="performance.html#//apple_ref/doc/uid/TP40004268-TP40003520-SW3">“Reducing Use of the eval Builtin”</a></span>), you should call <code>eval</code> on the first statement by itself, make the comparison, run <code>eval</code> for the next statement, and so on. By doing so, you are reducing the average number of calls to <code>eval</code>.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW10" title="Perform Comparisons Only Once"></a><h3>Perform Comparisons Only Once</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-DontLinkElementID_440"></a>If you have a function that performs an expensive test two or more times, cache the results of that test and perform the most lightweight comparison possible from then on.</p><p>Also, if you have two possible execution paths through your code that share some code in common, it may be faster to use only a single <code>if</code> statement and duplicate the small amount of common code rather than repeatedly performing the same comparison. In general, however, such changes will only result in a single-digit percentage improvement in performance, so it is usually not worth the decrease in maintainability to duplicate code in this way.</p><p>The performance impact varies depending on the expense of the test. Tests that perform computations or outside execution are particularly expensive and thus should be minimized as much as possible. Of course, you can reduce the additional impact by performing the calculation once and doing a lightweight test multiple times.</p><p>A simple test case produced the results shown in <span class="content_text">Table 8-1</span>.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW4" title="Table 8-1Performance (in seconds) impact of duplicating common code to avoid redundant tests"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8-1&nbsp;&nbsp;</strong>Performance (in seconds) impact of duplicating common code to avoid redundant tests</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Test performed twice with one copy of shared code in-between</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Test performed once with two copies of shared code</p></th></tr><tr><td  scope="row"><p>7.003</p></td><td ><p>6.957</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW11" title="Choose Control Statements Carefully"></a><h3>Choose Control Statements Carefully</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-DontLinkElementID_441"></a>In most situations, the appropriate control statement is obvious. To test to see whether a variable contains one of two or three values, you generally choose an <code>if</code> statement with a small number of <code>elif</code> statements. For larger number of values, you generally choose a <code>case</code> statement. This not only leads to more readable code, but also results in <em>faster</em> code.</p><p>For small numbers of cases (5), as expected, the difference between a series of <code>if</code> statements, an <code>if</code> statement with a series of <code>elif</code> statements, and a <code>case</code> statement is largely lost in the noise, performance-wise, even after 1000 iterations. Although the results shown in <span class="content_text">Table 8-2</span> are in the expected order, this was only true approximately half the time. For a smaller number of cases, the differences can largely be ignored.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW5" title="Table 8-2Performance (in seconds) comparisons of 1000 executions of various control statement sequences"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8-2&nbsp;&nbsp;</strong>Performance (in seconds) comparisons of 1000 executions of various control statement sequences</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>eval builtin executing multiple functions</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>series of if statements</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>if, then series of elif statements</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>case statement</p></th></tr><tr><td class="rowhead"  scope="row"><p>Five cases</p></td><td ><p>6.945</p></td><td ><p>6..846</p></td><td ><p>6.831</p></td><td ><p>6.807</p></td></tr><tr><td class="rowhead"  scope="row"><p>Ten cases</p></td><td ><p>7.094</p></td><td ><p>7.224</p></td><td ><p>6.980</p></td><td ><p>6.903</p></td></tr><tr><td class="rowhead"  scope="row"><p>Fifty cases</p></td><td ><p>7.023</p></td><td ><p>8.03</p></td><td ><p>7.392</p></td><td ><p>6.704</p></td></tr></table></div><p>With a larger number of cases, the results more predictably resemble what one might expect. The <code>case</code> version is fastest, followed by the <code>elif</code> version, followed by the <code>if</code> version, with the <code>eval</code> version still coming in last. These results tended to be more consistent, though <code>eval</code> was often faster than the series of <code>if</code> statements.</p><p>Although the performance differences (shown in <span class="content_text">Table 8-2</span>) are relatively small, in a sufficiently complex script with a large number of cases, they can make a sizable difference. In particular, the <code>case</code> statement tends to degrade more gracefully, whereas the series of <code>if</code> statements by themselves tends to cause an ever-increasing performance penalty.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW12" title="Perform Computations Only Once"></a><h3>Perform Computations Only Once</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-DontLinkElementID_442"></a>For example, if you have a function that includes <code>expr $ROW + 1</code> in two or more lines of code, you should define a local variable <code>ROW_PLUS_1</code> and store the value of the expression in that variable. Caching the results of computation is particularly important if you are using <code>expr</code> for more portable math, but doing so consistently results in a small performance improvement even when using shell math.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW13" title="Table 8-3Performance (in seconds) of 1000 iterations, performing each computation once or twice"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8-3&nbsp;&nbsp;</strong>Performance (in seconds) of 1000 iterations, performing each computation once or twice</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Twice with expr</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Once with expr</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Twice with shell math</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Once with shell math</p></th></tr><tr><td  scope="row"><p>23.744</p></td><td ><p>12.820</p></td><td ><p>6.596</p></td><td ><p>6.486</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW14" title="Use Shell Builtins Wherever Possible"></a><h3>Use Shell Builtins Wherever Possible</h3><p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-DontLinkElementID_443"></a>Using <code>echo</code> by itself is typically about 30 times faster than explicitly executing <code>/bin/echo</code>. This improved performance also applies to other builtins such as <code><a href="../../../../Darwin/Reference/ManPages/man1/umask.1.html#//apple_ref/doc/man/1/umask" target="_top">umask</a></code> or <code><a href="../../../../Darwin/Reference/ManPages/man1/test.1.html#//apple_ref/doc/man/1/test" target="_top">test</a></code>.</p><p>Of course, <code>test</code> is particularly important because it doubles as the bracket (<code><a href="../../../../Darwin/Reference/ManPages/man1/[.1.html#//apple_ref/doc/man/1/[" target="_top">[</a></code>) command, which is essential for most control statements in the shell. If you explicitly write a control statement using <code>/bin/[</code>, the script’s performance degrades immensely, Fortunately, it is unlikely that anyone would ever do that accidentally.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW15" title="Table 8-4Relative performance (in seconds) of 1000 iterations of the echo builtin and the echo command"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8-4&nbsp;&nbsp;</strong>Relative performance (in seconds) of 1000 iterations of the <code>echo</code> builtin and the <code>echo</code> command</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>echo (builtin)</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>/bin/echo</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>printf (builtin)</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>/usr/bin/printf</p></th></tr><tr><td  scope="row"><p>0.285</p></td><td ><p>6.212</p></td><td ><p>0.230</p></td><td ><p>6.359</p></td></tr></table></div><p>On a related note, the <code>printf</code> builtin is significantly faster than the <code>echo</code> builtin if your shell provides it (most do). Thus, for maximum performance, you should use <code>printf</code> instead of <code>echo</code>.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW16" title="For Maximum Performance, Use Shell Math, Not External Tools"></a><h3>For Maximum Performance, Use Shell Math, Not External Tools</h3><p>Although significantly less portable, code that uses the ZSH- and BASH-specific <code>$(( $VAR + 1))</code> math notation executes up to 125 times faster than identical code written with the <code>expr</code> command and up to 225 times faster than identical code written with the <code>bc</code> command.</p><p>Use <code>expr</code> in preference to <code>bc</code> for any integer math that exceeds the capabilities of the shell’s math capabilities. The floating-point math used by <code>bc</code> tends to be significantly slower.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW17" title="Table 8-5Relative performance (in seconds) of 1000 iterations of shell math, expr, and bc"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8-5&nbsp;&nbsp;</strong>Relative performance (in seconds) of 1000 iterations of shell math, <code>expr</code>, and <code>bc</code></caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>shell math</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>expr command</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>bc command</p></th></tr><tr><td  scope="row"><p>0.111</p></td><td ><p>14.106</p></td><td ><p>25.008</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW18" title="Combine Multiple Expressions with sed"></a><h3>Combine Multiple Expressions with sed</h3><p>The <code>sed</code> tool, like any other external tool, is expensive to start up. If you are processing a large chunk of data, this penalty is lost in the noise, but if you are processing a short quantity of data, it can be a sizable percentage of script execution time. Thus, if you can process multiple regular expressions in a single instance of <code>sed</code>, it is much faster than processing each expression separately.</p><p>Consider, for example, the following code, which changes “This is a test” into “This is burnt toast” and then throws away the results by redirecting them to  <code>/dev/null</code>.</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function1()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    LOOP=0<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ $LOOP -lt 1000 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "This is a test." | sed 's/a/burnt/g' | sed 's/e/oa/g' > /dev/null<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        LOOP=$((LOOP + 1))<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>You can speed this up dramatically by rewriting the processing line to look like this:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "This is a test." | sed -e 's/a/burnt/g' -e 's/e/oa/g' > /dev/null<span></span></pre></td></tr></table></div><p>By passing multiple expressions to <code>sed</code>, it processes them in a single execution. In this case, the processing of the second expression can be reduced by more than 60% on a typical computer.</p><p>As explained in <span class="content_text"><a href="performance.html#//apple_ref/doc/uid/TP40004268-TP40003520-SW1">“Avoiding Unnecessary External Commands,”</a></span> you can improve performance further by concatenating these strings into a single string and processing the output of all 1000 lines in a single invocation of <code>sed</code> (with two expressions). This change reduces the total execution time by nearly a factor of 20 compared with the original version.</p><p>For small inputs, the execution penalty is relatively large, so combining expressions results in a significant improvement. For large inputs, the execution penalty is relatively small, so combining expressions generally results in negligible improvement. However, even with large inputs, if the <code>sed</code> statements are executed in a loop, the cumulative performance difference could be noticeable.</p><a name="//apple_ref/doc/uid/TP40004268-TP40003520-SW19" title="Table 8-6Relative performance (in seconds) of different use cases for sed"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8-6&nbsp;&nbsp;</strong>Relative performance (in seconds) of different use cases for <code>sed</code></caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Two calls per line (2000 calls total)</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>One call per line (1000 calls total)</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Two calls on accumulated text</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>One call on accumulated text</p></th></tr><tr><td class="rowhead"  scope="row"><p>Single-processor system</p></td><td ><p>16.874</p></td><td ><p>9.983</p></td><td ><p>0.670</p></td><td ><p>0.665</p></td></tr><tr><td class="rowhead"  scope="row"><p>Dual-processor system</p></td><td ><p>11.460</p></td><td ><p>8.143</p></td><td ><p>0.619</p></td><td ><p>0.612</p></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AdvancedTechniques/AdvancedTechniques.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ForMoreInformation/ForMoreInformation.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-04-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/OpenSource/Conceptual/ShellScripting/performance/performance.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/OpenSource/Conceptual/ShellScripting/performance/performance.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/OpenSource/Conceptual/ShellScripting/performance/performance.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>