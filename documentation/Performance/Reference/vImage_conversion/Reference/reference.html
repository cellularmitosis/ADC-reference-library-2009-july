<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>vImage Conversion Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="vImage Conversion Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005488-DontLinkChapterID_1" title="vImage Conversion Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> &gt; <a href="../../../../../reference/Performance/index.html#//apple_ref/doc/uid/TP30001281-TP30000430" target="_top">Performance</a> &gt; <a href="../../../../../reference/Performance/idxGraphicsImaging-date.html#//apple_ref/doc/uid/TP30001281-TP30000430-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../index.html" target="_top">vImage Conversion Reference</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005488-DontLinkChapterID_1-DontLinkElementID_44" title="vImage Conversion Reference"></a><h1>vImage Conversion Reference</h1><div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr><td scope="row"><strong><span style="white-space: nowrap;">Framework</span></strong></td><td><div style="margin-bottom:1px"><a href="../../vDSP_Reference_Collection/index.html#//apple_ref/doc/uid/TP40006226" target="_top">Accelerate</a>/vImage</div></td></tr><tr><td scope="row"><strong><span class="noWrap">Companion guide</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text"><a href="../../../Conceptual/vImage/index.html#//apple_ref/doc/uid/TP30001001" target="_top">vImage Programming Guide</a></span><br/></div></td></tr><tr><td scope="row"><strong><span style="white-space: nowrap;">Declared in</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text">Conversion.h</span><br/></div></td></tr></table></div><br/><a name="//apple_ref/doc/uid/TP40005488-CH1-DontLinkElementID_42" title="Overview"></a><h2>Overview</h2><p>Conversion functions change an image from one image format into another. These functions work with the formats supported by vImage (Planar8, PlanarF, ARGB8888,  ARGBFFFF, RGBA8888, and RGBAFFFF) but they can also change between a supported format to one that’s not supported by vImage (such as RGB565). Conversion functions can also fill buffers with a color, overwrite channels, permute channels, flatten data, and clip data.</p><p>Conversion functions use a vImage buffer structure (<code>vImage_Buffer</code>—see <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>) to receive and supply image data. This buffer contains a pointer to image data, the height and width (in pixels) of the image data, and the number of row bytes. You actually pass a pointer to a vImage buffer structure. For some functions, you can provide a pointer to the same vImage buffer structure for the source images and the destination image because the function “works in place”. That is , the source and destination images can occupy the same memory if the they are strictly aligned pixel for pixel.</p><a name="//apple_ref/doc/uid/TP40005488-DontLinkChapterID_1-DontLinkElementID_43" title="Functions by Task"></a><h2>Functions by Task</h2>
<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_1" title="Filling Buffers"></a>
    
    <h3 class="tasks">Filling Buffers</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageBufferFill_ARGB8888">vImageBufferFill_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Fills an ARGB8888 buffer with a specified color.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageBufferFill_ARGBFFFF">vImageBufferFill_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Fills an ARGBFFFF buffer with a specified color.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_3" title="Permuting Channels"></a>
    
    <h3 class="tasks">Permuting Channels</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImagePermuteChannels_ARGB8888">vImagePermuteChannels_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reorders the channels in an ARGB8888 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImagePermuteChannels_ARGBFFFF">vImagePermuteChannels_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reorders the channels in an ARGBFFFF image.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_6" title="Overwriting Channels"></a>
    
    <h3 class="tasks">Overwriting Channels</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageSelectChannels_ARGB8888">vImageSelectChannels_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites the specified channels in an ARGB8888 image buffer with the provided channels from an ARGB8888 image buffer.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageSelectChannels_ARGBFFFF">vImageSelectChannels_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites the specified channels in an ARGBFFFF image buffer with the provided channels in an ARGBFFFF image buffer.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannels_ARGB8888">vImageOverwriteChannels_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites one or more planes of an ARGB8888 image buffer with the provided planar buffer.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannels_ARGBFFFF">vImageOverwriteChannels_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites one or more planes of an ARGBFFFF image buffer with the provided planar buffer.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannelsWithScalar_ARGB8888">vImageOverwriteChannelsWithScalar_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites the pixels of one or more planes of an ARGB8888 image buffer with the provided scalar value.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannelsWithScalar_ARGBFFFF">vImageOverwriteChannelsWithScalar_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites the pixels of one or more planes of an ARGBFFFF image buffer with the provided scalar value.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannelsWithScalar_Planar8">vImageOverwriteChannelsWithScalar_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites a Planar8 image buffer with the provided value.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannelsWithScalar_PlanarF">vImageOverwriteChannelsWithScalar_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites a PlanarF image buffer with the provided value.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannelsWithPixel_ARGB8888">vImageOverwriteChannelsWithPixel_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites an ARGB8888 image buffer with the provided pixel value.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannelsWithPixel_ARGBFFFF">vImageOverwriteChannelsWithPixel_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Overwrites an ARGBFFFF image buffer with the provided pixel value.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_12" title="Converting From 16 Bit"></a>
    
    <h3 class="tasks">Converting From 16 Bit</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_16SToF">vImageConvert_16SToF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an image in a special planar format—in which each pixel value is a 16-bit signed integer— to a PlanarF format.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_16UToF">vImageConvert_16UToF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an image in a special planar format—in which each pixel value is a 16-bit unsigned integer— to a PlanarF format. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_16UToPlanar8">vImageConvert_16UToPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an image in a special planar format—in which each pixel value is a 16-bit unsigned integer—to a Planar8 image. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_13" title="Transforming Using Table Lookups"></a>
    
    <h3 class="tasks">Transforming Using Table Lookups</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageTableLookUp_ARGB8888">vImageTableLookUp_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Transforms an ARGB8888 image by substituting pixel values with pixel values provided by four lookup tables.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageTableLookUp_Planar8">vImageTableLookUp_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Transforms an Planar8 image by substituting pixel values with pixel values provided by four lookup tables.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_14" title="Flattening Data"></a>
    
    <h3 class="tasks">Flattening Data</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageFlatten_ARGB8888ToRGB888">vImageFlatten_ARGB8888ToRGB888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Transforms an ARGB8888 image to an RGB888 image against an opaque background of the provided color.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageFlatten_ARGBFFFFToRGBFFF">vImageFlatten_ARGBFFFFToRGBFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Transforms an ARGBFFFF image to an RGBFFF image against an opaque background of the provided color.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_17" title="Clipping Data"></a>
    
    <h3 class="tasks">Clipping Data</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageClip_PlanarF">vImageClip_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Clips the pixel values of an image in PlanarF format, using the provided minimum and maximum values.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_19" title="Converting Between Chunky and Planar"></a>
    
    <h3 class="tasks">Converting Between Chunky and Planar</h3>
    <p>These convenience functions allow  you to convert between various interleaved (or <em>chunky</em>) formats that vImage does not explicitly support (and that may have less than or more than four channels) and the formats that vImage supports explicitly. You can represent some non-interleaved formats as well. The functions are not fast or vectorized. </p>    
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_PlanarToChunky8">vImageConvert_PlanarToChunky8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Combines a collection of planar source images into a single interleaved destination image, with one 8-bit channel for each planar image. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_PlanarToChunkyF">vImageConvert_PlanarToChunkyF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Combines a collection of planar source images into a single interleaved destination image, with one floating-point channel for each planar image. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ChunkyToPlanar8">vImageConvert_ChunkyToPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Separates a source image into a collection of corresponding planar destination images, one for each 8-bit channel of the original image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ChunkyToPlanarF">vImageConvert_ChunkyToPlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Separates a source image into a collection of corresponding planar destination images, one for each floating-point channel of the original image. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_20" title="Converting From Planar Formats"></a>
    
    <h3 class="tasks">Converting From Planar Formats</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_Planar8To16U">vImageConvert_Planar8To16U</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts a Planar8 image to a 16U image . '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_Planar8toARGB1555">vImageConvert_Planar8toARGB1555</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Combines four Planar8 images into one ARGB1555 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_Planar8toARGB8888">vImageConvert_Planar8toARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Combines four Planar8 images into one ARGB8888 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_Planar8toPlanarF">vImageConvert_Planar8toPlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts a Planar8 image to a PlanarF image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_Planar8toRGB565">vImageConvert_Planar8toRGB565</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Combines three Planar8 images  into one RGB565 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_Planar8toRGB888">vImageConvert_Planar8toRGB888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Combines three Planar8 images  into one RGB888 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_PlanarFtoRGBFFF">vImageConvert_PlanarFtoRGBFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Combines three PlanarF images into one RGBFFF image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_PlanarFtoARGBFFFF">vImageConvert_PlanarFtoARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Combines four PlanarF images into one ARGBFFFF image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_PlanarFtoPlanar16F">vImageConvert_PlanarFtoPlanar16F</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts a PlanarF image to a Planar16F image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8">vImageConvert_PlanarFtoPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts a PlanarF image to a Planar8 image, clipping values to the provided minimum and maximum values.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_Planar16FtoPlanarF">vImageConvert_Planar16FtoPlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts a Planar16F image to a PlanarF image. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_FTo16S">vImageConvert_FTo16S</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts a PlanarF image into a special format in which each pixel is a 16-bit signed integer.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_FTo16U">vImageConvert_FTo16U</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts a PlanarF image into a special format in which each pixel is a 16-bit unsigned integer.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_30" title="Converting From ARGB Formats"></a>
    
    <h3 class="tasks">Converting From ARGB Formats</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ARGB1555toARGB8888">vImageConvert_ARGB1555toARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an ARGB1555 image to an ARGB8888 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ARGB1555toPlanar8">vImageConvert_ARGB1555toPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Separates an ARGB1555 image into four Planar8 images.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ARGB8888toARGB1555">vImageConvert_ARGB8888toARGB1555</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an ARGB8888 image into an ARGB1555 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ARGB8888toPlanar8">vImageConvert_ARGB8888toPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Separates an ARGB8888 image into four Planar8 images.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ARGB8888toRGB565">vImageConvert_ARGB8888toRGB565</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an ARGB8888 image into an RGB565 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ARGB8888toRGB888">vImageConvert_ARGB8888toRGB888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an ARGB8888 image into an RGB888 image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_ARGBFFFFtoPlanarF">vImageConvert_ARGBFFFFtoPlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Separates an ARGBFFFF image into four PlanarF images.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_36" title="Converting From RGB Formats"></a>
    
    <h3 class="tasks">Converting From RGB Formats</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_RGB565toPlanar8">vImageConvert_RGB565toPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Separates an RGB565 image into three Planar8 images.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_RGB565toARGB8888">vImageConvert_RGB565toARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an RGB565 image into an ARGB8888 image, using the provided 8-bit alpha value. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_RGB888toARGB8888">vImageConvert_RGB888toARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Converts an RGB888 image into an ARGB8888 image, using the provided alpha value (either as planar or pixel data).'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_RGB888toPlanar8">vImageConvert_RGB888toPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Separates an RGB888 image into three Planar8 images.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvert_RGBFFFtoPlanarF">vImageConvert_RGBFFFtoPlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Separates an RGBFFF image into three PlanarF images.'/>
            </span></li>
    </ul>

<a name="//apple_ref/doc/uid/TP40005488-CH210-222475" title="Functions"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-BBCCEIDH" title="Functions"></a><h2><a name="//apple_ref/doc/uid/TP40005488-CH210-TPXREF102" title="Functions"></a>Functions</h2>                                               <a name="//apple_ref/c/func/vImageBufferFill_ARGB8888" title="vImageBufferFill_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageBufferFill_ARGB8888" title="vImageBufferFill_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageClip_PlanarF" title="vImageBufferFill_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_46"></a><h3 class="tight">vImageBufferFill_ARGB8888</h3> <p class="spaceabove">Fills an ARGB8888 buffer with a specified color.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageBufferFill_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> color,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data created with the fill  color. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>color</em></dt> <dd><p>The color to fill the buffer with.</p></dd> <dt><em>flags</em></dt> <dd><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannelsWithScalar_Planar8" target="_self">vImageOverwriteChannelsWithScalar_Planar8</a></code></li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageBufferFill_ARGBFFFF" title="vImageBufferFill_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageBufferFill_ARGBFFFF" title="vImageBufferFill_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_2" title="vImageBufferFill_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_47"></a><h3 class="tight">vImageBufferFill_ARGBFFFF</h3> <p class="spaceabove">Fills an ARGBFFFF buffer with a specified color.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageBufferFill_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> color,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data created with the fill  color. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>color</em></dt> <dd><p>The color to fill the buffer with.</p></dd> <dt><em>flags</em></dt> <dd><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannelsWithScalar_PlanarF" target="_self">vImageOverwriteChannelsWithScalar_PlanarF</a></code></li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageClip_PlanarF" title="vImageClip_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageClip_PlanarF" title="vImageClip_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_18" title="vImageClip_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_48"></a><h3 class="tight">vImageClip_PlanarF</h3> <p class="spaceabove">Clips the pixel values of an image in PlanarF format, using the provided minimum and maximum values.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageClip_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> maxFloat,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> minFloat,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to clip.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>maxFloat</em></dt> <dd><p>A maximum pixel value. The function clips larger values to this value in the destination image.</p></dd> <dt><em>minFloat</em></dt> <dd><p>A maximum pixel value. The function clips smaller values to this value in the destination image.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_16SToF" title="vImageConvert_16SToF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_16SToF" title="vImageConvert_16SToF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_16SToF" title="vImageConvert_16SToF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_49"></a><h3 class="tight">vImageConvert_16SToF</h3> <p class="spaceabove">Converts an image in a special planar format—in which each pixel value is a 16-bit signed integer— to a PlanarF format.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_16SToF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   float offset,
   float scale,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image (for which each pixel value is a 16-bit signed integer) whose data you want to overwrite.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains  the destination image data in  PlanarF format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>offset</em></dt> <dd><p>The offset value to add to each pixel.</p></dd> <dt><em>scale</em></dt> <dd><p>The value to multiply each pixel by.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The function changes each pixel value to a floating-point value, scales each value and then adds the offset value.  The calculation is</p><div class="codesample"><table><tr><td scope="row"><pre>    resultPixel = (float) sourcePixel * scale + offset<span></span></pre></td></tr></table></div><p>The functions <code><a href="reference.html#//apple_ref/doc/c_ref/vImageConvert_16SToF">vImageConvert_16SToF</a></code> and <code><a href="reference.html#//apple_ref/doc/c_ref/vImageConvert_FTo16S">vImageConvert_FTo16S</a></code> are  inverse transformations when you use the same offset and scale values for each. (The inversion is not precise due to round-off error.) This requires the two functions to use these values differently (and in a different order).</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_16UToF" title="vImageConvert_16UToF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_16UToF" title="vImageConvert_16UToF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_16UToF" title="vImageConvert_16UToF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_50"></a><h3 class="tight">vImageConvert_16UToF</h3> <p class="spaceabove">Converts an image in a special planar format—in which each pixel value is a 16-bit unsigned integer— to a PlanarF format. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_16UToF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   float offset,
   float scale,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image (for which each pixel value is a 16-bit unsigned integer) whose data you want to overwrite.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains  the destination image data in  PlanarF format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>offset</em></dt> <dd><p>The offset value to add to each pixel.</p></dd> <dt><em>scale</em></dt> <dd><p>The value to multiply each pixel by.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>Each pixel value is changed to a floating-point value, then scaled and offset by the provided values. The calculation is</p><div class="codesample"><table><tr><td scope="row"><pre>    resultPixel =   SATURATED_CLIP_SHRT_MIN_to_SHRT_MAX( (sourcePixel<span></span></pre></td></tr><tr><td scope="row"><pre>                    - offset) / scale  + 0.5f)<span></span></pre></td></tr></table></div><p>The functions <code><a href="reference.html#//apple_ref/doc/c_ref/vImageConvert_16SToF">vImageConvert_16SToF</a></code> and <code><a href="reference.html#//apple_ref/doc/c_ref/vImageConvert_FTo16S">vImageConvert_FTo16S</a></code> are  inverse transformations when you use the same offset and scale values for each. (The inversion is not precise due to round-off error.) This requires the two functions to use these values differently (and in a different order).</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_16UToPlanar8" title="vImageConvert_16UToPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageConvert_16UToPlanar8" title="vImageConvert_16UToPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_ARGBFFFFtoPlanarF" title="vImageConvert_16UToPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_51"></a><h3 class="tight">vImageConvert_16UToPlanar8</h3> <p class="spaceabove">Converts an image in a special planar format—in which each pixel value is a 16-bit unsigned integer—to a Planar8 image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_16UToPlanar8 (
const <!--a-->vImage_Buffer<!--/a--> *src,
const <!--a-->vImage_Buffer<!--/a--> *dest,
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The conversion from 16-bit to 8-bit values is:</p> <div class="codesample"><table><tr><td scope="row"><pre>    uint8_t result = (srcPixel * 255 + 32767) / 65535<span></span></pre></td></tr></table></div> <p>You can also use this function to convert a 4-channel interleaved 16U image to an ARGB8888. image. Simply multiply the width of the destination buffer by four.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ARGB1555toARGB8888" title="vImageConvert_ARGB1555toARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ARGB1555toARGB8888" title="vImageConvert_ARGB1555toARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_31" title="vImageConvert_ARGB1555toARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_52"></a><h3 class="tight">vImageConvert_ARGB1555toARGB8888</h3> <p class="spaceabove">Converts an ARGB1555 image to an ARGB8888 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ARGB1555toARGB8888 (
const <!--a-->vImage_Buffer<!--/a--> *src,
const <!--a-->vImage_Buffer<!--/a--> *dest,
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains the converted data. When you no longer need the data buffer, you must deallocate the memory. </p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The ARGB1555 format has 16-bit pixels with 1 bit for alpha and 5 bits each for red, green, and blue. The function calculates the 8-bit pixels in the destination image as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    Pixel8 alpha =  1bitAlphaChannel * 255<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 green = (5bitGreenChannel * 255 + 15) / 31<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31<span></span></pre></td></tr></table></div><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ARGB1555toPlanar8" title="vImageConvert_ARGB1555toPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ARGB1555toPlanar8" title="vImageConvert_ARGB1555toPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_ARGB8888toPlanar8" title="vImageConvert_ARGB1555toPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_53"></a><h3 class="tight">vImageConvert_ARGB1555toPlanar8</h3> <p class="spaceabove">Separates an ARGB1555 image into four Planar8 images.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ARGB1555toPlanar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *destA,
   const <!--a-->vImage_Buffer<!--/a--> *destR,
   const <!--a-->vImage_Buffer<!--/a--> *destG,
   const <!--a-->vImage_Buffer<!--/a--> *destB,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to separate.</p></dd> <dt><em>destA</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the alpha channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destR</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the red channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destG</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the green channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destB</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the blue channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The ARGB1555 format has 16-bit pixels with 1 bit for alpha and 5 bits each for red, green, and blue. The function calculates the 8-bit pixels in the destination image as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    Pixel8 alpha =  1bitAlphaChannel * 255<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 green = (5bitGreenChannel * 255 + 15) / 31<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31<span></span></pre></td></tr></table></div> <p>This function works in place for one destination buffer; the others must be allocated separately.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ARGB8888toARGB1555" title="vImageConvert_ARGB8888toARGB1555"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ARGB8888toARGB1555" title="vImageConvert_ARGB8888toARGB1555"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_Planar8toARGB8888" title="vImageConvert_ARGB8888toARGB1555"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_54"></a><h3 class="tight">vImageConvert_ARGB8888toARGB1555</h3> <p class="spaceabove">Converts an ARGB8888 image into an ARGB1555 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ARGB8888toARGB1555 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains the converted image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The ARGB1555 format has 16-bit pixels with 1 bit for alpha and 5 bits each for red, green, and blue. The function calculates the 16-bit pixels in the destination image as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    uint32_t alpha = (8bitAlphaChannel      + 127) / 255<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t red   = (8bitRedChannel   * 31 + 127) / 255<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t green = (8bitGreenChannel * 31 + 127) / 255<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t blue  = (8bitBlueChannel  * 31 + 127) / 255<span></span></pre></td></tr><tr><td scope="row"><pre>    uint16_t ARGB1555pixel = (alpha &lt;&lt; 15) | (red &lt;&lt;  10) | (green &lt;&lt; 5) | blue<span></span></pre></td></tr></table></div><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ARGB8888toPlanar8" title="vImageConvert_ARGB8888toPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ARGB8888toPlanar8" title="vImageConvert_ARGB8888toPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_32" title="vImageConvert_ARGB8888toPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_55"></a><h3 class="tight">vImageConvert_ARGB8888toPlanar8</h3> <p class="spaceabove">Separates an ARGB8888 image into four Planar8 images.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ARGB8888toPlanar8 (
   const <!--a-->vImage_Buffer<!--/a--> *srcARGB,
   const <!--a-->vImage_Buffer<!--/a--> *destA,
   const <!--a-->vImage_Buffer<!--/a--> *destR,
   const <!--a-->vImage_Buffer<!--/a--> *destG,
   const <!--a-->vImage_Buffer<!--/a--> *destB,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcARGB</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to separate.</p></dd> <dt><em>destA</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the alpha channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destR</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the red channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destG</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the green channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destB</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the blue channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The source image, and the <em>destA</em>, <em>destR</em>, <em>destG</em>, and <em>destB</em> destination buffers, must have the same height and the same width. This function works in place for one destination buffer. The others must be allocated separately.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ARGB8888toRGB565" title="vImageConvert_ARGB8888toRGB565"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ARGB8888toRGB565" title="vImageConvert_ARGB8888toRGB565"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_33" title="vImageConvert_ARGB8888toRGB565"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_56"></a><h3 class="tight">vImageConvert_ARGB8888toRGB565</h3> <p class="spaceabove">Converts an ARGB8888 image into an RGB565 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ARGB8888toRGB565 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size. The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains the data in RGB565 format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The alpha channel in the ARGB8888 image is ignored. (The RGB565 format has 16-bit pixels with 5 bits for red, 6 for green, and 5 for blue.) The function calculates the pixels in the destination image as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    uint32_t red   = (8bitRedChannel   * (31*2) + 255) / (255*2)<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t green = (8bitGreenChannel * 63 + 127) / 255<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t blue  = (8bitBlueChannel  * 31 + 127) / 255<span></span></pre></td></tr><tr><td scope="row"><pre>    uint16_t RGB565pixel =  (red &lt;&lt; 11) | (green &lt;&lt;  5) | blue<span></span></pre></td></tr></table></div><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ARGB8888toRGB888" title="vImageConvert_ARGB8888toRGB888"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ARGB8888toRGB888" title="vImageConvert_ARGB8888toRGB888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_34" title="vImageConvert_ARGB8888toRGB888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_57"></a><h3 class="tight">vImageConvert_ARGB8888toRGB888</h3> <p class="spaceabove">Converts an ARGB8888 image into an RGB888 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ARGB8888toRGB888 (
   const <!--a-->vImage_Buffer<!--/a--> *argbSrc,
   const <!--a-->vImage_Buffer<!--/a--> *rgbDest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>argbSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>rgbDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size. The destination data buffer can be the same as the <code>argbSrc</code> data buffer. On return, the data buffer pointed to by this structure contains the data in RGB888 format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The red, green, and blue channels are simply copied.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ARGBFFFFtoPlanarF" title="vImageConvert_ARGBFFFFtoPlanarF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ARGBFFFFtoPlanarF" title="vImageConvert_ARGBFFFFtoPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_35" title="vImageConvert_ARGBFFFFtoPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_58"></a><h3 class="tight">vImageConvert_ARGBFFFFtoPlanarF</h3> <p class="spaceabove">Separates an ARGBFFFF image into four PlanarF images.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ARGBFFFFtoPlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *srcARGB,
   const <!--a-->vImage_Buffer<!--/a--> *destA,
   const <!--a-->vImage_Buffer<!--/a--> *destR,
   const <!--a-->vImage_Buffer<!--/a--> *destG,
   const <!--a-->vImage_Buffer<!--/a--> *destB,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcARGB</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to separate.</p></dd> <dt><em>destA</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a PlanarF image equivalent to the alpha channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destR</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a PlanarF image equivalent to the red channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destG</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a PlanarF image equivalent to the green channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destB</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a PlanarF image equivalent to the blue channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The source image, and the <em>destA</em>, <em>destR</em>, <em>destG</em>, and <em>destB</em> destination buffers, must have the same height and the same width. This function works in place for one destination buffer. The others must be allocated separately.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ChunkyToPlanar8" title="vImageConvert_ChunkyToPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ChunkyToPlanar8" title="vImageConvert_ChunkyToPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_ChunkyToPlanar8" title="vImageConvert_ChunkyToPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_59"></a><h3 class="tight">vImageConvert_ChunkyToPlanar8</h3> <p class="spaceabove">Separates a source image into a collection of corresponding planar destination images, one for each 8-bit channel of the original image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ChunkyToPlanar8 (
   const void *srcChannels[],
   const <!--a-->vImage_Buffer<!--/a--> *destPlanarBuffers[],
   unsigned int channelCount,
   size_t srcStrideBytes,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcWidth,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcHeight,
   size_t srcRowBytes,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcChannels</em></dt> <dd><p>An array of pointers to channels of the source image. Each pointer points to the start of the data for one source channel.</p></dd> <dt><em>destPlanarBuffers</em></dt> <dd><p>An array of  vImage buffer structures, each of which contains image data in Planar8 format. Each structure must have the same width and height values, but may have  different row byte values. On return, the data buffer in each vImage buffer structure contains a planar image equivalent to the corresponding channel of the source image.</p></dd> <dt><em>channelCount</em></dt> <dd><p>The number of channels in the source image.</p></dd> <dt><em>srcStrideBytes</em></dt> <dd><p>The number of bytes from one pixel value in a given channel to the next pixel of that channel (within a row). This value must be the same for all channels.</p></dd> <dt><em>srcWidth</em></dt> <dd><p>The number of pixels in a row. This value must be the same for all channels in the source image, and for all the destination buffers.</p></dd> <dt><em>srcHeight</em></dt> <dd><p>The number of rows. This value must be the same for all channels in the source image, and for all the destination buffers.</p></dd> <dt><em>srcRowBytes</em></dt> <dd><p>The number of bytes from the beginning of a channel  row to the beginning of the next row of the channel. This value must be the same for all channels of the source image. (It does not have the be the same as the <em>rowBytes</em> values of the destination buffers. Each destination buffer can have its own <em>rowBytes</em> value.)</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_ChunkyToPlanarF" title="vImageConvert_ChunkyToPlanarF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_ChunkyToPlanarF" title="vImageConvert_ChunkyToPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_ChunkyToPlanarF" title="vImageConvert_ChunkyToPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_60"></a><h3 class="tight">vImageConvert_ChunkyToPlanarF</h3> <p class="spaceabove">Separates a source image into a collection of corresponding planar destination images, one for each floating-point channel of the original image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_ChunkyToPlanarF (
   const void *srcChannels[],
   const <!--a-->vImage_Buffer<!--/a--> *destPlanarBuffers[],
   unsigned int channelCount,
   size_t srcStrideBytes,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcWidth,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcHeight,
   size_t srcRowBytes,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcChannels</em></dt> <dd><p>An array of pointers to channels of the source image. Each pointer points to the start of the data for one source channel.</p></dd> <dt><em>destPlanarBuffers</em></dt> <dd><p>An array of  vImage buffer structures, each of which contains image data in PlanarF format. Each structure must have the same width and height values, but may have  different row byte values. On return, the data buffer in each each vImage buffer structure contains a planar image equivalent to the corresponding channel of the source image.</p></dd> <dt><em>channelCount</em></dt> <dd><p>The number of channels in the source image.</p></dd> <dt><em>srcStrideBytes</em></dt> <dd><p>The number of bytes from one pixel value in a given channel to the next pixel of that channel (within a row). This value must be the same for all channels.</p></dd> <dt><em>srcWidth</em></dt> <dd><p>The number of pixels in a row. This value must be the same for all channels in the source image, and for all the destination buffers.</p></dd> <dt><em>srcHeight</em></dt> <dd><p>The number of rows. This value must be the same for all channels in the source image, and for all the destination buffers.</p></dd> <dt><em>srcRowBytes</em></dt> <dd><p>The number of bytes from the beginning of a channel  row to the beginning of the next row of the channel. This value must be the same for all channels of the source image. (It does not have the be the same as the <em>rowBytes</em> values of the destination buffers. Each destination buffer can have its own <em>rowBytes</em> value.)</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_FTo16S" title="vImageConvert_FTo16S"></a><a name="//apple_ref/doc/c_ref/vImageConvert_FTo16S" title="vImageConvert_FTo16S"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_PlanarFtoARGBFFFF" title="vImageConvert_FTo16S"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_61"></a><h3 class="tight">vImageConvert_FTo16S</h3> <p class="spaceabove">Converts a PlanarF image into a special format in which each pixel is a 16-bit signed integer.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_FTo16S (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   float offset,
   float scale,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size. The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains the destination image converted to 16-bit signed integer format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>offset</em></dt> <dd><p>The offset value to subtract from every pixel.</p></dd> <dt><em>scale</em></dt> <dd><p>The scale value to divide each pixel by.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>Each pixel value is first offset and scaled by the provided values, and then changed to a 16-bit signed integer (rounded and clipped as necessary). The calculation is as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>    resultPixel =   SATURATED_CLIP_0_to_USHRT_MAX( (srcPixel - offset)<span></span></pre></td></tr><tr><td scope="row"><pre>                    / scale  + 0.5f)<span></span></pre></td></tr></table></div><p>The functions <code><a href="reference.html#//apple_ref/doc/c_ref/vImageConvert_16SToF">vImageConvert_16SToF</a></code> and <code><a href="reference.html#//apple_ref/doc/c_ref/vImageConvert_FTo16S">vImageConvert_FTo16S</a></code> are  inverse transformations when you use the same offset and scale values for each. (The inversion is not precise due to round-off error.) This requires the two functions to use these values differently (and in a different order).</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_FTo16U" title="vImageConvert_FTo16U"></a><a name="//apple_ref/doc/c_ref/vImageConvert_FTo16U" title="vImageConvert_FTo16U"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_FTo16U" title="vImageConvert_FTo16U"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_62"></a><h3 class="tight">vImageConvert_FTo16U</h3> <p class="spaceabove">Converts a PlanarF image into a special format in which each pixel is a 16-bit unsigned integer.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_FTo16U (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   float offset,
   float scale,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size. The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains the destination image converted to 16-bit unsigned integer format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>offset</em></dt> <dd><p>The offset value to subtract from every pixel.</p></dd> <dt><em>scale</em></dt> <dd><p>The scale value to divide each pixel by.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>Each pixel value is first offset and scaled by user-supplied values, and then changed to a 16-bit unsigned integer (rounded and clipped as necessary). The calculation is as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>    resultPixel =   SATURATED_CLIP_0_to_USHRT_MAX( (sourcePixel  - offset)<span></span></pre></td></tr><tr><td scope="row"><pre>                    / scale  + 0.5f)<span></span></pre></td></tr></table></div><p>The functions <code><a href="reference.html#//apple_ref/doc/c_ref/vImageConvert_16UToF">vImageConvert_16UToF</a></code> and <code><a href="reference.html#//apple_ref/doc/c_ref/vImageConvert_FTo16U">vImageConvert_FTo16U</a></code> are  inverse transformations when you use the same offset and scale values for each. (The inversion is not precise due to round-off error.) This requires the two functions to use these values differently (and in a different order).</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_Planar16FtoPlanarF" title="vImageConvert_Planar16FtoPlanarF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_Planar16FtoPlanarF" title="vImageConvert_Planar16FtoPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_Planar8toPlanarF" title="vImageConvert_Planar16FtoPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_63"></a><h3 class="tight">vImageConvert_Planar16FtoPlanarF</h3> <p class="spaceabove">Converts a Planar16F image to a PlanarF image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_Planar16FtoPlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size. On return, the data buffer pointed to by this structure contains the destination image converted to PlanarF format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The Planar16F format is identical to the OpenEXR format; it uses 16-bit floating-point numbers. In conformance with IEEE-754, the function quiets signaling NaNs during the conversion. (OpenEXR-1.2.1 does not do this.)</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_Planar8To16U" title="vImageConvert_Planar8To16U"></a><a name="//apple_ref/doc/c_ref/vImageConvert_Planar8To16U" title="vImageConvert_Planar8To16U"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_21" title="vImageConvert_Planar8To16U"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_64"></a><h3 class="tight">vImageConvert_Planar8To16U</h3> <p class="spaceabove">Converts a Planar8 image to a 16U image . </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_Planar8To16U (
const <!--a-->vImage_Buffer<!--/a--> *src,
const <!--a-->vImage_Buffer<!--/a--> *dest,
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The function converts from 8-bit to 16-bit values as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    uint16_t result = (srcPixel * 65535 + 127 ) / 255<span></span></pre></td></tr></table></div> <p>You can also use this function  to convert an ARGB8888 image to a 4-channel interleaved 16U image. Simply multiply the width of the destination buffer by four.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_Planar8toARGB1555" title="vImageConvert_Planar8toARGB1555"></a><a name="//apple_ref/doc/c_ref/vImageConvert_Planar8toARGB1555" title="vImageConvert_Planar8toARGB1555"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_22" title="vImageConvert_Planar8toARGB1555"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_65"></a><h3 class="tight">vImageConvert_Planar8toARGB1555</h3> <p class="spaceabove">Combines four Planar8 images into one ARGB1555 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_Planar8toARGB1555 (
   const <!--a-->vImage_Buffer<!--/a--> *srcA,
   const <!--a-->vImage_Buffer<!--/a--> *srcR,
   const <!--a-->vImage_Buffer<!--/a--> *srcG,
   const <!--a-->vImage_Buffer<!--/a--> *srcB,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcA</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the alpha channel of the destination image.</p></dd> <dt><em>srcR</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the red channel of the destination image.</p></dd> <dt><em>srcG</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the green channel of the destination image.</p></dd> <dt><em>srcB</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the blue channel of the destination image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains  the destination image data in ARGB1555 format (16-bit pixels with 1 bit for alpha and 5 bits each for red, green, and blue). When you no longer need the data buffer, you must deallocate the memory. The destination buffer can be the same as the source buffer.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>This function calculates the 8-bit pixels in the destination image as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    Pixel8 alpha =  1bitAlphaChannel * 255<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 green = (5bitGreenChannel * 255 + 15) / 31<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31<span></span></pre></td></tr></table></div><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_Planar8toARGB8888" title="vImageConvert_Planar8toARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageConvert_Planar8toARGB8888" title="vImageConvert_Planar8toARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_23" title="vImageConvert_Planar8toARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_66"></a><h3 class="tight">vImageConvert_Planar8toARGB8888</h3> <p class="spaceabove">Combines four Planar8 images into one ARGB8888 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_Planar8toARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *srcA,
   const <!--a-->vImage_Buffer<!--/a--> *srcR,
   const <!--a-->vImage_Buffer<!--/a--> *srcG,
   const <!--a-->vImage_Buffer<!--/a--> *srcB,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcA</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the alpha channel of the destination image.</p></dd> <dt><em>srcR</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the red channel of the destination image.</p></dd> <dt><em>srcG</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the green channel of the destination image.</p></dd> <dt><em>srcB</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the blue channel of the destination image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains the destination image in ARGB8888 format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The source and destination buffers must have the same height and width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_Planar8toPlanarF" title="vImageConvert_Planar8toPlanarF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_Planar8toPlanarF" title="vImageConvert_Planar8toPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_24" title="vImageConvert_Planar8toPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_67"></a><h3 class="tight">vImageConvert_Planar8toPlanarF</h3> <p class="spaceabove">Converts a Planar8 image to a PlanarF image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_Planar8toPlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> maxFloat,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> minFloat,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains the destination image converted to PlanarF format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>maxFloat</em></dt> <dd><p>The maximum pixel value for the destination image.</p></dd> <dt><em>minFloat</em></dt> <dd><p>The minimum pixel value for the destination image.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function transforms a Planar8 image to a PlanarF image, using a <em>minFloat</em> value and a <em>maxFloat</em> value to specify the range of values for the PlanarF image. The function maps each source pixel value(which can be in the range of 0 to 255 inclusive) linearly into the range <em>minFloat</em> to <em>maxFloat</em>, using the following mapping (where <code>i</code> is the old pixel value):</p><div class="codesample"><table><tr><td scope="row"><pre>new pixel value = i* (maxFloat - minFloat)/255.0f + minFloat<span></span></pre></td></tr></table></div><p>The two buffers must have the same number of rows and the same number of columns. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_Planar8toRGB565" title="vImageConvert_Planar8toRGB565"></a><a name="//apple_ref/doc/c_ref/vImageConvert_Planar8toRGB565" title="vImageConvert_Planar8toRGB565"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_25" title="vImageConvert_Planar8toRGB565"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_68"></a><h3 class="tight">vImageConvert_Planar8toRGB565</h3> <p class="spaceabove">Combines three Planar8 images  into one RGB565 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_Planar8toRGB565 (
   const <!--a-->vImage_Buffer<!--/a--> *srcR,
   const <!--a-->vImage_Buffer<!--/a--> *srcG,
   const <!--a-->vImage_Buffer<!--/a--> *srcB,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcR</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the red channel of the destination image.</p></dd> <dt><em>srcG</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the green channel of the destination image.</p></dd> <dt><em>srcB</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the blue channel of the destination image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains the destination image in RGB565 format (16-bit pixels with 5 bits for red, 6 for green, and 5 for blue). When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The function calculates the pixels in the destination image as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    uint32_t red   = (8bitRedChannel   * (31*2) + 255) / (255*2)<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t green = (8bitGreenChannel * 63 + 127) / 255<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t blue  = (8bitBlueChannel  * 31 + 127) / 255<span></span></pre></td></tr><tr><td scope="row"><pre>    uint16_t RGB565pixel =  (red &lt;&lt; 11) | (green &lt;&lt;  5) | blue<span></span></pre></td></tr></table></div><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_Planar8toRGB888" title="vImageConvert_Planar8toRGB888"></a><a name="//apple_ref/doc/c_ref/vImageConvert_Planar8toRGB888" title="vImageConvert_Planar8toRGB888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_26" title="vImageConvert_Planar8toRGB888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_69"></a><h3 class="tight">vImageConvert_Planar8toRGB888</h3> <p class="spaceabove">Combines three Planar8 images  into one RGB888 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_Planar8toRGB888 (
   const <!--a-->vImage_Buffer<!--/a--> *planarRed,
   const <!--a-->vImage_Buffer<!--/a--> *planarGreen,
   const <!--a-->vImage_Buffer<!--/a--> *planarBlue,
   const <!--a-->vImage_Buffer<!--/a--> *rgbDest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>planarRed</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the red channel of the destination image.</p></dd> <dt><em>planarGreen</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the green channel of the destination image.</p></dd> <dt><em>planarBlue</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the Planar8 image to use as the blue channel of the destination image.</p></dd> <dt><em>rgbDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains the destination image in RGB888 format.  When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The source and destination buffers must have the same height and width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_PlanarFtoARGBFFFF" title="vImageConvert_PlanarFtoARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_PlanarFtoARGBFFFF" title="vImageConvert_PlanarFtoARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_28" title="vImageConvert_PlanarFtoARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_70"></a><h3 class="tight">vImageConvert_PlanarFtoARGBFFFF</h3> <p class="spaceabove">Combines four PlanarF images into one ARGBFFFF image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_PlanarFtoARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *srcA,
   const <!--a-->vImage_Buffer<!--/a--> *srcR,
   const <!--a-->vImage_Buffer<!--/a--> *srcG,
   const <!--a-->vImage_Buffer<!--/a--> *srcB,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcA</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the PlanarF image to use as the alpha channel of the destination image.</p></dd> <dt><em>srcR</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the PlanarF image to use as the red channel of the destination image.</p></dd> <dt><em>srcG</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the PlanarF image to use as the green channel of the destination image.</p></dd> <dt><em>srcB</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the PlanarF image to use as the blue channel of the destination image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains  the destination image data in ARGBFFFF format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The source and destination buffers must have the same height and width. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_PlanarFtoPlanar16F" title="vImageConvert_PlanarFtoPlanar16F"></a><a name="//apple_ref/doc/c_ref/vImageConvert_PlanarFtoPlanar16F" title="vImageConvert_PlanarFtoPlanar16F"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_29" title="vImageConvert_PlanarFtoPlanar16F"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_71"></a><h3 class="tight">vImageConvert_PlanarFtoPlanar16F</h3> <p class="spaceabove">Converts a PlanarF image to a Planar16F image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_PlanarFtoPlanar16F (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains the destination image converted to Planar16F format. The destination buffer can be the same as the source buffer. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>Planar16F pixels are 16-bit floating-point numbers, conforming to the OpenEXR standard. Denormals, NaNs. and +/– Infinity are supported. In conformance with IEEE-754, all signaling NaNs are quieted during the conversion (OpenEXR-1.2.1 does not do this.)</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8" title="vImageConvert_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageConvert_PlanarFtoPlanar8" title="vImageConvert_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_PlanarFtoPlanar8" title="vImageConvert_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_72"></a><h3 class="tight">vImageConvert_PlanarFtoPlanar8</h3> <p class="spaceabove">Converts a PlanarF image to a Planar8 image, clipping values to the provided minimum and maximum values.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_PlanarFtoPlanar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> maxFloat,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> minFloat,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains the destination image converted to Planar8 format. When you no longer need the data buffer, you must deallocate the memory. </p></dd> <dt><em>maxFloat</em></dt> <dd><p>A maximum pixel value. The function clips larger values to this value in the destination image.</p></dd> <dt><em>maxFloat</em></dt> <dd><p>A minimum pixel value. The function clips smaller values to this value in the destination image.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The minimum and maximum value determine the mapping of intensity values to the destination image. The mapping is:</p><div class="codesample"><table><tr><td scope="row"><pre>    if oldPixel &lt; minFloat<span></span></pre></td></tr><tr><td scope="row"><pre>    newPixel = 0<span></span></pre></td></tr></table></div><div class="codesample"><table><tr><td scope="row"><pre>    if minfloat &lt;= oldPixel &lt;= maxFloat<span></span></pre></td></tr><tr><td scope="row"><pre>    newPixel = (oldPixel - minFloat) * 255.0f / (maxFloat - minFloat)<span></span></pre></td></tr></table></div><div class="codesample"><table><tr><td scope="row"><pre>    if oldPixel > maxFloat<span></span></pre></td></tr><tr><td scope="row"><pre>    newPixel = 255<span></span></pre></td></tr></table></div><p>The source and destination buffers must have the same height and width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_PlanarFtoRGBFFF" title="vImageConvert_PlanarFtoRGBFFF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_PlanarFtoRGBFFF" title="vImageConvert_PlanarFtoRGBFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_27" title="vImageConvert_PlanarFtoRGBFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_73"></a><h3 class="tight">vImageConvert_PlanarFtoRGBFFF</h3> <p class="spaceabove">Combines three PlanarF images into one RGBFFF image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_PlanarFtoRGBFFF (
   const <!--a-->vImage_Buffer<!--/a--> *planarRed,
   const <!--a-->vImage_Buffer<!--/a--> *planarGreen,
   const <!--a-->vImage_Buffer<!--/a--> *planarBlue,
   const <!--a-->vImage_Buffer<!--/a--> *rgbDest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>planarRed</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the PlanarF image to use as the red channel of the destination image.</p></dd> <dt><em>planarGreen</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the PlanarF image to use as the green channel of the destination image.</p></dd> <dt><em>planarBlue</em></dt> <dd><p>A pointer to vImage buffer structure that contains  the PlanarF image to use as the blue channel of the destination image.</p></dd> <dt><em>rgbDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains the destination image in RGBFFF format. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The source and destination buffers must have the same height and width. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_PlanarToChunky8" title="vImageConvert_PlanarToChunky8"></a><a name="//apple_ref/doc/c_ref/vImageConvert_PlanarToChunky8" title="vImageConvert_PlanarToChunky8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_PlanarToChunky8" title="vImageConvert_PlanarToChunky8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_74"></a><h3 class="tight">vImageConvert_PlanarToChunky8</h3> <p class="spaceabove">Combines a collection of planar source images into a single interleaved destination image, with one 8-bit channel for each planar image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_PlanarToChunky8 (
   const <!--a-->vImage_Buffer<!--/a--> *srcPlanarBuffers[],
   void *destChannels[],
   unsigned int channelCount,
   size_t destStrideBytes,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> destWidth,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> destHeight,
   size_t destRowBytes,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcPlanarBuffers</em></dt> <dd><p>An array of  vImage buffer structures, each of which contains image data in Planar8 format. Each structure must have the same width and height values, but may have  different row byte values.</p></dd> <dt><em>destChannels</em></dt> <dd><p>An array of pointers to channels of the destination image. Each pointer points to the start of the data for one destination channel. The function fills the pixel values of each channel, using the corresponding source image for each channel.</p></dd> <dt><em>channelCount</em></dt> <dd><p>The number of vImage buffer structures in the <em>srcPlanarBuffers</em> array and the number of channels in the destination image.</p></dd> <dt><em>destStrideBytes</em></dt> <dd><p>The number of bytes from one pixel value in a given channel to the next pixel of that channel (within a row). This value is used for all channels.</p></dd> <dt><em>destWidth</em></dt> <dd><p>The number of pixels in a row. This value is used for all channels. It must be the same as the width of each of the planar source images.</p></dd> <dt><em>destHeight</em></dt> <dd><p>The number of rows. This value will be used for all channels. It must be the same as the height of each of the planar source images.</p></dd> <dt><em>destRowBytes</em></dt> <dd><p>The number of bytes from the beginning of a channel  row to the beginning of the next row in that channel. This value is used for all channels. (It does not have to be the same as the <em>rowBytes</em> values of the source buffers. Each source buffer can have its own <em>rowBytes</em> value.)</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_PlanarToChunkyF" title="vImageConvert_PlanarToChunkyF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_PlanarToChunkyF" title="vImageConvert_PlanarToChunkyF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageConvert_PlanarToChunkyF" title="vImageConvert_PlanarToChunkyF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_75"></a><h3 class="tight">vImageConvert_PlanarToChunkyF</h3> <p class="spaceabove">Combines a collection of planar source images into a single interleaved destination image, with one floating-point channel for each planar image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_PlanarToChunkyF (
   const <!--a-->vImage_Buffer<!--/a--> *srcPlanarBuffers[],
   void *destChannels[],
   unsigned int channelCount,
   size_t destStrideBytes,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> destWidth,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> destHeight,
   size_t destRowBytes,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>srcPlanarBuffers</em></dt> <dd><p>An array of  vImage buffer structures, each of which contains image data in PlanarF format. Each structure must have the same width and height values, but may have  different row byte values.</p></dd> <dt><em>destChannels</em></dt> <dd><p>An array of pointers to channels of the destination image. Each pointer points to the start of the data for one destination channel. The function fills the pixel values of each channel, using the corresponding source image for each channel.</p></dd> <dt><em>channelCount</em></dt> <dd><p>The number of vImage buffer structures in the <em>srcPlanarBuffers</em> array and the number of channels in the destination image.</p></dd> <dt><em>destStrideBytes</em></dt> <dd><p>The number of bytes from one pixel value in a given channel to the next pixel of that channel (within a row). This value is used for all channels.</p></dd> <dt><em>destWidth</em></dt> <dd><p>The number of pixels in a row. This value is used for all channels. It must be the same as the width of each of the planar source images.</p></dd> <dt><em>destHeight</em></dt> <dd><p>The number of rows. This value is used for all channels. It must be the same as the height of each of the planar source images.</p></dd> <dt><em>destRowBytes</em></dt> <dd><p>The number of bytes from the beginning of a channel  row to the beginning of the next row in that channel. This value is used for all channels. (It does not have to be the same as the <em>rowBytes</em> values of the source buffers. Each source buffer can have its own <em>rowBytes</em> value.)</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_RGB565toARGB8888" title="vImageConvert_RGB565toARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageConvert_RGB565toARGB8888" title="vImageConvert_RGB565toARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_38" title="vImageConvert_RGB565toARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_76"></a><h3 class="tight">vImageConvert_RGB565toARGB8888</h3> <p class="spaceabove">Converts an RGB565 image into an ARGB8888 image, using the provided 8-bit alpha value. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_RGB565toARGB8888 (
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> alpha,
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>alpha</em></dt> <dd><p>A value of type <code>Pixel_8</code> to be used as the alpha value for all pixels in the destination image.</p></dd> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination data converted to ARGB8888 format.. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The RGB565 format has 16-bit pixels with 5 bits for red, 6 for green, and 5 for blue. The function calculates the pixels in the destination image as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    Pixel8 alpha = alpha<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 green = (6bitGreenChannel * 255 + 31) / 63<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31<span></span></pre></td></tr></table></div><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_RGB565toPlanar8" title="vImageConvert_RGB565toPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageConvert_RGB565toPlanar8" title="vImageConvert_RGB565toPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_37" title="vImageConvert_RGB565toPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_77"></a><h3 class="tight">vImageConvert_RGB565toPlanar8</h3> <p class="spaceabove">Separates an RGB565 image into three Planar8 images.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_RGB565toPlanar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *destR,
   const <!--a-->vImage_Buffer<!--/a--> *destG,
   const <!--a-->vImage_Buffer<!--/a--> *destB,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to separate.</p></dd> <dt><em>destR</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the red channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destG</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the green channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>destB</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the blue channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The RGB565 format has 16-bit pixels with 5 bits for red, 6 for green, and 5 for blue. The function calculates the pixels in the destination image as follows:</p> <div class="codesample"><table><tr><td scope="row"><pre>    Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 green = (6bitGreenChannel * 255 + 31) / 63<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31<span></span></pre></td></tr></table></div> <p>This function works in place for one destination buffer. You must allocate the others separately.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_RGB888toARGB8888" title="vImageConvert_RGB888toARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageConvert_RGB888toARGB8888" title="vImageConvert_RGB888toARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_39" title="vImageConvert_RGB888toARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_78"></a><h3 class="tight">vImageConvert_RGB888toARGB8888</h3> <p class="spaceabove">Converts an RGB888 image into an ARGB8888 image, using the provided alpha value (either as planar or pixel data).</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_RGB888toARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *rgbSrc,
   const <!--a-->vImage_Buffer<!--/a--> *aSrc,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> alpha,
   const <!--a-->vImage_Buffer<!--/a--> *argbDest,
   bool premultiply,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>rgbSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to convert.</p></dd> <dt><em>aSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains a Planar8 alpha plane to use as the alpha values for in the destination image. If you pass <code><!--a  -->NULL<!--/a--></code>, the function assigns the value of the <code>alpha</code> parameter for all pixels in the destination image.</p></dd> <dt><em>alpha</em></dt> <dd><p>An alpha value for all pixels in the destination image. The function ignores this value if the <code>aSrc</code> parameter is not <code><!--a  -->NULL<!--/a--></code>.</p></dd> <dt><em>argbDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains the converted image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd><dt><em>premultiply</em></dt><dd><p>Pass <code>YES</code> if the data is premultiplied by the alpha value; <code>NO</code> otherwise.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you specify premultiplied data, the function calculates each channel in the destination image as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>    (alpha * sourceValue + 127) / 255<span></span></pre></td></tr></table></div><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_RGB888toPlanar8" title="vImageConvert_RGB888toPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageConvert_RGB888toPlanar8" title="vImageConvert_RGB888toPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_40" title="vImageConvert_RGB888toPlanar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_79"></a><h3 class="tight">vImageConvert_RGB888toPlanar8</h3> <p class="spaceabove">Separates an RGB888 image into three Planar8 images.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_RGB888toPlanar8 (
   const <!--a-->vImage_Buffer<!--/a--> *rgbSrc,
   const <!--a-->vImage_Buffer<!--/a--> *redDest,
   const <!--a-->vImage_Buffer<!--/a--> *greenDest,
   const <!--a-->vImage_Buffer<!--/a--> *blueDest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>rgbSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to separate.</p></dd> <dt><em>redDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the red channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>greenDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the green channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>blueDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a Planar8 image equivalent to the blue channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The source image and the destination buffers, must all have the same height and the same width. This function works in place for one destination buffer. You must allocate the others  separately.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageConvert_RGBFFFtoPlanarF" title="vImageConvert_RGBFFFtoPlanarF"></a><a name="//apple_ref/doc/c_ref/vImageConvert_RGBFFFtoPlanarF" title="vImageConvert_RGBFFFtoPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_41" title="vImageConvert_RGBFFFtoPlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_80"></a><h3 class="tight">vImageConvert_RGBFFFtoPlanarF</h3> <p class="spaceabove">Separates an RGBFFF image into three PlanarF images.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvert_RGBFFFtoPlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *rgbSrc,
   const <!--a-->vImage_Buffer<!--/a--> *redDest,
   const <!--a-->vImage_Buffer<!--/a--> *greenDest,
   const <!--a-->vImage_Buffer<!--/a--> *blueDest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>rgbSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to separate.</p></dd> <dt><em>redDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a PlanarF image equivalent to the red channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>greenDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a PlanarF image equivalent to the green channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>blueDest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.   On return, the data buffer pointed to by this structure contains data for a PlanarF image equivalent to the blue channel of the source image. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The source image and the destination buffers, must all have the same height and the same width. This function works in place for one destination buffer. You must allocated the others separately.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageFlatten_ARGB8888ToRGB888" title="vImageFlatten_ARGB8888ToRGB888"></a><a name="//apple_ref/doc/c_ref/vImageFlatten_ARGB8888ToRGB888" title="vImageFlatten_ARGB8888ToRGB888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_15" title="vImageFlatten_ARGB8888ToRGB888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_81"></a><h3 class="tight">vImageFlatten_ARGB8888ToRGB888</h3> <p class="spaceabove">Transforms an ARGB8888 image to an RGB888 image against an opaque background of the provided color.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageFlatten_ARGB8888ToRGB888 (
const <!--a-->vImage_Buffer<!--/a--> *argb8888Src,
const <!--a-->vImage_Buffer<!--/a--> *rgb888dest,
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backgroundColor,
bool isImagePremultiplied,
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>argb8888Src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to flatten.</p></dd> <dt><em>rgb888dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>argb8888Src</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The destination buffer can be the same as the source buffer.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>An 8-bit interleaved pixel value.</p></dd> <dt><em>isImagePremultiplied</em></dt> <dd><p><code>TRUE</code> if the source image uses premultiplied data , <code>FALSE</code> otherwise.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>If the source image uses premultiplied data, the function calculates each channel value for a pixel in the destination image as follows (where i is the source value for the channel):</p> <div class="codesample"><table><tr><td scope="row"><pre>    new value = (i * 255 + (255 - alpha) * backgroundColor + 127)  / 255<span></span></pre></td></tr></table></div> <p>If the source image does not use premultiplied data, the function calculates each channel value for a pixel in the destination image as follows (where i is the source value for the channel):</p> <div class="codesample"><table><tr><td scope="row"><pre>    new value = (i * alpha + (255 - alpha) * backgroundColor + 127)  / 255<span></span></pre></td></tr></table></div><p>The source and destinations buffer must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageFlatten_ARGBFFFFToRGBFFF" title="vImageFlatten_ARGBFFFFToRGBFFF"></a><a name="//apple_ref/doc/c_ref/vImageFlatten_ARGBFFFFToRGBFFF" title="vImageFlatten_ARGBFFFFToRGBFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_16" title="vImageFlatten_ARGBFFFFToRGBFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_82"></a><h3 class="tight">vImageFlatten_ARGBFFFFToRGBFFF</h3> <p class="spaceabove">Transforms an ARGBFFFF image to an RGBFFF image against an opaque background of the provided color.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageFlatten_ARGBFFFFToRGBFFF (
const <!--a-->vImage_Buffer<!--/a--> *argbFFFFSrc,
const <!--a-->vImage_Buffer<!--/a--> *rgbFFFdest,
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backgroundColor,
bool isImagePremultiplied,
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>argbFFFFSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to flatten.</p></dd> <dt><em>rgbFFFdest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>argbFFFFSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The destination buffer can be the same as the source buffer.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A floating-point interleaved pixel value.</p></dd> <dt><em>isImagePremultiplied</em></dt> <dd><p>True if the source image is premultiplied, false otherwise.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>If the source image uses premultiplied data, the function calculates each channel value for a pixel in the destination image as follows (where i is the source value for the channel):</p> <div class="codesample"><table><tr><td scope="row"><pre>    newcolor = i + (1.0f - alpha) * backgroundColor<span></span></pre></td></tr></table></div> <p>If the source image does not use premultiplied data, the function calculates each channel value for a pixel in the destination image as follows (where i is the source value for the channel):</p> <div class="codesample"><table><tr><td scope="row"><pre>    newcolor = i * alpha + (1.0f - alpha) * backgroundColor<span></span></pre></td></tr></table></div><p>The source and destinations buffer must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageOverwriteChannelsWithPixel_ARGB8888" title="vImageOverwriteChannelsWithPixel_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageOverwriteChannelsWithPixel_ARGB8888" title="vImageOverwriteChannelsWithPixel_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-SW3" title="vImageOverwriteChannelsWithPixel_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_83"></a><h3 class="tight">vImageOverwriteChannelsWithPixel_ARGB8888</h3><p class="spaceabove">Overwrites an ARGB8888 image buffer with the provided pixel value.</p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageOverwriteChannelsWithPixel_ARGB8888 (
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> the_pixel,
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t copyMask,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>the_pixel</em></dt><dd><p>An ARGB pixel value.</p></dd><dt><em>src</em></dt><dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to overwrite.</p></dd><dt><em>dest</em></dt><dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>origSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd><dt><em>copyMask</em></dt><dd><p>An output value that selects the plane (or planes) from the ARGB8888 source buffer that you want replaced with the pixel value. The value <code>0x8</code> selects the alpha channel, <code>0x4</code> the red channel, <code>0x2</code> the green channel, and <code>0x1</code> the blue channel. You can add these values together to select multiple channels.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.5 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageOverwriteChannelsWithPixel_ARGBFFFF" title="vImageOverwriteChannelsWithPixel_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageOverwriteChannelsWithPixel_ARGBFFFF" title="vImageOverwriteChannelsWithPixel_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-SW4" title="vImageOverwriteChannelsWithPixel_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_84"></a><h3 class="tight">vImageOverwriteChannelsWithPixel_ARGBFFFF</h3><p class="spaceabove">Overwrites an ARGBFFFF image buffer with the provided pixel value.</p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageOverwriteChannelsWithPixel_ARGBFFFF (
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> the_pixel,
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t copyMask,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>the_pixel</em></dt><dd><p>An ARGB pixel value.</p></dd><dt><em>src</em></dt><dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to overwrite.</p></dd><dt><em>dest</em></dt><dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>origSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd><dt><em>copyMask</em></dt><dd><p>An output value that selects the plane (or planes) from the ARGBFFFF source buffer that you want replaced with the pixel value. The value <code>0x8</code> selects the alpha channel, <code>0x4</code> the red channel, <code>0x2</code> the green channel, and <code>0x1</code> the blue channel. You can add these values together to select multiple channels.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.5 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageOverwriteChannelsWithScalar_ARGB8888" title="vImageOverwriteChannelsWithScalar_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageOverwriteChannelsWithScalar_ARGB8888" title="vImageOverwriteChannelsWithScalar_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_9" title="vImageOverwriteChannelsWithScalar_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_85"></a><h3 class="tight">vImageOverwriteChannelsWithScalar_ARGB8888</h3> <p class="spaceabove">Overwrites the pixels of one or more planes of an ARGB8888 image buffer with the provided scalar value.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageOverwriteChannelsWithScalar_ARGB8888 (
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> scalar,
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t copyMask,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>scalar</em></dt> <dd><p>An 8-bit pixel value.</p></dd> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to overwrite.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>origSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>copyMask</em></dt> <dd><p>An output value that selects the plane (or planes) from the ARGB8888 source buffer that you want replaced with the scalar value. The value <code>0x8</code> selects the alpha channel, <code>0x4</code> the red channel, <code>0x2</code> the green channel, and <code>0x1</code> the blue channel. You can add these values together to select multiple channels.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageOverwriteChannelsWithScalar_ARGBFFFF" title="vImageOverwriteChannelsWithScalar_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageOverwriteChannelsWithScalar_ARGBFFFF" title="vImageOverwriteChannelsWithScalar_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_10" title="vImageOverwriteChannelsWithScalar_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_86"></a><h3 class="tight">vImageOverwriteChannelsWithScalar_ARGBFFFF</h3> <p class="spaceabove">Overwrites the pixels of one or more planes of an ARGBFFFF image buffer with the provided scalar value.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageOverwriteChannelsWithScalar_ARGBFFFF (
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> scalar,
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t copyMask,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>scalar</em></dt> <dd><p>A floating-point pixel value.</p></dd> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to overwrite.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>origSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>copyMask</em></dt> <dd><p>An output value that selects the plane (or planes) from the ARGBFFFF source buffer that you want replaced with the scalar value. The value <code>0x8</code> selects the alpha channel, <code>0x4</code> the red channel, <code>0x2</code> the green channel, and <code>0x1</code> the blue channel. You can add these values together to select multiple channels.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageOverwriteChannelsWithScalar_Planar8" title="vImageOverwriteChannelsWithScalar_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageOverwriteChannelsWithScalar_Planar8" title="vImageOverwriteChannelsWithScalar_Planar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-BBCHDAEB" title="vImageOverwriteChannelsWithScalar_Planar8"></a> <a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_87"></a><h3 class="tight">vImageOverwriteChannelsWithScalar_Planar8</h3> <p class="spaceabove">Overwrites a Planar8 image buffer with the provided value.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageOverwriteChannelsWithScalar_Planar8 (
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> scalar,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>scalar</em></dt> <dd><p>An 8-bit pixel value.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> field in the flags parameter to prevent vImage from using tiling internally. (This is appropriate if you are doing tiling yourself.)</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageOverwriteChannelsWithScalar_PlanarF" title="vImageOverwriteChannelsWithScalar_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageOverwriteChannelsWithScalar_PlanarF" title="vImageOverwriteChannelsWithScalar_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_11" title="vImageOverwriteChannelsWithScalar_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_88"></a><h3 class="tight">vImageOverwriteChannelsWithScalar_PlanarF</h3> <p class="spaceabove">Overwrites a PlanarF image buffer with the provided value.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageOverwriteChannelsWithScalar_PlanarF (
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> scalar,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>scalar</em></dt> <dd><p>A floating-point pixel value.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageOverwriteChannels_ARGB8888" title="vImageOverwriteChannels_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageOverwriteChannels_ARGB8888" title="vImageOverwriteChannels_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_7" title="vImageOverwriteChannels_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_89"></a><h3 class="tight">vImageOverwriteChannels_ARGB8888</h3> <p class="spaceabove">Overwrites one or more planes of an ARGB8888 image buffer with the provided planar buffer.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageOverwriteChannels_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *newSrc,
   const <!--a-->vImage_Buffer<!--/a--> *origSrc,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t copyMask,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>newSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the data, in Planar8 format, for overwriting the <code>origSrc</code> image data.</p></dd> <dt><em>origSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to overwrite.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>origSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>copyMask</em></dt> <dd><p>An output value that selects the plane (or planes) from the ARGB8888 source buffer that you want replaced with data from the Planar8 source buffer. The value <code>0x8</code> selects the alpha channel, <code>0x4</code> the red channel, <code>0x2</code> the green channel, and <code>0x1</code> the blue channel. You can add these values together to select multiple channels.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The function overwrites pixel values in the <code>origSrc</code> image buffer using the corresponding pixel value from the <code>newSrc</code> image buffer.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageOverwriteChannels_ARGBFFFF" title="vImageOverwriteChannels_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageOverwriteChannels_ARGBFFFF" title="vImageOverwriteChannels_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_8" title="vImageOverwriteChannels_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_90"></a><h3 class="tight">vImageOverwriteChannels_ARGBFFFF</h3> <p class="spaceabove">Overwrites one or more planes of an ARGBFFFF image buffer with the provided planar buffer.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageOverwriteChannels_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *newSrc,
   const <!--a-->vImage_Buffer<!--/a--> *origSrc,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t copyMask,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>newSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the data, in PlanarF format, for overwriting the <code>origSrc</code> image data.</p></dd> <dt><em>origSrc</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to overwrite.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>origSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>copyMask</em></dt> <dd><p>An output value that selects the plane (or planes) from the ARGBFFFF source buffer that you want replaced with data from the Planar8 source buffer. The value <code>0x8</code> selects the alpha channel, <code>0x4</code> the red channel, <code>0x2</code> the green channel, and <code>0x1</code> the blue channel. You can add these values together to select multiple channels.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The function overwrites pixel values in the <code>origSrc</code> image buffer using the corresponding pixel value from the <code>newSrc</code> image buffer.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImagePermuteChannels_ARGB8888" title="vImagePermuteChannels_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImagePermuteChannels_ARGB8888" title="vImagePermuteChannels_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_4" title="vImagePermuteChannels_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_91"></a><h3 class="tight">vImagePermuteChannels_ARGB8888</h3> <p class="spaceabove">Reorders the channels in an ARGB8888 image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImagePermuteChannels_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const uint8_t permuteMap[4],
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image whose data you want to permute.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>permuteMap</em></dt> <dd><p>An array of four 8-bit integers with the values 0, 1, 2, and 3, in some order. The ith value specifies the plane from the source image that you want copied to the ith plane of the destination image. 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.  The following figure shows the result of using a permute map shows values are (0, 3, 2, 1). The data in the alpha and green channels remain the same, but the data in the source red channel maps to the destination blue channel while the data in the source blue channel maps to the destination red channel.</p><br/><div><a name="//apple_ref/doc/uid/TP40005488-CH210-SW5" title="Figure 1Permuting the red and blue channels"></a><p><strong>Figure 1&nbsp;&nbsp;</strong>Permuting the red and blue channels</p><img src = "../art/permute.jpg" alt = "Permuting the red and blue channels" ></div><br/></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the permutation  operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImagePermuteChannels_ARGBFFFF" title="vImagePermuteChannels_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImagePermuteChannels_ARGBFFFF" title="vImagePermuteChannels_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_5" title="vImagePermuteChannels_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_92"></a><h3 class="tight">vImagePermuteChannels_ARGBFFFF</h3> <p class="spaceabove">Reorders the channels in an ARGBFFFF image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImagePermuteChannels_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const uint8_t permuteMap[4],
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image whose data you want to permute.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>permuteMap</em></dt> <dd><p>An array of four 8-bit integers with the values 0, 1, 2, and 3, in some order. The ith value specifies the plane from the source image that will be copied to the ith plane of the destination image. 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel. <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40005488-CH210-SW5">Figure 1</a></span> shows the result of using a permute map shows values are (0, 3, 2, 1). The data in the alpha and green channels remain the same, but the data in the source red channel maps to the destination blue channel while the data in the source blue channel maps to the destination red channel.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the permutation operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageSelectChannels_ARGB8888" title="vImageSelectChannels_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageSelectChannels_ARGB8888" title="vImageSelectChannels_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-SW1" title="vImageSelectChannels_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_93"></a><h3 class="tight">vImageSelectChannels_ARGB8888</h3><p class="spaceabove">Overwrites the specified channels in an ARGB8888 image buffer with the provided channels from an ARGB8888 image buffer.</p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageSelectChannels_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *newSrc,
   const <!--a-->vImage_Buffer<!--/a--> *origSrc,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t copyMask,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>newSrc</em></dt><dd><p>A pointer to a vImage buffer structure that contains the data, in ARGB8888 format, for overwriting the <code>origSrc</code> image data.</p></dd><dt><em>origSrc</em></dt><dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to overwrite.</p></dd><dt><em>dest</em></dt><dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>origSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd><dt><em>copyMask</em></dt><dd><p>An output value that selects the plane (or planes) from the ARGB8888 source buffer that you want replaced with the corresponding plane from the <code>newSrc</code> image buffer. The value <code>0x8</code> selects the alpha channel, <code>0x4</code> the red channel, <code>0x2</code> the green channel, and <code>0x1</code> the blue channel. You can add these values together to select multiple channels.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.5 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageOverwriteChannels_ARGB8888" target="_self">vImageOverwriteChannels_ARGB8888</a></code></li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageSelectChannels_ARGBFFFF" title="vImageSelectChannels_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageSelectChannels_ARGBFFFF" title="vImageSelectChannels_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-SW2" title="vImageSelectChannels_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_94"></a><h3 class="tight">vImageSelectChannels_ARGBFFFF</h3><p class="spaceabove">Overwrites the specified channels in an ARGBFFFF image buffer with the provided channels in an ARGBFFFF image buffer.</p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageSelectChannels_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *newSrc,
   const <!--a-->vImage_Buffer<!--/a--> *origSrc,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t copyMask,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>newSrc</em></dt><dd><p>A pointer to a vImage buffer structure that contains the data, in ARGBFFFF format, for overwriting the <code>origSrc</code> image data.</p></dd><dt><em>origSrc</em></dt><dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to overwrite.</p></dd><dt><em>dest</em></dt><dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>origSrc</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd><dt><em>copyMask</em></dt><dd><p>An output value that selects the plane (or planes) from the ARGBFFFF source buffer that you want replaced with the corresponding plane from the <code>newSrc</code> image buffer. The value <code>0x8</code> selects the alpha channel, <code>0x4</code> the red channel, <code>0x2</code> the green channel, and <code>0x1</code> the blue channel. You can add these values together to select multiple channels.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.5 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageTableLookUp_ARGB8888" title="vImageTableLookUp_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageTableLookUp_ARGB8888" title="vImageTableLookUp_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageTableLookUp_ARGB8888" title="vImageTableLookUp_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_95"></a><h3 class="tight">vImageTableLookUp_ARGB8888</h3> <p class="spaceabove">Transforms an ARGB8888 image by substituting pixel values with pixel values provided by four lookup tables.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageTableLookUp_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> alphaTable[256],
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> redTable[256],
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> greenTable[256],
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> blueTable[256],
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to transform.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>alphaTable</em></dt> <dd><p>The lookup table to use for the alpha channel of the source image. If you pass <code>NULL</code> for this table, the function copies the alpha channel unchanged to the destination buffer.</p></dd> <dt><em>redTable</em></dt> <dd><p>The lookup table to use for the red channel of the source image. If you pass <code>NULL</code> for this table, the function copies the red channel unchanged to the destination buffer.</p></dd> <dt><em>greenTable</em></dt> <dd><p>The lookup table to use for the green channel of the source image. If you pass <code>NULL</code> for this table, the function copies the green channel unchanged to the destination buffer.</p></dd> <dt><em>blueTable</em></dt> <dd><p>The lookup table to use for the blue channel of the source image. If you pass <code>NULL</code> for this table, the function copies the blue channel unchanged to the destination buffer.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The function separates each pixel into  four channels—alpha, red, green, and blue. It substitutes each channel separately, using the appropriate table. Then the function recombines each pixel  into a single ARGB8888 value, placing the transformed image into the destination buffer. </p><p>The source and destinations buffer must have the same height and the same width.</p> <p>You cannot use this function to perform an arbitrary color mapping. For example, if two different source colors have the same green component, you must map them to two destination colors whose green components are equal. You can’t map them to two arbitrary colors.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code><a name="//apple_ref/c/func/vImageTableLookUp_Planar8" title="vImageTableLookUp_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageTableLookUp_Planar8" title="vImageTableLookUp_Planar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-vImageTableLookUp_Planar8" title="vImageTableLookUp_Planar8"></a><a name="//apple_ref/doc/uid/TP40005488-CH210-DontLinkElementID_96"></a><h3 class="tight">vImageTableLookUp_Planar8</h3> <p class="spaceabove">Transforms an Planar8 image by substituting pixel values with pixel values provided by four lookup tables.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageTableLookUp_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> table[256],
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image  whose data you want to transform.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  The destination data buffer can be the same as the <code>src</code> data buffer. On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>table</em></dt> <dd><p>The lookup table to use.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing this operation. Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function transforms a Planar8 image by replacing all pixels of a given intensity value with pixels of a new intensity value. It maps old values to new values using the provided  256-element lookup table (LUT).</p><p>The source and destinations buffer must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Conversion.h</code>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-12<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Reference/vImage_conversion/Reference/reference.html%3Fid%3DTP40005488-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Reference/vImage_conversion/Reference/reference.html%3Fid%3DTP40005488-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Reference/vImage_conversion/Reference/reference.html%3Fid%3DTP40005488-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>