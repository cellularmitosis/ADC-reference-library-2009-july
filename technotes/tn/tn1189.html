<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1189: The Monster Disk Driver Technote</title><meta name="keywords" content="Macintosh Disk Driver Overview"><meta name="Description" content="Technical Note TN1189: This Technote is both a summary andreview of existing disk driver information and a descriptionof disk driver features that until now have not been generallydocumented. This Note is directed at developers of disk driversand disk formatting utilities. There is also a section specificallyaimed at application developers who need to operate on disksdirectly. "><meta name="categories" content="Devices"><meta name="week-posted" content="Nov 1, 1999 - Nov 5, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003028" title="The Monster Disk Driver Technote"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1189</div>
<div id="pageheadsub">The Monster Disk Driver Technote</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">   <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr><td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <span id="menutitle">CONTENTS   <br>  <br> </span>   </td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <!-- begin_toc -->   <P id ="menutext"><A HREF = "#Introduction">Introduction</A><BR><BR><A HREF = "#DiskDriverBasics">DiskDriver Basics</A><BR><BR><A HREF = "#DriverGestalt">DriverGestalt</A><BR><BR><A HREF = "#SecretsOfThePartitionMap">Secrets of thePartition Map</A><BR><BR><A HREF = "#Non512ByteBlockDevices">Non-512 ByteBlock Devices</A><BR><BR><A HREF = "#LargeVolumeSupport">LargeVolume Support</A><BR><BR><A HREF = "#HowTheROMLoadsDiskDrivers">How the ROMLoads SCSI and ATA Drivers</A><BR><BR><A HREF = "#LoadingFireWireDrivers">Loading FireWireDrivers</A><BR><BR><A HREF = "#ChainingDriversAndPatchPartitions">ChainingDrivers and Patch Partitions</A><BR><BR><A HREF = "#DiskDriversAndTheSystemHeap">DiskDrivers and the System Heap</A><BR><BR><A HREF = "#PowerPCNativeDiskDrivers">PowerPC NativeDisk Drivers</A><BR><BR><A HREF = "#InstallingAndRemovingDriversAndDrives">Installingand Removing Drivers and Drives</A><BR><BR><A HREF = "#CloseAndPurge">Close andPurge</A><BR><BR><A HREF = "#FileExchange">File Exchange(n&eacute; PC Exchange)</A><BR><BR><A HREF = "#PrivateControlAndStatusRequests">PrivateControl and Status Requests</A><BR><BR><A HREF = "#ReadVerifyMode">Read-VerifyMode</A><BR><BR><A HREF = "#colorIcons">ColorIcons</A><BR><BR><A HREF = "#TargetMode">TargetMode</A><BR><BR><A HREF = "#DiskDriverPowerManagement">Disk DriverPower Management</A><BR><BR><A HREF = "#Summary">Summary</A><BR><BR><A HREF = "#Downloads">Downloadables</A></p> <!-- end_toc --></td>  </tr>  <tr>   <td width=300 align=left scope="row"> <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>  </tr>    </table></td>  <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technote is both a summary and review of existing disk driverinformation and a description of disk driver features thatuntil now have not been generally documented.</P><P id = "introtext">This Note is directed at developers of disk drivers anddisk formatting utilities. There is also a sectionspecifically aimed at application developers who need tooperate on disks directly.</p>     <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Nov 22 1999]</h3><!-- end_date --></TD> </TR>    </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><P><A NAME="Introduction"></A></P><H2>Introduction</H2><P>The Mac OS disk driver architecture has not beencomprehensively documented since <CITE>Inside MacintoshII</CITE> (1985). In the intervening years, disk technologyhas changed radically, from 400 KB floppy disks to FireWire,visiting two different SCSI Managers and four versions ofATA Manager on the way. Many of these technological changeshave been accompanied by architectural changes for which thedocumentation is in obscureplaces, was notgenerally released, or was just never written.</P><P>The technote is an attempt to rectify that oversight. Itserves both to bring together the existing documentation andto fill in the missing pieces. You can use this technote aseither a reference, an introduction to writing diskdrivers, or just to bring yourself up-to-date on the latestdisk driver advances.</P><P>If you are new to Mac OS disk drivers, you should startwith the <A HREF = "#DiskDriverBasics">Disk Driver Basics</A>section. If you're already familiar with the basics of theMac OS disk driver architecture, you may want to start withthe two high-level summaries, one for<A HREF = "#ChecklistForDiskDriversWriters">disk driverwriters</A> and one for<A HREF = "#ForApplicationWriters">application developers</A>.</P><H3><A NAME="ExistingInformation"></A>Existing Information</H3><P>The existing documentation for disk drivers is scatteredthrough many different Apple documents, interface files, andcode samples. The sectionclassifies these references based on theirusefulness.</P><H4>Core References</H4><P>These large works cover information that you willdefinitely need in your driver. Don't start a disk driverwithout being familiar with these works:</P><UL>   <LI><CITE>Inside Macintosh:   Devices</CITE>, <a href="http://developer.apple.com/documentation/mac/Devices/Devices-119.html">SCSI   Manager</A> is the core   reference for the classic SCSI Manager programming   interface, introduced with the Mac Plus. It also   describes the Apple <a href="http://developer.apple.com/documentation/mac/Devices/Devices-121.html#HEADING121-37">partition   map format</A>, used by all   Macintosh computers since the Mac Plus.</li>      <LI><CITE>Inside Macintosh:   Devices</CITE>, <a href="http://developer.apple.com/documentation/mac/Devices/Devices-119.html">SCSI   Manager 4.3</A> is the core   reference for the SCSI Manager 4.3 programming interface,   introduced with the Quadra 840av. All SCSI drivers   written today should use the SCSI Manager 4.3 programming   interface.</li>      <LI><a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATA   Device Software for Macintosh Computers</A> (previously   known as the <CITE>ATA Device Software Guide</CITE>) is   the core reference for the ATA Manager, which allows you   to find and control ATA devices connected to the   computer. The "ATA Driver Reference" chapter offers a   useful summary of the Control and Status requests   relevant to a modern Mac OS hard disk driver, although   some of the information is inaccurate and has been   updated <A HREF = "#PartitionAttributes"> in this   document</A>.</li>      <LI><a href="http://developer.apple.com/documentation/hardware/Developer_Notes/System_Software/ATA_Device_Zero_One.pdf">ATA   0/1 Software Developers Guide</A> is a supplement to the   above, and describes the changes required to support   device 0/1 (master/slave) on ATA buses.</li>      <LI><a href="http://developer.apple.com/documentation/mac/Files/Files-2.html">Inside   Macintosh: Files</A> describes the   <a href="http://developer.apple.com/documentation/mac/Files/Files-112.html">drive   queue</A>, a key data structure used by all disk drivers.</li>      <LI>Technote 1041,    <a href="tn1041.html">"Inside   Macintosh: Files Errata"</A> comprises corrections to the   core <CITE>Inside Macintosh: Files</CITE> document.</li>      <LI>The <A HREF = "http://www.sdap.hoot.to/">Shared Device   Access Protocol</A> specification.</li>      <LI>DTS sample code   <A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Devices_and_Hardware/Disks/RAMDisk.sit">RAM   Disk</A> implements the basic framework for a disk   driver. Unfortunately, it does not demonstrate how to   handle requests asynchronously, which is one of the   trickiest things to get right in a disk driver.</li>      <LI><A NAME="TradDriverLoaderLib"></A>DTS sample code   <A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Devices_and_Hardware/Drivers/TradDriverLoaderLib.sit">TradDriverLoaderLib</A>   shows how to correctly install a Mac OS driver   <CODE>'DRVR'</CODE>.</li>      <LI>DTS sample code   <A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Devices_and_Hardware/SCSI/SCSI_Driver_Example.sit">SCSI   Driver Example</A> demonstrates a fully fledged SCSI   driver that supports both classic SCSI Manager and SCSI   Manager 4.3. It is a useful sample, although it has   decayed a bit in the years since it was last updated   (1994).</li>      <LI>DTS sample code   <A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Devices_and_Hardware/ATA/ATA_Demo.sit">ATA_Demo</A>&nbsp;demonstrates   how to read blocks from both ATA   and ATAPI disks.</li>      <LI>"DriverGestalt.h" (from the latest   <a href="http://developer.apple.com/sdk/">Universal   Interfaces</A>) always contains the most up-to-date list   of Driver Gestalt selectors.</li>      <LI>The MoreDisks module from the DTS sample code library   <A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Overview/MoreIsBetter.sit">MoreIsBetter</A>   contains a comprehensive list of all the currently   defined disk driver Control and Status requests, and   where to get more information on how to support them.</li></UL><H4>Additional Information</H4><P>These smaller documents contain information thatsupplements the above in certain key areas.</P><UL>   <LI>Technote 1098,    <a href="tn1098.html">"ATA   Device Software Guide: Additions and Corrections"</A> is   the latest errata for the   <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATA   Device Software for Macintosh Computers</A>.</li>      <LI>Technote DV 17   <a href="../dv/dv_17.html">Sony   Driver: What your Sony Drives For You</A> documents the   Control and Status requests supported by Apple's standard   floppy disk driver. This is a key reference for disk   driver developers. Floppy disk driver writers should also   read the "MFM Disk Device Driver" chapter of   <a href="http://developer.apple.com/documentation/hardware/hardware2.html">Apple   Logic Board Design LPX-40 Developer Note</A> (hardware   developer note), which includes information on floppy   disk Control and Status requests that is missing from DV   17.</li>      <LI>Technote DV 22,    <a href="../dv/dv_22.html">"CD-ROM   Driver Calls"</A> documents the Control and Status   requests supported by Apple's standard CD-ROM driver.   This is a key reference for CD-ROM driver developers.</li>      <LI>Technote 1104,    <a href="tn1104.html">"Interrupt-Safe   Routines"</A> answers the perennial question, can I do X   at interrupt time?</li>      <LI>Technote 1067,    <a href="tn1067.html">"Traditional   Device Drivers: Sync or Swim"</A> addresses a common   misconception of device driver writers.</li>      <LI>Technote 1040,    <a href="tn1040.html">"Write   Cache Flushing: Techniques for Properly Handling System   Shutdown"</A> describes how disk drivers should handle   system shutdown.</li>      <LI>Technote ME 09,   <a href="../me/me_09.html">"Coping   with VM and Memory Mappings"</A> is probably the best   place for information on ensuring that your device driver is   compatible with virtual memory.</li>      <LI>Technote 1094,    <a href="tn1094.html">"Virtual   Memory Application Compatibility"</A> contains a description of the Mac   OS VM architecture as a whole, which is useful background   material for device driver writers.</li>      <LI><A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">Designing   PCI Cards and Drivers for Power Macintosh Computers</A>,   pages 110 through 117, documents the Driver Gestalt   mechanism and some new Control requests. This technote   provides clarifications and corrections on   <A HREF = "#DriverGestalt">Driver Gestalt</A> and the   mechanism used to <A HREF = "#BootingFromAPartition">boot   from a partition</A>. In addition, the   <A HREF = "#FileExchange">File Exchange section</A> of this   technote completely replaces the PC Exchange description   in the book.</li>      <LI><A HREF = "ftp://ftp.apple.com//developer/Development_Kits/File_System_Manager.sit.hqx">Guide   to the File System Manager</A> contains useful background   information about how FSM interacts with disk drivers;   however, the specific recommendations for driver writers   are covered in the <A HREF = "#FileExchange">File   Exchange</A> section of this technote.</li>      <LI>DTS Q&amp;A OPS 22,    <a href="../../qa/ops/ops22.html">"Notification   Manager Reinitialized During Boot"</A> is an important   tidbit for disk driver developers.</li>      <LI>DTS Q&amp;A DV 34,    <a href="../../qa/dv/dv34.html">"Secondary   Interrupts on the Page Fault Path"</A> describes the   dangers of using secondary interrupts in software that   must service page faults. While the Q&amp;A was written   for SIM developers, its warning is also important for   other page fault path software, such as disk drivers.   <EM>Disk drivers must not use secondary interrupts (or,   for that matter, deferred tasks) on the page fault   path.</EM></li>      <LI><A HREF = "downloads/DataSecurityRecovery.txt">Data Structure to   Aid Security and Recovery Software</A>, David Shayer and   Marvin Carlberg, 1991</li>      <LI>The InterruptSafeDebug module   of the DTS sample code library <A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Overview/MoreIsBetter.sit">MoreIsBetter</A> can be useful when tracking down nasty   crashing problems in a device driver, especially those   that happen early at startup time.</li></UL><H4>Obsolete</H4><P>These documents, as they pertain to disk drivers, areconsidered obsolete. This list is provided for completeness only. Youshould read the recommended material instead.</P><UL>   <LI><CITE>Inside Macintosh   II</CITE>, "The Disk   Driver", page 211 through 219, documents the basic   interface to a disk driver, include the   <CODE>kEject</CODE> (7) Control request, the   <CODE>kSetTagBuffer</CODE> (8) Control request, and the   <CODE>kDriveStatus</CODE> (8) Status request.</li>      <LI><CITE>Inside Macintosh   IV</CITE>, "The Disk   Driver", page 223 through 224, documents the   <CODE>kVerify</CODE> (5), <CODE>kFormat</CODE> (6), <CODE>kTrackCache</CODE> (9), and <CODE>kDriveIcon</CODE> (21) Control requests.</li>      <LI><CITE>Inside Macintosh IV</CITE>, "The SCSI Manager",   page 292 through 293 describes the original partitioning   format used on the Mac Plus and goes on to say, "Since the   driver is called to install itself, it must contain code   to set up its own entry in the unit table and to call its   own Open routine. An example of how to do this can be   obtained from Developer Technical Support." This example   was part of the "SCSI Driver Developer Kit". All of the   information in the kit is available elsewhere. The   specific sample code referenced by the book evolved into   <A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Devices_and_Hardware/SCSI/SCSI_Driver_Example.sit">SCSI   Driver Example</A>.</li>     <LI><CITE>Inside Macintosh   V</CITE>, "The Disk Driver",   page 470 through 471, documents the <CODE>kDriveIcon</CODE> (21), <CODE>kMediaIcon</CODE> (22), and <CODE>kDriveInfo</CODE> (23) Control requests.</li>      <LI>Technote DV 2,    <a href="../dv/dv_02.html">"_AddDrive,   _DrvrInstall, and _DrvrRemove"</A> documented the   <CODE>AddDrive</CODE>, <CODE>DriverInstall</CODE>, and   <CODE>DriverRemove</CODE> system routines. This technote   is now obsolete. <CODE>AddDrive</CODE> is documented in   <a href="http://developer.apple.com/documentation/mac/Files/Files-295.html">Inside   Macintosh: Files</A>, and <CODE>DriverInstall</CODE>, and   <CODE>DriverRemove</CODE> are covered by   <a href="http://developer.apple.com/documentation/mac/Devices/Devices-42.html">Inside   Macintosh: Devices</A>, along with   <CODE>DriverInstallReserveMem</CODE>. Moreover,   developers of 68K drivers should use   <A HREF = "#TradDriverLoaderLib">TradDriverLoaderLib</A> to   install their drivers.</li>      <LI>Technote DV 12,    <a href="../dv/dv_12.html">"Our   Checksum Bounced"</A> documents a misfeature of the code   used by the ROM to checksum disk drivers. The technote is   now obsolete. The ROM checksum behavior is described in   <a href="http://developer.apple.com/documentation/mac/Devices/Devices-126.html">Inside   Macintosh: Devices</A> and this technote describes the   <A HREF = "#DriverChecksums">checksum algorithm</A> itself.</li>      <LI>Technote DV 13,    <a href="../dv/dv_13.html">"_PBClose   the Barn Door"</A> still contains valid advice for general   device driver writers, although this technote deals with   this topic as it <A HREF = "#CloseAndPurge">applies to disk   drivers</A>.</li>      <LI>Technote DV 18,    <a href="../dv/dv_18.html">"CD-ROM   Notes (Most Excellent)"</A> contains some interesting   historical information about CD-ROM devices, although   much of the information is now obsolete or covered   elsewhere.</li>      <LI><a href="http://developer.apple.com/documentation/hardware/Developer_Notes/Macintosh_CPUs-PPC_Desktop/PPC_9500.pdf">Power   Macintosh 9500 Computers</A> (hardware developer note)   describes many aspects of the large volume support   (greater than 4 GB support) introduced with that machine.   The large volume support aspects of that developer note   are now obsolete. This technote discusses   <A HREF = "#LargeVolumeSupport">large volume support</A> as   it applies to disk drivers. DTS Q&amp;As FL   <a href="../../qa/fl/fl07.html">07</A>   and FL   <a href="../../qa/fl/fl08.html">08</A>   discuss large volume support from the application   perspective.</li>      <LI>The following documents were never released   generally. Their developer-oriented content has been   rolled into this technote.      <UL><LI>"Chainable Drivers and Patches"</li><LI>"Ruby Slipper Lite ERS" (large volume support)</li><LI>"Bootable CD Developer Kit (Software DeveloperNote)"</li><LI>"PC Exchange and Large Volume Drivers"</li>   </UL></li></UL><H3><A NAME="ChecklistForDiskDriversWriters"></A>Checklistfor Disk Driver Writers</H3><P>All of the above is probably overwhelming, so here is asummary of the most important steps to take to improve thereliability and compatibility of your disk driver:</P><UL>   <LI>If you do nothing else, you should support   <A HREF = "#DriverGestalt">Driver Gestalt</A>.</li>      <LI>You should support the partition map entry features   documented in <A HREF = "#SecretsOfThePartitionMap">Secrets   of the Partition Map</A>. Specifically, you should ensure   that your driver is checksummed, supports booting from a   partition, and write your driver signature to the   <CODE>pmPad</CODE> field.</li>      <LI>Your driver should support   <A HREF = "#LargeVolumeSupport">large volumes</A>,   including booting from large volumes on machines without   large volume support in the ROM by means of the   <CODE><A HREF = "#ruby">'ruby'</A></CODE> patch.</li>      <LI>You should follow the rules when   <A HREF = "#InstallingAndRemovingDriversAndDrives">installing   and removing your driver and its drive queue   elements</A>. You should also support   <A HREF = "#CloseAndPurge">close</A> to allow other   developers to remove your driver cleanly.</li>      <LI><A NAME="ManagerRegistration"></A>If your driver uses   SCSI Manager 4.3 or ATA Manager, it must register itself   with the manager. The documentation for each manager   describes how this is done. If you're using SCSI Manager   4.3, use   <CODE><a href="http://developer.apple.com/documentation/mac/Devices/Devices-184.html">SCSICreateRefNumXref</A></CODE>.   If you're using ATA Manager, use   <CODE><a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.34.html">kATAMgrDriveRegister</A></CODE>.</li>      <LI>You should support the <A HREF = "#FileExchange">File   Exchange interface</A>. This will allow foreign file   systems to access your disks without any skullduggery.</li>      <LI>You should check that your   <A HREF = "#PrivateControlAndStatusRequests">private   Control and Status requests follow the rules</A>, both   with respect to Driver Gestalt and virtual memory. This   is harder than you might think.</li>      <LI>You should support   <A HREF = "#ReadVerifyMode">read-verify mode</A>. This   technote explains how to do it easily.</li>      <LI>You may want to support   <A HREF = "#TargetMode">target   mode</A> in your ATA   driver.</li>      <LI>You may want to support <A HREF = "#colorIcons">color   icons</A>. Woo hoo!</li></UL><H3><A NAME="ForApplicationWriters"></A>For ApplicationWriters</H3><P>The purpose of a disk driver is to support a genericinterface for accessing block devices. The primary client ofthis interface is the File Manager, although it can be usedby other programs. If you're writing a foreign file system,or just an application that needs something beyond thestandard File Manager programming interface, parts of thistechnote may be of interest to you.</P><UL>   <LI>If you need to interrogate a driver about its   capabilities, you should read the section   <A HREF = "#DriverGestaltForApplications">Driver Gestalt   for Applications</A>.</li>      <LI>If you need to read arbitrary blocks on a volume, you   should read the discussion of the   <A HREF = "#XIOForApps">XIOParam block for   applications</A>, along with the accompanying   <A HREF = "#NotesForDevelopersCallingDiskDrivers">hints and   tips</A>.</li>      <LI>If you need to read arbitrary blocks outside of a   volume -- for example, the partition map, or a non-Mac OS   partition -- you should investigate the   <A HREF = "#FileExchange">File Exchange</A> section of this   technote, especially the section on using the   <A HREF = "#UsingFileExchangeCalls">File Exchange   interface</A>.</li>      <LI>If you need to verify that you have written data to   the disk correctly, you should check out the   <A HREF = "#ReadVerifyMode">read-verify mode</A> section   which describes the easiest way to do this. [Hint: Think   "MoreFiles"!]</li>      <LI>If you need to get color icons for a drive, you can   now <A HREF = "#colorIcons">call the disk driver to get   them</A> -- although you should probably just call   <a href="http://developer.apple.com/documentation/macos8/HumanInterfaceToolbox/IconServUtili/iconservicesandutilities.html">Icon   Services</A> instead.</li></UL><P>In addition, if you're writing a disk formatting utility,this technote contain invaluable information on the<A HREF = "#SecretsOfThePartitionMap">partition map</A>,<A HREF = "#ChainingDriversAndPatchPartitions">chainingdrivers, patch partitions</A>, and<A HREF = "#CloseAndPurge">"hostile" takeovers</A>.</p>          <BR><P><A HREF="#top">Back to top</A></P><A NAME="DiskDriverBasics"></A><H2>Disk Driver Basics</H2><P>Mac OS communicates with attached devices through<STRONG>device drivers</STRONG>, which are software plug-insthat conform to a well-defined structure. The Device Manageris the original system component used to install, find,manage, and communicate with device drivers. It exportsroutines that can be called by higher level system software,and by applications. Most of these routines translatedirectly into requests to the underlying device driver.</P><P>In order to identify different drivers, the DeviceManager assigns each installed driver a unique negativenumber, referred to as a <STRONG>driver referencenumber</STRONG>. When calling the Device Manager, clientspass a driver reference number to tell it which driver theyare dealing with.</P><P>For a block device to be available to the system, it musthave a <STRONG>disk driver</STRONG>. This is either in theROM (for the built-in floppy drive), or loaded at systemstartup from a special partition on the disk (SCSI, ATA, andFireWire devices), or loaded from a system extension (USBand FireWire devices). In addition, a disk driver can beloaded when a device is plugged in by either an I/O familyexpert (ATA, USB, and FireWire), or by a special utilityprogram (SCSI). Finally, software can install a disk driverfor a virtual block device which has no obvious physicalpresence, such as a RAM disk or disk image. Regardless ofhow they are installed, alldisk drivers roughly follow the same rules.</P><P>It is important to note the difference between a disk anda device. A <STRONG>blockdevice</STRONG> is the entity which reads and writesdata on a disk. A <STRONG>disk</STRONG> is the medium whichactually stores the data. This distinction is unimportantfor fixed disk devices (such as hard disks), but is criticalfor removable disk devices (such as floppy drives andremovable cartridge disk devices).</P><P>Mac OS always directs block I/O to a software entityknown as a <STRONG>drive</STRONG>. Each disk driver createsone or more drives and puts them in a system structure called the <STRONG>drivequeue</STRONG>. Each <STRONG>drive queue element</STRONG>represents a drive, andcontains both the driver reference number and the drivenumber. The <STRONG>drive number</STRONG> is a positivenumber that uniquely identifies the drive; it is assignedwhen the drive is added to the drive queue.</P><P>A drive does not necessarily correspond directly to agiven physical device. Rather, the driver decides whichdrives to create for the device it controls. In some cases,there is one drive per physical device. For example, thebuilt-in floppy disk driver creates a drive for eachattached floppy disk device. However, it is also common fora driver to create multiple drives for a single device. Forexample, the driver for a partitioned hard disk devicecreates a drive for each file system partition on the disk.</P><P>When the system performs I/O to a drive, it supplies the driverreference number of the device driver and the drive numberof a drive created by that driver. The Device Manager usesthe driver reference number to find the device driver andcall its entry point. The device driver then uses the drivenumber to determine which drive is the target of the I/Orequest.</P><P>All drive I/O is done is terms of 512-byte logicalblocks. Therefore, all transfers must start at multiple of512 bytes and be a multiple of 512 bytes long. This isregardless of the underlying device's block size.</P><H3>File Manager and Drives</H3><P>To allow the flexibility of storage required by the userinterface (a hierarchy of folders and files), Mac OS implements anotherlayer of abstraction, known as the File Manager, on top of the Device Managerand the drive queue.</P><P>A <STRONG>filesystem</STRONG> is a mechanism for storingfine-grained data (files) and meta-data (folders, Findersattributes, and so on) on a drive. The file system definesthe way this data is stored and the rules for manipulatingit. The File Manager includes built-in support for two filesystems (HFS and HFS Plus) and a plug-in architecture (FileSystem Manager) for others (AppleShare, DOS FAT, ProDOS ,UDF, and third-party FSM plug-ins).</P><P>The File Manager exports a programming interface definedin terms of volumes, whichcontain directories, files, and meta-data. A<STRONG>volume</STRONG> is an instance of a file system on adrive. Each volume is uniquely identified by a negative<STRONG>volume reference number</STRONG>, which is stored,along with other data to operate the volume, in a<STRONG>volume control block</STRONG> (VCB) that is linkedinto the system <STRONG>VCB queue</STRONG>. The VCB alsocontains the drive number and the driver reference number ofthe drive on which the volume is mounted.</P><P>The process of making the contents of a drive availablevia the File Manager is called <STRONG>mounting</STRONG> avolume. When the File Manager attempts to mount a volume ona drive, it calls each of the file systems in turn to determine which oneunderstands the logical format of the data on the disk in the drive. It thencreates a VCB for that file system on that drive.</P><P>The File Manager takes requests to operate on the volumeand passes them to the appropriate plug-in file system,which reduces them to basic block operations and passes themto the drive via the Device Manager (using the drive numberand driver reference number stored in the VCB). As far asthe file system is concerned, the drive is its own logicaldisk, even though it may only represent a small part of the realdisk.</P><P>A drive can exist without having a volume mounted on it.This happens, for example, if the data format on the driveis incomprehensible to the installed file systems, or thevolume on the drive has been unmounted. You can still access the data on adrive that has no volume mounted on it, but only via theDevice Manager interface.</P><H3>Terminology</H3><P>In any technical document, it is very important to getyour terminology straight. This is especially important whentalking about disk drivers, where much of the terminologyhas been extended over the long, confusing history of theMac OS block storage architecture. This technote uses the following termsthroughout.</P><DL>   <DT><STRONG>disk driver</STRONG></dt>      <DD><P>A software plug-in that implements a hardware   abstraction layer for block devices, like hard disks,   floppy drives, and CD-ROM drives. In Mac OS, a disk   driver must be a Device Manager driver (either a 68K   driver or a native driver).</p></dd>      <DT><STRONG>68K driver</STRONG></dt>      <DD><P>A disk driver implemented using the traditional 68K   driver architecture, as documented in   <a href="http://developer.apple.com/documentation/mac/Devices/Devices-2.html">Inside   Macintosh: Devices</A>. A 68K driver is commonly stored   in a resource of type <CODE>'DRVR'</CODE> or in a driver partition.</p></dd>      <DT><STRONG>native driver</STRONG></dt>      <DD><P>A disk driver implemented using the native   driver model, introduced   with the first generation of PCI Power Macintosh   computers and documented in   <A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">Designing   PCI Cards and Drivers for Power Macintosh Computers</A>.   A native driver is commonly stored in a file of type   <CODE>'ndrv'</CODE>, although native drivers have started   appearing in driver partitions as well.</p></dd>      <DT><STRONG>driver reference number</STRONG></dt>      <DD><P>An <CODE>SInt16</CODE> that uniquely identifies a   Device Manager driver to the system. Driver reference   numbers are not persistent -- they are assigned when the   driver is added to the unit table -- but some driver   reference numbers are assigned to certain well-known   drivers. Driver reference numbers occupy the same "name   space" as file reference numbers (which identify an open   file). Driver reference numbers are always negative,   while file reference numbers are always positive. Zero is   an invalid driver reference number and an invalid file   reference number.</p></dd>      <DT><STRONG>unit table</STRONG></dt>      <DD><P>A Device Manager data structure   that lists the installed device drivers (both 68K and   native).</p></dd>      <DT><STRONG>block device</STRONG></dt>      <DD><P>A block-oriented storage device.</p></dd>      <DT><STRONG>real block device</STRONG></dt>      <DD><P>A block device that has some obvious physical   presence, such as a floppy drive or a SCSI hard disk   device.</p></dd>      <DT><STRONG>virtual block device</STRONG></dt>      <DD><P>A block device this has no obvious physical presence,   such as a RAM disk, a disk image, or a network block   device.</p></dd>      <DT><STRONG>device</STRONG></dt>      <DD><P>Some hardware attached to the computer. In this   context of this technote, this typically means a block   device although, in some   places, the term may be used for any type of   device.</p></dd>      <DT><STRONG>disk</STRONG></dt>      <DD><P>The actual physical media which holds data. A disk is   made up of blocks, each of which holds a fixed number of   bytes (typically 512). A disk is distinct from a block   device because, in the case of removable disk devices,   the user can insert one of many different disks into the   device.</p></dd>      <DT><STRONG>disc</STRONG></dt>      <DD><P>A synonym for "disk" that is only used in the context   of CD or DVD discs (where the disk is actually a disc).</p></dd>      <DT><STRONG>media</STRONG></dt>      <DD><P>See disk.</p></dd>      <DT><STRONG>drive</STRONG></dt>      <DD><P>A Mac OS software construct used to represent a block   storage entity. A volume is always mounted on a drive.   There may be multiple drives corresponding to a single   disk. Exception: some removable disk devices have been   historically known as drives (for example, floppy drive,   CD-ROM drive). This technote continues to use "drive" in   these contexts, rather than the more cumbersome "floppy   disk device." However, if the word "drive" appears   unqualified, it always refers to the primary definition.</p></dd>      <DT><STRONG>drive queue</STRONG></dt>      <DD><P>A OS queue which contains all the drive queue   elements known to the system. You can get the head of the   drive queue using the routine <CODE>GetDrvQHdr</CODE>.   See   <a href="http://developer.apple.com/documentation/mac/Files/Files-2.html">Inside   Macintosh: Files</A> for more details of the   <a href="http://developer.apple.com/documentation/mac/Files/Files-112.html">drive   queue</A> and its elements.</p></dd>      <DT><STRONG>drive queue element</STRONG></dt>      <DD><P>The specific data structure used to represent a   drive. A drive queue element is a structure of type   <CODE>DrvQEl</CODE> allocated in the system heap and   placed in the drive queue.</p></dd>      <DT><STRONG>drive number</STRONG></dt>      <DD><P>An <CODE>SInt16</CODE> which uniquely identifies a   drive. Drive numbers are not persistent; they are   assigned when the drive is added to the drive queue.   Drive numbers occupy the same "name space" as volume   reference numbers. Drive numbers are always positive,   while volume reference numbers are always negative.</p></dd>      <DT><STRONG>partition</STRONG></dt>      <DD><P>A disk may be divided into a set of contiguous   blocks, each known as a partition. Partitions are   typically either file system partitions (which hold file   system data) or meta-data partitions (which hold   information about the disk, such as the partition map or   the disk's device driver). Not all disks are partitioned,   although a disk must be partitioned to support booting   (except for floppy disks, because the driver for the   built-in floppy disk drive is in the ROM).</p></dd>      <DT><STRONG>partition map</STRONG></dt>      <DD><P>A data structure, typically at the beginning of the   disk, which describes the partitions on the disk. Most   Mac OS disks are partitioned using the Apple partition   map format, described in   <A HREF = "#SecretsOfThePartitionMap">Secrets of the   Partition Map</A>.</p></dd>      <DT><STRONG>partition map entry</STRONG></dt>      <DD><P>The Apple partition map describes each partition on   the disk using a partition map entry data structure (of   type <CODE>Partition</CODE>).</p></dd>      <DT><STRONG>startup partition</STRONG></dt>      <DD><P>The partition which the user has designated as the   one from which they prefer to boot the system, or the   partition from which the system booted.</p></dd>      <DT><STRONG>driver partition</STRONG></dt>      <DD><P>A partition which contains a disk driver.</p></dd>      <DT><STRONG>file system partition</STRONG></dt>      <DD><P>A partition which contains file   system data.</p></dd>      <DT><STRONG>meta-data partition</STRONG></dt>      <DD><P>A partition which holds information about the disk,   such as the partition map or the disk's device driver.</p></dd>      <DT><STRONG>partition-based driver</STRONG></dt>      <DD><P>A driver that is loaded from a partition.</p></dd>      <DT><STRONG>file system-based driver</STRONG></dt>      <DD><P>A driver that is loaded from a file in the file   system, typically in the Extensions folder.</p></dd>      <DT><STRONG>disk-based driver</STRONG></dt>      <DD><P>Either a partition-based driver or a file   system-based driver. This term is ambiguous and to be   avoided.</p></dd>      <DT><STRONG>ghost partitioning</STRONG></dt>      <DD><P>A system used on non-512 byte block devices where   partition map entries appear at both 512-byte boundaries   and device block boundaries so that they can be seen by   software using either physical or device blocks.</p></dd>      <DT><STRONG>I/O family</STRONG></dt>      <DD><P>A component of the Mac OS I/O subsystem that is   responsible for a particular category of devices. A   driver can work within multiple I/O families. Each family   requires certain attributes of the driver (for example,   how it is packaged and the programming interface it   provides to upper layer software) and provides services   for the driver. For example, a FireWire disk driver must   be packaged as a native driver which responds to the   standard disk driver programming interface, and FireWire   provides services to the disk driver, such as SBP-2   utility routines.</p></dd>      <DT><STRONG>I/O family expert</STRONG></dt>      <DD><P>A component of an I/O family   that seeks out devices of a particular type and registers   them with the I/O family.</p></dd>      <DT><STRONG>volume</STRONG></dt>      <DD><P>A File Manager software construct that represents a   single, user-visible storage device. Each volume appears   as a icon on the desktop. Each   volume is mounted on a drive, so if the disk has multiple   file system partitions it will also have multiple drives   and hence multiple volumes.</p></dd>      <DT><STRONG>volume reference number</STRONG></dt>      <DD><P>An <CODE>SInt16</CODE> which uniquely identifies a   volume. Volume reference numbers are not persistent; they   are assigned when the volume is mounted. Volume reference   numbers occupy the same 'name space' as drive numbers.   Drive numbers are always positive, while volume reference   numbers are always negative.</p></dd>      <DT><STRONG>refNum</STRONG></dt>      <DD><P>This contraction of "reference number" is ambiguous   and is not used in this document. In other documents, it   commonly means either a driver reference number or a file   reference number, depending on context.</p></dd>      <DT><STRONG>vRefNum</STRONG></dt>      <DD><P>A contraction of volume reference number.</p></dd>      <DT><STRONG>logical blocks</STRONG></dt>      <DD><P>The block numbering scheme used to access blocks on a   drive. Each logical block contains 512 bytes and the   first block accessible through the drive is block 0. See   <A HREF = "#BlockTranslation">Block Translation</A> for   details.</p></dd>      <DT><STRONG>physical blocks</STRONG></dt>      <DD><P>The block numbering scheme used to access blocks on a   disk. You can derive a physical block number from a   logical block number by adding to   it the start block number of the partition. If the   disk is not partitioned, logical blocks and physical   blocks are identical. Each physical block contains 512   bytes. See <A HREF = "#BlockTranslation">Block   Translation</A> for details.</p></dd>      <DT><STRONG>device blocks</STRONG></dt>      <DD><P>The actual block numbering scheme used by the device   hardware to access data on the disk. Device blocks are   not necessarily 512 bytes big, and the device driver is   responsible for blocking and deblocking to present the   illusion of 512-byte physical blocks to the system. See   <A HREF = "#BlockTranslation">Block Translation</A> for   details.</p></dd>      <DT><STRONG>blocks</STRONG></dt>      <DD><P>When used without qualification in this technote, blocks means   logical blocks.</p></dd>      <DT><STRONG>sectors</STRONG></dt>      <DD><P>Depending on context, this can   either mean device blocks (for a floppy drive), physical   blocks (for a hard disk device), or logical blocks (in a   volume format specification). To avoid confusion, this   technote avoids the term "sector" in favor of its more   specific synonyms.</p></dd>      <DT><STRONG>chaining driver</STRONG></dt>      <DD><P>A driver loaded from a partition which performs some   action and then loads the next driver in the driver   chain. The most common chaining driver is Apple's patch   driver.</p></dd>      <DT><STRONG>driver chain</STRONG></dt>      <DD><P>A sequence of drivers, each in its own driver   partition, that can all be loaded for a particular   expansion bus type (for example,   SCSI or ATA). Each driver chain consists of one or   more chaining drivers and a real driver for the disk. A   disk may contain more than one driver chain if it can be accessed through more   than one expansion bus type.</p></dd>      <DT><STRONG>patch driver</STRONG></dt>      <DD><P>A chaining driver which applies the patches from a   patch partition and then chains to the next driver.</p></dd>      <DT><STRONG>patch partition</STRONG></dt>      <DD><P>A meta-data partition containing patches that must be   applied to the system before it can boot. The patches in   the patch partition are applied by the patch driver   before it chains to the real disk driver.</p></dd>      <DT><STRONG>target mode</STRONG></dt>      <DD><P>PowerBook computers can be placed in target mode,   where the PowerBook's internal hard disk device is   accessible as a hard disk device to other computers on   an expansion bus (typically   SCSI).</p></dd>      <DT><STRONG>SCSI disk mode</STRONG></dt>      <DD><P>See target mode.</p></dd>      <DT><STRONG>request</STRONG></dt>      <DD><P>When the Device Manager calls a driver entry point   (Open, Close, Prime, Control, or Status for a 68K driver,   <CODE>DoDriverIO</CODE> for native drivers), it passes   the address of a parameter block which describes the   requested operation. This is known as a request. A   request is different from a simple function call in that   the driver may return from this initial call without   completing the request. Specifically, for queued   requests, the request is not complete until the driver   explicitly tells the system so (by calling   <CODE>IODone</CODE> for 68K drivers, or by calling   <CODE>IOCommandIsComplete</CODE> for native drivers).</p></dd>      <DT><STRONG>queued request</STRONG></dt>      <DD><P>Synchronous and asynchronous requests are   collectively known as queued requests. This is because   they are queued in the driver's queue (on the   <CODE>dCtlQHdr</CODE>) and the driver is marked as busy   while the request is being processed.</p></dd>      <DT><STRONG>immediate request</STRONG></dt>      <DD><P>Immediate requests are distinct from queued requests   in that they are not placed   in the driver's queue and do not mark the driver as busy.</p></dd></DL><BR><P><A HREF="#top">Back to top</A></P><A NAME="DriverGestalt"></A><H2>Driver Gestalt</H2><P>All disk drivers should support Driver Gestalt. DriverGestalt is a mechanism whereby the system can query yourdriver to determine whether it supports advanced driverfeatures. In many ways it is similar to the Mac OS GestaltManager, except that the system is querying your driver, notthe other way around.</P><P>Your driver should support DriverGestalt. If you don't support Driver Gestalt, thesystem is in the dark as to which advanced driver featuresyour driver supports.</P><H3>Driver Gestalt Reference</H3><P>The basic reference for Driver Gestalt is<A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">DesigningPCI Cards and Drivers for Power Macintosh Computers</A>,specifically the "Driver Gestalt" section starting on page106. However, Driver Gestalt is useful even on non-PCIcomputers. Your driver must support Driver Gestaltregardless of what computer or OS version it is running on.</P><P><A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">DesigningPCI Cards and Drivers for Power Macintosh Computers</A> doesnot document all of the selectors associated with DriverGestalt. The only official, up-to-date list of DriverGestalt selectors is the "DriverGestalt.h" header file,provided as part of Universal Interfaces. When Apple definesa new Driver Gestalt selector, we add the selector to"DriverGestalt.h", along with comments that describe how toimplement it.</P><P>In the event of a conflict between the writtendocumentation and "DriverGestalt.h", "DriverGestalt.h" iscorrect and the written documentation is wrong. For example,<A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">DesigningPCI Cards and Drivers for Power Macintosh Computers</A>describes the response of the <CODE>'purg'</CODE> selectoras a <CODE>Boolean</CODE> (page 111), whereas"DriverGestalt.h" correctly describes the response to be oftype <CODE>DriverGestaltPurgeResponse</CODE>.</P><H3>Driver Gestalt Guarantees</H3><P>By saying that it supports Driver Gestalt, your driverguarantees certain things to the system, including:</P><OL>   <LI>Your driver will return <CODE>controlErr</CODE> in   response to a Control request with an unrecognized   <CODE>csCode</CODE>.</li>      <LI>Your driver will return <CODE>statusErr</CODE> in   response to a Status request with an unrecognized   <CODE>csCode</CODE>.</li>      <LI>Your driver will return <CODE>controlErr</CODE> in   response to a Driver Configure request with an   unrecognized selector.</li>      <LI>Your driver will return <CODE>statusErr</CODE> in   response to a Driver Gestalt request with an unrecognized   selector.</li>      <LI>Your driver will not use any <CODE>csCode</CODE>s   below 128 for private Control or Status requests.</li></OL><P>Items 3 and 4 in the list above are not documentedclearly in<A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">DesigningPCI Cards and Drivers for Power Macintosh Computers</A>,although they are implemented by all Apple drivers and areclearly shown in the various Driver Gestalt samples. Thistechnote serves to officially document these two additionalrequirements.</P><H3><A NAME="DriverGestaltForApplications"></A>DriverGestalt for Applications</H3><P>Probably the best way to understand how to issue DriverGestalt queries from an application is to look at somesample code. "Driver Gestalt Demo" is a simple sample thatshows how to issue a few queries. "DriverGestaltExplorer" isa more comprehensive sample, which is also useful as asimple test and investigation tool. Both samples areavailable as DTS<A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Devices_and_Hardware/Disks/">samplecode</A>.</P><H3>Summary of Driver Gestalt</H3><P><STRONG>All disk drivers should support DriverGestalt.</strong></p><BR><P><A HREF="#top">Back to top</A></P><A NAME="SecretsOfThePartitionMap"></A><H2>Secrets of the Partition Map</H2><P>A number of features have been added to the Apple partition map since it wasdocumented in<a href="http://developer.apple.com/documentation/mac/Devices/Devices-121.html#HEADING121-37">InsideMacintosh: Devices</A>. This section describes thosefeatures in detail.</P><H3>Partition Field Relevance</H3><P>The description of the<CODE><a href="http://developer.apple.com/documentation/mac/Devices/Devices-126.html#MARKER-14-92">Partition</A></CODE>data type in<a href="http://developer.apple.com/documentation/mac/Devices/Devices-2.html">InsideMacintosh: Devices</A> does not explicitly call out thatsome fields of the data structure are only relevant fordriver partitions (those whose partition name contains"Apple" and "Driver"). Specifically, the fields from<CODE>pmLgBootStart</CODE> through to<CODE>pmProcessor</CODE> are only relevant for driverpartitions. Non-driver partitions should set these fields tozero.</P><H3>pmParType Possibilities</H3><P><a href="http://developer.apple.com/documentation/mac/Devices/Devices-121.html#HEADING121-37">InsideMacintosh: Devices</A> documents the<a href="http://developer.apple.com/documentation/mac/Devices/Devices-126.html">wellknown values</A> for the <CODE>pmParType</CODE> field of thepartition map entry, namely "Apple_partition_map","Apple_Driver", "Apple_Driver43", "Apple_MFS", "Apple_HFS","Apple_Unix_SVR2", "Apple_PRODOS", "Apple_Free", and"Apple_Scratch". This technote describes a number ofadditional partition types.</P><UL>   <LI>"Apple_Driver_ATA" -- Holds the device driver for an   ATA device.</li>      <LI>"Apple_Driver_ATAPI" -- Holds the device driver for   an ATAPI device. When it discovers a device on an ATA bus, the ATA   Manager identifies whether a device is ATA or ATAPI and   automatically loads the corresponding driver.</li>      <LI>"Apple_Driver43_CD" -- A SCSI CD-ROM driver suitable   for booting.</li>      <LI>"Apple_FWDriver" -- Holds a FireWire driver for the   device. See <A HREF = "#LoadingFireWireDrivers">Loading   FireWire Drivers</A> for details.</li>      <LI>"Apple_Void" -- A dummy partition map entry, used to   pad out a partition map to ensure the correct alignment   of partition map entries in a   <A HREF = "#BootingFromCDROM">bootable CD-ROM</A>.</li>      <LI>"Apple_Patches" -- Holds a patch partition. The patch   partition architecture is described in   <A HREF = "#ChainingDriversAndPatchPartitions">Chaining   Drivers and Patch Partitions</A>.</li></UL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Apple reserves all partition types beginningwith "Apple". Apple expects to add a number of newpartition types in the near future, and yoursoftware should handle these new, reserved partitiontypes cleanly.</p></TD></TR></TABLE></CENTER><BR><BR><A NAME="pmPartStatusRevealed"></A><H3>pmPartStatus Revealed</H3><P><a href="http://developer.apple.com/documentation/mac/Devices/Devices-121.html#HEADING121-37">InsideMacintosh: Devices</A> says that the<CODE>pmPartStatus</CODE> field of the<CODE>Partition</CODE> data structure is only used by A/UX,bits 0 through 7 having a defined meaning and all othersbeing reserved. This is no longer true.</P><P>The following flags are defined in<CODE>pmPartStatus</CODE> field of the<CODE>Partition</CODE> structure. Allbits not defined here are reserved (you should initializethem to 0 and ignore their value).</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kPartitionAUXIsValid= 0x00000001,    kPartitionAUXIsAllocated  = 0x00000002,    kPartitionAUXIsInUse= 0x00000004,    kPartitionAUXIsBootValid  = 0x00000008,    kPartitionAUXIsReadable   = 0x00000010,    kPartitionAUXIsWriteable  = 0x00000020,    kPartitionAUXIsBootCodePositionIndependent  = 0x00000040,&nbsp;    kPartitionIsWriteable     = 0x00000020,    kPartitionIsMountedAtStartup = 0x40000000,    kPartitionIsStartup = 0x80000000,&nbsp;    kPartitionIsChainCompatible  = 0x00000100,    kPartitionIsRealDeviceDriver = 0x00000200,    kPartitionCanChainToNext  = 0x00000400,};</pre></TD></TR></TABLE></CENTER><BR><BR>     <P>Bits 0 through 4 and 6 are still defined as documented in<a href="http://developer.apple.com/documentation/mac/Devices/Devices-126.html">InsideMacintosh: Devices</A>. A Mac OS formatting utility shouldalways set these bit to 1 for file system partitions andclear them for other partition types.</P><P>The second group of bits is used by Apple Mac OS diskdrivers to hold information about file system partitions.</P><DL>   <DT><CODE>kPartitionIsWriteable</CODE></dt>      <DD><P>This bit indicates whether the partition is writeable   (1) or write-protected (0). If the bit is clear and your   driver creates a drive queue element to represent this   partition, it should mark the drive queue element as   write-protected. Note that mask has the same value (and   the same semantics) as   <CODE>kPartitionAUXIsWriteable</CODE>.</p></dd>      <DT><CODE>kPartitionIsMountedAtStartup</CODE></dt>      <DD><P>This bit indicates whether the partition is mounted   at system startup (1) or not (0). If your driver would   otherwise create a drive queue element to represent this   partition at system startup and this bit is clear, it   should not create the drive.</p></dd>      <DT><CODE>kPartitionIsStartup</CODE></dt>      <DD><P>This bit indicates whether this is the startup   partition (1) or not (0). This bit must be set for at   most one partition. See   <A HREF = "#BootingFromAPartition">A Partition of Your   Imagination</A> below.</p></dd></DL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Some third-party disk drivers reverse the senseof the <CODE>kPartitionIsMountedAtStartup</CODE>bit of <CODE>pmPartStatus</CODE>. This is a bug.Unfortunately, we cannot retroactively fix that bugon all installed disks, so it is not possible tolook at this flag and determine whether thepartition will be mounted. The most reliable way towork out whether a partition will be mounted atstartup is by using the<A HREF = "#PartitionAttributes">partitionattribute</A> Control and Status requests.</p>    </TD></TR></TABLE></CENTER><BR><BR><P>The third group of bits provides information about driverpartitions. You may need to read<A HREF = "#ChainingDriversAndPatchPartitions">ChainingDrivers and Patch Partitions</A> to understand thesedescriptions.</P><DL>   <DT><CODE>kPartitionIsChainCompatible</CODE></dt>      <DD><P>The driver in this partition supports being loaded by   a chaining driver.</p></dd>      <DT><CODE>kPartitionIsRealDeviceDriver</CODE></dt>      <DD><P>This partition contains a driver that actually knows   how to drive the device. Contrast this with the patch   driver, which is chain compatible, but which can only load   patches and then chain to the next driver; it does not   actually contain a disk driver.</p></dd>      <DT><CODE>kPartitionCanChainToNext</CODE></dt>      <DD><P>This partition contains a driver that can chain to   another driver. Typically, all drivers in the chain must   have this bit set, except the last one where it is clear.</p></dd></DL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Some Apple and most third-party drivers do nothave the chaining flags set correctly, so it isvirtually impossible for your software to rely ontheir semantics.</p></TD></TR></TABLE></CENTER><BR><BR><H3><A NAME="PartitionAttributes"></A>Partition Attributes</H3><P>There are a number of Control and Status requests thatmodify the attributes of a partition. A disk driver mustsupport these requests as described below. A formattingapplication can use these requests to modify partitionattributes.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Many of these Control and Status requests werepreviously documented in<A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">DesigningPCI Cards and Drivers for Power MacintoshComputers</A>, page 113 through 114, and<a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.1.html">ATADevice Software for Macintosh Computers</A>. Thedescription herein replaces both of thesedocuments. The old documents fail to describe the<CODE>DeviceIdent</CODE> parameter to theseroutines, nor do they clarify that<CODE>csParam[0..1]</CODE> is a partition map entryaddress.</p></TD></TR></TABLE></CENTER><BR><BR><H4><A NAME="kSetStartupPartition"></A>Setting the StartupPartition</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kSetStartupPartition</CODE> (44)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the new startup partition,or 0 if you wish to specify the startup partitionby block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry ofthe new startup partition. If<CODE>ioVRefNum</CODE> is not 0, this is ignored.</p></TD></TR><TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thedevice containing the new startup partition. Thisis in the same format as the <CODE>SCSIID</CODE>field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must setthe partition described by <CODE>ioVRefNum</CODE> and<CODE>csParam[0..3]</CODE> as the startup partition.Typically this involves setting<CODE>kPartitionIsStartup</CODE> in<CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>,which in turn causes your disk driver to place the drivequeue element for this partition first in the drive queue atsystem startup.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>When your driver sets the<CODE>kPartitionIsStartup</CODE> bit for onepartition, it must clear it for all otherpartitions. This bit must be set for at most onepartition.</p></TD></TR></TABLE></CENTER><BR><BR><H4>Determining Whether a Partition is the Startup Partition</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Status</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kGetStartupStatus</CODE> (44)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the partition to query, or 0if you wish to query the partition by block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry ofthe partition to query. If <CODE>ioVRefNum</CODE>is not 0, this is ignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>DeviceIdent</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this isidentifies the device containing the partition toquery. This is in the same format as the<CODE>SCSIID</CODE> field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0]</CODE></p></TD><td width=100 align=left><P><CODE>UInt16</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>Your disk driver must set this to either 0 (thisis not the startup partition) or 1 (this is thestartup partition).</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must set<CODE>csParam[0]</CODE> toindicate whether the partition described by<CODE>ioVRefNum</CODE> and <CODE>csParam[0..3]</CODE> is thestartup partition. Typically this involves testing<CODE>kPartitionIsStartup</CODE> in<CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>.</P><P>The request returns the status that is currently recordedin the partition map, not whether the system actuallystarted from this partition.</P><H4>Specifying That a Partition Should Be Mounted at Startup</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kSetStartupMount</CODE> (45)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the partition, or 0 if youwish to specify the partition by block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry ofthe partition. If <CODE>ioVRefNum</CODE> is not 0,this is ignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>DeviceIdent</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thedevice containing the partition. This is in thesame format as the <CODE>SCSIID</CODE> field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must setthe partition described by <CODE>ioVRefNum</CODE> and<CODE>csParam[0..3]</CODE> to be mounted at startup.Typically this involves setting<CODE>kPartitionIsMountedAtStartup</CODE> in<CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>,which in turn causes your disk driver to place a drive queueelement for this partition in the drive queue at systemstartup.</P><P>This request modifies the partition map, and hence onlytakes effect the next time the system is started. It doesnot affect the state of any volume currently mounted on thepartition.</P><H4><A NAME="kClearPartitionMount"></A>Specifying That aPartition Should Not Be Mounted at Startup</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kClearPartitionMount</CODE> (48)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the partition, or 0 if youwish to specify the partition by block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry ofthe partition. If <CODE>ioVRefNum</CODE> is not 0,this is ignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>DeviceIdent</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thedevice containing the partition. This is in thesame format as the <CODE>SCSIID</CODE> field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must setthe partition described by <CODE>ioVRefNum</CODE> and<CODE>csParam[0..3]</CODE> to not be mounted at startup.Typically this involves clearing<CODE>kPartitionIsMountedAtStartup</CODE> in<CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>,which in turn causes your disk driver to not place a drivequeue element for this partition in the drive queue atsystem startup.</P><P>This request modifies the partition map and hence onlytakes effect the next time the system is started. It doesnot affect the state of any volume currently mounted on thepartition.</P><H4>Determining Whether a Partition is to be Mounted</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Status</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kGetMountStatus</CODE> (45)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the partition to query, or 0if you wish to query the partition by block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry ofthe partition to query. If <CODE>ioVRefNum</CODE>is not 0, this is ignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>DeviceIdent</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this isidentifies the device containing the partition toquery. This is in the same format as the<CODE>SCSIID</CODE> field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0]</CODE></p></TD><td width=100 align=left><P><CODE>UInt16</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>Your disk driver must set this to either 0 (thispartition is not to be mounted) or 1 (thispartition is to be mounted).</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must set<CODE>csParam[0]</CODE> toindicate whether the partition described by<CODE>ioVRefNum</CODE> and <CODE>csParam[0..3]</CODE> is tobe mounted at system startup. Typically this involvestesting <CODE>kPartitionIsMountedAtStartup</CODE> in<CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>.</P><P>The request returns the status that is currently recordedin the partition map, not whether the partition was actuallymounted at startup.</P><H4>Mounting a Partition Immediately</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kMountVolume</CODE> (60)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the partition, or 0 if youwish to specify the partition by block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry of thepartition. If <CODE>ioVRefNum</CODE> is not0, this is ignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>DeviceIdent</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thedevice containing the partition. This is in thesame format as the <CODE>SCSIID</CODE> field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must createa drive queue element for the partition described by<CODE>ioVRefNum</CODE> and <CODE>csParam[0..3]</CODE> (if itdoesn't already have one) and post a "disk inserted" event forit. It must do this regardless of the state of the<CODE>kPartitionIsMountedAtStartup</CODE> bit in thepartition's<CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>;however, the <CODE>kPartitionIsWriteable</CODE> bit stillcontrols whether the drive is writeable.</P><P>If there is already a volume mounted on the partition,the system will ignore the "extra disk inserted" event thisrequest generates.</P><H4>Locking a Partition</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kLockPartition</CODE> (46)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the partition, or 0 if youwish to specify the partition by block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry ofthe partition. If <CODE>ioVRefNum</CODE> is not 0,this is ignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>DeviceIdent</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thedevice containing the partition. This is in thesame format as the <CODE>SCSIID</CODE> field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must lockthe partition described by <CODE>ioVRefNum</CODE> and<CODE>csParam[0..3]</CODE>. Typically this involves:</P><UL>   <LI>clearing <CODE>kPartitionIsWriteable</CODE> in   <CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>,   which in turn causes your disk driver to create a   read-only drive queue element for this partition at   system startup, and</li>      <LI>making the drive queue element associated with this   partition read-only. A read-only drive queue element has   bit 7 of the <CODE>writeProt</CODE> field of the drive   queue element set, as described in   <a href="http://developer.apple.com/documentation/mac/Files/Files-2.html">Inside   Macintosh: Files</A>,   <a href="http://developer.apple.com/documentation/mac/Files/Files-112.html">page   2-85</A>.</li></UL><H4>Unlocking a Partition</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kUnlockPartition</CODE> (49)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the partition, or 0 if youwish to specify the partition by block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry ofthe partition. If <CODE>ioVRefNum</CODE> is not 0,this is ignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>DeviceIdent</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thedevice containing the partition. This is in thesame format as the <CODE>SCSIID</CODE> field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must unlockthe partition described by <CODE>ioVRefNum</CODE> and<CODE>csParam[0..3]</CODE>. Typically this involves:</P><UL>   <LI>setting <CODE>kPartitionIsWriteable</CODE> in   <CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>,   which in turn causes your disk driver to create a   read/write drive queue element for this partition at   system startup, and</li>      <LI>making the drive queue element associated with this   partition read/write.</li></UL><H4>Determining Whether a Partition is Locked</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</B></p></TD><td width=200 align=left><P><CODE>_Status</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</B></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kGetLockStatus</CODE> (46)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive number of the partition to query, or 0if you wish to query the partition by block number.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this is thephysical block number of the partition map entry ofthe partition to query. If <CODE>ioVRefNum</CODE>is not 0, this is ignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>DeviceIdent</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>If <CODE>ioVRefNum</CODE> is 0, this isidentifies the device containing the partition toquery. This is in the same format as the<CODE>SCSIID</CODE> field of the<CODE><A HREF = "#PartitionInformationRecord">partInfoRec</A></CODE>.If <CODE>ioVRefNum</CODE> is not 0, this isignored.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0]</CODE></p></TD><td width=100 align=left><P><CODE>UInt16</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>Your disk driver must set this to either 0 (thispartition is not locked) or 1 (this partition islocked).</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must set<CODE>csParam[0]</CODE> toindicate whether the partition described by<CODE>ioVRefNum</CODE> and <CODE>csParam[0..3]</CODE> islocked. Typically this involves testing<CODE>kPartitionIsWriteable</CODE> in<CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>The polarity of this test is opposite to theother partition attribute Status requests. If thepartition is locked,<CODE>kPartitionIsWriteable</CODE> is clear in<CODE>pmPartStatus</CODE>.</p></TD></TR></TABLE></CENTER><BR><BR><P>The request returns the status that is currently recordedin the partition map, not whether the partition was actuallylocked at startup. You can determine whether a drive iscurrently write-protected by looking at bit 7 of the<CODE>writeProt</CODE> field of the drive queue element, asdescribed in<a href="http://developer.apple.com/documentation/mac/Files/Files-2.html">InsideMacintosh: Files</A>,<a href="http://developer.apple.com/documentation/mac/Files/Files-112.html">page2-85</A>.</P><H3><A NAME="pmPadRevealed"></A>pmPad Pearls</H3><P>A previously undocumented feature of the<CODE>Partition</CODE> structure is the use of the<CODE>pmPad</CODE> field. The first four bytes of this fieldis a <STRONG>driver signature</STRONG>, a Mac OS four-character code that uniquely identifies the driver.Developers must fill out this field with either a<a href="http://developer.apple.com/dev/cftype/">registeredcreator code</A> (which is strongly recommended) or zero.Drivers that use a registered creator code in this driversignature field may then use the remainder of<CODE>pmPad</CODE> to hold driver-specific configurationparameters.</P><P>Apple currently uses the following driver signatures:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kPatchDriverSignature   = 'ptDR',    kSCSIDriverSignature    = 0x00010600,    kATADriverSignature     = 'wiki',    kSCSICDDriverSignature  = 'CDvr',    kATAPIDriverSignature   = 'ATPI',    kDriveSetupHFSSignature = 'DSU1'};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The values have the following meaning:</P><DL>   <DT><CODE>kPatchDriverSignature</CODE></dt>      <DD><P>The Apple patch driver.</p></dd>      <DT><CODE>kSCSIDriverSignature</CODE></dt>      <DD><P>The Apple SCSI hard disk driver. [The significance of   this value has been lost in the mists of time.]</p></dd>      <DT><CODE>kATADriverSignature</CODE></dt>      <DD><P>The Apple ATA hard disk driver.</p></dd>      <DT><CODE>kSCSICDDriverSignature</CODE></dt>      <DD><P>The Apple SCSI CD-ROM driver.</p></dd>      <DT><CODE>kATAPIDriverSignature</CODE></dt>      <DD><P>The Apple ATAPI CD-ROM driver.</p></dd>      <DT><CODE>kDriveSetupHFSSignature</CODE></dt>      <DD><P>Drive Setup sets the first four bytes of the   <CODE>pmPad</CODE> field of   "Apple_HFS" partitions to this value. While this is not,   in the strictest sense, a driver signature, it is   documented here for completeness.</p></dd></DL><P>Remember that your disk driver should use its own driversignature; do not use these values for your own driver.</P><H3><A NAME="NewDriverTypes"></A>New Driver Types</H3><P><a href="http://developer.apple.com/documentation/mac/Devices/Devices-125.html">InsideMacintosh: Devices</A> describes how a Mac OS driver istagged by having <CODE>ddType</CODE> set to 1 in the driverdescriptor map (DDM). There is a constant for this,<CODE>sbMac</CODE>, defined in "SCSI.h". However, there areother useful constants for this field.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kDriverTypeMacSCSI = 0x0001,    kDriverTypeMacATA  = 0x0701,    kDriverTypeMacSCSIChained   = 0xFFFF,    kDriverTypeMacATAChained    = 0xF8FF};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The following constants are defined for the<CODE>ddType</CODE> field of the DDM:</P><DL>   <DT><CODE>kDriverTypeMacSCSI</CODE></dt>      <DD><P>This is a Mac OS SCSI driver, equivalent to   <CODE>sbMac</CODE>. Typically this is only used for the   first driver (the patch driver) in a SCSI driver chain.</p></dd>      <DT><CODE>kDriverTypeMacATA</CODE></dt>      <DD><P>This is a Mac OS ATA driver. Typically this is only   used for the first driver (the patch driver) in an ATA   driver chain.</p></dd>      <DT><CODE>kDriverTypeMacSCSIChained</CODE></dt>      <DD><P>This is a chained Mac OS SCSI driver. This is used   for the second and subsequent drivers in a driver chain.</p></dd>      <DT><CODE>kDriverTypeMacATAChained</CODE></dt>      <DD><P>This is a chained Mac OS   ATA driver. This is used for the second and subsequent   drivers in a driver chain.</p></dd></DL><P>The driver type for a chained driver is always the two'scomplement of the driver type for the patch driver. For moreinformation about this relationship, see<A HREF = "#ChainingDriversAndPatchPartitions">ChainingDrivers and Patch Partitions</A>.</P><H3><A NAME="DriverChecksums"></A>Driver Checksums</H3><P><CITE>Inside Macintosh, Volume V</CITE> (page 580)contains an assembly language description of the checksumalgorithm used for the <CODE>pmBootCksum</CODE> field of thepartition map, but this algorithm was somehow dropped from<a href="http://developer.apple.com/documentation/mac/Devices/Devices-2.html">InsideMacintosh: Devices</A>. As it is now quite difficult toobtain copies of <I><CITE>Inside Macintosh</CITE></I><CITE>,Volume V</CITE>, the algorithm is included below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>; Inputs:;   a0.l -&gt; pointer to driver code;   d1.w -&gt; length of driver code in bytes; Outputs:;   d0.w -&gt; driver checksum&nbsp;DoCksum  moveq.l     #0,d0 ; initialize sum register  moveq.l     #0,d7 ; zero extended byte  bra.s CkDecr; handle 0 bytesCkLoop  move.b(a0)+,d7    ; get a byte  add.w d7,d0 ; add to checksum  rol.w #1,d0 ; and rotateCkDecr  dbra  d1,CkLoop   ; next byte  tst.w d0 ; convert a checksum of 0  bne.s @1 ; into $FFFF  subq.w#1,d0 ;@1</pre></TD></TR></TABLE></CENTER><BR><BR><P>The following is a C equivalent.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static UInt32 ChecksumDriver(void *start, UInt16 bytesToSum){    UInt8  *cursor;    UInt16 result;    cursor = (UInt8 *) start;    result = 0;    while ( bytesToSum != 0 ) {  result = result + *cursor;  result = ((result &lt;&lt;  1) &amp; 0x0FFFE) |  ((result &gt;&gt; 15) &amp; 0x00001);  cursor += 1;  bytesToSum -= 1;    }    if (result == 0) {  result = 0x0FFFF;    }    return result;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>One minor mystery of the <CODE>pmBootCksum</CODE> fieldis that the field is 32 bits wide but the checksum algorithmonly calculates a 16-bit value. The checksum is alwaysstored in the least significant 16 bits of<CODE>pmBootCksum</CODE> and the most significant bits arealways set to zero.</P><P><CITE>Inside Macintosh, Volume V</CITE> also states thatdriver checksumming is only done for if the first four bytesof the driver's partition map entry <CODE>pmPartName</CODE>field is "Maci". This is only true for SCSI disk drivers.Other, partition-based disk drivers are always checksummed.</P><P>The above algorithm is known as the <STRONG>16-bit driverchecksum algorithm</STRONG>. This is because the ROMdecrements and tests <CODE>bytesToSum</CODE> using a<CODE>DBRA</CODE> instruction (which effectively makes<CODE>bytesToSum</CODE> a <CODE>UInt16</CODE>), so only thefirst <CODE>bytesToSum</CODE> modulo 64 K bytes of thedriver are checksummed. This is not a problem if your driveris smaller than 64 K bytes. If your driver is larger, youmust be careful for two reasons.</P><OL>   <LI>The code you use to calculate   <CODE>pmBootCksum</CODE> must mimic the incorrect   behavior and only checksum your driver up to the driver   size modulo 64 K.</li>      <LI>You may want to include your own checksum in the   driver to ensure that the driver code is intact.</li></OL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The 16-bit driver checksum algorithm isidentical to the algorithm used by AppleTalk'sDatagram Delivery Protocol (DDP).</p><P>In some situations where the ROM loads a driver, it doesnot use the 16-bit checksum algorithm. Specifically, laterversions of ATA Manager use a <STRONG>32-bit driver checksumalgorithm</STRONG>, shown below.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static UInt16 ATALoadDoCksum(void *start, UInt32 bytesToSum){    UInt8  *startAsBytes;    UInt32 result;    UInt32 i;    startAsBytes = (UInt8 *) start;    result = 0;&nbsp;    for (i = 0; i &lt; bytesToSum; i++) {  result += startAsBytes[i];  result &lt;&lt;= 1;  result |= (result &amp; 0x00010000) ? 1 : 0;    }    return (UInt16) result;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>The key difference is that <CODE>bytesToSum</CODE> is nowexpressed as a 32-bit quantity, and the algorithm correctlychecksums bytes beyond 64 KB. Further, the 16-bit algorithmnever returns a checksum of 0 (it is mapped to $FFFF), whilethe 32-bit algorithm can return a checksum of 0.</P><P>Your formatting utility must set <CODE>pmBootCksum</CODE>appropriately, depending on which version of ATA Manager isloading your driver. Furthermore, the ATA driver loadermechanism is updated during the system startup process so thaton machines with the old checksum algorithm in ROM, yourdriver will need a different checksum depending on whetherit is loaded at start time or after system startup.</P><P>Overall, the best solution to thisdriver checksum conundrum is:</P><UL>   <LI>make your driver's size less   than 64 KB (if necessary, use a boot strap driver to load   your main driver), and </li>      <LI>if your driver checksums to 0,   add pad bytes until it doesn't.</li></UL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>ATA disk drivers are also limited to a size of255 * block size bytes (justunder 128 KB for 512-byte block devices).This is because the ROM reads the entire driverusing a single ATA request.</p></TD></TR></TABLE></CENTER><BR><BR>  <H3><A NAME="BootingFromAPartition"></A>A Partition of YourImagination</H3><P>The original Mac Plus SCSI implementation did not allow the userto specify a startup partition. Obviously this is desiredfeature, and disk driver developers came up with a number ofsolutions for this problem. Over the years, Apple hasintroduced various stages of OS support for booting from apartition.</P><H4>Developer-Only Solutions</H4><P>Prior to Apple providing a solution, developers wereresponsible for engineering their own. Developers quicklynoticed that, all things being equal, the Macintosh tends toboot from the first bootable drive in the drive queue. Therefore,disk driver writers arranged to add the startup partition'sdrive queue element to the drive queue before the non-bootpartitions' element. The disk driver's formatting utility providedthe user interface for specifying the boot partition.</P><P>This technique was relatively effective and stimulateduser demand for a reliable mechanism for booting from apartition.</P><H4>Partition Attribute Support</H4><P>Eventually, Apple codified this approach and providedsupport for it in the Startup Disk control panel. Thecodification came in the form of the<CODE>kPartitionIsStartup</CODE> bit in the<CODE>pmPartStatus</CODE> field of the partition map, alongwith a driver Control request,<CODE><A HREF = "#kSetStartupPartition">kSetStartupPartition</A></CODE>,which allows the Startup Disk control panel to instruct thedriver to set that bit.</P><P>This standardized the previous non-standard behavior,although it still is not a perfect solution because ofvariances in the way the ROM startup code chooses a drivefrom which to start up.</P><H4>SCSI Manager 4.3</H4><P>Apple made further refinements to this solution with theintroduction of SCSI Manager 4.3. SCSI Manager 4.3 presentednew problems to the startup code because it allows formultiple SCSI buses, and it provides full support for SCSILUNs. So, when SCSI Manager 4.3was introduced, Apple alsointroduced a new technique for finding the startuppartition, the <CODE>kdgBoot</CODE> Driver Gestalt selector.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>SCSI Manager 4.3 must be in ROM for the<CODE>kdgBoot</CODE> selector to be effective. Onmachines, such as the Quadra 700, that can run SCSIManager 4.3 but do not have it in ROM, SCSI Manager4.3 loads out of the System file, too late for itto affect the startup drive selection.</p></TD></TR></TABLE></CENTER><BR><BR><P>When the user chooses a drive in the Startup Disk controlpanel, Startup Disk sends the <CODE>kdgBoot</CODE> DriverGestalt selector to the disk driver controlling that drive. Startup Disk then records theresponse in PRAM. When the Macintosh boots, it iteratesthrough the drive queue, sending a <CODE>kdgBoot</CODE>request to each drive. When it finds a drive with a valuematching the value in PRAM, it knows that this is thecorrect startup drive.</P><P>The <CODE>kdgBoot</CODE> Driver Gestalt selector isdocumented in<A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">DesigningPCI Cards and Drivers for Power Macintosh Computers</A>,page 113. This documentation is accurate for SCSI drivers.<A NAME="kdgBootForATA"></A>For ATA drivers, the<CODE>DriverGestaltBootResponse</CODE> response fieldsshould be set as follows.</P><DL>   <DT><CODE>extDev</CODE></dt>      <DD><P>The ATA bus number of the device.</p></dd>      <DT><CODE>partition</CODE></dt>      <DD><P>The partition number on the bootable partition on the   device. As described   <A HREF = "#PartitionsAreOpaque">below</A>, the format of   this field is internal to your disk driver.</p></dd>      <DT><CODE>SIMSlot</CODE></dt>      <DD><P>ATA devices must set this to   <CODE>kDriverGestaltBootATASIMSlot</CODE> ($20). [This   constant is not currently in Universal Interfaces, Radar   ID 2314693.]</p></dd>      <DT><CODE>SIMsRSRC</CODE></dt>      <DD><P>If your driver supports ATA 0/1, you must put 0 or 1   in this field to indicate the number of the device on the   ATA bus. If your driver does not support ATA 0/1, you   must set this to zero. See   <a href="http://developer.apple.com/documentation/hardware/Developer_Notes/System_Software/ATA_Device_Zero_One.pdf">ATA   0/1 Software Developers Guide</A> for more details on ATA   0/1 support.</p></dd></DL><H4>ROM-in-RAM (NewWorld)</H4><P>The<a href="tn1167.html">ROM-in-RAMarchitecture</A>, introduced with the iMac, presents newchallenges for the startup device selection process. On aROM-in-RAM machine, Open Firmware is responsible for loadingthe Mac OS ROM file off the startup partition, and henceOpen Firmware must define the startup partition well beforeMac OS starts to execute. When the Mac OS ROM starts, itcontinues booting from the startup partition chosen by OpenFirmware to avoid the potential user confusion of loadingthe Mac OS ROM from one disk and the system software from another.</P><P>Open Firmware synthesizes the traditional Macintoshstartup process, including:</P><UL>   <LI>Startup drive selection algorithm -- Open Firmware   implements the traditional   startup drive selection algorithm. It turns out that this   algorithm is very complex, although the gist of it is:   <OL><LI>if a "snag" key is helddown, try booting from the correspondingdevice,</li><LI>try booting from the default drive (if any),</li><LI>then try booting from other drives.</li>   </OL></li>      <LI>CODS -- Holding down command-option-delete-shift   (CODS) prevents the Open Firmware from booting from the   default drive.</li>      <LI>C for CD-ROM -- Holding down the C key forces Open   Firmware to boot from the CD-ROM device. This was   previously implemented by the   <CODE><A HREF = "#snag">"snag"</A></CODE> patch but is   implemented by Open Firmware in ROM-in-RAM computers.</li>      <LI>Flashing question mark -- If no startup device is   available, Open Firmware displays the traditional   "flashing question mark" icon (although, in deference to   the fact that ROM-in-RAM computers do not have floppy   drives, it flashes the question mark inside a folder icon   instead of a floppy disk icon).</li></UL><P>On ROM-in-RAM computers, the selected default startupdevice is held in an Open Firmware configuration variable<CODE>boot-device</CODE>. This configuration variable holdsan Open Firmware path to the default startup device. TheStartup Disk control panel generates a path based on the diskdriver's response to various Driver Gestalt queries.</P><P>It is impossible for OpenFirmware to completely mimic the startup drive selectionalgorithm when it comes to selecting a startup partition.When booting from a partition, <CODE>boot-device</CODE>contains the Open Firmware partition number of thestartup partition. Unfortunately, there is no reliable wayto get this from a disk driver with commonly implementedDriver Gestalt queries.</P><A NAME="PartitionsAreOpaque"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>You might think that the <CODE>partition</CODE>field of the <CODE>DriverGestaltBootResponse</CODE>would do the trick; however, this field is definedto be opaque to the system. "Designing PCI Cardsand Drivers for Power Macintosh Computers"explicitly states:</P></TD></TR></TABLE></CENTER><BR><BR><BLOCKQUOTE><P>The <CODE>partition</CODE> fieldenables the selection of a single partition on amultiply partitioned device as the boot device. Itis not interpreted by the ROM or the Startup Disk<CODE>'cdev'</CODE> [sic], so the driver can choosea meaning and a value for this field.</P></BLOCKQUOTE><P>It turns out that different disk drivers usedifferent values for the <CODE>partition</CODE>field. Apple diskdrivers set this to be the block number of thepartition map entry for the partition, but some third-party drivers useother techniques, such as recording 1 for the firstHFS partition, 2 for the second HFS partition, andso on. The upshot of this is that Startup Disk isunable to use this field reliably to set thepartition number in <CODE>boot-device</CODE>.</p><P>Prior to Mac OS 9.0, the Startup Disk control panel usedtricky heuristics to allow booting from a partition withApple disk drivers as a temporary measure to solving thisproblem. The long-term solution; however, is for diskdrivers to support a set of new Driver Gestalt queries,which return exactly the information Startup Disk needs toset <CODE>boot-device</CODE>. The required Driver Gestaltselectors (<CODE>kdgDeviceReference</CODE>,<CODE>kdgNameRegistryEntry</CODE>,<CODE>kdgOpenFirmwareBootSupport</CODE>, and<CODE>kdgOpenFirmwareBootingSupport</CODE>) are described in"DriverGestalt.h" in Universal Interfaces 3.3.</P><A NAME="PartitionsAreOpaque"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Your driver onlyneed support the <CODE>kdgNameRegistryEntry</CODE> Driver Gestalt selector if yourdevice has an obvious Name Registry node. Fordevices with no Name Registry node (SCSI), or wherethe Name Registry node can be tricky to find (ATA),it is reasonable to just return <CODE>statusErr</CODE>.</p>    </TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="Non512ByteBlockDevices"></A></P><H2>Non-512 Byte Block Devices</H2><P>The original Mac OS disk driver architecture assumed thatall block devices would use 512-byte blocks. Supportingblock devices with a different block size is relativelysimple, although it gets more complicated if you want toboot from such a device. Non-512 byte block device supportis most important for CD-ROM drivers, which use a 2-KB blocksize.</P><H3>Just the Basics</H3><P>The basic rule for supporting non-512 block devices onMac OS is that the disk driver is responsible for blockingand deblocking all I/O requests to a drive. This discussionassumes that the device block size is an integer multiple of512, although similar algorithms work for weird device blocksizes.</P><H4><A NAME="BlockTranslation"></A>Block Translation</H4><P>The File Manager makes an I/O request in terms of512-byte <STRONG>logical block numbers</STRONG> on aparticular drive. The diskdriver is responsible for translating the logical blocknumber of the request to an actual block number on thedrive. If the disk is partitioned, the first step of thistranslation is to add the offset of the partition to thelogical block number; this generates the <STRONG>physicalblock number</STRONG>. If the device uses 512-byte blocks,the physical block number is the actual block number of thedata on the disk. If the device uses non-512 byte blocks,the disk driver must do a further translation, convertingthe physical block number to a <STRONG>device blocknumber</STRONG> by dividing the physical block number by thenumber of 512-byte blocks in each physical block.</P><P>In addition, the disk driver must block/deblock therequest. If the physical block number, or the number ofblocks to transfer, is not evenly divisible by the deviceblock size, the disk driver musttransfer partial blocks to and from the disk.</P><P>The following diagrams shows the entire translationprocess for two partitions on a 2 KB block device. Allnumbers on the diagram are in the units labeled in the leftcolumn. For example, partition 1 is a 50 MB partition whichextends from 0 to 100 mega logical blocks (512-byte blocks),40 to 140 mega physical blocks (also 512-byte blocks), and10 to 35 mega device blocks (2 KB byte blocks).</P><P align=center><img src="images/tn1189_001.gif" alt="tn1189.gif.1" width=399 height=229 align=bottom></P><H4>Implementation Notes</H4><P>A disk driver typically deblocks a request by breaking itinto three components. The <STRONG>leading</STRONG>component consists of all the requested physical blocks upto the first device block boundary. The leading component isempty if the requested physical blocks start on a deviceblock boundary.</P><P>The <STRONG>main</STRONG> component consists of all therequested physical blocks which are fully encompassed bydevice blocks. The main component may be empty if thetransfer is short. The main component is transferreddirectly from between the client buffer and the disk.</P><P>Finally, the <STRONG>trailing</STRONG> component consistsof all the requested physical blocks of the transfer whichfall after the last block of the main component. Thetrailing component is empty if the physical block numberplus the number of physical blocks to transfer falls on adevice block boundary.</P><P>Because you can't transfer a sub-block size request, theleading and trailing components must be transferred througha temporary buffer. You should allocate this temporarybuffer when your driver is opened. As the leading andtrailing components are always less than one device block(otherwise they would be part of the main component), thetemporary buffer need only be as big as a device block. Ifyour device driver is single threaded, you need onlyallocate a single temporary buffer. If your driver ismulti-threaded, you must allocate as many temporary buffersas you allow threads of execution within your driver, orinternally serialize the use of the temporary buffer.</P><P>The leading and trailing components are read bytransferring the device block to the temporary buffer andthen copying the appropriate data out of the temporarybuffer to the client buffer. The leading and trailingcomponents are written by first reading the current contentsof the device to the temporary buffer, then copying the newdata from the client buffer to the temporary buffer, thenwriting the temporary buffer to the device.</P><P>The following illustration shows how misaligned read istransferred to the client buffer:</P><P align=center><img src="images/tn1189_002.gif" alt="tn1189.gif.2" width=445 height=346 align=bottom></P><H4>Performance Considerations</H4><P>The above algorithm is obviously inefficient if transfersare misaligned, that is, if the leading and trailingcomponents are not empty. Misaligned writes are even moreexpensive than misaligned reads because the disk driver mustdo an extra I/O to pre-fill the temporary buffer with theexisting contents of device block. Worse yet, a misaligned write that has bothleading and trailing components takes <EM>five I/O operations</EM> (read leading, write leading, write main,read leading, write leading).</P><P>There are a number of ways to avoid misaligned transfers:</P><UL>   <LI>Your formatting utility should always start   partitions (especially file system   partitions) on device block boundaries.</li>      <LI>File system clients can issue a Driver Gestalt   <CODE>kdgMediaInfo</CODE> request to determine the device   block size and ensure that transfers are aligned. This is   particularly important for   write requests.</li>      <LI>As a rule, volume formats should use the above   technique to ensure that their allocation blocks are   correctly aligned. At a minimum, volume formats should   align allocation blocks on 2 KB boundaries to accommodate   the most common cases, namely CD-ROM, DVD-ROM/RAM, and   magneto-optical devices.</li></UL><P>It is strongly recommended that your disk driver cache atleast one device block. Many Mac OS programs will transferdata in sequential 512-byte chunks. By caching a singledevice block, your driver can radically reduce the averagetime taken to service these requests.</P><H3><A NAME="BootingFromCDROM"></A>Booting From Non-512 ByteBlock Devices</H3><P>This section is not yet finished and has been omitted in the interests of shippingan initial version of the technote. A future revision ofthis technote will cover booting from a non-512 byte blockdevice. If you are interested in this topic, please email<A HREF = "mailto:dts@apple.com">DTS</A> and ask for aprerelease draft of this section.</p><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="LargeVolumeSupport"></A></P><H2>Large Volume Support</H2><P>When Mac OS originally shipped, it supported volume sizesup to 2 GB. This limit was shared by a number of systemcomponents, including the File Manager and disk drivers.Large volume support was introduced in two phases.</P><OL>   <LI>System 7.5 introduced support for volumes larger than   2 GB, up to a size of 4 GB. The semantics of two   programming interfaces were changed to accomplish this.      <UL><LI><CODE>PBHGetVInfo</CODE> does not return the truesize of the volumes greater than 2 GB; the volume sizeand free space are always clipped to 2 GB or less.</li><LI>The <CODE>dCtlPosition</CODE> field of the DeviceControl Entry (DCE) was redefined as an unsignedquantity.</li>   </UL></li>      <LI>System 7.5.2 introduced support for volumes larger   than 4 GB, up to a size of a 2 TB. This required two new   programming interfaces.      <UL><LI><CODE>PBXGetVolInfo</CODE> returns the volume sizeand free space as a 64-bit quantity.</li><LI>The I/O parameter block passed to disk drivers wasextended to include a 64-bit field,<CODE>ioWPosOffset</CODE>, which supplants<CODE>dCtlPosition</CODE>.</li>   </UL></li></OL><P>The changes to the File Manager programming interfacesare not relevant to this technote; they are documented inDTS Q&amp;A FL 08, <a href="../../qa/fl/fl08.html">"DeterminingVolume Size</A>." This section describes the changes to thedisk driver interface.</P><H3>Large Volume Interfaces</H3><P>Supporting volumes between 2 GB and 4 GB was simply amatter of redefining the <CODE>dCtlPosition</CODE> field ofthe DCE and the <CODE>ioPosOffset</CODE> field of the<CODE>IOParam</CODE> structure to be unsigned longs(<CODE>UInt32</CODE>).</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>While the semantics of these fields have beenchanged to unsigned, Universal Interfaces (as ofthe current version, 3.3) still define the fieldsas signed. Your code must type cast the fields asappropriate.</p></TD></TR></TABLE></CENTER><BR><BR><P>To support volumes larger than 4 GB, a new extended I/Oparameter block (<CODE>XIOParam</CODE>) structure wasdefined. The original and extended I/O parameter blocks aredistinguished by the <CODE>kUseWidePositioning</CODE> bit ofthe <CODE>ioPosMode</CODE> field (clear for original, setfor extended).</P><P>The C definition of the extended I/O parameter block isgiven below. The key difference is the addition of the<CODE>ioWPosOffset</CODE> field, a signed 64-bit quantitywhich contains the offset of the request.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>The extended I/O parameter block must only beused for <CODE>_Read</CODE> or <CODE>_Write</CODE>requests to device drivers. It must not be used foraccessing files. The following description assumesthis restriction to simplify the text.</p></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>This structure was previously only documentedin the<a href="http://developer.apple.com/documentation/hardware/Developer_Notes/Macintosh_CPUs-PPC_Desktop/PPC_9500.pdf">PowerMacintosh 9500 Computers</A> hardware developernote. The description here is not only easier tofind, but updated and more accurate.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct XIOParam {    QElemPtr   qLink;    shortqType;    shortioTrap;    Ptr  ioCmdAddr;    IOCompletionUPP     ioCompletion;    OSErrioResult;    StringPtr  ioNamePtr;    shortioVRefNum;    shortioRefNum;    SInt8ioVersNum;    SInt8ioPermssn;    Ptr  ioMisc;    Ptr  ioBuffer;    long ioReqCount;    long ioActCount;    shortioPosMode;    wide ioWPosOffset;};typedef struct XIOParam XIOParam;typedef XIOParam *XIOParamPtr;</pre></TD></TR></TABLE></CENTER><BR><BR><P><A NAME="XIOForApps"></A>For software making extended I/Orequests, the fields are defined as follows:</P><DL>   <DT><CODE>qLink<BR>      qType<BR>      ioTrap<BR>      ioCmdAddr</CODE></dt>      <DD><P>Used internally by the Device Manager.</p></dd>      <DT><CODE>ioCompletion</CODE></dt>      <DD><P>For asynchronous requests, you must either set this   field to zero or set it to a universal procedure pointer   for your completion routine. For synchronous requests,   this field is ignored.</p></dd>      <DT><CODE>ioResult</CODE></dt>      <DD><P>On completion this field contains the result of the   request, which is either <CODE>noErr</CODE> (0) or a   negative error code. The Device Manager guarantees that   this field will be set to <CODE>ioInProgress</CODE> (1)   until the request is complete.</p></dd>      <DT><CODE>ioNamePtr</CODE></dt>      <DD><P>Ignored for <CODE>_Read</CODE> and   <CODE>_Write</CODE> requests.</p></dd>      <DT><CODE>ioVRefNum</CODE></dt>      <DD><P>You must set this field to the drive number of the   drive you wish to read or write.</p></dd>      <DT><CODE>ioRefNum</CODE></dt>      <DD><P>You must set this field to the driver reference   number of the device driver controlling the drive you   wish to read or write.</p></dd>      <DT><CODE>ioVersNum<BR>      ioPermssn<BR>      ioMisc</CODE></dt>      <DD><P>Ignored for <CODE>_Read</CODE> and   <CODE>_Write</CODE> requests.</p></dd>      <DT><CODE>ioBuffer</CODE></dt>      <DD><P>You must set this to point to a data buffer from   which data is written, or to which data is read.</p></dd>      <DT><CODE>ioReqCount</CODE></dt>      <DD><P>You must set this field to the number of bytes you   wish to read or write. For disk driver requests, this   must be a multiple of 512 bytes.</p></dd>      <DT><CODE>ioActCount</CODE></dt>      <DD><P>On completion this field contains the number of bytes   of data that were actually   transferred.</p></dd>      <DT><CODE>ioPosMode</CODE></dt>      <DD><P>You must set this field to   <CODE>kUseWidePositioning</CODE> to indicate that this is   a wide request. All wide requests use a positioning mode   of <CODE>fsFromStart</CODE>. You must not specify any   other positioning mode (<CODE>fsAtMark</CODE>,   <CODE>fsFromLEOF</CODE>, or <CODE>fsFromMark</CODE>). You   may also specify   <CODE>rdVerifyMask</CODE> for   <A HREF = "#ReadVerifyMode">read-verify mode</A>,   <CODE>noCacheMask</CODE> to request that   the data not be placed in the cache, or   <CODE>pleaseCacheMask</CODE> to request that data be   placed in the cache.</p></dd>      <DT><CODE>ioWPosOffset</CODE></dt>      <DD><P>You must set this field to the offset (in bytes) from   the beginning of the disk where the transfer should   begin. For disk driver requests, this must be a multiple   of 512 bytes.</p></dd></DL><P>For disk drivers servicing an extended I/O request, the fields are defined asfollows:</P><DL>   <DT><CODE>qLink<BR>      qType</CODE></dt>      <DD><P>Used internally by the Device Manager.</p></dd>      <DT><CODE>ioTrap</CODE></dt>      <DD><P>Your driver must test bit 0 of this field to   determine whether the request is a <CODE>_Read</CODE>   (bit 0 clear) or a <CODE>_Write</CODE> (bit 0 set). It   must also test <CODE>noQueueBit</CODE> (bit 9) to   determine whether the request is immediate (bit 9 set) or   not. If your driver does not support immediate requests,   it must fail the request with a <CODE>paramErr</CODE>.   Your driver <EM>must not</EM> test   <CODE>asyncTrpBit</CODE> (bit 10) to determine whether   the request is synchronous or asynchronous. Instead, it   should handle all requests as if they were made   asynchronously. See Technote 1067   <a href="tn1067.html">Traditional   Device Drivers: Sync or Swim</A> for details.</p></dd>      <DT><CODE>ioCmdAddr</CODE></dt>      <DD><P>Used internally by the Device Manager.</p></dd>      <DT><CODE>ioCompletion</CODE></dt>      <DD><P>The Device Manager <CODE>IODone</CODE> routine will   do the right thing with this field. Your driver should   ignore this field and handle all requests as if they were   made asynchronously. See Technote 1067   <a href="tn1067.html">Traditional   Device Drivers: Sync or Swim</A> for details.</p></dd>      <DT><CODE>ioResult</CODE></dt>      <DD><P>Your driver must not read or write this field. Your   driver sets this field implicitly when it calls   <CODE>IODone</CODE>. When your driver has finished a   queued request, it should call <CODE>IODone</CODE> to   signal that the request is complete. <CODE>IODone</CODE>   performs a number of actions, one of which is to set this   field to the error status you passed to the routine in   register D0. <STRONG>Your driver must pass a non-positive   error status to <CODE>IODone</CODE>.</STRONG></p></dd>      <DT><CODE>ioNamePtr</CODE></dt>      <DD><P>Your driver must ignore this field.</p></dd>      <DT><CODE>ioVRefNum</CODE></dt>      <DD><P>Your driver must use this field to determine which   drive is the target of the request. If your driver does   not control a drive with this drive number, it must   complete the request with <CODE>nsDrvErr</CODE>.</p></dd>      <DT><CODE>ioRefNum</CODE></dt>      <DD><P>Your driver may look at this field to determine the   driver reference number of the request. This may be   useful if the same code is used for multiple device   drivers (see <A HREF = "#CodeSharing">Code Sharing</A>).</p></dd>      <DT><CODE>ioVersNum<BR>      ioPermssn<BR>      ioMisc</CODE></dt>      <DD><P>Your driver must ignore these fields.</p></dd>      <DT><CODE>ioBuffer</CODE></dt>      <DD><P>Your driver must transfer data to or from the buffer   pointed to by this field.</p></dd>      <DT><CODE>ioReqCount</CODE></dt>      <DD><P>Your driver must attempt to transfer the number of   bytes specified in this field. Your driver may fail a   request (with <CODE>paramErr</CODE>) if this is not a   multiple of 512 bytes.</p></dd>      <DT><CODE>ioActCount</CODE></dt>      <DD><P>Before completing the request, your driver must set   this field to the number of bytes that were actually   transferred.</p></dd>      <DT><CODE>ioPosMode</CODE></dt>      <DD><P>Your driver must test the   <CODE>kUseWidePositioning</CODE> bit to determine whether   this is a wide request, as described in the next section.   If it is a wide request, your driver must ignore the   bottom 2 bits of this field (that is,   <CODE>fsFromStart</CODE>, <CODE>fsAtMark</CODE>,   <CODE>fsFromLEOF</CODE>, and <CODE>fsFromMark</CODE>) and   use <CODE>ioWPosOffset</CODE> to determine the offset   into the drive for the transfer. Your driver may choose   to honor the   <CODE><A HREF = "#ReadVerifyMode">rdVerifyMask</A></CODE>,   <CODE>noCacheMask</CODE>, and   <CODE>pleaseCacheMask</CODE> in the traditional way.</p></dd>      <DT><CODE>ioWPosOffset</CODE></dt>      <DD><P>Your driver must transfer data from this offset (in   bytes) into the drive. Your driver may fail a request   (with <CODE>paramErr</CODE>) if this is not a multiple of   512 bytes. If <CODE>ioWPosOffset</CODE> is negative or   <CODE>ioWPosOffset</CODE> plus <CODE>ioReqCount</CODE> is   beyond the end of the drive, your driver must fail the   request with a <CODE>paramErr</CODE>.</p></dd></DL><H3>Supporting Large Volumes in Your Driver</H3><P>To support large volumes correctly, your driver mustimplement the following:</P><UL>   <LI>Your driver must return true in response to the   <CODE>kdgWide</CODE> Driver Gestalt selector. You may   want to use the   <CODE>GetDriverGestaltBooleanResponse</CODE> macro to   ensure that you set the correct response byte in the   parameter block.</li>      <LI>When handling all <CODE>_Read</CODE> or   <CODE>_Write</CODE> requests, your driver must check   whether the <CODE>kUseWidePositioning</CODE> flag is set   in <CODE>ioPosMode</CODE>. If it is, you must cast the   parameter block to an <CODE>XIOParam</CODE> and do the   I/O at the 64-bit offset specified in   <CODE>ioWPosOffset</CODE>. This type of request is known   as a <STRONG>wide request</STRONG>.</li>      <LI>If <CODE>kUseWidePositioning</CODE> is not set, your   driver must do the I/O at the offset specified by   <CODE>dCtlPosition</CODE>. You must cast this signed   value to an unsigned quantity (<CODE>UInt32</CODE>) to   correctly handle offsets from 2 GB to 4 GB. This type of   request is known as a <STRONG>narrow request</STRONG>.</li></UL><P>There are some important caveats of which you should beaware.</P><UL>   <LI>There is no guarantee that the system will check with   Driver Gestalt before issuing a wide request. The system   expects that any driver controlling a drive larger than 4 GB will   respond to wide request correctly. Similarly, the system   expects that a driver controlling a drive whose size is   between 2 GB and 4 GB is smart enough to treat   <CODE>dCtlPosition</CODE> as unsigned.</li>      <LI>There is no guarantee that the system will always use   wide requests when talking to a drive larger than 4 GB.   In fact, the system currently decides on a   request-by-request basis whether to use a wide or a   narrow request, based on the request's offset on the   drive. However, you must not rely on this behavior; you   must handle wide requests to offsets less than 4 GB   correctly.</li>      <LI>The <CODE>dCtlPosition</CODE> field of the DCE is a   32-bit quantity, thus it cannot accurately reflect the   position of the current I/O beyond the 4 GB boundary. You   should ignore <CODE>dCtlPosition</CODE> for wide requests   and use it only for narrow requests.</li></UL><H3><A NAME="NotesForDevelopersCallingDiskDrivers"></A>Notesfor Developers Calling Disk Drivers</H3><P>If you're writing software that issues <CODE>_Read</CODE>or <CODE>_Write</CODE> requests to a disk driver, you mustbe careful to avoid some common pitfalls. Specifically, youshould follow the recommendations given below.</P><UL>   <LI>You should always use an <CODE>ioPosMode</CODE> of   <CODE>fsFromStart</CODE> when calling a disk driver.   Because <CODE>dCtlPosition</CODE> cannot accurately   reflect the position beyond 4 GB, other positioning modes   do not work as expected in all cases.</li>      <LI>Before issuing a wide request, you should call Driver   Gestalt to determine whether the driver supports wide   requests.</li>      <LI>If the driver supports wide requests, you may choose   to always use wide requests for that driver. However, for   maximum compatibility, DTS recommends that you take the same approach as the   system by deciding to use a wide or narrow request based   on the offset into the drive.</li></UL><P>The following code snippet implements theserecommendations.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static void SetWidePosOffset(UInt32 blockOffset, XIOParamPtr pb)    // Set up ioPosMode and either ioPosOffset or ioWPosOffset for a    // device _Read or _Write.{    pb-&gt;ioWPosOffset.lo = blockOffset &lt;&lt; 9;  // convert block number    pb-&gt;ioWPosOffset.hi = blockOffset &gt;&gt; 23; // to wide byte offset    if ( pb-&gt;ioWPosOffset.hi != 0 ) {  // Offset on drive is &gt;= 4G, so use wide positioning mode  pb-&gt;ioPosMode = fsFromStart | (1 &lt;&lt; kWidePosOffsetBit);    } else {  // Offset on drive is &lt; 4G, so use regular positioning mode,  // and move the offset into ioPosOffset  pb-&gt;ioPosMode = fsFromStart;  ((IOParam *)pb)-&gt;ioPosOffset = pb-&gt;ioWPosOffset.lo;    }}</pre></TD></TR></TABLE></CENTER><BR><BR><P>In addition, you should never call<CODE>PBReadImmed</CODE> or <CODE>PBWriteImmed</CODE> on adisk driver unless you know, in advance, that the diskdriver supports such requests. Many disk drivers fail tohandle <CODE>Immediate</CODE> requests properly. Because immediaterequests result in the disk driver possibly being reentered,these problems are hard to detect and debug.</p><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="HowTheROMLoadsDiskDrivers"></A></P><H2>How the ROM Loads SCSI and ATA Drivers</H2><P>This section describes how the ROM loads SCSI and ATAdrivers from a driver partition. Understanding this processis critical to an understanding of the<A HREF = "#ChainingDriversAndPatchPartitions">chaining driverarchitecture</A>, and useful for general disk driverwriters.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>This discussion only applies to computers withbuilt-in support for SCSI orATA, and the drivers loaded from devicesattached to those buses. It does not apply to theMacintosh 128 and 512, which can only boot throughthe floppy drive interface and do not support<CODE>partition-based drivers</CODE>. Nor does itapply to drivers for modern I/O buses, such as USBand <A HREF = "#LoadingFireWireDrivers">FireWire</A>.</p></TD></TR></TABLE></CENTER><BR><BR><P>When a Macintosh boots, code in the ROM scans each SCSI and ATA bus for block devices ina bus-specific manner. Once it has found a potentiallybootable block device, the ROM attempts to load a driverfrom that device. The ROM executes the following procedureto load a driver.</P><OL>   <LI>It first reads device   block 0 of the disk. This is the driver descriptor map   (DDM) and is structured as the <CODE>Block0</CODE> data   type defined in "SCSI.h". It checks that block 0 is a   valid DDM by comparing the <CODE>sbSig</CODE> field to   <CODE>sbSIGWord</CODE> ($4552 or <CODE>'ER'</CODE>). If   the DDM is not valid, the ROM ignores the device.</li>      <LI>It then reads device   block 1 of the disk and looking for the first entry of   the partition map. A partition map entry is represented   by the <CODE>Partition</CODE> data structure in "SCSI.h".   For the partition to be recognized, the   <CODE>pmSig</CODE> field must be   <CODE>newPMSigWord</CODE> ($5453 or <CODE>'PM'</CODE>).   The ROM uses the <CODE>pmMapBlkCnt</CODE> field of this   first partition to determine the size of the partition   map as a whole.</li>      <LI>The ROM then searches the DDM for the first driver   that is compatible with this   bootable bus. The DDM contains an array of   <CODE>DDMap</CODE> structures. The key field in this   structure is <CODE>ddType</CODE>, which identifies the   type of driver defined by the structure. If the device is   attached to a SCSI bus, the ROM looks for a   <CODE>DDMap</CODE> whose <CODE>ddType</CODE> is   <CODE>kDriverTypeMacSCSI</CODE>. If the device is   attached to an ATA bus, the ROM looks for a   <CODE>DDMap</CODE> whose <CODE>ddType</CODE> is   <CODE>kDriverTypeMacATA</CODE>.</li>      <LI>The ROM then searches (by   reading consecutive device blocks) the partition   map for the chosen driver's partition map entry (whose   <CODE>pmParType</CODE> <EM>starts with</EM>   "Apple_Driver" and whose <CODE>pmPyPartStart</CODE>   equals the <CODE>ddBlock</CODE> field of the   <CODE>DDMap</CODE> of the chosen driver). It stores this   partition map entry in a temporary memory block.</li>      <LI>The ROM then searches (by   reading consecutive device blocks) the partition   map for the first HFS partition (whose   <CODE>pmParType</CODE> is "Apple_HFS"). It stores this   partition map entry in a temporary memory block.</li>      <LI>The ROM then uses the driver's <CODE>DDMap</CODE> to   read the driver into memory. It first allocates a pointer   block in the system heap to hold the driver (the size of   this block is the size of the driver in blocks   (<CODE>ddSize</CODE>) multiplied by the disk's block size   (<CODE>sbBlkSize</CODE>)) and then reads the driver off   the disk (starting from <CODE>ddBlock</CODE>) into that   buffer.</li>      <LI>Next, the ROM checksums the driver to ensure its   validity. For more information on the exact details of   the checksum, see <A HREF = "#DriverChecksums">Driver   Checksums</A>.</li>      <LI>The ROM then calls the driver's entry point. The   exact calling conventions are described below. The driver   is expected to install itself in the unit table, open   itself, and create drive queue elements for each mountable partition on the disk.   (The exact definition of "mountable" is covered in   <A HREF = "#CooperatingWithFSM">Cooperating with File   System Manager</A>.)</li></OL><P>If any of these steps fail, the ROM assumes that thedevice is not bootable and attempts to boot from the nextavailable device.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>The fact that the ROM requires an "Apple_HFS"partition to boot from a device is important to authors ofnon-standard disk drivers, such as RAID stripingdrivers. The RAID software must create a dummy"Apple_HFS" partition on the device so that the ROM will boot far enoughto load the RAID driver.</p></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The Macintosh Plus originally used an old style(<CITE>Inside Macintosh IV</CITE>) partitionformat, identified by a <CODE>pmSig</CODE> of<CODE>oldPMSigWord</CODE> ($5453 or<CODE>'TS'</CODE>). Chaining drivers are notsupported on the old partition format. However, thenew (<CITE>Inside Macintosh V</CITE>) partition mapformat will work on the Mac Plus, so it is possibleto use chaining drivers on these venerablemachines.</P></TD></TR></TABLE></CENTER><BR><BR><P>If you want to support the Macintosh Plus inyour driver, you need to be aware of the subtledifference between it and later computers.Specifically the buffer pointed to by A0 when theMacintosh Plus ROM calls your driver contains thecontents of the second block on the disk (the oldstyle "device partition map"); on all subsequentcomputers, the buffer pointed to by A0 contains thefirst "Apple_HFS" partition map entry.</p><P>Each driver has two possible entry points. The<STRONG>primary entry point</STRONG> is at the beginning ofthe memory block holding the driver. The <STRONG>secondaryentry point</STRONG> is 8 bytes into the memory blockholding the driver. In general, the primary entry point iscalled when an "old" driver is loaded, or a "new" driver isloaded by an 'old' ROM, and the secondary entry point isused when a 'new' ROM load a "new" driver. The secondaryentry point has extra parameters that make sense in the'new' ROM environment.</P><P>The exact definition of "old" and "new" depends on thebootable bus. For SCSI, a "new" ROM is one that contains SCSI Manager 4.3, and a"new" driver is indicated by the bytes "43" in the two bytesfollowing the "Apple_Driver" in <CODE>pmParType</CODE>. ForATA, an 'old' ROM is one that contains ATA Manager 1.0. Allnewer versions of ATA Manager use the secondary entry point.A 'new' ATA Manager will always callthe secondary entry point of the driver.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Computers with<a href="http://developer.apple.com/documentation/hardware/DeviceManagers/ata/ata_ref/ATA.9.html">ATAManager 1.0</A> in ROM are listed in the tablebelow:</P><TABLE BORDER=1>   <TR><td width=160 align=left><P><STRONG>Base Model</STRONG></p></TD><td width=80 align=left><P><STRONG>Introduced</STRONG></p></TD><td width=120 align=left><P><STRONG>and Derivatives?</STRONG></p></TD></TR>   <TR><td width=160 align=left><P>Macintosh Performa 630</p></TD><td width=80 align=left><P>July 1994</p></TD><td width=120 align=left><P>yes</p></TD></TR>   <TR><td width=160 align=left><P>Macintosh PowerBook 150</p></TD><td width=80 align=left><P>July 1994</p></TD><td width=120 align=left><P>yes</p></TD></TR>   <TR><td width=160 align=left><P>Macintosh LC 580</p></TD><td width=80 align=left><P>Apr 1995</p></TD><td width=120 align=left><P>yes</p></TD></TR>   <TR><td width=160 align=left><P>Power Macintosh 5200</p></TD><td width=80 align=left><P>Apr 1995</p></TD><td width=120 align=left><P>yes</p></TD></TR>   <TR><td width=160 align=left><P>Power Macintosh 6200</p></TD><td width=80 align=left><P>May 1995</p></TD><td width=120 align=left><P>yes</p></TD></TR>   <TR><td width=160 align=left><P>Power Macintosh 5300</p></TD><td width=80 align=left><P>Aug 1995</p></TD><td width=120 align=left><P>yes</p></TD></TR>   <TR><td width=160 align=left><P>Power Macintosh 6300</p></TD><td width=80 align=left><P>Oct 1995</p></TD><td width=120 align=left><P>yes, except 6360</p></TD></TR></TABLE></TD></TR></TABLE></CENTER><BR><BR><P>Both entry points use register-based calling conventions.The register usage is shown in the table below:</P><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>A0</CODE></p></TD><td width=100 align=left><P><CODE>Partition *</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>A pointer to the first "Apple_HFS" partition mapentry in the partition map. See step 5 above. Youdo not own this memory and must neither change itnor free it. This memory is<EM>not</EM> guaranteed to be a standard MemoryManager pointer block. This parameter isgenerally ignored by drivers.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>D3</CODE></p></TD><td width=100 align=left><P>n/a</p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>See discussion <A HREF = "#RegisterD3">below</A>.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>D5</CODE></p></TD><td width=100 align=left><P>bus dependent</p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>A specification of the device from which thedriver was loaded, in a format that is bootable-bus dependent. Seethe table and discussion<A HREF = "#RegisterD5">below</A>.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>D7</CODE></p></TD><td width=100 align=left><P><CODE>long</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The <CODE>sbData</CODE> field from the DDM. Thisparameter is generally ignored by drivers.</p></TD></TR>   <TR><td width=91 align=left><P><CODE>D0</CODE></p></TD><td width=100 align=left><P><CODE>OSErr</CODE> or <CODE>SInt32</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>See discussion <A HREF = "#RegisterD0">below</A>.</p></TD></TR></TABLE><br><H3><A NAME="RegisterD3"></A>Register D3</H3><P>Old Apple SCSI drivers require that register D3 be set toa non-zero value in order to boot correctly. This bug wasfixed in September 1996 although, if you are writing a SCSIdisk -mounting utility, you may still encounter these olddrivers.</P><H3><A NAME="RegisterD5"></A>Register D5</H3><P>The data in register D5 depends on both the bootable busand the entry point called. The following table indicatesthe possible combinations.</P><TABLE BORDER=1>   <TR><td width=100 align=left><P><STRONG>Bootable Bus</STRONG></p></TD><td width=100 align=left><P><STRONG>Entry Point</STRONG></p></TD><td width=120 align=left><P><STRONG>D5 Format</STRONG></p></TD></TR>   <TR><td width=100 align=left><P>SCSI</p></TD><td width=100 align=left><P>Primary</p></TD><td width=120 align=left><P>0, 0, 0, SCSI ID</p></TD></TR>   <TR><td width=100 align=left><P>SCSI</p></TD><td width=100 align=left><P>Secondary</p></TD><td width=120 align=left><P><CODE>DeviceIdent</CODE></p></TD></TR>   <TR><td width=100 align=left><P>ATA</p></TD><td width=100 align=left><P>Primary</p></TD><td width=120 align=left><P>0, 0, 0, Bus</p></TD></TR>   <TR><td width=100 align=left><P>ATA</p></TD><td width=100 align=left><P>Secondary</p></TD><td width=120 align=left><P><CODE>DeviceIdentATA</CODE></p></TD></TR></TABLE><br><P><A NAME="DeviceIdentATA"></A>The format of<CODE>DeviceIdentATA</CODE> is given below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct DeviceIdentATA {    UInt8 diReserved;    UInt8 busNum;    UInt8 devNum;    UInt8 diReserved2;};typedef struct DeviceIdentATA   DeviceIdentATA;typedef DeviceIdentATA *  DeviceIdentATAPtr;</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR><CODE>DeviceIdentATA</CODE> is not the same asthe <CODE>ataDeviceID</CODE> structure defined in<a href="http://developer.apple.com/documentation/hardware/Developer_Notes/System_Software/ATA_Device_Zero_One.pdf">ATA0/1 Software Developers Guide</A>, although itis easy to convertbetween the two.</p></TD></TR></TABLE></CENTER><BR><BR><P>The fields have the following meaning:</P><DL>   <DT><CODE>diReserved</CODE></dt>      <DD><P>Reserved. When calling a disk driver, the ROM sets   this to 0; however, in the case described below, this   field contains meaningful data.</p></dd>      <DT><CODE>busNum</CODE></dt>      <DD><P>The ATA bus number.</p></dd>         <DT><CODE>devNum</CODE></dt>      <DD><P>If the machine has ATA 0/1 support, this is the   device number of the device on that bus. Otherwise, it   must be zero.</p></dd>         <DT><CODE>diReserved2</CODE></dt>      <DD><P>Reserved. Set to 0.</p></dd>   </DL><P><A NAME="diReserved"></A>In some cases (such as the<A HREF = "#PatchExecution">entry point to a patch</A> loadedby the <A HREF = "#TheApplePatchDriver">Apple patchdriver</A>), the <CODE>diReserved</CODE> field is used todistinguish between a <CODE>DeviceIdent</CODE> and<CODE>DeviceIdentATA</CODE>. The appropriate values for thisfield are given below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kBusTypeSCSI  = 0,    kBusTypeATA= 1,    kBusTypePCMCIA= 2,    kBusTypeMediaBay    = 3};</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Values other than <CODE>kBusTypeSCSI</CODE>(which indicates a <CODE>DeviceIdent</CODE>) and<CODE>kBusTypeATA</CODE> (which indicates a<CODE>DeviceIdentATA</CODE>) are now deprecated. PCCard and media bay device are now handled throughthe ATA Manager, modernversions of which handle multiple buses.</p>     </TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>In times past, it was accepted practice to usevarious high bits of register D5 to hold variouspieces of state information. Specifically thefollowing bits are used by various Apple and thirdparty drivers.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kSecondaryEntryPointCalled  = 29,    // 1 =&gt; secondary entry point called    kDontMountVolumes  = 30,    // 1 =&gt; don't mount any partitions    kAfterSystemStartupTime     = 31     // 1 =&gt; post-system startup load};</pre></TD></TR></TABLE></CENTER><BR><BR><P>However, in the circumstances described above,all bits in register D5 can be used to holdinformation. Therefore, DTS recommends that youdiscontinue the practice of storing flags in thehigh bit of D5 where practical.</P><P>A good substitute for the<CODE>kAfterSystemStartupTime</CODE> flag isdescribed in<A HREF = "#DiskDriversAndTheSystemHeap">Disk Driversand the System Heap</A>.</p><H3><A NAME="RegisterD0"></A>Register D0</H3><P>The significance of register D0 on return from yourdriver's entry point varies depending on the manager thatloaded your driver.</P><UL>   <LI>For ATA Manager, your driver should return an error   result in the low word of register D0 and, if the driver   successfully installed, its driver reference number in   the high word (or a high word of zero otherwise). If you   return an error value other than <CODE>noErr</CODE>, ATA   Manager will unload your driver code from memory.</li>      <LI>For SCSI Manager 4.3, the contents of register D0 are   always ignored. SCSI Manager 4.3 will never unload your   driver from memory. With some clever coding, you can   unload the bulk of your driver code upon a failed   installation, if you feel that level of polish is   necessary.</li>      <LI>For old SCSI Manager, the situation varies depending   on the particular ROM.      <UL><LI>The Mac Plus will treat register D0 as an errorresult and unload your driver if you return a non-zerovalue.</li><LI>Subsequent computers ignore the contents ofregister D0. If your driver fails to install and youwant its code to be unloaded, you can return to thereturn address plus 4 bytes, which signals this toSCSI Manager. <B>Doing this on a computer running SCSIManager 4.3 will crash the system.</B></li>   </UL></li></UL><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="LoadingFireWireDrivers"></A></P><H2>Loading FireWire Drivers</H2><P>This section is only available under non-disclosureagreement.  Please contact <A HREF = "mailto:dts@apple.com">DTS</A>for details.</p><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="ChainingDriversAndPatchPartitions"></A></P><H2>Chaining Drivers and Patch Partitions</H2><P>Booting a computer is always a tricky exercise. One ofthe perennial challenges is working around problemsin the ROM that prevent the OS from booting far enough toload patches in the normal way. On pre-ROM-in-RAM Macintosh computers,this problem is solved by means of chaining drivers andpatch partitions. Patches loaded in this way have been usedto:</P><UL>   <LI>support booting from volumes larger than 2 GB on machines that don't have   such support in the ROM (for example, NuBus-based Power   Macintoshes),</li>      <LI>fix bugs in the ROM SCSI Manager that would otherwise   prevent booting, and</li>      <LI>provide support for <STRONG>snag booting</STRONG>,   where the user can hold down the C key to force the   system to boot from the CD-ROM device.</li></UL><P>This section explains how chaining drivers and patchpartitions are implemented, and how you can license chainingdrivers and patches suitable for inclusion in your own diskformatting utility.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The chaining driver architecture is onlyrequired for SCSI and ATA devices. All computerscapable of booting from modern I/O buses (USB andFireWire) use the<a href="tn1167.html">ROM-in-RAM</A>architecture, where the ROM is loaded from the "MacOS ROM" file in the System Folder. On suchmachines, ROM patches are effected by updating the"Mac OS ROM" file.</p></TD></TR></TABLE></CENTER><BR><BR><H3>Background Material</H3><P>This section presumes that you are familiar with theexisting documentation on disk partitions and how Mac OSloads a driver from the disk at startup time. Specifically,you should be familiar with:</P><UL>   <LI><a href="http://developer.apple.com/documentation/mac/Devices/Devices-2.html">Inside   Macintosh: Devices</A>, Chapter 3 "SCSI Manager"   <a href="http://developer.apple.com/documentation/mac/Devices/Devices-121.html#HEADING121-37">The   Structure of Block Devices</A> (page 3-12 through 3-15)   and   <a href="http://developer.apple.com/documentation/mac/Devices/Devices-124.html#HEADING124-0">Data   Structures</A>, (page 3-23 through 3-27), and</li>      <LI><a href="http://developer.apple.com/documentation/mac/Devices/Devices-2.html">Inside   Macintosh: Devices</A>, Chapter 4 "SCSI Manager 4.3"   <a href="http://developer.apple.com/documentation/mac/Devices/Devices-154.html#HEADING154-2">Loading   and Initializing a Driver</A> (page 4-11)</li>      <LI><A HREF = "#SecretsOfThePartitionMap">Secrets of the   Partition Map</A>, earlier in this document.</li></UL><H3><A NAME="ArchitectureOverview"></A>Architecture Overview</H3><P>When it boots from a block device, Mac OS loads thedriver from the device itself. This driver is held in adriver partition (whose<CODE>pmParType</CODE> starts with "Apple_Driver") and isreferenced by an entry in the driver descriptor map (DDM),which is stored in the first device block on the disk. The ROMsearches the DDM to find the appropriate driver, loads thatdriver into memory, and calls it.</P><P>The chaining driver architecture works by installing aspecial driver in place of the standard disk driver. This<STRONG>chaining driver</STRONG> performs its operation(typically it applies a patch to the ROM) and then loads thenext suitable driver in the DDM, in exactly the same way asthe ROM would have. The next driver may be a real diskdriver, or yet another chaining driver.</P><P>The sequence of driversloaded in this way is known as a <STRONG>driverchain</STRONG>. There may be more than one driver chain onthe disk; often, there is onefor each bootable bus possible for that disk. Forexample, a Zip disk may have a chain of SCSI drivers (whose<CODE>pmParType</CODE> is "Apple_Driver43") for use when theZip disk is inserted in a SCSI Zip device, and a chain ofATA drivers (whose <CODE>pmParType</CODE> is"Apple_Driver_ATA") for use when the Zip disk is inserted inan ATA Zip device.</P><P>The last driver in a driver chain does not need tosupport chaining because there is nothing to chain to. Thismeans that you don't need to modify your disk driver tosupport this architecture, as long as the disk driver isalways installed last in the chain.</P><P>One special kind of chaining driver is the <STRONG>patchdriver</STRONG>. This is a driver supplied by Apple that isresponsible for loading and executing system patches out ofa <STRONG>patch partition</STRONG>. Each patch has a<STRONG>patch descriptor</STRONG>, which contains a fourcharacter code that uniquely identifies the patch. Once ithas loaded the patches, the patch driver chains to the nextdriver, as any other chaining driver would.</P><P>In general, you do not needto write a patch driver, or the patches it installs.However, your formattingutility must install the patch driver and the patch partition such that the rightpatches are loaded.</P><H3><A NAME="AvailablePatches"></A>Available Patches</H3><P>Apple supplies both patch drivers and patches todevelopers. The available patch drivers are listed below:</P><UL>   <LI>"PatchChainDriver" -- This patch driver is used when   booting from a SCSI device.</li>      <LI>"ATAPatchChainDriver" -- This patch driver is used   when booting from an ATA device, such as an internal ATA   hard disk.</li>      <LI>"ATAPIPatchChainDriver" -- This patch driver is used   when booting from an ATAPI device, such as an ATAPI   CD-ROM.</li></UL><P>The following patches are available.</P><UL>   <LI><CODE><A NAME="mesh"></A>'mesh'</CODE> -- This patch   fixes a bug in the ROM SCSI Manager's handling of the   MESH chip. It is required to successfully boot on a   machine with that chip.</li>      <LI><CODE><A NAME="scsi"></A>'scsi'</CODE> -- This patch   makes adjustments to the classic SCSI Manager to enable   booting from CD-ROM devices.</li>      <LI><CODE><A NAME="ruby"></A>'ruby'</CODE> -- This patch   installs support for volumes larger than 2 GB on machines   that don't have this support in the ROM.</li>      <LI><A NAME="snag"></A><CODE>'snag'</CODE> -- This patch   implements the "To start up from this CD-ROM, hold down   the C key as the computer starts up" functionality used   in many bootable CD-ROM products. It is only necessary on   pre-ROM-in-RAM computers; ROM-in-RAM computers implement   snag booting in Open Firmware.</li></UL><P>To legally include these patch drivers and patches inyour formatting software, you must license the patches fromApple. Contact<a href="http://developer.apple.com/mkt/registering/swl/swl.shtml">AppleSoftware Licensing</A> for details.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>For experimental and debugging use, you canextract the relevant patch resources from Apple'sDrive Setup utility. Resources of type<CODE>'ptDR'</CODE> hold patch drivers, resourcesof type <CODE>'pDES'</CODE> hold patch descriptors,and resources of type <CODE>'ptch'</CODE> holdpatch code. However, production software mustlicense this resources from Apple forredistribution.</p></TD></TR></TABLE></CENTER><BR><BR><H3>Advice for Formatting Utilities</H3><P>The first thing that a formatting utility must do isdecide how many driver chains need to be constructed. Thisis determined by the number of possible bootable buses forthe disk. For example, a SCSI device can only be attachedvia SCSI, so the utility need only construct one driverchain. In contrast, an removable cartridge disk might beplaced in either a SCSI or ATA mechanism, and thereforemust contain two driver chains,one for SCSI and one for ATA. Moreover, a PowerBook internalATA hard disk device needs to have a SCSI driver chain if itis to work in <A HREF = "#TargetMode">target mode</A>.</P><P>For each driver chain constructed, the formatting utilitymust first create a partition for the patch driver and thencreate a partition for the disk driver itself. When creatingpartitions, the formatting utility must be careful to writethe <A HREF = "#pmPadRevealed">driver signature</A> into the<CODE>pmPad</CODE> field of the <CODE>Partition</CODE> record. Chainingdrivers (including the patch driver) need this signature tocorrectly find the next driver to load. The utility shouldalso be sure to set up the <CODE>pmPartStatus</CODE> fieldaccording to the description in<CODE><A HREF = "#pmPartStatusRevealed">pmPartStatus</A></CODE>Revealed.</P><P>In addition to creating the driver partitions, theformatting utility must also create entries in the DDM withthe appropriate driver type. See<A HREF = "#NewDriverTypes">New Driver Types</A> for a list ofdriver types, and<A HREF = "#ArchitectureInDetail">Architecture in Detail</A>for an explanation of the relationship between them.</P><P>The formatting utility must also construct the"Apple_Patches" partition. Some rules must be observed whendoing this.</P><UL>   <LI>The <CODE>pmPartName</CODE> field of the partition   map entry should be "Patch Partition".</li>      <LI>The <CODE>pmParType</CODE> field of the partition map   entry must be "Apple_Patches".</li>      <LI>The first block of the patch partition contains a   list of the patches in the partition.</li>      <LI>Patches are run in order, so it is necessary to place   patches that are critical to the correct operation of   later patches (like <CODE>'mesh'</CODE> and   <CODE>'scsi'</CODE>) before the less critical ones (like   <CODE>'snag'</CODE>).</li>      <LI>Patch descriptors contain a version number. The   formatting utility should not replace a newer patch with   an older one.</li>      <LI>Patch descriptors are variable length data   structures. You cannot index the list of patches as an   array.</li></UL><P>There are also some non-obvious factors when decidingwhether to install a particular patch on a particular disk.</P><UL>   <LI>The MESH patch (<CODE>'mesh'</CODE>) should be   installed on any disk which might be booted from via   SCSI. In particular, the MESH patch is required on the   internal ATA hard disk on PowerBooks, because it is   possible they might be used to boot a machine while in   <A HREF = "#TargetMode">target mode</A>.</li>      <LI>The <A HREF = "#ruby">large volume support patch</A>   (<CODE>'ruby'</CODE>) is only required if any of the   partitions on the disk are 2 GB or larger.</li>      <LI>Do not install the <CODE>'snag'</CODE> patch on hard   disks! Doing so will prevent the user from snag booting a   CD. This is because, if the C key is held down, the hard   disk <CODE>'snag'</CODE> patch prevents booting from the   CD, while the CD-ROM <CODE>'snag'</CODE> patch prevents   booting from the hard disk.</li></UL><P>Finally, formatting utilities should aim to leave somefree space in the partition maps, driver partitions, andpatch partitions. Drivers and patches grow over time andwasting a few KB now mayradically ease the job of upgrading a driver or patch in the future.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>To be compatible with computers that have theclassic SCSI Manager in ROM, all data that is readby the ROM must be within the first 1 GB of thedisk. This is because the classic SCSI Managerdriver loading code uses 6-byte SCSI commands toread the driver.</p></TD></TR></TABLE></CENTER><BR><BR><H3><A NAME="ArchitectureInDetail"></A>Architecture inDetail</H3><P>This section describes the chaining driver architecturein detail, including how <A HREF = "#ChainingDrivers">chainingdrivers</A> intercept the driver loading process, the<A HREF = "#TheApplePatchDriver">Apple patch driver</A>, and the<A HREF = "#PatchExecution">structure of the patches</A> itloads. To understand this section, you need to understand<A HREF = "#HowTheROMLoadsDiskDrivers">how the ROMloads SCSI and ATA drivers</A>.</P><H4>Pre-Chaining Example</H4><P>The following diagram shows how a partition map might belaid out prior to the introduction of chaining drivers. Thisexample includes both ATA and SCSI drivers, a setup which isuseful for disks that can be mounted in both ATA and SCSImechanisms. Some salient features are:</P><UL>   <LI>The sample SCSI driver   has a driver signature of <CODE>'QSCZ'</CODE>, and the   sample ATA driver has a driver signature of   <CODE>'QATA'</CODE>.</li></UL><P align=center><img src="images/tn1189_003.gif" alt="tn1189.gif.3" width=528 height=879 align=bottom></P><H4><A NAME="ChainingDrivers"></A>Chaining Drivers</H4><P>The basic idea behind chaining drivers is very simple. Achaining driver appears to the ROM as the actual diskdriver. It has a DDM entry ofthe appropriate type (<CODE>kDriverTypeMacSCSI</CODE> forSCSI, <CODE>kDriverTypeMacATA</CODE> for ATA) and it has a partition with theappropriate type ("Apple_Driver43" for SCSI,"Apple_Driver_ATA" for ATA). The ROM finds, loads, andexecutes the chaining driver as if it was the real diskdriver. The chaining driver does its operation (patching,password protection, and so on) and then finds, loads andexecutes the next driver in the driver chain. This processis repeated once for each driver in the chain.</P><P>The first chaining driver in a driver chain always hasthe <CODE>ddType</CODE> expected by the ROM(<CODE>kDriverTypeMacSCSI</CODE> for SCSI,<CODE>kDriverTypeMacATA</CODE> for ATA). Subsequent driversin the driver chain have their <CODE>ddType</CODE> set tothe two's complement of the standard value(<CODE>kDriverTypeMacSCSIChained</CODE> for SCSI,<CODE>kDriverTypeMacATAChained</CODE> for ATA).</P><P>There are a number of important implementation detailsfor chaining drivers.</P><UL>   <LI>All drivers in the chain,   except the first, must have the <CODE>kPartitionIsChainCompatible</CODE> bit set in the <CODE>pmPartStatus</CODE> field of their partition map entries to   indicate that they can be chained to (they don't have to   be loaded directly by the ROM). The first driver may have   this bit set, although it is not required.</li>      <LI>A chaining driver must always   have the <CODE>kPartitionCanChainToNext</CODE> bit set in the <CODE>pmPartStatus</CODE> field of its partition map entry. While   this bit is not actually needed for the chaining driver   to be loaded, formatting utilities may use the bit to   determine the required order of drivers in the   DDM.</li>      <LI>A chaining driver may also   contain the real disk driver. If it does, it should have   the <CODE>kPartitionIsRealDeviceDriver</CODE> bit set in the <CODE>pmPartStatus</CODE> field of its partition map entry.   </li>   <LI>The ROM loads the chaining driver exactly as it would   a normal driver. Therefore, if a   chaining SCSI driver wants to have its   <A HREF = "#DriverChecksums">checksum</A> validated by the   ROM, it must set the first four bytes of its partition   map entry <CODE>pmPartName</CODE> field to "Maci".</li>      <LI>A chaining driver must find the next driver to load   using the following algorithm.      <OL><LI>First, the chaining driver should search thepartition map for its own partition map entry. It candistinguish itself from other drivers by looking forits driver signature in the <CODE>pmPad</CODE> field.</li><LI>Then, the driver should look up its entry in theDDM. It can find itself by matching the<CODE>pmPyPartStart</CODE> field of its partition mapentry to the <CODE>ddBlock</CODE> field of its<CODE>DDMap</CODE>.</li><LI>It can then find the <CODE>DDMap</CODE> of thenext driver in the driver chain by searching onwardsfrom its own <CODE>DDMap</CODE> for a<CODE>DDMap</CODE> with the appropriate<CODE>ddType</CODE>. In this case, appropriate iseither the two's complement of the chaining driver's<CODE>ddType</CODE> (if the chaining driver is firstin the chain), or the same <CODE>ddType</CODE> as thechaining driver (if the chaining driver is subsequentin the chain).</li>   </OL></li>      <LI>There may be no next driver to load. The chaining   driver should treat this as an error, and handle it as   described below.</li>      <LI>A chaining driver must load and execute the next   driver exactly as the ROM would have. The exact details   are covered in the   <A HREF = "#HowTheROMLoadsDiskDrivers">previous   section</A>. Note that the chaining driver must:      <OL><LI>checksum the driver, as described in<A HREF = "#DriverChecksums">Driver Checksums</A>, and</li><LI>remember which of its entry point was called(primary or secondary) and call the same entry pointfor the next driver, and</li><LI>call the next driver with registers A0, D5, and D7set exactly as they were when the chaining driver wascalled.</li><LI>handle any errorreturned by the next driver as described below.</li>   </OL></li>      <LI>A chaining driver may need to increase the size of   the system heap to allow it to allocate enough memory to   load the next driver. See   <A HREF = "#DiskDriversAndTheSystemHeap">Disk Drivers and   the System Heap</A> for details on doing this.</li></UL><P><A NAME="ChainingDriverErrorHandling"></A>How thechaining driver handles errors depends on whether thechaining driver precedes the disk driver in the driverchain. If the chaining driver precedes the disk driver, anyerror loading the next driver, or any error returned by thenext driver's entry point, is fatal. The chaining drivershould return <CODE>ioErr</CODE> from its entry point.However, if the chaining driver is the disk driver (both<CODE>kPartitionCanChainToNext</CODE> and <CODE>kPartitionIsRealDeviceDriver</CODE>are set in its <CODE>pmPartStatus</CODE>) or comes after thedisk driver, any error loading the next driver is not fatal,and the chaining driver should return <CODE>noErr</CODE>regardless of any error loading the next driver in thechain.</P><P>The following diagram shows how a partition map might belaid out for a disk that can only be booted on an ATA busand which has a chaining driver. Some salient features are:</P><UL>   <LI>The DDM has the chaining   driver first, followed by the disk driver (with a negated   <CODE>ddType</CODE>).</li>      <LI>The chaining flags are   set in the <CODE>pmPartStatus</CODE> fields of the   chaining driver's and the disk driver's partition map   entry.</li></UL><P align=center><img src="images/tn1189_004.gif" width=528 height=879 align=bottom alt="tn1189.gif.4"></P><H4><A NAME="TheApplePatchDriver"></A>The Apple Patch Driver</H4><P>The Apple patch driver is a chaining driver supplied byApple that loads patches from a special partition on thedisk. You must <A HREF = "#AvailablePatches">license the patchdriver and its accompanying patches</A> for inclusion withyour disk driver software. This section describes theoperation of the patch driver insofar as is necessary foryou to write a formatting utility that correctly installsthe patches.</P><P>Typically, the patch driver is installed first in thedriver chain. It finds the patch partition by searching thepartition map for an entry whose type is "Apple_Patches". Itthen walks the patch partition, loading and executing thepatches. Finally, it chains to the next driver.</P><P>The patch partition is structured to contain multiplepatches. The first block of the patch partition contains a<STRONG>patch list</STRONG>, a description of all thepatches in the partition. The patch list is defined by the<CODE>PatchList</CODE> structure.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct PatchList {    UInt16 numPatchBlocks;    UInt16 numPatches;    PatchDescriptor thePatch[1];};typedef struct PatchList    PatchList;typedef PatchList *PatchListPtr;</pre></TD></TR></TABLE></CENTER><BR><BR><P>The fields have the following meaning:</P><DL>   <DT><CODE>numPatchBlock</CODE></dt>      <DD><P>The number of <EM>device blocks</EM> used to hold the   patch list. The patch driver must load this many blocks   from the start of the patch partition to ensure that it   has all the patch descriptors.</p></dd>      <DT><CODE>numPatches</CODE></dt>      <DD><P>The number of patch descriptors contained in the   patch list.</p></dd>      <DT><CODE>thePatch</CODE></dt>      <DD><P>The patch descriptor describing the first patch in   the patch list.</p></dd></DL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Each patch descriptor is of variable size, soyou can't index <CODE>thePatch</CODE> as an array.</p></TD></TR></TABLE></CENTER><BR><BR><P>Each patch in the patch list is described by the<CODE>PatchDescriptor</CODE> data type.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct PatchDescriptor {    OSType patchSig;    UInt16 majorVers;    UInt16 minorVers;    UInt32 flags;    UInt32 patchOffset;    UInt32 patchSize;    UInt32 patchCRC;    UInt32 patchDescriptorLen;    Str32  patchName;    UInt8  patchVendor[1];};typedef struct PatchDescriptor  PatchDescriptor;typedef PatchDescriptor * PatchDescriptorPtr;typedef PatchDescriptorPtr *    PatchDescriptorHandle;&nbsp;enum {    kRequiredPatch = 0x00000001;};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The fields have the following meaning:</P><DL>   <DT><CODE>patchSig</CODE></dt>      <DD><P>A four-character code that uniquely identifies the   patch. If you create your own patches, you must use a   <a href="http://developer.apple.com/dev/cftype/">registered   creator code</A>.</p></dd>      <DT><CODE>majorVers</CODE></dt>      <DD><P>A major version number. Typically this is 1.</p></dd>      <DT><CODE>minorVers</CODE></dt>      <DD><P>A minor version number. Typically this is 0. This   combines with the major version number to indicate a   version of the form 1.0, 1.1, and so on.</p></dd>      <DT><CODE>flags</CODE></dt>      <DD><P>A set of flags for the patch. The only bit currently   defined is <CODE>kRequiredPatch</CODE>. If this is set,   the patch must succeed for the system to continue   booting. See the section on   <A HREF = "#PatchDriverErrorHandling">error handling</A>   below. All other bits are reserved and must be set to   zero.</p></dd>      <DT><CODE>patchOffset</CODE></dt>      <DD><P>The offset, in <EM>device blocks</EM>, from the   beginning of the patch partition to the patch code.</p></dd>      <DT><CODE>patchSize</CODE></dt>      <DD><P>The actual size of the patch code in bytes.</p></dd>      <DT><CODE>patchCRC</CODE></dt>      <DD><P>A checksum for the patch. This is calculated   using the <A HREF = "#DriverChecksums">16-bit driver   checksum algorithm</A>.</p></dd>      <DT><CODE>patchDescriptorLen</CODE></dt>      <DD><P>The total length, in bytes, of this patch descriptor.   The minimum value for this field is   <CODE>sizeof(PatchDescriptor)</CODE>, which is 62 bytes.   This value of this field must be even.</p></dd>      <DT><CODE>patchName</CODE></dt>      <DD><P>A human-readable name for the patch. This name is   never displayed to users or used by the system. It is   present for debugging and diagnosis only.</p></dd>      <DT><CODE>patchVendor</CODE></dt>      <DD><P>A human-readable description of the patch vendor.   This name is never displayed to users or used by the   system. It is present for debugging and diagnosis only.   This string may be followed by an arbitrary amount of   patch-specific data.</p></dd></DL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Previous versions of the patch partitiondocumentation described <CODE>patchName</CODE> as a<CODE>Str31</CODE> (actually, an array of 32<CODE>UInt8</CODE>s), which implied that<CODE>patchVendor</CODE> started at offset 60 inthe structure. This is incorrect. The<CODE>patchName</CODE> field is a<CODE>Str32</CODE> and <CODE>patchVendor</CODE>starts at offset 61. Note that this is an exceptionto the general rule that Pascal strings are notsupposed to be placedat odd offsets in a structure.</P></TD></TR></TABLE></CENTER><BR><BR><P>In addition, because of the aforementioned error, theminimum value for the<CODE>patchDescriptorLen</CODE> field is 62, not 61as previously documented.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Previous versions of the patch partitiondocumentation stated that<CODE>patchDescriptorLen</CODE> must be a multipleof 4. This is contradicted by observed behavior.</p></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Apple patches generally use "\pApple Computer,Inc." in the <CODE>patchVendor</CODE> field andhave no patch-specific data. This results in a<CODE>patchDescriptorLen</CODE> of 82, which is 62+ <CODE>PLstrlen(patchVendor)</CODE>.</p></TD></TR></TABLE></CENTER><BR><BR><P>When the patch driver executes a patch, it does so bycreating a new pointer block in the system heap which islarge enough to hold the patch, reading the patch code intothat block, and then calling the patch entry point (thefirst byte of the memory block) using the callingconventions described in the <A HREF = "#PatchExecution">nextsection</A>.</P><P>As part of its operation, the patch driver<A HREF = "#DiskDriversAndTheSystemHeap">increases the size ofthe system heap</A> to accommodate the size of the patchesloaded.</P><H4><A NAME="PatchDriverErrorHandling"></A>Patch DriverError Handling</H4><P>Error handling in the patch driver follows the generaloutline for <A HREF = "#ChainingDriverErrorHandling">errorhandling in chaining drivers</A>. Specifically, an error isclassified as either fatal or non-fatal. For a fatal error,the patch driver discards the current patch descriptor andpatch code (if any) and returns <CODE>ioErr</CODE> from itsentry point, which indicates to the system that this disk isunusable. Fatal errors include:</P><UL>   <LI>failure to load a required patch (one whose patch   descriptor's <CODE>flags</CODE> field has   <CODE>kRequiredPatch</CODE> set),</li>      <LI>a positive result from a required patch,</li>      <LI>a negative error result from any patch, and</li>      <LI>failure to load the next driver (the patch driver is   always loaded first in the driver chain, so a failure to   load the next driver is always a fatal error).</li></UL><P>For a non-fatal error, the patch driver simply discardsthe patch descriptor and patch code for the patch andcontinues trying to load the next patch (if any) or the nextdriver in the driver chain. Non-fatal errors include:</P><UL>   <LI>inability to load a non-required patch, and</li>      <LI>a positive error result from a non-required patch.</li></UL><H4><A NAME="PatchExecution"></A>Patch Execution</H4><P>The prototype for a patch's entry point is given below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal OSErr MyPatch(PatchDescriptorPtr myPatch, DeviceIdent myDevID);</pre></TD></TR></TABLE></CENTER><BR><BR> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Previous versions of the patch partitiondocumentation incorrectly documented this prototypeas using C calling conventions and having a<CODE>long</CODE> return result. This documentationis correct.</p></TD></TR></TABLE></CENTER><BR><BR><P>The parameters to the entry point are:</P><DL>   <DT><CODE>myPatch</CODE></dt>      <DD><P>A pointer to the patch's patch descriptor. The patch   can use this pointer to extract patch-specific   information from <CODE>patchVendor</CODE> part of the   patch descriptor. The memory containing the patch   descriptor will be deallocated after the patch returns;   the patch is responsible for copying any information it   needs to retain.</p></dd>      <DT><CODE>myDevID</CODE></dt>      <DD><P>A device identifier which identifies the device from   which the patch was loaded. The   <CODE><A HREF = "#diReserved">diReserved</A></CODE> field   of this parameter can be used to distinguish whether this   is a SCSI <CODE>DeviceIdent</CODE> or a   <CODE>DeviceIdentATA</CODE>.</p></dd>      <DT><I>result</I></dt>      <DD><P><CODE>noErr</CODE>, if the patch was successful. The   patch driver will dispose of the patch descriptor but   leave the patch code in memory. A positive error code, if   the patch encountered a non-fatal error. A negative error   code, if the patch encountered a fatal error. See the   description of <A HREF = "#PatchDriverErrorHandling">patch   driver error handling</A> for details.</p></dd></DL><P>The patch's code is alwaysloaded in the system heap. The patch's entry point is alwayscalled at system task time.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>A patch must try to minimize any assumptionsabout its environment. Specifically:</P></TD></TR></TABLE></CENTER><BR><BR><UL>   <LI>A patch should not assume that it was loaded   from an ATA or SCSI device. For example, a   SCSI-specific patch should behave correctly if   it is loaded from an ATA device. This can happen   if the patch is installed on a removable   cartridge disk that can be mounted in both ATA   or SCSI devices.</li>      <LI>A patch should not assume the existence of   optional system software capabilities. For   example, a SCSI Manager 4.3 specific patch   should not assume that SCSI Manager 4.3 is   present. It is possible for an external device   to be moved from a machine with SCSI Manager 4.3   to a machine without it, and vice versa.</li>      <LI>Because of the above, patches should avoid   loading data from the disk. If your patch needs   data, you should add the data after the   <CODE>patchVendor</CODE> field of your patch   descriptor.</li>      <LI>Patches are loaded very early in the startup   sequence and must allocate memory as outlined in   <A HREF = "#DiskDriversAndTheSystemHeap">Disk   Drivers and the System Heap</A>.</li>      <LI>A patch should work correctly even if it is   loaded twice. For example, if the same patch is   installed on multiple SCSI devices, both patches   will be executed at startup time and the patches   must coordinate to avoid any conflicts.</li></UL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The <CODE>myDevID</CODE> parameter is a truedevice identifier, even if the patch is beingloaded on a system without SCSI Manager 4.3 in theROM. In that case, the patch driver is responsiblefor synthesizing the device identifier from theSCSI ID. A full explanation of the driver's variousentry points is given in an<A HREF = "#HowTheROMLoadsDiskDrivers">earliersection</A>.</p></TD></TR></TABLE></CENTER><BR><BR><P>Because a patch's code is always loaded in a pointerblock in the system heap, it can reduce its size in memoryusing clever code sorting and <CODE>SetPtrSize</CODE>. Forexample, imagine a patch that has 5 KB of install code and25 KB of resident code. The patch can reduce its memoryfootprint by sorting the code as shown below.</P><P align=center><img src="images/tn1189_005.gif" alt="tn1189.gif.5" width=240 height=297 align=bottom></P><P>The following code snippet shows how this might beachieved in C.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal OSErr MyPatch(PatchDescriptorPtr myPatch, DeviceIdent myDevID){    OSErr err;    err = MyInstall(myPatch, myDevID);    SetPtrSize( (Ptr) &amp;MyPatch, (UInt32) &amp;MyInstall - (UInt32) &amp;MyPatch     );    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>If you use this technique, be sure to generatea link map and check that the code order matchesyour expectations. Your development environmentmight reorder code in an unexpected way.</p></TD></TR></TABLE></CENTER><BR><BR><H4>Putting It All Together</H4><P>The following diagram shows the layout of a disk that canbe booted via SCSI and ATA.</P><UL>   <LI>The DDM has two patch chains, one for ATA booting and   one for SCSI booting.</li>      <LI>Each patch chain starts with the appropriate Apple   patch driver.</li>      <LI>The first block of the "Apple_Patches" partition   contains a list of patches to be installed on the   machine. The remaining blocks contain the code for the   patches themselves.</li>      <LI>The <CODE><A HREF = "#mesh">'mesh'</A></CODE> patch is   installed to ensure correct operation when booted via   SCSI on a machine with the MESH chip.</li>      <LI>The <CODE><A HREF = "#ruby">'ruby'</A></CODE> patch is   installed to allow booting on machines without large   volume support in ROM. Note that the total disk size in   this example is 5 GB. On the smaller disks used in the   previous examples, the <CODE>'ruby'</CODE> patch would   not be necessary.</li></UL><P align=center><img src="images/tn1189_006.gif" width=531 height=1378 align=bottom alt="tn1189.gif.6"></p><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="DiskDriversAndTheSystemHeap"></A></P><H2>Disk Drivers and the System Heap</H2><P>Disk drivers typically allocate their memory in thesystem heap. A disk driver must use one of three techniquesto allocate system heap space, depending on the executioncontext. There are three relevant execution contexts foryour driver:</P>    <OL TYPE=1 START=1> <LI>Driver Load Time -- If you driver is bootable, it is  called at driver load time to install itself in the unit  table.</li>   <LI>System Startup -- It is possible for your driver to   be called at system startup time, after driver load time   but before system startup is complete. For example, if   your driver sets <CODE>dNeedTime</CODE> and some startup   code (for example, an <CODE>'INIT'</CODE>) brings up a   dialog, your driver will receive   <CODE><A HREF = "#accRun">accRun</A></CODE> requests.</li>      <LI>After System Startup -- System startup time finishes   when the Process Manager starts and launches the Finder.</li>    </ol><P>The best way to detect whether system startup is completeis to compare the first byte (the length) of the Pascalstring returned by <CODE>LMGetCurApName</CODE> to <CODE>$FF</CODE>. Ifthe first byte is <CODE>$FF</CODE>, the system is still starting up. Ifit is any other value, system startup is complete.</P><P>There is no good way to distinguish between driver loadtime and system startup time. Your driver must rememberinternally whether it is executing as a result of itsinstall routine being called.</P><H3>Driver Load Time</H3><P>At driver load time, a driver that needs to allocate alarge amount of memory must grow the system heap using<CODE>SetApplBase</CODE>. This system routine is documentedas<a href="http://developer.apple.com/documentation/mac/Memory/Memory-144.html">InsideMacintosh: Memory</A>, along with a warning thatapplications should not use it. However, it is expected thatdisk drivers which need to expand the system heap will usethis routine.</P><P>A simple example of calling <CODE>SetApplBase</CODE> isshown below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static void ExpandSystemHeap(Size bytesToGrow){    THz currentZone;&nbsp;    // Only try to expand the system heap if we're at startup time,    // ie the CurApName is still filled with $FFs.    assert( LMGetCurApName()[0] == 0xFF );    // from &lt;assert.h&gt;&nbsp;    currentZone = GetZone();&nbsp;    // Round up the request to 512 bytes.    bytesToGrow = (bytesToGrow + 0x01FF) &amp; ~0x01FF;    // Set the system heap to the specified size.    SetApplBase((Ptr)((UInt32) (LMGetSysZone())-&gt;bkLim + bytesToGrow));    SetZone(currentZone);}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Disk drivers should not attempt to grow thesystem heap too much using this mechanism. How muchis too much? It depends on a lot of factors,including the machine's ROM software, the systemversion, whether virtual memory is turned on, whichpatches are being loaded, and which other devicedrivers are installed.</P><P>For example, on Mac OS 8.1 the system heap cangrow to a maximum of 4 MB during this early phaseof the startup process and this limit was exceededwhen certain PCI RAID cards were installed. Whilethis problem was worked around before Mac OS 8.1shipped, it is an important lesson for developersof software that runs during the early startupprocess. There <EM>is</EM> a system heap limit andthere is no allocation policy for what memory isavailable.</P><P>In the absence of a formal policy, DTSrecommends that each individual developer limittheir system heap expansion to less than 256 KBduring this early startup phase. This includes theexpansion done by the system to load your code. Ifnecessary, you must compromise on the speed of yourdriver to achieve this goal. If you need morememory to improve performance, you must either:</P><UL>   <LI>install a system extension with an   <CODE>'INIT'</CODE> resource, which grows the   system heap (as described below), and turns that   memory over to your driver, or</li>      <LI>wait until your driver receives an   <CODE><A HREF = "#accRun">accRun</A></CODE>   Control request and allocate your extra memory   then.</li></UL></TD></TR></TABLE></CENTER><BR><BR><H3>System Startup</H3><P>Disk drivers that load as part of the <CODE>'INIT'</CODE>loading process should request that the system heap be grownusing a <CODE>'sysz'</CODE> resource, as documented in<a href="http://developer.apple.com/documentation/mac/Memory/Memory-58.html">InsideMacintosh: Memory</A> and<a href="http://developer.apple.com/documentation/mac/OSUtilities/OSUtilities-192.html">InsideMacintosh: Operating System Utilities</A>, and amended inTechnote IM 2<a href="../im_errata/im_errata_02.html">InsideMacintosh: Memory Errata</A>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR><CODE>'INIT'</CODE> resources should not expandthe system heap using <CODE>SetApplBase</CODE>. TheStart Manager has open resource files whoseresource maps reside in the application zone andthere is no supported way to close and reopen theseresource files.</p></TD></TR></TABLE></CENTER><BR><BR><H3>After Startup Time</H3><P>After the system has started up, a disk driver shouldallocate its system heap memory using<CODE>NewPtrSys</CODE>, or <CODE>NewHandleSys</CODE>. Thesystem heap will automatically expand to meet theserequirements.</p><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="PowerPCNativeDiskDrivers"></A></P><H2>PowerPC Native Disk Drivers</H2><P>Many developers wish to implement their disk drivers inPowerPC native code. However, there is no well-definedarchitecture for native disk drivers. There are a number ofconsequences and drawbacks, which this section discusses indetail.</P><H3>The Need for Speed</H3><P>Most drivers are I/O bound. They spend a small amount oftime setting up an I/O request and a proportionally muchlarger amount of time waiting for the underlying hardware tocomplete that request. Such drivers receive very littlebenefit from executing as native code.Moreover, the benefit varies depending on the ratioof small I/O requests (which tend to be CPU bound) to largeI/O requests (which tend to be I/O bound).</P><P>On the other hand, some drivers are CPU bound. Forexample, a driver that encrypts data as it transfers it tothe disk may spend a significant amount of time executingdriver code. This may even be true for a complex, but stillI/O focused driver, such as a RAID driver or a caching diskdriver. These drivers may receive significant benefit from"going native."</P><P>The only good way to tell whether your driver receives abenefit from conversion to native code, and that the benefitis enough to overcome the difficulties in doing so, is toactually profile the code. You may be able to do thisquickly by profiling the driver code in an applicationframework before facing the challenges of creating a workingnative driver.</P><H3>Difficulties with Taking Your Driver Native</H3><P>The primary difficulty in creating a native disk driveris that there is no well-defined architecture for it. ThePCI-native driver model has a number of drawbacks for diskdriver developers.</P><OL>   <LI>It does not include a   disk driver I/O family expert. It is possible to write a   generic native driver   (<CODE>kServiceCategoryNdrvDriver</CODE>) which acts as a   disk driver, but it is not possible to do so within the   native driver architecture. Specifically, a disk driver   must link to InterfaceLib to access routines like   <CODE>AddDrive</CODE>. Linking to InterfaceLib works just   fine on the current Mac OS, but it is not legal within   the native driver model and guarantees that your driver   will not be compatible with any future Mac OS that   emulates this model on a non-traditional framework.</li>      <LI>The PCI native driver model is not available on   older, non-PCI-based, Power Macintosh computers.</li></OL><P>Another possible approach is to implement a partiallynative driver, where code that you know to take a long timeis implemented as native code. This makes a lot of sense insome cases, such as an encryption driver, where the lengthycode is easily isolated from the rest of the driver.</P><P>It is also possible to implement a virtually fully nativedriver without the PCI native driver module, using only atiny amount of 68K glue code to provide the driver headerand an interface to <CODE>IODone</CODE>. In general, thisapproach is not recommended by DTS because of thecomplexities involved in transitioning from 68K to nativecode and back.</P><P>When taking a disk driver native, it is important toremember that the primary client of the disk driver is theFile Manager, which is not native. While it is likely that adisk driver will incur Mixed Mode switches regardless ofwhether it is native or not (the SCSI Manager and ATAManager are native), taking the driver native shifts theline where the switches occur, and may increase or decreasethe number of switches depending on how your driver works.So, to guarantee an overall speed improvement, it isimportant that the native driver be significantly fasterthan the emulated one.</P><H3><A NAME="accRun"></A>Native Drivers and accRun</H3><P>Before implementing a disk driver as a native driver, youmust read DTS Q&amp;A DV 35, <a href="../../qa/dv/dv35.html">"NativeDrivers (<CODE>'ndrv'</CODE>s) and<CODE>dNeedTime</CODE>"</A>, which describes anincompatibility between native drivers and<CODE>dNeedTime</CODE>.</P><P>The rest of this technote assumes that you are building a68K driver, and thus you can set <CODE>dNeedTime</CODE> in<CODE>dCtlFlags</CODE> to get system task time via the<CODE>accRun</CODE> Control request. If you are building anative driver and you need system task time, you mustimplement one of the alternative mechanisms described in theQ&amp;A.</P><P>68K drivers should continue to use <CODE>dNeedTime</CODE>as always.</P><H3>Recommendations</H3><P>DTS does not recommend that developers implement diskdrivers in PowerPC native code unless there is clearevidence that doing so improves the performancesignificantly. Typically this is only for drivers that areCPU bound, such as encrypting drivers. A standard SCSI orATA driver is I/O bound, and receives little benefit fromrunning native.</P><P>The easiest way to implement a PowerPC native driver isusing the native driver model, introduced with the PCI-basedPower Macintosh computers. However, this approach will notwork on older Power Macintosh computers. Another recommendedalternative is to implement a partially native driver, wherecore functionality (such as anencryption engine) is in native code.</p><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="InstallingAndRemovingDriversAndDrives"></A></P><H2>Installing and Removing Drivers and Drives</H2><P>Over the course of the past 15 years, Mac OS has evolvedfrom a relatively static environment -- a Mac with one ortwo floppy drives that neededto be connected at startup time -- to a highly dynamicsystem, where devices and disks come and go at runtime. TheMac OS disk driver architecture has, to a large extent, coped with this evolution, as long asdriver writers play by the rules. This section explainsthese rules in detail.</P><H3>Installing and Removing Drivers</H3><P>There are a number of waysto install your disk driver.</P><OL>   <LI>If you're writing a native driver that controls a   real piece of hardware (a FireWire   device, or a PCI RAM disk card, for example), you   can set up your <CODE>DriverDescription</CODE> so that   the system automatically finds and opens your device   driver. See   <A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">Designing   PCI Cards and Drivers for Power Macintosh Computers</A>   for details.</li>      <LI>If you're writing a native driver with no   corresponding hardware, you can use DriverLoaderLib to   install your driver directly. See   <A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">Designing   PCI Cards and Drivers for Power Macintosh Computers</A>   for details.</li>      <LI>If you're writing a 68K driver,   you should use TradDriverLoaderLib to install your   driver. Installing a driver in the unit table is easy to   do half right but tricky to do exactly right, which is   why DTS strongly recommends that developers use   TradDriverLoaderLib. The only exception is boot disk   drivers, where the limited scope of the task makes the   general nature of TradDriverLoaderLib seem a little too   much. See <A HREF = "#CodeSharing">Code Sharing</A> for   more details on this.</li></OL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>TradDriverLoaderLib is a DTS sample thatprovides similar functionality to DriverLoaderLib,except that it works for 68K drivers rather thannative drivers. You can <A HREF = "ftp://ftp.apple.com//developer/Sample_Code/Devices_and_Hardware/Drivers/TradDriverLoaderLib.sit">download the sample via FTP</A>.</p></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>Disk drivers, which can be called at interrupttime, must never be installed as RAM-based drivers(<CODE>dRAMBased</CODE> must not be set in<CODE>dCtlFlags</CODE>); paradoxically, diskdrivers are always "ROM-based." TradDriverLoaderLibtakes care of this and many other details ofloading a driver.</p></TD></TR></TABLE></CENTER><BR><BR><P>To remove a disk driver from the unit table, you have anumber of choices.</P><OL>   <LI>If the driver is a native driver, you must use the   DriverLoaderLib routine <CODE>RemoveDriver</CODE> to   remove it.</li>      <LI>If the driver is a 68K driver, you should have   installed it using <CODE>TradDriverLoaderLib</CODE>. If   so, you can remove it using the   <CODE>TradRemoveDriver</CODE> routine provided by that   library.</li>      <LI>If the driver was not installed using   TradDriverLoaderLib (either because it was a boot disk   driver or because it wasn't installed by your software),   you should follow the procedure described in the   <A HREF = "#HostileTakeovers">Hostile Takeovers</A> section   of this document.</li></OL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>You must <STRONG>never remove a driver that has drives inthe drive queue</STRONG>. Doing so will cause thesystem to crash.</p></TD></TR></TABLE></CENTER><BR><BR><H3><A NAME="CodeSharing"></A>Code Sharing</H3><P>Code sharing is a technique used by some third-party diskdrivers to share the device driver code between multipledrivers in the unit table. Code sharing is a legaltechnique, although it is not implemented by Apple diskdrivers and is not recommended by DTS. Before shipping adriver that uses code sharing, you need to understand thecosts and benefits of the technique.</P><H4>How Code Sharing Works</H4><P>The basic algorithm for code sharing is as follows:</P><OL>   <LI>When your driver installs itself, it first scans the   unit table to see whether another instance of it is   already installed.</li>      <LI>If there is an existing instance, you must check its   version number to determine whether to use its code or   replace its code with the code in your driver. You can   get the driver's version using a Driver Gestalt   <CODE>kdgVersion</CODE> request.</li>      <LI>If the existing driver is older, you must somehow   dispose of its code and replace it with yours. As there   is no Apple-defined way of replacing   <CODE>'DRVR'</CODE>s, you must use a private hand-off   technique built in to your driver. Alternatively, you   might consider not sharing code in this case.</li>      <LI>If the existing driver is newer, you must somehow   inform it that another instance of it is being created.   Again, there is no Apple-defined technique for this; this   information exchange is private to your driver.</li></OL><P>In addition, drivers that implement code sharing mustreference count the code in order to support<A HREF = "#CloseAndPurge">close and purge</A> correctly.</P><H4>The Pros and Cons of Code Sharing</H4><P>Code sharing has one big advantage: it reduces memoryusage if two devices controlled by your driver are attachedto the system. This may be especially significant for acomplex device driver, such as a RAID driver.</P><P>The disadvantages of code sharing include:</P><UL>   <LI>The standard library for installing   <CODE>'DRVR'</CODE>s, TradDriverLoaderLib does not   support code sharing. If you implement code sharing, you   must do this leg work yourself.</li>      <LI>Supporting code sharing significantly complicates the   installation code path of your driver. As the   installation code is run very early in the startup   sequence, bugs in that code are often very hard to debug.</li>      <LI>Drivers that use code sharing cannot be   <A HREF = "#SupportingReopen">reopened</A>.</li></UL><H3>Managing Drive Queue Elements</H3><H4>The Basics</H4><P>The drive queue and its associated drive queue elementsare documented in<a href="http://developer.apple.com/documentation/mac/Files/Files-2.html">InsideMacintosh: Files</A>,<a href="http://developer.apple.com/documentation/mac/Files/Files-112.html">page2-85</A>. However, that document does not describe how drivequeue elements are created, installed, removed, anddestroyed.</P><P>Your disk driver must add a drive queue element for eachfile system partition on each disk it controls. The strategyyou use for managing drive queue elements is largely up toyou, within some basic constraints. Drive queue elementsmust be allocated in the system heap, primarily so that theypersist throughout the life of the system but also, in thecase of paging devices, so that they are held resident inmemory. Typically, your driver is responsible for creatingand disposing the drive queue elements under your control.</P><P>One popular technique for managing drive queue elementsis to extend the <CODE>DrvQEl</CODE> data structure with theextra per-drive storage needed by your driver. This makes iteasy for you to find your per-drive storage structure giveneither the <CODE>DrvQElPtr</CODE> (just cast the<CODE>DrvQElPtr</CODE> to a pointer to your per-drivestorage structure) or the drive number (search the drivequeue looking for that drive number, which gives you the<CODE>DrvQElPtr</CODE>, and then proceed as before).</P><P>Another important thing to remember about drive queueelements is that the system requires that you implementfour flag bytes immediatelybefore the first field of the<CODE>DrvQEl</CODE>. You can choose to either define theseflags as part of your per-drive storage structure (whichcomplicates the cast between it and a <CODE>DrvQElPtr</CODE>), orjust handle those flags as a special case.</P><P>When creating a drive queue element, you must firstdecide on the drive number for the new drive. The algorithmto find a free drive number is very simple: start with drivenumber 5 (or, by convention, 8 if you're a hard diskdriver), check to see whether it is in use, and if so,increment the number and try again.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>This algorithm must be run at system task timeto work reliably.</p></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Drive numbers below 5 are reserved. A third-party disk driver should not use drive numbers lessthan 5 except in special circumstances. As anexample, a floppy disk driver that provides high-fidelityemulation of Apple's ".Sony" driver, might want touse drive number 1.</p></TD></TR></TABLE></CENTER><BR><BR><P>Once your driver has created a drive queue element, itcan put it in the drive queue with the system routine<CODE>AddDrive</CODE>. <CODE>AddDrive</CODE> is a very thinwrapper around <CODE>GetDrvQHdr</CODE> and<CODE>Enqueue</CODE>. It is not strictly necessary to usethis routine, but it may be convenient.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Prior to Mac OS 8.5, the PowerPC glue for<CODE>AddDrive</CODE> in InterfaceLib was broken.The MoreInterfaceLib module of the DTS MoreIsBettersample shows how to correctly call<CODE>AddDrive</CODE> from PowerPC code.</p></TD></TR></TABLE></CENTER><BR><BR><P>Once your driver has created a drive queue element, itshould inform the system of its existence, as described in<A HREF = "#CooperatingWithFSM">Cooperating with File SystemManager</A>.</P><H4>Removing a Drive Queue Element</H4><P>Removing a drive queue element is somewhat moreconvoluted than adding one. The basics are very simple. Thesystem doesn't define a <CODE>RemoveDrive</CODE> routine;you must remove a drive queue element using the code shown below. Compilable source is available aspart of the MoreDisks module of the DTS sample code libraryMoreIsBetter.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal OSErr MoreRemoveDrive(DrvQElPtr drvQEl){    OSStatus err;    if ( MoreVolumeMountedOnDrive(drvQEl-&gt;dQDrive, false) == 0 ) {  err = Dequeue( (QElemPtr) drvQEl, GetDrvQHdr());    } else {  err = volOnLinErr;    }    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>You must <STRONG>never remove a drive queueelement for a drive which has mountedvolumes</STRONG>. Doing so will cause the system tocrash, with possible data loss.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>You should <STRONG>never add or remove drivequeue elements at interrupt time</STRONG>. For astart, <CODE>AddDrive</CODE> is not<a href="tn1104.html">documentedto be interrupt safe</A>. Furthermore, system tasktime code may be walking the drive queue, lookingat elements in thequeue. If your interrupt-timecode removes the drive queue element whilesystem task time code is looking at it, the systemmay crash.</P></TD></TR></TABLE></CENTER><BR><BR><P>It is also important to remember that, if yourdisk driver can be called asynchronously, it ispossible for even synchronous requests to beexecuted at interrupt time. See Technote 1067, <a href="tn1067.html">"TraditionalDevice Drivers: Sync or Swim</A>."</P><P>Consequently, your driver should never add orremove a drive queue element except in its Open orClose entry point, or in response to an immediaterequest that it knows was made at system task time,such as an<CODE><A HREF = "#accRun">accRun</A></CODE> Controlrequest. In particular, it is <STRONG>not safe foryour disk driver to remove a drive queue element aspart of handling an <CODE>kEject</CODE> Controlrequest</STRONG>.</P><P>If your disk driver needs to remove a drivequeue element, it must mark the drive queue elementas "to be removed" and set <CODE>dNeedTime</CODE>in its <CODE>dCtlFlags</CODE>. When it receives the<CODE><A HREF = "#accRun">accRun</A></CODE> Controlrequest, it must walk the drive queue looking fordrives it owns that are marked as "to be removed"and remove them there. The DTS sample<A HREF = "ftp://ftp.apple.com/developer/Sample_Code/Devices_and_Hardware/Drivers/AsyncDriverSample.sit">AsyncDriverSample</A> shows a correct implementation ofthis.</p><H4>Drive Queue Strategies</H4><P>While removing a drive queue element is relativelysimple, deciding on a strategy for when to remove the drivequeue element is not. The key is how you handle the<CODE>kEject</CODE> Control request. The two commonstrategies are described below.</P><H5>Real Block Device</H5><P>If your disk driver controlssome real piece of hardware (for example, a floppy drive, a SCSI ejectable diskdevice, a SCSI fixed disk device), you should not remove thedrive queue element when the user ejects the disk. Youshould leave the drive queue element in the queue so that,when the user reinserts the disk, you can post a "diskinserted" event for it. This simplifies your life and ensuresthat your drive's drive number is relatively stable.</P><P>This approach may seem a little strange for fixed disks,but it works just fine. Fixed disks are typically not markedas ejectable, so the user can not really eject a fixed disk;they simply unmount the volume mounted on it. This is usefulfor programs (for example, a disk recovery program) whichwant to unmount a volume, perform some low-level activity onthe disk, and then remount the volume. To remount thevolume, the program can simply call <CODE>PBMountVol</CODE>for the old drive number. This technique would not bepossible if the fixed disk driver removed its drive queueelements when the disk was ejected.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The Alias Manager remounts volumes in this way,which is very convenient for the user. The user canunmount a volume by dragging it to the Trash andlater remount it by simply double-clicking an aliasto the volume.</p></TD></TR></TABLE></CENTER><BR><BR><P>So leaving fixed disk drive queue elements in the drivequeue is not only safe, it is also convenient.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>One important exception to the above isremovable disks with multiple partitions. Forexample, if the users ejects a disk with threepartitions and then inserts a disk with a singlepartition, you should remove the two extra drivequeue elements (at <A HREF = "#accRun">systemtask</A> time) before informing the system aboutthe new disk.</p></TD></TR></TABLE></CENTER><BR><BR><H5>Virtual Block Device</H5><P>If you are writing a disk driver for some virtual blockdevice (like a RAM disk, or a disk image, or ablock-oriented network protocol), your job is more complex.In the simple case, if the disk is ejected when there is novolume mounted on it, you should remove the drive queueelement, as explained in the previous section.</P><P>However, if the disk is ejected while there is still avolume mounted on it, you must take special action to avoidthe disk switch dialog asking the user to insert the virtualdisk. [The "Please insert disk RAM Disk" disk switch dialogis particularly amusing or annoying depending on how muchcaffeine you've had that day.] There are two common ways toprevent this:</P><OL>   <LI>Non-Ejectable -- You can mark your virtual drive as   non-ejectable. This is probably the easiest and most   sensible approach. It can; however, have problems when   running with virtual memory enabled on older systems. Old   versions of the Virtual Memory Manager assume that any   local, non-ejectable drive is eligible for paging. This   may not be true for your virtual block device driver   (especially if it relies on the network). Modern versions   of the Virtual Memory Manager (starting with Mac OS 8.1)   query the drive, via Driver Gestalt   (<CODE><a href="tn1121.html#kdgVMOptions">kdgVMOptions</A></CODE>),   to see whether the drive is really suitable for paging.   However, for older systems, the only recourse you have is   to make your drive as ejectable.</li>      <LI>Auto Reinsert -- If you are forced to mark your   virtual drive as ejectable, the following algorithm will   ensure that you remove the drive queue element when   appropriate and never have an ejected drive with a volume   mounted on it:      <OL><LI TYPE="1">When you receive the <CODE>kEject</CODE>Control request, mark the drive as not having a diskin place and set the <CODE>dNeedTime</CODE> bit in the<CODE>dCtlFlags</CODE>.</li><LI>When the system sends you an<CODE><A HREF = "#accRun">accRun</A></CODE>, walk thedrive queue looking for any of your drives which aremarked as not having a disk in place.</li><LI>For those drives, walk the system VCB queuelooking for a volume that has been ejected but waspreviously mounted on that drive.</li><LI>If you find such a volume, post a "disk inserted"event for that drive. This will remount the volumeback on the drive.</li><LI>If you don't find such a volume, remove the drivequeue element for that drive.</li>   </OL>      <P>The DTS sample AsyncDriverSample implements this   algorithm.</P></li></OL><H4>Hot Swapping</H4><P>The Mac OS I/O subsystem is evolving towards more supportfor hot-swappable devices. Modern I/O buses, like USB andFireWire, fully support the addition and removal of deviceswhile the system is running.</P><P>Unfortunately, other parts of Mac OS are not as friendlyto the hot swapping of devices. For disk devices, hotswapping is a relatively new idea, and Mac OS support forhot swappable disk devices is limited. While it is possibleto add new drives on the fly, removing a drive while thereis a volume mounted on it will cause the system to crash,with possible loss of user data.</P><P>There are two basic strategies for handling a disk devicebeing unplugged unexpectedly.</P><OL>   <LI>Put It Back -- If possible, your disk driver should   stop the system and post a dialog telling the user to   replace the disk device. This dialog should have no OK or   Cancel buttons; the user must replace the device to   continue using the system and the dialog should   auto-dismiss when the device is reattached. This is   tricky to implement, for the following reasons.   <UL><LI>In most cases, the notification that a device hasbeen removed happens at interrupt time, and it isunsafe to pose a standard Dialog Manager dialog atinterrupt time. You can defer the dialog until yournext <CODE><A HREF = "#accRun">accRun</A></CODE>, butyou may receive I/O requests before you are issued an<CODE><A HREF = "#accRun">accRun</A></CODE>, and youmust be prepared to handle those I/O requests atinterrupt time.</li><LI>Some I/O families are not capable of handlingreconnections at interrupt time.</li><LI>Some block devices are not tagged with a unique IDso, even if the device is reconnected, there is no wayto guarantee that it is the same device.</li>   </UL></li>      <LI>Error Everything -- Your device driver should simply   fail all I/O requests with the error   <CODE>driverHardwareGoneErr</CODE> (-503). In Mac OS 9.0   and higher, the File Manager recognizes this error and   responds in the following way.      <UL><LI>It sets the <CODE>kVCBFlagsHardwareGoneBit</CODE>in the <CODE>vcbFlags</CODE> field of the VolumeControl Block (<CODE>VCB</CODE>).</li><LI><A NAME="DiskGoneAlert"></A>It posts aNotification Manager alert saying, "The device for disk'MyDiskName' was unexpectedly disconnected. To preventdata loss, always use the Finder to 'Put Away' a diskbefore disconnecting its disk device."</li><LI>At system task time, it walks the volume listlooking for volumes that have the<CODE>kVCBFlagsHardwareGoneBit</CODE> bit set and putsthem offline.</li>   </UL></li>      <LI>This approach is similar to that taken by the   AppleShare external file system when the connection to   the server tears.</li></OL><P>In some cases, your I/O family may provide support forthe hot unplugging of disk devices. For example, if yourdevice is connected via the media bay, the system willautomatically put up a "put it back" dialog for you, and ifyour device is connected via FireWire, you can use the<CODE>FWWaitForDeviceRePlug</CODE> routine to wait for adevice to be reconnected.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The media bay uses the<a href="http://developer.apple.com/documentation/mac/OSUtilities/OSUtilities-28.html">SystemError Handler</A> to display its dialogs. Thesystem error codes used by the media bay aredocumented in "Errors.h", namely:</P></TD></TR></TABLE></CENTER><BR><BR><TABLE BORDER=1>   <TR><td width=150 align=left><P><B>System Error Code</B></p></TD><td align="left"><P><B>English Text (Mac OS 8.5)</B></p></TD></TR>   <TR><td width=150 align=left><P><CODE>dsMBFlpySysError</CODE></p></TD><td align="left"><P>Please reinsert the Floppy Drive modulenow.</p></TD></TR>   <TR><td width=150 align=left><P><CODE>dsMBATASysError</CODE></p></TD><td align="left"><P>Please reinsert the Disk Drive modulenow.</p></TD></TR>   <TR><td width=150 align=left><P><CODE>dsMBATAPISysError</CODE></p></TD><td align="left"><P>Please reinsert the CD-ROM module now.</p></TD></TR>   <TR><td width=150 align=left><P><CODE>dsMBExternFlpySysError</CODE></p></TD><td align="left"><P>Please reconnect the Floppy Drivemodule now.</p></TD></TR></TABLE><br><P>You might think to use the same technique as themedia bay but this is unsatisfactory for a numberof reasons:</P><UL>   <LI>It is not supported by DTS.</li>      <LI>The System Error Handler uses QuickDraw to   display its dialogs. Calling QuickDraw at   interrupt time is illegal, and therefore calling   <CODE>SysError</CODE> at interrupt time is   illegal. This is a known compromise in the   design of <CODE>SysError</CODE> and is   acceptable because, when you're handling a real   system error, the system is already in a   precarious state. However, using   <CODE>SysError</CODE> as part of the standard   operation of your disk driver is asking for   trouble.</li></UL><P>In the absence of an I/O family-specific solution, thebest compromise solution is to implement the followingalgorithm:</P><UL>   <LI>When you are notified of a device being disconnected,   check whether there is a volume mounted on any of its   drives. If there isn't a volume mounted on any of its   drives, all is well; you can simply wait for the next   <CODE><A HREF = "#accRun">accRun</A></CODE> to remove the   device's drive queue elements. If there is a volume   mounted, set a flag in your per-drive storage.</li>      <LI>If you receive an I/O request while that flag is set,   fail the request with <CODE>driverHardwareGoneErr</CODE>   error. On Mac OS 9.0 or above, this is a sufficient   response. On earlier systems, you should also:      <UL><LI>At <CODE><A HREF = "#accRun">accRun</A></CODE> time,look through for drives owned by your driver whichhave the flag set. For each missing device, post aDialog Manager dialog that requires the user toreattach the device. Once the device is reattached,clear the flag and return from your<CODE><A HREF = "#accRun">accRun</A></CODE> handler.</li><LI>Post a Notification Manager alert like that<A HREF = "#DiskGoneAlert">described above</A>.</li>   </UL></li></UL><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="CloseAndPurge"></A></P><H2>Close and Purge</H2><P>For maximum friendliness, your driver must support beingclosed. This section explains how to support the Closerequest properly in you disk driver and how a formattingutility might use this to allow a disk to be reformattedwithout rebooting.</P><H3>Supporting Close in Your Driver</H3><P>Your driver must support the Close request properly. Thisrequirement was documented a<a href="../dv/dv_13.html">longtime ago</A> and is as true today as it ever was.</P><P>Your driver's Close entry point should attempt to undoall the things that its Open entry point did, including thetasks listed below.</P><OL>   <LI>Check to see whether there are volumes mounted in any   of the drives controlled by the driver. Code for doing   this is shown below. If there are, the Close should fail   with a <CODE>closErr</CODE>.</li>   </ol><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal SInt16 MoreVolumeMountedOnDrive(SInt16 drive,Boolean ejectedIsMounted){    SInt16 result;    VCBPtr thisVCB;&nbsp;    result = 0;    thisVCB = (VCBPtr) GetVCBQHdr()-&gt;qHead;    while (thisVCB != nil &amp;&amp; result == 0) {  if (thisVCB-&gt;vcbDrvNum == drive || (ejectedIsMounted &amp;&amp;  thisVCB-&gt;vcbDrvNum == 0 &amp;&amp;  thisVCB-&gt;vcbDRefNum == drive )  ) {   result = thisVCB-&gt;vcbVRefNum;  } else {   thisVCB = (VCBPtr) thisVCB-&gt;qLink;  }    }    return result;}</pre></TD></TR></TABLE></CENTER><BR><BR>   <OL>   <LI>Terminate all asynchronous operations and remove any   interrupt handlers. Your Close entry point is always   called immediately at system task time, so it is safe to   "spin wait" (that is, synchronously   wait) for asynchronous operations to complete.</li>      <LI>Remove all of its drive queue elements from the drive   queue. The system supplies a routine for adding a drive   queue elements (<CODE>AddDrive</CODE>), but not one to   remove them. The code for removing a drive queue element   is shown <A HREF = "#MoreRemoveDrive">earlier</A>.</li>      <LI>Unregister with any system services with which it   registered. Typically, this includes SCSI Manager or ATA   Manager, Power Manager, and Shutdown Manager.</li>      <LI>Free any memory allocated by the driver, including   the <CODE>dCtlStorage</CODE>.</li></OL><P>If it is absolutely impossible to complete any of thesesteps, the driver should return <CODE>closErr</CODE> andcontinue as if the close had not been requested.</P><P>In addition, your driver may choose to implement the<CODE>kdgPurge</CODE> Driver Gestalt selector. The responseto this selector is a<CODE>DriverGestaltPurgeResponse</CODE>, as shown below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct DriverGestaltPurgeResponse {    UInt16  purgePermission;    UInt16  purgeReserved;    Ptr     purgeDriverPointer;};typedef struct DriverGestaltPurgeResponse DriverGestaltPurgeResponse;</pre></TD></TR></TABLE></CENTER><BR><BR><P>If your driver responds to this selector, it must fillout the fields of the response as follows:</P><DL>   <DT><CODE>purgePermission</CODE></dt>      <DD><P>Three bits in this field are defined below. You   should set them as appropriate for your driver. The   remaining bits are reserved and must be set to zero.</p></dd>      <DT><CODE>purgeReserved</CODE></dt>      <DD><P>Reserved. Must be set to zero.</p></dd>      <DT><CODE>purgeDriverPointer</CODE></dt>      <DD><P>A pointer to the memory block containing your   driver's code. You must set this to a valid Memory   Manager pointer if you return   <CODE>kmOkCloseOkPurge</CODE> in the   <CODE>purgePermission</CODE> field.</p></dd></DL><P>The bits in the <CODE>purgePermission</CODE> field aredefined as follows:</P><DL>   <DT><CODE>kbCloseOk</CODE></dt>      <DD><P>Set this bit if your driver correctly handles the   Close request, as described above.</p></dd>      <DT><CODE>kbRemoveOk</CODE></dt>      <DD><P>Set this bit if your driver can be removed from the   unit table with <CODE>DriverRemove</CODE>. Usually this   is safe if you installed your driver using   <CODE>DriverInstall</CODE> or   <CODE>DriverInstallReserveMem</CODE> (assuming your   driver is pointer based, which   all disk drivers should be).</p></dd>      <DT><CODE>kbPurgeOk</CODE></dt>      <DD><P>Set this bit if you can supply a pointer to a single   Memory Manager pointer block that contains your driver   code and that can be disposed to free the memory used   by your driver's code. If you set this bit, you must set   <CODE>purgeDriverPointer</CODE> to be that pointer. If your driver   supports <A HREF = "#CodeSharing">code sharing</A>, you   must only set this bit if there is only one instance of   your driver remaining in the unit table.</p></dd></DL><P>Of the eight possible combinations of these three bits,only three make any real sense. There are symbolic constantsfor these three useful combinations(<CODE>kmNoCloseNoPurge</CODE>,<CODE>kmOkCloseNoPurge</CODE> and<CODE>kmOkCloseOkPurge</CODE>).</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If you set <CODE>kbRemoveOk</CODE> withoutsetting <CODE>kbPurgeOk</CODE>, anyone closing yourdriver is guaranteed to leak the memory containingyour driver's code (unless you use<A HREF = "#CodeSharing">code sharing</A> ).</p></TD></TR></TABLE></CENTER><BR><BR><H3><A NAME="SupportingReopen"></A>Supporting Reopen</H3><P>If your driver supports close, it should also supportbeing reopened. There are circumstances under which thirdparty software wants to close your driver, take control ofthe device, and then restore the normal function of yourdriver. This is only possible if your driver supportsreopen.</P><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Most existing SCSI and ATA drivers do notsupport reopen. There is no well-documented way ofdetermining whether a driver supports reopen.Software that relies on the ability to reopen diskdrivers should warn the user that the reopen maynot work, preferably before closing the driver.</p><P>Most existing disk drivers perform their driverinitialization code in their Install routine and do nothingin their Open entry point. A typical SCSI driver'sinitialization code is as follows.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>on installinstall driver into unit table    scan partition map    create a drive queue element for each partition    'open' driver by marking it open in the DCEend install&nbsp;on open    return noErrend open</pre></TD></TR></TABLE></CENTER><BR><BR><P>The problem with this approach is that it does not allowclients to reopen the driver after closing it. A betterapproach is shown below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>on install    install driver into unit table    rename driver to a unique name    open driver using OpenDriverend install&nbsp;on open    scan partition map    create a drive queue element for each partitionend open</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>SCSI disk driver lore requires that a driver'sinstallation routine not use the<CODE>OpenDriver</CODE> routine to open the driver.Instead, the driver installation routine wasexpected to put the driver in the unit table andthen mark the driver as open by setting the<CODE>dOpened</CODE> bit of the DCE's<CODE>dCtlFlags</CODE>. This was because theimplementation of <CODE>OpenDriver</CODE> in oldROM's would touch the Resource Manager (and hencethe File Manager) even when the driver alreadyexisted in the unit table. DTS believes that thisis only necessary on ancient Macintosh ROMs andmodern drivers should install themselves using<CODE>OpenDriver</CODE>.</p>     </TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Many device driver writers guard against theirOpen entry point beingcalled multiple times. This is unnecessary for 68Kdrivers. Once your 68K driver is marked as open(bit <CODE>dOpened</CODE> is set in the DCE's<CODE>dCtlFlags</CODE>), further calls to<CODE>OpenDriver</CODE> will simply return<CODE>noErr</CODE> without calling your driver'sOpen entry point.</P></TD></TR></TABLE></CENTER><BR><BR><P>This is not true for native drivers, where opensand closes are reference counted by the DeviceManager. For a native driver, a second call to<CODE>OpenDriver</CODE> will result in your driverbeing sent another <CODE>kOpenCommand</CODE>request.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If your driver uses <A HREF = "#CodeSharing">codesharing</A>, it is impossible to support reopenproperly because all instances of your driver inthe unit table will have the same name, and the<CODE>OpenDriver</CODE> routine only allows you toopen a driver by name.</p>    </TD></TR></TABLE></CENTER><BR><BR><H3><A NAME="HostileTakeovers"></A>Hostile Takeovers</H3><P>There are circumstances under which software wants toremove the driver for a disk at runtime. For example, aformatting utility might want to reformat a disk which waspreviously controlled by another driver. If the drivercontrolling the disk is written by you, it is easy tocoordinate this takeover. On the other hand, if the drivercontrolling the disk is unknown to you, taking over the diskis tricky to do safely. This process is known as a<STRONG>hostile takeover</STRONG>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Do not use the term "hostile takeover" in youruser interface. It is likely to scare and confuseusers.</p></TD></TR></TABLE></CENTER><BR><BR><P>To initiate a hostile takeover of a device, you must takethe following steps.</P><OL>   <LI>Warn the user that you are attempting something that   risks both crashing and data loss.</li>      <LI>Verify that there are no volumes mounted on drives   controlled by the device. Do this by iterating through   the mounted volumes (by making indexed calls to   <CODE>PBHGetVInfo</CODE>) checking that   <CODE>ioVDRefNum</CODE> is not equal to the driver   reference number of the driver in question. If there are   volumes mounted using the driver, you may want to unmount   the volumes yourself using <CODE>PBUnmountVol</CODE>.</li>      <LI>If the driver supports   Driver Gestalt, issue a <CODE>kdgPurge</CODE> Driver   Gestalt request. If this succeeds, you can check the   <CODE>purgePermission</CODE> to see whether the driver   supports the Close request. If it doesn't, a hostile   takeover is not possible without restarting.</li>      <LI>Call <CODE>CloseDriver</CODE> to close the driver,   which returns one of the following results.      <OL><LI TYPE="1"><CODE>noErr</CODE> -- The driver closedsuccessfully. Continue with the next step.</li><LI><CODE>closErr</CODE> (or any other error) -- Thedriver could not be closed. A hostile takeover is notpossible without restarting.</li>  </ol></li>  </ol>     <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Never close a driver with<CODE>FSClose</CODE> or <CODE>PBClose</CODE>.If you're closing a driver, always use<CODE>CloseDriver</CODE>. Similarly, ifyou're opening a driver, always use<CODE>OpenDriver</CODE>. These routinesprovide the correct glue to the<CODE>_Open</CODE> and <CODE>_Close</CODE>traps to ensure that you are acting on adriver, not a file, or a desk accessory, or aslot driver.</p></TD></TR></TABLE></CENTER><BR><BR>   <OL>      <LI>Just to be certain, you should check whether any   drive queue elements belonging to the driver remain in   the drive queue. If there are, the driver's   implementation of the Close request is broken and a   hostile takeover is not possible without restarting.</li>      <LI>If you issued a <CODE>kdgPurge</CODE> request (step 3   above) and <CODE>kbRemoveOk</CODE> was set in the   <CODE>purgePermission</CODE> response, you can call   <CODE>DriverRemove</CODE> to remove the driver from the   unit table. If the driver doesn't support Driver Gestalt,   or <CODE>kbRemoveOk</CODE> is not set, the hostile   takeover is complete. The driver is still installed in   the unit table but it should be a relatively benign   memory leak.</li>      <LI>If you issued a <CODE>kdgPurge</CODE> request (step 3   above) and <CODE>kbPurgeOk</CODE> was set in the   <CODE>purgePermission</CODE> response, you can call   <CODE>DisposePtr</CODE> on   <CODE>purgeDriverPointer</CODE> to remove the driver's   code from memory. If the driver doesn't support Driver   Gestalt, or <CODE>kbPurgeOk</CODE> is not set, the   hostile takeover is complete. The driver code is still in   memory but it should be a relatively benign memory   leak.</li>   </ol>       <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>You might think that you can just dispose   <CODE>dCtlDriver</CODE>, but that is not   correct. <CODE>dCtlDriver</CODE> may not be a   valid Memory Manager pointer. Specifically, for   SCSI and ATA drivers, <CODE>dCtlDriver</CODE>   typically points some number of bytes into the   pointer block.</p></TD></TR></TABLE></CENTER><BR><BR><P>If a hostile takeover is not possible without restarting-- or the user declines your offer to attempt one -- you areforced to restart the computer to take over the disk. Youcan overwrite the DDM to eliminate all foreign drivers fromthe disk and then restart the computer. Because there are nodrivers in the DDM, the disk will not be mounted and youwill be free to use it as you wish.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Do not expect any data on the disk to survivethis operation. While most drivers use the standardpartition format, there are some non-standardpartition formats (such as RAID striping) for whichthe driver is the only thing that "holds it alltogether". In those cases, eliminating the drivertypically eliminates the data. The only way aroundthis is to treat each of the common RAID formats asa special case in your hostile takeover software.</p></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Some third-party formatting utilities implementa more powerful but less safe approach to hostiletakeovers. Specifically, if the check for orphaneddrive queue elements (step 5 above) fails, theutility simply dequeues the orphaned drive queueelements and<A HREF = "#ManagerRegistration">unregisters thedrives with the appropriate manager</A>. Thistechnique works in most cases, although it leaksmemory (the orphaned drive queue elements) and maypotentially cause a system crash. If you implementthis technique, be sure to warn the user of thepossible consequences.</p></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="FileExchange"></A><H2>File Exchange (n&eacute; PC Exchange)</H2><P>Foreign file systems (such as File Exchange) require yourdisk driver to do extra work to support the mounting ofnon-HFS volumes. While this extra work is not hard, it hasbeen poorly documented. This section explains the correctway to support foreign file systems in your disk driver.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>For an in-depth explanation of the whole volumemounting process, see<A HREF = "#PartitionHandlingBackground">PartitionHandling: Background and Rationale</A> later inthis section.</p></TD></TR></TABLE></CENTER><BR><BR><H3><A NAME="CooperatingWithFSM"></A>Cooperating with FileSystem Manager</H3><P>There are two steps you must take to fully support FileSystem Manager in your disk driver. The first step is tosupport the File Exchange interface, which is described inthe <A HREF = "#ImplementingFileExchangeSupport">nextsection</A>. The second step is related to the way your diskdriver scans a bus and creates drive queue elements fordevices on that bus. Your current algorithm might looksomething like that shown below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>on scanForDevices  scan bus for devices  for each device found on the bus    if the disk contains an Apple partition mapfor each partition on the disk  if <CODE>kPartitionIsMountedAtStartup</CODE> is set in pmPartStatus if the partition is of type "Apple_HFS"   create a drive queue element with FSID of 0   post a "disk inserted" event end-if  end-ifend-for    end-if  end-forend scanForDevices</pre></TD></TR></TABLE></CENTER><BR><BR><P>To cooperate with FSM, you should modify this algorithmto the one shown below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>on scanForDevices  clear InformFSM flag  scan bus for devices  for each device found on the bus    if the disk contains an Apple partition mapfor each partition on the disk  if <CODE>kPartitionIsMountedAtStartup</CODE> is set in pmPartStatus if the partition is of type "Apple_HFS"   create a drive queue element with FSID of 0   post a "disk inserted" event else if the partition is of a known non-disk type   do nothing else   create a drive queue element with FSID of fsmGenericFSID   set InformFSM flag end-if  end-ifend-for    elsecreate a drive queue element with FSID of fsmGenericFSID \    that encompasses the entire driveset InformFSM flag    end-if  end-for  if InformFSM flag    call InformFSM(fsmDrvQElChangedMessage)  end-ifend scanForDevices</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR><CODE>InformFSM</CODE> is a generic utilityroutine by which your disk driver can send messagesto FSM. It is documented in<A HREF = "ftp://ftp.apple.com//developer/Development_Kits/File_System_Manager.sit.hqx">Guideto the File System Manager</A>.</p></TD></TR></TABLE></CENTER><BR><BR><P>The basic algorithm, as shown above, is surprisinglyeasy. However, complications arise if your disk driver mightload before FSM. This can happen in the followingcircumstances:</P><OL>   <LI>If your disk driver is loaded out of a driver   partition in a partition map.</li>      <LI>If your disk driver loads from a system extension on   an old system. Systems prior to System 7.5 did not have   FSM in the System file, so FSM loaded at INIT time. The   system extension which loads your driver might run before   the one loading FSM.</li></OL>    <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>There are two common cases where FSM might loadfrom a system extension:</P><OL>   <LI>Early versions of PC Exchange contain an   equally early version of FSM embedded in the   extension. When PC Exchange loads, it checks to   see whether FSM is already present in the   system. If it isn't, it loads the embedded   version of FSM.</li>      <LI>FSM plug-in developers can license a system   extension, "File System Manager", to install   with their FSM plug-in on older systems.</li></OL></TD></TR></TABLE></CENTER><BR><BR><P>If your disk driver loads before FSM, the above algorithmhas a number of problems. Firstly, <CODE>InformFSM</CODE> isnot implemented until FSM loads, so calling it would be bad.Secondly, the support for <CODE>fsmGenericFSID</CODE> isimplemented by FSM, so creating a drive queue element withthat FSID is a bad idea unless FSM is installed.</P><P>The solution to this is to defer both activities untilFSM loads. If system startup completes without FSM loading,you simply do not perform these steps. You can poll for bothof these events in your driver's<CODE><A HREF = "#accRun">accRun</A></CODE> handler. The newalgorithm is shown below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>on scanForDevices  determine whether FSM is installed  clear InformFSM flag  scan bus for devices  for each device found on the bus    if the disk contains an Apple partition mapfor each partition on the disk  if <CODE>kPartitionIsMountedAtStartup</CODE> is set in pmPartStatus if the partition is of type "Apple_HFS"   create a drive queue element with FSID of 0   post a "disk inserted" event else if the partition is of a known non-disk type   do nothing else   if FSM available     create a drive queue element with FSID of fsmGenericFSID   end-if   set InformFSM flag end-if  end-ifend-for    elseif FSM available  create a drive queue element with FSID of fsmGenericFSID \that encompasses the entire driveend-ifset InformFSM flag    end-if  end-for  if InformFSM flag    if FSM availablecall InformFSM(fsmDrvQElChangedMessage)    elseset gPollForFSMset dNeedTime in dCtlFlags    end-if  end-ifend scanForDevices&nbsp;on accRun  if gPollForFSM    if FSM available thencall scanForDevices againclear gPollForFSMclear dNeedTime in dCtlFlags (unless you need it for other reasons)    else if startup time is overclear gPollForFSMclear dNeedTime in dCtlFlags (unless you need it for other reasons)    end-if  end-ifend accRun</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>You can determine whether system startup iscomplete using the technique described in<A HREF = "#DiskDriversAndTheSystemHeap">Disk Driversand the System Heap</A>.</p></TD></TR></TABLE></CENTER><BR><BR><P>For more information about why this algorithm isnecessary, see<A HREF = "#PartitionHandlingBackground">Partition Handling:Background and Rationale</A>.</P><P>Finally, if you mount a large number of disks simultaneously, you may runafoul of the system event queue's size limit. On currentsystems (Mac OS 9.0), the system event queue is limited to48 events. If the system event queue is full and you post a"disk inserted" event, the event is ignored. There are twoaspects to this problem:</P><OL>   <LI>If you explicitly posted the "disk inserted" event by   calling <CODE>PostEvent</CODE>, you will find that an   event posted while the event queue is full will cause the   first event in the queue to be dropped.   <CODE>PostEvent</CODE> will not return an error to   indicate that an event was dropped.</li>      <LI>You also receive no notification that the event queue   is full if you implicitly post "disk inserted" events by   calling <CODE>InformFSM</CODE> with the   <CODE>fsmDrvQElChangedMessage</CODE> selector.</li></OL><P>There is a simple algorithm that handles both of thesecases:</P><OL>   <LI>When a drive is ready for operation (its disk has   just been inserted, or you detected it during your   initial scan for devices), set a flag in your per-drive   storage to indicate that a "disk inserted" event is   pending.</li>      <LI>Inform the system that the disk was inserted as   described above (either by posting a "disk inserted" event   or by calling <CODE>InformFSM</CODE> with the   <CODE>fsmDrvQElChangedMessage</CODE> selector).</li>      <LI>When any I/O is done to the drive, clear the disk   inserted pending flag. I/O to the drive indicates that   some file system has queried the drive to determine   whether to mount a volume on it, which implies that the   "disk inserted" event was successfully processed.</li>      <LI>At <CODE><A HREF = "#accRun">accRun</A></CODE> time,   check for any drives with the disk inserted pending flag   still set. If you find one it is likely that the "disk   inserted" event was lost, so you should reinform the   system of the disk insertion.</li></OL><H3><A NAME="ImplementingFileExchangeSupport"></A>ImplementingFile Exchange Support</H3><P>This section describes how you should implement the FileExchange interface in your disk driver.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The requests described here have beendocumented in a number of places, including<A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">DesigningPCI Cards and Drivers for Power MacintoshComputers</A>, page 114, and "PCX and Large VolumeDrivers." However, none of the previousdescriptions are sufficiently detailed for you toimplement the requests correctly.</p></TD></TR></TABLE></CENTER><BR><BR><H4><A NAME="kdgAPI"></A>Implementing Driver Gestalt kdgAPI</H4><P>A disk driver that supports the following Control andStatus requests must implement the <CODE>kdgAPI</CODE>selector to indicate that it does. For more informationabout Driver Gestalt, see the<A HREF = "#DriverGestalt">Driver Gestalt</A> section of thistechnote.</P><H4><A NAME="PartitionInformationRecord"></A>PartitionInformation Record</H4><P>The partition information record(<CODE>partInfoRec</CODE>) is a structure used to storeinformation about a partition on a disk. The fields of thestructure are:</P><DL>   <DT><CODE>SCSIID</CODE></dt>      <DD><P>If the underlying device is connected via a SCSI   interface, this field holds the SCSI Manager   <CODE>DeviceIdent</CODE> of the device. If the device is   connected via an ATA interface, this field holds the ATA   Manager <CODE>ataDeviceID</CODE> (a structure defined in   <a href="http://developer.apple.com/documentation/hardware/Developer_Notes/System_Software/ATA_Device_Zero_One.pdf">ATA   0/1 Software Developers Guide</A>). Devices connected via   other interfaces can use whatever value makes sense to   uniquely identify the device on that bus (typically this is the same 32-bit   number returned by the <CODE>kdgDeviceReference</CODE> Driver Gestalt selector). If no   value makes sense, a driver   must clear this field.</p></dd>      <DT><CODE>physPartitionLoc</CODE></dt>      <DD><P>The block number of the first block in the partition.</p></dd>      <DT><CODE>partitionNumber</CODE></dt>      <DD><P>The physical block number of the partition map entry   of this partition.</p></dd></DL>  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>You can determine the interface used by thedevice issuing the <CODE>kdgInterface</CODE> DriverGestalt query. Drivers that support File Exchangeshould also support this Driver Gestalt selector.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>For more information about the<CODE>ataDeviceID</CODE> structure, consult the<a href="http://developer.apple.com/documentation/hardware/Developer_Notes/System_Software/ATA_Device_Zero_One.pdf">ATADevice 0/1 Software Developer Guide</A>. Thisstructure is not the same as the<CODE>DeviceIdentATA</CODE> structure, defined<A HREF = "#DeviceIdentATA">above</A>.</p></TD></TR></TABLE></CENTER><BR><BR><H4>Creating a New Drive Queue Element</H4><TABLE BORDER=0>   <TR><td width=50 align=left><B>Trap</b></TD><td width=200 align=left><CODE>_Control</CODE></TD>   </TR>   <TR><td width=50 align=left><B>Mode</b></TD><td width=200 align=left><p>Synch, Async, Immediate</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><CODE>csCode</CODE></TD><td width=100 align=left><CODE>SInt16</CODE></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><p><CODE>kGetADrive</CODE> (51)</p></TD></TR>   <TR><td width=91 align=left><CODE>csParam[0..1]</CODE></TD><td width=100 align=left><CODE>DrvQElPtr *</CODE></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><P>On input, contains the address of a drive queueelement pointer. The request creates a new drivequeue element based on the supplied drive queueelement and places a pointer to the new drive queueelement in the supplied address.</p></TD></TR></TABLE><br>  <P>In response to this request, your disk driver must createa new drive queue element. The fields of the new drive queueelement must be filled out as described below.</P><DL>   <DT>drive flags (the 4 bytes prior to <CODE>qLink</CODE>)</dt>      <DD><P>Inherited from the supplied drive queue element.</p></dd>      <DT><CODE>qLink</CODE></dt>      <DD><P>Set up when you add the drive to the drive queue   using <CODE>AddDrive</CODE>.</p></dd>      <DT><CODE>qType</CODE></dt>      <DD><P>Inherited from the supplied drive queue element.</p></dd>      <DT><CODE>dQDrive</CODE></dt>      <DD><P>Must be set to a new unique drive number.</p></dd>      <DT><CODE>dQRefNum</CODE></dt>      <DD><P>Must be set to your driver's reference number.</p></dd>      <DT><CODE>dQFSID</CODE></dt>      <DD><P>Inherited from the supplied drive queue element.</p></dd>      <DT><CODE>dQDrvSz</CODE></dt>      <DD><P>Inherited from the supplied drive queue element.</p></dd>      <DT><CODE>dQDrvSz2</CODE></dt>      <DD><P>Inherited from the supplied drive queue element.</p></dd>      <DT>partition offset (typically held in extra bytes   beyond <CODE>dQDrvSz2</CODE>)</dt>      <DD><P>Inherited from the supplied drive queue element.</p></dd></DL><P>Your driver must return the new drive queue element inthe memory pointed by <CODE>csParam[0..1]</CODE>. You mustnot post a "disk inserted" event for the new drive, or sendthe <CODE>fsmDrvQElChangedMessage</CODE> message to FSM.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>This request is typically issued as asynchronous request, which can cause problems ifyour driver needs to allocate memory to create thenew drive queue element. To avoid this problem, DTSrecommends that all clients issue this as animmediate request. However, to work with oldclients, your driver should be prepared to handleall possible requestmodes.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Your driver shouldbe prepared for the incoming value of the drivequeue element pointed to by <CODE>csParam[0..1]</CODE> being nil, or some other valuewhich is not a pointer to one of your driver'sdrive queue elements. In that case, your drivershould initialize the fields of the new drive queueelement to default values.</p></TD></TR></TABLE></CENTER><BR><BR><H4>&nbsp;Changing the Partition of a Drive Queue Element</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</b></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</b></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kRegisterPartition</CODE> (50)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>DrvQElPtr</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The drive queue element whose partition is to bechanged</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The block number of the first block in thepartition</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[4..5]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The size (in blocks) of the partition</p></TD></TR></TABLE><br><P>In response to this request, your disk driver mustretarget the specified drive queue element to represent thegiven partition on the disk. After this request, the drivequeue element must represent a partition that starts at theblock specified by <CODE>csParam[2..3]</CODE> and is of thesize specified by <CODE>csParam[4..5]</CODE>.</P><P>You must not post a "disk inserted" event for the drive, or send the<CODE>fsmDrvQElChangedMessage</CODE> message to FSM.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>The effects of this request are limited to thedrive queue element in memory. This request mustnot change the partitioning scheme on the disk.</p></TD></TR></TABLE></CENTER><BR><BR><H4>&nbsp;Preventing a Partition from Mounting</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</b></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</b></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><P><CODE>kProhibitMounting</CODE> (52)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>partInfoRec *</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><P>A pointer to a <CODE>partInfoRec</CODE> thatdescribes the partition which is not to be mountedat startup</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must markthe partition specified <CODE>csParam[0..1]</CODE> such thatit isn't mounted at system startup.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>The effects of this request are permanentlyapplied to the partition map on the disk.</p></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Modern versions of File Exchange do not requireyour driver to support this request (partly because it is functionallyequivalent to <A HREF = "#kClearPartitionMount">kClearPartitionMount</A>). If you decide not tosupport it, make sure to return<CODE>controlErr</CODE>.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The partition is completely determined by thefields of the partition information record, not bythe <CODE>ioVRefNum</CODE> field of the parameterblock.</p></TD></TR></TABLE></CENTER><BR><BR><H4>&nbsp;Determining the Partition of a Drive</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</b></p></TD><td width=200 align=left><P><CODE>_Status</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</b></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kGetPartInfo</CODE> (51)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><P>The drive number of the drive whose partitioninformation is requested</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>partInfoRec *</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><P>A pointer to a <CODE>partInfoRec</CODE> wherethe partition information is placed</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must placepartition information about the specified drive in the<A HREF = "#PartitionInformationRecord">partition informationrecord</A> pointed to by <CODE>csParam[0..1]</CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Your driver's response to this request has anon-obvious effect on the Disk InitializationPackage, especially the <CODE>DIReformat</CODE>call. The Disk Initialization Package prevents theuser changing the file system on a drive thatexists on a partitioned disk. It does this toprevent the data on the partition getting out ofsync with the partition type(<CODE>pmParType</CODE>) in the partition mapentry. For example, if the user could reformat anexisting HFS partition to be in DOS FAT format, thepartition data would be in DOS FAT format while the<CODE>pmParType</CODE> would still be "Apple_HFS".This is obviously not a good thing (the ROM mightattempt to boot from a DOS FAT partition!), so theDisk Initialization Package prevents it.</P></TD></TR></TABLE></CENTER><BR><BR><P>This raises the question, how does the DiskInitialization Package know whether a drive is apartition on a disk. The algorithm used is shownbelow.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>on driveIsAPartition drive  if drive's driver supports File Exchange requests (<A HREF = "#kdgAPI">kdgAPI</A>) and kGetPartInfo on drive succeeds then    return <CODE>physPartitionLoc != 0</CODE>  else    return drive's driver's unit number in [32..39]  end-ifend driveIsAPartition</pre></TD></TR></TABLE></CENTER><BR><BR><P>The gist of this algorithm is that, if yourdriver supports File Exchange requests, the drive'spartition must start at the beginning of the diskfor the Disk Initialization Package to allow achange of format. Alternatively, if your driverdoes not support File Exchange requests, it isconsidered to have partitions if its unit numberfalls in the range reserved for classic SCSIManager drivers.</P><P>If other demands on your driver prevent it frombeing reformatted by the above algorithm, you willprobably need to include reformat support in yourformatting utility.</P><P>DTS has requested a better solution to thisproblem [Radar ID 2287925].</p><H4>Determining Whether a Partition is Mounted</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</b></p></TD><td width=200 align=left><P><CODE>_Status</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</b></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><P><CODE>kGetPartitionStatus</CODE> (50)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>partInfoRec *</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><P>A pointer to a <CODE>partInfoRec</CODE> thatdescribes the partition to be queried</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2..3]</CODE></p></TD><td width=100 align=left><P><CODE>SInt16 *</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td width=250 align=left><P>A pointer to an <CODE>SInt16</CODE>. On return,this holds the <CODE>vRefNum</CODE> of the volumerepresented by this partition, or 0 if no volume isrepresented by this partition.</p></TD></TR></TABLE><br><P>In response to this request, your disk driver mustdetermine whether the partition described by the<A HREF = "#PartitionInformationRecord">partition informationrecord</A> pointed to by <CODE>csParam[0..1]</CODE> ismounted and return the volume reference number of the volumein the <CODE>SInt16</CODE> pointed by <CODE>csParam[2..3]</CODE>, or 0 if thepartition is not mounted.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The partition is completely determined by thefields of the partition information record, not bythe <CODE>ioVRefNum</CODE> field of the parameterblock.</p></TD></TR></TABLE></CENTER><BR><BR><A NAME="UsingFileExchangeCalls"></A><H3>Using TheseRequests</H3><P>This section explains how you might utilize the FileExchange driver requests in your application (or FSMplug-in) to access portions of a partitioned disk that lieoutside of the HFS partitions.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>Many of the File Exchange driver requestsrequire you to pass a pointer to a buffer. Asexplained in <A HREF = "#PrivateControlAndStatusRequests">PrivateRequests and Virtual Memory</A>, you must hold thesebuffers (in the VM sense) to prevent fatal pagefaults.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>This section contains a number of routineswhich demonstrate the use of the File Exchangeinterface. Some of the details have been removedfor brevity. Moreover, the routines rely on otherutility routines that are not included here. Thefull source code for these routines is available inthe MoreDisks module of the DTS MoreIsBetter samplecode library.</p></TD></TR></TABLE></CENTER><BR><BR><P>The first step of using the File Exchange interface is tocreate a drive queue element that targets the section of thedisk you wish to read or write. The following code snippetshows how this might be done.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal OSErr MoreCreateNewDriveQueueElement(SInt16 driveToClone,UInt32 firstBlock, UInt32 sizeInBlocks, SInt16 *newDrive)    // See comment in interface part.{    OSErr err;    CntrlParam pb;    DrvQElPtr drvQEl;&nbsp;    // First check that the driver supports the File Exchange    // interface.    err = noErr;    if ( ! MoreDriveSupportFileExchange(driveToClone) ) {  err = controlErr;    }    // Find the drive queue element associated with    // driveToClone.  This is an input parameter to    // kGetADrive.    if (err == noErr) {  err = MoreUTFindDriveQ(driveToClone, &amp;drvQEl);    }    // Make the kGetADrive request to the driver.  Because    // we pass a pointer to memory outside of the parameter    // block (drvQEl) and the driver might be a paging device,    // we must hold drvQEl (and make sure to unhold it later!).    if (err == noErr) {  err = SafeHoldMemory(&amp;drvQEl, sizeof(drvQEl));  if (err == noErr) {   pb.ioVRefNum = driveToClone;   pb.ioCRefNum = MoreGetDriveRefNum(driveToClone);   pb.csCode = kGetADrive;   *((DrvQElPtr **) &amp;pb.csParam[0]) = &amp;drvQEl;&nbsp;   err = PBControlSync((ParmBlkPtr) &amp;pb);   if (err == noErr) { *newDrive = drvQEl-&gt;dQDrive;   }   (void) SafeUnholdMemory(&amp;drvQEl, sizeof(drvQEl));  }    }    // Now retarget the new drive to the partition on the    // disk specified by firstBlock and sizeInBlocks.  We do    // this in the create call because some disk drivers    // don't always inherit the partition information from    // the drive that was cloned.    if (err == noErr) {  err = MoreSetDrivePartition(*newDrive, firstBlock, sizeInBlocks);    }    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>This routine works in two parts. First, it finds the drivequeue element associated with <CODE>driveToClone</CODE> andclones it using a <CODE>kGetADrive</CODE> request to thedriver. Then, it sets the new drive's partition location andsize using <CODE>MoreSetDrivePartition</CODE>, which isshown below.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>     extern pascal OSErr MoreSetDrivePartition(SInt16 drive, UInt32 firstBlock,     UInt32 sizeInBlocks)    // See comment in interface part.{    OSErr err;    CntrlParam pb;    DrvQElPtr drvQEl;    // First check that the driver supports the File Exchange    // interface.    err = noErr;    if ( ! MoreDriveSupportFileExchange(drive) ) {  err = controlErr;    }    // Find the drive queue element associated with    // drive.  This is an input parameter to    // kRegisterPartition.    if (err == noErr) {  err = MoreUTFindDriveQ(drive, &amp;drvQEl);    }    // Make the kRegisterPartition Control request.  We    // don't need to hold any memory because all the    // parameters to this Control request are entirely    // contained within the parameter block.&nbsp;    if (err == noErr) {  pb.ioVRefNum = drive;  pb.ioCRefNum = MoreGetDriveRefNum(drive);  pb.csCode = kRegisterPartition;  *((DrvQElPtr *) &amp;pb.csParam[0]) = drvQEl;  *((UInt32 *) &amp;pb.csParam[2]) = firstBlock;  *((UInt32 *) &amp;pb.csParam[4]) = sizeInBlocks;&nbsp;  err = PBControlSync((ParmBlkPtr) &amp;pb);    }    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR>          <P>Once you have a drive queue element that spans the blocksyou're interested in, you can read and write those blocksusing standard Device Manager routines, for example,<CODE>PBReadSync</CODE>. The next listing shows how thismight be done.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static OSErr ReadBlock(SInt16 drive, UInt32 blockNumber, void *blockBuffer){    OSErr err;    IOParam pb;    pb.ioVRefNum = drive;    pb.ioRefNum = MoreGetDriveRefNum(drive);    pb.ioBuffer = blockBuffer;    pb.ioReqCount = 512;    pb.ioPosMode = fsFromStart;    pb.ioPosOffset = blockNumber * 512;    err = PBReadSync( (ParmBlkPtr) &amp;pb );    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="PartitionHandlingBackground"></A><H3>PartitionHandling: Background and Rationale</H3><P>To understand the current disk driver architecture, youreally need to understand the history of how it evolved,starting with the floppy disk drives on the Mac 128.</P><H4>Mac 128 Disk Driver</H4><P>When the original Mac shippedall disks were floppy disks, which did not supportpartitions. The floppy disk driver would create a singledrive queue element that represented the entire disk, andthe File Manager used thisdrive as the entire volume. There was a one-to-onetranslation between logical blocks on the volume (blocksthat the File Manager requests) and physical blocks on thedisk.</P><P>For example, on a floppy disk, if the File Managerrequests block 64, the disk driver would simply return block64.</P><P>Disk insertion was handled with the following algorithm:</P><OL>   <LI>The disk driver created a drive queue element for   each physically attached floppy drive.</li>      <LI>When the user inserted a disk in a drive, the driver   posted a disk inserted (<CODE>diskEvt</CODE>) event for   that drive.</li>      <LI>The next time the application called   <CODE>GetNextEvent</CODE> (a predecessor to   <CODE>WaitNextEvent</CODE>), the (Toolbox) Event Manager   got the "disk inserted" event and called   <CODE>_MountVol</CODE>.</li>      <LI><CODE>_MountVol</CODE> only recognized built-in file   systems, such as MFS and HFS. An attempt to mount an   unsupported file system would cause   <CODE>_MountVol</CODE> to return an error.</li>      <LI>The (Toolbox) Event Manager put the error result from   <CODE>_MountVol</CODE> into the high word of the   <CODE>message</CODE> field of the   <CODE>EventRecord</CODE>, and returned the "disk inserted"   event to the application.</li>      <LI>The application saw the "disk inserted" event and   examined the high word of the event's   <CODE>message</CODE> field. If the value was not zero,   the "disk inserted" event was "bad" and the application   called the Disk Initialization Package's   <CODE>DIBadMount</CODE> routine. <CODE>DIBadMount</CODE>   would give the user the opportunity to initialize or eject the disk.</li></OL><H4>SCSI and Partitions</H4><P>The introduction of SCSI hard disk devices on the MacPlus made this situation more complex. Hard disk devicessupport multiple partitions. The File Manager was notchanged to recognize these partitions, so the burden ofsupporting partitions fell on the disk driver. When a diskis partitioned, the disk driver must read the partition mapand creates a drive queue element for each HFS partition (apartition whose <CODE>pmParType</CODE> is "Apple_HFS") onthe disk.</P><P>Thus, each drive queue element on a partitioned diskcontains an implicit translation from logical blocks tophysical blocks. For example, if you have a partition thatstarts at block 1024 and continues for 4096 blocks, thedriver creates a drive queue element for a drive whose sizeis 4096 blocks. When the system reads logical block 64 onthat volume, the driver knows that it must translate that tophysical block 1088 (that is, 1024 + 64) on the disk.</P><P>The new disk insertion algorithm was:</P><OL>   <LI>The ROM or a system extension loaded the disk driver.</li>      <LI>The disk driver parsed the partition map looking for   all the partitions of type "Apple_HFS". For each found   partition, the driver would create a drive queue element   and post a "disk inserted" event.</li>      <LI>If the driver was being loaded at system startup, the   Start Manager would call <CODE>_MountVol</CODE> to mount   the startup volume. It would then boot from that volume.   Later, when the Finder launched and started calling   <CODE>GetNextEvent</CODE>, the "disk inserted" events for   other partitions would be processed.</li>      <LI>If the driver was being loaded after system startup,   the process would proceed as from step 3 above.</li></OL><P>This works just fine for disks with the Apple partitionmap and HFS partitions, where the driver recognizes both thepartition map format and the "Apple_HFS" partition mapentries, and creates the appropriate drive queue elements.However, it doesn't allow foreign disk formats to be handledcorrectly, in two importantcases.</P><OL>   <LI><STRONG><A NAME="Problem1"></A>The partition map   contains non-HFS partitions</STRONG> (such as "Apple_PRODOS" or   "Apple_UNIX_SVR2" (A/UX) partitions) -- When confronted   by a non-HFS partition, the driver has a difficult   choice. If it creates a drive queue element for the   partition and a suitable foreign file system is not   installed, the system asks   the user whether they want to initialize the partition.   Probably not good. On the other hand, if it doesn't   create a drive queue element for the partition, there is   no way for a foreign file   system to access the data on   the partition. To safeguard user data, most drivers   choose the second alternative.</li>      <LI><STRONG>The partition map format is   unrecognized</STRONG> -- As Mac OS loads disk drivers   from a partition on the disk, it is rare that a disk   driver is loaded for a non-Apple partitioned disk.   However, if a driver is loaded (by a system extension,   for example) for a disk with an unrecognized partition   map (such as a DOS partition map), it faces the same   difficult choice described above. Most drivers resolve   this issue by simply not creating any drive queue   elements for disks with an unrecognized partition map.</li></OL><P>A foreign file system (such as a File System Managerplug-in) is responsible for controlling a volume mounted ona particular drive (represented by a drive queue element).If there is no drive queue element for a partition, there isno obvious way to create one. Similarly, if there is nodriver for a particular disk (because the disk doesn't havean Apple partition map to load it from), there is no easyway for the foreign file system to read from or write to the disk.</P><H4>File System Manager</H4><P>When File System Manager was introduced, it defined a newway for disk drivers to announce the arrival of new drivequeue elements. This mechanism allows disk drivers to createdrive queue elements for non-Apple partitions, free from thefear of the dreaded "This is not a Macintosh disk. Would youlike to initialize it?" dialog.</P><P>The new algorithm works as described below:</P><OL>   <LI>When the disk driver loads, it parses the partition   map. For each partition of type "Apple_HFS", the driver   creates a drive queue element and posts a "disk inserted"   event. For other partition types, the disk driver creates   a drive queue element whose FSID is   <CODE>fsmGenericFSID</CODE> and calls   <CODE>InformFSM</CODE> with the   <CODE>fsmDrvQElChangedMessage</CODE> message. If it can't   recognize the partition map, the driver just creates a   single drive queue element whose FSID is   <CODE>fsmGenericFSID</CODE> and calls   <CODE>InformFSM</CODE> with the   <CODE>fsmDrvQElChangedMessage</CODE> message.</li>      <LI>When <CODE>InformFSM</CODE> is called with the   <CODE>fsmDrvQElChangedMessage</CODE> message, FSM posts a   "disk inserted" event for the drive if all the following   conditions are met:      <UL><LI>the drive's FSID is not zero,</li><LI>the drive's FSID is not<CODE>fsmIgnoreFSID</CODE>,</li><LI>the drive does not already have a volume mountedon it, and</li><LI>the drive's FSID is <CODE>fsmGenericFSID</CODE> orthe drive's FSID matches the FSID of one of theinstalled FSM plug-ins.</li>   </UL>   		</li>      <LI>Each "disk inserted" event is handled as before,   except:      <OL><LI TYPE="1">FSM passes <CODE>_MountVol</CODE>requests to external file systems, which have theopportunity to claim the drive as a foreign volume.</li><LI>FSM tail patches <CODE>_MountVol</CODE>. If<CODE>_MountVol</CODE> fails and the drive on whichthe mount was attempted has the FSID of<CODE>fsmGenericFSID</CODE>, FSM causes<CODE>_MountVol</CODE> to return<CODE>nsDrvErr</CODE>. This error code, when passedback to the application and hence on to<CODE>DIBadMount</CODE>, causes<CODE>DIBadMount</CODE> to not display the diskinitialization dialog.</li>   </OL></li></OL><P>The effect of these changes is that disk drivers are nowfree to create a drive queue element for any partition andwill not trigger the Disk Initialization Package as long asthey set the FSID of the drive to<CODE>fsmGenericFSID</CODE>. This goes some way toaddressing problem 1, <A HREF = "#Problem1">describedabove</A>.</P><H4>File Exchange</H4><P>The final part of the solution for problem 1 is the FileExchange interface for disk drivers, as<A HREF = "#ImplementingFileExchangeSupport">definedabove</A>. To mount non-HFS partitions in an Apple partitionmap, File Exchange (and by extension any FSM plug-in) usesthis interface in the following way.</P><OL>   <LI>It first creates a new drive queue element by cloning   an existing drive queue element using   <CODE>kGetADrive</CODE>.</li>      <LI>It then retargets that drive queue element to   represent the partition map for the disk using   <CODE>kRegisterPartition</CODE>. For an Apple partition   map, this is a two-step process. First it must set the   partition to start at block 0 and be 2 blocks long. This   gives access to the driver descriptor map (DDM) and to   the first partition map entry. It then uses the first   partition map entry to determine the size of the   partition map. It then retargets the drive to represent   the entire DDM and partition map.</li>      <LI>It then reads through the partition map looking for   the required partition type. For each found partition, it   creates a new drive queue element (using   <CODE>kGetADrive</CODE>) and sets that drive queue   element to represent the partition's data. It can then   mount a volume on that drive queue element.</li></OL><P>A similar technique can be used for non-Apple partitionmaps.</P><P>File Exchange also includes a partial solution to problem2 in that it contains a generic SCSI disk driver. Atstartup time, File Exchange scans the SCSI bus looking fordevices that contain DOS partition maps. When it finds sucha device, it loads its generic SCSI driver for the device.Obviously that driver supports the File Exchange interface,which File Exchange then uses (in a similar process to thatdescribed above) to read through the DOS partition map andcreate drives for all the mountable DOS partitions on thedisk.</P><P>This is only a partial solution because (a) it onlysupports SCSI and ATA devices (the system includes a genericATA device driver), but not any other block devices, and (b)the mechanism for loading the generic SCSI driver is notdocumented to developers. However, as a disk driver writer,you can craft your driver to guarantee a total solution toproblem 2, as described in<A HREF = "#CooperatingWithFSM">Cooperating with File SystemManager</A>.</P><BR><P><A HREF="#top">Back to top</A></P><A NAME="PrivateControlAndStatusRequests"></A><H2>Private Control and Status Requests</H2><P>If you define private Control and Status requests forcommunication with your device driver, you must followcertain rules to ensure their reliable operation. Thissection outlines these rules.</P><H3>Private csCode Selection</H3><P>If your driver claims to supports<A HREF = "#DriverGestalt">Driver Gestalt</A>, it must not useany <CODE>csCode</CODE> below 128 for a private Control orStatus request. All private <CODE>csCodes</CODE> must be allocated fromthe range 128 to 32767.</P><H3>Private Means Private</H3><P>If you implement a Control or Status request that isprivate to your driver, you must issue it only to yourdriver. Do not issue your private Control and Statusrequests to other drivers, because the other driver mightuse the private <CODE>csCode</CODE> for a completelydifferent purpose, one that is potentially fatal to userdata (such as rewriting the partition map!).</P><P>At a minimum, you must check the driver name beforeissuing a private Control or Status request. You may alsowant to perform other checks (such as verifying a signaturein the driver header, or issuing a private Driver Gestalt)just to be sure.</P><H3>Synchronous != System Task Time</H3><P>As described in DTS Technote 1067, <a href="tn1067.html">"TraditionalDevice Drivers: Sync or Swim</A>," calling a device driversynchronously does not guarantee that the driver's entrypoint will run at system task time. If you are defining aControl or Status request for which your driver must dosomething that is not interrupt safe, you must define therequest to be executed immediately.</P><H3>Private Requests and Virtual Memory</H3><P>If your driver supports virtual memory (you can use the<CODE>kdgVMOptions</CODE> <A HREF = "#DriverGestalt">DriverGestalt</A> selector to indicate this), you must be carefulto avoid fatal page faults when fielding private Control orStatus requests. Specifically, your driver must not cause apage fault while it is fielding a queued (that is,synchronous or asynchronous) request.</P><P>The Virtual Memory Manager holds the entire<CODE>ParamBlockRec</CODE> (80 bytes) passed to all queued<CODE>_Read</CODE>, <CODE>_Write</CODE>,<CODE>_Control</CODE>, and <CODE>_Status</CODE> calls. Inaddition, VM holds the I/O buffer (pointed to by<CODE>ioBuffer</CODE>, for length <CODE>ioReqCount</CODE>)for <CODE>_Read</CODE> and <CODE>_Write</CODE> requests.Thus your driver can safely access this memory withoutcausing a fatal page fault.</P><P>The problem comes when you define a private Control orStatus request whose <CODE>ParamBlockRec</CODE> contains apointer to another piece of memory. If your driver accessesthat memory, it may cause a page fault. If your driversupports virtual memory, that page fault will be fatal(because a page fault while any paging device is busy isfatal).</P><P>There are a number of ways to avoid this problem.</P><OL>   <LI>Always include all information "inline" in the   parameter block. Remember that the parameter block is   automatically held for you by the Virtual Memory Manager.</li>      <LI>If you must include pointers in your parameter block,   define your private Control or Status interface to be   called immediately. Immediate requests to a driver do not   mark the driver as busy, and hence any page faults they   cause will not be fatal. However, your driver must be   written to support immediate requests of this kind.</li>      <LI>If none of the above are suitable, you must require   that your clients hold any buffers pointed to by the   parameter block.</li></OL><P>If you're making a queuedControl or Status request to a device driver which supportspaging and the parameter block contains pointers to otherdata structures, you should hold those data structures, justto be sure.</P><P>For more background about how the Mac OS Virtual MemoryManager prevents fatal page faults, see DTS Technote 1094, <a href="tn1094.html">"VirtualMemory Application Compatibility</A>."</p><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="ReadVerifyMode"></A></P><H2>Read-Verify Mode</H2><P>Very few disk driver writers support read-verify mode intheir drivers, perhaps on the mistaken assumption that it isdifficult to do. This may be because the historicaldefinition of read-verify mode in the ".Sony" driver istricky to implement for any DMA-based peripheral. Thissection explains the current definition of read-verify mode,the best way to support it in your driver, and the best wayfor application software to use it.</P><H3>Read-Verify Mode Explained</H3><P>Read-verify mode is engaged by setting<CODE>rdVerifyMask</CODE> in the <CODE>ioPosMode</CODE>field of the I/O parameter block passed to a device driver.The original definition of read-verify mode is that thedriver should do a byte-for-byte comparison of the databuffer (pointed to be <CODE>ioBuffer</CODE> and<CODE>ioReqCount</CODE>) with the data on disk. If they arethe same, the operation would succeed. If they aredifferent, the operation would fail with an<CODE>ioErr</CODE>.</P><P>This was easy to implement in the classic ".Sony" driverbecause the driver polled all bytes in to and out of memory.So implementing read-verify mode was a simple as changingthe original copy loop:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>while ( err == noErr &amp;&amp; ioActCount != ioReqCount ) {    err = GetByte(ioBuffer + ioActCount);    if (err == noErr) {  ioActCount += 1;    }}</pre></TD></TR></TABLE></CENTER><BR><BR>   <p>to a verify loop:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>while ( err == noErr &amp;&amp; ioActCount != ioReqCount ) {    err = GetByte(&amp;tmp);    if (err == noErr &amp;&amp; tmp != *(ioBuffer + ioActCount)) {  err = ioErr;    }    if (err == noErr) {  ioActCount += 1;    }}</pre></TD></TR></TABLE></CENTER><BR><BR><P>This form of read-verifymode is tricky to implement inmodern disk drivers, which typically use a DMA engine totransfer the data. So the definition of read-verify mode haschanged, as explained in the next section.</P><H3>Implementing Read-Verify Mode in Your Driver</H3><P>The new definition of read-verify mode is simple to explain, and to implementin your driver. If your driver gets a read-verify request,it should treat it exactly like a read request except thatit must disable all caches for the request. The datatransferred into memory must have originated from thephysical medium itself.</P><P>This new definition of read-verify mode still allowsapplications to perform read-verify operations, as explainedin the next section.</P><H3>Using Read-Verify Mode in an Application</H3><P>It is easy to write software that uses read-verify modein way that is compatible with both the old and new definitions. The<CODE>FSWriteVerify</CODE> routine in the DTS sample"MoreFiles" is an excellent example. The basic algorithm isas follows.</P><OL>   <LI>Write the data to the disk in the traditional way.</li>      <LI>Copy the data to a temporary buffer.</li>      <LI>Read the data back into the temporary buffer.</li>      <LI>Compare the temporary buffer to the original data.</li></OL><P>This works because:</P><UL>   <LI>if the driver implements read-verify mode in the old   way, any errors will be detected at step 3, and</li>      <LI>if the driver implements read-verify mode in the new   way, any errors will be detected at step 4.</li></UL><BR><P><A HREF="#top">Back to top</A></P><A NAME="colorIcons"></A><H2>Color Icons</H2><P>A classic problem with disk drivers is that the mechanismfor returning icons from a disk driver (Control requests <CODE>kDriveIcon</CODE> (21) and <CODE>kMediaIcon</CODE> (22), documented in Technote DV 17, <a href="../dv/dv_17.html">"SonyDriver: What Your Sony Drives for You</A>") is limited toblack-and-white icons. In Mac OS 8, the Finder was changedto look at the drive and apply special-case color icons, butthere was still no generic way for a disk driver to return acolor icon.</P><P>Mac OS 8.5 and later allow disk drivers to return coloricons. This is done through two new Driver Gestaltselectors, <CODE>kdgPhysDriveIconSuite</CODE> (equivalent tothe <CODE>kDriveIcon</CODE> (21) Control request) and<CODE>kdgMediaIconSuite</CODE> (equivalent to the<CODE>kMediaIcon</CODE> (22) Control request). To give yourdrives a color icon, you must respond to these DriverGestalt requests by putting a pointer to an icon family(<CODE>'icns'</CODE>) in <CODE>driverGestaltResponse</CODE>.The icon family allows you to return any number of iconsizes and depths in one data structure.</P><P>You can build an icon family in a number of ways.</P><UL>   <LI>Manually -- The format is documented in   "IconServices.r". This approach is most suitable for boot   disk drivers which typically statically link the icon   into the driver code resource.</li>      <LI>Resource Editor -- Modern resource editors have been   updated to edit these structures directly.</li>      <LI>Programatically -- The Icon Services programming   interface allows you to create an icon family from an   icon suite, as shown in the code sample below. This   approach is more suitable for disk drivers that are   loaded after the machine has started to boot, for   example, network or disk image drivers.</li></UL>   <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static IconFamilyPtr GetRamDiskIconFamily(void){    OSErr err;    OSErr junk;    IconFamilyPtr result;    IconSuiteRef iconSuite;    IconFamilyHandle iconFamily;    Size iconFamilySize;    result = nil;    iconSuite = nil;    iconFamily = nil;    err = GetIconSuite(&amp;iconSuite, 128, kSelectorAllAvailableData);    if (err == noErr) {  err = IconSuiteToIconFamily(iconSuite, kSelectorAllAvailableData, &amp;iconFamily);    }    if (err == noErr) {  iconFamilySize = GetHandleSize( (Handle) iconFamily);  result = (IconFamilyPtr) NewPtrSys(iconFamilySize);  err = MemError();  if (err == noErr &amp;&amp; result == nil) {   err = memFullErr;  }    }    if (err == noErr) {  BlockMoveData(*iconFamily, result, iconFamilySize);    }&nbsp;    // Clean up.&nbsp;    if (iconSuite != nil) {  (void) DisposeIconSuite(iconSuite, false);    }    if (iconFamily != nil) {  DisposeHandle( (Handle) iconFamily);    }    return result;}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Icon Services always requests icons using animmediate request at system task time. Your drivercan move or purge memory in response to theserequests. Be warned; however, that this immediaterequest can cause your driver to be reentered.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>If an application issues these Driver Gestaltrequests, it must follow Icon Services and issuethem using an immediate request at system tasktime.</p></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="DiskDriverPowerManagement"></A><H2>Disk Driver Power Management</H2><P>This section is not yet finished and has been omitted in the interests of shippingan initial version of the technote. A future revision ofthis technote will cover disk driver power management. Inthe meantime, you can consult the following references:</P><UL>   <LI><CITE>Inside Macintosh: Devices</CITE>,   <a href="http://developer.apple.com/documentation/mac/Devices/Devices-230.html">Power   Manager</A></li>      <LI>DTS Technote 1046,    <a href="tn1046.html">"Inside   Macintosh: Devices, Power Manager Addenda"</A></li>      <LI>DTS Technote 1039,    <a href="tn1039.html">"File   Access and the Power Manager"</A></li></UL><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="TargetMode"></A></P><H2>Target Mode</H2><P>Most PowerBooks support <STRONG>target mode</STRONG>(commonly known as "SCSI disk mode"), in which the attachmentof a special cable causes the PowerBook to make its internalhard disk device available as a SCSI target device. ForPowerBooks that use internal SCSI hard disk devices,support for target mode requires no special work by the diskdriver. The PowerBook simplystays off of the SCSI bus and the host computer has freeaccess to the PowerBook's internal hard disk device.However, for PowerBooks that use aninternal ATA hard disk device, the implementation of targetmode is somewhat more complex, and requires explicit supportby the ATA disk driver.</P><P>When a PowerBook with an internal ATA hard disk deviceboots in target mode, the CPU runs special target modesoftware. This software loads the ATA driver for theinternal hard disk device and then puts the built-in SCSIcontroller into target mode, listening for incoming SCSIrequests. When such a request is made, the CPU services thatrequest by interpreting the incoming SCSI command. If thecommand requires disk I/O, the CPU makes an appropriate I/Orequest to the ATA disk driver to satisfy that I/O.</P><P>In order to support target mode, your ATA disk drivermust support some additional Control and Status requeststhat allow the target mode software to do its job. Theserequests are described in the remainder of this section.</P><H3>Target Mode Checklist</H3><P>If your ATA disk driver is having trouble when used intarget mode, check that you support the following items.</P><UL>   <LI>You must support the <CODE>kdgBoot</CODE>   (<CODE>'boot'</CODE>) Driver Gestalt selector as   <A HREF = "#kdgBootForATA">described above</A>.</li>      <LI>You must return <CODE>kdgDiskType</CODE>   (<CODE>'disk'</CODE>) in response to the   <CODE>kdgDeviceType</CODE> (<CODE>'devt'</CODE>) Driver   Gestalt selector.</li>      <LI>You must support the <CODE>kPhysicalIOCode</CODE>   (17) Control request,   <A HREF = "#kPhysicalIOCode">described below</A>.</li>      <LI>You must support the <CODE>kGetDriveCapacity</CODE>   (125) Status request,   <A HREF = "#kGetDriveCapacity">described below</A>.</li>      <LI>You must support the <CODE>kSetPowerMode</CODE> (70)   Control request, described in   <A HREF = "ftp://ftp.apple.com//developer/Development_Kits/PCI_Driver_SDK.sit.hqx">Designing   PCI Cards and Drivers for Power Macintosh Computers</A>.</li>      <LI>You may choose to support the   <CODE>kGetErrorInfo</CODE> (123) and   <CODE>kGetDriveInfo</CODE> (124) Status requests, although the   system will accommodate you   not supporting them. <A HREF = "#TargetModeOptional">See   below</A> for details of how to support these Status   requests.</li></UL><H3>Required Control and Status Requests</H3><P>Your ATA driver must support the Control and Statusrequests described in this section in order to work intarget mode.</P><H4><A NAME="kPhysicalIOCode"></A>Switching to Physical I/OMode</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</b></p></TD><td width=200 align=left><P><CODE>_Control</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</b></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kPhysicalIOCode</CODE> (17)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>A drive number of a drive controlled by yourdriver</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0]</CODE></p></TD><td width=100 align=left><P><CODE>UInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>Contains either 1 to specify physical I/O mode,or 0 to specify logical I/O mode</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must changehow it does logical-to-physical block translation on thedrive specified by <CODE>ioVRefNum</CODE>. If<CODE>csParam[0]</CODE> is 1, your driver must disablelogical-to-physical block translations on the drive forsubsequent I/O requests. In this mode, an I/O request forlogical block X will always access physical block X. If<CODE>csParam[0]</CODE> is 0, your driver must re-enablelogical-to-physical block translation. In this mode, an I/Orequest for logical block X will access physical block X +Y, where Y is the offset from the beginning of the disk ofthe partition represented by the drive.</P><P>For more details on logical-to-physical blocktranslation, see <A HREF = "#BlockTranslation">BlockTranslation</A>.</P><P>If <CODE>ioVRefNum</CODE> is not a drive numbercontrolled by your driver, it must return<CODE>nsDrvErr</CODE>.</P><H4><A NAME="kGetDriveCapacity"></A>Returning Disk Size</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</b></p></TD><td width=200 align=left><P><CODE>_Status</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</b></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kGetDriveCapacity</CODE> (125)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The <CODE>ataDeviceID</CODE> of yourdevice</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0]</CODE></p></TD><td width=100 align=left><P><CODE>UInt16</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>Your disk driver must set this to the bottom 16bits of the number of physical blocks on the device</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[1]</CODE></p></TD><td width=100 align=left><P><CODE>UInt16</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>Your disk driver must set this to the top 16bits of the number of physical blocks on the device</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must returnthe physical size (in 512-byte blocks) of the disk in thedevice.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>In this request, <CODE>ioVRefNum</CODE> is an<CODE>ataDeviceID</CODE>, not themore typical drive number.</p></TD></TR></TABLE></CENTER><BR><BR><P>If <CODE>ioVRefNum</CODE> is not an <CODE>ataDeviceID</CODE> of a devicecontrolled by your driver, it must return<CODE>nsDrvErr</CODE>.</P><H3><A NAME="TargetModeOptional"></A>Optional StatusRequests</H3><P>Your ATA driver may support the following Status requeststo improve the fidelity of SCSI target emulation.</P><H4>Returning Error Information</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</b></p></TD><td width=200 align=left><P><CODE>_Status</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</b></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kGetErrorInfo</CODE> (123)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>A drive number of a drive controlled by yourdriver</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[2]</CODE></p></TD><td width=100 align=left><P><CODE>OSErr</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>Your disk driver must set this to the last errorthat occurred on the drive</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[3..4]</CODE></p></TD><td width=100 align=left><P><CODE>UInt32</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>Your disk driver must set this to the number ofbytes that were transferred in the I/O request thatcaused the last error on the drive</p></TD></TR></TABLE><br><P>In response to this request, your disk driver must returnthe information described above about the last error thatoccurred on the drive.</P><P>If <CODE>ioVRefNum</CODE> is not a drive numbercontrolled by your driver, it must return<CODE>nsDrvErr</CODE>.</P><H4>Getting Information About the Drive</H4><TABLE BORDER=0>   <TR><td width=50 align=left><P><B>Trap</b></p></TD><td width=200 align=left><P><CODE>_Status</CODE></p></TD></TR>   <TR><td width=50 align=left><P><B>Mode</b></p></TD><td width=200 align=left><P>Synch, Async</p></TD></TR></TABLE><TABLE BORDER=1>   <TR><td width=91 align=left><P><CODE>csCode</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P><CODE>kGetDriveInfo</CODE> (124)</p></TD></TR>   <TR><td width=91 align=left><P><CODE>ioVRefNum</CODE></p></TD><td width=100 align=left><P><CODE>SInt16</CODE></p></TD><td width=22 align=left><P>-&gt;</p></TD><td align="left"><P>The <CODE>ataDeviceID</CODE> of yourdevice</p></TD></TR>   <TR><td width=91 align=left><P><CODE>csParam[0..1]</CODE></p></TD><td width=100 align=left><P><CODE>void *</CODE></p></TD><td width=22 align=left><P>&lt;-</p></TD><td align="left"><P>Your disk driver must set this to a pointer to a20-byte structure containing ASCII text describingthe attached drive; the first 16 bytes should bethe model number, the next 4 bytes should be thefirmware revision number</p></td></tr></table><BR><P>In response to this request, your disk driver must returnthe information described above about the attached drive.The target mode software uses this information to satisfy aSCSI Inquiry (<CODE>$12</CODE>) command.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The Apple ATA driver extracts this informationfrom the results of an ATA<CODE>kATAcmdDriveIdentify</CODE> (<CODE>$EC</CODE>) command tothe device. The model number is extracted frombytes 27 through 42 of the response. The firmwarerevision number is extracted from bytes 23 through26 of the response.</p>    </TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>In this request, <CODE>ioVRefNum</CODE> is an<CODE>ataDeviceID</CODE>, not themore typical drive number.</p></TD></TR></TABLE></CENTER><BR><BR>  <P>If <CODE>ioVRefNum</CODE> is not an <CODE>ataDeviceID</CODE> of a devicecontrolled by your driver, it must return<CODE>nsDrvErr</CODE>.</p><BR><P><A HREF="#top">Back to top</A></P><A NAME="Summary"></A><H2>Summary</H2><BLOCKQUOTE><BLOCKQUOTE><P><CITE>When the war of the giantsis over, the war of the pygmies will begin.</CITE></P><P>Winston S. Churchill</P><P>This technote <EM>is</EM> the summary!</p></BLOCKQUOTE></BLOCKQUOTE><BR><P><A HREF="#top">Back to top</A></P><a name="References"></a><H2>References</H2><p>See the <A HREF = "#ExistingInformation">ExistingInformation</A> section of the technote.</p><A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Acrobat version of this Note (1800K).</P></TD><td width=60 align=left>   <p><A HREF="pdf/tn1189.pdf">Download</A></P></TD>  </TR>   <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/bluebook.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>PartitionExtras.h(49K)</P></TD><td width=60 align=left>   <p><A HREF = "downloads/tn1189.1.hqx">Download</a></P></TD>  </TR>        <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/bluebook.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>MoreIsBetter (contains MoreDisks module) (486K)</P></TD><td width=60 align=left>   <p><A HREF = "ftp://ftp.apple.com/developer/Sample_Code/Overview/MoreIsBetter.sit">Download</a></P></TD>  </TR> </table></center><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1189.html%3Fid%3DDTS10003028-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1189.html%3Fid%3DDTS10003028-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1189.html%3Fid%3DDTS10003028-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>