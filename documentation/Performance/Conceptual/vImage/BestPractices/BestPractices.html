<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>vImage Programming Guide: Best Practices for Using vImage</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Best Practices for Using vImage"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001001-CH211" title="Best Practices for Using vImage"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000430" target="_top">Performance</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000430-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30001001-CH201-TPXREF101">vImage Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ImageTransformationOperations/ImageTransformationOperations.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Glossary/Glossary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001001-CH211-SW1" title="Best Practices for Using vImage"></a><h1>Best Practices for Using vImage</h1><p>This chapter gives guidelines for getting  optimal performance from vImage. It covers the following best practices:</p><ul class="ul"><li class="li"><p>Make sure the system your application runs on meets the basic requirements</p></li><li class="li"><p>Use the Image I/O framework to load images into memory</p></li><li class="li"><p>When possible, use planar image formats</p></li><li class="li"><p>Take advantage of tiles</p></li><li class="li"><p>Align data buffers</p></li><li class="li"><p>Reuse buffers</p></li><li class="li"><p>Use threads appropriately</p></li><li class="li"><p>Separate 2D kernels into multiple 1D kernels</p></li></ul><a name="//apple_ref/doc/uid/TP30001001-CH211-SW3" title="Loading Image Data"></a><h2>Loading Image Data</h2><p>The first step to integrating vImage into your own applications is getting raw image data loaded into memory. You can use the Image I/O framework to load images of any major image file format (.JPG, .PNG, .GIF) into C-style buffers (void * arrays).</p><p>Below is an example of how to extract raw image data from a local file. If you would like to know more about the other methods and options available in Image I/O, see <em><a href="../../../../GraphicsImaging/Conceptual/ImageIOGuide/index.html#//apple_ref/doc/uid/TP40005462" target="_top">Image I/O Programming Guide</a></em>.</p><div class="codesample"><table><tr><td scope="row"><pre>NSURL* url = [NSURL fileURLWithPath:filename];<span></span></pre></td></tr><tr><td scope="row"><pre>//Create the image source with the options left null for now<span></span></pre></td></tr><tr><td scope="row"><pre>//Keep in mind since we created it, we're responsible for getting rid of it<span></span></pre></td></tr><tr><td scope="row"><pre>CGImageSourceRef image_source = CGImageSourceCreateWithURL( (CFURLRef)url, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>if(image_source == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //Something went wrong<span></span></pre></td></tr><tr><td scope="row"><pre>    fprintf(stderr, "VImage error: Couldn't create image source from URL\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>//Now that we got the source, let's create an image from the first image in the CGImageSource<span></span></pre></td></tr><tr><td scope="row"><pre>CGImageRef image = CGImageSourceCreateImageAtIndex(image_source, 0, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//We created our image, and that's all we needed the source for, so let's release it<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(image_source);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if(image == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //something went wrong<span></span></pre></td></tr><tr><td scope="row"><pre>    fprintf(stderr, "VImage error: Couldn't create image source from URL\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>After you’ve loaded the images into the buffers, they are ready to be passed to vImage functions. Pay close attention to the character sequence that follows the underscore in the function name—this is the format that it expects the pixel data to match. vImage functions can either work in-place (the output is in the same buffer that was passed as input) or they use a destination buffer that you can supply.</p><p>Since vImage handles only the image processing, you need to look to another technology to actually display the image. Depending on the goal of your application, or the application environment you used (Carbon or Cocoa), you may have to find a way of displaying the resultant pixel data (Quartz, for example), or saving the image data to disk (Image I/O).</p><a name="//apple_ref/doc/uid/TP30001001-CH211-SW2" title="Use Planer Image Formats"></a><h3>Use Planer Image Formats</h3><p>Most vImage functions come with four image format variants, (one for each of the image formats understood by vImage). Planar images encode one single channel at a time (e.g. all the byte data for the red channel is stored consecutively, then all for the green channel, then the blue, then alpha, and so on), instead of mixing the bits of all channels throughout the in-memory representation of the image (interleaved).</p><p>Since most vImage functions have to separate by channel the bits of the images you pass to it anyway (thus putting it into a planar format), it frequently makes sense to do this ahead of time. Since vImage usually works only on one channel at a time anyway, having your image data grouped by channel saves you the time that would usually be spent deinterleaving and reinterleaving each pixel. So in general, use planar image formats as much as possible.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001001-CH211-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;In some cases you may not even need all red, green, blue, and alpha channels. For example, you may know beforehand that the alpha channel is irrelevant in the images that you’re dealing with, or perhaps all of your images are grayscale and thus can use only one channel. Using planar formats makes it is possible to isolate only the channels you need.</p></div><a name="//apple_ref/doc/uid/TP30001001-CH211-SW4" title="Take Advantage of Tiles"></a><h3>Take Advantage of Tiles</h3><p>Tiling is a technique commonly used in graphics applications that takes a large image and breaks it into several, smaller images. This is called tiling because much like how floor tiles can be placed together to create a larger floor, small subunits of an image can be stitched together to form a larger image. The benefit behind this method is that CPUs tend to handle data a lot faster when it fits in their high-speed data caches.</p><p>In general, vImage functions have much better performance when the data they process (including input and output buffers) fit in processor data caches. Data stored in the CPU caches can be accessed a lot faster than data stored in main memory. While CPU cache memory is fast, it is also limited in space. Cache size varies from processor to processor, but in general it’s good to keep image tile sizes below 2 MB for Intel processors and below 512 KB for PowerPC processors.</p><ul class="spaceabove"><li class="li"><p>Here are some tips for tiling:</p><ul class="nested"><li class="nested li"><p>Some caches can only hold a small amount at a time (usually 512 KB or less)</p><ul class="nested"><li class="nested li"><p>Tile sizes of 128 KB - 256 KB give overall best throughput</p></li></ul></li><li class="nested li"><p>Many vImage functions use tiling (along with multithreading)internally. If you want to control tiling yourself, set the <code>kvImageDoNotTile</code> flag in the flags parameter when you call a function, which prevents the function from using tiling or multithreading internally.</p></li><li class="nested li"><p>For square tiles, a tile size of 128 KB to 256 KB gives the best overall throughput.</p></li><li class="nested li"><p>Which functions tile or multithread internally is subject to change from one release to another. If you are doing your own tiling or multithreading, you can probably improve performance by using the <code>kvImageDoNotTile</code> flag with all functions. You may also need the <code>kvImageDoNotTile</code> flag if you are concerned about vImage blocking on a condition variable while worker threads do the work. This may be required to prevent a priority inversion in real time code.</p></li><li class="nested li"><p>The best tile size varies according to function. Functions with very little computation per byte (mostly conversion functions) are fastest with tiles smaller than 16 KB. Typical vImage functions do best with 256 KB tiles. Tile size is less important for computation-heavy functions (such as those that use multithreading).</p></li></ul></li></ul><a name="//apple_ref/doc/uid/TP30001001-CH211-SW6" title="Align Data Buffers"></a><h3>Align Data Buffers</h3><p>When allocating floating-point data for images, it’s important to keep the data 4-byte aligned. This means that the amount of bytes that you allocate should be an integer multiple of 4.</p><p>Here are some tips about data alignment and buffer sizes:</p><ul class="spaceabove"><li class="li"><p>Though vImage tolerates lesser alignments, for best performance, everything should be 16-byte aligned and <code>rowbytes</code> should be a multiple of 16 bytes.</p></li><li class="li"><p>Floating-point data must be at least 4-byte aligned or some functions will fail.</p></li><li class="li"><p>The value you pass in the <code>rowBytes</code> parameter to a function should not be a power of 2.</p></li></ul><a name="//apple_ref/doc/uid/TP30001001-CH211-SW7" title="Reuse Buffers"></a><h3>Reuse Buffers</h3><p>Many vImage functions use temporary buffers to hold intermediate values when performing a task. Creating this buffer once initially, and supplying it to the various functions can save time depending on how frequently you call the functions.</p><p>If you do not provide a buffer, these functions allocate memory for themselves (and, of course, deallocate it when they are finished).</p><p>If you are going to call the function only a small number of times, and the possibility of blocking on a lock for a short period of time is not a concern, it is sensible to let the function allocate the buffer itself.</p><p>Each function that uses a temporary buffer has a <code>src</code> and a <code>dest</code> parameter (both of type <code>vImage_Buffer</code>). The function uses only the <code>height</code> and <code>width</code> fields of these parameters; the <code>data</code> and <code>rowBytes</code> fields are ignored.</p><p>If possible, applications should also try to reuse the regular image buffers that the <code>data</code> field of <code>vImage_Buffer</code> data type points to. This saves time otherwise spent reallocating and zero-filling the buffer.</p><p>In order to facilitate real-time usage, vImage avoids, as much as possible, usage of the heap and other operations that block on a lock, such as memory allocation</p><a name="//apple_ref/doc/uid/TP30001001-CH211-SW8" title="Thread Appropriately"></a><h3>Thread Appropriately</h3><p>vImage is thread-safe and can be called reentrantly. If you tile your image, you can use separate threads for different tiles. If you use different processors to handle different tiles, you should choose tiles that are not horizontally adjacent to each other. Otherwise the tile edges may share cache lines, potentially resulting in time-consuming crosstalk between the two processors.</p><p>The state of a vImage output buffer is undefined while a vImage call is working on it. There may be times when the value of a pixel is neither the starting data or ending result, but the result of some intermediate calculation.</p><p>In Mac OS X v10.4 and later, some vImage functions are transparently multithreaded internally. They do their own parameter checking and only multithread in cases where it is expected that a performance benefit will be obtained. vImage maintains its own lazily allocated pool of threads to do this work. Thus, your code should just automatically be multithreaded without you doing anything for those vImage functions that have been internally multithreaded. (In Mac OS X v10.4.0, these are most functions in <code>Geometry.h</code>, and the gamma functionality.) The threads are not destroyed once created. They are reused. The calling thread may block while it is waiting for the secondary threads to finish their work. It is safe to call internally multithreaded functions reentrantly.</p><p>Thread-safe functions use locks to maintain data coherency. If you don’t want functions to use locks, you may prevent vImage from multithreading and tiling by passing the <code>kvImageDoNotTile</code> flag. If you use this flag, your application is responsible for tiling its own data and doing its own multithreading.</p><a name="//apple_ref/doc/uid/TP30001001-CH211-SW9" title="Separate 2D Kernels into 1D Kernels"></a><h3>Separate 2D Kernels into 1D Kernels</h3><p>If you’re using convolution to apply filters to images, you can sometimes gain a performance boost by splitting the two-dimensional kernel into multiple one-dimensional kernels, and then applying the convolution twice (once per dimension).</p><p>You can, of course, pass the 2D kernel to one of the <code>vImageConvolve</code> functions. vImage uses the 2D kernel to perform nine multiply and eight add operations to compute each pixel result. To get better performance, call the <code>vImageConvolve</code> function twice, once for each of the 1D convolve filters. When separated, vImage performs three multiply and two add operations per pixel per convolve pass, for a total of six multiply and four add operations. You’ll notice that separating the convolution kernel into multiple passes, there is an algorithmic savings of one third of the multiply operations and half the add operations. For a M x N kernel, the processing cost is roughly reduced from M*N to M+N when kernels are separated. For larger kernels, the savings becomes more dramatic. A 5 x 5 kernel might be 2.5 times faster when separated, and a 11x11 kernel might be over 5 times faster!</p><p>Keep in mind that this technique may be slower in routines where the cost of traversing the image is higher than the arithmetic involved. This typically happens when the images are very large, or they don’t fit into physical RAM.</p><p>There are cases involving very large filters where separating the filter may be the only way to perform the convolution operation. A very larger filter that sums to a value larger than 2<sup>24</sup>, over its entirety or any part, runs the risk of overflowing the accumulators that vImage uses for 8-bit vImage convolution operations. In such cases, separating the kernel is likely to allow you to avoid the overflow. You can even use this to add more fixed-point precision into your filter, by scaling the filter values to be larger. The extent to which the loss of precision from the intermediate rounding offsets this advantage is unknown.</p><p>Separating the filters might be slower in routines where the cost of traversing the image is higher than the arithmetic involved. This typically happens with very large images, or images that don’t fit into physical RAM.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ImageTransformationOperations/ImageTransformationOperations.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Glossary/Glossary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-10-15<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Conceptual/vImage/BestPractices/BestPractices.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Conceptual/vImage/BestPractices/BestPractices.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Conceptual/vImage/BestPractices/BestPractices.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>