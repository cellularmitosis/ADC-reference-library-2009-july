<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoofWarsOld - /MoofWars/MoofWars.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGames-date.html">Games</a> &gt; <A HREF="javascript:location.replace('index.html');">MoofWarsOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/index.html" target="_blank">Reference Library > Games</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoofWarsOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoofWars/MoofWars.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MoofEncoder/AppConditionals.h</option>
<option value="listing2.html">/MoofEncoder/Color Search Procs.cp</option>
<option value="listing3.html">/MoofEncoder/Color Search Procs.h</option>
<option value="listing4.html">/MoofEncoder/GridEncode.cp</option>
<option value="listing5.html">/MoofEncoder/GridEncode.h</option>
<option value="listing6.html">/MoofEncoder/GridTilesFormat.h</option>
<option value="listing7.html">/MoofEncoder/ICL8Encode.cp</option>
<option value="listing8.html">/MoofEncoder/ICL8Encode.h</option>
<option value="listing9.html">/MoofEncoder/main.cp</option>
<option value="listing10.html">/MoofEncoder/main.h</option>
<option value="listing11.html">/MoofEncoder/PICTEncode.cp</option>
<option value="listing12.html">/MoofEncoder/PICTEncode.h</option>
<option value="listing13.html">/MoofEncoder/PICTMask.cp</option>
<option value="listing14.html">/MoofEncoder/PICTMask.h</option>
<option value="listing15.html">/MoofWars/AppConditionals.h</option>
<option value="listing16.html">/MoofWars/GridTilesFormat.h</option>
<option value="listing17.html">/MoofWars/MoofWars.cp</option>
<option value="listing18.html">/MoofWars/MoofWars.h</option>
<option value="listing19.html">/MoofWars/TCommandTimer.cp</option>
<option value="listing20.html">/MoofWars/TCommandTimer.h</option>
<option value="listing21.html">/MoofWars/TEnemySprite.cp</option>
<option value="listing22.html">/MoofWars/TEnemySprite.h</option>
<option value="listing23.html">/MoofWars/TShipSprite.cp</option>
<option value="listing24.html">/MoofWars/TShipSprite.h</option>
<option value="listing25.html">/MoofWars/TShotSprite.cp</option>
<option value="listing26.html">/MoofWars/TShotSprite.h</option>
<option value="listing27.html">/MoofWars/TSprite.cp</option>
<option value="listing28.html">/MoofWars/TSprite.h</option>
<option value="listing29.html">/MoofWars/TSpriteCollection.cp</option>
<option value="listing30.html">/MoofWars/TSpriteCollection.h</option>
<option value="listing31.html">/MoofWars/TTileCollection.cp</option>
<option value="listing32.html">/MoofWars/TTileCollection.h</option>
<option value="listing33.html">/MoofWars/TTileGrid.cp</option>
<option value="listing34.html">/MoofWars/TTileGrid.h</option>
<option value="listing35.html">/Tim's Libraries/Common Stuff.h</option>
<option value="listing36.html">/Tim's Libraries/Error Macros.h</option>
<option value="listing37.html">/Tim's Libraries/Scaling.cp</option>
<option value="listing38.html">/Tim's Libraries/Scaling.h</option>
<option value="listing39.html">/Tim's Libraries/TGraphic.cp</option>
<option value="listing40.html">/Tim's Libraries/TGraphic.h</option>
<option value="listing41.html">/Tim's Libraries/TGraphicCollection.cp</option>
<option value="listing42.html">/Tim's Libraries/TGraphicCollection.h</option></select>
				</p>
				</form>
				<p><strong><a href="MoofWarsOld.zip">Download Sample</a></strong> (&#147;MoofWarsOld.zip&#148;, 222.9K)<BR>
<strong><a href="MoofWarsOld.dmg">Download Sample</a></strong> (&#147;MoofWarsOld.dmg&#148;, 287.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MoofWars.cp  Contains:  All of the main game functions are defined in here, including initialization,         tear-down and the actual game loop.  Written by: Timothy Carroll  Copyright:  Copyright &copy; 1996-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/2/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1                4/2/97    Timothy Carroll  Now dispose of the color table when we exit                       the game.  Technically, we still end up leaking                       the appPalette, so this should be corrected if                        InitGame is called more than once.        4/2/97    Timothy Carroll  Now check DSpStartup error code.                2/24/97    Timothy Carroll  Now conditionally allocate QD globals if we aren't               using Metrowerks        1/23/97    Timothy Carroll  allocate QuickDraw globals so that MrC will               compile.        1/23/97     Timothy Carroll  Added include for Moofwars.h so that MrC will               compile        1/23/97    Timothy Carroll  Now include other system headers so that MrC               will compile.        8/15/96    Timothy Carroll  Initial Release        */#if __profile__#include &lt;profiler.h&gt;#endif#include &lt;fp.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Fonts.h&gt;#include &lt;Sound.h&gt;#include &quot;Moofwars.h&quot;#include &quot;TTileGrid.h&quot;#include &quot;TSpriteCollection.h&quot;#include &quot;TShipSprite.h&quot;#include &quot;TEnemySprite.h&quot;#include &quot;TShotSprite.h&quot;#if qShowTiming#include &lt;Timer.h&gt;#include &lt;FixMath.h&gt;#include &lt;TextUtils.h&gt;#endif/********************************************************************************  GLOBALS ********************************************************************************/// Quickdraw Globals#if TARGET_RT_MAC_CFM#ifndef  __MWERKS__QDGlobals  qd;#endif#endifCTabHandle        gAppColorTable = NULL;DSpContextReference    gDrawContext = NULL;// We define a few static variables to hold all the game information.  Only in a few cases// do we actually need to export this information to other functions.  In general, if a// particular object needs a piece of information, it should be sent directly to that object,// rather than be imported as a global.// The playing fieldstatic TTileGrid    *theGrid = NULL;WorldRect32       gWorldBounds;// All of the sprite groupsstatic TSpriteCollection    *gFriendlyShipGroup = NULL;static TSpriteCollection    *gEnemyShipGroup = NULL;static TSpriteCollection    *gFriendlyShotGroup = NULL;static TSpriteCollection    *gEnemyShotGroup = NULL;// We keep track of the two ships separately as well,// as we can use them as the camera locationstatic TShipSprite    *gFriendlyShip = NULL;static TEnemySprite    *gEnemyShip = NULL;// Although the sprites would load their own graphics (because of the magic of our TGraphic// collection, we can preload the graphics and pass them to the TSprite constructors for// speed.  These variables will manage the loading and unloading of the sprites.TGraphicCollection *gShipGraphics = NULL;TGraphicCollection *gEnemyGraphics = NULL;TGraphicCollection *gShotGraphics = NULL;#if qUsingSound// SoundsSndReference   gSounds[10];Boolean     gPlayingSound = true; // If false, no sounds will play#endif#if qShowTiming// Miscellaneouslong       gShotsOnBoard = 0;  // Holds the total number of shots in game#endif// Holds the current state of the keyboard and other input devices when processing// the list of sprites.TInputState     gCommandKeys;TCommandTimer    theTimer;// A standard set of lookup tables in 16.16 fixed notation, so that we can quickly// do sin and cos.  We currently use 48 frames because thats easy to do from// Specular Infini-D.  360/48 = 7.5&iexcl; per angle.SInt32       gSinLookup[48];SInt32      gCosLookup[48];/********************************************************************************  GLOBALS ********************************************************************************/void main (void);// Initialize everything for the gamestatic OSStatus InitGame (void);// Fills in the initial values in the lookup tables.static OSStatus InitAngleLookups (void);#if qUsingSound// Initializes Sound API and loads all the sound resourcesstatic OSStatus LoadSounds (void);#endif// This creates a draw sprocket contextstatic OSStatus InitDrawSprocket (void);// This loads all of our graphics and tile resourcesstatic OSStatus LoadGameGraphics (void);// This creates the grid, the initial sprites and sprite groups.static OSStatus CreateGame (void);// The actual event loopstatic OSStatus RunGame (void);// The cleanup code for InitGamestatic OSStatus CloseGame (void);/********************************************************************************  main    All main does is the standard mac init, followed by initializing the game  and running it once.  In a real game it would probably put up a splash screen  with some widgets on it. ********************************************************************************/void main (void){  int      loop;  OSStatus  theErr = noErr;  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(nil);  InitCursor();  MaxApplZone();    for (loop = 0; loop &lt; 30; loop++)    MoreMasters();      theErr = InitGame();  FAIL_OSERR (theErr, &quot;\pCouldn't initialize new game&quot;)  theErr = RunGame();  FAIL_OSERR (theErr, &quot;\pFailure in game running code&quot;)    error:  cleanup:    theErr= CloseGame();}/************************************************************************************ InitGame  Init Game loads all the sprites and sets up all the variables for running a game. Eventually, we can split out a large number of these routines so that they only need to be called when the application actually initializes, rather than once per game.  Of course, our loading routines are way cool, so we may not care. :)   ************************************************************************************/ OSStatus InitGame (void){  OSStatus         theErr = noErr;  PaletteHandle       appPalette;  // Load our initial color table and make it the default palette for the entire application.  // (We'll also send this color table to DrawSprocket)    gAppColorTable = GetCTable (kAppColorTableResID);  FAIL_NIL (gAppColorTable, &quot;\pFailed to load the color table&quot;)  appPalette = NewPalette (256, gAppColorTable, pmExplicit + pmTolerant, 0);  FAIL_NIL (appPalette, &quot;\pFailed to convert the color table into a palette&quot;)  SetPalette ( (WindowRef) -1L, appPalette, false);    // Initialize the sound effects#if qUsingSound  theErr = LoadSounds();  FAIL_OSERR (theErr, &quot;\pFailed to load the sounds&quot;)#endif  // Initialize our predefined arrays of the move angles.  theErr = InitAngleLookups();  FAIL_OSERR (theErr, &quot;\pFailed to initialize the lookup tables&quot;)// Initialize the keyboard command routines.#if qSyncTiming  theTimer.Initialize(30); // 30 frames per second#else  theTimer.Initialize (0); // one command per frame, fast as possible.#endif// Create a draw sprocket context  theErr = InitDrawSprocket ();  FAIL_OSERR (theErr, &quot;\pFailed to initialize draw sprocket&quot;)// Load the game graphics  theErr = LoadGameGraphics();  FAIL_OSERR (theErr, &quot;\pFailed to preload the game graphics&quot;)// Create all of the game objects -- note that the stuff in here is probably the only thing that// would be run more than once every time the application runs -- the rest of the initialization code// will all run once.  theErr = CreateGame();  FAIL_OSERR (theErr, &quot;\pFailed to create the game objects&quot;)    return noErr;    error:    if (theErr == noErr)    theErr = paramErr;  return theErr;  }/************************************************************************************InitAngleLookups   ************************************************************************************/OSStatus InitAngleLookups(void){  int loop;    for (loop = 0; loop &lt; 48; loop++)  {    double angle = (90 - loop * 7.5)/57.296;        gSinLookup[loop] = (1&lt;&lt;14) * sin (angle);    gCosLookup[loop] = (1&lt;&lt;14) * -cos (angle);  }  return noErr;}/************************************************************************************ LoadSounds This initializes whatever sound API we're using and loads all of the sound resources.  ************************************************************************************/ #if qUsingSoundOSStatus LoadSounds (void){  OSStatus theErr;  // Initialize and load all of the game sounds.  theErr = HY_Setup (kNormal, 5);  FAIL_OSERR (theErr, &quot;\p Failed to set up hollywood API&quot;)  gSounds[0] = HY_GetSoundResource(6000);  FAIL_NIL(gSounds[0], &quot;\p Failed to allocate the sound resource&quot;)  gSounds[1] = HY_GetSoundResource(6001);  FAIL_NIL(gSounds[1], &quot;\p Failed to allocate the sound resource&quot;)  gSounds[2] = HY_GetSoundResource(6002);  FAIL_NIL(gSounds[2], &quot;\p Failed to allocate the sound resource&quot;)  gSounds[3] = HY_GetSoundResource(6003);  FAIL_NIL(gSounds[3], &quot;\p Failed to allocate the sound resource&quot;)  gSounds[4] = HY_GetSoundResource(6004);  FAIL_NIL(gSounds[4], &quot;\p Failed to allocate the sound resource&quot;)  gSounds[5] = HY_GetSoundResource(6005);  FAIL_NIL(gSounds[5], &quot;\p Failed to allocate the sound resource&quot;)    return noErr;    error:  if (theErr == noErr)    theErr = paramErr;  return theErr;  }#endif/************************************************************************************InitDrawSprocket   ************************************************************************************/OSStatus InitDrawSprocket (void){  OSStatus         theErr = noErr;  DSpContextAttributes  screenData;  RGBColor        fade;  // Create a Draw Sprocket context for the screen.  theErr = DSpStartup();  FAIL_OSERR (theErr, &quot;\pError: Failed to start up DrawSprocket&quot;)    // fill in our requirements.  Anything we place here we need to have for our game to work properly.  screenData.frequency        = 0;  screenData.displayWidth        = 640;  screenData.displayHeight      = 480;  screenData.reserved1        = 0;  screenData.reserved2        = 0;  screenData.colorNeeds        = kDSpColorNeeds_Require;  screenData.colorTable        = gAppColorTable;  screenData.contextOptions      = 0;  screenData.backBufferDepthMask    = kDSpDepthMask_8;  screenData.displayDepthMask      = kDSpDepthMask_8;  screenData.backBufferBestDepth    = 8;  screenData.displayBestDepth      = 8;  screenData.pageCount        = 2;  screenData.gameMustConfirmSwitch  = false;  screenData.reserved3[0]        = 0;  screenData.reserved3[1]        = 0;  screenData.reserved3[2]        = 0;  screenData.reserved3[3]        = 0;    theErr = DSpUserSelectContext(&amp;screenData, 0,NULL, &amp;gDrawContext);  FAIL_OSERR (theErr, &quot;\p Failed to retrieve a drawing context&quot;)    // We should now alter the screenData to reflect things that would be useful to have, but aren't  // requirements.  #if qUsePageFlip  screenData.contextOptions  |= kDSpContextOption_PageFlip;  screenData.pageCount    = 3;#endif#if (!qSyncToDrawVBL)  screenData.contextOptions  |= kDSpContextOption_DontSyncVBL;#endif    // Reserve the screen and set it to active.  theErr = DSpContext_Reserve (gDrawContext, &amp;screenData);  FAIL_OSERR (theErr, &quot;\pFailed to reserve the context&quot;)#if 0  theErr = DSpContext_SetMaxFrameRate (gDrawContext, 60);  FAIL_OSERR (theErr, &quot;\p Failed to set the maximum frame rate&quot;)#endif    fade = kBlack; // DrawSprocket requires this to be a non-const param  theErr = DSpContext_FadeGammaOut (gDrawContext, &amp;fade);  FAIL_OSERR (theErr, &quot;\p Failed to fade out&quot;)  theErr = DSpContext_SetState (gDrawContext, kDSpContextState_Active);  FAIL_OSERR (theErr, &quot;\pFailed to activate the draw context&quot;)  theErr = DSpContext_FadeGammaIn (gDrawContext, &amp;fade);  FAIL_OSERR (theErr, &quot;\p Failed to fade in&quot;)  return noErr;    error:  if (theErr == noErr)    theErr = paramErr;  return theErr;}/************************************************************************************LoadGameGraphics  ************************************************************************************/ OSStatus LoadGameGraphics (void){  OSStatus theErr = noErr;// Preload and lock all of our game's graphics so that everything runs smoothly.    gShipGraphics = TGraphicCollection::NewCollection (kShipResourceID);  FAIL_NIL (gShipGraphics, &quot;\pcouldn't load friendly ship graphics&quot;)  gShipGraphics-&gt;LockCollection();    gShotGraphics = TGraphicCollection::NewCollection (kShotResourceID);  FAIL_NIL (gShotGraphics, &quot;\pcouldn't load friendly shot graphics&quot;)  gShotGraphics-&gt;LockCollection();// This version uses the same graphics for the enemy and friendly units, but you can// insert your own favorite graphics instead.    #if 0  gEnemyGraphics = TGraphicCollection::NewCollection (kEnemyResourceID);  FAIL_NIL (gEnemyGraphics, &quot;\pcouldn't load enemy graphics&quot;)  gEnemyGraphics-&gt;LockCollection();#endif  return noErr;    error:  if (theErr == noErr)    theErr = paramErr;  return theErr;}/************************************************************************************CreateGame   ************************************************************************************/OSStatus CreateGame (void){  OSStatus      theErr = noErr;  Rect         boundsRect   = {0,0, 480, 640};    TShipSpriteData    shipData;  TEnemySpriteData  enemyData;// Load the Grid and Tiles.  Note that we do load the tile graphics here as well --// we could move that to LoadGameGraphics if we wanted.// Load the tile grid information  theGrid = new TTileGrid();  theErr = theGrid-&gt;CreateGridFromResource(kGridResourceID);  FAIL_OSERR (theErr, &quot;\p Failed to load the grid resource&quot;)    // Initialize the world boundaries in 16.16 fixed point coordinates.    gWorldBounds.left = 0;  gWorldBounds.top = 0;  gWorldBounds.right = theGrid-&gt;GetGridWidth() * (32 &lt;&lt; 16);  gWorldBounds.bottom = theGrid-&gt;GetGridHeight() * (32 &lt;&lt; 16);    //  Create groups for all of our game's sprites  gFriendlyShipGroup = new TSpriteCollection ();  FAIL_NIL (gFriendlyShipGroup, &quot;\pcouldn't create friendly ship group&quot;)  gEnemyShipGroup = new TSpriteCollection ();  FAIL_NIL (gEnemyShipGroup, &quot;\pcouldn't create enemy ship group&quot;)  gFriendlyShotGroup = new TSpriteCollection ();  FAIL_NIL (gFriendlyShotGroup, &quot;\pcouldn't create friendly shot group&quot;)  gEnemyShotGroup = new TSpriteCollection ();  FAIL_NIL (gEnemyShotGroup, &quot;\pcouldn't create enemy shot group&quot;)    // Create the good guy ship    shipData.spriteData.spriteType = TShipSprite::kSpriteType;  shipData.spriteData.initialX = (100) &lt;&lt; 16;  shipData.spriteData.initialY = (100) &lt;&lt; 16;  shipData.spriteData.initialXVelocity = 0;  shipData.spriteData.initialYVelocity = 0;  shipData.spriteData.visibility = kVisible;  shipData.spriteData.face = 0;  shipData.spriteData.collectionID = 1000;  shipData.spriteData.preloadedCollection = gShipGraphics;  shipData.rotateInterval = 1;  shipData.shotInterval = 1;  shipData.shotsGroup = gFriendlyShotGroup;    gFriendlyShip = new TShipSprite(&amp;shipData);  gFriendlyShip-&gt;AddToGroup (gFriendlyShipGroup);    // Create the enemy ship  // We are using the same graphics here, but this can be changed if you want  // a separate villain.  enemyData.spriteData.spriteType = TEnemySprite::kSpriteType;  enemyData.spriteData.initialX = (1200) &lt;&lt; 16;  enemyData.spriteData.initialY = (1200) &lt;&lt; 16;  enemyData.spriteData.initialXVelocity = 0;  enemyData.spriteData.initialYVelocity = 0;  enemyData.spriteData.visibility = kVisible;  enemyData.spriteData.face = 0;  enemyData.spriteData.collectionID = 1000;  enemyData.spriteData.preloadedCollection = gShipGraphics;  enemyData.rotateInterval = 1;  enemyData.shotInterval = 1;  enemyData.shotsGroup = gEnemyShotGroup;      gEnemyShip = new TEnemySprite(&amp;enemyData);  gEnemyShip-&gt;AddToGroup (gEnemyShipGroup);    return noErr;    error:  if (theErr == noErr)    theErr = paramErr;  return theErr;}OSStatus RunGame (void){  // Is game currently running?  Boolean      running = true;    // We need a separate boolean to determine is the sound key is still being held down -- if it is, we  // don't toggle.  Otherwise we'd keep turning the sound off and on.  Boolean     soundKeyDown = false;    OSStatus    theErr = noErr;  //DrawSprocket will return us a CGrafPtr to draw into.  CGrafPtr    buffer;    //The center of the tile grid is tracked by a camera position.  In this version of the code, this  //position is identical to the ship, but it could actually be any arbitrary point.  Missile-CAM!  SInt32      cameraX, cameraY;  SInt32      tileTop, tileLeft;  Rect      clipping = {0,0,480,640};  #if qShowTiming  UnsignedWide  startMicroSec, endMicroSec;  Str255       theString;  long      frame;#endif    // We play a beep to signal the start of the game.  SysBeep(2);  HideCursor();  // Basic structure of the game loop is:  //  * erase all sprites  //  * draw all sprites in their new locations  //  * refresh the screen  //  * move and hit test the sprites based on any queued commands.    // Erasing and drawing is relative to a clipping rectangle and a graphics scale.  // If at all possible, keep different clipping areas in the game from overlapping.  // failing that, do all erases in all clip areas before any sprites are drawn.    // For the current version (fixed map), all scaling data is constant, so we can   // set it once and ignore it.  If we are changing the scaling data, then we need to  // move this section into the loop.  Note that scaling data will be different  // for erases and draws in that case.  // Set the initial camera location.  gFriendlyShip-&gt;GetCurrentWorldLocation(&amp;cameraX, &amp;cameraY);#if __profile__  ProfilerInit(collectDetailed, PPCTimeBase, 200, 30);#endif#if qShowTiming  Microseconds(&amp;startMicroSec);#endif#if qSyncTiming    theTimer.AcceptCommands(true);#endif  while (running)  {    /*************   Point at the Current Buffer    ***************************/    theErr =  DSpContext_GetBackBuffer( gDrawContext,kDSpBufferKind_Normal, &amp;buffer );  #if qDebugging    FAIL_OSERR(theErr, &quot;\p Failed to retrieve a drawing surface.&quot;)  #endif        SetPort ((GrafPtr) buffer);    SetDestinationBuffer (buffer-&gt;portPixMap, NULL);        /*************   Set the camera location        ***************************/        gFriendlyShip-&gt;GetCurrentWorldLocation(&amp;cameraX, &amp;cameraY);        SetBufferClip (&amp;clipping);    SetWorldOrigin(cameraX, cameraY);    /*************   Draw the Tile Grid   ************************/    tileLeft = (cameraX &gt;&gt; 16) - 320;    tileTop = (cameraY &gt;&gt; 16) - 240;        theGrid-&gt;DrawGrid (&amp;clipping, tileTop,tileLeft);    /**************  Show the time to draw the current frame *******/  #if qShowTiming    Microseconds(&amp;endMicroSec);    WideSubtract((wide *) &amp;endMicroSec, (wide *) &amp;startMicroSec);    Microseconds(&amp;startMicroSec); // start timing the next frame    frame = 1000000.0/endMicroSec.lo;        RGBForeColor (&amp;kWhite);    NumToString (frame, theString);    MoveTo (10,470);    DrawString (theString);    NumToString (gShotsOnBoard, theString);    MoveTo (10, 450);    DrawString (theString);    RGBForeColor (&amp;kBlack);  #endif      /*************   Draw all the sprites ***************/        gEnemyShipGroup-&gt;DrawSpriteGroup ();    gFriendlyShipGroup-&gt;DrawSpriteGroup ();    gEnemyShotGroup-&gt;DrawSpriteGroup ();    gFriendlyShotGroup-&gt;DrawSpriteGroup ();          /*************   Refresh the screen ***************/          theErr =  DSpContext_SwapBuffers( gDrawContext, NULL, NULL);  #if qDebugging    FAIL_OSERR (theErr,&quot;\p Failed to swap the buffers.&quot;)  #endif            /*************   Process Commands    *************************************/    // If we are syncing our timing, we'll make sure we have at least one command to process,    // and then loop until all of the commands are completed.  Otherwise we just grab one key    // state and call through the loop once.  #if qSyncTiming    // Wait for a command to actually show up    while (!theTimer.IsCommandWaiting())      ;    // Process all waiting commands.    while (theTimer.RetrieveCommand (&amp;gCommandKeys))  #else    theTimer.RetrieveCommand (&amp;gCommandKeys);  #endif    {          gFriendlyShipGroup-&gt;ProcessSpriteGroup();      gEnemyShipGroup-&gt;ProcessSpriteGroup();      gFriendlyShotGroup-&gt;ProcessSpriteGroup();      gEnemyShotGroup-&gt;ProcessSpriteGroup();            gFriendlyShotGroup-&gt;HitTest (gEnemyShipGroup);      gEnemyShotGroup-&gt;HitTest (gFriendlyShipGroup);        // Check for exit game      if (CheckKey ((unsigned char *) &amp;gCommandKeys, kExitGame))        running = false;              // Check for debugger break      if (CheckKey ((unsigned char *) &amp;gCommandKeys, kDebugger))      {        FlushEvents (everyEvent,0);        Debugger();      }    #if qUsingSound          // Give the sound API some time to service tasks.      HY_ServiceTasks();              // play some sounds.      if (CheckKey ((unsigned char *) &amp;gCommandKeys, kOne) &amp;&amp; gPlayingSound)      {        HY_PlaySoundHandle (1, gSounds[0], NULL, 0, false);      }      if (CheckKey ((unsigned char *) &amp;gCommandKeys, kTwo)  &amp;&amp; gPlayingSound)      {        HY_PlaySoundHandle (1, gSounds[1], NULL, 0, false);      }      if (CheckKey ((unsigned char *) &amp;gCommandKeys, kThree)  &amp;&amp; gPlayingSound)      {        HY_PlaySoundHandle (1, gSounds[2], NULL, 0, false);      }      if (CheckKey ((unsigned char *) &amp;gCommandKeys, kFour)  &amp;&amp; gPlayingSound)      {        HY_PlaySoundHandle (1, gSounds[3], NULL, 0, false);      }              // toggle the sound setting      if (CheckKey ((unsigned char *) &amp;gCommandKeys,kSoundToggle))      {        if (!soundKeyDown)        {          soundKeyDown = true;          gPlayingSound = !gPlayingSound;          if (!gPlayingSound)          {          HY_StopSample(1);          HY_StopSample(2);          HY_StopSample(3);          HY_StopSample(4);          }        }      }      else      {        soundKeyDown = false;      }    #endif        }  }    #if __profile__  ProfilerSetStatus(false);  ProfilerDump(&quot;\pMoofWarsDump&quot;);  ProfilerTerm();#endif    ShowCursor();  // We want to flush all the keyboard events we haven't been taking.    theTimer.AcceptCommands (false);  FlushEvents(everyEvent, 0);    return noErr;#if qDebugging  error:  return theErr;#endif}OSStatus CloseGame (void){  // This doesn't clean up everything just yet, but it should!  if (gFriendlyShipGroup != NULL)  {    delete gFriendlyShipGroup;    gFriendlyShipGroup = NULL;    }    if (gEnemyShipGroup != NULL)  {    delete gEnemyShipGroup;    gEnemyShipGroup = NULL;  }      if (gFriendlyShotGroup != NULL)  {    delete gFriendlyShotGroup;    gFriendlyShotGroup = NULL;  }      if (gEnemyShotGroup != NULL)  {    delete gEnemyShotGroup;    gEnemyShotGroup = NULL;  }  if (theGrid != NULL)  {    delete theGrid;    theGrid = NULL;  }  if (gShipGraphics != NULL)  {    gShipGraphics-&gt;DisposeReference;    gShipGraphics = NULL;  }      if (gShotGraphics != NULL)  {    gShotGraphics-&gt;DisposeReference;    gShotGraphics = NULL;  }    if (gDrawContext != NULL)  {    DSpContext_SetState (gDrawContext, kDSpContextState_Inactive);    DSpContext_Release( gDrawContext);    DSpShutdown();  }  if (gAppColorTable)    DisposeCTable (gAppColorTable);  return noErr;}Boolean CheckKey (unsigned char *PtrToKeyMap, short theKey){  unsigned char  theByte, theBit;  short      byteIndex;    byteIndex = theKey &gt;&gt; 3;  theByte = *(unsigned char *)(PtrToKeyMap + byteIndex);  theBit = 1L&lt;&lt;(theKey &amp; 7);    return (theByte &amp; theBit);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoofWarsOld/listing17.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoofWarsOld/listing17.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoofWarsOld/listing17.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>