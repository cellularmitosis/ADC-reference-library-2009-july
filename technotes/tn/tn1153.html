<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1153: Thread-Safe Toolbox Access From MRJ</title>    <meta name="keywords" content="Mac OS 8 Java Toolbox calls multi-thread safety LOCK MRJ">    <meta name="Description" content="Technical Note TN1153: This Technical Note 
for jdk 1.1.x on Mac OS Classic describes synchronization
techniques that will allow your native or JDirect code to
play safely (multi-thread safe) when making OS or Toolbox
calls."><meta name="categories" content="Java"><meta name="week-posted" content="Feb 1, 1999 - Feb 5, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002992" title="Thread-Safe Toolbox Access From MRJ"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxJava-date.html">Java</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Java/idxPorting-date.html" target="_blank">Java > Porting</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1153</div>
<div id="pageheadsub">Thread-Safe Toolbox Access From MRJ</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">   <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>            <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <span id="menutitle">CONTENTS   <br>  <br> </span>   </td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <!-- begin_toc --><P id = "menutext"><A HREF = "#Section1">How We Play Safely With the         Toolbox</A><BR>         <BR>         <A HREF = "#Section2">Paranoia and Reality</A><BR>         <BR>         <A HREF = "#Section3">The Perils of LOCKing</A><BR><BR>     <A HREF = "#References">References</A><BR><BR>         <A HREF="#Downloads">Downloadables</A></p>       <!-- end_toc --></td>  </tr>  <tr>   <td width=300 align=left scope="row"> <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>  </tr>    </table></td>  <td width=300 valign="top" align=left>            <!-- begin_intro_text --><P id = "introtext">Java is         pervasively multi-threaded. The Mac OS isn't. Most of it         isn't re-entrant, and parts of it are very dependent on         global state that needs to remain consistent from one call         to the next. This can cause big problems when trying to call         the Mac OS directly from Java. This technote describes         synchronization techniques that will allow your native or         JDirect code to play safely when making OS or Toolbox calls,         especially as we move forward to Mac OS X.</P>     <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Mar 1 1999]</h3><!-- end_date --></TD> </TR>    </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR>      <!-- begin_content -->               <P><A NAME=Section1></A></P>                  <H2>How We Play Safely With the Toolbox</H2>                  <P>As we all know, the basics of the Mac OS and Toolbox         (which for simplicity I'll just lump together as the         "Toolbox" here) were designed in the early 1980's for a         machine that could run only a single app at a time and a         single thread of execution in that app. Things have been         improved a bit since that time, but the constraints of that         basic design require that the Toolbox is still only         single-threaded. Cooperative multitasking between         applications means process switching occurs only at well         known times (when <CODE>WaitNextEvent</CODE> is called) and requires         swapping a whole mess of low-memory global state.</P>                  <P>This causes problems when trying to run multiple threads         in a Mac OS app. Toolbox calls are not re-entrant, which         means that while one thread is executing a Toolbox call, no         other thread can enter the Toolbox. Furthermore, the pervasive use of         global state (like the current <CODE>GrafPort</CODE> or the current         resource chain) means that a thread that needs to make a         sequence of calls that rely on that state needs to prevent         other threads from using or changing that state.</P>                  <P>We had to deal with these issues in implementing the AWT         for MRJ 2.1, since most of the AWT is written in Java code         that calls the Toolbox via JDirect2. We used a pretty         standard solution of using "critical sections" in the code         wherever the Toolbox is used, with only one thread able to         enter such a critical section at a time.</P>                  <P>In Java terms, this is implemented by having a single         global object (accessed via a public static variable) serve         as a synchronization lock, and putting all critical sections         into Java blocks synchronized to that object. This object is         known as:</P>                  <CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>com.apple.mrj.macos.toolbox.Toolbox.LOCK</pre></TD></TR></TABLE></CENTER>                  <P>(In other words, it's a static final variable called         <code>LOCK</code> in the class <code>Toolbox</code> in the package         <code>com.apple.mrj.macos.toolbox</code>.) Usage of this,         presuming the appropriate import directive, looks like:</P>                  <CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre><CODE>synchronized( Toolbox.LOCK ) {     ...     }</CODE></pre></TD></TR></TABLE></CENTER>                  <P>We on the MRJ team call this "LOCKing" or "using the         LOCK", capitalized as shown. (When saying it, you emphasize         the first syllable to indicate that it's capitalized...)</P>                  <H3>Why You Should Care</H3>                  <P>We implemented this so that our own AWT would work         correctly. But if other developers are going to write code         that uses JDirect -- and many of you are -- and if that code         is going to run in apps that also use AWT, then we need to         use the same synchronization technique so that your code         doesn't step on our code and vice versa. Thus, this         technote.</P>                  <H3>Example</H3>                  <P>Here's a simple example showing a fully synchronized         <CODE>SysBeep</CODE> call:</P>                           <CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>import com.apple.mrj.macos.toolbox.Toolbox;import SoundFunctions;    // From JDirect Sample Code from SDK...public void playABeep( ) {    synchronized(Toolbox.LOCK) {        SoundFunctions.SysBeep(1);    }}</pre></TD></TR></TABLE></CENTER>                  <H3>Native-code (JNI) </H3>                  <P>This isn't an issue specific to JDirect. If you write         native methods (probably using JNI) that call the Toolbox,         the same issues can arise. If your native code alters         Toolbox state like the current port or the state inside a         <CODE>GrafPort</CODE>, you should synchronize it against the LOCK. The         easiest way to do this is to leave the native code alone and         ensure that you LOCK every call to the native method.         However, you can also use the JNI API to locate the LOCK         object and acquire/release its monitor. Just make absolutely         sure that your native method cannot exit without releasing         the monitor, or you will cause MRJ to hang!</P>   <P><A HREF = "#top">Back to top</A></P>         <H2><A NAME=Section2></A>Paranoia and         Reality</H2>                  <P>The previous section is actually a bit alarmist ... for         now. The truth is that it is <I>currently</I> not necessary         to LOCK around every single Toolbox call -- in fact,         individual calls that don't require or change system state         -- like the <CODE>SysBeep</CODE> above -- don't currently need any         synchronization. This is because MRJ 2.1 threads aren't         really pre-emptive -- they just pretend to be, by         time-slicing Java code. They will not preempt while running         native code, including the Toolbox. Any individual Toolbox         call will run as long as it wants without any other Java         threads getting time, so there's no danger of another thread         re-entrantly calling the Toolbox.</P>                  <P><B>Note carefully</B> that I said <I>currently</I>. The         current state of the art is due to the current limitations         of how you can implement threads on the Mac OS, which has a         lot to do with the nanokernel at the heart of the system.         Future releases of Mac OS 8 ("Blue") will have improvements         to the nanokernel that might at some future time allow us to         support true pre-emption. Moreover, Mac OS X will be based on the         Mach 3 microkernel which supports true pre-emptive threads,         which Java will use.</P>                  <P>This will requires changes to any native method         implementations as well (which is not surprising, since all         MacOS code will need to be revised to run with the Carbon         APIs in OS X.) In OS X it will become possible for a native         method to be preempted by another thread, which makes         synchronization a lot more important. You'll need to start         acquiring/releasing the LOCK within your native methods just         as you would in the equivalent Java code. We'll be providing         more details of what kind of synchronization is necessary,         as Mac OS X becomes more of a reality.</P>                  <P>Therefore, if you want your JDirect- or JNI-based Toolbox         calls to continue to function in future releases of the Mac         OS with future Java implementations, you should start         LOCKing all your Toolbox calls right away. If you don't have         time to do it religiously for everything, you at least need         to LOCK groups of Toolbox calls that need an undisturbed         global environment.</P>    <P><A HREF = "#top">Back to top</A></P>         <H2><A NAME=Section3></A>The Perils of         LOCKing</H2>                  <P>Unfortunately, all this synchronization comes with         dangers of its own, as anyone who's done much multithreaded         programming can tell you. The principal one is the classic         problem of <I>deadlock</I>.</P>                  <H3>A short tutorial on deadlock</H3>                  <P>Deadlock results when a thread holding a monitor (it's         inside a <code>synchronized</code> block, in Java parlance)         tries to acquire another monitor which is being held by         another thread, which is already blocked trying to acquire         the monitor the first thread is holding. Or, in human terms,         "I won't give you the can until you give me the         can-opener, but you won't give me the can-opener until I give         you the can." We both starve; in Java both threads will be         blocked forever.</P>                  <P>The LOCK object is nothing special in this regard, but         the fact that you're going to be synchronizing against it a         lot means you have to watch out for deadlocks. Here's a         typical scenario that causes a deadlock:</P>                  <CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>public synchronized void foo( ) {    System.out.println("In foo!");    synchronized(Toolbox.LOCK) {        SoundFunctions.SysBeep(1);    }}public void bar( ) {    synchronized(Toolbox.LOCK) {        SoundFunctions.SysBeep(1);        foo();    }}</pre></TD></TR></TABLE></CENTER>                              <P>This may look innocuous, but consider a thread that calls         foo, gets as far as the <CODE>println</CODE>, then is preempted. Control         switches to a second thread that calls the bar method on the         same object. The second thread proceeds through the bar         method, calls foo, and is now blocked because the first         thread is already holding the monitor for that object         (because foo is synchronized).</P>                  <P>Later, the first thread wakes up and tries to enter the         foo method's <code>synchronized</code> statement. Unfortunately         the second thread is already holding the LOCK, so the first         thread also blocks.</P>                  <P>Now both threads are blocked, and neither can proceed         until the other one releases a monitor. Permanent         deadlock.</P>                  <H3>How to avoid this</H3>                  <P>One of the textbook solutions for avoiding deadlock is to         always acquire monitors in the same order. The reason for         the deadlock in the above example is that the first thread         acquired first the receiving object's lock and then the         Toolbox LOCK, while the second thread acquired them in the         opposite order.</P>                  <P>The ordering we've used in our own code is that <I>the         LOCK is always the last monitor acquired.</I> In Java terms,         this means that, while synchronized to the LOCK, you should         never synchronize on anything else or call any method that         synchronizes on anything else. (In the example, the bar         method violates this rule when it calls foo. The best fix is         probably to move the foo call out of the synchronized         block.)</P>                  <P>A specific and very important corollary of this is that         you should not call into the AWT while holding the LOCK,         since the public AWT methods do a lot of synchronization, as         do our private peer classes that they call.</P>                  <P>If you feel very smart, you can make certain exceptions         to this rule -- you can call synchronized methods from with         a LOCKed block as long as you're certain that you never LOCK         while synchronized against that object. For instance, you         may feel safe calling methods on a Vector object within a         LOCKed block, even though most Vector methods are         synchronized, because it's pretty unlikely that you have         other code that synchronizes against that Vector.</P>                  <P>This leads to a programming style in which you wrap         LOCKed blocks pretty tightly around your Toolbox calls. If         you have a method that needs to call the Toolbox, do some         other Java stuff, then call the Toolbox again, don't LOCK         the entire method. Instead, LOCK the first and second group         of Toolbox calls, leaving the stuff in the middle out. Of         course, this implies that global state might have changed         between the first and second group of calls. If this is         unacceptable, you'll need to have the second group set the         state up again, or figure out how to re-order the code so         the two groups can be merged into one with the rest of the         Java calls coming before or after.</P>                  <H3>Debugging deadlocks</H3>                  <P>We had so much fun with deadlocks while developing MRJ         that we added some support to the MRJ VM to help us debug         them.</P>                  <P>First, the debug build of MRJLib includes a deadlock         sniffer in its thread scheduler. This will detect the         classic deadlock case described above, and will immediately         drop into MacsBug with a user-break telling you that a         deadlock was detected. You can then use the techniques below         to get more info. (The debug build is supplied with the MRJ         2.1 SDK. See its accompanying Read-Me file for installation         instructions and more info.)</P>                  <P>Even with the regular optimized build of MRJLib, if you         have the MRJ <CODE>'dcmd'</CODE> installed you can break into MacsBug and         then use the <code>'mrj dl'</code> and <code>'mrj sync'</code>         commands to see if there are currently any deadlocks or         deadlock-like synchronization problems. These commands will         print information about the threads and objects involved.         (The <CODE>'dcmd'</CODE> is supplied with the MRJ 2.1 SDK; for more         information about it and these specific commands, see its         accompanying Read-Me file and the <I>Debugging Java Code         With MacsBug</I> technote.)</P>     <P><A HREF = "#top">Back to top</A></P><a name="References"></a><H2>References</H2>            <p><A HREF = "tn1154.html">Technote 1154: <I>Debugging Java Code With MacsBug</I></A></p>            <p><I>Using JDirect To Access MacOS Code From Java.</I> A quick introduction to JDirect. In the "docs" folder of the MRJ 2.1 SDK.</p>                         <p>Oaks, Scott and Wong, Henry. <A HREF = "http://www.oreilly.com/catalog/jthreads2/"><I>Java            Threads</I></A>. O'Reilly, 1997.<br>                        Another typically excellent O'Reilly book, serving as            a strong introduction to multithreading and threads in            Java. Very readable for beginners but has some good            advice for more advanced users, too.</p>                        <p>Lea, Doug. <I>Concurrent Programming in Java: Design            Principles and Patterns</I>. Addison-Wesley, 1997.               This is a very good, solid book that's nonetheless            somewhat academic and may be overkill for many people.            I've never managed to read all the way through it!</p>        <BR><p><A HREF = "#top">Back to top</a></p><A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Acrobat version of this Note (56K).</P></TD><td width=60 align=left>   <p><A HREF="pdf/tn1153.pdf">Download</A></P></TD>  </TR> </table></center><BR><p><a href="#top">Back to top</a></p></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1153.html%3Fid%3DDTS10002992-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1153.html%3Fid%3DDTS10002992-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1153.html%3Fid%3DDTS10002992-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>