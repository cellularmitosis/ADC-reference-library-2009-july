<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Imageer - /source/windows.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Imageer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Imageer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/windows.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/source/doevent.c</option>
<option value="listing2.html">/source/eventloop.c</option>
<option value="listing3.html">/source/fileCache.c</option>
<option value="listing4.html">/source/fileIO.c</option>
<option value="listing5.html">/source/gxGraphics.c</option>
<option value="listing6.html">/source/Imageer.app.h</option>
<option value="listing7.html">/source/Imageer.protos.h</option>
<option value="listing8.html">/source/Imageer.r</option>
<option value="listing9.html">/source/imageFilter.c</option>
<option value="listing10.html">/source/menu.c</option>
<option value="listing11.html">/source/offscrnGraphics.c</option>
<option value="listing12.html">/source/PreCompiledHeaders.c</option>
<option value="listing13.html">/source/start.c</option>
<option value="listing14.html">/source/windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Imageer.zip">Download Sample</a></strong> (&#147;Imageer.zip&#148;, 161.4K)<BR>
<strong><a href="Imageer.dmg">Download Sample</a></strong> (&#147;Imageer.dmg&#148;, 243.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************//*                          *//*  File:    windows.c              *//*                          *//*  Program:  Imageer                *//*                          *//*  By:      Jason Hodges-Harris          *//*                          *//*  Created:  26/10/95  00:00:00 AM        *//*                          *//*  Version:  1.0.0d3                *//*                          *//*  Copyright:  &copy; 1995-96 Apple Computer, Inc.,    */ /*          all rights reserved.      */    /*                          *//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __CONTROLS__#include &lt;Controls.h&gt;#endif#ifndef __DEVICES__#include &lt;Devices.h&gt;#endif#ifndef __DIALOGS__#include &lt;Dialogs.h&gt;#endif#ifndef __GXENVIRONMENT__#include &lt;GXEnvironment.h&gt;#endif#ifndef __GXGRAPHICS__#include &lt;GXGraphics.h&gt;#endif#ifndef __LOWMEM__#include&lt;LowMem.h&gt;#endif#ifndef __PALETTES__#include &lt;Palettes.h&gt;#endif#ifndef __QDOFFSCREEN__#include &lt;QDOffscreen.h&gt;#endif#ifndef __TEXTUTILS__#include &lt;TextUtils.h&gt;#endif#ifndef __TOOLUTILS__#include &lt;ToolUtils.h&gt;#endif#ifndef __WINDOWS__#include &lt;Windows.h&gt;#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include &quot;Imageer.app.h&quot;#endif#ifndef __IMAGEERPROTOSHEADER__#include &quot;Imageer.protos.h&quot;#endif/***** Global Variables *****/extern short      gNumOpenWindows;    //  number of open document windows /* The DisplayAlert() function is a generic modal dialog display function    which uses GetStdFilterProc() and SetDialogDefaultItem() to    automatically get the standard filter and outline the default DITL item.    These 'undocumented' functions are available in system 7.0 or later. */ #pragma segment windowslong  DisplayAlert(short dialogID,short errStrID,short StrIDindex){  GrafPtr      savePort = nil;  DialogPtr    myDialog = nil;  ModalFilterUPP  theFilter = nil;  Str255      theTextStr;  short      alertResponse;    myDialog = GetNewDialog(dialogID,nil,((WindowPtr)-1L));  // get dialog resource  GetPort(&amp;savePort);  SetPort  (myDialog);  if (GetStdFilterProc(&amp;theFilter) !=noErr)    DebugStr(&quot;\pFailed to get standard dialog filter.&quot;);  SetDialogDefaultItem(myDialog,1);  /* If the errStrID variable contains 0, the dialog doesn't     require any text from a STR# resource */  if (errStrID!=0)    // get STR# resource text  {    GetIndString(theTextStr,errStrID,StrIDindex);    ParamText(theTextStr,(ConstStr255Param)kNull_Str,          (ConstStr255Param)kNull_Str,(ConstStr255Param)kNull_Str);  }  do{    ModalDialog(theFilter,&amp;alertResponse);  } while (alertResponse==0);  DisposeDialog(myDialog);//  dispose dialog mem allocation  SetPort(savePort);      return alertResponse;  // return dialog return value}// Drag the window from the position passed in the mouseLoc parameter #pragma segment windowsvoid DragSelWind(WindowPtr window,Point mouseLoc){  Rect  dragBounds;    dragBounds=(**GetGrayRgn()).rgnBBox;  DragWindow(window,mouseLoc,&amp;dragBounds);}// Close the active window which had it's close box selected#pragma segment windowsvoid DoGoAwayWind(WindowPtr window,Point mouseLoc){  if(TrackGoAway(window,mouseLoc))  {    if (window!=nil)    {      // Test for a dialog window and hide if selected      if ((((WindowPeek)window)-&gt;windowKind)==2)         HideWindow(window);      // Test for a Desk Accessory window and Close.      else if ((((WindowPeek)window)-&gt;windowKind)&lt;0)         CloseDeskAcc(((WindowPeek)window)-&gt;windowKind);      // Test for an application window.      else if ((((WindowPeek)window)-&gt;windowKind)==8)        {        // Handle application windows        DisposeImageWindow (window);      }    }  }}/**** create new image window  ****/// Create a new window complete with scroll bar controls// position staggered at max possible size and resize to// be completely visible on the main screen.#pragma segment windowsOSErr  CreateImageWindow (ImageDocHndl theWindDocHndl){  ImageDocHndl  theWindowRefcon = nil;  PaletteHandle  theWPalette = nil;  CWindowPtr    theCWindow;  Point      theWindowOffset;  short      maxXsize,          maxYsize;  OSErr      error = noErr;            theCWindow = (CWindowPtr)GetNewCWindow(rGenWindow,nil,(WindowPtr)-1L);  SetWRefCon((WindowPtr)theCWindow,(long)theWindDocHndl);  // set window refcon to doc handle  SetWTitle((WindowPtr)theCWindow,(**theWindDocHndl).theImageFileReply.sfFile.name);  CalcMaxImageWindowSize(theWindDocHndl);  theWindowOffset  = CalcNextWindowPosition(theWindDocHndl);  SizeWindow((WindowPtr)theCWindow,    (**theWindDocHndl).theMaxWindowSize.right - (**theWindDocHndl).theMaxWindowSize.left,    (**theWindDocHndl).theMaxWindowSize.bottom - (**theWindDocHndl).theMaxWindowSize.top,false);  MoveWindow((WindowPtr)theCWindow,theWindowOffset.h,theWindowOffset.v,false);  (**theWindDocHndl).theVScrollBar = GetNewControl (rVScrollBar,(WindowPtr)theCWindow);  (**theWindDocHndl).theHScrollBar = GetNewControl (rHScrollBar,(WindowPtr)theCWindow);  (**theWindDocHndl).theColorsPalette = nil;  // not used by image window  (**theWindDocHndl).isColorsWindow = false;  if ((**theWindDocHndl).theVScrollBar == nil || (**theWindDocHndl).theHScrollBar == nil)  {    DisposeWindow((WindowPtr)theCWindow);    return kDefaultAppError;  }  MoveControl((**theWindDocHndl).theVScrollBar,        theCWindow-&gt;portRect.right - kScrollBarWidth,theCWindow-&gt;portRect.top - 1);  MoveControl((**theWindDocHndl).theHScrollBar,        theCWindow-&gt;portRect.left - 1,theCWindow-&gt;portRect.bottom - kScrollBarWidth);  SizeControl((**theWindDocHndl).theVScrollBar,16,        (theCWindow-&gt;portRect.bottom - theCWindow-&gt;portRect.top)-13);  SizeControl((**theWindDocHndl).theHScrollBar,        (theCWindow-&gt;portRect.right - theCWindow-&gt;portRect.left)-13,16);  theWPalette =     NewPalette(256,(**(*(**theWindDocHndl).theImageWorld).portPixMap).pmTable,pmTolerant+pmExplicit,0);  NSetPalette((WindowPtr)theCWindow,theWPalette,pmAllUpdates);  ShowControl((**theWindDocHndl).theVScrollBar);  ShowControl((**theWindDocHndl).theHScrollBar);  SetControlMinimum((**theWindDocHndl).theVScrollBar,0);  SetControlMinimum((**theWindDocHndl).theHScrollBar,0);  maxXsize = (*theWindDocHndl)-&gt;theImageWorld-&gt;portRect.right -         ((theCWindow-&gt;portRect.right - kScrollBarWidth) - theCWindow-&gt;portRect.left);  maxYsize = (*theWindDocHndl)-&gt;theImageWorld-&gt;portRect.bottom -         ((theCWindow-&gt;portRect.bottom - kScrollBarWidth) - theCWindow-&gt;portRect.top);  SetControlMaximum((**theWindDocHndl).theVScrollBar,maxYsize);  SetControlMaximum((**theWindDocHndl).theHScrollBar,maxXsize);  SetControlValue((**theWindDocHndl).theVScrollBar,0);  SetControlValue((**theWindDocHndl).theHScrollBar,0);  ShowWindow((WindowPtr)theCWindow);  DrawGrowIcon((WindowPtr)theCWindow);  return error;}// Close an application window#pragma segment windowsvoid DisposeImageWindow (WindowPtr window){  ImageDocHndl    theDocRefCon;  MenuHandle      theMenu;  WindowPtr      theWindow;  Str255        theString;  short        count;    // check if the window to close is a valid Document window  if ((theDocRefCon=(ImageDocHndl)GetWRefCon(window)) != 0)  {    // dispose of the window document structure    if (!(**theDocRefCon).isColorsWindow)      DeleteDocNameFromMenu (theDocRefCon);    else    {      GetIndString (theString,rMenuItems,iShowColors);      SetMenuItemText (GetMHandle(mWindow),iColors,theString);      if ((**theDocRefCon).theColorsPalette)    // Direct color images have no palette        DisposePalette((**theDocRefCon).theColorsPalette);    }    if ((**theDocRefCon).theVScrollBar)    {      DisposeControl((**theDocRefCon).theVScrollBar);      DisposeControl((**theDocRefCon).theHScrollBar);    }    /****  Dispose QuickDraw specific document items  ****/    if (!(**theDocRefCon).isUsingQDGX)    {      if ((**theDocRefCon).theImageWorld)        DisposeGWorld((**theDocRefCon).theImageWorld);      if ((**theDocRefCon).hasUndoTemp)        RemoveTempFile(theDocRefCon, true, false);      if ((**theDocRefCon).hasRedoTemp)        RemoveTempFile(theDocRefCon, false, true);    }          /****  Dispose of GX related objects  ****/    if ((**theDocRefCon).isUsingQDGX)    {      GXDisposeShape((**theDocRefCon).theGXImageShape);      GXDisposeInk((**theDocRefCon).theInkShape);      GXDisposeViewPort((**theDocRefCon).theGxChildView);      GXDisposeViewPort((**theDocRefCon).theGXview);    }    DisposeHandle((Handle)theDocRefCon);    DisposeWindow(window);    theWindow = FrontWindow();    if (theWindow == nil || gNumOpenWindows == 0)    {      if (ColorWindowVisible())        DisposeColorsWindow();      theMenu = GetMHandle(mFile);      DisableItem(theMenu,iClose);      DisableItem(theMenu,iCloseAll);      DisableItem(theMenu,iSaveAs);      DisableItem(theMenu,iRevert);      DisableItem(GetMHandle(mWindow),iColors);      theMenu = GetMHandle(mFilters);      for (count = iSmoothFilter;count &lt;= iHiPassFilter; ++count)        DisableItem(theMenu,count);      theMenu = GetMHandle(mEffects);      for (count = iInvert;count &lt;= iRotate180; ++count)        DisableItem(theMenu,count);      /****  Reset undo menu item text  ****/      SetUndoItemText(kCannotUndo);      ForceRestoreColors();    }    else    {      theDocRefCon=(ImageDocHndl)GetWRefCon(theWindow);      switch ((*theDocRefCon)-&gt;theUndoState)      {        case kCannotUndo:          SetUndoItemText(kCannotUndo);        break;        case kCanUndo:          SetUndoItemText(kCanUndo);        break;        case kCanRedo:          SetUndoItemText(kCanRedo);        break;      }    }  }}/*****  Perform update operation for image and colors windows for both imaging models  ****/#pragma segment windowsvoid  DoWindowUpdate(WindowPtr theWindow){  PixMapHandle    thePixMapHndl = nil;  ImageDocHndl    theWindDocHndl;  WindowPtr      oldPort;    GetPort(&amp;oldPort);  SetPort(theWindow);  BeginUpdate(theWindow);  theWindDocHndl = (ImageDocHndl)GetWRefCon(theWindow);  if (theWindDocHndl &amp;&amp; (**theWindDocHndl).isColorsWindow == false &amp;&amp;               (**theWindDocHndl).isUsingQDGX == false)  {    TransferImageToWindow(theWindDocHndl,theWindow);  // Color QD content region update    UpdateControls(theWindow,theWindow-&gt;visRgn);    DrawGrowIcon(theWindow);  }  else if (theWindDocHndl &amp;&amp;       (**theWindDocHndl).isColorsWindow == false &amp;&amp;       (**theWindDocHndl).isUsingQDGX)  {    UpdateGXObjectDisplay(theWindDocHndl, theWindow);    UpdateControls(theWindow,theWindow-&gt;visRgn);    DrawGrowIcon(theWindow);  }  else if ((**theWindDocHndl).isColorsWindow &amp;&amp;        (**theWindDocHndl).isUsingQDGX == false)    DrawImageColors(theWindow);  EndUpdate(theWindow);  SetPort (oldPort);}/****  Create new Image Colors Window  ****/#pragma segment windowsOSErr  CreateColorsWindow(void){  ImageDocHndl    theColorsDocHndl = nil,            theFoundDocHndl = nil;  CWindowPtr      theWindow;  WindowPtr      theFrontWindow;  Str255        theString;  OSErr        error = noErr;            theWindow = (CGrafPort*)GetNewCWindow(rColorsWindow,nil,(WindowPtr)-1L);  theColorsDocHndl = (ImageDocHndl)NewHandle(sizeof(ImageDoc));  // alloc new image document  if (theColorsDocHndl)  {    SetWRefCon((WindowPtr)theWindow,(long)theColorsDocHndl);  // set refcon to doc handle    (**theColorsDocHndl).theImageWorld = nil;    (**theColorsDocHndl).theVScrollBar = nil;    (**theColorsDocHndl).theHScrollBar = nil;    (**theColorsDocHndl).isColorsWindow = true;    (**theColorsDocHndl).theColorsPalette = nil;    // initialise to nil as direct images have no palette info    (**theColorsDocHndl).isUsingQDGX = false;    (**theColorsDocHndl).theUndoState = kCannotUndo;    (**theColorsDocHndl).hasUndoTemp = false;    (**theColorsDocHndl).hasRedoTemp = false;    theFrontWindow = FrontWindow();    theFoundDocHndl = (ImageDocHndl)GetWRefCon(theFrontWindow);    (**theColorsDocHndl).theImageDepth = (**theFoundDocHndl).theImageDepth;    SetWTitle((WindowPtr)theWindow,&quot;\pImage Colors&quot;);    SizeWindow((WindowPtr)theWindow,128+32,32+32,false);    ShowWindow((WindowPtr)theWindow);    if ((**theFoundDocHndl).theImageDepth &lt;= 8)  // create palette for indexed images    {      if (!(**theFoundDocHndl).isUsingQDGX)        (**theColorsDocHndl).theColorsPalette =           NewPalette(256,                 (**(*(**theFoundDocHndl).theImageWorld).portPixMap).pmTable,                 pmTolerant+pmExplicit,0);      else        (**theColorsDocHndl).theColorsPalette =           NewPalette((**theFoundDocHndl).theImageDepth,                 nil,pmTolerant+pmExplicit,0);      if ((**theColorsDocHndl).theColorsPalette)         NSetPalette((WindowPtr)theWindow,(**theColorsDocHndl).theColorsPalette,pmAllUpdates);      else        return kFailMakePalette;    }    GetIndString (theString,rMenuItems,iHideColors);    SetMenuItemText (GetMHandle(mWindow),iColors,theString);    SetUndoItemText((*theColorsDocHndl)-&gt;theUndoState);  }  else    error = kDefaultAppError;  return error;}/****  Dispose of Current image Colors window  ****/#pragma segment windowsOSErr  DisposeColorsWindow(void){  ImageDocHndl  theDocHndl = nil;  WindowPtr    theWindow,          theNextWindow;  OSErr      error = noErr;    theWindow = FrontWindow();  while (theWindow)  {    theDocHndl = (ImageDocHndl)GetWRefCon(theWindow);    if ((**theDocHndl).isColorsWindow)    {      DisposeImageWindow (theWindow);      return error;    }    theNextWindow = &amp;((WindowPeek)theWindow)-&gt;nextWindow-&gt;port;    theWindow = theNextWindow;  }  return kDefaultAppError;}/****  determine maximum window size  ****/#pragma segment windowsOSErr  CalcMaxImageWindowSize(ImageDocHndl theWindDocHndl){  GDHandle    theMainGDevHndl;  Rect      maxWindowSize,          theImageSize;  short      theMenuHeight;  OSErr      error = noErr;    SetRect(&amp;theImageSize,0,0,(**theWindDocHndl).theImageXSize+kScrollBarWidth,                (**theWindDocHndl).theImageYSize+kScrollBarWidth);  theMainGDevHndl = GetMainDevice();  maxWindowSize = (**theMainGDevHndl).gdRect;  theMenuHeight = GetMBarHeight();  maxWindowSize.bottom -=theMenuHeight+20;  maxWindowSize.right -= 20;  if (((**theWindDocHndl).theImageXSize+kScrollBarWidth) &lt; (maxWindowSize.right - maxWindowSize.left) &amp;&amp;    ((**theWindDocHndl).theImageYSize+kScrollBarWidth) &lt; (maxWindowSize.bottom - maxWindowSize.top))  {    (**theWindDocHndl).theMaxWindowSize = theImageSize;      }  else  {    /**** Set max window size depth and width to not larger than main screen or image  ****/    (**theWindDocHndl).theMaxWindowSize = maxWindowSize;    if (((**theWindDocHndl).theImageXSize+kScrollBarWidth) &lt; (maxWindowSize.right - maxWindowSize.left))    {      (**theWindDocHndl).theMaxWindowSize.left = theImageSize.left;      (**theWindDocHndl).theMaxWindowSize.right = theImageSize.right;    }    if (((**theWindDocHndl).theImageYSize+kScrollBarWidth) &lt; (maxWindowSize.bottom - maxWindowSize.top))    {      (**theWindDocHndl).theMaxWindowSize.top = theImageSize.top;      (**theWindDocHndl).theMaxWindowSize.bottom = theImageSize.bottom;    }  }  return error;}/****  position next open image window  staggered on main window to front most image window ****/#pragma segment windowsPoint  CalcNextWindowPosition(ImageDocHndl theDocHndl){  ImageDocHndl   theWindDocHndl;  WindowPtr    theWindow,          theNextWindow,          oldPort;  Point      theWindowOffset;  short      theMenuHeight;    GetPort(&amp;oldPort);  theMenuHeight = GetMBarHeight();  theWindow = FrontWindow();  if (!theWindow)  {    theWindowOffset.h = 0;    theWindowOffset.v = theMenuHeight+18;    return theWindowOffset;  }  theWindDocHndl = (ImageDocHndl)GetWRefCon(theWindow);  if (!(**theWindDocHndl).isColorsWindow)  {    SetPort(theWindow);    theWindowOffset.h = theWindow-&gt;portRect.left;    theWindowOffset.v = theWindow-&gt;portRect.top;    LocalToGlobal(&amp;theWindowOffset);  }  else  {        do {      theNextWindow = &amp;((WindowPeek)theWindow)-&gt;nextWindow-&gt;port;      theWindow = theNextWindow;      theWindDocHndl = (ImageDocHndl)GetWRefCon(theWindow);    } while (theWindow &amp;&amp; (**theWindDocHndl).isColorsWindow);    if (theWindow)    {      SetPort(theWindow);      theWindowOffset.h = theWindow-&gt;portRect.left;      theWindowOffset.v = theWindow-&gt;portRect.top;      LocalToGlobal(&amp;theWindowOffset);    }    else    {      theWindowOffset.h = 0;      theWindowOffset.v = 0;    }  }  theWindowOffset.h +=18;  theWindowOffset.v +=18;  TestWindowFitMainScrn(theDocHndl, &amp;theWindowOffset);  SetPort(oldPort);  return theWindowOffset;}/****  Test for window fit main screen  ****/#pragma segment windowsvoid  TestWindowFitMainScrn(ImageDocHndl theDocHndl, Point *windowOffset){  GDHandle    theMainGDevHndl;  Rect      mainScrnSize,          *maxWindowSize;  Point      theWindowOffset;  short      theMenuHeight;  theMainGDevHndl = GetMainDevice();  mainScrnSize = (**theMainGDevHndl).gdRect;  theMenuHeight = GetMBarHeight();  mainScrnSize.bottom -=theMenuHeight+20;  maxWindowSize = &amp;(*theDocHndl)-&gt;theMaxWindowSize;  if ((maxWindowSize-&gt;right+windowOffset-&gt;h) &gt; mainScrnSize.right)  {    windowOffset-&gt;h = 0;    if ((maxWindowSize-&gt;right+windowOffset-&gt;h) &gt; mainScrnSize.right)      maxWindowSize-&gt;right = mainScrnSize.right - 20;  }  if ((maxWindowSize-&gt;bottom+windowOffset-&gt;v) &gt; mainScrnSize.bottom)  {    windowOffset-&gt;v = theMenuHeight+18;    if ((maxWindowSize-&gt;bottom+windowOffset-&gt;v) &gt; mainScrnSize.bottom)      maxWindowSize-&gt;bottom = mainScrnSize.bottom;  } }/****  Resize window  ****/#pragma segment windowsvoid  HandleWindowReSize(WindowPtr theWindow,Point startPoint){  ImageDocHndl    theWindDocHndl;  WindowPtr      oldPort;  long        returnCoord;  Rect        resizeBounds;  short        windWidth,            windHeight,            maxXsize,            maxYsize;    GetPort(&amp;oldPort);  theWindDocHndl = (ImageDocHndl)GetWRefCon((WindowPtr)theWindow);  SetRect(&amp;resizeBounds,96,96,      (1+(**theWindDocHndl).theMaxWindowSize.right - (**theWindDocHndl).theMaxWindowSize.left),      (1+(**theWindDocHndl).theMaxWindowSize.bottom - (**theWindDocHndl).theMaxWindowSize.top));  returnCoord = GrowWindow(theWindow, startPoint, &amp;resizeBounds);  windHeight   = HiWord(returnCoord);  windWidth = LoWord(returnCoord);  SizeWindow(theWindow, windWidth, windHeight, true);  MoveControl((**theWindDocHndl).theVScrollBar,        theWindow-&gt;portRect.right - kScrollBarWidth,theWindow-&gt;portRect.top - 1);  MoveControl((**theWindDocHndl).theHScrollBar,        theWindow-&gt;portRect.left - 1,theWindow-&gt;portRect.bottom-kScrollBarWidth);  SizeControl((**theWindDocHndl).theVScrollBar,16,        (theWindow-&gt;portRect.bottom - theWindow-&gt;portRect.top)-13);  SizeControl((**theWindDocHndl).theHScrollBar,        (theWindow-&gt;portRect.right - theWindow-&gt;portRect.left)-13,16);  maxXsize = (*theWindDocHndl)-&gt;theImageWorld-&gt;portRect.right -         ((theWindow-&gt;portRect.right - kScrollBarWidth) - theWindow-&gt;portRect.left);  maxYsize = (*theWindDocHndl)-&gt;theImageWorld-&gt;portRect.bottom -         ((theWindow-&gt;portRect.bottom - kScrollBarWidth) - theWindow-&gt;portRect.top);  SetControlMaximum((**theWindDocHndl).theVScrollBar,maxYsize);  SetControlMaximum((**theWindDocHndl).theHScrollBar,maxXsize);  SetPort(theWindow);  InvalRect(&amp;theWindow-&gt;portRect);  SetPort(oldPort);}/****  Display Progres Bar Dialog  *****/#pragma segment windowsvoid  DisplayProgressBarDlog(short updateState, short controlValue, short theStrGroup, short theStrID){  static ControlHandle  theControl;  static GrafPtr      oldPort;  static CWindowPtr    theProgressWindow;  Str255          theProgressStr;            GetPort(&amp;oldPort);  // Perform operations on dialog and progress control dependent on updateState parameter  switch (updateState)  {     case kDisplayProgressWindow:      DisableAllMenus(true);      theProgressWindow = (CWindowPtr) GetNewCWindow(rProgressBarWindow,nil,((WindowPtr)-1L));      SetPort  ((WindowPtr)theProgressWindow);      theControl=GetNewControl(rProgressCntl, (WindowPtr)theProgressWindow);      MoveControl(theControl,20,32);      ShowControl(theControl);      GetIndString (theProgressStr,theStrGroup,theStrID);      if (theStrGroup != 0)      {        MoveTo(20,64);        DrawString(theProgressStr);      }    break;    case kUpdateProgressWindow:      SetPort  ((WindowPtr)theProgressWindow);      SetControlValue(theControl,controlValue);    break;    case kDisposeProgressWindow:      DisposeControl(theControl);      DisposeWindow((WindowPtr)theProgressWindow);      DisableAllMenus(false);    break;  }  SetPort(oldPort);}/****  Display Startup splash screen  *****/#pragma segment windowsvoid SplashScreen(short theDelayLength){  WindowPtr    theWindow,          oldPort;  PicHandle    thePict = nil;  signed long    currentTime,          delayTime;    GetPort(&amp;oldPort);  thePict=GetPicture(rSplashPICT);  if (thePict==nil)    return;      theWindow=GetNewWindow(rSplashWindow,nil,(WindowPtr)-1L);  SetPort(theWindow);  HLock((Handle)thePict);  DrawPicture(thePict,&amp;theWindow-&gt;portRect);  HUnlock((Handle)thePict);  DisposeHandle((Handle)thePict);  currentTime=LMGetTicks();  delayTime = currentTime+theDelayLength;  do  {    currentTime = LMGetTicks();  }while (currentTime &lt; delayTime);  DisposeWindow((GrafPtr)theWindow);  SetPort(oldPort);}/****  Test for open colors window    ****/#pragma segment windowsBoolean  ColorWindowVisible(void){  Str255    theItemString,        theResString;  Boolean    isVisible = false;  GetMenuItemText(GetMHandle(mWindow),iColors,theItemString);    GetIndString (theResString,rMenuItems,iHideColors);  if (EqualString(theItemString,theResString,true,true))    isVisible = true;  return isVisible;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Imageer/listing14.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Imageer/listing14.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Imageer/listing14.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>