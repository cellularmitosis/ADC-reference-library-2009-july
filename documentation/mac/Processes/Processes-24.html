<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Getting Information About Other Processes (IM: Pr)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING24></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Processes-23.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Processes-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Processes-171.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Processes-25.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="Processes-2.html"><B>Processes</B></A><BR><DD><A HREF="Processes-21.html"><B>Chapter 2 - Process Manager</B></A> / <A HREF="Processes-23.html"><B>Using the Process Manager </B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING24-0></A>
<H2><A NAME=MARKER-9-24></A>Getting Information About Other Processes</H2>
 <A NAME=MARKER-2-32></A><A NAME=MARKER-2-85></A><A NAME=MARKER-2-24></A><A NAME=MARKER-2-97></A>You can call the <CODE>GetNextProcess</CODE>, <CODE>GetFrontProcess</CODE>, or <CODE>GetCurrentProcess</CODE> functions to get the process serial number of a process. The <CODE>GetCurrentProcess</CODE> function returns the process serial number of the process currently executing, called the <B>current process</B>. This is the process whose A5 world is currently valid; this process can be in the background or foreground. The <CODE>GetFrontProcess</CODE> function returns the process serial number of the foreground process. For example, if your process is running in the background, you can use <CODE>GetFrontProcess</CODE> to determine which process is in the foreground.<A NAME=MARKER-2-129></A><A NAME=MARKER-2-2></A><P>
 The Process Manager maintains a list of all open processes. You can specify the process serial number of a process currently in the list and call <CODE>GetNextProcess</CODE> to get the process serial number of the next process in the list. The interpretation of the value<BR>of a process serial number and of the order of the list of processes is internal to the Process Manager.<P>
 When specifying a particular process, use only a process serial number returned by a high-level event or a Process Manager routine, or constants defined by the Process Manager. You can use these constants to specify special processes:<A NAME=MARKER-2-131></A><A NAME=MARKER-2-135></A><A NAME=MARKER-2-34></A><P>
<PRE>
CONST 
   kNoProcess        = 0;        {process doesn't exist}
   kSystemProcess    = 1;        {process belongs to OS}
   kCurrentProcess   = 2;        {the current process}
</PRE>
 In all Process Manager routines, the constant <CODE>kNoProcess</CODE> refers to a process that doesn't exist, the constant <CODE>kSystemProcess</CODE> refers to a process belonging to the Operating System, and the constant <CODE>kCurrentProcess</CODE> refers to the current process. <P>
 To begin enumerating a list of processes, call the <CODE>GetNextProcess</CODE> function and specify the constant <CODE>kNoProcess</CODE> as the parameter. In response, <CODE>GetNextProcess</CODE> returns the process serial number of the first process in the list. You can use the returned process serial number to get the process serial number of the next process in the list. When the <CODE>GetNextProcess</CODE> function reaches the end of the list, it returns the constant <CODE>kNoProcess</CODE> and the result code <CODE>procNotFound</CODE>.<P>
 You can also use a process serial number to specify a target application when your application sends a high-level event. See the chapter "Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for information on how to use a process serial number when your application sends a high-level event.<P>
 You can call the <CODE>GetProcessInformation</CODE> function to obtain information about any process, including your own. For example, for a specified process, you can find<P>
<UL>
<LI>the application's name as it appears in the Application menu
<LI>the type and signature of the application
<LI>the number of bytes in the application partition
<LI>the number of free bytes in the application heap
<LI>the application that launched the application<P>
</UL>
 <A NAME=MARKER-2-48></A>The <CODE>GetProcessInformation</CODE> function returns information in a process information record, which is defined by the <CODE>ProcessInfoRec</CODE> data type<DFN>.</DFN><A NAME=MARKER-2-36></A><P>
<PRE>
TYPE ProcessInfoRec =
   RECORD
      processInfoLength:   LongInt;       {length of process info record}
      processName:         StringPtr;     {name of this process}
      processNumber:       ProcessSerialNumber;
                                          {psn of this process}
      processType:         LongInt;       {file type of application file}
      processSignature:    OSType;        {signature of application file}
      processMode:         LongInt;       {'SIZE' resource flags}
      processLocation:     Ptr;           {address of partition}
      processSize:         LongInt;       {partition size}
      processFreeMem:      LongInt;       {free bytes in heap}
      processLauncher:     ProcessSerialNumber;
                                          {process that launched this one}
      processLaunchDate:   LongInt;       {time when launched}
      processActiveTime:   LongInt;       {accumulated CPU time}
      processAppSpec:      FSSpecPtr;     {location of the file}
   END;
</PRE>
 You specify the values for three fields of the process information record: <CODE>processInfoLength</CODE>, <CODE>processName</CODE>, and <CODE>processAppSpec</CODE>. You must either set the <CODE>processName</CODE> and <CODE>processAppSpec</CODE> fields to <CODE>NIL</CODE> or set these fields to point to memory that you have allocated for them. The <CODE>GetProcessInformation</CODE> function returns information in all other fields of the process information record. See <A HREF=Processes-35.html#MARKER-9-135>"Process Information Record" on page 2-16</A> for a complete description of the fields of this record.<P>
 <A HREF=#MARKER-9-40>Listing 2-1</A> shows how you can use the <CODE>GetNextProcess</CODE> function with the <CODE>GetProcessInformation</CODE> function to search the process list for a specific process.<A NAME=MARKER-2-70></A><A NAME=MARKER-9-65></A><A NAME=MARKER-21-39></A><P>
<B>Listing 2-1  <A NAME=MARKER-9-40></A>Searching for a specific process</B><P>
<PRE>
FUNCTION FindAProcess (signature: OSType; 
                        VAR process: ProcessSerialNumber; 
                        VAR InfoRec: ProcessInfoRec;
                        myFSSpecPtr: FSSpecPtr;
                        myName: Str31): Boolean;
BEGIN
   FindAProcess := FALSE;              {assume FALSE}
   process.highLongOfPSN := 0;
   process.lowLongOfPSN := kNoProcess; {start at the beginning}

   InfoRec.processInfoLength := sizeof(ProcessInfoRec);
   InfoRec.processName := myName;
   InfoRec.processAppSpec := myFSSpecPtr;

   WHILE (GetNextProcess(process) = noErr) DO
   BEGIN
      IF GetProcessInformation(process, InfoRec) = noErr THEN
      BEGIN
         IF (InfoRec.processType = LongInt('APPL')) AND
            (InfoRec.processSignature = signature) THEN 
         BEGIN                         {found the process}
            FindAProcess := TRUE;
            Exit(FindAProcess);
         END;
      END;
   END; {WHILE}
END;
</PRE>
 The code in <A HREF=#MARKER-9-40>Listing 2-1</A> searches the process list for the application with the specified signature. For example, you might want to find a specific process so that you can send a high-level event to it.<A NAME=MARKER-2-41></A><A NAME=MARKER-9-73></A><P>
</BLOCKQUOTE><P>
<HR>
<center>
<A HREF="Processes-23.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Processes-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Processes-171.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Processes-25.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Processes-3.html">&copy; Apple Computer, Inc.</A><br>17 JUN 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
