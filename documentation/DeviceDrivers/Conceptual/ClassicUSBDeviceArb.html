<html><head><meta name=Title content="User Mode USB Device Arbitration"><meta name=Keywords content="USB"><meta http-equiv=Content-Type content="text/html; charset=macintosh"><X-SAS-WINDOW TOP=75 BOTTOM=633 LEFT=109 RIGHT=639><title>User-Mode USB Device Arbitration</title></head><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><body bgcolor=white lang=EN-US style='tab-interval:.5in;text-justify-trim:punctuation'><a name="//apple_ref/doc/uid/TP40001048"></a><br><!-- start of path --><font face="Geneva,Helvetica,Arial" size="1"><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Documentation</a> &gt; <!-- a href="" target="_top" -->Device Drivers<!-- /a --></font><br><!-- end of path --><h1>User-Mode USB Device Arbitration</h1><p><span style='font-family:Helvetica'>Last Updated:(6-Feb-2002) for MacOS X 10.2 and later.</span></p><br><h2>Introduction</h2><font face="Geneva,Helvetica,Arial" size="2"><p>This document describes a new feature in Mac OS X 10.1 called USB Device Arbitration. It is aimed at developers writing user-mode USB drivers and applications for those drivers (of which Classic is a notable example). The basic principles described herein also apply to kernel drivers although some of the details of the implementationdiffer (for example, use of the <code>::message()</code> method instead of General Interest Notification.)</p><br><h3>The Problem</h3><font face="Geneva,Helvetica,Arial" size="2"><p>The Mac OS 8.x/9.x USBstack was implemented with the expectation that it had exclusive access to theUSB bus and the devices connected to it. As a result, any application that wanted to communicate with any USBdevice would have to go through that API. This same code runs inside Classic on top of Mac OS X, but thatassumption is no longer true: the Mac OS X kernel now &quot;owns&quot; thehardware and non-Classic applications can communicate with USB devices withoutgoing through the Classic USB API.</p><p>One consequence of this is that Classic will acquire all USB devices for which it might  have a driver as soon as it sees them. It acquires them by calling </span><code>USBDeviceOpen()</code> and <code>USBInterfaceOpen()</code> which in turn prevents other user-mode applications from opening them. If some other application tries to open a device/interface that Classic hasopened, it will get a <code>kIOReturnExclusiveAccess</code> error and will not be allowed to communicatewith the device.</p><p>This causes problems for developers trying to develop Mac OS X versions of their drivers and applications.</p><p>What devices will be acquired by Classic? Any devicethat fits any of the following criteria (or has an interface that fits any ofthe following criteria):</p><table summary="Device interfaces aquired by Classic" border="1" padding="5" rules="rows"> <font face="Geneva,Helvetica,Arial" size="2">	<tr width="350" height="30">		<th>Attribute</th>		<th>Value</th>		<th>Comment</th>	<tr>		<td scope="row">deviceClass</td>		<td>255</td>		<td>vendor-specific</td>	</tr>	<tr>		<td scope="row">deviceClass<br>interfaceClass</td>		<td>0<br>16</td>		<td>composite device with an interface of class16</td>	</tr>	<tr>		<td scope="row">interfaceClass</td>		<td>255</td>		<td>vendor-specific</td>	</tr>	<tr>		<td scope="row">interfaceClass</td>		<td>7</td>		<td>printer</td>	</tr>	<tr>		<td scope="row">interfaceClass<br>interfaceSubclass</td>		<td>0<br>0</td>		<td>deprecated vendor-specific</td>	</tr></table></font></font><br><h3>Workarounds</h3><font face="Geneva,Helvetica,Arial" size="2"><p>The only reasonableworkarounds in Mac OS X 10.0.x are to not run Classic if you are attempting to accessone of these kinds of devices from a non-Classic application, or to launch yournon-Classic application before launching Classic. Shutting down Classic will also cause it to release its holdon these devices.</p></font><br><h2>USB Device Arbitration Mechanisms</h2><font face="Geneva,Helvetica,Arial" size="2"><p>There are twomechanisms for USB device arbitration that will be available starting in the10.1 release of Mac OS X.</p></font><br><h3>USB DeviceArbitration Mechanism #1: Static</h3><font face="Geneva,Helvetica,Arial" size="2"><p>The first mechanism ismore static and is intended for devices where you would like to prevent Classicfrom ever opening the device at all, or for forcing Classic to open it eventhough it might not do so otherwise. This mechanism works via a &quot;skeleton&quot; kext that contains nocode but has a personality to match each USB device you're interested in.</p><p>All it does is cause aBoolean property <code>ClassicMustNotSeize</code> or<code>ClassicMustSeize</code> to be set to <code>True</code> (<code>Yes</code>) onthe IOUSBDevice or IOUSBInterface node in the IORegistry inside the kernel. Classic looks for these properties wheniterating through the devices on the system.</p><p>You might be temptedto set the property programmatically, but you need to set it via a kext if youwant to be sure to avoid the race condition that will occur between Classic andyour code -- Classic might open the device before your code gets a chance toset the property. Another thing tokeep in mind is that the IORegistry is never stored persistently and thus anyproperties you add to a node will not exist after a reboot. An example of this technique isincluded in the Mac OS X USB DDK.</p><p>You can set theproperty on either the device or, starting with MacOS X 10.2, one of theinterfaces on the device that you are interested in. If you set the property on an interface, the entire devicewill be affected; there is no per-interface granularity; it is simply anotherway to communicate your intentions for the entire device.</p><p>Classic considersinterfaces as well as devices in order to make it easier to write your skeleton kext. If yourdevice is a Composite device (deviceClass == 0), Mac OS X IOUSBFamily'sComposite Driver will match against your device first and preventyour 'Seize property from being considered, unless you also set the<code>OSBundleRequired</code> property to &quot;Root&quot; so that your kextloads earlier (see the Inside Macintosh document &quot;Loading KernelExtensions at Boot Time&quot;). This is probably not a good use of the OSBundleRequired mechanism. If the property is set on an interface,your 'Seize property will be added to the registry even if it refers to aComposite device.</p><p>The following is anexample of the kind of <code>Info.plist</code> text file you might place in yourskeleton kext. You canedit it manually or use the Property List Editor application. The values for <code>idProduct</code>, <code>idVendor</code>, <code>bConfigurationValue</code> and <code>bInterfaceNumber</code> are used for matching against an interface; only<code>idProduct</code> and <code>idVendor</code> are used for matching against a device. You may wish to use theI/O Registry Explorer application, observing the IOService service plane withyour device connected, for help in determining these values.</p><p>To test yourskeleton kext, be sure to delete the cache file <code>/System/Library/Extensions.mkext</code> and then reboot. (Items within square brackets suggest possible values.)</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist SYSTEM &quot;file://localhost/System/Library/DTDs/PropertyList.dtd&quot;&gt;&lt;plist version=&quot;0.9&quot;&gt;&lt;dict&gt;&nbsp;&nbsp;&lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;&nbsp;&nbsp;&lt;string&gt;English&lt;/string&gt;&nbsp;&nbsp;&lt;key&gt;CFBundleIdentifier&lt;/key&gt;&nbsp;&nbsp;&lt;string&gt;com.apple.driver.test&lt;/string&gt;&nbsp;&nbsp;&lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;&nbsp;&nbsp;&lt;string&gt;6.0&lt;/string&gt;&nbsp;&nbsp;&lt;key&gt;CFBundlePackageType&lt;/key&gt;&nbsp;&nbsp;&lt;string&gt;KEXT&lt;/string&gt;&nbsp;&nbsp;&lt;key&gt;CFBundleSignature&lt;/key&gt;&nbsp;&nbsp;&lt;string&gt;????&lt;/string&gt;&nbsp;&nbsp;&lt;key&gt;CFBundleVersion&lt;/key&gt;&nbsp;&nbsp;&lt;string&gt;1.5.1&lt;/string&gt;&nbsp;&nbsp;&lt;key&gt;IOKitPersonalities&lt;/key&gt;&nbsp;&nbsp;&lt;dict&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;TestSeizeOrUnseizeAnInterface&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dict&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;CFBundleIdentifier&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;com.apple.driver.AppleUSBMergeNub&lt;/string&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;IOClass&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;AppleUSBMergeNub&lt;/string&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;IOProviderClass&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;IOUSBInterface&lt;/string&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;IOProviderMergeProperties&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dict&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;[ClassicMustNotSeize or ClassicMustSeize]&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;true/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dict&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;idProduct&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;integer&gt;[NumberInDecimal]&lt;/integer&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;idVendor&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;integer&gt;[NumberInDecimal]&lt;/integer&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;bConfigurationValue&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;integer&gt;[NumberInDecimal, often 1]&lt;/integer&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;bInterfaceNumber&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;integer&gt;[NumberInDecimal, often 0]&lt;/integer&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dict&gt;&nbsp;&nbsp;&lt;/dict&gt;&nbsp;&nbsp;&lt;key&gt;OSBundleLibraries&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dict&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;com.apple.driver.AppleUSBMergeNub&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;1.8.3b1&lt;/string&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&gt;com.apple.iokit.IOUSBFamily&lt;/key&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;1.8&lt;/string&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dict&gt;&nbsp;&nbsp;&lt;/dict&gt;&lt;/plist&gt;</pre></font><br><h3>USB Device Arbitration Mechanism #2: Dynamic</h3><font face="Geneva,Helvetica,Arial" size="2"><p>The second mechanismis more dynamic and is intended for devices where you would like Classic andnon-Classic applications to be able to take turns accessing thedevice. This mechanism is morecomplex than the first mechanism but is also more flexible.</p><p>A note about devicesand interfaces: everything in this section applies equally to devices andinterfaces. <code>Open()</code> stands for any of the <code>USBDeviceOpen()</code>, <code>USBInterfaceOpen()</code>, <code>USBDeviceOpenSeize()</code>, or <code>USBInterfaceOpenSeize()</code> functions. Similarly, <code>Close()</code> represents functions <code>USBDeviceClose()</code> or <code>USBInterfaceClose()</code>.</p><p>Registering forGeneral Interest Notifications is very similar to registering for ServiceMatching notifications, which you are already doing in order to find devices orinterfaces of interest. Here isthe prototype for the function you use to do this:</p><pre>#include &lt;IOKit/IOKitLib.h&gt;#include &lt;IOKit/IOKitKeys.h&gt;kern_return_tIOServiceAddInterestNotification(&nbsp;&nbsp;&nbsp;IONotificationPortRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifyPort,	&nbsp;&nbsp;&nbsp;io_service_t&nbsp;&nbsp;&nbsp;service,&nbsp;&nbsp;&nbsp;const io_name_t&nbsp;&nbsp;&nbsp;interestType,&nbsp;&nbsp;&nbsp;IOServiceInterestCallback &nbsp;&nbsp;&nbsp;	callback,&nbsp;&nbsp;&nbsp;void *&nbsp;&nbsp;&nbsp;refCon,&nbsp;&nbsp;&nbsp;io_object_t *	&nbsp;&nbsp;&nbsp;notification );</pre><p>The <code>notifyPort</code>is the same one you used to register for Service Matching notifications. The <code>service</code> is the <code>io_service_t</code> representing the IOUSBDevice orIOUSBInterface. We'll be using <code>interestType</code>= <code>kIOGeneralInterest</code>, which is defined in <code>IOKitKeys.h</code>. The <code>callback</code> is your callbackfunction whose prototype matches the one below. The <code>refCon</code> will be passed to your callback function eachtime it is invoked. (One use forthis, for example, might be a pointer to your record describing thedevice or interface.If you do this,be careful to validate the pointer somehow before using it!) The <code>notification</code> is an outputparameter that represents the notification. If you want to dispose of the notification (becauseyou no longer wish to receive these notifications) then invoke <code>IOObjectRelease()</code> on it.</p><pre>typedef void(*IOServiceInterestCallback)(&nbsp;&nbsp;&nbsp;void *	refcon,&nbsp;&nbsp;&nbsp;io_service_t	service,&nbsp;&nbsp;&nbsp;natural_t	messageType,&nbsp;&nbsp;&nbsp;void *	messageArgument );</pre><p>The <code>refcon</code>and the <code>service</code> are just the ones you supplied when youregistered for notifications. The <code>messageType</code>and <code>messageArgument</code> is one of the ones listed below, and describedin detail in what follows.</p><pre>#include&lt;IOKit/Message.h&gt;kIOMessageServiceIsAttemptingOpenkIOMessageServiceIsRequestingClose // (kernel only)kIOMessageServiceWasClosed</pre><br><p><b><code>USBDeviceOpen()/USBInterfaceOpen() -&gt; AttemptingOpen(0)</code></b></p><p>When someone(including your own code) calls <code>Open()</code>, your callback will be called with <code>messageType == kIOMessageServiceIsAttemptingOpen</code> and <code>messageArgument== 0</code>. Classic listens for this message in order to be a &quot;goodcitizen&quot; but other applications may want to release devices only if theextra argument is non-zero, in response to the more serious <code>USBDeviceOpenSeize()</code> or <code>USBInterfaceOpenSeize()</code>. Before releasing a device in response to this message Classic firstchecks an activity timer which it keeps for each device. If no I/O has been done to or from thedevice in the last five seconds, then Classic will release the device. From inside Classic it appears asthough the device had been unplugged.</p><br><p><b><code>USBDeviceOpenSeize()/USBInterfaceOpenSeize() -&gt; AttemptingOpen(1)</code></b></p><p>This works just thesame as <code>Open()</code>, except the <code>kIOMessageServiceIsRequestingClose</code> message gets sent to whatever kernel driver isholding the IOUSBDevice or IOUSBInterface object open instead of the <code>kIOMessageServiceIsAttemptingOpen</code> message. Outside the kernel, a user-mode application which has registered forGeneral Interest Notifications on this IOUSBDevice or IOUSBInterface will only receivea callback with <code>messageType ==kIOMessageServiceIsAttemptingOpen </code>and<code>messageArgument != 0</code>. The way to distinguish whether <code>Open()</code> or <code>OpenSeize()</code> was called is tocheck the <code>messageArgument</code>. We use this distinction in order to distinguishbetween two levels of seriousness. A casual request to open a device or interface should betreated differently than a seize request. You should use the <code>...Seize()</code> variation of these calls onlywhen you're sure you want the application that's holding the device/interfaceopen to release it as soon as possible, without regard for any ongoingI/O. If your kernel driverreceives a <code>kIOMessageServiceIsRequestingClose</code>message then it should close theIOUSBDevice or IOUSBInterface as soon as possible (if possible). The same is true for a user-mode driverthat receives a General Interest Notification callback with <code>messageType == kIOMessageServiceIsAttemptingOpen </code>and <code>messageArgument!= 0</code>.</p><br><p><b><code>USBDeviceClose()/USBInterfaceClose() -&gt; WasClosed</code></b></p><p>When theIOUSBDevice or IOUSBInterface is closed, your callback will be called with the <code>kIOMessageServiceWasClosed</code> message. If you recently got an <code>kIOReturnExclusiveAccess</code> error this is your signal to retry the Open()that failed. For example, Classiclistens for this message after releasing a device (in respond to an <code>kIOMessageServiceIsAttemptingOpen</code> message) to know when to attempt to reacquirethe device. When it reacquires thedevice it simulates a hot plug so that from inside Classic it appears that thedevice has been plugged in.</p><p><b>Warning</b>: be careful toignore messages that you caused to be sent. Set a flag or increment a counter when you do open orclose operations. That way you'll know whenthe next <code>AttemptingOpen</code> or <code>WasClosed</code> message arrives that you were the one whocaused it to be sent. Otherwiseyou could go into an infinite loop arbitrating access to the device betweenyourself and yourself.</p><br><h4>Scenarios</h4><p>Consider a vendor-specificUSB device that has been noticed by Classic. And imagine that you have a user-mode application or driverthat would like to access the device from outside Classic. The first time this entity attempts to call <code>USBDeviceOpen</code>()(similarly, <code>USBDeviceOpenSeize()</code>, <code>USBInterfaceOpen()</code>, or <code>USBInterfaceOpenSeize()</code>) it will get a <code>kIOReturnExclusiveAccess</code>error. Shortly thereafter, Classicwill call <code>USBDeviceClose()</code> on the device. To applications running inside Classic, the device willappear to have been unplugged. Atthis point, anyone can attempt the <code>USBDeviceOpen()</code> again and it ought to succeed. And when you are done using the deviceand you <code>USBDeviceClose()</code> it, Classic reopens it. It then reappears to applicationsrunning inside Classic, just as if it had been hot-plugged.</p><p>This should provide aworkaround for existing Mac OS X USB software: the user can simply retry thefailed operation without needing to quit Classic.</p><p>The most complete wayto handle arbitration is to register for general interest notifications andhandle <code>kIOMessageServiceIsAttemptingOpen</code>, and <code>kIOMessageServiceWasClosed</code> messages as described above.</p><p>In some situations,the following simplified mechanism might suffice:</p><pre>for (sleepCount = 5; sleepCount > 0; sleepCount--){	// Attempt to open the device.	err = (*device)->DeviceOpen(device);	if ( kIOReturnExclusiveAccess == err )	{		// Someone else has the device open.		// But they might release it in a few seconds.		// So sleep for a second and try again.	     	// Update user interface to warn the user that		// you're waiting for the device.	     	sleep(1);		continue;	}	else	if ( kIOReturnSuccess != err )	{          		// Unexpected error.  Break out of the loop.          		break;     	}	else	{		// Success.  Break out of the loop.		break;	}}// Check <err> here to see whether you got access or not.</pre>                <!-- start of footer -->        <!--#include virtual="/includes/framesetfooter" -->        <!-- end of footer --></body></html>