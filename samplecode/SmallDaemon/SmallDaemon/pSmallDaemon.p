(* *  pSmallDaemon * *  7/92 Greg Robbins         based on code by C.K. Haun * *  This is a minimal faceless background application for System 7. * *  It demonstrates how to install and dispatch Apple events, as well *  as the other bare essentials for a faceless background app. * *  The file type for this application should be 'APPL' if it will be launched *  like an application or 'appe' if it will be placed into the Extensions *  folder and launched at startup.  'appe' files can also have an INIT resource  *  to put up an icon (using ShowInit) at startup. *)PROGRAM pSmallDaemon;	USES AppleEvents, GestaltEqu;		CONST		kSleepMax = MAXLONGINT; { long sleep time to avoid stealing cycles         }		                        { an app which does something on null events might }								{ sleep less                                       }	VAR		gQuitFlag, gAppleEventsFlag: Boolean;		gSleepVal: LongInt;				gRetCode: OSErr;		gGestResponse: LongInt;		gMainEventRec: EventRecord;		gEventFlag: Boolean;			{ Apple event handlers to be installed }	FUNCTION DoAEOpenApplication(theAEvent: AppleEvent;		reply: AppleEvent; refcon: LONGINT): OSErr;	BEGIN		DoAEOpenApplication := noErr;	END;			FUNCTION DoAEOpenDocuments(theAEvent: AppleEvent;		reply: AppleEvent; refcon: LONGINT): OSErr;	BEGIN		DoAEOpenDocuments := errAEEventNotHandled;	END;	FUNCTION DoAEPrintDocuments(theAEvent: AppleEvent;		reply: AppleEvent; refcon: LONGINT): OSErr;	BEGIN		DoAEPrintDocuments := errAEEventNotHandled;	END;			FUNCTION DoAEQuitApplication(theAEvent: AppleEvent;		reply: AppleEvent; refcon: LONGINT): OSErr;	BEGIN		gQuitFlag := TRUE;		DoAEQuitApplication := noErr;	END; { DoAEQuit }		PROCEDURE InitAppleEventsStuff;	VAR		retCode: OSErr;	BEGIN		IF gAppleEventsFlag THEN		BEGIN			retCode := AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, 				@DoAEOpenApplication, 0, FALSE);			IF retCode = noErr THEN				retCode := AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,					@DoAEOpenDocuments, 0, FALSE);			IF retCode = noErr THEN				retCode := AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, 					@DoAEPrintDocuments, 0, FALSE);			IF retCode = noErr THEN				retCode := AEInstallEventHandler(kCoreEventClass, kAEQuitApplication,					@DoAEQuitApplication, 0, FALSE);			IF retCode <> noErr THEN				DebugStr('Install event handler failed');			{ a better way to indicate an error is to post a notification }		END;	END;		PROCEDURE DoHighLevelEvent(theEventRec: EventRecord);	{ high-level event dispatching }	VAR		retCode: OSErr;	BEGIN		retCode := AEProcessAppleEvent(theEventRec)	END;		BEGIN { main program }	{ faceless background apps only get a 2K stack by default.  If necessary,	  increase the stack size here (by calling GetApplLimit to find the current	  heap limit, and SetApplLimit to set it to a lower address, thus reserving	  more space for the stack)                                                 }		{ initialize QuickDraw globals }		InitGraf(@thePort);		{ initialize application globals }		gQuitFlag := FALSE;	gSleepVal := kSleepMax;		{ is the Apple Event Manager available? }		gRetCode := Gestalt(GestaltAppleEventsAttr, gGestResponse);	IF (gRetCode = noErr) AND BTST(gGestResponse, gestaltAppleEventsPresent) THEN		gAppleEventsFlag := TRUE	ELSE		gAppleEventsFlag := FALSE;			{ install Apple event handlers }		InitAppleEventsStuff;		{ main event loop }		WHILE NOT(gQuitFlag) DO	BEGIN		gEventFlag := 			WaitNextEvent(highLevelEventMask, gMainEventRec, gSleepVal, NIL);		{ faceless background tasks receive only high-level events }		IF gMainEventRec.what = kHighLevelEvent THEN			DoHighLevelEvent(gMainEventRec);				{ during testing, I like to call GetKeys here and check if the CapsLock		  key is down.  If it is, set gQuitFlag so the program will exit. }	END;		END.