/***	File:		PICTFile.c****	Contains:	PICT file for simple text application****	Version:	SimpleText 1.4 or later**** Copyright 1993-1999 Apple Computer. All rights reserved.****	You may incorporate this sample code into your applications without**	restriction, though the sample code has been provided "AS IS" and the**	responsibility for its operation is 100% yours.  However, what you are**	not permitted to do is to redistribute the source as "DSC Sample Code"**	after having made changes. If you're going to re-distribute the source,**	we require that you make it clear in the source that the code was**	descended from Apple Sample Code, but that you've made changes.*/#include "MacIncludes.h"#include "PICTFile.h"/* ------------------------------------------------------------------------------------	*//* GLOBALS ONLY USED BY THIS FILE *//* ------------------------------------------------------------------------------------	*/#define kBufferSize	2048static short			gPictFileRefNum;static char				gPictureBuffer[kBufferSize];static long				gAmountInBuffer;static long				gFirstCharInBuffer;static QDProcsPtr     	gSavedProcs;static QDProcs        	gMyProcs;static CQDProcs       	gMyColorProcs;// --------------------------------------------------------------------------------------------------------------// INTERNAL ROUTINES// --------------------------------------------------------------------------------------------------------------static pascal void GetPICTData(Ptr dataPtr,short byteCount)/*	replacement for the QuickDraw bottleneck routine*/{     OSErr            err = noErr;    long            longCount;    longCount = byteCount;		while ( (longCount > 0) && (err == noErr) )		{		if (gAmountInBuffer == 0)			{			gAmountInBuffer = kBufferSize;			gFirstCharInBuffer = 0;			err = FSRead(gPictFileRefNum,&gAmountInBuffer,gPictureBuffer);			}		if (gAmountInBuffer > 0)			{			long	amountToMove;						amountToMove = gAmountInBuffer;			if (amountToMove > longCount)				amountToMove = longCount;							BlockMoveData(&gPictureBuffer[gFirstCharInBuffer], dataPtr, amountToMove);			longCount -= amountToMove;			dataPtr += amountToMove;			gFirstCharInBuffer += amountToMove;			gAmountInBuffer -= amountToMove;			}					}	} // GetPICTData#if GENERATINGCFM	static RoutineDescriptor gGetPICTDataRD = BUILD_ROUTINE_DESCRIPTOR(uppQDGetPicProcInfo, GetPICTData);	static QDGetPicUPP gGetPICTData = &gGetPICTDataRD;#else	static QDGetPicUPP gGetPICTData = NewQDGetPicProc(GetPICTData);#endif// --------------------------------------------------------------------------------------------------------------static OSErr	DiskPictureDraw( WindowDataPtr pData, 	Boolean doDraw, Rect *pictureRect, Point *pOffset){	OSErr		anErr;	PicHandle	picHandle;	Point		offset;		if (pOffset)		offset = *pOffset;	else		{		offset.h = GetControlValue(pData->hScroll);		offset.v = GetControlValue(pData->vScroll);		}	picHandle = ((PICTDataPtr)pData)->cacheHandle;		if (picHandle)		{		if (doDraw)			{			Rect	destRect;						GetPICTRectangleAt72dpi(picHandle, &destRect);			OffsetRect(&destRect, 								-destRect.left + 									pData->contentRect.left -									offset.h, 								-destRect.top + 									pData->contentRect.top -									offset.v);			DrawPicture(picHandle, &destRect);			}				if (pictureRect)			{			GetPICTRectangleAt72dpi(picHandle, pictureRect);			OffsetRect(pictureRect, -pictureRect->left, -pictureRect->top);			}					picHandle = nil;		anErr = noErr;		}	else		{		// make enough room for PICT header, including version		picHandle = (PicHandle) NewHandle(sizeof(Picture)  + sizeof(long)*8);		anErr = MemError();		nrequire(anErr, FailedNewHandle);				gPictFileRefNum = pData->dataRefNum;		anErr = SetFPos(gPictFileRefNum, fsFromStart, 512);		nrequire(anErr, FailedSetFPos);				gAmountInBuffer = kBufferSize;		gFirstCharInBuffer = 0;		anErr = FSRead(gPictFileRefNum, &gAmountInBuffer, gPictureBuffer);		if (anErr == eofErr)			anErr = noErr;		if (gAmountInBuffer < sizeof(Picture))			anErr = eofErr;		nrequire(anErr, FailedInitialRead);			// copy PICT header, including version		BlockMoveData(gPictureBuffer, *picHandle, sizeof(Picture) + sizeof(long)*8);		gFirstCharInBuffer += sizeof(Picture);		gAmountInBuffer -= sizeof(Picture);				if (doDraw)			{			Rect	destRect;						GetPICTRectangleAt72dpi(picHandle, &destRect);			if (!gMachineInfo.haveQuickTime)				{				if (gMachineInfo.theEnvirons.hasColorQD)					{					if ((*qd.thePort).grafProcs)						BlockMoveData((*qd.thePort).grafProcs, &gMyColorProcs, sizeof(gMyColorProcs));					else						SetStdCProcs(&gMyColorProcs);					}				else					{					if ((*qd.thePort).grafProcs)						BlockMoveData((*qd.thePort).grafProcs, &gMyProcs, sizeof(gMyProcs));					else						SetStdProcs(&gMyProcs);					}									gMyProcs.getPicProc = gGetPICTData;				gMyColorProcs.getPicProc = gGetPICTData;				gSavedProcs = (*qd.thePort).grafProcs;							if (gMachineInfo.theEnvirons.hasColorQD)					(*qd.thePort).grafProcs = (QDProcsPtr)&gMyColorProcs;				else					(*qd.thePort).grafProcs = &gMyProcs;				}							OffsetRect(&destRect, 								-destRect.left + 									pData->contentRect.left -									offset.h, 								-destRect.top + 									pData->contentRect.top -									offset.v);															if (!gMachineInfo.haveQuickTime)				{				DrawPicture(picHandle, &destRect);				(*qd.thePort).grafProcs = gSavedProcs;				}			else				DrawPictureFile(gPictFileRefNum, &destRect, nil);				}					if (pictureRect)			{			GetPICTRectangleAt72dpi(picHandle, pictureRect);			OffsetRect(pictureRect, -pictureRect->left, -pictureRect->top);			}		}	// FALL THROUGH EXCEPTION HANDLINGFailedInitialRead:FailedSetFPos:	DisposeHandle((Handle) picHandle);FailedNewHandle:		return(anErr);		} // DiskPictureDraw// --------------------------------------------------------------------------------------------------------------static OSErr GetSelectedPicture(WindowDataPtr pData, PicHandle *pResult){	OSErr		anErr;	PicHandle	scrapPict;	Rect		globRect;	GDHandle	theMaxDevice;	short		theDepth;	GDHandle	savedGDevice;	CGrafPtr	savedPort;	GWorldPtr	offscreenGWorld;	// save away current value for restores	GetGWorld(&savedPort, &savedGDevice);	// determine the best way in which to allocate stuff		SetRect(&globRect, -32760, -32760, 32760, 32760);	theDepth = 1;	if (gMachineInfo.theEnvirons.hasColorQD)		{		theDepth = 8;		theMaxDevice = GetMaxDevice(&globRect);		if (theMaxDevice != nil)			theDepth = (**(**theMaxDevice).gdPMap).pixelSize;		}		// allocate the GWorld in temp mem, or local if we run out	anErr = NewGWorld(&offscreenGWorld, theDepth, 						&((PICTDataPtr)pData)->selectionRectangle,						nil, nil, useTempMem);	if (anErr != noErr)		anErr = NewGWorld(&offscreenGWorld, theDepth, 							&((PICTDataPtr)pData)->selectionRectangle,							nil, nil, 0);	nrequire(anErr, FailedNewGWorld);	// blow open the visRgn, and clip to the selected area	RectRgn(offscreenGWorld->visRgn, &globRect);	PortChanged((GrafPtr) offscreenGWorld);	SetGWorld(offscreenGWorld, nil);	EraseRect(&offscreenGWorld->portRect);	ClipRect(&((PICTDataPtr)pData)->selectionRectangle);		// Draw the picture into the offscreen	LockPixels( GetGWorldPixMap(offscreenGWorld));	{	Point	offset = {0,0};	anErr = DiskPictureDraw(pData, true, &((PICTDataPtr)pData)->selectionRectangle, &offset);	}	UnlockPixels( GetGWorldPixMap(offscreenGWorld));	nrequire(anErr, FailedDraw);	// CopyBits in place to grab the selection	scrapPict = OpenPicture(&((PICTDataPtr)pData)->selectionRectangle);	LockPixels( GetGWorldPixMap(offscreenGWorld));	CopyBits(&((GrafPtr)offscreenGWorld)->portBits, &((GrafPtr)offscreenGWorld)->portBits, 		&((PICTDataPtr)pData)->selectionRectangle, &((PICTDataPtr)pData)->selectionRectangle,		srcCopy, nil);	anErr = QDError();	UnlockPixels( GetGWorldPixMap(offscreenGWorld));	ClosePicture();	globRect = (**scrapPict).picFrame;	if ( (anErr == noErr) && (EmptyRect(&globRect)) )		anErr = memFullErr;			// done with our offscreen now	SetGWorld(savedPort, savedGDevice);	DisposeGWorld(offscreenGWorld);	if (anErr == noErr)		*pResult = scrapPict;		return(anErr);	// EXCEPTION HANDLINGFailedDraw:	DisposeGWorld(offscreenGWorld);	FailedNewGWorld:	SetGWorld(savedPort, savedGDevice);	return(anErr);	} // GetSelectedPicture// --------------------------------------------------------------------------------------------------------------static OSErr CopyGWorld(WindowDataPtr pData){	OSErr		anErr;	PicHandle	scrapPict;	anErr = GetSelectedPicture(pData, &scrapPict);	if (anErr == noErr)		{		if (LoadScrap() == noErr)			{			ZeroScrap();			HLock((Handle) scrapPict);			anErr = PutScrap(GetHandleSize((Handle) scrapPict), 'PICT', (Ptr)*scrapPict);			KillPicture(scrapPict);			}		}		return(anErr);	} // CopyGWorld// --------------------------------------------------------------------------------------------------------------static pascal OSErr PICTSendDataProc(FlavorType theType, void *dragSendRefCon,								ItemReference theItem, DragReference theDrag)/* *	The ItemReference is the gxShape to be sent. The dragSendRefCon is ignored.*/{#pragma unused (dragSendRefCon)	OSErr	result = noErr;	switch (theType) 		{		case 'PICT':			{				PicHandle 	pict;			OSErr		anErr = GetSelectedPicture((WindowDataPtr)theItem, &pict);				if (anErr == noErr)				{					HLock((Handle)pict);				result = SetDragItemFlavorData(theDrag, theItem, 'PICT', (Ptr)*pict, GetHandleSize((Handle)pict), 0);				KillPicture(pict);				}			}			break;					default:			result = badDragFlavorErr;			break;		}			return result;	} // PICTSendDataProc#if GENERATINGCFM	static RoutineDescriptor gPICTSendDataProcRD = BUILD_ROUTINE_DESCRIPTOR(uppDragSendDataProcInfo, PICTSendDataProc);	static DragSendDataUPP gPICTSendDataProc = &gPICTSendDataProcRD;#else	static DragSendDataUPP gPICTSendDataProc = NewDragSendDataProc(PICTSendDataProc);#endif// --------------------------------------------------------------------------------------------------------------// OOP INTERFACE ROUTINES// --------------------------------------------------------------------------------------------------------------static OSErr	PICTUpdateWindow(WindowRef pWindow, WindowDataPtr pData){	OSErr		anErr;	RgnHandle	oldClip = NewRgn();		EraseRect(&pData->contentRect);		GetClip(oldClip);	ClipRect(&pData->contentRect);	anErr = DiskPictureDraw( pData, true, nil, nil);	SetClip(oldClip);	DisposeRgn(oldClip);		DrawSelection(pData, &((PICTDataPtr)pData)->selectionRectangle, &((PICTDataPtr)pData)->patternPhase, false);		DrawControls(pWindow);	DrawGrowIcon(pWindow);		return(anErr);	} // PICTUpdateWindow// --------------------------------------------------------------------------------------------------------------static OSErr	PICTGetDocumentRect(WindowRef pWindow, WindowDataPtr pData, 			LongRect * documentRectangle, Boolean forGrow){#pragma unused (pWindow, forGrow)	RectToLongRect(&((PICTDataPtr)pData)->pictureRectangle, documentRectangle);		return(noErr);	} // PICTGetDocumentRect// --------------------------------------------------------------------------------------------------------------static OSErr	PICTCloseWindow(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)	DisposeHandle( (Handle) (((PICTDataPtr)pData)->cacheHandle));		return(noErr);	} // PICTCloseWindow// --------------------------------------------------------------------------------------------------------------static OSErr	PICTContentClick(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){	OSErr	anErr = noErr;	Rect	selectionRect = ((PICTDataPtr)pData)->selectionRectangle;	Point	clickPoint = pEvent->where;		GlobalToLocal(&clickPoint);	OffsetRect(&selectionRect, -GetControlValue(pData->hScroll), -GetControlValue(pData->vScroll));	if ( (gMachineInfo.haveDragMgr) && (PtInRect(clickPoint, &selectionRect)) )		{		DragAndDropArea(pWindow, pData, pEvent, 							&selectionRect);		}	else		{		anErr = SelectContents(pWindow, pData, pEvent, 					&((PICTDataPtr)pData)->selectionRectangle, &((PICTDataPtr)pData)->pictureRectangle, 					&((PICTDataPtr)pData)->patternPhase);		}		return(anErr);	} // PICTContentClick// --------------------------------------------------------------------------------------------------------------static OSErr	PICTAdjustCursor(WindowRef pWindow, WindowDataPtr pData, Point * localMouse, Rect * globalRect){#pragma unused (pWindow, globalRect)	OSErr			anErr = noErr;	CursHandle		theCross;	Rect			selectionRect = ((PICTDataPtr)pData)->selectionRectangle;		OffsetRect(&selectionRect, -GetControlValue(pData->hScroll), -GetControlValue(pData->vScroll));	if (!PtInRect(*localMouse, &selectionRect) )		{		theCross = GetCursor(crossCursor);		if (theCross)			{			char	oldState;						oldState = HGetState((Handle) theCross);			HLock((Handle) theCross);			SetCursor(*theCross);			HSetState((Handle) theCross, oldState);			anErr = eActionAlreadyHandled;			}		}				return(anErr);	} // PICTAdjustCursor// --------------------------------------------------------------------------------------------------------------static OSErr	PICTDragAddFlavors(WindowRef pWindow, WindowDataPtr pData, DragReference theDragRef){#pragma unused (pWindow)	OSErr	anErr = noErr;		SetDragSendProc(theDragRef, gPICTSendDataProc, nil);	AddDragItemFlavor(theDragRef, (unsigned long)pData, 'PICT', nil, 0, 0);		return(anErr);	} // PICTDragAddFlavors// --------------------------------------------------------------------------------------------------------------static OSErr	PICTGetBalloon(WindowRef pWindow, WindowDataPtr pData, 		Point *localMouse, short * returnedBalloonIndex, Rect *returnedRectangle){#pragma unused (pWindow, pData)	Rect	tempRect = ((PICTDataPtr)pData)->selectionRectangle;		// assume generic content	*returnedBalloonIndex = iHelpPictContent;		// see if we are within the selection	OffsetRect(&tempRect, -GetControlValue(pData->hScroll), -GetControlValue(pData->vScroll) );	SectRect(&tempRect, &pData->contentRect, &tempRect);		if (PtInRect(*localMouse, &tempRect))		{		*returnedRectangle		= tempRect;		*returnedBalloonIndex 	= iHelpPictSelection;		}			return(noErr);	} // PICTGetBalloon// --------------------------------------------------------------------------------------------------------------static OSErr	PICTPrintPage(WindowRef pWindow, WindowDataPtr pData,					Rect * pageRect, long *pageNum){#pragma unused (pWindow)	OSErr	anErr = noErr;	short	pagesWide, pagesHigh;	Rect	pictureRect = ((PICTDataPtr)pData)->pictureRectangle;	Point	offset;	Rect	localPageRect = *pageRect;		// calculate how many physical pages will be required to print this PICT	if (EqualRect(&pictureRect, &localPageRect))		pagesWide = pagesHigh = 1;	else		{		pagesWide = (pictureRect.right - pictureRect.left) / (localPageRect.right - localPageRect.left) + 1;		pagesHigh = (pictureRect.bottom - pictureRect.top) / (localPageRect.bottom - localPageRect.top) + 1;		}						// compute the offset in # of pages	offset.h = ((*pageNum - 1) % pagesWide);	offset.v = ((*pageNum - 1) / pagesWide);	// compute the pixel offset for this page	offset.h *= localPageRect.right - localPageRect.left;	offset.v *= localPageRect.bottom - localPageRect.top;		anErr = DiskPictureDraw( pData, true, &localPageRect, &offset);		// tell it to stop printing when we reach the end	if (*pageNum >= (pagesWide*pagesHigh))		*pageNum = -1;		return(anErr);	} // PICTPrintPage// --------------------------------------------------------------------------------------------------------------static OSErr	PICTAdjustMenus(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)	OSErr anErr = noErr;		if (!EmptyRect(&((PICTDataPtr)pData)->selectionRectangle))		EnableCommand(cCopy);	if 	(EqualRect(&((PICTDataPtr)pData)->pictureRectangle, &((PICTDataPtr)pData)->selectionRectangle))		ChangeCommandName(cSelectAll, kMiscStrings, iSelectNoneCommand);	else		ChangeCommandName(cSelectAll, kMiscStrings, iSelectAllCommand);	EnableCommand(cSelectAll);		return(anErr);	} // PICTAdjustMenus// --------------------------------------------------------------------------------------------------------------static OSErr	PICTCommand(WindowRef pWindow, WindowDataPtr pData, short commandID, long menuResult){#pragma unused (pWindow, menuResult)	OSErr	anErr = noErr;		switch (commandID)		{		case cCopy:			anErr = CopyGWorld(pData);			break;				case cSelectAll:			// erase the old selection			DrawSelection(pData, &((PICTDataPtr)pData)->selectionRectangle, &((PICTDataPtr)pData)->patternPhase, false);						if 	(EqualRect(&((PICTDataPtr)pData)->pictureRectangle, &((PICTDataPtr)pData)->selectionRectangle))				{				((PICTDataPtr)pData)->selectionRectangle.top = 0;				((PICTDataPtr)pData)->selectionRectangle.left = 0;				((PICTDataPtr)pData)->selectionRectangle.bottom = 0;				((PICTDataPtr)pData)->selectionRectangle.right = 0;				}			else				{				((PICTDataPtr)pData)->selectionRectangle = ((PICTDataPtr)pData)->pictureRectangle;				}							// draw the new selection			DrawSelection(pData, &((PICTDataPtr)pData)->selectionRectangle, &((PICTDataPtr)pData)->patternPhase, true);			break;		}		return(anErr);	} // PICTCommand// --------------------------------------------------------------------------------------------------------------static long PICTCalculateIdleTime(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)	if (!EmptyRect( &((PICTDataPtr)pData)->selectionRectangle))		return(0);	else		return(kMaxWaitTime);		} // PICTCalculateIdleTime// --------------------------------------------------------------------------------------------------------------static Boolean	PICTFilterEvent(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){	if 	(		(!gMachineInfo.amInBackground) &&		(pEvent->what == nullEvent) &&		(pWindow == FrontWindow()) &&		(EmptyRgn( ((WindowPeek)pWindow)->updateRgn)) &&		(MOVESELECTION(pEvent->when) )		)		{		// erase the old		DrawSelection(pData, &((PICTDataPtr)pData)->selectionRectangle, &((PICTDataPtr)pData)->patternPhase, false);				// draw the new, moving onto the next pattern		DrawSelection(pData, &((PICTDataPtr)pData)->selectionRectangle, &((PICTDataPtr)pData)->patternPhase, true);		}			return(false);	} // PICTFilterEvent// --------------------------------------------------------------------------------------------------------------static OSErr	PICTMakeWindow(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)	Size	availableRAM;	long	amountInFile;	OSErr	anErr = noErr;		pData->pUpdateWindow 		= (UpdateWindowProc)		PICTUpdateWindow;	pData->pGetDocumentRect 	= (GetDocumentRectProc)		PICTGetDocumentRect;	pData->pCloseWindow 		= (CloseWindowProc)			PICTCloseWindow;	pData->pContentClick 		= (ContentClickProc)		PICTContentClick;	pData->pAdjustCursor 		= (AdjustCursorProc)		PICTAdjustCursor;	pData->pGetBalloon	 		= (GetBalloonProc)			PICTGetBalloon;	pData->pAdjustMenus 		= (AdjustMenusProc)			PICTAdjustMenus;	pData->pPrintPage	 		= (PrintPageProc)			PICTPrintPage;	pData->pCommand		 		= (CommandProc)				PICTCommand;	pData->pFilterEvent		 	= (FilterEventProc)			PICTFilterEvent;	pData->pCalculateIdleTime	= (CalculateIdleTimeProc)	PICTCalculateIdleTime;	pData->pDragAddFlavors		= (DragAddFlavorsProc)		PICTDragAddFlavors;		pData->hasGrow				= true;	pData->hScrollAmount		= 10;	pData->vScrollAmount		= 10;		// Calculate amount of available RAM for cache	{	Size grow;	availableRAM = MaxMem(&grow);	}		// Take half of it	availableRAM >>= 1;		// if too big, make it just big enough	GetEOF(pData->dataRefNum, &amountInFile);	amountInFile -= 512;		if (amountInFile < sizeof(Picture))		anErr = eErrorWhileDrawing;	else		{		if (availableRAM > amountInFile)			{			Handle	theHandle = NewHandle(amountInFile);						if (theHandle)				{				SetFPos(pData->dataRefNum, fsFromStart, 512);				FSRead(pData->dataRefNum, &amountInFile, *theHandle);								((PICTDataPtr)pData)->cacheHandle = (PicHandle)theHandle;				}			}					// initialize the rectangle to be valid		{		Rect	pictureRect;		DiskPictureDraw( pData, false, &((PICTDataPtr)pData)->pictureRectangle, nil);			pictureRect = ((PICTDataPtr)pData)->pictureRectangle;		if ((pData->contentRect.right > pictureRect.right) && (pictureRect.right > 0))			pData->contentRect.right = pictureRect.right;		if ((pData->contentRect.bottom > pictureRect.bottom) && (pictureRect.bottom > 0))			pData->contentRect.bottom = pictureRect.bottom;		}		}		return(anErr);	} // PICTMakeWindow// --------------------------------------------------------------------------------------------------------------OSErr	PICTPreflightWindow(PreflightPtr pPreflightData){	pPreflightData->wantHScroll			= true;	pPreflightData->wantVScroll			= true;		pPreflightData->continueWithOpen 	= true;	pPreflightData->makeProcPtr 		= PICTMakeWindow;		pPreflightData->storageSize = sizeof(PICTDataRecord);		return(noErr);	} // PICTPreflightWindow// --------------------------------------------------------------------------------------------------------------void PICTGetFileTypes(OSType * pFileTypes, OSType * pDocumentTypes, short * numTypes){	pFileTypes[*numTypes] 		= 'PICT';	pDocumentTypes[*numTypes] 	= kPICTWindow;	(*numTypes)++;	} // PICTGetFileTypes