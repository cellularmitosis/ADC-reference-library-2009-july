<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoofWarsOld - /Tim's Libraries/TGraphicCollection.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGames-date.html">Games</a> &gt; <A HREF="javascript:location.replace('index.html');">MoofWarsOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/index.html" target="_blank">Reference Library > Games</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoofWarsOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Tim's Libraries/TGraphicCollection.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MoofEncoder/AppConditionals.h</option>
<option value="listing2.html">/MoofEncoder/Color Search Procs.cp</option>
<option value="listing3.html">/MoofEncoder/Color Search Procs.h</option>
<option value="listing4.html">/MoofEncoder/GridEncode.cp</option>
<option value="listing5.html">/MoofEncoder/GridEncode.h</option>
<option value="listing6.html">/MoofEncoder/GridTilesFormat.h</option>
<option value="listing7.html">/MoofEncoder/ICL8Encode.cp</option>
<option value="listing8.html">/MoofEncoder/ICL8Encode.h</option>
<option value="listing9.html">/MoofEncoder/main.cp</option>
<option value="listing10.html">/MoofEncoder/main.h</option>
<option value="listing11.html">/MoofEncoder/PICTEncode.cp</option>
<option value="listing12.html">/MoofEncoder/PICTEncode.h</option>
<option value="listing13.html">/MoofEncoder/PICTMask.cp</option>
<option value="listing14.html">/MoofEncoder/PICTMask.h</option>
<option value="listing15.html">/MoofWars/AppConditionals.h</option>
<option value="listing16.html">/MoofWars/GridTilesFormat.h</option>
<option value="listing17.html">/MoofWars/MoofWars.cp</option>
<option value="listing18.html">/MoofWars/MoofWars.h</option>
<option value="listing19.html">/MoofWars/TCommandTimer.cp</option>
<option value="listing20.html">/MoofWars/TCommandTimer.h</option>
<option value="listing21.html">/MoofWars/TEnemySprite.cp</option>
<option value="listing22.html">/MoofWars/TEnemySprite.h</option>
<option value="listing23.html">/MoofWars/TShipSprite.cp</option>
<option value="listing24.html">/MoofWars/TShipSprite.h</option>
<option value="listing25.html">/MoofWars/TShotSprite.cp</option>
<option value="listing26.html">/MoofWars/TShotSprite.h</option>
<option value="listing27.html">/MoofWars/TSprite.cp</option>
<option value="listing28.html">/MoofWars/TSprite.h</option>
<option value="listing29.html">/MoofWars/TSpriteCollection.cp</option>
<option value="listing30.html">/MoofWars/TSpriteCollection.h</option>
<option value="listing31.html">/MoofWars/TTileCollection.cp</option>
<option value="listing32.html">/MoofWars/TTileCollection.h</option>
<option value="listing33.html">/MoofWars/TTileGrid.cp</option>
<option value="listing34.html">/MoofWars/TTileGrid.h</option>
<option value="listing35.html">/Tim's Libraries/Common Stuff.h</option>
<option value="listing36.html">/Tim's Libraries/Error Macros.h</option>
<option value="listing37.html">/Tim's Libraries/Scaling.cp</option>
<option value="listing38.html">/Tim's Libraries/Scaling.h</option>
<option value="listing39.html">/Tim's Libraries/TGraphic.cp</option>
<option value="listing40.html">/Tim's Libraries/TGraphic.h</option>
<option value="listing41.html">/Tim's Libraries/TGraphicCollection.cp</option>
<option value="listing42.html">/Tim's Libraries/TGraphicCollection.h</option></select>
				</p>
				</form>
				<p><strong><a href="MoofWarsOld.zip">Download Sample</a></strong> (&#147;MoofWarsOld.zip&#148;, 222.9K)<BR>
<strong><a href="MoofWarsOld.dmg">Download Sample</a></strong> (&#147;MoofWarsOld.dmg&#148;, 287.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    TGraphicCollection.cp  Contains:  A TGraphicCollection is a group of related TGraphic objects.  The API is        very similar to that of TGraphic, but includes an index to determine which        TGraphic is receiving the command.        This class is tightly coupled to the TGraphic class, so it has all of the        same limitations.          Note that this class isn't currently intended to be subclassed, so all of        the methods are non-virtual.  This might change if at some point we        determine we need to create a subclass.    Written by: Timothy Carroll    Copyright:  Copyright &copy; 1996-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/2/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1                11/5/97            Cleaned up to work with 3.x Universal Headers                       and CW Pro. Cleaned up some comments.  Made same                      changes to list management code as were made in                      TGraphic.  Should revisit making a generic list                      class, if performance isn't killed.                              4/2/97            CreateCollection was calling ReleaseResource twice,                       because I forgot to remove the original call to                        ReleaseResource when I reorganized some of the                       cleanup code.  Onyx's Spotlight spotted this one for                        me.        2/24/97            Explicitly includes the error macros now.  We should                       be able to build on other compilers than Metrowerks.        */#include &lt;Memory.h&gt;#include &lt;Resources.h&gt;#include &quot;Error Macros.h&quot;#include &quot;TGraphicCollection.h&quot;/*************************************************************************************TGraphicCollections and List ManagementTGraphicCollections are allocated and maintained in a list internally by this class.Each object is reference counted, to minimize the need to load resources more thanonce.For optimal performance, pre-load the TGraphicCollection once outside the game loop.This should mean that all searches hit inside the list.  Theoretically, you can alsojust create one TGraphicCollection, and everybody who needs it gets a copy of thehandle.  Eliminates the need for reference counting, but then you need to make sureany references to it are eliminated.The list is sorted by the collections's resource ID, and uses standard C array indexing.The list is searched using a binary search.  *************************************************************************************/static Handle gCollectionList = NULL;static UInt32 gNumberCollections = 0;static OSStatus InsertCollectionIntoList (TGraphicCollection *theCollection, UInt32 index);static OSStatus DeleteCollectionFromList (UInt32 index);static OSStatus SearchCollectionList (SInt16 resID, Boolean *found, UInt32 *index);/*****************************************************************************InsertCollectionIntoListThis routine creates the list if it hasn't been initialized.  Otherwise, itjust inserts the collection into the spot pointed to by the index.  If an erroroccurs, the list is left in an indeterminate state.*****************************************************************************/OSStatus InsertCollectionIntoList (TGraphicCollection *theCollection, UInt32 index){  OSStatus theErr = noErr;#if qDebugging  if (theCollection == NULL)    SIGNAL_ERROR (&quot;\pAttempting to insert a null collection into the list&quot;)    if ((index &gt; gNumberCollections) || (index &lt; 0))    SIGNAL_ERROR (&quot;\pAttempting to insert collection at invalid index&quot;)#endif    // if we don't have a list allocate one  if (gCollectionList == NULL)  {    gNumberCollections = 1;        gCollectionList = NewHandleClear (sizeof (TGraphicCollection *));    theErr = MemError();    FAIL_OSERR (theErr, &quot;\pCouldn't allocate a new handle of information&quot;)    FAIL_NIL (gCollectionList, &quot;\pCouldn't allocate a new handle of information&quot;)  }  else  // if we do have a list, expand it by one node.  {    gNumberCollections++;    SetHandleSize(gCollectionList,gNumberCollections*sizeof(TGraphicCollection *));        theErr = MemError();    FAIL_OSERR (theErr, &quot;\pCouldn't resize the list handle&quot;)    FAIL_NIL (gCollectionList, &quot;\pCouldn't resize the list handle&quot;)        // Shift the data to make room    BlockMoveData(  (*(TGraphicCollection ***)gCollectionList)+index,            (*(TGraphicCollection ***)gCollectionList)+index+1,            (gNumberCollections - index-1) * sizeof(TGraphicCollection *));  }    // finally, set the new object in place      *((*(TGraphicCollection ***) gCollectionList)+index)   = theCollection;  goto cleanup;  error:  if (theErr == noErr)    theErr = paramErr;    cleanup:  return theErr;}/*****************************************************************************DeleteCollectionFromList  This routine removes the collection from the list.  If the list is then empty,it disposes of the handle.  If an error occurs, the list is left in an indeterminate state.*****************************************************************************/OSStatus DeleteCollectionFromList (UInt32 index){  OSStatus theErr = noErr;  #if qDebugging  if ((index &lt; 0) || (index &gt; gNumberCollections-1))    SIGNAL_ERROR (&quot;\pError: Attempted to delete outside of the list.&quot;)#endif    gNumberCollections--;    //  slide remaining elements up    BlockMoveData(  (*(TGraphicCollection ***)gCollectionList)+index+1,          (*(TGraphicCollection ***)gCollectionList)+index,          (gNumberCollections - index) * sizeof(TGraphicCollection *));  //  Shrink the handle    if (gNumberCollections&gt; 0)  {    SetHandleSize((Handle) gCollectionList,gNumberCollections*sizeof(TGraphicCollection *));    theErr = MemError();    FAIL_OSERR (theErr, &quot;\pCouldn't resize the list handle&quot;)    FAIL_NIL (gCollectionList, &quot;\pCouldn't resize the list handle&quot;)  }  else  {    DisposeHandle (gCollectionList);    gCollectionList = NULL;  }    // We succeeded, cleanup and exit.  goto cleanup;error:  if (theErr == noErr)    theErr = paramErr;    cleanup:  return theErr;}/*****************************************************************************SearchCollectionList  This routine searches the list for an existing collection with that resID.If it doesn't find one, the index points to where that resID should beinserted into the list.*****************************************************************************/OSStatus SearchCollectionList (SInt16 resID, Boolean *found, UInt32 *index){    OSStatus  theErr = noErr;  UInt32    low = 0;  UInt32    high = gNumberCollections;  UInt32    tempIndex;  SInt16    tempID;  TGraphicCollection *theItem;      while (low &lt; high)  {    tempIndex = (low+high) &gt;&gt; 1;    theItem = (*(TGraphicCollection ***)gCollectionList)[tempIndex];#if qDebugging    FAIL_NIL (theItem, &quot;\pBad TGraphic object&quot;)#endif    tempID = theItem-&gt;GetResID();    if (resID == tempID)    {      *found = true;      *index = tempIndex;      goto cleanup;    }    else if (resID &lt; tempID)    // element must be below the current index      high = tempIndex;              else    // element must be above the current index.      low = tempIndex+1;  }    // We fell through, so we didn't find the item in the list.    *found = false;  *index = (low+high) &gt;&gt; 1;    goto cleanup;  error:  if (theErr == noErr)    theErr = paramErr;cleanup:  return theErr;}/*****************************************************************************TGraphicCollection::NewCollectionThis uses the list management routines to create and load a TGraphicCollection.*****************************************************************************/TGraphicCollection*TGraphicCollection::NewCollection (SInt16 resID){  OSStatus      theErr = noErr;  UInt32        listIndex;  Boolean       collectionExists;  TGraphicCollection  *newCollection = NULL;    theErr = SearchCollectionList (resID, &amp;collectionExists, &amp;listIndex);  FAIL_OSERR(theErr,&quot;\pError: Failed to search the collection list&quot;)    if (collectionExists)  {    // Bump the reference count on the existing collection.    newCollection = (*(TGraphicCollection ***)gCollectionList)[listIndex];    newCollection-&gt;AddReference();  }  else  {    // create a new collection    newCollection = new TGraphicCollection(resID);    theErr = newCollection-&gt;CreateCollection ();    FAIL_OSERR(theErr,&quot;\pCouldn't create new TGraphicCollection&quot;)    theErr = InsertCollectionIntoList(newCollection, listIndex);    FAIL_OSERR(theErr, &quot;\pCouldn't add new TGraphicCollection to list&quot;)    newCollection-&gt;AddReference();  }    // We succeeded, cleanup and return the collection.  goto cleanup;  error:  if (newCollection != NULL)  {    delete newCollection;    newCollection = NULL;  }  cleanup:    return newCollection;}/*****************************************************************************TGraphicCollection::AddReference*****************************************************************************/voidTGraphicCollection::AddReference (void)   {     fReferenceCount++;   }      /*****************************************************************************TGraphicCollection::DisposeReference*****************************************************************************/void TGraphicCollection::DisposeReference (void){     fReferenceCount--;     if (fReferenceCount == 0)     {       UInt32    listIndex;    Boolean   tableEntry;    OSStatus  theErr;    theErr = SearchCollectionList (fResID, &amp;tableEntry, &amp;listIndex);            FAIL_OSERR (theErr, &quot;\pFailed to search the CollectionList&quot;)    FAIL_FALSE (tableEntry, &quot;\pFailed to find an existing TGraphicCollection in list&quot;)            theErr = DeleteCollectionFromList(listIndex);    FAIL_OSERR (theErr, &quot;\pFailed to delete Collection from the list&quot;)               delete this;     }         error:     return;}   /*****************************************************************************TGraphicCollection::TGraphicCollectionThe constructor just sets a few clean values -- the real work is done later.*****************************************************************************/TGraphicCollection::TGraphicCollection (SInt16 resID){  fResID = resID;  fReferenceCount = 0;  fGraphics = NULL;}/*****************************************************************************TGraphicCollection::~TGraphicCollection  The destructor just disposes of any data and returns.*****************************************************************************/TGraphicCollection::~TGraphicCollection (void){  (void) DestroyCollection();}/*****************************************************************************TGraphicCollection::CreateCollectionWe load the 'SptA' resource, and extract the resource IDs of our TGraphicobjects we want to load.  Assumes those resources are in the currentresource fork.The format of a 'SptA' resource is a 2 byte unsigned integer for the numberof elements in the list, followed by the resource IDs.  In the future, thisshould probably have a version number, so we can change the format.*****************************************************************************/OSStatus TGraphicCollection::CreateCollection(void){  Handle    collectionResource = Get1Resource ('SptA', fResID);  OSStatus  theErr = ResError();  UInt32    loop;    FAIL_OSERR (theErr, &quot;\pResource manager couldn't load the sprite resource&quot;)  FAIL_NIL (collectionResource, &quot;\pResource manager returned a null handle&quot;)    // Find out how many TGraphcs we need to load, and allocate a handle  // to hold the TGraphic pointers.    fNumberOfGraphics = *((SInt16 *) (*collectionResource));  fGraphics = NewHandleClear (fNumberOfGraphics * sizeof (TGraphic *));  FAIL_NIL (fGraphics, &quot;\pCouldn't allocate collection handle&quot;)  // Load each of the TGraphics.    HLock (fGraphics);    for (loop = 1; loop &lt;= fNumberOfGraphics; loop++)  {    SInt16  graphicResID = *((SInt16 *) ((*collectionResource)+sizeof (SInt16)*loop));    TGraphic *theGraphic = TGraphic::NewGraphic (graphicResID);    FAIL_NIL (theGraphic, &quot;\pFailed to load graphic for collection&quot;)        *((*(TGraphic ***)fGraphics)+loop-1) = theGraphic;  }  HUnlock (fGraphics);    goto cleanup;  error:  if (theErr == noErr)    theErr = paramErr;    // We didn't explictly destroy the collection if an error occured, because  // the object will be deleted anyway.cleanup:  if (collectionResource != NULL)    ReleaseResource (collectionResource);    return theErr;}/*****************************************************************************TGraphicCollection::DestroyCollection  Throw away all of the objects that we're created.  We do check for null TGraphic objects here,and properly skip null objects that might not have been finished from the create calls.*****************************************************************************/OSStatusTGraphicCollection::DestroyCollection (void){  UInt32 loop;    if (fGraphics)  {    HLock (fGraphics);    for (loop = 0; loop &lt; fNumberOfGraphics ; loop++)    {          TGraphic *theGraphic = *((*(TGraphic ***)fGraphics)+loop);      if (theGraphic != NULL)        theGraphic-&gt;DisposeReference();    }    DisposeHandle (fGraphics);    fGraphics = NULL;  }  return noErr;}/*****************************************************************************TGraphicCollection::LockCollection*****************************************************************************/OSStatusTGraphicCollection::LockCollection (void){  UInt32    loop;  OSStatus  theErr = noErr;    MoveHHi (fGraphics);  theErr = MemError();  FAIL_OSERR (theErr, &quot;\pCouldn't move fGraphics handle high&quot;)  HLock (fGraphics);  theErr = MemError();  FAIL_OSERR (theErr, &quot;\pCouldn't lock fGraphics handle&quot;)    TGraphic **ptrToGraphics = (TGraphic **) *fGraphics;    for (loop = 0; loop &lt; fNumberOfGraphics ; loop++)  {    TGraphic *theGraphic = *ptrToGraphics++;    theGraphic-&gt;LockGraphic();  }    return noErr;    error:  return theErr;}/*****************************************************************************TGraphicCollection::UnlockCollection*****************************************************************************/OSStatusTGraphicCollection::UnlockCollection (void){  UInt32 loop;  OSStatus theErr = noErr;    // Should still be locked from the lock collection call.  We should do some testing  // to make sure we aren't locking and unlocking things multiple times here.  TGraphic **ptrToGraphics = (TGraphic **) *fGraphics;    for (loop = 0; loop &lt; fNumberOfGraphics ; loop++)  {    TGraphic *theGraphic = *ptrToGraphics++;    theGraphic-&gt;UnlockGraphic();  }    HUnlock (fGraphics);  theErr = MemError();  FAIL_OSERR (theErr, &quot;\pCouldn't unlock fGraphics handle&quot;)    return noErr;    error:  return theErr;}/*****************************************************************************TGraphicCollection::GetBounds*****************************************************************************/RectTGraphicCollection::GetBounds (UInt32 index){  TGraphic *theGraphic;#if qDebugging  if  (index &gt;= fNumberOfGraphics)    // We're outside of the bounds of the graphics table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TGraphic that was out of bounds&quot;);#endif  theGraphic = *((*(TGraphic ***)fGraphics)+index);#if qDebugging  if (theGraphic == NULL)      SIGNAL_ERROR(&quot;\pRetrieved a null TGRAPHIC object&quot;)#endif    return (theGraphic-&gt;GetBounds ());#if qDebugging  error:  Rect theRect = {0,0,0,0};  return theRect;#endif}/*****************************************************************************TGraphicCollection::CopyImage*****************************************************************************/voidTGraphicCollection::CopyImage (UInt32 index, SInt32 top, SInt32 left, Boolean useBackground){  TGraphic *theGraphic;#if qDebugging  if  (index &gt;= fNumberOfGraphics)    // We're outside of the bounds of the graphics table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TGraphic that was out of bounds&quot;);#endif  theGraphic = *((*(TGraphic ***)fGraphics)+index);#if qDebugging  if (theGraphic == NULL)      SIGNAL_ERROR(&quot;\pRetrieved a null TGRAPHIC object&quot;)#endif    theGraphic-&gt;CopyImage(top, left, useBackground);  error:  return;}/*****************************************************************************  TGraphicCollection::HitTest*****************************************************************************/BooleanTGraphicCollection::HitTest (UInt32 index, SInt32 v, SInt32 h){  TGraphic *theGraphic;#if qDebugging  if  (index &gt;= fNumberOfGraphics)    // We're outside of the bounds of the graphics table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TGraphic that was out of bounds&quot;);#endif  theGraphic = *((*(TGraphic ***)fGraphics)+index);#if qDebugging  if (theGraphic == NULL)      SIGNAL_ERROR(&quot;\pRetrieved a null TGRAPHIC object&quot;)#endif    return theGraphic-&gt;HitTest (v, h);  error:  return false;}/*****************************************************************************TGraphicCollection::GetGraphicObject*****************************************************************************/TGraphic *TGraphicCollection::GetTGraphic (UInt32 index){  TGraphic *theGraphic;#if qDebugging  if  (index &gt;= fNumberOfGraphics)    // We're outside of the bounds of the graphics table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TGraphic that was out of bounds&quot;);#endif  theGraphic = *((*(TGraphic ***)fGraphics)+index);#if qDebugging  if (theGraphic == NULL)      SIGNAL_ERROR(&quot;\pRetrieved a null TGRAPHIC object&quot;)#endif    return theGraphic;  error:    return NULL;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoofWarsOld/listing41.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoofWarsOld/listing41.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoofWarsOld/listing41.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>