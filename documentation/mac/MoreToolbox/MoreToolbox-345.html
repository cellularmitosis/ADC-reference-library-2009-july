<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Managing Components</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING345></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-344.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-346.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-333.html"><B>Chapter 6 - Component Manager</B></A> / <A HREF="MoreToolbox-341.html"><B>Creating Components</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING345-0></A>
<H2><A NAME=MARKER-9-116></A><A NAME=MARKER-21-117></A>Managing Components</H2>
 This section discusses the Component Manager routines that help you manage your component. It describes how to register your component and how to allow applications to connect to your component. <P>
<A NAME=HEADING345-2></A>
<H3><A NAME=MARKER-9-118></A>Registering a Component</H3>
 <A NAME=MARKER-21-110></A>Applications must use the services of the Component Manager to find components that meet their needs. Before an application can find a component, however, that component must be registered with the Component Manager. When you register your component, the Component Manager adds the component to its list of available components.<P>
 There are two mechanisms for registering a component with the Component Manager. First, during startup processing, the Component Manager searches the Extensions folder (and all of the folders within the Extensions folder) for files of type <CODE>'thng'</CODE>. If the file contains all the information needed for registration (see <A HREF=#MARKER-9-125>"Creating a Component Resource" on page 6-31</A> for more information on creating a component file), <BR>the Component Manager automatically registers the component stored in the file. Components registered in this manner are registered globally; that is, the component is made available to all applications and other clients.<P>
 Second, your application (or another application) can register your component. When you register your component in this manner, you can specify whether the component should be made available to all applications (global registration) or only to your application (local registration). Your application can register a component that is in memory or that is stored in a resource. You use the <CODE>RegisterComponent</CODE> function to register a component that is in memory. You use the <CODE>RegisterComponentResource</CODE> function to register a component that is stored in a component resource. See <A HREF=MoreToolbox-400.html#MARKER-9-396>"The Component Resource" on page 6-77</A> for a description of the format and content of component resources. The code in <A HREF=#MARKER-9-122>Listing 6-14</A> demonstrates how an application can use the <CODE>RegisterComponent</CODE> function to register a component that is in memory. <A NAME=MARKER-2-119></A><A NAME=MARKER-2-121></A><P>
<B>Listing 6-14  <A NAME=MARKER-9-122></A><A NAME=MARKER-21-123></A>Registering a component</B><P>
<PRE>
VAR
   cd:      ComponentDescription;
   draw:    Component;

   WITH cd DO
   BEGIN          {initialize the component description record}
      componentType := 'draw';
      componentSubtype := 'oval';
      componentManufacturer := 'appl';
      componentFlags := 0;
      componentFlagsMask := 0;
   END;
   {register the component}
   draw := RegisterComponent(cd, ComponentRoutine(@OvalDrawer),
                             0, NIL, NIL, NIL);
</PRE>
 The code in <A HREF=#MARKER-9-122>Listing 6-14</A> specifies six parameters to the <CODE>RegisterComponent</CODE> <BR>function. The first three are a component description record, a pointer to the component's entry point, and a value of 0 to indicate that this component should be made available only to this application. A component that is registered locally is visible only within the A5 world of the registering program. The last three parameters are specified as <CODE>NIL</CODE> to indicate that the component doesn't have a name, an information string, or an icon. See <A HREF=MoreToolbox-368.html#MARKER-9-279>page 6-55</A> for more information on the <CODE>RegisterComponent</CODE> function.<P>
 When a component is registered and the <CODE>cmpWantsRegisterMessage</CODE> bit is not set in the <CODE>componentFlags</CODE> field of the component description record, the Component Manager adds the component to its list of registered components. Whenever a client requests access to or information about a component (for example, by using <CODE>OpenDefaultComponent</CODE>, <CODE>FindNextComponent</CODE>, or <CODE>GetComponentInfo</CODE>), the Component Manager searches its list of registered components.<P>
 If a component's <CODE>cmpWantsRegisterMessage</CODE> bit is set, the Component Manager does not automatically add your component to its list of registered components. Instead, it sends your component a series of three requests: open, register, and close. If your component returns a nonzero value as its function result in response to the register request, your component is not added to the Component Manager's list of registered components. Thus, clients are not able to connect to or get information about <BR>your component. You might choose to set the <CODE>cmpWantsRegisterMessage</CODE> bit if, for example, your application requires specific hardware.<P>
 Alternatively, you can let your component be automatically registered. Your component can then check for any specific hardware requirements upon receiving an open request. This lets clients attempt to connect to your component and also lets them get information about your component. However, in most cases, if your component requires specific hardware to operate, you should set the <CODE>cmpWantsRegisterMessage</CODE> bit and respond to the register request appropriately.<P>
 If your component controls a hardware resource, you should register your component once for each hardware resource that is available (rather than registering once and allowing multiple instances of your component). This allows clients to easily determine how many hardware resources are available by using the <CODE>FindNextComponent</CODE> function. If you register a component multiple times, be sure that you specify a unique name for each registration.<P>
 If the feature is available, you can request that the Component Manager provide automatic version control for your component (this feature is available only in version 3 and above of the manager). To request automatic version control, specify the <CODE>componentDoAutoVersion</CODE> flag in the optional extension to the component resource. If you specify this flag, the Component Manager registers your component only if there is no later version available. If an older version is already registered, the Component Manager unregisters it. If a newer version of the same component is registered after yours, the Component Manager automatically unregisters your component. You can use this automatic version control feature to make sure that the most recent version of your component is registered, regardless of the number of versions that are installed.<A NAME=MARKER-2-328></A><P>
<A NAME=HEADING345-14></A>
<H3><A NAME=MARKER-9-125></A>Creating a Component Resource</H3>
 <A NAME=MARKER-9-98></A><A NAME=MARKER-2-124></A><A NAME=MARKER-2-35></A>You can create a component resource (a resource of type <CODE>'thng'</CODE>) in a component file. A component file is a file whose resource fork contains a component resource and other required resources for the component. If you store your component in a component file, either you can allow applications to use the <CODE>RegisterComponentResource</CODE> function to register your component as needed, or you can automatically register your component at startup by storing your component file in the Extensions folder. <P>
 A component file consists of<P>
<UL>
<LI> a component description record that specifies the characteristics of your component (its type, subtype, manufacturer, and control flags) 
<LI>the resource type and resource ID of your component's code resource
<LI>the resource type and resource ID of your component's name string
<LI>the resource type and resource ID of your component's information string
<LI>the resource type and resource ID of your component's icon
<LI>optional information about the component (its version number, additional flags, and resource ID of the component's icon family)
<LI>the actual resources for your component's code, name, information string, and icon<P>
</UL>
 <A NAME=MARKER-2-43></A><A HREF=MoreToolbox-345.html#MARKER-9-122>Listing 6-15</A> shows, in Rez format, a component resource that defines an oval drawing component. This drawing component does not specify optional information (see <BR><A HREF=MoreToolbox-400.html#MARKER-9-412>Figure 6-5 on page 6-81</A> for the contents of the optional extension to the component resource). For compatibility with early versions of the Component Manager, <BR>component resources should be locked. <P>
<B>Listing 6-15  <A NAME=MARKER-9-1></A>Rez input for a component resource</B><P>
<PRE>
resource 'thng' (128, locked) {
   'draw',        /*component type*/
   'oval',        /*component subtype*/
   'appl',        /*component manufacturer*/
   $00000000,     /*component flags: 0*/
   $00000000,     /*reserved (component flags mask): 0*/
   'CODE',        /*component code resource type*/
   128,           /*component code resource ID*/
   'STR ',        /*component name resource type*/
   128,           /*component name resource ID*/
   'STR ',        /*component info resource type*/
   129,           /*component info resource ID*/
   'ICON',        /*component icon resource type*/
   128            /*component icon resource ID*/
   /*optional information (if any) goes here*/
};
</PRE>
 The component resource, and the resources that define the component's code, name, information string, and icon, must be in the same file. A component file must have the file type <CODE>'thng'</CODE> and reside in the Extensions folder in order to be automatically registered by the Component Manager at startup. <A NAME=MARKER-21-258></A><A NAME=MARKER-2-15></A><A NAME=MARKER-2-57></A><A NAME=MARKER-9-106></A><P>
<A NAME=HEADING345-28></A>
<H3><A NAME=MARKER-9-136></A>Establishing and Managing Connections</H3>
 Your component may support one or more connections at a time. In addition, a single application may have open connections with two or more different components at the same time. In fact, a single application can use more than one connection to a single component. <A HREF=#MARKER-9-137>Figure 6-2</A> shows two applications and two components: the first application, SurfPaint, uses two connections to component A; the second application, SurfWriter, uses one connection to component A and one to component B. <P>
<B>Figure 6-2  <A NAME=MARKER-9-137></A><A NAME=MARKER-21-138></A>Supporting multiple component connections</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-02.jpg">
 A component can allocate separate storage for each open connection. A component can also set the A5 world for a specific component instance and can maintain separate error information for each instance. A component can also use a reference constant value to maintain global data for the component.<P>
 When an application requests that the Component Manager open a connection to your component, the Component Manager issues an open request to your component. At this time, your component should allocate any memory it needs in order to maintain a connection for the requesting application. Be sure to allocate this memory in the current heap zone rather than in the system heap. As described in <A HREF=MoreToolbox-343.html#MARKER-9-63>"Responding to the Open Request" on page 6-18</A>, you can use the <CODE>SetComponentInstanceStorage</CODE> procedure to associate the allocated memory with the component instance. Whenever the application requests services from your component, the Component Manager supplies you with the handle to this memory. You can also use the open request as an opportunity to restrict the number of connections your component can support.<P>
 To allocate global data for your component, you can maintain a reference constant for use by your component. The Component Manager provides two routines, <CODE>SetComponentRefcon</CODE> and <CODE>GetComponentRefcon</CODE>, that allow you to work with your component's reference constant. Note that your component has one reference constant, regardless of the number of connections maintained by your component. <A NAME=MARKER-2-276></A><A NAME=MARKER-9-238></A><P>
 If your component uses its reference constant and is registered globally, be aware that in certain situations the Component Manager may clone your component. This situation occurs only when the Component Manager opens a component that is registered globally and there's no available space in the system heap. In this case, the Component Manager clones your component, creating a new registration of the component in the caller's heap, and returns to the caller the component identifier of the cloned component, not the component identifier of the original registration. The reference constant of the original component is not preserved in the cloned component. Thus you need to take extra steps to set the reference constant of the cloned component to the same value as that of the original component.<A NAME=MARKER-2-141></A><A NAME=MARKER-2-142></A><P>
 To determine whether your component has been cloned, you can examine your component's A5 world using the <CODE>GetComponentInstanceA5</CODE> function. If the returned value of the A5 world is nonzero, your component is cloned (only components registered globally can be cloned; if your component is registered locally it has a valid, nonzero A5 world and you don't need to check whether it's been cloned). If you determine that your component is cloned, you can retrieve the original reference constant by using the <CODE>FindNextComponent</CODE> function to iterate through all registrations of your component. You should compare the component identifier of the cloned component with the component identifier returned by <CODE>FindNextComponent</CODE>. Once you find a component with the same component description but a different component identifier, you've found the original component. You can then use <CODE>GetComponentRefcon</CODE> to get the reference constant of the original component and then use <CODE>SetComponentRefcon</CODE> to set the reference constant of the cloned component appropriately. This technique works if a component registers itself only once or registers itself multiple times but with a unique name for each registration. This technique does not work if a component registers itself multiple times using the same name.<P>
 When responding to a request from an application, your component can invoke the services of other components. The Component Manager provides two techniques for calling other components. First, your component can call another component using the standard mechanisms also used by applications. The Component Manager then passes the requests to the appropriate component, and your component receives the results of those requests.<P>
 Second, your component can redirect a request to another component. For example, you might want to create two similar components that provide different levels of service to applications. Rather than completely implementing both components, you could design one to rely on the capabilities of the other. Use the <CODE>DelegateComponentCall</CODE> function to pass a request on to another component.<A NAME=MARKER-2-342></A><A NAME=MARKER-2-40></A><P>
 <A HREF=#MARKER-9-146>Listing 6-16</A> shows an example of delegating a request to another component. The component in this example is a drawing component that draws rectangles. The <CODE>RectangleDrawer</CODE> component handles open, close, and setup requests. It delegates all other requests to another component. When the <CODE>RectangleDrawer</CODE> component receives an open request, it opens the component to which it will later delegate requests, and stores in its allocated storage the delegated component's component instance. It then specifies this value when it calls the <CODE>DelegateComponentCall</CODE> function.<A NAME=MARKER-2-262></A><P>
<B>Listing 6-16  <A NAME=MARKER-9-146></A>Delegating a request to another component</B><P>
<PRE>
FUNCTION RectangleDrawer(params: ComponentParameters; 
                         storage: Handle): ComponentResult; 
VAR
   theRtn:  ComponentRoutine;
   safe:    Boolean;
BEGIN
   safe := FALSE;
   CASE (params.what) OF
      kComponentOpenSelect:
         theRtn := ComponentRoutine(@RectangleOpen);
      kComponentCloseSelect:
         theRtn := ComponentRoutine(@RectangleClose);
      kDrawerSetupSelect:
         theRtn := ComponentRoutine(@RectangleSetup);
      OTHERWISE
      BEGIN
         safe := TRUE;
         IF (storage &lt;&gt; NIL) THEN
            RectangleDrawer := 
               DelegateComponentCall
                  (params,
                   ComponentInstance(StorageHdl(storage)^^.delegateInstance))
         ELSE
            RectangleDrawer := badComponentSelector;
      END;
   END; {of CASE}
   IF NOT safe THEN
      RectangleDrawer := 
         CallComponentFunctionWithStorage(storage, params, theRtn);
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-344.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-346.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
