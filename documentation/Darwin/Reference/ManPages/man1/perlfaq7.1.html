<html><head><title>Mac OS X
 Manual Page For perlfaq7(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlfaq7" title="Mac OS X
 Manual Page for perlfaq7(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlfaq7"; name=perlfaq7(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLFAQ7(1)                           Perl Programmers Reference Guide                           PERLFAQ7(1)



<b>NAME</b>
       perlfaq7 - General Perl Language Issues ($Revision: 1.28 $, $Date: 2005/12/31 00:54:37 $)

<b>DESCRIPTION</b>
       This section deals with general Perl language issues that don't clearly fit into any of the other
       sections.

       <b>Can</b> <b>I</b> <b>get</b> <b>a</b> <b>BNF/yacc/RE</b> <b>for</b> <b>the</b> <b>Perl</b> <b>language?</b>

       There is no BNF, but you can paw your way through the yacc grammar in perly.y in the source distribu-<font color="#ffffff" class="whiteout">tion&nbsp;distribution</font>
       tion if you're particularly brave.  The grammar relies on very smart tokenizing code, so be prepared
       to venture into toke.c as well.

       In the words of Chaim Frenkel: "Perl's grammar can not be reduced to BNF.  The work of parsing perl
       is distributed between yacc, the lexer, smoke and mirrors."

       <b>What</b> <b>are</b> <b>all</b> <b>these</b> <b>$@%&amp;*</b> <b>punctuation</b> <b>signs,</b> <b>and</b> <b>how</b> <b>do</b> <b>I</b> <b>know</b> <b>when</b> <b>to</b> <b>use</b> <b>them?</b>

       They are type specifiers, as detailed in perldata:

           $ for scalar values (number, string or reference)
           @ for arrays
           % for hashes (associative arrays)
           &amp; for subroutines (aka functions, procedures, methods)
           * for all types of that symbol name.  In version 4 you used them like
             pointers, but in modern perls you can just use references.

       There are couple of other symbols that you're likely to encounter that aren't really type specifiers:

           &lt;&gt; are used for inputting a record from a filehandle.
           \  takes a reference to something.

       Note that &lt;FILE&gt; is <u>neither</u> the type specifier for files nor the name of the handle.  It is the "&lt;&gt;"
       operator applied to the handle FILE.  It reads one line (well, record--see "$/" in perlvar) from the
       handle FILE in scalar context, or <u>all</u> lines in list context.  When performing open, close, or any
       other operation besides "&lt;&gt;" on files, or even when talking about the handle, do <u>not</u> use the brack-<font color="#ffffff" class="whiteout">ets.&nbsp;brackets.</font>
       ets.  These are correct: "eof(FH)", "seek(FH, 0, 2)" and "copying from STDIN to FILE".

       <b>Do</b> <b>I</b> <b>always/never</b> <b>have</b> <b>to</b> <b>quote</b> <b>my</b> <b>strings</b> <b>or</b> <b>use</b> <b>semicolons</b> <b>and</b> <b>commas?</b>

       Normally, a bareword doesn't need to be quoted, but in most cases probably should be (and must be
       under "use strict").  But a hash key consisting of a simple word (that isn't the name of a defined
       subroutine) and the left-hand operand to the "=&gt;" operator both count as though they were quoted:

           This                    is like this
           ------------            ---------------<font color="#ffffff" class="whiteout">$foo{line}&nbsp;--------------$foo{line}</font>
           $foo{line}              $foo{'line'}
           bar =&gt; stuff            'bar' =&gt; stuff

       The final semicolon in a block is optional, as is the final comma in a list.  Good style (see perl-<font color="#ffffff" class="whiteout">style)&nbsp;perlstyle)</font>
       style) says to put them in except for one-liners:

           if ($whoops) { exit 1 }
           @nums = (1, 2, 3);

           if ($whoops) {
               exit 1;
           }
           @lines = (
               "There Beren came from mountains cold",
               "And lost he wandered under leaves",
           );

       <b>How</b> <b>do</b> <b>I</b> <b>skip</b> <b>some</b> <b>return</b> <b>values?</b>

       One way is to treat the return values as a list and index into it:

               $dir = (getpwnam($user))[7];

       Another way is to use undef as an element on the left-hand-side:

           ($dev, $ino, undef, undef, $uid, $gid) = stat($file);

       You can also use a list slice to select only the elements that you need:

               ($dev, $ino, $uid, $gid) = ( stat($file) )[0,1,4,5];

       <b>How</b> <b>do</b> <b>I</b> <b>temporarily</b> <b>block</b> <b>warnings?</b>

       If you are running Perl 5.6.0 or better, the "use warnings" pragma allows fine control of what warn-<font color="#ffffff" class="whiteout">ing&nbsp;warning</font>
       ing are produced.  See perllexwarn for more details.

           {
               no warnings;          # temporarily turn off warnings
               $a = $b + $c;         # I know these might be undef
           }

       Additionally, you can enable and disable categories of warnings.  You turn off the categories you
       want to ignore and you can still get other categories of warnings.  See perllexwarn for the complete
       details, including the category names and hierarchy.

               {
               no warnings 'uninitialized';
               $a = $b + $c;
               }

       If you have an older version of Perl, the $^W variable (documented in perlvar) controls runtime warn-<font color="#ffffff" class="whiteout">ings&nbsp;warnings</font>
       ings for a block:

           {
               local $^W = 0;        # temporarily turn off warnings
               $a = $b + $c;         # I know these might be undef
           }

       Note that like all the punctuation variables, you cannot currently use <u>my()</u> on $^W, only <u>local()</u>.

       <b>What's</b> <b>an</b> <b>extension?</b>

       An extension is a way of calling compiled C code from Perl.  Reading perlxstut is a good place to
       learn more about extensions.

       <b>Why</b> <b>do</b> <b>Perl</b> <b>operators</b> <b>have</b> <b>different</b> <b>precedence</b> <b>than</b> <b>C</b> <b>operators?</b>

       Actually, they don't.  All C operators that Perl copies have the same precedence in Perl as they do
       in C.  The problem is with operators that C doesn't have, especially functions that give a list con-<font color="#ffffff" class="whiteout">text&nbsp;context</font>
       text to everything on their right, eg. print, chmod, exec, and so on.  Such functions are called
       "list operators" and appear as such in the precedence table in perlop.

       A common mistake is to write:

           unlink $file || die "snafu";

       This gets interpreted as:

           unlink ($file || die "snafu");

       To avoid this problem, either put in extra parentheses or use the super low precedence "or" operator:

           (unlink $file) || die "snafu";
           unlink $file or die "snafu";

       The "English" operators ("and", "or", "xor", and "not") deliberately have precedence lower than that
       of list operators for just such situations as the one above.

       Another operator with surprising precedence is exponentiation.  It binds more tightly even than unary
       minus, making "-2**2" product a negative not a positive four.  It is also right-associating, meaning
       that "2**3**2" is two raised to the ninth power, not eight squared.

       Although it has the same precedence as in C, Perl's "?:" operator produces an lvalue.  This assigns
       $x to either $a or $b, depending on the trueness of $maybe:

           ($maybe ? $a : $b) = $x;

       <b>How</b> <b>do</b> <b>I</b> <b>declare/create</b> <b>a</b> <b>structure?</b>

       In general, you don't "declare" a structure.  Just use a (probably anonymous) hash reference.  See
       perlref and perldsc for details.  Here's an example:

           $person = {};                   # new anonymous hash
           $person-&gt;{AGE}  = 24;           # set field AGE to 24
           $person-&gt;{NAME} = "Nat";        # set field NAME to "Nat"

       If you're looking for something a bit more rigorous, try perltoot.

       <b>How</b> <b>do</b> <b>I</b> <b>create</b> <b>a</b> <b>module?</b>

       (contributed by brian d foy)

       perlmod, perlmodlib, perlmodstyle explain modules in all the gory details. perlnewmod gives a brief
       overview of the process along with a couple of suggestions about style.

       If you need to include C code or C library interfaces in your module, you'll need h2xs.  h2xs will
       create the module distribution structure and the initial interface files you'll need.  perlxs and
       perlxstut explain the details.

       If you don't need to use C code, other tools such as ExtUtils::ModuleMaker and Module::Starter, can
       help you create a skeleton module distribution.

       You may also want to see Sam Tregar's "Writing Perl Modules for CPAN" (
       <a href="http://apress.com/book/bookDisplay.html?bID=14">http://apress.com/book/bookDisplay.html?bID=14</a> ) which is the best hands-on guide to creating module
       distributions.

       <b>How</b> <b>do</b> <b>I</b> <b>create</b> <b>a</b> <b>class?</b>

       See perltoot for an introduction to classes and objects, as well as perlobj and perlbot.

       <b>How</b> <b>can</b> <b>I</b> <b>tell</b> <b>if</b> <b>a</b> <b>variable</b> <b>is</b> <b>tainted?</b>

       You can use the <u>tainted()</u> function of the Scalar::Util module, available from CPAN (or included with
       Perl since release 5.8.0).  See also "Laundering and Detecting Tainted Data" in perlsec.

       <b>What's</b> <b>a</b> <b>closure?</b>

       Closures are documented in perlref.

       <u>Closure</u> is a computer science term with a precise but hard-to-explain meaning. Closures are imple-
       mented in Perl as anonymous subroutines with lasting references to lexical variables outside their
       own scopes.  These lexicals magically refer to the variables that were around when the subroutine was
       defined (deep binding).

       Closures make sense in any programming language where you can have the return value of a function be
       itself a function, as you can in Perl.  Note that some languages provide anonymous functions but are
       not capable of providing proper closures: the Python language, for example.  For more information on
       closures, check out any textbook on functional programming.  Scheme is a language that not only sup-
       ports but encourages closures.

       Here's a classic function-generating function:

           sub add_function_generator {
             return sub { shift() + shift() };
           }

           $add_sub = add_function_generator();
           $sum = $add_sub-&gt;(4,5);                # $sum is 9 now.

       The closure works as a <u>function</u> <u>template</u> with some customization slots left out to be filled later.
       The anonymous subroutine returned by <u>add</u><b>_</b><u>function</u><b>_</b><u>generator()</u> isn't technically a closure because it
       refers to no lexicals outside its own scope.

       Contrast this with the following <u>make</u><b>_</b><u>adder()</u> function, in which the returned anonymous function con-
       tains a reference to a lexical variable outside the scope of that function itself.  Such a reference
       requires that Perl return a proper closure, thus locking in for all time the value that the lexical
       had when the function was created.

           sub make_adder {
               my $addpiece = shift;
               return sub { shift() + $addpiece };
           }

           $f1 = <!-- a -->make_adder(20)<!-- /a -->;
           $f2 = <!-- a -->make_adder(555)<!-- /a -->;

       Now "&amp;$f1($n)" is always 20 plus whatever $n you pass in, whereas "&amp;$f2($n)" is always 555 plus what-
       ever $n you pass in.  The $addpiece in the closure sticks around.

       Closures are often used for less esoteric purposes.  For example, when you want to pass in a bit of
       code into a function:

           my $line;
           timeout( 30, sub { $line = &lt;STDIN&gt; } );

       If the code to execute had been passed in as a string, '$line = &lt;STDIN&gt;', there would have been no
       way for the hypothetical <u>timeout()</u> function to access the lexical variable $line back in its caller's
       scope.

       <b>What</b> <b>is</b> <b>variable</b> <b>suicide</b> <b>and</b> <b>how</b> <b>can</b> <b>I</b> <b>prevent</b> <b>it?</b>

       This problem was fixed in perl 5.004_05, so preventing it means upgrading your version of perl. ;)

       Variable suicide is when you (temporarily or permanently) lose the value of a variable.  It is caused
       by scoping through <u>my()</u> and <u>local()</u> interacting with either closures or aliased <u>foreach()</u> iterator
       variables and subroutine arguments.  It used to be easy to inadvertently lose a variable's value this
       way, but now it's much harder.  Take this code:

           my $f = 'foo';
           sub T {
             while ($i++ &lt; 3) { my $f = $f; $f .= $i; print $f, "\n" }
           }
           T;
           print "Finally $f\n";

       If you are experiencing variable suicide, that "my $f" in the subroutine doesn't pick up a fresh copy
       of the $f whose value is &lt;foo&gt;. The output shows that inside the subroutine the value of $f leaks
       through when it shouldn't, as in this output:

               foobar
               foobarbar
               foobarbarbar
               Finally foo

       The $f that has "bar" added to it three times should be a new $f "my $f" should create a new lexical
       variable each time through the loop.  The expected output is:

               foobar
               foobar
               foobar
               Finally foo

       <b>How</b> <b>can</b> <b>I</b> <b>pass/return</b> <b>a</b> <b>{Function,</b> <b>FileHandle,</b> <b>Array,</b> <b>Hash,</b> <b>Method,</b> <b>Regex}?</b>

       With the exception of regexes, you need to pass references to these objects.  See "Pass by Reference"
       in perlsub for this particular question, and perlref for information on references.

       See "Passing Regexes", below, for information on passing regular expressions.

       Passing Variables and Functions
           Regular variables and functions are quite easy to pass: just pass in a reference to an existing
           or anonymous variable or function:

               func( \$some_scalar );

               func( \@some_array  );
               func( [ 1 .. 10 ]   );

               func( \%some_hash   );
               func( { this =&gt; 10, that =&gt; 20 }   );

               func( \&amp;some_func   );
               func( sub { $_[0] ** $_[1] }   );

       Passing Filehandles
           As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other
           scalar.

                   open my $fh, $filename or die "Cannot open $filename! $!";
                   func( $fh );

                   sub func {
                           my $passed_fh = shift;

                           my $line = &lt;$fh&gt;;
                           }

           Before Perl 5.6, you had to use the *FH or "\*FH" notations.  These are "typeglobs"--see "Type-
           globs and Filehandles" in perldata and especially "Pass by Reference" in perlsub for more infor-
           mation.

       Passing Regexes
           To pass regexes around, you'll need to be using a release of Perl sufficiently recent as to sup-
           port the "qr//" construct, pass around strings and use an exception-trapping eval, or else be
           very, very clever.

           Here's an example of how to pass in a string to be regex compared using "qr//":

               sub compare($$) {
                   my ($val1, $regex) = @_;
                   my $retval = $val1 =~ /$regex/;
                   return $retval;
               }
               $match = compare("old McDonald", qr/d.*D/i);

           Notice how "qr//" allows flags at the end.  That pattern was compiled at compile time, although
           it was executed later.  The nifty "qr//" notation wasn't introduced until the 5.005 release.
           Before that, you had to approach this problem much less intuitively.  For example, here it is
           again if you don't have "qr//":

               sub compare($$) {
                   my ($val1, $regex) = @_;
                   my $retval = eval { $val1 =~ /$regex/ };
                   die if $@;
                   return $retval;
               }

               $match = compare("old McDonald", q/($?i)d.*D/);

           Make sure you never say something like this:

               return eval "\$val =~ /$regex/";   # WRONG

           or someone can sneak shell escapes into the regex due to the double interpolation of the eval and
           the double-quoted string.  For example:

               $pattern_of_evil = 'danger ${ system("rm -rf * &amp;") } danger';

               eval "\$string =~ /$pattern_of_evil/";

           Those preferring to be very, very clever might see the O'Reilly book, <u>Mastering</u> <u>Regular</u> <u>Expres</u>-
           <u>sions</u>, by Jeffrey Friedl.  Page 273's <u>Build</u><b>_</b><u>MatchMany</u><b>_</b><u>Function()</u> is particularly interesting.  A
           complete citation of this book is given in perlfaq2.

       Passing Methods
           To pass an object method into a subroutine, you can do this:

               call_a_lot(10, $some_obj, "methname")
               sub call_a_lot {
                   my ($count, $widget, $trick) = @_;
                   for (my $i = 0; $i &lt; $count; $i++) {
                       $widget-&gt;$trick();
                   }
               }

           Or, you can use a closure to bundle up the object, its method call, and arguments:

               my $whatnot =  sub { $some_obj-&gt;obfuscate(@args) };
               func($whatnot);
               sub func {
                   my $code = shift;
                   &amp;$code();
               }

           You could also investigate the <u>can()</u> method in the UNIVERSAL class (part of the standard perl
           distribution).

       <b>How</b> <b>do</b> <b>I</b> <b>create</b> <b>a</b> <b>static</b> <b>variable?</b>

       (contributed by brian d foy)

       Perl doesn't have "static" variables, which can only be accessed from the function in which they are
       declared. You can get the same effect with lexical variables, though.

       You can fake a static variable by using a lexical variable which goes out of scope. In this example,
       you define the subroutine "counter", and it uses the lexical variable $count. Since you wrap this in
       a BEGIN block, $count is defined at compile-time, but also goes out of scope at the end of the BEGIN
       block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-
       time so the subroutine is ready to use just like any other subroutine, and you can put this code in
       the same place as other subroutines in the program text (i.e. at the end of the code, typically). The
       subroutine "counter" still has a reference to the data, and is the only way you can access the value
       (and each time you do, you increment the value).  The data in chunk of memory defined by $count is
       private to "counter".

           BEGIN {
               my $count = 1;
               sub counter { $count++ }
           }

           my $start = count();

           .... # code that calls count();

           my $end = count();

       In the previous example, you created a function-private variable because only one function remembered
       its reference. You could define multiple functions while the variable is in scope, and each function
       can share the "private" variable. It's not really "static" because you can access it outside the
       function while the lexical variable is in scope, and even create references to it. In this example,
       "increment_count" and "return_count" share the variable. One function adds to the value and the other
       simply returns the value.  They can both access $count, and since it has gone out of scope, there is
       no other way to access it.

           BEGIN {
               my $count = 1;
               sub increment_count { $count++ }
               sub return_count    { $count }
           }

       To declare a file-private variable, you still use a lexical variable.  A file is also a scope, so a
       lexical variable defined in the file cannot be seen from any other file.

       See "Persistent Private Variables" in perlsub for more information.  The discussion of closures in
       perlref may help you even though we did not use anonymous subroutines in this answer. See "Persistent
       Private Variables" in perlsub for details.

       <b>What's</b> <b>the</b> <b>difference</b> <b>between</b> <b>dynamic</b> <b>and</b> <b>lexical</b> <b>(static)</b> <b>scoping?</b>  <b>Between</b> <u>local()</u> <b>and</b> <u>my()</u><b>?</b>

       "local($x)" saves away the old value of the global variable $x and assigns a new value for the dura-
       tion of the subroutine <u>which</u> <u>is</u> <u>visible</u> <u>in</u> <u>other</u> <u>functions</u> <u>called</u> <u>from</u> <u>that</u> <u>subroutine</u>.  This is done
       at run-time, so is called dynamic scoping.  <u>local()</u> always affects global variables, also called
       package variables or dynamic variables.

       "my($x)" creates a new variable that is only visible in the current subroutine.  This is done at com-
       pile-time, so it is called lexical or static scoping.  <u>my()</u> always affects private variables, also
       called lexical variables or (improperly) static(ly scoped) variables.

       For instance:

           sub visible {
               print "var has value $var\n";
           }

           sub dynamic {
               local $var = 'local';   # new temporary value for the still-global
               visible();              #   variable called $var
           }

           sub lexical {
               my $var = 'private';    # new private variable, $var
               visible();              # (invisible outside of sub scope)
           }

           $var = 'global';

           visible();                  # prints global
           dynamic();                  # prints local
           lexical();                  # prints global

       Notice how at no point does the value "private" get printed.  That's because $var only has that value
       within the block of the <u>lexical()</u> function, and it is hidden from called subroutine.

       In summary, <u>local()</u> doesn't make what you think of as private, local variables.  It gives a global
       variable a temporary value.  <u>my()</u> is what you're looking for if you want private variables.

       See "Private Variables via <u>my()</u>" in perlsub and "Temporary Values via <u>local()</u>" in perlsub for excru-
       ciating details.

       <b>How</b> <b>can</b> <b>I</b> <b>access</b> <b>a</b> <b>dynamic</b> <b>variable</b> <b>while</b> <b>a</b> <b>similarly</b> <b>named</b> <b>lexical</b> <b>is</b> <b>in</b> <b>scope?</b>

       If you know your package, you can just mention it explicitly, as in $Some_Pack::var. Note that the
       notation $::var is <b>not</b> the dynamic $var in the current package, but rather the one in the "main"
       package, as though you had written $main::var.

               use vars '$var';
               local $var = "global";
               my    $var = "lexical";

               print "lexical is $var\n";
               print "global  is $main::var\n";

       Alternatively you can use the compiler directive <u>our()</u> to bring a dynamic variable into the current
       lexical scope.

               require 5.006; # our() did not exist before 5.6
               use vars '$var';

               local $var = "global";
               my $var    = "lexical";

               print "lexical is $var\n";

               {
                 our $var;
                 print "global  is $var\n";
               }

       <b>What's</b> <b>the</b> <b>difference</b> <b>between</b> <b>deep</b> <b>and</b> <b>shallow</b> <b>binding?</b>

       In deep binding, lexical variables mentioned in anonymous subroutines are the same ones that were in
       scope when the subroutine was created.  In shallow binding, they are whichever variables with the
       same names happen to be in scope when the subroutine is called.  Perl always uses deep binding of
       lexical variables (i.e., those created with <u>my()</u>).  However, dynamic variables (aka global, local, or
       package variables) are effectively shallowly bound.  Consider this just one more reason not to use
       them.  See the answer to "What's a closure?".

       <b>Why</b> <b>doesn't</b> <b>"my($foo)</b> <b>=</b> <b>&lt;FILE&gt;;"</b> <b>work</b> <b>right?</b>

       "my()" and "local()" give list context to the right hand side of "=".  The &lt;FH&gt; read operation, like
       so many of Perl's functions and operators, can tell which context it was called in and behaves appro-
       priately.  In general, the <u>scalar()</u> function can help.  This function does nothing to the data itself
       (contrary to popular myth) but rather tells its argument to behave in whatever its scalar fashion is.
       If that function doesn't have a defined scalar behavior, this of course doesn't help you (such as
       with <u>sort()</u>).

       To enforce scalar context in this particular case, however, you need merely omit the parentheses:

           local($foo) = &lt;FILE&gt;;           # WRONG
           local($foo) = scalar(&lt;FILE&gt;);   # ok
           local $foo  = &lt;FILE&gt;;           # right

       You should probably be using lexical variables anyway, although the issue is the same here:

           my($foo) = &lt;FILE&gt;;  # WRONG
           my $foo  = &lt;FILE&gt;;  # right

       <b>How</b> <b>do</b> <b>I</b> <b>redefine</b> <b>a</b> <b>builtin</b> <b>function,</b> <b>operator,</b> <b>or</b> <b>method?</b>

       Why do you want to do that? :-)

       If you want to override a predefined function, such as <u>open()</u>, then you'll have to import the new
       definition from a different module.  See "Overriding Built-in Functions" in perlsub.  There's also an
       example in "Class::Template" in perltoot.

       If you want to overload a Perl operator, such as "+" or "**", then you'll want to use the "use over-
       load" pragma, documented in overload.

       If you're talking about obscuring method calls in parent classes, see "Overridden Methods" in perl-
       toot.

       <b>What's</b> <b>the</b> <b>difference</b> <b>between</b> <b>calling</b> <b>a</b> <b>function</b> <b>as</b> <b>&amp;foo</b> <b>and</b> <u>foo()</u><b>?</b>

       When you call a function as &amp;foo, you allow that function access to your current @_ values, and you
       bypass prototypes.  The function doesn't get an empty @_--it gets yours!  While not strictly speaking
       a bug (it's documented that way in perlsub), it would be hard to consider this a feature in most
       cases.

       When you call your function as "&amp;foo()", then you <u>do</u> get a new @_, but prototyping is still circum-
       vented.

       Normally, you want to call a function using "foo()".  You may only omit the parentheses if the func-
       tion is already known to the compiler because it already saw the definition ("use" but not
       "require"), or via a forward reference or "use subs" declaration.  Even in this case, you get a clean
       @_ without any of the old values leaking through where they don't belong.

       <b>How</b> <b>do</b> <b>I</b> <b>create</b> <b>a</b> <b>switch</b> <b>or</b> <b>case</b> <b>statement?</b>

       This is explained in more depth in the perlsyn.  Briefly, there's no official case statement, because
       of the variety of tests possible in Perl (numeric comparison, string comparison, glob comparison,
       regex matching, overloaded comparisons, ...).  Larry couldn't decide how best to do this, so he left
       it out, even though it's been on the wish list since perl1.

       Starting from Perl 5.8 to get switch and case one can use the Switch extension and say:

               use Switch;

       after which one has switch and case.  It is not as fast as it could be because it's not really part
       of the language (it's done using source filters) but it is available, and it's very flexible.

       But if one wants to use pure Perl, the general answer is to write a construct like this:

           for ($variable_to_test) {
               if    (/pat1/)  { }     # do something
               elsif (/pat2/)  { }     # do something else
               elsif (/pat3/)  { }     # do something else
               else            { }     # default
           }

       Here's a simple example of a switch based on pattern matching, this time lined up in a way to make it
       look more like a switch statement.  We'll do a multiway conditional based on the type of reference
       stored in $whatchamacallit:

           SWITCH: for (ref $whatchamacallit) {

               /^$/            &amp;&amp; die "not a reference";

               /SCALAR/        &amp;&amp; do {
                                       print_scalar($$ref);
                                       last SWITCH;
                               };

               /ARRAY/         &amp;&amp; do {
                                       print_array(@$ref);
                                       last SWITCH;
                               };

               /HASH/          &amp;&amp; do {
                                       print_hash(%$ref);
                                       last SWITCH;
                               };

               /CODE/          &amp;&amp; do {
                                       warn "can't print function ref";
                                       last SWITCH;
                               };

               # DEFAULT

               warn "User defined type skipped";

           }

       See "perlsyn/"Basic BLOCKs and Switch Statements"" for many other examples in this style.

       Sometimes you should change the positions of the constant and the variable.  For example, let's say
       you wanted to test which of many answers you were given, but in a case-insensitive way that also
       allows abbreviations.  You can use the following technique if the strings all start with different
       characters or if you want to arrange the matches so that one takes precedence over another, as "SEND"
       has precedence over "STOP" here:

           chomp($answer = &lt;&gt;);
           if    ("SEND"  =~ /^\Q$answer/i) { print "Action is send\n"  }
           elsif ("STOP"  =~ /^\Q$answer/i) { print "Action is stop\n"  }
           elsif ("ABORT" =~ /^\Q$answer/i) { print "Action is abort\n" }
           elsif ("LIST"  =~ /^\Q$answer/i) { print "Action is list\n"  }
           elsif ("EDIT"  =~ /^\Q$answer/i) { print "Action is edit\n"  }

       A totally different approach is to create a hash of function references.

           my %commands = (
               "happy" =&gt; \&amp;joy,
               "sad",  =&gt; \&amp;sullen,
               "done"  =&gt; sub { die "See ya!" },
               "mad"   =&gt; \&amp;angry,
           );

           print "How are you? ";
           chomp($string = &lt;STDIN&gt;);
           if ($commands{$string}) {
               $commands{$string}-&gt;();
           } else {
               print "No such command: $string\n";
           }

       <b>How</b> <b>can</b> <b>I</b> <b>catch</b> <b>accesses</b> <b>to</b> <b>undefined</b> <b>variables,</b> <b>functions,</b> <b>or</b> <b>methods?</b>

       The AUTOLOAD method, discussed in "Autoloading" in perlsub and "AUTOLOAD: Proxy Methods" in perltoot,
       lets you capture calls to undefined functions and methods.

       When it comes to undefined variables that would trigger a warning under "use warnings", you can pro-
       mote the warning to an error.

               use warnings FATAL =&gt; qw(uninitialized);

       <b>Why</b> <b>can't</b> <b>a</b> <b>method</b> <b>included</b> <b>in</b> <b>this</b> <b>same</b> <b>file</b> <b>be</b> <b>found?</b>

       Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or
       the object is of the wrong type.  Check out perltoot for details about any of the above cases.  You
       may also use "print ref($object)" to find out the class $object was blessed into.

       Another possible reason for problems is because you've used the indirect object syntax (eg, "find
       Guru "Samy"") on a class name before Perl has seen that such a package exists.  It's wisest to make
       sure your packages are all defined before you start using them, which will be taken care of if you
       use the "use" statement instead of "require".  If not, make sure to use arrow notation (eg.,
       "Guru-&gt;find("Samy")") instead.  Object notation is explained in perlobj.

       Make sure to read about creating modules in perlmod and the perils of indirect objects in "Method
       Invocation" in perlobj.

       <b>How</b> <b>can</b> <b>I</b> <b>find</b> <b>out</b> <b>my</b> <b>current</b> <b>package?</b>

       If you're just a random program, you can do this to find out what the currently compiled package is:

           my $packname = __PACKAGE__;

       But, if you're a method and you want to print an error message that includes the kind of object you
       were called on (which is not necessarily the same as the one in which you were compiled):

           sub amethod {
               my $self  = shift;
               my $class = ref($self) || $self;
               warn "called me from a $class object";
           }

       <b>How</b> <b>can</b> <b>I</b> <b>comment</b> <b>out</b> <b>a</b> <b>large</b> <b>block</b> <b>of</b> <b>perl</b> <b>code?</b>

       You can use embedded POD to discard it.  Enclose the blocks you want to comment out in POD markers.
       The &lt;=begin&gt; directive marks a section for a specific formatter.  Use the "comment" format, which no
       formatter should claim to understand (by policy).  Mark the end of the block with &lt;=end&gt;.

           # program is here

           =begin comment

           all of this stuff

           here will be ignored
           by everyone

               =end comment

           =cut

           # program continues

       The pod directives cannot go just anywhere.  You must put a pod directive where the parser is expect-
       ing a new statement, not just in the middle of an expression or some other arbitrary grammar produc-
       tion.

       See perlpod for more details.

       <b>How</b> <b>do</b> <b>I</b> <b>clear</b> <b>a</b> <b>package?</b>

       Use this code, provided by Mark-Jason Dominus:

           sub scrub_package {
               no strict 'refs';
               my $pack = shift;
               die "Shouldn't delete main package"
                   if $pack eq "" || $pack eq "main";
               my $stash = *{$pack . '::'}{HASH};
               my $name;
               foreach $name (keys %$stash) {
                   my $fullname = $pack . '::' . $name;
                   # Get rid of everything with that name.
                   undef $$fullname;
                   undef @$fullname;
                   undef %$fullname;
                   undef &amp;$fullname;
                   undef *$fullname;
               }
           }

       Or, if you're using a recent release of Perl, you can just use the <u>Symbol::delete</u><b>_</b><u>package()</u> function
       instead.

       <b>How</b> <b>can</b> <b>I</b> <b>use</b> <b>a</b> <b>variable</b> <b>as</b> <b>a</b> <b>variable</b> <b>name?</b>

       Beginners often think they want to have a variable contain the name of a variable.

           $fred    = 23;
           $varname = "fred";
           ++$$varname;         # $fred now 24

       This works <u>sometimes</u>, but it is a very bad idea for two reasons.

       The first reason is that this technique <u>only</u> <u>works</u> <u>on</u> <u>global</u> <u>variables</u>.  That means that if $fred is
       a lexical variable created with <u>my()</u> in the above example, the code wouldn't work at all: you'd acci-
       dentally access the global and skip right over the private lexical altogether.  Global variables are
       bad because they can easily collide accidentally and in general make for non-scalable and confusing
       code.

       Symbolic references are forbidden under the "use strict" pragma.  They are not true references and
       consequently are not reference counted or garbage collected.

       The other reason why using a variable to hold the name of another variable is a bad idea is that the
       question often stems from a lack of understanding of Perl data structures, particularly hashes.  By
       using symbolic references, you are just using the package's symbol-table hash (like %main::) instead
       of a user-defined hash.  The solution is to use your own hash or a real reference instead.

           $USER_VARS{"fred"} = 23;
           $varname = "fred";
           $USER_VARS{$varname}++;  # not $$varname++

       There we're using the %USER_VARS hash instead of symbolic references.  Sometimes this comes up in
       reading strings from the user with variable references and wanting to expand them to the values of
       your perl program's variables.  This is also a bad idea because it conflates the program-addressable
       namespace and the user-addressable one.  Instead of reading a string and expanding it to the actual
       contents of your program's own variables:

           $str = 'this has a $fred and $barney in it';
           $str =~ s/(\$\w+)/$1/eeg;             # need double eval

       it would be better to keep a hash around like %USER_VARS and have variable references actually refer
       to entries in that hash:

           $str =~ s/\$(\w+)/$USER_VARS{$1}/g;   # no /e here at all

       That's faster, cleaner, and safer than the previous approach.  Of course, you don't need to use a
       dollar sign.  You could use your own scheme to make it less confusing, like bracketed percent sym-
       bols, etc.

           $str = 'this has a %fred% and %barney% in it';
           $str =~ s/%(\w+)%/$USER_VARS{$1}/g;   # no /e here at all

       Another reason that folks sometimes think they want a variable to contain the name of a variable is
       because they don't know how to build proper data structures using hashes.  For example, let's say
       they wanted two hashes in their program: %fred and %barney, and that they wanted to use another
       scalar variable to refer to those by name.

           $name = "fred";
           $$name{WIFE} = "wilma";     # set %fred

           $name = "barney";
           $$name{WIFE} = "betty";     # set %barney

       This is still a symbolic reference, and is still saddled with the problems enumerated above.  It
       would be far better to write:

           $folks{"fred"}{WIFE}   = "wilma";
           $folks{"barney"}{WIFE} = "betty";

       And just use a multilevel hash to start with.

       The only times that you absolutely <u>must</u> use symbolic references are when you really must refer to the
       symbol table.  This may be because it's something that can't take a real reference to, such as a for-
       mat name.  Doing so may also be important for method calls, since these always go through the symbol
       table for resolution.

       In those cases, you would turn off "strict 'refs'" temporarily so you can play around with the symbol
       table.  For example:

           @colors = qw(red blue green yellow orange purple violet);
           for my $name (@colors) {
               no strict 'refs';  # renege for the block
               *$name = sub { "&lt;FONT COLOR='$name'&gt;@_&lt;/FONT&gt;" };
           }

       All those functions (<u>red()</u>, <u>blue()</u>, <u>green()</u>, etc.) appear to be separate, but the real code in the
       closure actually was compiled only once.

       So, sometimes you might want to use symbolic references to directly manipulate the symbol table.
       This doesn't matter for formats, handles, and subroutines, because they are always global--you can't
       use <u>my()</u> on them.  For scalars, arrays, and hashes, though--and usually for subroutines-- you proba-
       bly only want to use hard references.

       <b>What</b> <b>does</b> <b>"bad</b> <b>interpreter"</b> <b>mean?</b>

       (contributed by brian d foy)

       The "bad interpreter" message comes from the shell, not perl.  The actual message may vary depending
       on your platform, shell, and locale settings.

       If you see "bad interpreter - no such file or directory", the first line in your perl script (the
       "shebang" line) does not contain the right path to perl (or any other program capable of running
       scripts).  Sometimes this happens when you move the script from one machine to another and each
       machine has a different path to perl---/usr/bin/perl versus /usr/local/bin/perl for instance. It may
       also indicate that the source machine has CRLF line terminators and the destination machine has LF
       only: the shell tries to find /usr/bin/perl&lt;CR&gt;, but can't.

       If you see "bad interpreter: Permission denied", you need to make your script executable.

       In either case, you should still be able to run the scripts with perl explicitly:

               % perl script.pl

       If you get a message like "perl: command not found", perl is not in your PATH, which might also mean
       that the location of perl is not where you expect it so you need to adjust your shebang line.

<b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b>
       Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and other authors as noted. All rights
       reserved.

       This documentation is free; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       Irrespective of its distribution, all code examples in this file are hereby placed into the public
       domain.  You are permitted and encouraged to use this code in your own programs for fun or for profit
       as you see fit.  A simple comment in the code giving credit would be courteous but is not required.



perl v5.8.8                                      2006-01-07                                      PERLFAQ7(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq7.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq7.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq7.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
