<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h1>

<FONT COLOR="#000066">

<a name="108">

 <a name="//apple_ref/occ/cl/NSProxy">NSProxy</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

none <em>(NSProxy is a root class)

</em>

<p><B>Conforms To:</B><BR>

NSObject



<p><B>Declared In:	</B><BR>

Foundation/NSProxy.h



<p><a name="139"></a>

<a name="description"></a>

<H2>Class Description

</H2>

NSProxy is an abstract superclass defining an API for objects that act as stand-ins for other objects or for objects that don't exist yet. Typically, a message to a proxy is forwarded to the real object, or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create.<p>

NSProxy implements the basic methods required of a root class, including those defined in the NSObject protocol. However, as an abstract class it doesn't provide an initialization method, and it raises an exception upon receiving any message it doesn't respond to. A concrete subclass must therefore provide an initialization or creation method and override the <code>forwardInvocation:</code> and <code>methodSignatureForSelector:</code> methods to handle messages that it doesn't implement itself. A subclass's implementation of <code>forwardInvocation:</code> should do whatever is needed to process the invocation, such as forwarding the invocation over the network or loading the real object and passing it the invocation. <code>methodSignatureForSelector:</code> is required to provide argument type information for a given message; a subclass's implementation should be able to determine the argument types for the messages it needs to forward and should construct an NSMethodSignature accordingly. See the NSDistantObject, NSInvocation, and NSMethodSignature class specifications for more information.<p>

<HR WIDTH=50% ALIGN=LEFT>

<h2>Adopted Protocols</h2>  





<dl>

<dt>NSObject<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/autorelease" target="_top">- autorelease</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/class" target="_top">- class</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/conformsToProtocol:" target="_top">- conformsToProtocol:</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/description" target="_top">- description</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/hash" target="_top">- hash</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/isEqual:" target="_top">- isEqual:</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/isKindOfClass:" target="_top">- isKindOfClass:</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/isMemberOfClass:" target="_top">- isMemberOfClass:</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/isProxy" target="_top">- isProxy</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/performSelector:" target="_top">- performSelector:</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/performSelector:withObject:" target="_top">- performSelector:withObject:</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/performSelector:withObject:withObject:" target="_top">- performSelector:withObject:withObject:</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">- release</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">- respondsToSelector:</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/retain" target="_top">- retain</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/retainCount" target="_top">- retainCount</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/self" target="_top">- self</a><dt><a href="../../Protocols/NSObject.html#//apple_ref/occ/intfm/NSObject/superclass" target="_top">- superclass</a><dt><a href="../../Protocols/NSObject/NSObject.html#//apple_ref/occ/intfm/NSObject/zone" target="_top">- zone</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<a name="163">

<HR WIDTH=50% ALIGN=LEFT>

<h2>Method Types

</h2>

</a><dl>

<dt>Creating instances<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSProxy/alloc">+ alloc</a><dt><a href="#//apple_ref/occ/clm/NSProxy/allocWithZone:">+ allocWithZone:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Deallocating instances<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSProxy/dealloc">- dealloc</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting the class<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSProxy/class">+ class</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Handling unimplemented methods<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSProxy/forwardInvocation:">- forwardInvocation:</a><dt><a href="#//apple_ref/occ/instm/NSProxy/methodSignatureForSelector:">- methodSignatureForSelector:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting a description<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSProxy/description">- description</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH=50% ALIGN=LEFT>

<a name="176"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  

 



<a name="177"></a>

<h3>

 <a name="//apple_ref/occ/clm/NSProxy/alloc">alloc</a>

</h3>

+ (id)<code>alloc</code>

<P>Returns a new instance of the receiving class, as described in the NSObject class specification under the <code>alloc</code> class method.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="180"></a>

<h3> <a name="//apple_ref/occ/clm/NSProxy/allocWithZone:">allocWithZone:</a></h3>

+ (id)<code>allocWithZone:</code>(NSZone *)<em>zone</em>

<P>Returns a new instance of the receiving class, as described in the NSObject class specification under the <code>allocWithZone:</code> class method.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="183"></a>

<h3> <a name="//apple_ref/occ/clm/NSProxy/class">class</a></h3>

+ (Class)<code>class</code>

<P>Returns <code>self</code>. Since this is a class method, it returns the class object.<p>

<B>See also: </B>  

<code><a href="../NSObject.html#//apple_ref/occ/clm/NSObject/class" target="_top">+ class</code> (NSObject)</a>, <code><a href="../../Protocols/NSObject/NSObject.html#//apple_ref/occ/intfm/NSObject/class" target="_top">- class</code> (NSObject protocol)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="187"></a>

<h3><a name="//apple_ref/occ/clm/NSProxy/load">load</a></h3>

+ (void)<code>load</code>

<P>This method is invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading. It is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly-loaded class or category implements a method that can respond. As an example, when Interface Builder loads a palette, the load method is sent to each class and category in the palette.<p>

<code>load</code> is usually invoked before <code>initialize</code>. It is usually the very first method sent to the class, although this isn't guaranteed. The order in which classes are loaded is also not guaranteed, to the point that superclasses aren't even guaranteed to be loaded before all of their subclasses. Because you can't rely on other classes being loaded at the point when your class is sent a <code>load</code> message, you should be extremely careful when messaging other classes from within your load method.<p>

<HR WIDTH=25% ALIGN=LEFT>

<B>Warning:	</B>

Due to the amount of uncertainty about the environment at the point that <code>load</code> is invoked, you 

should avoid using <code>load</code> whenever possible. All class-specific initialization should be done in the 

class's <code>initialize</code> method.



<HR WIDTH=25% ALIGN=LEFT>

<p>Note that although <code>load</code> is essentially replaces NEXTSTEP's <code>finishLoading:</code> method, the circumstances surrounding their invocation is slightly different. Consult your NEXTSTEP Developer documentation if you are porting code that uses <code>finishLoading:</code>.<p>

<B>See also: </B>  

<code><a href="../NSObject/NSObject.html#//apple_ref/occ/clm/NSObject/load" target="_top">+ load</code> (NSObject)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="194"></a>

<h3><a name="//apple_ref/occ/clm/NSProxy/respondsToSelector:">respondsToSelector:</a></h3>

+ (BOOL)<code>respondsToSelector:</code>(SEL)<em>aSelector</em>

<P>Returns YES if the receiving class responds to <em>aSelector</em> messages, NO otherwise.<p>

<HR WIDTH=50% ALIGN=LEFT>

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="198"></a>

<h3>

 <a name="//apple_ref/occ/instm/NSProxy/class">class</a>

</h3>

@protocol NSObject

<P>- (Class)<code>class</code>

<P>Returns the class of the receiver (not the class of the real object).<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="202"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/conformsToProtocol:">conformsToProtocol:</a></h3>

@protocol NSObject

<P>- (BOOL)<code>conformsToProtocol:</code>(Protocol)<em>aProtocol</em>

<P>Uses <code>forwardInvocation:</code> to send the <code>conformsToProtocol:</code> message to the real object and returns the result. Note that NSProxy's implementation of <code>forwardInvocation:</code> merely raises an exception.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="206"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/dealloc">dealloc</a></h3>

- (void)<code>dealloc</code>

<P>Deallocates the memory occupied by the receiver, as described in the NSObject class specification under the <code>dealloc</code> instance method.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="209"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/description">description</a></h3>

- (NSString *)<code>description</code>

<P>Returns an NSString containing the real class name and the <code>id</code> of the receiver as a hexadecimal number.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="212"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/forwardInvocation:">forwardInvocation:</a></h3>

- (void)<code>forwardInvocation:</code>(NSInvocation *)<em>anInvocation</em>

<P>Passes <em>anInvocation</em> on to the real object that the proxy represents. NSProxy's implementation merely raises NSInvalidArgumentException. Override this method in your subclass to handle <em>anInvocation</em> appropriately, at the very least by setting its return value.<p>

For example, if your proxy merely forwards messages to an instance variable named <code>realObject</code>, it can implement <code>forwardInvocation:</code> like this:<p>

<blockquote><pre>- (void)forwardInvocation:(NSInvocation *)anInvocation<br>{<br>    [anInvocation setTarget:realObject];<br>    [anInvocation invoke];<br>    return;<br>}

</pre></blockquote><p><hr WIDTH=25% ALIGN=LEFT>

<a name="217"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/isKindOfClass:">isKindOfClass:</a></h3>

@protocol NSObject

<P>- (BOOL)<code>isKindOfClass:</code>(Class)<em>aClass</em>

<P>Uses <code>forwardInvocation:</code> to send the <code>isKindOfClass:</code> message to the real object and returns the result. Note that NSProxy's implementation of <code>forwardInvocation:</code> merely raises an exception.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="221"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/isMemberOfClass:">isMemberOfClass:</a></h3>

@protocol NSObject

<P>- (BOOL)<code>isMemberOfClass:</code>(Class)<em>aClass</em>

<P>Uses <code>forwardInvocation:</code> to send the <code>isMemberOfClass:</code> message to the real object and returns the result. Note that NSProxy's implementation of <code>forwardInvocation:</code> merely raises an exception.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="225"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/isProxy">isProxy</a></h3>

@protocol NSObject

<P>- (BOOL)<code>isProxy</code>

<P>Returns YES. Subclasses shouldn't override this method to return NO.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="229"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/methodSignatureForSelector:">methodSignatureForSelector:</a></h3>

- (NSMethodSignature *)<code>methodSignatureForSelector:</code>(SEL)<em>aSelector</em>

<P>Raises NSInvalidArgumentException. Override this method in your concrete subclass to return a proper NSMethodSignature for <em>aSelector</em> and the class that your proxy objects stand in for. Be sure to avoid an infinite loop when necessary by checking that <em>aSelector</em> isn't the selector for this method itself and by not sending any message that might invoke this method.<p>

For example, if your proxy merely forwards messages to an instance variable named <code>realObject</code>, it can implement <code>methodSignatureForSelector:</code> like this:<p>

<blockquote><pre>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector<br>{<br>    return [realObject methodSignatureForSelector:aSelector];<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="../NSObject/NSObject.html#//apple_ref/occ/instm/NSObject/methodSignatureForSelector:" target="_top">- methodSignatureForSelector:</code> (NSObject)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="235"></a>

<h3> <a name="//apple_ref/occ/instm/NSProxy/respondsToSelector:">respondsToSelector:</a></h3>

@protocol NSObject

<P>- (BOOL)<code>respondsToSelector:</code>(SEL)<em>aSelector</em>

<P>Uses <code>forwardInvocation:</code> to send the <code>respondsToSelector:</code> message to the real object and returns the result. Note that NSProxy's implementation of <code>forwardInvocation:</code> merely raises an exception.<p>



 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 06/17/97 16:52:04 -->



</body>

</html>

