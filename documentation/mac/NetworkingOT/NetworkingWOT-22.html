<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Downloading a URL With HTTP</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING22></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-21.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-23.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-16.html"><B>Chapter 2 - Getting Started With Open Transport</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING22-0></A>
<H1><A NAME=MARKER-9-66></A>Downloading a URL With HTTP</H1>
 The sample code shown in <A HREF=#MARKER-9-67>Listing 2-4</A> downloads a URL from a web server. It includes two functions: a simple notifier, YieldingNotifier, and a function, MyDownloadHTTPSimple, that downloads the URL. Because the function MyDownloadHTTPSimple contains synchronous calls to Open Transport, the notifier is used to call the function <CODE>YieldToAnyThread</CODE>, which cedes time to the processor while a synchronous operation waits to complete. A detailed discussion is contained in the sections following the listing.<P>
 The code shown in <A HREF=#MARKER-9-67>Listing 2-4</A> begins by initializing required debugging flags and including the appropriate header files. The <CODE>OTDebugStr</CODE> function is not defined in any of the Open Transport header files, but it is exported by the libraries, so its prototype is included.<P>
<B>Listing 2-4  <A NAME=MARKER-9-67></A>Downloading a URL With HTTP</B><P>
<PRE>
<A NAME=MARKER-0-95></A>#ifndef qDebug/* The OT debugging macros in &lt;OTDebug.h&gt; */
#define qDebug 1/* require this variable to be set.*/
#endif

#include &lt;OpenTransport.h&gt;
#include &lt;OpenTptInternet.h&gt; /* header for TCP/IP */
#include &lt;OTDebug.h&gt;/* header for OTDebugBreak, OTAssert macros */
#include &lt;Threads.h&gt;/* declaration for YieldToAnyThread */
#include &quot;OTSimpleDownloadHTTP.h&quot; /* header for our own protype */

extern pascal void OTDebugStr(const char* str);

enum 
   { kTransferBufferSize = 4096 };/* define size of buffer */

/* define notifier */

static pascal void YieldingNotifier(void* contextPtr, OTEventCode code, 
                              OTResult result, void* cookie)
{
   #pragma unused(contextPtr)
   #pragma unused(result)
   #pragma unused(cookie)
   OSStatus junk;
   
   switch (code) 
   {
      case kOTSyncIdleEvent:
         junk = YieldToAnyThread();
         OTAssert(&quot;YieldingNotifier: YieldToAnyThread failed&quot;,
                              junk == noErr);
         break;
      default:
         /* do nothing */
         break;
   }
}


/* Define function that downloads a URL from a web server. */

OSStatus MyDownloadHTTPSimple(const char *hostName,
                     const char *httpCommand,
                     const short destFileRefNum)
{
   OSStatus err;
   OSStatus junk;
   Ptr      transferBuffer = nil;
   EndpointRef ep = kOTInvalidEndpointRef;
   TCall    sndCall;
   DNSAddress hostDNSAddress;
   OTFlags  junkFlags;
   OTResult bytesSent;
   OTResult bytesReceived;
   OTResult lookResult;
   Boolean  bound    = false;
   
   /* Allocate a buffer for storing the data as we read it. */
   
   err = noErr;
   transferBuffer = OTAllocMem(kTransferBufferSize);
   if ( transferBuffer == nil ) 
       err = kENOMEMErr; 
      
   /* Open a TCP endpoint. */
   
   if (err == noErr) 
   {  
      ep = OTOpenEndpoint(OTCreateConfiguration(kTCPName), 0, nil,
                                          &amp;err);
   }
      
   /* If the endpoint opens successfully... */
   
   if (err == noErr) 
   {
      junk = OTSetSynchronous(ep);
      OTAssert(&quot;MyDownloadHTTPSimple: OTSetSynchronous failed&quot;,
                                    junk == noErr);
      
      junk = OTSetBlocking(ep);

      OTAssert(&quot;MyDownloadHTTPSimple: OTSetBlocking failed&quot;,
                                    junk == noErr);
      
      junk = OTInstallNotifier(ep, YieldingNotifier, nil);
      OTAssert(&quot;MyDownloadHTTPSimple: OTInstallNotifier failed&quot;,
                                    junk == noErr);
      
      junk = OTUseSyncIdleEvents(ep, true);
      OTAssert(&quot;MyDownloadHTTPSimple: OTUseSyncIdleEvents failed&quot;,
                                       junk == noErr);

      /* Bind the endpoint. */
            
      err = OTBind(ep, nil, nil);
      bound = (err == noErr);
   }
      
   /* Initialise the sndCall structure and call OTConnect. */ 
   if (err == noErr) 
   {
      OTMemzero(&amp;sndCall, sizeof(TCall));
      sndCall.addr.buf = (UInt8 *) &amp;hostDNSAddress;
      sndCall.addr.len = OTInitDNSAddress(&amp;hostDNSAddress, (char *)
                                       hostName);
      
      err = OTConnect(ep, &amp;sndCall, nil);
   }
   
   /* Send the HTTP command to the server. */
   
   if (err == noErr) 
      { 
         bytesSent = OTSnd(ep, (void *) httpCommand,
                           OTStrLength(httpCommand), 0); 
      if (bytesSent &gt; 0) 
         err = noErr; 
      else err = bytesSent; 
      }        
   /* Now we receive the data coming back from the server. */
   if (err == noErr) 
   {
      do 
      {
         bytesReceived = OTRcv(ep, (void *) transferBuffer,
                        kTransferBufferSize, &amp;junkFlags);
         
         if (bytesReceived &gt; 0) 
             err = FSWrite(destFileRefNum, &amp;bytesReceived,
                                    transferBuffer); 
         else err = bytesReceived; 
         
      } while (err == noErr); /* Loop until we get an error. */
   }

   /* Now handle the various forms of error that can occur. */
   if (err == kOTLookErr) 
   {
      lookResult = OTLook(ep);

      switch (lookResult) 
         {
            case T_DISCONNECT:
            
               err = OTRcvDisconnect(ep, nil);
               break;
            
            case T_ORDREL:
                        
               err = OTRcvOrderlyDisconnect(ep);
               if (err == noErr) 
                  {err = OTSndOrderlyDisconnect(ep);}
               break;
            
            default:
               
               break;
         }
   }

   if ( (err == noErr) &amp;&amp; bound ) 
   {
      junk = OTUnbind(ep);
      OTAssert(&quot;MyDownloadHTTPSimple: OTUnbind failed.&quot;,
                                 junk == noErr);
   }
   
   /* Clean up. */
   if (ep != kOTInvalidEndpointRef) 
   {
      junk = OTCloseProvider(ep);
      OTAssert(&quot;MyDownloadHTTPSimple: OTCloseProvider failed&quot;,
                                 junk == noErr);
   }
   if (transferBuffer != nil) 
    OTFreeMem(transferBuffer); 
      
   return (err);
}
</PRE>
<A NAME=HEADING22-5></A>
<H2><A NAME=MARKER-9-69></A>Using Threads for Easy Synchronous Processing</H2>
 The notifier shown in <A HREF=#MARKER-9-67>Listing 2-4 </A> is used to yield time to the processor whenever the endpoint receives a <CODE>kOTSyncIdleEvent</CODE>. Open Transport sends this event whenever it's waiting for a synchronous operation to complete. In response, your notifier should call the function <CODE>YieldToAnyThread</CODE>. <P>
<PRE>
<A NAME=MARKER-0-95></A>static pascal void YieldingNotifier(void* contextPtr, OTEventCode code, 
                              OTResult result, void* cookie)
{
   #pragma unused(contextPtr)
   #pragma unused(result)
   #pragma unused(cookie)
   OSStatus junk;
   
   switch (code) 
   {
      case kOTSyncIdleEvent:
         junk = YieldToAnyThread();
         OTAssert(&quot;YieldingNotifier: YieldToAnyThread failed&quot;,
                              junk == noErr);
         break;
      default:
         /* do nothing */
         break;
   }
}
</PRE>
<A NAME=HEADING22-8></A>
<H2>Specifying the Host Names and HTTP Commands</H2>
 The next section of code in <A HREF=#MARKER-9-67>Listing 2-4 </A> calls the function <CODE>MyDownloadHTTPSimple</CODE>. This function accepts three parameters: the name of the host to which you want to connect, the command to send to the host, and a reference to the file to which you want to download the URL.<P>
<PRE>
<A NAME=MARKER-0-95></A>OSStatus MyDownloadHTTPSimple(const char *hostName,
                     const char *httpCommand,
                     const short destFileRefNum)

/* declarations go here */
The parameter hostName is a pointer to a string that contains the DNS 
address of the web server. The DNS address must have the suffix :&lt;port&gt;, 
where port is the port number the web server is operating on. 
</PRE>
 The parameter <CODE>httpCommand</CODE> is a pointer to the HTTP command to send. Typically this command has the following form, where <CODE>&lt;<I>x&gt;</I></CODE> is the URL path.<P>
<PRE>
<A NAME=MARKER-0-95></A>Get &lt;X&gt; HTTP/1.0\0x13\0x10\0x13\0x10
</PRE>
 For example, if you were to download the URL<P>
 <CODE> http://devworld.apple.com/dev/technotes.shtml</CODE><P>
 You would set <CODE>hostName</CODE> to <CODE>devworld.apple.com:80</CODE>. (The default port for HTTP is 80.) And you would set <CODE>httpCommand</CODE> to<P>
<PRE>
<A NAME=MARKER-0-95></A>"GET /dev/technotes.shtml HTTP/1.0\0x13\0x10\0x13\0x10"
</PRE>
 The parameter <CODE>destFileRefNum</CODE> is the reference number of the file to which the results of the HTTP command are written. The function <CODE>MyDownloadHTTPSimple</CODE> does not parse the returned HTTP header. The entire incoming stream is written to the file.<P>
<A NAME=HEADING22-18></A>
<H2>Opening an Endpoint and Setting the Mode of Operation</H2>
 The first section of the function <CODE>MyDownloadHTTPSimple</CODE> shown in <A HREF=#MARKER-9-67>Listing 2-4 </A> opens a TCP endpoint, sets the mode of operation, and installs the notifier YieldingNotifier. <P>
<PRE>
<A NAME=MARKER-0-95></A>if (err == noErr) 
      ep = OTOpenEndpoint(OTCreateConfiguration(kTCPName), 0, nil,
                                          &amp;err); 
      /* If the endpoint opens successfully... */
   
   if (err == noErr) 
   {
      junk = OTSetSynchronous(ep);
      OTAssert(&quot;MyDownloadHTTPSimple: OTSetSynchronous failed&quot;,
                                    junk == noErr);
      
      junk = OTSetBlocking(ep);

      OTAssert(&quot;MyDownloadHTTPSimple: OTSetBlocking failed&quot;,
                                    junk == noErr);
      
      junk = OTInstallNotifier(ep, YieldingNotifier, nil);
      OTAssert(&quot;MyDownloadHTTPSimple: OTInstallNotifier failed&quot;,
                                    junk == noErr);
      
      junk = OTUseSyncIdleEvents(ep, true);
      OTAssert(&quot;MyDownloadHTTPSimple: OTUseSyncIdleEvents failed&quot;,
                                       junk == noErr);

      /* Bind the endpoint. */
            
      err = OTBind(ep, nil, nil);
      bound = (err == noErr);
   }
</PRE>
 The <CODE>OTOpenEndpoint</CODE> function opens the endpoint and returns an endpoint reference (<CODE>ep</CODE>). You need to specify this endpoint reference when you set the mode of execution for the endpoint, when you bind the endpoint to an address, and, later, when you establish a connection, receive data, and close the endpoint. The mode of operation for the endpoint is set as synchronous blocking with the call to the <CODE>OTSetSynchronous</CODE> function and the <CODE>OTSetBlocking</CODE> function. The call to the function <CODE>OTInstallNotifier</CODE> installs the notifier <CODE>YieldingNotifier</CODE>. The call to the function <CODE>OTUseSyncIdleEvents</CODE> tells Open Transport to send <CODE>kOTSyncIdleEvents</CODE> to this endpoint; the notifier responds to this event by yielding time to other processes, as noted in <A HREF=#MARKER-9-69>"Using Threads for Easy Synchronous Processing"</A>.<P>
 Using a synchronous blocking mode of operation results in a simpler programming model, and the use of the notifier function to yield time to other processes prevents the machine from hanging when synchronous operations are waiting to complete.<P>
 Finally, the call to the <CODE>OTBind</CODE> function binds the endpoint to a TCP address. (A connection-oriented endpoint can initiate a connection only after the endpoint is bound or queue incoming connection requests.) The second parameter requests the address to which you want to bind the endpoint. In this case, a value of <CODE>nil</CODE> is passed; because this is an outgoing connection, it does not particularly matter what address the endpoint is bound to. The third parameter to the <CODE>OTBind</CODE> function returns the address to which Open Transport has actually bound the endpoint. The code passes <CODE>nil</CODE> because we don't need that information.<P>
<A NAME=HEADING22-24></A>
<H2>Connecting to the Host and Sending Data</H2>
 The next section of the function <CODE>MyDownloadHTTPSimple,</CODE> shown in <A HREF=#MARKER-9-67>Listing 2-4 </A>, connects to the host and sends an HTTP command to the server. The <CODE>OTConnect</CODE> function, which is used to connect the endpoint, passes three parameters: in this case, <CODE>ep</CODE> (the endpoint reference), <CODE>&amp;sndCall</CODE> (a pointer to the address of the remote endpoint), and a pointer to a buffer in which <CODE>OTConnect</CODE> can return information about the connection. Because no data or options were specified with the <CODE>sndCall</CODE> parameter, it is not necessary to examine any information returned by the function, so the third parameter is set to <CODE>nil</CODE>.<P>
<PRE>
<A NAME=MARKER-0-95></A>   if (err == noErr) 
   {
      OTMemZero(&amp;sndCall, sizeof(TCall));
      sndCall.addr.buf = (UInt8 *) &amp;hostDNSAddress;
      sndCall.addr.len = OTInitDNSAddress(&amp;hostDNSAddress, (char *)
                                       hostName);
      err = OTConnect(ep, &amp;sndCall, nil);
   }
   
   /* Send the HTTP command to the server. */
   
   if (err == noErr)
   {
       bytesSent = OTSnd(ep, (void *) httpCommand,
                           OTStrLength(httpCommand), 0); 
      if (bytesSent &gt; 0) 
         err = noErr; 
      else err = bytesSent; 
   }
</PRE>
 Before calling the <CODE>OTConnect</CODE> function, the <CODE>sndCall</CODE> structure is initialized. In this case, only the address fields are specified because we are neither sending data with the connection request nor asking for specific option values. The specification of the address is described in detail in <A HREF=NetworkingWOT-19.html#MARKER-9-51>"Storing an Address in a TNetBuf Structure"</A>.<P>
 After connecting to the server, the <CODE>OTSnd</CODE> function is called to send the HTTP command. The <CODE>OTSnd</CODE> function takes four parameters: in this case, <CODE>ep</CODE> (the endpoint reference), <CODE>httpCommand</CODE> (a pointer to the data being sent), <CODE>OTStrLength(httpCommand)</CODE> (the length of the data), and 0 (specifying that no flags are set). The <CODE>OTSnd</CODE> function returns the number of bytes sent or a negative number representing an error code if an error occurred. Because the endpoint is in synchronous mode, the function won't return until it has sent all the bytes or it returns an error. The code following the call to <CODE>OTSnd</CODE> tests to see whether the return value of the function is greater than zero to determine whether or not an error occurred.<P>
<A NAME=HEADING22-29></A>
<H2>Receiving Data From the Remote Endpoint</H2>
 As shown in <A HREF=#MARKER-9-67>Listing 2-4 </A> after establishing the connection and sending the data, the function <CODE>MyDownloadHTTPSimple</CODE> calls the function <CODE>OTRcv</CODE>, which returns the number of bytes received or a negative (error code) number. <P>
<PRE>
<A NAME=MARKER-0-95></A>if (err == noErr) 
   {
      do 
      {
         bytesReceived = OTRcv(ep, (void *) transferBuffer,
                        kTransferBufferSize, &amp;junkFlags);
         
         if (bytesReceived &gt; 0) 
             err = FSWrite(destFileRefNum, &amp;bytesReceived,
                                    transferBuffer); 
         else err = bytesReceived; 
         
      } while (err == noErr); /* Loop until we get an error. */
   }
</PRE>
 Because the endpoint is in synchronous blocking mode, the function won't return until it has received all the data you asked for, or it returns an error. The <CODE>OTRcv</CODE> function is called repeatedly until it gets an error, which indicates that there is no data left to receive. The function <CODE>OTRcv</CODE> takes four parameters: in this case <CODE>ep</CODE> (the endpoint reference), <CODE>transferBuffer</CODE> (a pointer to the buffer in which data is to be placed), <CODE>kTransferBufferSize</CODE> (which specifies the size of the buffer), and <CODE>&amp;junkFlags</CODE> (a pointer to a buffer for flags information), which this sample ignores.<P>
 As it receives data, the function <CODE>MyDownloadHTTPSimple</CODE> calls the <CODE>FSWrite</CODE> function to write the data to a file.<P>
<A NAME=HEADING22-34></A>
<H2>Error Handling</H2>
 The next section of the function <CODE>MyDownloadHTTPSimple</CODE> in <A HREF=#MARKER-9-67>Listing 2-4 </A> handles errors that might be returned. The most common error is <CODE>kOTLookErr</CODE>. This indicates that some event has happened that you need to look at. To do this, the function <CODE>MyDownloadHTTPSimple</CODE> calls the function <CODE>OTLook</CODE>, which returns an event code for the pending event. <P>
<PRE>
<A NAME=MARKER-0-95></A>if (err == kOTLookErr) 
{
      lookResult = OTLook(ep);

      switch (lookResult) 
      {
            case T_DISCONNECT:
            
               err = OTRcvDisconnect(ep, nil);
               break;
            
            case T_ORDREL:
                        
               err = OTRcvOrderlyDisconnect(ep);
               if (err == noErr) 
                  {err = OTSndOrderlyDisconnect(ep);}
               break;
            
            default:
               break;
      }
}
</PRE>
 The <CODE>switch</CODE> statement includes cases for the most common types of events, <CODE>T_DISCONNECT</CODE> and <CODE>T_ORDREL</CODE>, and handles them appropriately. The event <CODE>T_DISCONNECT </CODE>signals that the remote peer has initiated a disorderly disconnect. HTTP servers will often just disconnect to indicate the end of the data, so all that is needed in response is to clear the event by calling the function <CODE>OTRcvDisconnect</CODE>. The event <CODE>T_ORDREL</CODE> signals that the remote peer has initiated an orderly disconnect. This means it has no more data to send. In response, your function clears the <CODE>T_ORDREL</CODE> event by calling the <CODE>OTRcvOrderlyDisconnect</CODE> function and then calls the <CODE>OTSndOrderlyDisconnect</CODE> to let the remote peer know that it received and processed the event.<P>
<A NAME=HEADING22-38></A>
<H2>Unbinding the Endpoint and Final Clean-Up</H2>
 As <A HREF=#MARKER-9-67>Listing 2-4 </A> shows, having received the data requested, the function <CODE>MyDownloadHTTPSimple</CODE> unbinds the endpoint. The conditional call to the <CODE>OTCloseProvider</CODE> function closes the endpoint. The following call to the <CODE>OTFreeMem</CODE> function frees up memory for the buffer that was allocated to receive data from the <CODE>OTRcv</CODE> function.<P>
<PRE>
if ( (err == noErr) &amp;&amp; bound ) 
{
	junk = OTUnbind(ep);
	OTAssert(&quot;MyDownloadHTTPSimple: OTUnbind failed.&quot;, 
											junk == noErr);
}
	
/* Clean up. */
if (ep != kOTInvalidEndpointRef) 
{
	junk = OTCloseProvider(ep);
	OTAssert(&quot;MyDownloadHTTPSimple: OTCloseProvider failed.&quot;,
											junk == noErr);
}

</PRE>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-22.html#HEADING22-5">Using Threads for Easy Synchronous Processing</A>
<DD>
<DT><A HREF="NetworkingWOT-22.html#HEADING22-8">Specifying the Host Names and HTTP Commands</A>
<DD>
<DT><A HREF="NetworkingWOT-22.html#HEADING22-18">Opening an Endpoint and Setting the Mode of Operation</A>
<DD>
<DT><A HREF="NetworkingWOT-22.html#HEADING22-24">Connecting to the Host and Sending Data</A>
<DD>
<DT><A HREF="NetworkingWOT-22.html#HEADING22-29">Receiving Data From the Remote Endpoint</A>
<DD>
<DT><A HREF="NetworkingWOT-22.html#HEADING22-34">Error Handling</A>
<DD>
<DT><A HREF="NetworkingWOT-22.html#HEADING22-38">Unbinding the Endpoint and Final Clean-Up</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-21.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-23.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
