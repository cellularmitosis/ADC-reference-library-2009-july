<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>OpenGL Programming Guide for Mac OS X: Drawing to a Window or View</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Drawing to a Window or View"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001987-CH404" title="Drawing to a Window or View"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../OpenGL-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000549" target="_top">OpenGL</a> &gt; <a href="../opengl_intro/opengl_intro.html#//apple_ref/doc/uid/TP40001987-CH207-TP9">OpenGL Programming Guide for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_pg_concepts/opengl_pg_concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_fullscreen/opengl_cgl.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001987-CH404-SW8" title="Drawing to a Window or View"></a><h1>Drawing to a Window or View</h1><p>The OpenGL programming interface provides hundreds of drawing commands that drive graphics hardware. It doesn't provide any commands that interface with the windowing system of an operating system. Without a windowing system, the 3D graphics of an OpenGL program are trapped inside the GPU. <span class="content_text">Figure 2-1</span> shows a cube drawn to a Cocoa view and a trefoil drawn to a Carbon window. (You can just as easily draw the trefoil to the Cocoa view and the cube to the Carbon window.) </p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH404-SW19" title="Figure 2-1OpenGL content in a Cocoa view (left) and a Carbon window (right)"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>OpenGL content in a Cocoa view (left) and a Carbon window (right)</p><img src = "../art/cocoa_carbon_rendering.jpg" alt = "OpenGL content in a Cocoa view (left) and a Carbon window (right)" ></div><br/><p>This chapter shows how to display OpenGL drawing onscreen  using the APIs provided by Mac OS X. You'll see how to draw to Cocoa views and Carbon windows. (This chapter does not show how to use GLUT.) The first section describes the overall approach to drawing onscreen and provides an overview to the functions and methods used by each API. You'll want to read this regardless of the application framework that you use. The remaining sections in the chapter provide information that's specific to Cocoa or Carbon. After you consult the appropriate section, take a look at <span class="content_text"><a href="opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW1">“What's Next”</a></span> for pointers to optimization strategies and other information that will help your OpenGL application to perform at its best.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW2">General Approach</a>
				
			<br/>
			
        
			
			
				<a href="opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW23">Drawing to a Cocoa View</a>
				
			<br/>
			
        
			
			
				<a href="opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW24">Drawing to a Carbon Window</a>
				
			<br/>
			
        
			
			
				<a href="opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW1">What's Next</a>
				
			<br/>
			
        
			
			
				<a href="opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW27">See Also</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001987-CH404-SW2" title="General Approach"></a><h2>General Approach</h2><p>Mac OS X provides three interfaces for drawing OpenGL content onscreen: the NSOpenGL classes, AGL, and CGL. (See <span class="content_text"><a href="../opengl_pg_concepts/opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW19">“Programming Interfaces”</a></span> for more information). You use the NSOpenGL classes  from within the Cocoa application framework, while AGL is the interface that supports drawing OpenGL content to a Carbon application. CGL can be used from either a Cocoa or Carbon application. For drawing to a view or a window, you'll either use the NSOpenGL classes (for a Cocoa view) or AGL (for a Carbon window), because CGL supports drawing only to the full screen.</p><p>Regardless of the application framework, to draw OpenGL content to a window or view, you need to perform these tasks:</p><ol class="ol"><li class="li"><p>Set up the renderer and buffer attributes that support the OpenGL drawing you want to perform.</p><p>Each of the OpenGL APIs in Mac OS X has its own set of constants that represent renderer and buffer attributes. For example, the all-renderers attribute is represented by the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLPixelFormat_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSOpenGLPFAAllRenderers" target="_top">NSOpenGLPFAAllRenderers</a></code> constant in Cocoa and the <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/AGL_ALL_RENDERERS" target="_top">AGL_ALL_RENDERERS</a></code> constant in the AGL API. </p></li><li class="li"><p>Request, from the operating system, a pixel format object that encapsulates pixel storage information and the renderer and buffer attributes required by your application. The returned pixel format object contains all possible combinations of renderers and displays available on the system that your program runs on and that meets the requirements specified by the attributes. The combinations are referred to as virtual screens. (See <span class="content_text"><a href="../opengl_pg_concepts/opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW16">“Virtual Screens.”</a></span>) </p><p>There may be situations for which you want to ensure that your program uses a specific renderer. <span class="content_text"><a href="../opengl_pixelformats/opengl_pixelformats.html#//apple_ref/doc/uid/TP40001987-CH214-SW9">“Techniques for Choosing Attributes”</a></span> discusses how to set up an attributes array that will guarantee the system passes back a pixel format object that uses only that renderer.</p><p>You'll need to provide code that handles the case of getting back a <code>NULL</code> pixel format object. </p></li><li class="li"><p>Create a rendering context and bind the pixel format object to it. The rendering context keeps track of state information that controls such things as drawing color, view and projection matrices, characteristics of light, and conventions used to pack pixels.</p><p>Your application needs a pixel format object to create a rendering context. </p></li><li class="li"><p>Release the pixel format object. Once the pixel format object is bound to a rendering context, its resources are no longer needed.</p></li><li class="li"><p>Bind a drawable object to the rendering context. You'll either bind a Cocoa view or a Carbon window  to the context.</p></li><li class="li"><p>Make the rendering context the current context. The system sends OpenGL drawing to whichever rendering context is designated as the current one. It's possible for you to set up more than one rendering context, so you'll need to make sure that the one you want to draw to is the current one.</p></li><li class="li"><p>Perform your drawing.</p></li></ol><p>The specific functions or methods that you use to perform each of the steps are discussed in the sections that follow.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW23" title="Drawing to a Cocoa View"></a><h2>Drawing to a Cocoa View</h2><p>There are two ways to draw OpenGL content to a Cocoa view. You can either use the <code>NSOpenGLView</code> class or create a custom <code>NSView</code> class. If your application has modest drawing requirements, then you can use the <code>NSOpenGLView</code> class. For example, if your application draws to a single view and does not support dragging the view between monitors, you can use the <code>NSOpenGLView</code> class. See <span class="content_text">“Drawing to an NSOpenGLView Class: A Tutorial.”</span></p><p>If your application is more complex and needs to support drawing to multiple rendering contexts, you may want to consider subclassing the <code>NSView</code> class. For example, if your application supports drawing to multiple views at the same time, you'll need to set up a custom <code>NSView</code> class. See <span class="content_text"><a href="opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW3">“Drawing OpenGL Content to a Custom View.”</a></span></p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW5" title="Drawing to an NSOpenGLView Class: A Tutorial"></a><h3>Drawing to an NSOpenGLView Class: A Tutorial</h3><p>The <code>NSOpenGLView</code> class  is a lightweight subclass of the <code>NSView</code> class that provides convenience methods for setting up OpenGL drawing. An <code>NSOpenGLView</code> object maintains an <code>NSOpenGLPixelFormat</code> object and an <code><a name="//apple_ref/doc/uid/TP40001987-CH404-DontLinkElementID_3"></a>NSOpenGLContext</code> object into which OpenGL calls can be rendered. It provides methods for accessing and managing the pixel format object and the rendering context, and handles notification of visible region changes.</p><p>An <code>NSOpenGLView</code> object does not support subviews. You can, however, divide the view into multiple rendering areas using the OpenGL function <code>glViewport</code>.</p><p>This section provides step-by-step instructions for creating a simple Cocoa application that draws OpenGL content to a view. The tutorial assumes that you know how to use Xcode and Interface Builder. If you have never created an application using the Xcode development environment, see <span class="content_text"><a href="../../../../../referencelibrary/GettingStarted/GS_Tools/index.html" target="_top">Getting Started with Tools</a></span>.</p><ol class="ol"><li class="li"><p>Open Xcode and create a Cocoa application project named Golden Triangle.</p></li><li class="li"><p>Open the Frameworks folder in the Groups &amp; File list. Then select the Linked Frameworks folder.</p></li><li class="li"><p>Choose Project > Add to Project and navigate to the OpenGL framework, which is located in the <code>System/Library/Frameworks</code> directory. In the sheet that appears, choose <code>OpenGL.framework</code> and click Add. Then, in the next sheet that appears, click Add to add the framework to the target.</p></li><li class="li"><p>Choose File > New File. Then choose the Objective-C class template.</p></li><li class="li"><p>Click Next and name the file <code>MyOpenGLView.m</code>. Make sure the checkbox to create <code>MyOpenGLView.h</code> is selected. Then click Finish.</p></li><li class="li"><p>Open the <code>MyOpenGLView.h</code> file and modify the file so that it looks like the code shown in <span class="content_text">Listing 2-2</span> to declare the interface.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW6" title="Listing 2-1The interface for MyOpenGLView"></a><br/><br/><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>The interface for <code>MyOpenGLView</code></p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Cocoa/Cocoa.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface MyOpenGLView : NSOpenGLView<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void) drawRect: (NSRect) bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div></li><li class="li"><p>Save and close the <code>MyOpenGLView.h</code> file.</p></li><li class="li"><p>Open the <code>MyOpenGLView.m</code> file and include the <code>gl.h</code> file, as shown in <span class="content_text">Listing 2-3</span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW7" title="Listing 2-2Include OpenGL/gl.h"></a><br/><br/><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Include <code>OpenGL/gl.h</code></p><div class="codesample"><table><tr><td scope="row"><pre>#import "MyOpenGLView.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;OpenGL/gl.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyOpenGLView<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement the <code>drawRect:</code> method as shown in  <span class="content_text">Listing 2-3</span>, adding the code after the <code>@implementation</code> statement. The method sets the clear color to black and clears the color buffer in preparation for drawing. Then, <code>drawRect:</code> calls your drawing routine, which you’ll add next. The OpenGL command <code>glFlush</code> draws the content provided by your routine to the view.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW12" title="Listing 2-3The drawRect: method for MyOpenGLView"></a><br/><br/><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>The <code>drawRect:</code> method for <code>MyOpenGLView</code></p><div class="codesample"><table><tr><td scope="row"><pre>-(void) drawRect: (NSRect) bounds<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    glClearColor(0, 0, 0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    glClear(GL_COLOR_BUFFER_BIT);<span></span></pre></td></tr><tr><td scope="row"><pre>    drawAnObject();<span></span></pre></td></tr><tr><td scope="row"><pre>    glFlush();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Add the code to perform your drawing. In your own application, you'd perform whatever drawing is appropriate. But for the purpose of learning how to draw OpenGL content to a view, you'll add the code shown in <span class="content_text">Listing 2-4</span>. This code draws a 2-dimensional, gold-colored triangle, whose dimensions are not quite the dimensions of a true golden triangle, but good enough to show how to perform OpenGL drawing.</p><p>Make sure that you insert this routine before the drawRect: method in the  <code>MyOpenGLView.m</code> file. </p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW13" title="Listing 2-4Code that draws a triangle using OpenGL commands"></a><br/><br/><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Code that draws a triangle using OpenGL commands</p><div class="codesample"><table><tr><td scope="row"><pre>static void drawAnObject ()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    glColor3f(1.0f, 0.85f, 0.35f);<span></span></pre></td></tr><tr><td scope="row"><pre>    glBegin(GL_TRIANGLES);<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        glVertex3f(  0.0,  0.6, 0.0);<span></span></pre></td></tr><tr><td scope="row"><pre>        glVertex3f( -0.2, -0.3, 0.0);<span></span></pre></td></tr><tr><td scope="row"><pre>        glVertex3f(  0.2, -0.3 ,0.0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    glEnd();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>In the File Name list, double click the <code>MainMenu.xib</code> file to open Interface Builder. A default menu bar and window titled "Window" appears when the file opens.</p></li><li class="li"><p>Click the window and choose Tools > Inspector.</p></li><li class="li"><p>In the Window Attributes pane of the inspector window, change the Title entry to <code>Golden Triangle</code>. </p></li><li class="li"><p>Choose Tools > Library and type <code>NSOpenGLView</code> in the Search field.</p></li><li class="li"><p>Drag an <code>NSOpenGLView</code> object from the Library to the window. Resize the view to fit the window.</p></li><li class="li"><p>In the Identity pane of the inspector for the view, choose <code>MyOpenGLView</code> from the Class pop-up menu.</p></li><li class="li"><p>Open the Attributes pane of the inspector for the view, and take a look at the renderer and buffer attributes that are available to set.  These settings save you from setting attributes programmatically.</p><p>Only those attributes listed in the Interface Builder inspector are set when the view is instantiated. If you need additional attributes, you'll need to set them programmatically.</p></li><li class="li"><p>Choose File > Build &amp; Go in Xcode. You should see content similar to the triangle shown in <span class="content_text">Figure 2-2</span>. </p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40001987-CH404-SW18" title="Figure 2-2The output from the Golden Triangle program"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>The output from the Golden Triangle program</p><img src = "../art/golden_triangle.jpg" alt = "The output from the Golden Triangle program" ></div></li></ol><p>This example is extremely simple. In a more complex application, you'd want to do the following:</p><ul class="spaceabove"><li class="li"><p>In the interface for the view, declare a variable that indicates whether the view is ready to accept drawing. A view is ready for drawing only if it is bound to a rendering context and that context is set to be the current one.</p></li><li class="li"><p>Cocoa does not call initialization routines for objects created in Interface Builder. If you need to perform any  initialization tasks, do so in the  <code>awakeFromNib</code> method for the view. Note that because you set attributes in the inspector, there is no need to set them up programmatically unless you need additional ones. There is also no need to create a pixel format object programmatically; it is created and loaded when Cocoa loads the nib file.</p></li><li class="li"><p>Your <code>drawRect:</code> method should test whether the view is ready to draw into. You need to provide code that handles the case when the view is not ready to draw into.</p></li><li class="li"><p>OpenGL is at its best when doing real-time and interactive graphics. Your application will need to provide a timer or support user interaction.</p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH404-SW3" title="Drawing OpenGL Content to a Custom View"></a><h3>Drawing OpenGL Content to a Custom View</h3><p>This section provides an overview of the key tasks you need to perform to customize the <code>NSView</code> class for OpenGL drawing. Before you create a custom view for OpenGL drawing, you should read <span class="content_text"><a href="../../../../Cocoa/Conceptual/CocoaViewsGuide/SubclassingNSView/SubclassingNSView.html#//apple_ref/doc/uid/TP40002978-CH7" target="_top">Creating a Custom View</a></span> in <em><a href="../../../../Cocoa/Conceptual/CocoaViewsGuide/index.html#//apple_ref/doc/uid/TP40002978" target="_top">View Programming Guide for Cocoa</a></em>. You will also want to download Custom Cocoa OpenGL (available on the ADC website from <span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxOpenGL-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000549" target="_top">Sample Code > Graphics &amp; Imaging > OpenGL</a></span>), which is a full-featured OpenGL sample application that uses a custom subclass of <code>NSView</code> that behaves similarly to the <code>NSOpenGLView</code> class. The custom class is declared and defined in the <code>CustomOpenGLView.h</code> and <code>CustomOpenGLView.m</code> files. After you've set up your custom class, you can use it just as you would use the built-in <code>NSOpenGLView</code> class.</p><p>When you subclass the <code>NSView</code> class to create a custom view for OpenGL drawing, you'll override any Quartz drawing or other content that is in that view. To set up a custom view for OpenGL drawing, subclass <code>NSView</code> and create two private variables—one which is an <code>NSOpenGLContext</code> object and the other an <code>NSOpenGLPixelFormat</code> object, as shown in <span class="content_text">Listing 2-5</span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW9" title="Listing 2-5The interface for a custom OpenGL view"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>The interface for a custom OpenGL view</p><div class="codesample"><table><tr><td scope="row"><pre>@class NSOpenGLContext, NSOpenGLPixelFormat;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface CustomOpenGLView : NSView<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  @private<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLContext*     _openGLContext;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLPixelFormat* _pixelFormat;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>+ (NSOpenGLPixelFormat*)defaultPixelFormat;<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithFrame:(NSRect)frameRect pixelFormat:(NSOpenGLPixelFormat*)format;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setOpenGLContext:(NSOpenGLContext*)context;<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSOpenGLContext*)openGLContext;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)clearGLContext;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)prepareOpenGL;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)update;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPixelFormat:(NSOpenGLPixelFormat*)pixelFormat;<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSOpenGLPixelFormat*)pixelFormat;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>In addition to the usual methods for the private variables (<code>openGLContext</code>, <code>setOpenGLContext:</code>, <code>pixelFormat</code>, and <code>setPixelFormat:</code>) you'll need to implement the following methods:</p><ul class="spaceabove"><li class="li"><p><code>+ (NSOpenGLPixelFormat*) defaultPixelFormat</code></p><p>Use this method to allocate and initialize the <code>NSOpenGLPixelFormat</code> object.</p></li><li class="li"><p><code>- (void) clearGLContext</code></p><p>Use this method to clear and release the <code>NSOpenGLContext</code> object.</p></li><li class="li"><p><code>- (void) prepareOpenGL</code></p><p>Use this method to initialize the OpenGL state after creating the <code>NSOpenGLContext</code> object.</p></li></ul><p>You need to override the <code>update</code> and <code>initWithFrame:</code> methods of the <code>NSView</code> class. </p><ul class="spaceabove"><li class="li"><p><code>update</code> calls the <code>update</code> method of the <code>NSOpenGLContext</code> class.</p></li><li class="li"><p><code>initWithFrame:pixelFormat</code> retains the pixel format and sets up the notification <code>NSViewGlobalFrameDidChangeNotification</code>. See <span class="content_text">Listing 2-6</span>.</p></li></ul><p>If the custom view is not guaranteed to be in a window, you must also override the <code>lockFocus</code> method of the <code>NSView</code> class. See <span class="content_text">Listing 2-7</span>. This method makes sure that the view is locked prior to drawing and that the context is the current one. </p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW10" title="Listing 2-6The initWithFrame:pixelFormat: method"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>The <code>initWithFrame:pixelFormat:</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithFrame:(NSRect)frameRect pixelFormat:(NSOpenGLPixelFormat*)format<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self = [super initWithFrame:frameRect];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self != nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>        _pixelFormat   = [format retain];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSNotificationCenter defaultCenter] addObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                     selector:@selector(_surfaceNeedsUpdate:)<span></span></pre></td></tr><tr><td scope="row"><pre>                     name:NSViewGlobalFrameDidChangeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                     object:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void) _surfaceNeedsUpdate:(NSNotification*)notification<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   [self update];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH404-SW11" title="Listing 2-7The lockFocus method"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>The <code>lockFocus</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)lockFocus<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLContext* context = [self openGLContext];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [super lockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([context view] != self) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [context setView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    [context makeCurrentContext];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>reshape</code> method is not supported by the <code>NSView</code> class. You need to update bounds in the <code>drawRect:</code> method, which should take the form shown in <span class="content_text">Listing 2-8</span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW20" title="Listing 2-8The drawRect method for a custom view"></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>The <code>drawRect</code> method for a custom view</p><div class="codesample"><table><tr><td scope="row"><pre>-(void) drawRect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [context makeCurrentContext];<span></span></pre></td></tr><tr><td scope="row"><pre>    //Perform drawing here<span></span></pre></td></tr><tr><td scope="row"><pre>    [context flushBuffer];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>There may be other methods that you want to add. For example, you might consider detaching the context from the drawable object when the custom view is moved from the window, as shown in <span class="content_text">Listing 2-9</span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW21" title="Listing 2-9Detaching the context from a drawable object"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>Detaching the context from a drawable object</p><div class="codesample"><table><tr><td scope="row"><pre>-(void) viewDidMoveToWindow<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super viewDidMoveToWindow];<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([self window] == nil)<span></span></pre></td></tr><tr><td scope="row"><pre>        [context clearDrawable];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH404-SW24" title="Drawing to a Carbon Window"></a><h2>Drawing to a Carbon Window</h2><p>This section describes the steps for setting up onscreen drawing to a Carbon window. To get an idea of how these steps fit into an full application, you should look at the sample application <em><!--a target="_top" -->GLCarbonAGLWindow<!--/a--></em>.</p><p>Follow these steps to use the AGL API to set up onscreen drawing to a Carbon window:</p><ol class="ol"><li class="li"><p>Set up an array of attributes that describes the buffer characteristics and renderer capabilities that you want. You can supply any of the pixel format attributes or extended attributes defined in <span class="content_text"><!--a target="_top" -->AGL Constants<!--/a--></span> in  <em><a href="../../../Reference/AGL_OpenGL/index.html#//apple_ref/doc/uid/TP30001068" target="_top">AGL Reference</a></em>.</p><p> This example in <span class="content_text"><a href="opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW4">Listing 2-10</a></span> sets up attributes for RGBA, double buffering, and a pixel depth of 24 bits. Your code would set up whatever attributes are appropriate. In later chapters in this book, you'll see how to choose attributes for specific purposes. (See <span class="content_text"><a href="../opengl_pixelformats/opengl_pixelformats.html#//apple_ref/doc/uid/TP40001987-CH214-SW9">“Techniques for Choosing Attributes.”</a></span>)</p></li><li class="li"><p>Obtain a pixel format object by passing the attributes array to the function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglChoosePixelFormat" target="_top">aglChoosePixelFormat</a></code>.</p><p>The pixel format object contains a list of all appropriate renderer-display combinations. In the example shown here, it's likely that the list will contain at least two items—one that uses a hardware renderer and another that uses a software renderer.</p></li><li class="li"><p>Bind the pixel format object to a rendering context by passing the pixel format object to the function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglCreateContext" target="_top">aglCreateContext</a></code>.</p><p>If the pixel format object has more than one pixel format (renderer-display combination) in it, AGL uses the first in the list. You can call the function <code>aglNextPixelFormat</code> if you want to use the next pixel format in the list.</p></li><li class="li"><p>Release the pixel format object by calling the function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglDestroyPixelFormat" target="_top">aglDestroyPixelFormat</a></code>.</p></li><li class="li"><p>Get the port associated with the Carbon window that you want to draw into by calling the Window Manager function <code><a href="../../../../Carbon/Reference/Window_Manager/Reference/reference.html#//apple_ref/doc/c_ref/GetWindowPort" target="_top">GetWindowPort</a></code>. After you attach a rendering context to the Carbon window, its viewport is set to the full size of the window.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH404-SW25" title="Note"></a><p><strong>Note:</strong>&nbsp;The AGL API for drawing to a Carbon window was developed prior to Mac OS X. Because of this heritage, the <code>AGLDrawable</code> data type is a <code>CGrafPtr</code> data type under the hood. That's why you must call <code><a href="../../../../Carbon/Reference/Window_Manager/Reference/reference.html#//apple_ref/doc/c_ref/GetWindowPort" target="_top">GetWindowPort</a></code> to obtain the associated graphics port from the <code>WindowRef</code> data type passed to <code>MySetWindowAsDrawableObject</code>.</p></div></li><li class="li"><p>Bind the window to the rendering context by passing the port to the function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglSetDrawable" target="_top">aglSetDrawable</a></code>.</p></li><li class="li"><p>Make the rendering context the current context by calling function <code>aglSetCurrentContext</code>.</p></li></ol><p><span class="content_text">Listing 2-10</span> shows how to implement these steps and how to check for errors along the way by calling the application-defined function <code>MySetWindowAsDrawableObject</code>. It's recommended that your application provides a similar error-checking function. In the case of an error you'll either want to notify the user and abort the program or take some sort of fallback action that ensures you application can draw OpenGL content. (See <span class="content_text"><a href="../opengl_pixelformats/opengl_pixelformats.html#//apple_ref/doc/uid/TP40001987-CH214-SW10">“Ensuring a Valid Pixel Format Object”</a></span> for an example of backing out of attributes. See <span class="content_text"><a href="../opengl_performance/opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW21">“Retrieve Error Information Only When Debugging”</a></span> for guidelines on error checking and performance.)</p><p>Note that the example passes the pixel format object returned from the <code>aglChoosePixelFormat</code> function to the function <code>aglCreateContext</code>. By default, AGL uses the first pixel format in the pixel format object regardless of how many pixel formats are actually in the object. You can iterate through the pixel format object using the function<code>aglNextPixelFormat</code>.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW4" title="Listing 2-10Setting a Carbon window as a drawable object"></a><p class="codesample"><strong>Listing 2-10&nbsp;&nbsp;</strong>Setting a Carbon window as a drawable object</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus MySetWindowAsDrawableObject  (WindowRef window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect rectPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    GLint attributes[] =  { AGL_RGBA,<span></span></pre></td></tr><tr><td scope="row"><pre>                        AGL_DOUBLEBUFFER,<span></span></pre></td></tr><tr><td scope="row"><pre>                        AGL_DEPTH_SIZE, 24,<span></span></pre></td></tr><tr><td scope="row"><pre>                        AGL_NONE };<span></span></pre></td></tr><tr><td scope="row"><pre>    AGLContext  myAGLContext = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    AGLPixelFormat myAGLPixelFormat;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    myAGLPixelFormat = aglChoosePixelFormat (NULL, 0, attributes);<span></span></pre></td></tr><tr><td scope="row"><pre>    err = MyAGLReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myAGLPixelFormat) {<span></span></pre></td></tr><tr><td scope="row"><pre>        myAGLContext = aglCreateContext (myAGLPixelFormat, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>        err = MyAGLReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (! aglSetDrawable (myAGLContext, GetWindowPort (window)))<span></span></pre></td></tr><tr><td scope="row"><pre>            err = MyAGLReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!aglSetCurrentContext (myAGLContext))<span></span></pre></td></tr><tr><td scope="row"><pre>            err = MyAGLReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus MyAGLReportError (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    GLenum err = aglGetError();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (AGL_NO_ERROR != err) {<span></span></pre></td></tr><tr><td scope="row"><pre>        char errStr[256];<span></span></pre></td></tr><tr><td scope="row"><pre>        sprintf (errStr, "AGL: %s",(char *) aglErrorString(err));<span></span></pre></td></tr><tr><td scope="row"><pre>        reportError (errStr);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err == AGL_NO_ERROR)<span></span></pre></td></tr><tr><td scope="row"><pre>        return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        return (OSStatus) err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH404-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;Although this example shows how to draw OpenGL content to an entire Carbon window, it is possible for Carbon applications to draw to a part of a window. Carbon developers can find additional information on using windows by reading <em><a href="../../../../Carbon/Conceptual/HandlingWindowsControls/index.html#//apple_ref/doc/uid/TP30001004" target="_top">Handling Carbon Windows and Controls</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40001987-CH404-SW1" title="What&#39;s Next"></a><h2>What's Next</h2><p>After you've successfully drawn OpenGL content onscreen from within  a Cocoa or a Carbon application, you'll want to move on to more complex tasks. Most 3D applications have sophisticated needs, especially with regard to performance and the need to ensure that the application works with a variety of graphics cards and displays. Some of the chapters that follow will  help you to fine tune your code. Other chapters provide guidance and code examples for accomplishing common tasks, such as checking for OpenGL functionality or using images as textures.</p><a name="//apple_ref/doc/uid/TP40001987-CH404-SW27" title="See Also"></a><h2>See Also</h2><p>OpenGL sample code projects (<span class="content_text"><a href="../../../../../referencelibrary/" target="_top">ADC Reference Library</a></span>):</p><ul class="ul"><li class="li"><p><em><a href="../../../../../samplecode/CocoaGL/index.html#//apple_ref/doc/uid/DTS10004501" target="_top">Cocoa OpenGL</a></em> sets up a window and handles events for drawing OpenGL content to a Cocoa view.</p></li><li class="li"><p><em><!--a target="_top" -->Custom Cocoa OpenGL<!--/a--></em> uses a custom view in Cocoa for OpenGL drawing.</p></li><li class="li"><p><em><!--a target="_top" -->GLCarbonAGLWindow<!--/a--></em> contains code that sets up a Carbon window for OpenGL drawing, handles events, and has a virtual trackball as well as a number of other features.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_pg_concepts/opengl_pg_concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_fullscreen/opengl_cgl.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_drawing/opengl_drawing.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_drawing/opengl_drawing.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_drawing/opengl_drawing.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>