<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>FireWire Device Interface Guide: FireWire on Mac OS X</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="FireWire on Mac OS X"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000969-CH201" title="FireWire on Mac OS X"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/FireWire-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000511" target="_top">FireWire</a> &gt; <a href="../FWDevIntro/FWDevintro.html#//apple_ref/doc/uid/TP40000969-CH205-BABGJCGG">FireWire Device Interface Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../FWDevIntro/FWDevintro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../FWDevAccess/FWDevAccess.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000969-CH201-TPXREF101" title="FireWire on Mac OS X"></a><h1>FireWire on Mac OS X</h1><p>FireWire is Apple’s implementation of the IEEE 1394 High Performance Serial Bus. Fast, hot-pluggable, and flexible, FireWire is a digital interface that supports daisy-chaining and branching for true peer-to-peer communication.</p><p>This chapter gives you a brief overview of FireWire. Then, it explains how the I/O Kit represents FireWire devices and describes the device interface libraries the IOFireWire family provides.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="FWDevOverview.html#//apple_ref/doc/uid/TP40000969-CH201-CCHJIHJG">FireWire Overview</a>
				
			<br/>
			
        
			
			
				<a href="FWDevOverview.html#//apple_ref/doc/uid/TP40000969-CH201-BBIDHAFI">In-Kernel FireWire Device Support</a>
				
			<br/>
			
        
			
			
				<a href="FWDevOverview.html#//apple_ref/doc/uid/TP40000969-CH201-CCHJFJEJ">IOFireWire Family Device Interface Libraries</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40000969-CH201-CCHJIHJG" title="FireWire Overview"></a><h2>FireWire Overview</h2><p>The FireWire bus appears as a large, 64-bit memory-mapped address space with each device, represented by a node, occupying a specific address range. The high-order 16 bits of each address identify the node and the remaining 48 bits are for device-specific use.</p><p>Because of FireWire’s hot-pluggable nature, the FireWire bus is by no means static. A bus reset occurs whenever nodes appear or disappear or when software initiates it. A bus reset signal erases the current topology of the bus and forces the nodes to reidentify and reconnect themselves. Although much of the logic to handle bus resets is at the device firmware level, your application must be ready to manage the affects of a bus reset at any point. In some cases, this may mean setting a flag in a command that requests it to retry after a bus reset. In others, however, you may have to perform significant device reconfiguration tasks in order to continue processing data.</p><p>FireWire supports two types of data transfer: Asynchronous and isochronous. Asynchronous transfer provides acknowledged, guaranteed delivery of data and is targeted to a specific node with an explicit address. If the data you’re sending is not error-tolerant, such as data written to a disk drive, asynchronous transfer is appropriate.</p><p>Isochronous transfer, on the other hand, is broadcast in a one-to-many or one-to-one manner. Before a node begins to send or receive isochronous data, it requests a particular amount of bandwidth and one or more isochronous channels. A channel can have one transmitter of data (or talker) and any number of receivers (or listeners). Isochronous transfers do not allow for error-checking or retransmission but they do deliver data at a constant, real-time rate. If you’re sending time-critical, error-tolerant data, such as a video stream, isochronous transfers are preferable.</p><p>As a medium for data transmission that defines how to move packets on the FireWire bus, FireWire does not specify any high-level communication protocol to use. Protocols are special sets of communication guidelines that simplify and standardize the data transmission between FireWire devices. Mac OS X supports user-space access for two protocols commonly used on FireWire: SBP-2 and AV/C.</p><p>The Serial Bus Protocol 2, or SBP-2, is a storage protocol used to efficiently transfer large amounts of data at high speed. Printers, scanners, and hard drives are typically SBP-2 devices. The SBP-2 protocol defines a data and command transaction entity called an ORB, or Operation Request Block. You use normal ORBs to send data and commands to your device and special management ORBs to perform device login and logout. The SBP-2 protocol sends ORBs using FireWire’s asynchronous data transport mode. You can get more information about the SBP-2 specification at <span class="content_text"><a href="http://t10.org" target="_blank">http://t10.org</a></span>.</p><p>The Audio/Video Control, or AV/C, protocol defines a command set used to control devices such as video recorders and digital cameras. Like SBP-2, the AV/C protocol uses FireWire’s asynchronous data transport mode. An AV/C command or response is first encapsulated in a Function Control Protocol (or FCP) frame. Then, a FireWire write or block write transaction transports the FCP frame to and from the device.</p><p>The AV/C protocol uses the concept of a plug to describe an end-point of a connection an AV/C unit implements to receive or transmit data. Plugs can be external, physical plugs on the device itself, internal, virtual plugs the AV/C unit implements, or serial bus plugs that are accessible through the plug control registers (or PCRs). For more information about the AV/C specification, see <span class="content_text"><a href="http://www.1394ta.org" target="_blank">http://www.1394ta.org</a></span>.</p><p>A Digital Video (or DV) device, such as a DV camcorder, implements a subunit of the AV/C specification. If you want to communicate with a DV camcorder, you should use the QuickTime APIs Mac OS X provides. QuickTime supplies APIs and components to encode and decode DV data, communicate with a DV device, and handle video digitizing. For more information on QuickTime, see <span class="content_text"><!--a target="_top" -->Reference Library > QuickTime<!--/a--></span>. In <span class="content_text"><a href="../FWDevInterfaces/FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHDEBJH">“Using the IOFireWireAVCLib,”</a></span> this document describes how to communicate with AV/C devices that are not DV camcorders.</p><a name="//apple_ref/doc/uid/TP40000969-CH201-BBIDHAFI" title="In-Kernel FireWire Device Support"></a><h2>In-Kernel FireWire Device Support</h2><p>In the kernel, several layers of objects represent each FireWire device. For each FireWire hardware interface on the Macintosh, such as FireWire OHCI (or Open Host Controller Interface), the IOFireWire family publishes an IOFireWireController object in the I/O Registry. The IOFireWireController object provides bus management services for the multiple devices and protocols that can exist on one FireWire hardware interface. </p><p>The IOFireWire family then tries to read the configuration ROM of each device on the bus. A device’s configuration ROM (or config ROM) contains information such as device identification and addresses of various registers. For each device that responds with its bus information block, the IOFireWire family publishes an IOFireWireDevice object in the I/O Registry. The IOFireWireDevice object keeps track of the device’s node ID (which can change with the dynamic reconfiguration of the bus) and it copies properties from the device’s configuration ROM, such as the device’s globally unique identification (or GUID), into its property list. Most importantly, however, the IOFireWireDevice object scans the configuration ROM for unit directories. For each unit directory it finds, it publishes an IOFireWireUnit object in the I/O Registry. <span class="content_text">Figure 1-1</span> shows the stack of objects instantiated for a FireWire unit.</p><br/><div><a name="//apple_ref/doc/uid/TP40000969-CH201-CCHDBIHC" title="Figure 1-1In-kernel objects supporting a FireWire unit"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>In-kernel objects supporting a FireWire unit</p><img src = "../art/firewire.gif" alt = "In-kernel objects supporting a FireWire unit" width="247" height="211"></div><br/><p>The IOFireWireUnit object copies properties from the device’s unit into its property list in the I/O Registry. The I/O Kit uses these properties to enable matching on a specific unit specification ID and unit software version. When an SBP-2 unit appears in the I/O Registry, for example, the IOFireWireSBP2 kernel extension (or KEXT) matches on it and loads. The IOFireWireSBP2 family then publishes an IOFireWireSBP2Target object that scans the configuration ROM and publishes an IOFireWireSBP2LUN object for each logical unit (or LUN) it finds.</p><p>For AV/C units, the process is similar: The IOFireWireAVC KEXT matches an AV/C unit and publishes an IOFireWireAVCUnit object in the I/O Registry for it.</p><a name="//apple_ref/doc/uid/TP40000969-CH201-CCHJFJEJ" title="IOFireWire Family Device Interface Libraries"></a><h2>IOFireWire Family Device Interface Libraries</h2><p>The same device and unit properties the I/O Kit uses for in-kernel driver matching are available to you for application-level device matching (described in <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHFHJDE">“Device Matching for FireWire Devices”</a></span>). Because many devices, such as scanners, digital cameras, and printers, are better driven from applications, you can use the device interfaces the IOFireWire family provides to access them. Nearly all services available to in-kernel drivers are also available to an application through one of the IOFireWire family’s device interfaces.</p><p>To communicate with FireWire devices or units from an application, the IOFireWire family provides three libraries that each include several device interfaces:</p><ul class="ul"><li class="li"><p>IOFireWireLib for standard FireWire commands and isochronous communication</p></li><li class="li"><p>IOFireWireSBP2Lib for sending ORBs to an SBP-2 unit and managing login status</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000969-CH201-DontLinkElementID_10" title="Note"></a><p><strong>Note:</strong>&nbsp;If your device conforms to the SBP-2 specification and complies with the SCSI Architecture Model SCSI Primary Commands specification (both available at <span class="content_text"><a href="http://t10.org" target="_blank">http://t10.org</a></span>), you should consider using the SCSI Architecture Model family device interfaces, described in <em><a href="../../WorkingWithSAM/index.html#//apple_ref/doc/uid/TP40000971" target="_top">SCSI Architecture Model Device Interface Guide</a></em>.</p></div></li><li class="li"><p>IOFireWireAVCLib for sending AV/C commands to an AV/C unit</p></li></ul><p>The header files for all three libraries are part of <code>IOKit.framework</code>, located in <code>/System/Library/Frameworks</code>. In your application, you link against <code>IOKit.framework</code> to get access to these libraries.</p><a name="//apple_ref/doc/uid/TP40000969-CH201-TPXREF102" title="IOFireWireLib Device Interfaces"></a><h3>IOFireWireLib Device Interfaces</h3><p>The IOFireWireLib is a library of device interfaces that give applications access to both standard FireWire device functions and isochronous communication. The IOFireWireLib provides the lowest-level FireWire interfaces available in user space, allowing you to browse the configuration ROM of an external device, send commands, and perform FireWire bus operations. IOFireWireLib also gives you control of isochronous communication with a FireWire device by providing an interface that allows you to open a channel object and send and receive isochronous data. <span class="content_text">Figure 1-2</span> shows the interfaces available in the IOFireWireLib.</p><br/><div><a name="//apple_ref/doc/uid/TP40000969-CH201-CCHBEFBH" title="Figure 1-2IOFireWireLib device interfaces"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>IOFireWireLib device interfaces</p><img src = "../art/interfacehierarchy01.gif" alt = "IOFireWireLib device interfaces" width="280" height="194"></div><br/><p>In order to use the other interfaces in the IOFireWireLib, you must first get an instance of the primary interface, IOFireWireDeviceInterface. The IOFireWireDeviceInterface includes functions that allow you to communicate directly with a device and methods that create the other interfaces listed in <span class="content_text">Figure 1-2</span>. You can get an IOFireWireDeviceInterface for a FireWire device or even the local node (defined to be the Macintosh itself). <span class="content_text">Figure 1-3</span> shows how an application uses an instance of the IOFireWireDeviceInterface to communicate with a device on the FireWire bus.</p><br/><div><a name="//apple_ref/doc/uid/TP40000969-CH201-CCHDGIBA" title="Figure 1-3Using the IOFireWireDeviceInterface"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Using the IOFireWireDeviceInterface</p><img src = "../art/fwireinterface.gif" alt = "Using the IOFireWireDeviceInterface" width="247" height="270"></div><br/><p>When you have an instance of the IOFireWireDeviceInterface, you can:</p><ul class="spaceabove"><li class="li"><p>Perform a FireWire bus reset</p></li><li class="li"><p>Create FireWire command object interfaces to perform asynchronous read, write and lock operations</p></li><li class="li"><p>Create an isochronous interface that provides isochronous services, such as creating and managing isochronous channels and sending and receiving isochronous data</p></li><li class="li"><p>Create other interfaces that provide miscellaneous services, such as managing local unit directories in the Macintosh and accessing and browsing remote device configuration ROMs</p></li></ul><p>You can also use the IOFireWireLib services and interfaces in conjunction with interfaces from the other two FireWire device interface libraries. <span class="content_text"><a href="FWDevOverview.html#//apple_ref/doc/uid/TP40000969-CH201-CCHIBDEG">Figure 1-5</a></span> and <span class="content_text"><a href="FWDevOverview.html#//apple_ref/doc/uid/TP40000969-CH201-CCHBDIIE">Figure 1-7</a></span> show how an application can use the IOFireWireDeviceInterface in cooperation with interfaces from other libraries. For more information on how to do this, see <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHJACIJ">“Getting Multiple FireWire Device Interfaces.”</a></span> For code samples that illustrate how to use various FireWire device interfaces, see <span class="content_text"><a href="../FWDevInterfaces/FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-TPXREF101">“Using the FireWire Device Interface Libraries.”</a></span></p><a name="//apple_ref/doc/uid/TP40000969-CH201-TPXREF103" title="IOFireWireSBP2Lib Device Interfaces"></a><h3>IOFireWireSBP2Lib Device Interfaces</h3><p>The IOFireWireSBP2Lib is a library of interfaces and functions that allow you to control the SBP-2 functions of your device. <span class="content_text">Figure 1-4</span> shows the interfaces of the IOFireWireSBP2Lib.</p><br/><div><a name="//apple_ref/doc/uid/TP40000969-CH201-CCHFDIBB" title="Figure 1-4IOFireWireSBP2Lib interfaces"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>IOFireWireSBP2Lib interfaces</p><img src = "../art/interfacehierarchy02.gif" alt = "IOFireWireSBP2Lib interfaces" width="281" height="118"></div><br/><p>To use the SBP-2 functions the IOFireWireSBP2Lib provides, you first acquire the primary interface, IOFireWireSBP2LibLUNInterface, which supplies the methods that control the operation of the logical unit (or LUN) as a whole. When you have the IOFireWireSBP2LibLUNInterface, you can get two other interfaces:</p><ul class="spaceabove"><li class="li"><p>The IOFireWireSBP2LibLoginInterface, which supplies methods that control the behavior and execution of an SBP-2 login session, including the execution of ORBs</p></li><li class="li"><p>The IOFireWireSBP2LibMgmtORBInterface, which provides methods that configure and append nonlogin–related management functions</p></li></ul><p>The IOFireWireSBP2LibLoginInterface itself provides another interface, the IOFireWireSBP2LibORBInterface, that supplies the methods for configuring normal command ORBs.</p><p>The IOFireWireSBP2Lib handles device communication at the SBP-2 protocol level. In other words, it is concerned mostly with sending and receiving ORBs and managing login sessions. It does not include interfaces that allow you to communicate directly with the device. If you need to send commands to the device itself, for example, to read the configuration ROM or to service additional functionality beyond the scope of SBP-2, you must use the IOFireWireDeviceInterface of the IOFireWireLib (for more information on how to do this, see <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHJACIJ">“Getting Multiple FireWire Device Interfaces”</a></span>).</p><p><span class="content_text">Figure 1-5</span> shows an application using the IOFireWireSBP2LibLUNInterface to communicate with the logical unit of a FireWire SBP-2 device and, optionally, using the IOFireWireDeviceInterface to communicate with the device.</p><br/><div><a name="//apple_ref/doc/uid/TP40000969-CH201-CCHIBDEG" title="Figure 1-5Using the IOFireWireSBP2LibLUNInterface and IOFireWireDeviceInterface"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Using the IOFireWireSBP2LibLUNInterface and IOFireWireDeviceInterface</p><img src = "../art/sbp2interface.gif" alt = "Using the IOFireWireSBP2LibLUNInterface and IOFireWireDeviceInterface" width="353" height="347"></div><br/><a name="//apple_ref/doc/uid/TP40000969-CH201-TPXREF104" title="IOFireWireAVCLib Device Interfaces"></a><h3>IOFireWireAVCLib Device Interfaces</h3><p>The IOFireWireAVCLib is a library of interfaces and functions that you can use to send AV/C commands to an AV/C unit. <span class="content_text">Figure 1-6</span> shows the interfaces in the IOFireWireAVCLib.</p><br/><div><a name="//apple_ref/doc/uid/TP40000969-CH201-SW1" title="Figure 1-6IOFireWireAVCLib interfaces"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>IOFireWireAVCLib interfaces</p><img src = "../art/interfacehierarchy03.gif" alt = "" width="281" height="79"></div><br/><p>The IOFireWireAVCLib supplies two interfaces to handle AV/C units and commands: the IOFireWireAVCLibProtocolInterface and the IOFireWireAVCLibUnitInterface. Unlike the device interfaces in the IOFireWireLib and IOFireWireSBP2Lib, these device interfaces are not dependent on each other in any way. You can get either the IOFireWireAVCLibProtocolInterface or the IOFireWireAVCLibUnitInterface or both, according to what you need to accomplish. Because they are both primary interfaces, you do not need to get one before the other.</p><p>In addition, the IOFireWireAVCLib supplies a limited interface that supports a subset of asynchronous connection functionality. The IOFireWireAVCLibConsumerInterface is based on the assumption that the controller node is built into the consumer node, and that this dual entity is implemented in the Macintosh. The functions in the IOFireWireAVCLibConsumerInterface support creating an asynchronous connection to a producer, sending commands to the producer, and receiving data from the producer. The IOFireWireAVCLibConsumerInterface does not support any other configuration of the consumer, controller, and producer nodes and does not allow the consumer/controller pair to receive commands.</p><p>The IOFireWireAVCLibProtocolInterface allows your application to treat the Macintosh as an AV/C device and access its plug control registers (or PCRs). To access the PCRs of an external FireWire device, you need to use the IOFireWireDeviceInterface. Because the IOFireWireAVCLibProtocolInterface is specifically for accessing the Macintosh as an AV/C device, you can open it only on the local node. With the IOFireWireAVCLibProtocolInterface, you can:</p><ul class="spaceabove"><li class="li"><p>Allocate and deallocate input and output plugs</p></li><li class="li"><p>Read the current value of input and output plugs</p></li><li class="li"><p>Register callbacks for AV/C commands sent to the Macintosh and for bus reset and reconnect messages</p></li><li class="li"><p>Update the value of input and output plugs, simulating lock transactions</p></li></ul><p>The IOFireWireAVCLibUnitInterface supplies functions that issue AV/C commands to an AV/C unit. Beginning in Mac OS X v10.4, the IOFireWireAVCLibUnitInterface includes functions that support asynchronous AV/C commands (not to be confused with AV/C asynchronous connections). You can use the asynchronous command functions to, for example, receive notifications when a user adjusts a switch on the device you're communicating with. Because the asynchronous commands are part of the IOFireWireAVCLibUnitInterface, you do not have to acquire a separate interface object to use them.</p><p>As with the IOFireWireSBP2LibLUNInterface, you can use both an IOFireWireAVCLibUnitInterface and an IOFireWireDeviceInterface to control the AV/C unit as well as the device object. For more information on how to do this, see <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHJACIJ">“Getting Multiple FireWire Device Interfaces.”</a></span> </p><p><span class="content_text">Figure 1-7</span> shows an application using the IOFireWireAVCLibUnitInterface, the IOFireWireAVCLibProtocolInterface, and, optionally, the IOFireWireDeviceInterface.</p><br/><div><a name="//apple_ref/doc/uid/TP40000969-CH201-CCHBDIIE" title="Figure 1-7Using the IOFireWireAVCLib interfaces and IOFireWireDeviceInterface"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>Using the IOFireWireAVCLib interfaces and IOFireWireDeviceInterface</p><img src = "../art/avcinterface.gif" alt = "Using the IOFireWireAVCLib interfaces and IOFireWireDeviceInterface" width="521" height="323"></div><br/>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../FWDevIntro/FWDevintro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../FWDevAccess/FWDevAccess.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WorkingWFireWireDI/FWDevOverview/FWDevOverview.html%3Fid%3DTP40000969-3.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WorkingWFireWireDI/FWDevOverview/FWDevOverview.html%3Fid%3DTP40000969-3.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WorkingWFireWireDI/FWDevOverview/FWDevOverview.html%3Fid%3DTP40000969-3.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>