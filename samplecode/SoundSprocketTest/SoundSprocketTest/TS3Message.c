/* *	File:		TS3Message.c * *	Copyright © 1996 Apple Computer, Inc. */#include <assert.h>#include <string.h>#include <Dialogs.h>#include <SegLoad.h>#include "SoundSprocket.h"#include "TS3Message.h"#include "TS3Resource.h"typedef struct TMessageIgnore {	struct TMessageIgnore*	next;		OSStatus				err;	unsigned long			line;		char					func[64];} TMessageIgnore;typedef struct TMessageError {	OSStatus				err;	char*					msg;} TMessageError;static TMessageIgnore*		gMessageIgnore = NULL;static TMessageError		gMessageError[] = {	{kSSpInternalErr,			"kSSpInternalErr"},	{kSSpVersionErr,			"kSSpVersionErr"},	{kSSpCantInstallErr,		"kSSpCantInstallErr"},	{kSSpParallelUpVectorErr,	"kSSpParallelUpVectorErr"},	{kSSpScaleToZeroErr,		"kSSpScaleToZeroErr"},	{0,							NULL}};/* ============================================================================= *		Message_Init (external) * *	Initializes our message thing. * ========================================================================== */void Message_Init(	void){}/* ============================================================================= *		Message_Exit (external) * *	Cleans up. * ========================================================================== */void Message_Exit(	void){	//¥ TODO: Dispose the "ignore" list}/* ============================================================================= *		_Message_CheckError (external) * *	If inErr is not noErr, then an alert is posted with Continue and Quit *	buttons. * ========================================================================== */void _Message_CheckError(	OSStatus			inErr,	const char*			inInRoutine,	const char*			inFromRoutine,	const char*			inFile,	unsigned long		inLine){	TMessageIgnore*		ignore;	TMessageError*		messageError;	char				errorText[64];	Str255				message;		if (inErr == noErr)  return;		// Check our "ignore" list	ignore = gMessageIgnore;	while (ignore != NULL)	{		if (ignore->err		== inErr		&&			ignore->line	== inLine		&&			strcmp(ignore->func, inInRoutine) == 0)		{			return;		}		else		{			ignore = ignore->next;		}	}		// See if we know the name of the beast from the number of the beast	messageError = gMessageError;	while (messageError->err != 0 &&		   messageError->err != inErr)	{		messageError += 1;	}		// Make a string from the error message	if (messageError->msg != NULL)	{		sprintf(errorText, "%s (%ld)", messageError->msg, inErr);	}	else	{		sprintf(errorText, "%ld", inErr);	}		// Format the message	sprintf((char*) message, "xError %s returned by %s.  Called from %s at line %ld of Ò%sÓ.",			errorText,			inFromRoutine,			inInRoutine,			inLine,			inFile);		message[0] = strlen((char*) message) - 1;		// Put up the alert and handle the results	ParamText(message, NULL, NULL, NULL);		switch (StopAlert(kAlrtID_Error, NULL))	{		case kErrorItem_Continue:			// do nothing		break;				case kErrorItem_Ignore:			// Add to our list of errors to ignore			ignore = (TMessageIgnore*) NewPtr(sizeof(TMessageIgnore));			assert(ignore != NULL);						ignore->next = gMessageIgnore;			gMessageIgnore = ignore;						ignore->err = inErr;			ignore->line = inLine;						assert(strlen(inInRoutine) < 64);			strcpy(ignore->func, inInRoutine);		break;				case kErrorItem_Quit:			// Goodbye			ExitToShell();		break;				default:			assert(0);	}}