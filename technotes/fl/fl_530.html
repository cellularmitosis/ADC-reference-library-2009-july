<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note FL530: File Manager Volume Handling Q&amp;As</title><meta name="keywords" content="Mac OS 8 File Manager Volume PBGetVolMountInfoSize  PBGetVolMountInfo dskFulErr ioVAtrb"><meta name="Description" content="Technical Note FL530: This Technical Note contains a collectionof archived Q&amp;As relating to File Manager Volume Handling--questionssent the Developer Support Center (DSC) along with answersfrom the DSC engineers. Archived Q&amp;As include: How many volumescan be mounted at Boot Time; Why code crashes when it callsPBGetVolMountInfoSize and PBGetVolMountInfo; What happenswhen you call FSWrite and the disk is full; How to determineif a volume is locked from ioVAtrb bit 7 and bit 15; Howto distinguish between vRefNums and WDRefNums; How to unlocka Volume; and Why a Macintosh driver receives a positivedrive number upon notification of an _Eject call."><meta name="categories" content="Files"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002469" title="File Manager Volume Handling Q&As"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxFileManagement-date.html" target="_blank">Carbon > File Management</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note FL530</div>
<div id="pageheadsub">File Manager Volume Handling Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext">					<A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specific topic--questions sent the Developer Support Center (DSC) along withanswers from the DSC engineers. Current Q&amp;As can be found on the <a href="../../qa/index.html">Macintosh Technical Q&amp;As web site</a>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><h2>20 mounted volume limitation</h2><p>Date Written:</p><p>Last reviewed: </p><p>How many mounted volumes does the Macintosh support? I've heard that duringstartup the Macintosh mounts only the first 20. I'm writing a system extensionthat will boot additional volumes because we need them to be available when thesystem starts up. Mounting the extra volumes is no problem but once inside anapplication going to the desktop in an open dialog freezes the applications. Isthere any documentation of this problem or this topic?</p><p>___</p><p>The reason all the disk partitions aren't mounted at boot time is an EventManager limitation. The Event Manager can queue only 20 events. Depending onwhat else is going on at boot time that might post an event (or events), you'llprobably get only somewhere between 15 and 20 volumes mounted.</p><p>The lockup/crash problem is caused by a Standard File limitation. Standard File(under System 7) works only with up to 20 mounted volumes. Any more than thatand Standard File trashes its own local variables. We've filed a bug reportagainst Standard File for this behavior. The Radar bug system number for thisis #1070708 if you need to refer to it in the future.</p><p>As a workaround until the Standard File limitation is fixed, you can use sharedfolders to reduce the number of mounted volumes on an AppleShare server.</p><h2>PBGetVolMountInfoSize &amp; PBGetVolMountInfo doc fix</h2><p>Date Written:  2/3/93</p><p>Last reviewed:  6/14/93</p><p>Our code crashes when we call <code>PBGetVolMountInfoSize</code> or <code>PBGetVolMountInfo</code>. Aretheir parameter blocks correctly defined in <i><cite>Inside Macintosh: Files</cite>?</i></p><p>___</p><p>The documentation is missing a parameter for both calls; <code>ioNamePtr</code> (type<code>StringPtr</code>) should follow <code>ioResult</code> in the parameter block description. With<code>PBGetVolMountInfoSize</code>, <code>PBGetVolMountInfo</code>, <code>PBHGetLogInInfo</code>, and any other FileManager call where you specify the volume reference number as an input,<code>ioNamePtr</code> must either point to the volume name, or be set to NIL.</p><p>In <i><cite>Inside Macintosh: Files</cite>,</i> page 2-220, and <i>Inside Macintosh</i>Volume VI, page 25-48, the parameter block passed to PBGetVolMountInfoSizeshould look like this:</p><p>Parameter block</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>-&gt;  ioCompletion  LongInt    A pointer to a completion routine.&lt;-  ioResult      OSErr      The function's result code.-&gt;  ioNamePtr     StringPtr  A pointer to the volume's name.-&gt;  ioVRefNum     Integer    A volume specification.-&gt;  ioBuffer      LongInt    A pointer to storage for size.</pre>	</TD></TR></TABLE></CENTER><p>In <i><cite>Inside Macintosh: Files</cite>,</i> page 2-220, and <i>Inside Macintosh</i>Volume VI, page 25-48, the parameter block passed to PBGetVolMountInfo shouldlook like this:</p><p>Parameter block</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>-&gt;  ioCompletion  LongInt    A pointer to a completion routine.&lt;-  ioResult      OSErr      The function's result code.-&gt;  ioNamePtr     StringPtr  A pointer to the volume's name.-&gt;  ioVRefNum     Integer    A volume specification.-&gt;  ioBuffer      LongInt    A pointer to mounting information.</pre>	</TD></TR></TABLE></CENTER><h2>FSWrite and error handling for dskFulErr</h2><p>Date Written:  10/9/92</p><p>Last reviewed:  6/14/93</p><p>If I call <code>FSWrite</code> and attempt to write more than space allows, what happens? Ofcourse I get a Disk Full error, but does <code>FSWrite</code> write as much as possible before quitting, and then return the number of bytes written in the count parameter?</p><p>___</p><p>In the current implementation of the file system, writes to local volumes ownedby the file system are an all-or-nothing deal. If the space for a write can'tbe allocated, the write call fails and no bytes are written.</p><p>However, do not depend on that, because the Macintosh file system doesn'tcontrol all volumes that might be mounted. Today, Apple ships four externalfile systems: CD-ROM, AppleShare, ProDOS File System (for Apple II ProDOSvolumes), and PC Exchange (for MS-DOS volumes). Various third parties havewritten other external file systems. The way they react to error conditions maynot be the same as local volumes controlled entirely by the file system.</p><p>To make your application always work correctly, you should check for errors andhandle them appropriately. If you get a <code>dskFulErr</code>, you should assume that ifany information was written to the file, it wasn't written correctly. Youshould either reset the file's EOF to its previous position (if you'reappending to an existing file) or delete the file (if you had just created thefile and were writing to it for the first time).</p><h2>PBHSetVolParms volume attribute bits</h2><p>Date Written:  7/29/92</p><p>Last reviewed:  3/1/93</p><p>I'd like to change <code>PBHGetVolParms</code> fields such as <code>vMVolumeGrade</code> and <code>vMAttrib</code>(especially <code>bNoBootBlks</code> and <code>bNoSysDir</code>). In addition, I want a way to prevent avolume from being shared. How can I set this up? Is there something I need toset up in my driver's format call?</p><p>___</p><p>A disk driver has no say in what volume attribute bits are returned by<code>PBHGetVolParms</code>. The volume attributes are determined by the file system thathandles a particular volume. So, a disk driver cannot set or clear specificvolume attribute bits.</p><p>The System 7 file system sets these three volume attribute bits on every localHFS volume: <code>bHasCatSearch</code>, <code>bHasFileIDs</code>, and <code>bHasBTreeMgr</code>. In addition to thosethree bits, the <code>bHasDesktopMgr</code> bit is set on local HFS volumes if they areeither nonejectable or ejectable but bigger than 2 Mb. The volume attributebits, <code>bLimitFCBs</code>, <code>bNoVNEdit</code>, <code>bAccessCntl</code>, <code>bHasOpenDeny</code>, <code>bHasShortName</code>,<code>bHasFolderLock</code>, <code>bHasPersonalAccessPrivileges</code>, <code>bHasUserGroupList</code>, and<code>bHasBlankAccessPrivileges</code>, are set on local shared volumes by Macintosh FileSharing or AppleShare 3.0 when the file service is on.</p><p>An example of an external file system is AppleShare. For AppleShare volumes,the AppleShare external file system sets these volume attribute bits:<code>bLimitFCBs</code>, <code>bLocalWList</code>, <code>bNoMiniFndr</code>, <code>bNoVNEdit</code>, <code>bNoLclSync</code>, <code>bTrshOffLine</code>,<code>bNoSwitchTo</code>, <code>bNoDeskItems</code>, <code>bNoBootBlks</code>, <code>bAccessCntl</code>, <code>bNoSysDir</code>, <code>bHasExtFSVol</code>,<code>bHasOpenDeny</code>, <code>bHasCopyFile</code>, <code>bHasMoveRename</code>, <code>bHasDesktopMgr</code>, <code>bHasShortName</code>,<code>bHasFolderLock</code>. AppleShare volumes that support AFP 2.1 also have these volumeattribute bits set: <code>bHasCatSearch</code>, <code>bHasFileIDs</code>, <code>bHasBlankAccessPrivileges</code>.</p><p>There isn't a way to keep a volume from being shared if it's mounted whenMacintosh File Sharing or AppleShare starts up. The file system doesn't givethe file servers a way to tell which volumes should not be shared, so the fileservers uses this method:</p><ul type="circle">	<li>If volume's signature &lt;&gt; $4244 (hierarchical directory volume), then the volume is not sharable.</li>	<li>If volume's driver reference number = $fffb (the .SONY driver), then the volume is not sharable.</li>	<li>If the volume is a volume controlled by our AFP code, then the volume is not sharable.</li></ul><p>As you can see, your disk driver doesn't have control over any of that.</p><h2>ioVAtrb bit 7 and bit 15 locked volume bits</h2><p>Date Written:  8/15/90</p><p>Last reviewed:  6/14/93</p><p>I want to determine whether a disk is locked before trying to mount the volume.When I examine bit 15 of ioVAtrb using <code>PBGetVInfo</code>, as suggested on page 104 of<i>Inside Macintosh</i> Volume II, bit 15 is clear for a locked volume such asa CD-ROM, but bit 7 is set. Why is this happening?</p><p>___</p><p>The reason for your observed discrepancy is that bit 15 is set for a softwarelock and bit 7 is set for a hardware lock. In the case of the CD-ROM there's nosoftware lock but only a hardware lock, so bit 7 is set and bit 15 is clear.Volumes II and IV of <i>Inside Macintosh</i> both say that "only bit 15 can bechanged" and should be set if the volume is locked. The fact that you can setit with <code>PBSetVol</code> means that it's a software lock. What the documentation failsto mention is that using <code>PBGetVInfo</code> you can also check bit 7 of <code>ioVAtrb</code> to seeif there's a hardware lock. The recommended procedure is to first check thehardware lock (bit 7 of <code>ioVAtrb</code>) and then check the software lock (bit 15 of ioVAtrb).</p><h2>How to display mounted volumes in a dialog box</h2><p>Date Written:  11/1/90</p><p>Last reviewed:  6/14/93</p><p>In a MacApp Pascal program, how can I display all mounted volumes in a dialogbox including each volume's icon and name (similar to the way the Finderdisplays volumes)? I cannot get the resource ID of the icons.</p><p>___</p><p><i>Inside Macintosh</i> IV-223 and V-469 describe how to read a volume's ICON."The Disc Driver" discusses <code>csCode</code>=21, which you can use to make specialcontrol calls that will work for all drives to get icon and other information.The Technote "What Your Sony Drives for You," describes how to make floppycalls if necessary. The <code>csCode</code> control call should work for you.</p><h2>Distinguishing between Macintosh vRefNums and WDRefNums</h2><p>Date Written:  12/3/90</p><p>Last reviewed:  6/14/93</p><p>How do I find the real Macintosh <code>vRefNum</code> and real <code>dirID</code>? If I pass a workingdirectory to <code>PBHGetFInfo</code>, will the <code>ioDirID</code> field return a real dirID? Will the<code>ioVRefNum</code> field contain the working directory I passed in or the real <code>vRefNum</code>?Also, if I pass a real <code>vRefNum</code> to <code>GetWDInfo</code>, will it do nothing and yet returnno error?</p><p>___</p><p>Here's the way to tell the difference between vRefNums and WDRefNums (copiedfrom the Macintosh Technical Note <A HREF = "fl_22.html">"HFS Ruminations"</a>:</p><p> A <code>vRefNum</code> is a small negative word (e.g. $FFFE).</p><p>A <code>WDRefNum</code> is a large negative word (e.g. $8033).</p>    <p>A <code>dirID</code> is a long word (for example, 38).  The root directory of an HFS volume always has a dirID of 2.</p><p>When you pass a real <code>vRefNum</code> into <code>GetWDInfo</code>, it will look at the <code>ioWDIndex</code>field in the <code>WDPBPtr</code> and return information about the corresponding workingdirectory on that volume (<i>Inside Macintosh</i> Volume IV, page 159). You canalso specify an <code>ioWDProcID</code> and <code>GetWDInfo</code> will only index through WorkingDirectories on the specified volume with the specified proc ID.</p><p><code>PBHGetFInfo</code> will not return a valid <code>dirID</code> and <code>vRefNum</code> if you pass it a workingdirectory; if you want that information you should pass the WDRefNum to<code>PBGetWDInfo</code> in <code>ioVRefNum</code> (making sure you set <code>ioWDIndex</code> to zero).</p><p>Remember that working directories are provided simply to facilitatecompatibility between HFS and programs that were written under MFS. You shouldbe converting working directories to their corresponding <code>VRefNum</code> and <code>dirID</code>pairs before using them with your PBH variant calls.</p><h2>Technique for maintaining up-to-date list of Macintosh volumes</h2><p>Date Written:  6/7/91</p><p>Last reviewed:  6/14/93</p><p>How can my Macintosh application maintain an up-to-date list of active volumes?Is there a way to detect if a volume is ejected?</p><p>___</p><p>No event is posted, and no other notification is available for when a volume isejected. The best way of keeping your list of volumes up to date is to indexperiodically through all mounted volumes with <code>PBHGetVInfo</code> or <code>PBGetVInfo</code> andcross-check them against your program's most up-to-date list of volumes.</p><p>It's probably best to do this check also on every resume event, in case theuser ejects a disk while in the Finder. The periodic check is still necessary,however, in case a Desk Accessory in your own heap ejects a disk or the userhits command-shift-1 or 2. Since you probably don't want to check every callthrough <code>WaitNextEvent</code>, just keep track of the last time you updated the volumelist and compare it to <code>TickCount</code>.</p><h2>Unlocking a Macintosh volume</h2><p>Date Written:  6/14/91</p><p>Last reviewed:  11/19/91</p><p><code>PBSetVInfo</code> failed to reset a software lock bit that had been set using<code>PBSetVInfo</code>, because the volume was, of course, locked. How do you allow avolume to be unlocked?</p><p>___</p><p>DTS discourages developers from locking and unlocking volumes through softwarebecause it's not readily apparent to users. Many users are aware only of thephysical reasons that they would be prevented from modifying a disk. Forexample, it's easy to identify CD-ROMs and locked floppies as unchangeable.</p><p>Additionally, the Finder caches the contents of its windows, so a change in thelocked status of a volume may not be reflected immediately. An unlocked volumemay still show a lock icon in its window, misleading users into thinking thatthe particular volume is still protected. For these reasons, we recommend thatvolumes not be locked by software.</p><p>If you need to software lock a volume, be sure it's done only after explicitlywarning the user that the disk will be locked and providing an opportunity tocancel the operation.</p><p>Locking a volume is done by calling <code>PBSetVInfo</code> with bit 15 of the <code>ioVAtrb</code> fieldset. However, this creates a Catch-22 in that you can't make the call to unlockthe disk. To override the locked status for the volume and unlock it, you mustwalk the volume-control-block queue in memory and clear the lock bit for thedrive, as shown in the following code:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>USES Files, Errors;FUNCTION SoftwareVolumeUnlock(targetVRefNum: INTEGER): OSErr;    TYPE VCBPtr = ^VCB;    VAR        theVCBQHdrPtr: QHdrPtr;        myVCBPtr: VCBPtr;    BEGIN        theVCBQHdrPtr := GetVCBQHdr;        myVCBPtr := VCBPtr(theVCBQHdrPtr^.qHead);        WHILE (myVCBPtr &lt;&gt; NIL) AND                (myVCBPtr^.vcbVRefNum &lt;&gt; targetVRefNum) DO            myVCBPtr := VCBPtr(myVCBPtr^.qLink);        IF myVCBPtr^.vcbVRefNum = targetVRefNum THEN            BEGIN                { clear locked bit }                myVCBPtr^.vcbAtrb := BAND(myVCBPtr^.vcbAtrb, $7FFF);                { write change to disk }                SoftwareVolumeUnlock := FlushVol(NIL, targetVRefNum)            END        ELSE SoftwareVolumeUnlock := nsvErr { volume not found }    END;</pre>	</TD></TR></TABLE></CENTER><p>The VCB queue and volume attributes are discussed under "Volume Control Blocks"in the File Manager chapter of <i>Inside Macintosh</i> Volume IV.</p><h2>Booting a write-protected disk under System 7</h2><p>Date Written:  9/18/91</p><p>Last reviewed:  10/15/91</p><p>How do I boot a write-protected disk under System 7? It seems that theMacintosh operating system tries to write/modify the desktop file and I get anerror message telling me to write-enable the disk.</p><p>___</p><p>Every Macintosh has been equipped with the ability for users to boot from bothwrite-protected as well as writeable disks, all the way back to the firstmachine introduced in 1984. This didn't change with System 7; in fact, theoperating system has only an indirect impact on this capability. The only thingyou can't do from a write-protected boot disk is use the Chooser because theO/S needs to be able to write back the preferences for whatever you do in the Chooser.</p><p>You might be encountering the error you described because of desktop changes:Since the desktop file was obsoleted in System 7, which now uses the DesktopManager instead, diskettes that are mastered on a System 7 machine theninserted into another machine running 6.0.x must have a desktop file created.(This does not apply to diskettes that you're trying to boot from; rather, whenyou insert the disk into a machine already running 6.0.x.) When this situationis encountered, the user is presented with the now familiar dialog to theeffect that the disk needs minor repairs (in fact, it needs a desktop file). Ifyou say OK to this dialog, the desktop file will be created and all will bewell. All this leads up to how (not) to treat diskettes mastered under System7: If you drag a series of files to a floppy disk (from a System 7 machine),immediately eject and lock it, then try to boot from it, the machine will tryto update the directory information on the diskette as the machine is bootingup. The way around this is to either A) eject the floppy after copying yourfiles then reinsert it (or simply open and close the main window) to allow thedirectory information to be updated or B) use the installer to place files onthe floppy as the installer automatically updates the directory information.</p><p>Another possible explanation for the anomolous behavior you're seeing is thatyou've got an INIT or application of some sort (such as a virus checkerperhaps) on the floppy that wants to update itself after the system hasfinished starting up.</p><h2>Changing a volume's modification date</h2><p>Date Written:  12/9/91</p><p>Last reviewed: 6/14/93</p><p>Why can't I use <code>PBSetVInfo</code> to change a volume's modification date? The changeshows up in the VCB list, but not in the Finder.</p><p>___</p><p>The modification date shown for a volume in its Get Info window in the Finderis not actually the mod date as recorded in the volume's VCB. Rather, it is themod date of the root folder. The VCB mod date as returned by <code>PBGetVInfo</code> is thelast time a change was written to the volume, but it cannot easily be forged,since calling <code>PBSetVInfo</code> will set the mod date to the time of the <code>PBSetVInfo</code> call.</p><p>An application should not need to change the modification date of a volume asit appears in the disk's Get Info window. However, it can be done by callingPBSetCatInfo to set the <code>ioDrModDat</code> field of the root folder. The root folder'sdir ID is the constant <code>fsRtDirID</code> = 2. <code>PBSetCatInfo</code> is documented on page 156 of<i>Inside Macintosh</i> Volume IV.</p><h2>System 7 DA UnmountVol bug</h2><p>Date Written:  2/26/92</p><p>Last reviewed:  6/14/93</p><p>I am trying to unmount a volume from a desk accessory using the UnmountVoltrap. Unmounting network volumes works fine. However, unmounting a floppy endsup giving me a stack/heap collision in the <code>_Unmountvol</code> trap. This only occursin System 7 and only in a DA. If I move this to an application the code worksfine. On System 6 the code also works (although I am getting unexpected resultsin the Finder.)</p><p>___</p><p>This is a bug in System 7, which should be fixed in the next major systemrelease. It only happens with native (local) volumes since they are the onlyones that use the operating system Unmount code. Network volumes dispatch to anexternal file system, whose code is likely to be correct.</p><h2>How do I tell if a volume is a floppy or hard disk, or removable</h2><p>Date Written:  11/17/89</p><p>Last reviewed:  6/14/93</p><p>How do I tell if a Macintosh volume is a floppy or hard disk?</p><p>___</p><p>What you probably want to know is whether a device in the drive queue isremovable. Do this by examining the four bytes of flags proceeding the drivequeue entry for the device. See pages 181-2 of <i>Inside Macintosh</i> VolumeIV for details. C source is:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* we assume that you get the drive number from some appropriate   place, such as doing a PBHGetVInfo for the volume and grabbing the   ioVDrvInfo field (Inside Mac IV-124)*/BooleanIsEjectable(driveNumber)short driveNumber{    DrvQElPtr   d;    QHdrPtr     queueHeader;    Ptr         p;    queueHeader = GetDrvQHdr();    d = (DrvQElPtr)queueHeader-&gt;qHead;    while (d != nil)    /* find the appropriate drive # */    {        if (d-&gt;dQDrive == driveNumber)   /* is this the drive we want? */        {            p = (Ptr)d;            p -= 3; /* to get to the byte with eject info */            if ((*p) &amp; 8)                return false;           /* non ejectable disk in drive */            else                return true;        }        d = (DrvQElPtr)d-&gt;qLink;    }    return false;   /* you specified an invalid drive number */}</pre>	</TD></TR></TABLE></CENTER><p>If you actually want to know if a volume is a floppy or not, use <code>PBHGetVInfo</code>,and multiply the <code>ioVNmAlBlks</code> (remember, it's unsigned!) times <code>ioVAlBlkSiz</code>.Currently valid sizes include 400K, 800K, 720K, 1440K.</p><p>How will you handle other sizes in the future? Nasty. That's why I hope you arereally asking to detect removable media.</p><h2>Where can I find more information about HFS structures?</h2><p>Date Written:  5/3/89</p><p>Last reviewed:  11/21/90</p><p>Where can I find more information about HFS structures other than in <i>Inside Macintosh?</i></p><p>___</p><p>Another source of information besides <i>Inside Macintosh</i> is the MPW<code>FSPrivate.a</code> file, which contains some private equates used when building thesystem. None of the information found or used in this file, however, issupported. Don't ask MacDTS questions regarding any of this information. Usingthe information is very risky, and will certainly lead to compatibilityproblems. Proceed at your own risk!</p><h2>File Manager backup volume info block bug &amp; workaround</h2><p>Date Written:  3/6/92</p><p>Last reviewed:  6/14/93</p><p>I found a situation where the Macintosh file system incorrectly updates thebackup volume info block. If the driver for this volume is a qType 1 and the<code>dQDrvSz</code> is zero (let's say <code>dQDrvSz2</code> is $0100), the backup volume info blockwon't get updated properly when a new catalog extent is created. This isbecause the calculation dQDrvSz-2 (to get to the backup volume info block) isdone as an integer rather than a longint. This means the block addressed is<code>$0100FFFE</code> instead of <code>$FFFFFE</code> which accesses a block past the end of the volume!I caught this condition by a test in my driver code for accesses outside thedrive's size. It seems to be a problem with both System 6 and System 7. Is thisa bug?</p><p>___</p><p>It looks like you're right. That bug is present in the File Manager ROM code onthe Macintosh Plus, SE, II, IIx, IIcx, and Classic (everything with thepre-IIci ROMs). The two workarounds are:</p><p>* Make sure the low word of the logical number of blocks (stored in <code>dQDrvSz</code>) isnever $0000 or $0001. This is the best workaround because it ensures that thealternate master directory block gets updated.</p><p>or</p><p>* Make sure your driver ignores accesses past the end of the volume.</p><h2>Changing the volume control block modification date</h2><p>Date Written:  3/11/91</p><p>Last reviewed:  6/14/93</p><p>How can I change the modification date of my Macintoshreg. external file systemdriver's volume control block? I've tried different values in both the vcbLsModfield of the volume control block and the <code>ioVLsMod</code> field of the <code>HParamBlock</code>without success.</p><p>___</p><p>Some of the volume information is getting magically cached somewhere, and thatin order to update it, you must first put the volume offline! I know, it soundsweird, but I've seen the source code to disk copy utilities that do this inorder to change that kind of information. So try putting the volume offlinebefore writing the volume info out to it, and then call FlushVol on the volume.</p><h2>Code for identifying vRefNum and DirID of MAC System Folder</h2><p>Date Written:  4/10/91</p><p>Last reviewed:  6/14/93</p><p>I need to identify the startup volume as I index through all volumes with<code>PBHGetVInfo</code>, but <code>GetVol</code> and <code>SysEnvirons</code> are returning <code>WDIDs</code>. How can I get thetrue <code>vRefNum</code> from these calls?</p><p>___</p><p>The code below is general purpose code to identify the <code>vRefNum</code> and <code>DirID</code> of theSystem Folder. It is System 7.0 friendly in that it will use FindFolder ifpresent; otherwise, it falls back to <code>SysEnvirons</code> and converts the <code>wdRefNum</code> intoa vRefNum and DirID.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#define BTstQ(arg, bitnbr) (arg &amp; (1 &lt;&lt; bitnbr))/* FindSysFolder returns the (real) vRefNum, and the DirID of the current   system folder. It uses the Folder Manager if present, otherwise it falls   back to SysEnvirons. It returns zero on success, otherwise a standard   system error. */OSErr FindSysFolder(short *foundVRefNum, long *foundDirID){    long            gesResponse;    SysEnvRec        envRec;    WDPBRec            myWDPB;    unsigned char    volName[34];    OSErr            err;    *foundVRefNum = 0;    *foundDirID = 0;    if (!Gestalt (gestaltFindFolderAttr, &amp;gesResponse) &amp;&amp;        BTstQ (gesResponse, gestaltFindFolderPresent)) {    /* Does FolderManager exist? */            err = FindFolder (kOnSystemDisk, kSystemFolderType,kDontCreateFolder,                foundVRefNum, foundDirID);    } else {        /* Gestalt can't give us the answer, so we resort to SysEnvirons */        if (!(err = SysEnvirons (curSysEnvVers, &amp;envRec))) {            myWDPB.ioVRefNum = envRec.sysVRefNum;            volName[0] = '\000';                    /* Zero volume name */            myWDPB.ioNamePtr = volName;            myWDPB.ioWDIndex = 0;            myWDPB.ioWDProcID = 0;            if (!(err = PBGetWDInfo (&amp;myWDPB, 0))) {                *foundVRefNum = myWDPB.ioWDVRefNum;                *foundDirID = myWDPB.ioWDDirID;            }        }    }    return (err);}</pre>	</TD></TR></TABLE></CENTER><h2>System 7 UnmountVol and Eject calls return positive drive number</h2><p>Date Written:  4/30/91</p><p>Last reviewed:  6/14/93</p><p>Why is my Macintosh driver receiving a positive drive number under System 7.0upon notification of an <code>_Eject</code> call?</p><p>__</p><p>When the "driver wants a call on eject" bit is set in the flag bytes precedinga drive queue element, <code>_Eject</code> will issue a <code>_Control</code> call with a csCode of 7 tothe driver. This <code>_Control</code> call is supposed to inform the driver which disk theOS is attempting to eject, by passing the drive number in the <code>ioVRefNum</code> fieldof the parameter block.</p><p>However, there's a bug in the ROM that only mainfests itself when <code>_Eject</code> isgiven a volume reference number for a disk that has both the "nonejectable" and"driver wants a call on eject" bits set in the drive flag bytes. This bugcauses the driver to receive the negative of the drive number, rather than thepositive drive number.</p><p>The System 7.0 Finder has reversed the order of its calls to <code>_UnmountVol</code> and<code>_Eject</code>, causing it to pass the drive number to <code>_Eject</code>, which then passes it onto the driver correctly. Unfortunately, under previous systems, the Finderpassed the volume reference number to <code>_Eject</code>, forcing developers to work aroundthe bug by accepting negative drive numbers; however, a problem could occur nowunder System 7.0 if positive drive numbers weren't accepted as well.</p><p>A number of driver writers have notified us of this problem, but few (so far)have been adversely affected. As it has always been possible for utilities orapplications to make <code>_Eject</code> calls with either a volume reference number or adrive number, the proper workaround is to handle both positive and negativedrive numbers.</p><p>X-Refs:</p><p><i>Inside Macintosh</i> Volume II, page 214</p><p><i>Inside Macintosh</i> Volume IV, page 181</p><h2>How to determine if a Macintosh file is on a locked disk</h2><p>Date Written:  1/1/91</p><p>Last reviewed:  6/14/93</p><p>How do I determine whether a Macintosh file is on a locked disk?</p><p>___</p><p>Call the function <code>PBGetVInfo</code> and check <code>ioVAtrb</code>, which it passes back in theparameter block. If the volume has a software lock, then bit 15 of ioVatrb willbe set. If there is a hardware lock (such as the CD-ROM), bit 7 is set.</p><h2>Working directories and unmounted volumes</h2><p>Date Written:  5/4/92</p><p>Last reviewed:  6/14/93</p><p>When can I unmount a Macintosh volume? I know that if any files (other thanDesktop, Desktop DB or Desktop DF) are open, I can't unmount the volume, butI'm not sure about working directories. Will open working directories for thatvolume prevent the unmount call from working?</p><p>___</p><p>Open working directories on a volume will not keep the volume from unmounting.When a volume is unmounted under either System 6 (Finder or MultiFinder) orSystem 7, all working directories for that volume are made invalid. Anyattempts to use the working directory number after the volume is unmounted willresult in a <code>rfNumErr</code> (-51).</p><h2>Getting open file name on an MFS volume</h2><p>Date Written:  4/30/92</p><p>Last reviewed:  6/14/93</p><p><code>PBGetFCBInfo</code> works great for getting the name of an open file given the pathreference number, except for on an MFS volume. In this case, the call returnssuccess but the name is not filled in. Is it because the name of the file isnot kept in the FCB of an MFS volume? Should this work or is there a better wayto do what I am trying to do?</p><p>___</p><p>The code that deals with MFS volumes and the files on MFS volumes is the samecode that has always dealt with MFS. The MFS code that fills in the FCB onlyknows about the first 30 bytes of the FCB (the 30 bytes documented in <i>InsideMacintosh</i> Volume II on page 127) which does not include the file name andseveral other pieces of information used by only by HFS.</p><p>So, there's really no good way to get the file name of an open file on an MFS volume.</p><h2>How Macintosh Finder calculates free and used volume space</h2><p>Date Written:  7/1/92</p><p>Last reviewed:  6/14/93</p><p>How does the Macintosh Finder calculate free, total, and used space on a givenvolume? The information derived from the fields in the VCB seems to give me thecorrect volume free space, but the volume used space sometimes is off.</p><p>___</p><p>The calculation the Finder uses for space used in the Get Info dialog is this:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    free = vcbFreeBks * vcbAlBlkSiz    totalAlBlks = vcbNmAlBlk    if the volume is not a MFS volume        totalAlBlks = totalAlBlks - (vcbXTAlBlks + vcbCTAlBlks)    used = (totalAlBlks * vcbAlBlkSiz) - free;</pre>	</TD></TR></TABLE></CENTER><p>The Finder doesn't consider space used by the volume's catalog file and extentsoverflow file to be space used by the "user."</p><p>We don't normally recommend accessing the VCB directly if at all possiblebecause it is a compatibility risk, but there is some information you can't getany other way, such as <code>vcbXTAlBlks</code> and <code>vcbCTAlBlks</code>. That is, if you can geteverything you need from the <code>PBHGetVInfo</code> call, use <code>PBHGetVInfo</code>.</p><P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (68K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/fl_530.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/fl/fl_530.html%3Fid%3DDTS10002469-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/fl/fl_530.html%3Fid%3DDTS10002469-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/fl/fl_530.html%3Fid%3DDTS10002469-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --><hr width=500 align=center></BODY></HTML>