<html>
<body bgcolor="#FFFFFF">
<CENTER><H1>Class WOApplication</H1></CENTER>
<a name="//apple_ref/occ/cl/WOApplication">
<!-- inherits from:NSObject -->
<DL>
<DT><B>Inherits From:</B></DT><DD>NSObject</DD>
<DT><B>Conforms To:</B></DT><DD>NSObject (NSObject)</DD>

</DL>
<HR>

<A name="classAtAGlance"></A>

<CENTER>

  <H2>

    CLASS AT A GLANCE

  </H2>

</CENTER>

<P>

<h4>Purpose</h4>

<P>

A WOApplication object receives an HTTP request from an adaptor, manages the request-response loop that processes the request, and returns a response to the adaptor. It also manages sessions, caches component definitions and page instances, and offers localization, debugging, and error-handling support.

<H4>Principal Attributes</h4>

<UL>

<LI>Application bundle

<LI>Session store

<LI>Page and component-definition caches

<LI>Current adaptors

</UL>

<H4>Creation</H4>

Created in default application <B>main</B> (<B>WODefaultMain()</B>)

<br>

<b>application</b>

<H4>Commonly Used Methods</H4>

<TABLE><TR>

<TD> pageWithName: </td>

<td>Returns a Component (page) instance identified by name.</td>

</TR><TR>

<TD>awake</td><TD>Allows custom application initializations during the start of a request-response cycle.</td>

</TR><TR>

<td>takeValuesFromRequest:inContext:<BR>invokeActionForRequest:inContext:<BR>appendToResponse:inContext: </td><td>These three methods allow custom application logic during the value-extraction, action-invocation, and HTML-generation phases of the request-reponse loop.</td>

</TR><TR>

<td> setTimeOut: </td><td>Sets the period of inactivity after which the application process stops executing.</td>

</TR><TR>

<td> setPageCacheSize: </td><td>Sets the number of page instances cached in the session by the application.</td>

</TR><TR>

<td> setCachingEnabled:</td><td>Controls whether the application caches component definitions.</td>

</TR>

</table>

<BR>

<hr>	

<BR>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>
<P>
<P>

The primary role of the WOApplication class is to coordinate the handling

of HTTP requests. Each application must have exactly one WOApplication object

(or, simply, <I>application object</I>). The application object receives client

requests from an HTTP server adaptor, manages the processing that generates

a response, and returns that response--typically an object representing a

web page--to the adaptor. The adaptor, in turn, forwards the response in

a suitable form to the HTTP server that originated the request.

<P>

In handling requests, an application object creates and manages one or more

sessions; a session (represented by a WOSession object) dedicates resources

to a period of access by a single user and stores persistent state during that period.
Conceptually, each cycle of the request-response loop (or <I>transaction</I>)

takes place within a session.

<P>

Besides acting as a facilitator between the adaptor and the rest of the

application during request handling, WOApplication performs many secondary

functions. It returns pages based on component name, caches page instances

and component definitions, provides

some facilities for error handling and script debugging, and furnishes a

variety of data, such as the base URL and the current WOContext object.

<P>

Typical deployment schemes balance the processing load by having multiple

application instances per server adaptor. A single application, in turn,

can interact with multiple adaptors; for example, an application can

simultaneously communicate with secure-socket and Distributed Object adaptors

as well as HTTP adaptors.

<P>

You can instantiate ready-made application objects from the WOApplication class or you can obtain the application object from a custom subclass of WOApplication. Custom WOApplication subclasses are common in WebObjects applications since there is often a need to override the <b>awake</b>, <b>sleep</b>, <b>init</b>, and request-handling methods. Compiled WOApplication subclasses can take any name, but if the name is anything other than "Application" you must implement your own <b>main</b> function to instantiate the application object from this class. However, if the class name is "Application," you don't need to modify <b>main</b>. In scripted
applications, the code in the <B>Application.wos</B> file becomes the
implementation logic of a WOApplication subclass automatically created at
run time; the application object is instantiated from this subclass. <BR>

<BR>

<H2>

  The Application Run Loop

</H2>

<P>

When a WebObjects application is launched from the command line, either manually

or automatically ("autostarting"), the <B>main</B> function is called. In

<B>main</B> the WOApplication subclass for the application is loaded. This

class sets up for request handling by:

<OL>

  <LI>

    Parsing the command-line arguments <BR>

  <LI>

    Creating and initializing an application instance <BR>

  <LI>

    Instantiating the adaptors with which the application will communicate <BR>

</OL>

<P>

The application instance then has its <B>run</B> method invoked; in this

method it registers its adaptors to receive run-loop events and then starts

a run loop. The application remains in this run loop until it either times

out, receives a <B>terminate</B> message, or has its process externally stopped.

<P>

The events that initiate each cycle of the run loop are not, as in a typical

non-web application, user actions such as mouse clicks or key presses. Instead

they are HTTP requests originating from client browsers. A browser sends

an HTTP request (according to the URL specified) to an HTTP server, which

then "talks" with a WebObjects adaptor customized for that server. The adaptor

packages the request in a WORequest object and invokes the application object's

<B>handleRequest:</B> method. The receipt of this message initiates a cycle

of the <I>request-response loop</I>, a three-phase cycle that handles the

request and returns (in most cases) a response in the form of a Web page.

Each phase of the cycle centers around a message propagated from the application

object to all other "interested" objects in the application:

<UL>

  <LI>

    takeValuesFromRequest:inContext:

  <LI>

    invokeActionForRequest:inContext:

  <LI>

    appendToResponse:inContext:

</UL>

<!--Need to provide links for the following chapters, or just to the DevGuide and Serving WO -->

<P>

For more on the request-response loop, see the <A HREF="../../../../../../DevGuide/DevGuideTOC.html" target=_top><i>WebObjects Developers Guide</i></A>. For information on

valid command-line arguments for launching an application, see the "<a href="../../../../../../ServingWebObjects/ManualStarting.html" target=_top>Manually

Starting WebObjects Applications</a>" section of the <i>Serving WebObjects</i> document.

<BR>

<BR>

<A name="Caching"></A>

<H2>

  <A name="Caching">Caching Strategies</A>

</H2>

<P>

The WOApplication object implements or controls three kinds of caching.

You turn caching off or on in each case for reasons ranging from performance

enhancement to page integrity or ease of debugging.

<DL>

  <DT>

    <B>Component-definition caching</B> <BR>

  <DD>

    Component definitions are compact programmatic descriptions of components

    (pages or subcomponents), and are used to create instances of those components.

    When a page of an application is requested the first time, an application

    parses the HTML, declaration (".wod"), and implementation files in the component

    directory (".wo"), creates an internal representation of the component (the

    component definition), and instantiates the WOComponent object from it. If

    caching is enabled, it stores the component definition in memory. If not,

    the application must reparse the files in the component directory every time

    that page is revisited.

    <P>

    You turn component-definition caching off and on with the

    <B>setCachingEnabled:</B> method. By default, it is disabled. The advantage

    of having this kind of caching disabled is that you can edit a scripted component

    without having to relaunch the application every time to check the results.

    However, you should always enable component-definition caching when you deploy

    an application since performance improves significantly when you do. You

    can also control caching of individual component definitions using an identically

    named WOComponent method. Selective caching is an especially valuable technique

    for very large applications where only the most common components and pages

    should be cached. <BR>

    <BR>

  <DT>

    <B>Page-instance caching</B> <BR>

  <DD>

    In normal processing of requests, an application caches at least one page instance. It does this because the lifecycle of a page overlaps transaction boundaries: a page "begins" by having its HTML generated and "ends" when the user navigates to a new page, which replaces the previous page in the browser. Because the application caches the page instance that once represented the response page, it can easily make it the request page for the next transaction.

<P>

Page-instance caching also facilitates backtracking in the client browser. It

    works like this: At the end of a request-response cycle, the application

    object stores the WOComponent instance representing the response page in the

    session. When the user backtracks to this page, the instance is restored

    from the session object, enabling the page to display things as they were

    when the user visited it the previous time. By default, page-instance caching

    is enabled, with a cache limit of 30 pages.

    <P>

    You turn page-instance caching off by sending <B>setPageCacheSize:</B> to

    the application object with an argument of zero. In this case, when the user

    backtracks to a page, the page is not stored in the session and so must be

    re-created "from scratch"; it will show none of its previous state. This

    situation is sometimes what is appropriate for certain applications. If you

    wish, you can also turn this feature off and implement your own selective

    page-caching scheme. Because page storage uses up application memory, you

    should test for the optimum cache size before you deploy an application with

    page-instance caching turned on. <BR>

    <BR>

  <DT>

    <B>Client caching</B> <BR>

  <DD>

    Usually client browsers cache pages (as HTML code) so they can redisplay

    them when users backtrack to them. You can turn off client caching by setting

    the date and the expiration time in the response page's headers to the current

    date and time. The client, however, retains the URL for the page. When the

    user backtracks to the page, the client resends the URL to the server, which

    returns a page based on a restored component instance. 

    <P>

    WebObjects turns off client caching for you when you send the application

    object <B>setPageRefreshOnBacktrackEnabled:</B> with an argument of

    YES. This setting is valuable when you do not want the client to

    backtrack to a page that would be obsolete because of changes that might

    occur in the session. In particular, if you are using WODisplayGroup's batch

    and selection-management functionality, you should turn off client caching.

</DL>

<P>

<BR>

<BR>

<H2>

  <A name="Localization">Localization </A>

</H2>

<P>

Localization in WebObjects depends on an array of languages stored (as NSString

objects) in the WOSession object using WOSession's <B>setLanguages:</B>.

The order of languages in the array indicates the preferred order. The language

names in the array should map to "<I>Language</I>.lproj" subdirectories of

the ".woa" directory. Thus, if there is a "French" item in the array, there

should be a <B>French.lproj</B> subdirectory. The ".lproj" directories should contain

everything that has localized content: ".strings" tables, sounds, images,

and so on. Because the application first looks for resources in localized

".lproj" directories and then in a non-localized location, be sure there

are no files of the same name in localized locations when no localization

is supposed to occur.

<P>

The ".strings" file contains a simple property list that maps common keys

to words, phrases, or sentences in a particular language. For instance, a

<B>Session.strings</B> file in English.lproj might have the following content:<BR>

<PRE>{

    buttonTitle = "Submit your request";

}

</PRE>

<P>

<BR>

<P>

The <B>Session.strings</B> file in French.lproj would have the following:<BR>

<PRE>{

    buttonTitle = "Soumettez votre requete";

}

</PRE>

<P>
You might want to have localized versions of a component's HTML file as well. If you do this, you must place the file inside of an ".lproj" directory in the component. For example, you would have this directory structure:
<PRE>	English.lproj/
		MyApplicationWide.strings
	French.lproj/
		MyApplicationWide.strings
	Main.wo/
		English.lproj/
			Main.html
		French.lproj
			Main.html
</PRE>
<P>
<BR>

<P>

<B>Note</B>: You can determine the language of the request sender by getting

the value of the WORequest object's "accept-language" header. This returns

a two-character value ("en", "fr", and so on) that you can then map to the

language subdirectory.<BR>

<BR>

<BR>

<H2>

  Error Handling and Debugging

</H2>

<P>

WOApplication offers developers some assistance in the areas of debugging

and error handling.

<UL>

  <LI>

    You can invoke the <B>logWithFormat:</B> method at critical points in your code

    to print debugging messages to the standard error device. You can also use the 
    <b>trace...</b> methods to print messages to standard error whenever statements of 
    a certain type are executed. <BR>

    <BR>

  <LI>

    For handling exceptions that arise during request handling, WOApplication

    gives the <B>handleException:</B> method as well as methods for handling errors

    occurring at specific points in the request-response loop (for example,

    <B>handlePageRestorationError</B>). The default implementation of these methods

    prints debugging information on the browser page; you can override them to

    implement "friendlier" or more elaborate error handling.<BR>

    <BR>

  <LI>

    A WebObjects application can print diagnostic messages to the standard output

    device when it parses HTML code, (for example, when it encounters unbalanced

    containers). You can turn this feature off and on with the

    <B>setPrintsHTMLParserDiagnostics:</B> method.

</UL>

<P>

<hr>
<!-- class methods -->
<a name="class methods"><CENTER><H2>CLASS METHODS</H2></CENTER></a>
<!-- key://apple_ref/occ/clm/WOApplication/application cons:application descr:<TT>+ (WOApplication *)<B>application</B> </TT> -->
<H3><a name="//apple_ref/occ/clm/WOApplication/application">application</a></H3>
   <TT>+ (WOApplication *)<B>application</B> </TT>
<P>
Initializes and returns a WOApplication object. This initializes

application attributes and

initializes the adaptor or adaptors specified on the command line. If no

adaptor is specified, WODefaultAdaptor is made the default adaptor. Some

of the more interesting attribute initializations are:

<UL>

  <LI>

    Session store is in the server.

  <LI>

    Page cache size is 30 pages.

  <LI>

    Client caching of pages is enabled (<B>isPageRefreshOnBacktrackEnabled</B>

    returns NO).

  <LI>

    Component-definition caching is disabled (<B>isCachingEnabled</B> returns

    NO).

</UL>

<P>

A exception is raised if initialization does not succeed. 




<hr>
<!-- instance methods -->
<a name="instance methods"><CENTER><H2>INSTANCE METHODS</H2></CENTER></a>
<!-- key://apple_ref/occ/instm/WOApplication/activeSessionsCount meth:activeSessionsCount descr:<TT>- (int)<B>activeSessionsCount</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/activeSessionsCount">activeSessionsCount</a></H3>
   <TT>- (int)<B>activeSessionsCount</B> </TT>
<P>
Returns the number of sessions that are currently active. (A session is active if it has not yet timed out.)
<P>
The number returned here is only accurate if the application stores state in memory in the server, which is the default. If you use a custom state-storage strategy, there may be no way to tell how many sessions are active for a given application instance.
<P>
<B>See Also: </B>-&nbsp;<B>minimumActiveSessionsCount</B>, -&nbsp;<B>setMinimumActiveSessionsCount:</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/adaptors meth:adaptors descr:<TT>- (NSArray *)<B>adaptors</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/adaptors">adaptors</a></H3>
   <TT>- (NSArray *)<B>adaptors</B> </TT>
<P>
Returns the current list of application adaptors. A WOApplication can have multiple adaptors. (To associate the WOApplication with multiple adaptors, you specify each adaptor on the application's command line using the <b>-a</b> option.) This allows you to design an application that can not only listen to a socket for incoming HTTP requests (using the WODefaultAdaptor), but can also receive remote request messages using more advanced RPC mechanisms such as DO, CORBA, and DCOM.

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/adaptorWithName:arguments: meth:adaptorWithName:arguments: descr:<TT>- (WOAdaptor *)<B>adaptorWithName:</B>(NSString *)<I>aName</I> <B>arguments:</B>(NSArray *)<I>someArguments</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/adaptorWithName:arguments:">adaptorWithName:arguments:</a></H3>
   <TT>- (WOAdaptor *)<B>adaptorWithName:</B>(NSString *)<I>aName</I> <B>arguments:</B>(NSArray *)<I>someArguments</I> </TT>
<P>
Invoked during the <b>init</b> method to create an adaptor. If you subclass WOAdaptor, you specify the WOAdaptor subclass you want the application to use with the <b>-a</b> option on the application's command line. When WOApplication encounters the <b>-a</b> option, it invokes this method. This method looks for a subclass of WOAdaptor with the name <i>aName</i> (which was supplied as the <b>-a</b> option's argument), and if such a class exists, a new instance is initialized using the WOAdaptor method <b>initWithName:arguments:application:</b>. The <i>someArguments</i> array is populated with any adaptor-specific options (such as <b>-p</b> or <b>-q</b>) that follow the adaptor name on the command line. See the <a href="../WOAdaptor/WOAdaptor.html" target="_top">WOAdaptor</a> class for more information. 
<P>

<B>See Also: </B>- <b>adaptors</b>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/appendToResponse:inContext: meth:appendToResponse:inContext: descr:<TT>- (void)<B>appendToResponse:</B>(WOResponse *)<I>aResponse</I> <B>inContext:</B>(WOContext *)<I>aContext</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/appendToResponse:inContext:">appendToResponse:inContext:</a></H3>
   <TT>- (void)<B>appendToResponse:</B>(WOResponse *)<I>aResponse</I> <B>inContext:</B>(WOContext *)<I>aContext</I> </TT>
<P>
The WOApplication object sends this message to itself to initiate the last

phase of request handling. This occurs right after the

<B>invokeActionForRequest:inContext:</B> method has completed, typically with the return

a response page. In the append-to-response phase, the application objects

(particularly the response component itself) generate the HTML content of

the page. WOApplication's default implementation of this method forwards

the message to the session object.

<P>

<B>See Also: </b>- <b>invokeActionForRequest:inContext:</B>, - <B>takeValuesFromRequest:inContext:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/awake meth:awake descr:<TT>- (void)<B>awake</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/awake">awake</a></H3>
   <TT>- (void)<B>awake</B> </TT>
<P>
Invoked at the beginning of each cycle of the request-response loop, affording

the opportunity to perform initializations with application-wide scope. Since the

default implementation does nothing, overridden implementations do not have to call super.

<P>

<B>See Also: </b>- <b>sleep</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/baseURL meth:baseURL descr:<TT>- (NSString *)<B>baseURL</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/baseURL">baseURL</a></H3>
   <TT>- (NSString *)<B>baseURL</B> </TT>
<P>
Returns the application URL relative to the server's document root, for example:

<B>/WebObjects/MyApp.woa</B>.

<P>
This method works always works correctly if one of the following is true:
<UL>
<P><LI>The application executable is under the document root.
<P><LI>The application's web server resources directory is directly under the document root (for example <B><I>&lt;DocRoot&gt;</I>/WebObjects/<I>MyApp</I>.woa/WebServerResources</B>).
</UL>
<P>
If the executable is not under the document root, WOApplication assumes a base URL of <B>/WebObjects/</B><I>MyApp</I><B>.woa</B>. If the application's resources directory is in a subdirectory of <B><I>&lt;DocRoot&gt;</I>/WebObjects</B>, the base URL is incorrect. In this case, you must specify the application name on the command line to ensure that <B>baseURL</B> returns the correct URL. 
<P>
For example, if the application's resource directory is in <B><I>&lt;DocRoot&gt;</I>/WebObjects/ASubdirectory/MyApp.woa</B>, you should start the application with these commands:
<PRE>&gt; cd /NextLibrary/WOApps/ASubdirectory/MyApp.woa
&gt; MyApp ASubdirectory/MyApp
</PRE>
<P>
<B>See Also: </b>- <b>name</B>, - <b>path</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/context meth:context descr:<TT>- (WOContext *)<B>context</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/context">context</a></H3>
   <TT>- (WOContext *)<B>context</B> </TT>
<P>
Returns the application's current WOContext object. May not be overridden.

<P>
<B>See Also: </B> <A href="../WOContext/WOContext.html" target=_top>WOContext</A>

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/createSession meth:createSession descr:<TT>- (WOSession *)<B>createSession</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/createSession">createSession</a></H3>
   <TT>- (WOSession *)<B>createSession</B> </TT>
<P>
Creates and returns a WOSession object to manage a session for the application.

The method goes through several steps to locate the class to use for

instantiating this object:

<OL>

  <LI>

    First it looks for a compiled class of name "Session" that is a subclass

    of WOSession. 

<BR>

<BR>

  <LI>

    If such a class does not exist, it looks for a ".wos" script with the name

    of "Session" in the application wrapper (".woa" directory). 

<BR>

<BR>

  <LI>

    If the <B>Session.wos</B> script exists, the method parses the script and

    dynamically adds a scripted-class subclass of WOSession to the runtime.

</OL>

<P>

The method then returns an allocated and initialized (using the default

WOSession initializer) session instance of the selected class. It raises

an exception if it is unable to create a new session.

<P>

<B>Note: </B>An implication of the foregoing description is that the names

of compiled WOSession subclasses should be "Session"; if not, you will have

to override this method to use the proper class to create the session object.

<P>

<B>See Also: </b>- <b>restoreSession</B>, - <B>saveSession:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/dynamicElementWithName:associations:template: meth:dynamicElementWithName:associations:template: descr:<TT>- (WODynamicElement *)<B>dynamicElementWithName:</B>(NSString *)<I>aName</I> <B>associations:</B>(NSDictionary *)<I>someAssociations</I> <B>template:</B>(WOElement *)<I>anElement</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/dynamicElementWithName:associations:template:">dynamicElementWithName:associations:template:</a></H3>
   <TT>- (WODynamicElement *)<B>dynamicElementWithName:</B>(NSString *)<I>aName</I> <B>associations:</B>(NSDictionary *)<I>someAssociations</I> <B>template:</B>(WOElement *)<I>anElement</I> </TT>
<P>
Creates and returns a WODynamicElement object based on the element's name, a dictionary of associations, and a template of elements. This method is invoked automatically to provide a WODynamicElement object that represents a WEBOBJECT element in the HTML template. You don't ordinarily invoke <B>dynamicElementWithName:associations:template:</B>, but you might override it to substitute your own WODynamicElement or reusable component for one of the built-in WODynamicElements.
<P>The arguments <I>aName</I> and <I>someAssociations</I> are derived from a corresponding line in the declarations file. <I>aName</I> is an NSString that identifies the kind of element to create.  Generally <I>aName</I> specifies a built-in WODynamicElement such as WOString, but it may also identify a reusable component. (For more information, see the chapter "<A HREF="../../../../../../DevGuide/Reuse/ReuseTOC.html" target="_top">Using Reusable Components</A>" in the <i>WebObjects Developer's Guide</i>.) For example, in the <B>dynamicElementWithName:associations:template:</B> message for the following declaration:
<PRE>APP_STRING: WOString {value = applicationString;};
</PRE>
<P><I>aName</I> contains the string "WOString".
<P>The <I>someAssociations</I> dictionary contains an entry for each attribute specified in the corresponding declaration. For the declaration above, <I>someAssociations</I> contains a single entry for WOString's <B>value</B> attribute. The keys of <I>someAssociations</I> are the attribute names and the values are WOAssociation objects.
<P>WOApplication's implementation of <B>dynamicElementWithName:associations:template:</B> first searches for a WODynamicElement named <I>aName</I>. If a WODynamicElement is found, the method creates an instance using the method <b>initWithName:associations:template:</b> and returns it. Otherwise, it searches for a component--either scripted or compiled--to return instead. If neither are found, this method returns <B>nil</B>.

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/handleException: meth:handleException: descr:<TT>- (WOResponse *)<B>handleException:</B>(NSException *)<I>anException</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/handleException:">handleException:</a></H3>
   <TT>- (WOResponse *)<B>handleException:</B>(NSException *)<I>anException</I> </TT>
<P>
Invoked when an exception occurs within the request-response loop. The default

behavior displays a page with debugging information. You can override this

method to catch exceptions and display a "friendlier" error page.
For example, the following code replaces the standard error page with a component named <B>ErrorPage.wo</B>.
<PRE>- (WOResponse *)handleException:(NSException *)anException {
	WOResponse *response = [[WOResponse alloc] init];
	WORequest *request = [[self context] request];
	WOString newURL = [NSString stringWithFormat:@"http://%@%@/%@.woa/-/ErrorPage.wo", 
		[request applicationHost], 
		[request adaptorPrefix], 
		[request applicationName]];

	[response setHeader:newURL forKey:@"location"];
	[response setHeader:@"text/html" forKey:@"content-type"];
	[response setHeader:@"0" forKey:@"content-length"];
	[response setStatus:302];
	return response;
}</PRE>
<P>

<B>See Also: </b>- <b>handlePageRestorationError</B>, - 

<B>handleSessionCreationError</B>, - <B>handleSessionRestorationError</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/handlePageRestorationError meth:handlePageRestorationError descr:<TT>- (WOResponse *)<B>handlePageRestorationError</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/handlePageRestorationError">handlePageRestorationError</a></H3>
   <TT>- (WOResponse *)<B>handlePageRestorationError</B> </TT>
<P>
Invoked when a page (WOComponent) instance cannot be restored, which typically

happens when a user backtracks too far. Specifically, this method is invoked

when the following occurs: the request is not the first of a session, page

restoration by context ID fails, and page re-creation is disabled. The default

behavior displays a page with debugging information. You can override this

method to display a "friendlier" error page.

<P>

<B>See Also: </b>- <b>handleException:</B>, - <B>handleSessionCreationError</B>,

- <B>handleSessionRestorationError</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/handleRequest: meth:handleRequest: descr:<TT>- (WOResponse *)<B>handleRequest:</B>(WORequest *)<I>aRequest</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/handleRequest:">handleRequest:</a></H3>
   <TT>- (WOResponse *)<B>handleRequest:</B>(WORequest *)<I>aRequest</I> </TT>
<P>
Prepares for and manages the handling of a request. The method

creates the WOResponse and WOContext objects used in the request-response loop

and causes <B>awake</B> and <B>sleep</B> to be sent to application objects

at the appropriate times. This method is invoked by the HTTP server adaptor.

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/handleSessionCreationError meth:handleSessionCreationError descr:<TT>- (WOResponse *)<B>handleSessionCreationError</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/handleSessionCreationError">handleSessionCreationError</a></H3>
   <TT>- (WOResponse *)<B>handleSessionCreationError</B> </TT>
<P>
Invoked when a session (WOSession) instance cannot be created. The default

behavior displays a page with debugging information. You can override this

method to display a "friendlier" error page.

<P>

<B>See Also: </b>- <b>handleException:</B>, - <B>handlePageRestorationError</B>,

- <B>handleSessionRestorationError</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/handleSessionRestorationError meth:handleSessionRestorationError descr:<TT>- (WOResponse *)<B>handleSessionRestorationError</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/handleSessionRestorationError">handleSessionRestorationError</a></H3>
   <TT>- (WOResponse *)<B>handleSessionRestorationError</B> </TT>
<P>
Invoked when a session (WOSession) instance cannot be restored, which typically

happens when the session times out. The default behavior displays a page

with debugging information. You can override this method to display a

"friendlier" error page.

<P>

<B>See Also: </b>- <b>handleException:</B>, - <B>handlePageRestorationError</B>,

- <B>handleSessionCreationError</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/init meth:init descr:<TT>- (id)<B>init</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/init">init</a></H3>
   <TT>- (id)<B>init</B> </TT>
<P>
Initializes application attributes and

initializes the adaptor or adaptors specified on the command line. If no

adaptor is specified, WODefaultAdaptor is made the default adaptor. Some

of the more interesting attribute initializations are:

<UL>

  <LI>

    Session store is in the server.

  <LI>

    Page cache size is 30 pages.

  <LI>

    Client caching of pages is enabled (<B>isPageRefreshOnBacktrackEnabled</B>

    returns NO).

  <LI>

    Component-definition caching is disabled (<B>isCachingEnabled</B> returns

    NO).

</UL>

<P>

A exception is raised if initialization does not succeed. 

<P>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/invokeActionForRequest:inContext: meth:invokeActionForRequest:inContext: descr:<TT>- (WOElement *)<B>invokeActionForRequest:</B>(WORequest *)<I>aRequest</I> <B>inContext:</B>(WOContext *)<I>aContext</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/invokeActionForRequest:inContext:">invokeActionForRequest:inContext:</a></H3>
   <TT>- (WOElement *)<B>invokeActionForRequest:</B>(WORequest *)<I>aRequest</I> <B>inContext:</B>(WOContext *)<I>aContext</I> </TT>
<P>
The WOApplication object sends this message to itself to initiate the middle

phase of request handling. In this phase, the message is propagated through

the objects of the application until the dynamic element that has received

the user action (for instance, a click on a button) responds to the message

by triggering the method in the request component that is bound to the action.

This phase occurs right after the <B>takeValuesFromRequest:inContext:</B> method has

completed. The default WOApplication implementation of this method forwards

the message to the session object.

<P>

<B>See Also: </b>- <b>appendToResponse:inContext:</B>, - <B>takeValuesFromRequest:inContext:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/isBrowserLaunchingEnabled meth:isBrowserLaunchingEnabled descr:<TT>- (BOOL)<B>isBrowserLaunchingEnabled</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/isBrowserLaunchingEnabled">isBrowserLaunchingEnabled</a></H3>
   <TT>- (BOOL)<B>isBrowserLaunchingEnabled</B> </TT>
<P>
Returns YES if starting up the application also launches a web browser, and NO otherwise. Browser launching is enabled by default as long as there is a WOAdaptorURL key in the file <I>NeXT_ROOT</I><B>/NextLibrary/WOAdaptors/Configuration/WebServerConfig.plist</B>.
<P>
<B>See Also: </B>-&nbsp;<B>setBrowserLaunchingEnabled:</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/isCachingEnabled meth:isCachingEnabled descr:<TT>- (BOOL)<B>isCachingEnabled</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/isCachingEnabled">isCachingEnabled</a></H3>
   <TT>- (BOOL)<B>isCachingEnabled</B> </TT>
<P>
Returns whether component-definition caching is enabled. The default is NO.

<P>

<B>See Also: </b>- <b>setCachingEnabled:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/isPageRefreshOnBacktrackEnabled meth:isPageRefreshOnBacktrackEnabled descr:<TT>- (BOOL)<B>isPageRefreshOnBacktrackEnabled</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/isPageRefreshOnBacktrackEnabled">isPageRefreshOnBacktrackEnabled</a></H3>
   <TT>- (BOOL)<B>isPageRefreshOnBacktrackEnabled</B> </TT>
<P>
Returns whether caching of pages is disabled in the client. If so, the client

does not restore request pages from its cache but re-creates them "from scratch"

by resending the URL to the server. This flag is set to NO by default.

<P>

<B>See Also: </b>- <b>setPageRefreshOnBacktrackEnabled:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/isRefusingNewSessions meth:isRefusingNewSessions descr:<TT>- (BOOL)<B>isRefusingNewSessions</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/isRefusingNewSessions">isRefusingNewSessions</a></H3>
   <TT>- (BOOL)<B>isRefusingNewSessions</B> </TT>
<P>
Returns YES if the application instance is refusing new sessions, and NO otherwise. When the application instance refuses new sessions, the WebObjects adaptor tries to start the session in another instance of the same application. If no other instance is running and accepting new sessions, the user receives an error message. 
<P>
<B>See Also: </B>-&nbsp;<B>activeSessionsCount</B>, -&nbsp;<B>minimumActiveSessionsCount</B>, -&nbsp;<B>refuseNewSessions:</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/isTerminating meth:isTerminating descr:<TT>- (BOOL)<B>isTerminating</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/isTerminating">isTerminating</a></H3>
   <TT>- (BOOL)<B>isTerminating</B> </TT>
<P>
Returns whether the application will terminate at the end of the current

request-response loop.

<P>

<B>See Also: </b>- <b>setTimeOut:</B>, - <B>terminate</B>, - <B>terminateAfterTimeInterval:</B>, - <B>timeOut</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/logToMonitorWithFormat: meth:logToMonitorWithFormat: descr:<TT>- (void)<B>logToMonitorWithFormat:</B>(NSString *)<I>aFormat</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/logToMonitorWithFormat:">logToMonitorWithFormat:</a></H3>
   <TT>- (void)<B>logToMonitorWithFormat:</B>(NSString *)<I>aFormat</I> </TT>
<P>
Same as <B>logWithFormat:</B> but prints the string to the Monitor application's standard error. That is, the message is displayed in the command-shell window that was used to launch the Monitor application. 
<P>
You use this method to log messages about significant events when the application is ready to be deployed and you will use Monitor regularly to monitor the application. Otherwise, use <B>logWithFormat:</B>. If the Monitor application is not running or if this application instance is not being monitored, this method does nothing. 
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/logWithFormat: meth:logWithFormat: descr:<TT>- (void)<B>logWithFormat:</B>(NSString *)<I>aFormat</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/logWithFormat:">logWithFormat:</a></H3>
   <TT>- (void)<B>logWithFormat:</B>(NSString *)<I>aFormat</I> </TT>
<P>
Prints a message to the standard error device (stderr). The message can include

formatted variable data using <b>printf</b>-style conversion specifiers, for example:

<PRE>    id i = 500;

    id f = 2.045;

    [self logWithFormat:@"Amount = %@, Rate = %@, Total = %@", 
         i, f, i*f];

</PRE>

<P>

Note that in WebScript, all variables are objects, so the only conversion specifier allowed is <TT>%@</TT> as shown above. In compiled Objective-C code, all <b>printf</b> conversion specifiers are allowed. The equivalent 
method in Java is <B>logString</B>. 
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/minimumActiveSessionsCount meth:minimumActiveSessionsCount descr:<TT>- (int)<B>minimumActiveSessionsCount</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/minimumActiveSessionsCount">minimumActiveSessionsCount</a></H3>
   <TT>- (int)<B>minimumActiveSessionsCount</B> </TT>
<P>
Returns the minimum number of active sessions allowed. If the number of active sessions is less than or equal to this number and <B>isRefusingNewSessions</B> is YES, the application instance terminates. The default is 0.
<P>
<B>See Also: </B>-&nbsp;<B>activeSessionsCount</B>, -&nbsp;<B>refuseNewSessions:</B>, -&nbsp;<B>setMinimumActiveSessionsCount:</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/monitoringEnabled meth:monitoringEnabled descr:<TT>- (BOOL)<B>monitoringEnabled</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/monitoringEnabled">monitoringEnabled</a></H3>
   <TT>- (BOOL)<B>monitoringEnabled</B> </TT>
<P>
Returns YES if the application is "monitorable" by the Monitor application, and NO otherwise. An application is "monitorable" if it was able to find a running Monitor upon startup and it is able to successfully communicate with that Monitor.
<P>
By default, all applications are monitorable if the Monitor application is running on the same machine as the application. You can specifically disable monitoring using the <B>-m OFF</B> option on the application command line. If you want the application to be monitorable and the Monitor is running on another host, you can start up the application through Monitor, or you can specify Monitor's host on the application command line this way:
<PRE>MyApp.exe -m ON -mhost <I>monitorHost</I> ...</PRE>
<P>
<B>See Also: </B>-&nbsp;<B>logToMonitorWithFormat:</B>, the online document <A HREF="../../../../../../ServingWebObjects/ServingWebObjectsTOC.html" target=_top><I>Serving WebObjects</I></A>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/name meth:name descr:<TT>- (NSString *)<B>name</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/name">name</a></H3>
   <TT>- (NSString *)<B>name</B> </TT>
<P>
Returns the name of the application minus the ".woa" extension;

for example "HelloWorld" is a typical application name.

<P>

<B>See Also: </b>- <b>baseURL</B>, - <B>path</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/number meth:number descr:<TT>- (NSString *)<B>number</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/number">number</a></H3>
   <TT>- (NSString *)<B>number</B> </TT>
<P>
Returns the application's instance number. If this application instance was started through the Monitor application or if the instance number was explicitly specified on the command line (using the adaptor's <B>-n</B> option), that number is returned by this method. Otherwise, the application's instance number is undefined, and this method sends the message <B>applicationNumber</B> to the current <A HREF="../WORequest/WORequest.html" target=_top>WORequest</A> object to see if it has been assigned an instance number by the request. 
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/pageCacheSize meth:pageCacheSize descr:<TT>- (unsigned int)<B>pageCacheSize</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/pageCacheSize">pageCacheSize</a></H3>
   <TT>- (unsigned int)<B>pageCacheSize</B> </TT>
<P>
Returns the size of the internal cache for page instances. The default size

is 30 instances.

<P>

<B>See Also: </b>- <b>setPageCacheSize:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/pageWithName: meth:pageWithName: descr:<TT>- (WOComponent *)<B>pageWithName:</B>(NSString *)<I>aName</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/pageWithName:">pageWithName:</a></H3>
   <TT>- (WOComponent *)<B>pageWithName:</B>(NSString *)<I>aName</I> </TT>
<P>
Returns a new page instance (a WOComponent object) identified by <I>aName</I>.

If <I>aName</I> is <b>nil</b>, the "Main" component is assumed. If the method cannot

create a valid page instance, it raises an exception.

<P>

<B>See Also: </B> - <B>restorePageForContextID:</B>, - <B>savePage:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/path meth:path descr:<TT>- (NSString *)<B>path</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/path">path</a></H3>
   <TT>- (NSString *)<B>path</B> </TT>
<P>
Returns the file-system path of the application, which is an absolute path

and includes the ".woa" extension; for example

"C:\NeXT\NextLibrary\WOApps\MyApp.woa" is a typical

application path.

<P>

<B>See Also: </b>- <b>baseURL</B>, - <B>name</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/pathForResourceNamed:ofType: meth:pathForResourceNamed:ofType: descr:<TT>- (NSString *)<B>pathForResourceNamed:</B>(NSString *)<I>aName</I> <B>ofType:</B>(NSString *)<I>anExtension</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/pathForResourceNamed:ofType:">pathForResourceNamed:ofType:</a></H3>
   <TT>- (NSString *)<B>pathForResourceNamed:</B>(NSString *)<I>aName</I> <B>ofType:</B>(NSString *)<I>aType</I> </TT>
<P>
Returns the absolute path to the application resource having the name of

<I>aName</I> and an extension of <I>aType</I>. The method searches all localized

application ".lproj" directories before searching directly under the ".woa" wrapper.

<P>

This method is provided for backwards compatibility only. For WebObjects 3.5 and above, you should use the <A HREF="../WOResourceManager/WOResourceManager.html" target=_top>WOResourceManager</A> API to retrieve resources. 
<P>

<B>See Also: </B> - <B>stringForKey:inTableNamed:withDefaultValue:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/printsHTMLParserDiagnostics meth:printsHTMLParserDiagnostics descr:<TT>- (BOOL)<B>printsHTMLParserDiagnostics</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/printsHTMLParserDiagnostics">printsHTMLParserDiagnostics</a></H3>
   <TT>- (BOOL)<B>printsHTMLParserDiagnostics</B> </TT>
<P>
Returns whether the HTML parser prints warning messages to the standard output

device (stdout) if it encounters unbalanced container elements or other

syntactically incorrect HTML.

<P>

<B>See Also:  </b>- <b>setPrintsHTMLParserDiagnostics:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/refuseNewSessions: meth:refuseNewSessions: descr:<TT>- (void)<B>refuseNewSessions:</B>(BOOL)<I>aVal</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/refuseNewSessions:">refuseNewSessions:</a></H3>
   <TT>- (void)<B>refuseNewSessions:</B>(BOOL)<I>flag</I> </TT>
<P>
Controls whether this application instance will create a session when it receives an HTTP request from a new user. If <I>flag</I> is YES, the application does not create new sessions; when it receives a request from a new user, it refuses that request, and the adaptor must try to find another application instance that can process the request. If <I>flag</I> is NO, the application creates new sessions. NO is the default.
<P>
You use this method with <B>setMinimumActiveSessionsCount:</B> to gracefully shut down application instances. Use <B>setMinimumActiveSessionsCount:</B> to set the active session minimum to a certain number. When number of active sessions reaches the number you set and <B>isRefusingNewSessions</B> returns YES, the application terminates. 
<P>
<B>See Also: </B>-&nbsp;<B>activeSessionsCount</B>, -&nbsp;<B>isRefusingNewSessions</B>, -&nbsp;<B>minimumActiveSessionsCount</B>, -&nbsp;<B>setMinimumActiveSessionsCount:</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/resourceManager meth:resourceManager descr:<TT>- (WOResourceManager *)<B>resourceManager</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/resourceManager">resourceManager</a></H3>
   <TT>- (WOResourceManager *)<B>resourceManager</B> </TT>
<P>
Returns the <A HREF="../WOResourceManager/WOResourceManager.html" target=_top>WOResourceManager</A> object that the application uses to manage resources.
<P>
<B>See Also: </B><B>-</B>&nbsp;<B>setResourceManager:</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/restorePageForContextID: meth:restorePageForContextID: descr:<TT>- (WOComponent *)<B>restorePageForContextID:</B>(NSString *)<I>contextID</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/restorePageForContextID:">restorePageForContextID:</a></H3>
   <TT>- (WOComponent *)<B>restorePageForContextID:</B>(NSString *)<I>contextID</I> </TT>
<P>
Returns a page instance stored the session page cache. The key to the stored

instance is the context ID, which derives from the transaction's WOContext

or WORequest objects. This method returns <B>nil</B> if restoration is impossible.

<P>

<B>See Also:  </b>- <b>savePage:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/restoreSession meth:restoreSession descr:<TT>- (WOSession *)<B>restoreSession</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/restoreSession">restoreSession</a></H3>
   <TT>- (WOSession *)<B>restoreSession</B> </TT>
<P>
Restores the WOSession object representing a session. In normal request

handling, this method is invoked at the start of a cycle of the request-response

loop. The default implementation simply invokes WOSessionStore's

<B>restoreSession</B> method, but raises an exception if the WOSessionStore

object is missing.

<P>

<B>See Also:  </b>- <b>createSession</B>, - <B>saveSession:</B>, 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/run meth:run descr:<TT>- (void)<B>run</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/run">run</a></H3>
   <TT>- (void)<B>run</B> </TT>
<P>
Runs the application in a near-indefinite run loop in the default run-loop

mode. Before starting the run loop, the method sends <B>registerForEvents</B>

to the application's adaptors so that they can begin receiving run-loop events.

Normally, <b>run</b> is invoked in the <B>main</B> function.

<P>

<B>See Also:  </b>- <b>setTimeOut:</B>, - <B>terminate</B>, - <B>terminateAfterTimeInterval:</B>

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/runLoop meth:runLoop descr:<TT>- (NSRunLoop *)<B>runLoop</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/runLoop">runLoop</a></H3>
   <TT>- (NSRunLoop *)<B>runLoop</B> </TT>
<P>
Returns the run loop used in the <b>run</b> method.
<P>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/savePage: meth:savePage: descr:<TT>- (void)<B>savePage:</B>(WOComponent *)<I>aPage</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/savePage:">savePage:</a></H3>
   <TT>- (void)<B>savePage:</B>(WOComponent *)<I>aPage</I> </TT>
<P>
Saves the page instance <I>aPage</I> in the session page cache. The

context ID for the current transaction is made the key for obtaining this

instance in the cache using <B>restorePageForContextID:</B>. 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/saveSession: meth:saveSession: descr:<TT>- (void)<B>saveSession:</B>(WOSession *)<I>aSession</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/saveSession:">saveSession:</a></H3>
   <TT>- (void)<B>saveSession:</B>(WOSession *)<I>aSession</I> </TT>
<P>
Saves a WOSession object that represents a session. In normal request handling,

this method is invoked at the end of a cycle of the request-response loop.

The default implementation simply invokes WOSessionStore's <B>saveSession:</B>

method, but raises an exception if the WOSessionStore object is missing.

<P>

<B>See Also:  </b>- <b>restoreSession</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/scriptedClassWithPath: meth:scriptedClassWithPath: descr:<TT>- (Class)<B>scriptedClassWithPath:</B>(NSString *)<I>aPath</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/scriptedClassWithPath:">scriptedClassWithPath:</a></H3>
   <TT>- (Class)<B>scriptedClassWithPath:</B>(NSString *)<I>aPath</I> </TT>
<P>
Loads a scripted class with the pathname <i>aPath</i> into the application. The specified script is parsed assuming the default string encoding, and the class and categories found in the script file are dynamically added to the runtime.
<P>

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/scriptedClassWithPath:encoding: meth:scriptedClassWithPath:encoding: descr:<TT>- (Class)<B>scriptedClassWithPath:</B>(NSString *)<I>aPath</I> <B>encoding:</B>(NSStringEncoding)<I>anEncoding</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/scriptedClassWithPath:encoding:">scriptedClassWithPath:encoding:</a></H3>
   <TT>- (Class)<B>scriptedClassWithPath:</B>(NSString *)<I>aPath</I> <B>encoding:</B>(NSStringEncoding)<I>anEncoding</I> </TT>
<P>
Loads a scripted class with the pathname <i>aPath</i> using the encoding <i>anEncoding</i>. The class and categories found in the script file are dynamically added to the runtime.
<P>

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/session meth:session descr:<TT>- (WOSession *)<B>session</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/session">session</a></H3>
   <TT>- (WOSession *)<B>session</B> </TT>
<P>
Returns the application's current WOSession object. May not be overridden.

<P>

<B>See Also:  </b>+ <b>application</B>, - <B>context</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/sessionStore meth:sessionStore descr:<TT>- (WOSessionStore *)<B>sessionStore</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/sessionStore">sessionStore</a></H3>
   <TT>- (WOSessionStore *)<B>sessionStore</B> </TT>
<P>
Returns the application's current WOSessionStore object (which, by default,

stores state in the server).

<P>

<B>See Also:  </b>- <b>setSessionStore:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setBrowserLaunchingEnabled: meth:setBrowserLaunchingEnabled: descr:<TT>- (void)<B>setBrowserLaunchingEnabled:</B>(BOOL)<I>isEnabled</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setBrowserLaunchingEnabled:">setBrowserLaunchingEnabled:</a></H3>
   <TT>- (void)<B>setBrowserLaunchingEnabled:</B>(BOOL)<I>isEnabled</I> </TT>
<P>
Controls whether starting up this application also launches a web browser. If <I>isEnabled</I> is YES, the application launches the web browser. If NO, the application does not launch the browser. Browser launching is enabled by default as long as there is a WOAdaptorURL key in the file <I>NeXT_ROOT</I><B>/NextLibrary/WOAdaptors/Configuration/WebServerConfig.plist</B>.
<P>
To disable web browser launching, you must send this message in the <B>init</B> method of your application subclass (or application script).
<P>
<B>See Also: </B>-&nbsp;<B>isBrowserLaunchingEnabled</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setCachingEnabled: meth:setCachingEnabled: descr:<TT>- (void)<B>setCachingEnabled:</B>(BOOL)<I>aFlag</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setCachingEnabled:">setCachingEnabled:</a></H3>
   <TT>- (void)<B>setCachingEnabled:</B>(BOOL)<I>aFlag</I> </TT>
<P>
Enables or disables the caching of component definitions. Component definitions

contain templates and other information about pages and subcomponents, and

are used to generate instances of those components. When this flag is enabled,

the application parses the script (or implementation) file, the HTML,

and the declaration (".wod") file of a component once and then stores the

resulting component definition. By default, this kind of caching is disabled

so that you can edit a scripted component without having to relaunch the

application every time to check the results.
You should always enable component-definition caching when you deploy an

application since performance improves significantly. 


<P>

Do not confuse this type of caching with <I>page-instance caching</I> (see

<B>setPageCacheSize:</B>). <A href="#Caching">Caching Strategies</A> in the class description provides further details.

<P>

<B>See Also:  </b>- <b>isCachingEnabled</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setMinimumActiveSessionsCount: meth:setMinimumActiveSessionsCount: descr:<TT>- (void)<B>setMinimumActiveSessionsCount:</B>(int)<I>anInt</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setMinimumActiveSessionsCount:">setMinimumActiveSessionsCount:</a></H3>
   <TT>- (void)<B>setMinimumActiveSessionsCount:</B>(int)<I>anInt</I> </TT>
<P>
Sets the minimum number of active sessions to <I>anInt</I>. The default is 0.
<P>
You use this method to gracefully shut down application instances. If the active sessions count reaches this number and <B>isRefusingNewSessions</B> returns YES, the application terminates. You might want to terminate application instances periodically for performance reasons; some applications leak a certain amount of memory per transaction, and shutting down and restarting instances of those applications can free up that memory.
<P>
<B>See Also: </B>-&nbsp;<B>activeSessionsCount</B>, -&nbsp;<B>isRefusingNewSessions</B>, -&nbsp;<B>minimumActiveSessionsCount</B>, -&nbsp;<B>refuseNewSessions:</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setPageCacheSize: meth:setPageCacheSize: descr:<TT>- (void)<B>setPageCacheSize:</B>(unsigned int)<I>anInt</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setPageCacheSize:">setPageCacheSize:</a></H3>
   <TT>- (void)<B>setPageCacheSize:</B>(unsigned int)<I>anInt</I> </TT>
<P>
Sets whether caching of page instances will occur <I>and</I> the number of

pages the cache will hold. When page-instance caching is enabled, the application

stores the WOComponent instance corresponding to the response page in the session.

When the page is backtracked to, it restores it from the session and makes

it the request page. The state of the page is retained. By default, page-instance

caching is enabled, with a cache limit of 30 pages.

<P>

You turn page-instance caching off by invoking this method with an argument

of zero. In this case, when the user backtracks to a page, the page is not

stored in the session and so must be re-created "from scratch." Do not confuse

this type of caching with <I>component-definition caching</I> (see

<B>setCachingEnabled:</B>).

<P>

See <A href="#Caching">Caching Strategies</A> in the class description for

further details.

<P>

<B>See Also:  </b>- <b>pageCacheSize</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setPageRefreshOnBacktrackEnabled: meth:setPageRefreshOnBacktrackEnabled: descr:<TT>- (void)<B>setPageRefreshOnBacktrackEnabled:</B>(BOOL)<I>aFlag</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setPageRefreshOnBacktrackEnabled:">setPageRefreshOnBacktrackEnabled:</a></H3>
   <TT>- (void)<B>setPageRefreshOnBacktrackEnabled:</B>(BOOL)<I>flag</I> </TT>
<P>
When <I>flag</I> is YES, disables caching of pages by the client

by setting the page's expiration-time header to the current date and time.

(By default, this attribute is set to NO.) Disabling of client

caching affects what happens during backtracking. With client caching turned

off, the browser resends the URL to the server for the page requested by

backtracking. The application must return a new page to the browser

(corresponding to a new WOComponent instance). This behavior is desirable when

you do not want the user to backtrack to a page that might be obsolete because

of changes that have occurred in the session.

<P>

When this flag is turned on and a request corresponding to a client backtrack

occurs, the retrieved page will only be asked to regenerate its response.

The first two phases of a normal request-response loop (value extraction

from the request and action invocation) do not occur.

<P>

See <A href="#Caching">Caching Strategies</A> in the class description for

further details.

<P>

<B>See Also:  </b>- <b>isPageRefreshOnBacktrackEnabled</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setPrintsHTMLParserDiagnostics: meth:setPrintsHTMLParserDiagnostics: descr:<TT>- (void)<B>setPrintsHTMLParserDiagnostics:</B>(BOOL)<I>aBool</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setPrintsHTMLParserDiagnostics:">setPrintsHTMLParserDiagnostics:</a></H3>
   <TT>- (void)<B>setPrintsHTMLParserDiagnostics:</B>(BOOL)<I>aBool</I> </TT>
<P>
Sets whether the HTML parser prints warning messages to the standard output

device (stdout) if it encounters unbalanced container elements or other

syntactically incorrect HTML.

<P>

<B>See Also:  </b>- <b>printsHTMLParserDiagnostics</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setResourceManager: meth:setResourceManager: descr:<TT>- (void)<B>setResourceManager:</B>(WOResourceManager *)<I>aResourceManager</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setResourceManager:">setResourceManager:</a></H3>
   <TT>- (void)<B>setResourceManager:</B>(WOResourceManager *)<I>aResourceManager</I> </TT>
<P>
Sets the <A HREF="../WOResourceManager/WOResourceManager.html" target=_top>WOResourceManager</A> object to <I>aResourceManager</I>. WOResourceManager objects search for and retrieve resources from the application directory and from shared framework directories.
<P>
<B>See Also: </B><B>-</B>&nbsp;<B>resourceManager</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setSessionStore: meth:setSessionStore: descr:<TT>- (void)<B>setSessionStore:</B>(WOSessionStore *)<I>aSessionStore</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setSessionStore:">setSessionStore:</a></H3>
   <TT>- (void)<B>setSessionStore:</B>(WOSessionStore *)<I>aSessionStore</I> </TT>
<P>
Set the session-store object for the application. By default, an object that

stores session state in process memory (that is, in the server) is used.

The session-store object specifies the state storage strategy for the whole

application. This object is responsible for making session objects persistent.

WebObjects supports state storage in the server, in the page, and in cookies.

You should set the session store object when the application starts up, before

the first request is handled.

<P>

<B>See Also:  </b>- <b>sessionStore</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setStatisticsStore: meth:setStatisticsStore: descr:<TT>- (void)<B>setStatisticsStore:</B>(WOStatisticsStore *)<I>aStatisticsStore</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setStatisticsStore:">setStatisticsStore:</a></H3>
   <TT>- (void)<B>setStatisticsStore:</B>(WOStatisticsStore *)<I>aStatisticsStore</I> </TT>
<P>
Sets the <A HREF="../WOStatisticsStore/WOStatisticsStore.html" target=_top>WOStatisticsStore</A> object to <I>aStatisticsStore</I>. WOStatisticsStore objects record application statistics while the application runs. 
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/setTimeOut: meth:setTimeOut: descr:<TT>- (void)<B>setTimeOut:</B>(NSTimeInterval)<I>aTimeInterval</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/setTimeOut:">setTimeOut:</a></H3>
   <TT>- (void)<B>setTimeOut:</B>(NSTimeInterval)<I>aTimeInterval</I> </TT>
<P>
Sets the number of seconds the application can experience inactivity (no

HTTP requests) before it terminates execution.

<P>
This method differs from <B>terminateAfterTimeInterval:</B> in that with this method, the application must be idle
for <I>aTimeInterval</I> seconds for the application to terminate. <B>terminateAfterTimeInterval:</B> terminates the application whether it is active or not.
<P>
<B>See Also:  </b>- <b>timeOut</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/sleep meth:sleep descr:<TT>- (void)<B>sleep</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/sleep">sleep</a></H3>
   <TT>- (void)<B>sleep</B> </TT>
<P>
Invoked at the conclusion of a request-handling cycle to give an application

the opportunity for deallocating objects created and initialized in its

<B>awake</B> method. The default implementation does nothing. 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/statistics meth:statistics descr:<TT>- (bycopyNSDictionary *)<B>statistics</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/statistics">statistics</a></H3>
   <TT>- (bycopy NSDictionary *)<B>statistics</B> </TT>
<P>
Returns a copy of the dictionary containing the application statistics maintained by WOStatisticsStore. This method is used by the Monitor application to retrieve application statistics. If you need to access the statistics internally, use this message instead:
<PRE>[[[WOApplication application] statisticsStore] statistics]</PRE>
<P>
<B>See Also: </B><A HREF="../WOStatisticsStore/WOStatisticsStore.html" target=_top>WOStatisticsStore</A> class
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/statisticsStore meth:statisticsStore descr:<TT>- (WOStatisticsStore *)<B>statisticsStore</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/statisticsStore">statisticsStore</a></H3>
   <TT>- (WOStatisticsStore *)<B>statisticsStore</B> </TT>
<P>
Returns the <A HREF="../WOStatisticsStore/WOStatisticsStore.html" target=_top>WOStatisticsStore</A> object, which records statistics while the application runs.
<P>
<B>See Also: </B><B>-</B>&nbsp;<B>setStatisticsStore:</B>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/stringForKey:inTableNamed:withDefaultValue: meth:stringForKey:inTableNamed:withDefaultValue: descr:<TT>- (NSString *)<B>stringForKey:</B>(NSString *)<I>aKey</I> <B>inTableNamed:</B>(NSString *)<I>aTableName</I> <B>withDefaultValue:</B>(NSString *)<I>aDefaultValue</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/stringForKey:inTableNamed:withDefaultValue:">stringForKey:inTableNamed:withDefaultValue:</a></H3>
   <TT>- (NSString *)<B>stringForKey:</B>(NSString *)<I>aKey</I> <B>inTableNamed:</B>(NSString *)<I>aTable</I> <B>withDefaultValue:</B>(NSString *)<I>defaultValue</I> </TT>
<P>
Returns a localized string from string table "<I>aTable</I>.strings" using

<I>aKey</I> to look it up. If no string value for the key is found in the

table, <I>defaultValue</I> (optional) is returned. The method first searches

the "<I>aTable</I>.strings" file, if it exists, in each localized (".lproj")

subdirectories of the application wrapper; searching proceeds in the order

of the language list maintained by the WOSession object<!-- (for details, see

the <B>setLanguages</B> method of the

<A href="../WOSession/WOSession.html" target=_top> WOSession</A> class)-->.

If no string value matching the key is found, the search then continues to

the "<I>aTable</I>.strings" file (if it exists) directly under the application

wrapper (the directory with the "woa" extension).

<P>

See <A href="#Localization">Localization</A> in the class

description for further details.

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/takeValuesFromRequest:inContext: meth:takeValuesFromRequest:inContext: descr:<TT>- (void)<B>takeValuesFromRequest:</B>(WORequest *)<I>aRequest</I> <B>inContext:</B>(WOContext *)<I>aContext</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/takeValuesFromRequest:inContext:">takeValuesFromRequest:inContext:</a></H3>
   <TT>- (void)<B>takeValuesFromRequest:</B>(WORequest *)<I>aRequest</I> <B>inContext:</B>(WOContext *)<I>aContext</I> </TT>
<P>
The WOApplication object sends this message to itself to start the first

phase of request handling. In this phase, the message is propagated to the

session and component objects involved in the request as well as the request

page's dynamic elements. Each dynamic element acquires any entered data or

changed state (such as a check in a check box) associated with an attribute

and assigns the value to the variable bound to the attribute. The default

WOApplication implementation of this method forwards the message to the

session object.

<P>

<B>See Also:  </b>- <b>appendToResponse:inContext:</B>, - <B>invokeActionForRequest:inContext:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/terminate meth:terminate descr:<TT>- (void)<B>terminate</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/terminate">terminate</a></H3>
   <TT>- (void)<B>terminate</B> </TT>
<P>
Terminates the application process. Termination does not take place until

the handling of the current request has completed.

<P>

<B>See Also:  </b>- <b>isTerminating</B>, - <B>setTimeOut:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/terminateAfterTimeInterval: meth:terminateAfterTimeInterval: descr:<TT>- (void)<B>terminateAfterTimeInterval:</B>(NSTimeInterval)<I>aTimeInterval</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/terminateAfterTimeInterval:">terminateAfterTimeInterval:</a></H3>
   <TT>- (void)<B>terminateAfterTimeInterval:</B>(NSTimeInterval)<I>aTimeInterval</I> </TT>
<P>
Sets the application to terminate itself after <I>aTimeInterval</I> seconds has elapsed. After the specified time interval has elapsed, the application immediately stops all current processing. If any sessions are active, users may lose information. 
<P>
This method differs from <B>setTimeOut:</B> in that it does not set idle time; <B>terminateAfterTimeInterval:</B> shuts down the application regardless of if it is idle. 
<P>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/timeOut meth:timeOut descr:<TT>- (NSTimeInterval)<B>timeOut</B> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/timeOut">timeOut</a></H3>
   <TT>- (NSTimeInterval)<B>timeOut</B> </TT>
<P>
Returns the application's time-out interval: a period (in seconds) of inactivity

before the application terminates execution. The default application time-out

interval is a very large number.

<P>

<B>See Also:  </b>- <b>setTimeOut:</B> 

<hr>
<!-- key://apple_ref/occ/instm/WOApplication/trace: meth:trace: descr:<TT>- (void)<B>trace:</B>(BOOL)<I>aFlag</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/trace:">trace:</a></H3>
   <TT>- (void)<B>trace:</B>(BOOL)<I>aFlag</I> </TT>
<P>
If <i>aFlag</i> is YES, prints all trace messages (messages for scripted messages, compiled messages, and all statements in the application) to the standard error device. If <i>aFlag</i> is NO, stops printing all trace messages.

<P>

<B>See Also: </B>- <b>traceAssignments:</b>, - <b>traceObjectiveCMessages:</b>, - <b>traceScriptedMessages:</b>, - <b>traceStatements:</b>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/traceAssignments: meth:traceAssignments: descr:<TT>- (void)<B>traceAssignments:</B>(BOOL)<I>aFlag</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/traceAssignments:">traceAssignments:</a></H3>
   <TT>- (void)<B>traceAssignments:</B>(BOOL)<I>aFlag</I> </TT>
<P>
If <i>aFlag</i> is YES, prints a message to the standard error device every time an assignment statement is executed. If <i>aFlag</i> is NO, stops printing trace assignment messages.

<P>

<B>See Also: </B>- <b>trace:</b>, - <b>traceObjectiveCMessages:</b>, - <b>traceScriptedMessages:</b>, - <b>traceStatements:</b>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/traceObjectiveCMessages: meth:traceObjectiveCMessages: descr:<TT>- (void)<B>traceObjectiveCMessages:</B>(BOOL)<I>aFlag</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/traceObjectiveCMessages:">traceObjectiveCMessages:</a></H3>
   <TT>- (void)<B>traceObjectiveCMessages:</B>(BOOL)<I>aFlag</I> </TT>
<P>
If <i>aFlag</i> is YES, prints a message to the standard error device every time a message is sent to a compiled class. If <i>aFlag</i> is NO, stops printing trace Objective-C method messages.

<P>

<B>See Also: </B>- <b>trace:</b>, - <b>traceAssignments:</b>, - <b>traceScriptedMessages:</b>, - <b>traceStatements:</b>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/traceScriptedMessages: meth:traceScriptedMessages: descr:<TT>- (void)<B>traceScriptedMessages:</B>(BOOL)<I>aFlag</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/traceScriptedMessages:">traceScriptedMessages:</a></H3>
   <TT>- (void)<B>traceScriptedMessages:</B>(BOOL)<I>aFlag</I> </TT>
<P>
If <i>aFlag</i> is YES, prints a message to the standard error device every time a message is sent to a scripted class. If <i>aFlag</i> is NO, stops printing trace scripted method messages.

<P>

<B>See Also: </B>- <b>trace:</b>, - <b>traceAssignments:</b>, - <b>traceObjectiveCMessages:</b>, - <b>traceStatements:</b>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/traceStatements: meth:traceStatements: descr:<TT>- (void)<B>traceStatements:</B>(BOOL)<I>aFlag</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/traceStatements:">traceStatements:</a></H3>
   <TT>- (void)<B>traceStatements:</B>(BOOL)<I>aFlag</I> </TT>
<P>
If <i>aFlag</i> is YES, prints a message to the standard error device every time a statement in the application is executed. If <i>aFlag</i> is NO, stops printing trace statement messages.

<P>

<B>See Also: </B>- <b>trace:</b>, - <b>traceAssignments:</b>, - <b>traceObjectiveCMessages:</b>, - <b>traceScriptedMessages:</b>
<hr>
<!-- key://apple_ref/occ/instm/WOApplication/urlForResourceNamed:ofType: meth:urlForResourceNamed:ofType: descr:<TT>- (NSString *)<B>urlForResourceNamed:</B>(NSString *)<I>aName</I> <B>ofType:</B>(NSString *)<I>anExtension</I> </TT> -->
<H3><a name="//apple_ref/occ/instm/WOApplication/urlForResourceNamed:ofType:">urlForResourceNamed:ofType:</a></H3>
   <TT>- (NSString *)<B>urlForResourceNamed:</B>(NSString *)<I>aName</I> <B>ofType:</B>(NSString *)<I>aType</I> </TT>
<P>
Returns the URL associated with an application resource having a name of

<I>aName</I> and an extension of <I>aType</I>. The method searches all localized

application ".lproj" directories before searching directly under the ".woa"

wrapper for the resource.

<P>

This method is provided for backwards compatibility only. For WebObjects 3.5 and above, you should use the <A HREF="../WOResourceManager/WOResourceManager.html" target=_top>WOResourceManager</A> API to retrieve resources. 
<P>

<B>See Also:  - <B>stringForKey:inTableNamed:withDefaultValue:</B> 

<hr>
</body>
</html>