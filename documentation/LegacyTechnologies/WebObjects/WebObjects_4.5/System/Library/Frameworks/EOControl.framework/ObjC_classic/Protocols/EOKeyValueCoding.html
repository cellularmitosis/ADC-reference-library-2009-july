<HTML>		<HEAD>		<TITLE>			EOKeyValueCoding		</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOControl Reference</font><br><br><!--end of path --><a href="../EOControlTOC.html"><img src="../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> <a name = "CIACHFGJ"><BR><h1><FONT COLOR="#000066"><a name="//apple_ref/occ/intf/EOKeyValueCoding">EOKeyValueCoding</a></FONT></h1><br></a><blockquote><b>(informal protocol)</b></blockquote><blockquote><dl><b>Declared in: </b><dd>EOControl/EOKeyValueCoding.h</dd></dl></blockquote><br><br><HR SIZE=4><h2>Protocol Description</h2><hr><p>The EOKeyValueCoding informal protocol defines EnterpriseObjects Framework's main data transport mechanism, in which theproperties of an object are accessed indirectly by name (or <em>key</em>), ratherthan directly through invocation of an accessor method or as instancevariables. Thus, all of an object's properties can be accessedin a consistent manner. the Framework additions to NSObject providedefault implementations of EOKeyValueCoding, which are sufficientfor most purposes.</p><p>The basic methods for accessing an object's values are  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeValue:forKey:">takeValue:forKey:</a>,which sets the value for the property identified by the specifiedkey, and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/valueForKey:">valueForKey:</a>,which returns the value for the property identified by the specifiedkey. The default implementations provided by NSObject use the accessor methodsnormally implemented by objects (or to access instance variablesdirectly if need be), so that you don't have to write specialcode simply to integrate your objects into the Enterprise Objects Framework.</p><p>The corresponding methods  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeStoredValue:forKey:">takeStoredValue:forKey:</a> and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/storedValueForKey:">storedValueForKey:</a> aresimilar, but they're considered to be a private API, for use bythe Framework for transporting data to and from <em>trusted</em> sources.For example, <b>takeStoredValue:forKey:</b> isused to initialize an object's properties with values fetchedfrom the database, whereas <b>takeValue:forKey:</b> isused to modify an object's properties to values provided by auser or other business logic. How these methods work and how they'reused by the framework is discussed in more detail in the section  <a frame= "conv" href="../Protocols/More/EOKeyValueCoding.html#BADCCAHA">"Stored Value Methods" </a>.</p><p>Both the basic and stored value key-value coding methods cacheattribute bindings for both accessor methods and instance variables,making lookups efficient. The method  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/flushAllKeyBindings">flushAllKeyBindings</a> is providedto clear these bindings-as you should when you add or modify aclass in the run-time system.</p><p>The the methods  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/accessInstanceVariablesDirectly">accessInstanceVariablesDirectly</a> and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/useStoredAccessor">useStoredAccessor</a> areused by enterprise object classes to modify the behavior of thedefault implementations of key-value coding methods. The remainingmethods,  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleQueryWithUnboundKey:">handleQueryWithUnboundKey:</a>,  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleTakeValue:forUnboundKey:">handleTakeValue:forUnboundKey:</a>,and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/unableToSetNullForKey:">unableToSetNullForKey:</a>,are provided to handle error conditions. The default versions of  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleQueryWithUnboundKey:">handleQueryWithUnboundKey:</a> and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleTakeValue:forUnboundKey:">handleTakeValue:forUnboundKey:</a> raise EOUnknownKeyException, withthe target object (EOTargetObjectUserInfoKey) and key (EOUnknownUserInfoKey)in the user info.</p><p>For more information on EOKeyValueCoding, see the sections:</p><ul><li> <a frame= "conv" href="../Protocols/More/EOKeyValueCoding.html#BADCCAHA">"Stored Value Methods" </a></li><li> <a frame= "conv" href="../Protocols/More/EOKeyValueCoding.html#BADCJJIH">"Type Checking and Type Conversion" </a></li></ul><br><br><h2>Constants</h2><hr><p>In <tt>EOKeyValueCoding.h</tt>, EOControl definesan enumeration with two constants to be used as possible argumentsfor the  <a frame= "conv" href="../Protocols/EOKeyBindingCreation.html#//apple_ref/java/intfm/EOKeyValueCoding.KeyBindingCreation/createKeyValueBindingForKey">createKeyValueBindingForKey</a> and  <a frame= "conv" href="../Protocols/EOKeyBindingCreation.html#//apple_ref/java/intfm/EOKeyValueCoding.KeyBindingCreation/keyValueBindingForKey">keyValueBindingForKey</a> methods. Theargument indicates whether the return value, a  <a frame= "conv" href="../Classes/EOKeyBinding.html#CHCBGIID">EOKeyBinding</a> object, binds a class/keypair to a mechanism to set the value for a key or to retrieve it.</p><br><table border = "1"><tr><td scope="row"><b>Constant</b></td><td><b>Description</b></td></tr><tr><td scope="row"><a name = "BADEADGD"><tt>EOSetKeyBindingMask</tt></a></td><td>Designatesa binding as one responsible for setting an object's value.</td></tr><tr><td scope="row"><a name = "BADCCJBJ"><tt>EOStoredKeyBindingMask</tt></a></td><td>Designatesa binding as one responsible for retrieving an object's value.</td></tr></table><br><br><br><h2>Method Types</h2><hr><blockquote><dl><dt>Accessing values</dt><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/storedValueForKey:">- storedValueForKey:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeStoredValue:forKey:">- takeStoredValue:forKey:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeValue:forKey:">- takeValue:forKey:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/valueForKey:">- valueForKey:</a></dd></dl><dl><dt>Changing default behavior</dt><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/accessInstanceVariablesDirectly">+ accessInstanceVariablesDirectly</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/useStoredAccessor">+ useStoredAccessor</a></dd></dl><dl><dt>Flushing key bindings</dt><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/flushAllKeyBindings">+ flushAllKeyBindings</a></dd></dl><dl><dt>Handling error conditions</dt><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleQueryWithUnboundKey:">- handleQueryWithUnboundKey:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleTakeValue:forUnboundKey:">- handleTakeValue:forUnboundKey:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/unableToSetNullForKey:">- unableToSetNullForKey:</a></dd></dl></blockquote><br><br><h2>Class Methods</h2><hr><a name = "accessInstanceVariablesDirectly"><BR><h3><a name="//apple_ref/occ/clm/EOKeyValueCoding/accessInstanceVariablesDirectly">accessInstanceVariablesDirectly</a></h3></a><p><code>+ (BOOL)<b>accessInstanceVariablesDirectly</b></code></p>Returns YES if the key-value coding methodsshould access the corresponding instance variable directly on findingno accessor method for a property. Returns NO if they shouldn't.NSObject's implementation of this method returns YES. Subclassescan override it to return NO, in which case the key-value codingmethods won't access instance variables.<hr WIDTH=25% ALIGN=LEFT><a name = "flushAllKeyBindings"><BR><h3><a name="//apple_ref/occ/clm/EOKeyValueCoding/flushAllKeyBindings">flushAllKeyBindings</a></h3></a><p><code>+ (void)<b>flushAllKeyBindings</b></code></p>Invalidates the cached key binding informationfor all classes (caches are kept of key-to-method or instance variablebindings in order to make key-value coding efficient). This methodshould be invoked whenever a class is modified in or removed fromthe run-time system.<hr WIDTH=25% ALIGN=LEFT><a name = "useStoredAccessor"><BR><h3><a name="//apple_ref/occ/clm/EOKeyValueCoding/useStoredAccessor">useStoredAccessor</a></h3></a><p><code>+ (BOOL)<b>useStoredAccessor</b></code></p>Returns YES if the stored value methods ( <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/storedValueForKey:">storedValueForKey:</a> and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeStoredValue:forKey:">takeStoredValue:forKey:</a>)should use private accessor methods in preference to public accessors.Returning NO causes the stored value methods to use the same accessormethod-instance variable search order as the corresponding basic key-valuecoding methods ( <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/valueForKey:">valueForKey:</a> and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeValue:forKey:">takeValue:forKey:</a>).NSObject's implementation of this method returns YES.<hr WIDTH=25% ALIGN=LEFT><BR><BR><h2>Instance Methods</h2><hr><a name = "BEDCGBIA"><BR><h3><a name="//apple_ref/occ/intfm/EOKeyValueCoding/handleQueryWithUnboundKey:">handleQueryWithUnboundKey:</a></h3></a><p><code>- (id)<b>handleQueryWithUnboundKey:</b>(NSString*)<em>key</em></code></p>Invoked from  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/valueForKey:">valueForKey:</a> when it finds no propertybinding for <em>key</em>. NSObject's implementation raises an EOUnknownKeyException,with the target object (EOTargetObjectUserInfoKey) and key (EOUnknownUserInfoKey)in the user info. Subclasses can override this method to handlethe query in some other way.<hr WIDTH=25% ALIGN=LEFT><a name = "BEDCFBCC"><BR><h3><a name="//apple_ref/occ/intfm/EOKeyValueCoding/handleTakeValue:forUnboundKey:">handleTakeValue:forUnboundKey:</a></h3></a><p><code>- (void)<b>handleTakeValue:</b>(id)<em>value</em><b>forUnboundKey:</b>(NSString *)<em>key</em></code></p>Invoked from  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeValue:forKey:">takeValue:forKey:</a> when it finds noproperty binding for <em>key</em>. NSObject'simplementation raises an EOUnknownKeyException, with the targetobject (EOTargetObjectUserInfoKey) and key (EOUnknownUserInfoKey)in the user info. Subclasses can override it to handle the requestin some other way.<hr WIDTH=25% ALIGN=LEFT><a name = "BEDDFCAG"><BR><h3><a name="//apple_ref/occ/intfm/EOKeyValueCoding/storedValueForKey:">storedValueForKey:</a></h3></a><p><code>- (id)<b>storedValueForKey:</b>(NSString*)<em>key</em></code></p>Returns the property identified by <em>key</em>.This method is used when the value is retrieved for storage in anobject store (generally, this is ultimately in a database) or forinclusion in a snapshot. The default implementation provided by theFramework additions to NSObject is similar to the implementationof  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/valueForKey:">valueForKey:</a>, butit resolves <em>key</em> with a differentmethod-instance variable search order:<ol><li>Searches for a private accessor method basedon <em>key</em> (a method preceded by an underbar).For example, with a key of "lastName", <b>storedValueForKey:</b> looksfor a method named _getLastName or _lastName.</li><li>If a private accessor isn't found, searches for an instancevariable based on <em>key</em> and returnsits value directly. For example, with a key of "lastName", <b>storedValueForKey:</b> looksfor an instance variable named <b>_lastName</b> or <b>lastName</b>.</li><li>If neither a private accessor or an instance variable is found, <b>storedValueForKey:</b> searchesfor a public accessor method based on <em>key</em>.For the key "lastName", this would be getLastName or lastName.</li><li>If <em>key</em> is unknown, <b>storedValueForKey:</b> calls  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleTakeValue:forUnboundKey:">handleTakeValue:forUnboundKey:</a>.</li></ol><p>This different search order allows an object to bypass processingthat is performed before returning a value through public API. However,if you always want to use the search order in <b>valueForKey:</b>,you can implement the class method  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/useStoredAccessor">useStoredAccessor</a> toreturn NO. And as with <b>valueForKey:</b>, youcan prevent direct access of an instance variable with the methodthe class method  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/accessInstanceVariablesDirectly">accessInstanceVariablesDirectly</a>.</p><hr WIDTH=25% ALIGN=LEFT><a name = "BEDCHICF"><BR><h3><a name="//apple_ref/occ/intfm/EOKeyValueCoding/takeStoredValue:forKey:">takeStoredValue:forKey:</a></h3></a><p><code>- (void)<b>takeStoredValue:</b>(id)<em>value</em><b>forKey:</b>(NSString *)<em>key</em></code></p>Sets the property identified by <em>key</em> to <em>value</em>.This method is used to initialize the receiver with values froman object store (generally, this is ultimately from a database)or to restore a value from a snapshot. The default implementationprovided by the Framework additions to NSObject is similar to the implementationof  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeValue:forKey:">takeValue:forKey:</a>,but it resolves <em>key</em> with a differentmethod-instance variable search order:<ol><li>Searches for a private accessor method basedon <em>key</em> (a method preceded by an underbar).For example, with a key of "lastName", <b>takeStoredValue:forKey:</b> looksfor a method named _setLastName:.</li><li>If a private accessor isn't found, searches for an instancevariable based on <em>key</em> and sets itsvalue directly. For example, with a key of "lastName", <b>takeStoredValue:forKey:</b> looksfor an instance variable named <b>_lastName</b> or <b>lastName</b>.</li><li>If neither a private accessor or an instance variable is found, <b>takeStoredValue:forKey:</b> searchesfor a public accessor method based on <em>key</em>.For the key "lastName", this would be setLastName:.</li><li>If <em>key</em> is unknown, <b>takeStoredValue:forKey:</b> calls  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleTakeValue:forUnboundKey:">handleTakeValue:forUnboundKey:</a>.</li></ol><p>This different search order allows an object to bypass processingthat is performed before setting a value through public API. However,if you always want to use the search order in <b>takeValue:forKey:</b>, youcan implement the class method  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/useStoredAccessor">useStoredAccessor</a> toreturn NO. And as with <b>valueForKey:</b>, youcan prevent direct access of an instance variable with the methodthe class method  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/accessInstanceVariablesDirectly">accessInstanceVariablesDirectly</a>. </p><hr WIDTH=25% ALIGN=LEFT><a name = "BEDDDFHB"><BR><h3><a name="//apple_ref/occ/intfm/EOKeyValueCoding/takeValue:forKey:">takeValue:forKey:</a></h3></a><p><code>- (void)<b>takeValue:</b>(id)<em>value</em><b>forKey:</b>(NSString *)<em>key</em></code></p>Sets the value for the property identified by <em>key</em> to <em>value</em>,invoking  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleTakeValue:forUnboundKey:">handleTakeValue:forUnboundKey:</a> if thereceiver doesn't recognize <em>key</em> and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/unableToSetNullForKey:">unableToSetNullForKey:</a> if <em>value</em> is nil and <em>key</em> identifiesa scalar property.<p>The default implementation provided by the Framework additionsto NSObject works as follows:</p><ol><li>Searches for a public accessor method of theform <b>set</b><em>Key</em><b>:</b>,invoking it if there is one.</li><li>If a public accessor method isn't found, searches for aprivate accessor method of the form <b>_set</b><em>Key</em><b>:</b>,invoking it if there is one.</li><li>If an accessor method isn't found and the class method  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/accessInstanceVariablesDirectly">accessInstanceVariablesDirectly</a> returns YES, <b>takeValue:forKey:</b> searchesfor an instance variable based on <em>key</em> andsets the value directly, autoreleasing the old value and retainingthe new one. For the key "lastName", this would be <b>_lastName</b> or <b>lastName</b>.</li><li>If neither an accessor method nor an instance variable isfound, the default implementation invokes  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleTakeValue:forUnboundKey:">handleTakeValue:forUnboundKey:</a>.</li></ol><hr WIDTH=25% ALIGN=LEFT><a name = "BEDDAGBD"><BR><h3><a name="//apple_ref/occ/intfm/EOKeyValueCoding/unableToSetNullForKey:">unableToSetNullForKey:</a></h3></a><p><code>- (void)<b>unableToSetNilForKey:</b>(NSString*)<em>key</em></code></p>Invoked from  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeValue:forKey:">takeValue:forKey:</a> (and  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeStoredValue:forKey:">takeStoredValue:forKey:</a>)when it's given a nil value for a scalar property (such as an <b>int</b> ora <b>float</b>). NSObject's implementation raisesan NSInvalidArgumentException. Subclasses can override it to handlethe request in some other way, such as by substituting zero or asentinel value and invoking  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/takeValue:forKey:">takeValue:forKey:</a> again.<hr WIDTH=25% ALIGN=LEFT><a name = "BEDCFEGI"><BR><h3><a name="//apple_ref/occ/intfm/EOKeyValueCoding/valueForKey:">valueForKey:</a></h3></a><p><code>- (id)<b>valueForKey:</b>(NSString*)<em>key</em></code></p>Returns the value for the property identifiedby <em>key</em>, invoking  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/handleQueryWithUnboundKey:">handleQueryWithUnboundKey:</a> if the receiverdoesn't recognize <em>key</em>.<p>The default implementation provided by the Framework additionsto NSObject works as follows:</p><ol><li>Searches for a public accessor method based on <em>key</em>.For example, with a key of "lastName", <b>valueForKey:</b><b> </b>looksfor a method named getLastName or lastName.</li><li>If a public accessor method isn't found, searches for aprivate accessor method based on <em>key</em> (a methodpreceded by an underbar). For example, with a key of "lastName", <b>valueForKey:</b> looksfor a method named _getLastName or _lastName.</li><li>If an accessor method isn't found and the class method  <a frame= "conv" href="#//apple_ref/occ/intfm/EOKeyValueCoding/accessInstanceVariablesDirectly">accessInstanceVariablesDirectly</a> returns YES, <b>valueForKey:</b> searchesfor an instance variable based on <em>key </em>andreturns its value directly. For the key "lastName", this wouldbe _lastName or lastName.</li><li>If neither an accessor method nor an instance variable isfound, the default implementation invokes <b>handleQueryWithUnboundKey:</b>.</li></ol><hr WIDTH=25% ALIGN=LEFT><BR><br><a href="../EOControlTOC.html"><img src="../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> </BODY></HTML>