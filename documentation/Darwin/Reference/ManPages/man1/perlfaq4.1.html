<html><head><title>Mac OS X
 Manual Page For perlfaq4(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlfaq4" title="Mac OS X
 Manual Page for perlfaq4(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlfaq4"; name=perlfaq4(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLFAQ4(1)                           Perl Programmers Reference Guide                           PERLFAQ4(1)



<b>NAME</b>
       perlfaq4 - Data Manipulation ($Revision: 1.73 $, $Date: 2005/12/31 00:54:37 $)

<b>DESCRIPTION</b>
       This section of the FAQ answers questions related to manipulating numbers, dates, strings, arrays,
       hashes, and miscellaneous data issues.

<b>Data:</b> <b>Numbers</b>
       <b>Why</b> <b>am</b> <b>I</b> <b>getting</b> <b>long</b> <b>decimals</b> <b>(eg,</b> <b>19.9499999999999)</b> <b>instead</b> <b>of</b> <b>the</b> <b>numbers</b> <b>I</b> <b>should</b> <b>be</b> <b>getting</b> <b>(eg,</b>
       <b>19.95)?</b>

       Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two)
       computers cannot store all numbers exactly.  Some real numbers lose precision in the process.  This
       is a problem with how computers store numbers and affects all computer languages, not just Perl.

       perlnumber show the gory details of number representations and conversions.

       To limit the number of decimal places in your numbers, you can use the printf or sprintf function.
       See the "Floating Point Arithmetic" for more details.

               printf "%.2f", 10/3;

               my $number = sprintf "%.2f", 10/3;

       <b>Why</b> <b>is</b> <u>int()</u> <b>broken?</b>

       Your <u>int()</u> is most probably working just fine.  It's the numbers that aren't quite what you think.

       First, see the above item "Why am I getting long decimals (eg, 19.9499999999999) instead of the num-<font color="#ffffff" class="whiteout">bers&nbsp;numbers</font>
       bers I should be getting (eg, 19.95)?".

       For example, this

           print int(0.6/0.2-2), "\n";

       will in most computers print 0, not 1, because even such simple numbers as 0.6 and 0.2 cannot be pre-<font color="#ffffff" class="whiteout">sented&nbsp;presented</font>
       sented exactly by floating-point numbers.  What you think in the above as 'three' is really more like
       2.9999999999999995559.

       <b>Why</b> <b>isn't</b> <b>my</b> <b>octal</b> <b>data</b> <b>interpreted</b> <b>correctly?</b>

       Perl only understands octal and hex numbers as such when they occur as literals in your program.
       Octal literals in perl must start with a leading "0" and hexadecimal literals must start with a lead-<font color="#ffffff" class="whiteout">ing&nbsp;leading</font>
       ing "0x".  If they are read in from somewhere and assigned, no automatic conversion takes place.  You
       must explicitly use <u>oct()</u> or <u>hex()</u> if you want the values converted to decimal.  <u>oct()</u> interprets hex
       ("0x350"), octal ("0350" or even without the leading "0", like "377") and binary ("0b1010") numbers,
       while <u>hex()</u> only converts hexadecimal ones, with or without a leading "0x", like "0x255", "3A", "ff",
       or "deadbeef".  The inverse mapping from decimal to octal can be done with either the "%o" or "%O"
       <u>sprintf()</u> formats.

       This problem shows up most often when people try using <u>chmod()</u>, <u>mkdir()</u>, <u>umask()</u>, or <u>sysopen()</u>, which
       by widespread tradition typically take permissions in octal.

           chmod(644,  $file); # WRONG
           chmod(0644, $file); # right

       Note the mistake in the first line was specifying the decimal literal 644, rather than the intended
       octal literal 0644.  The problem can be seen with:

           printf("%#o",644); # prints 01204

       Surely you had not intended "chmod(01204, $file);" - did you?  If you want to use numeric literals as
       arguments to <u>chmod()</u> et al. then please try to express them as octal constants, that is with a lead-<font color="#ffffff" class="whiteout">ing&nbsp;leading</font>
       ing zero and with the following digits restricted to the set 0..7.

       <b>Does</b> <b>Perl</b> <b>have</b> <b>a</b> <u>round()</u> <b>function?</b>  <b>What</b> <b>about</b> <u>ceil()</u> <b>and</b> <u>floor()</u><b>?</b>  <b>Trig</b> <b>functions?</b>

       Remember that <u>int()</u> merely truncates toward 0.  For rounding to a certain number of digits, <u>sprintf()</u>
       or <u>printf()</u> is usually the easiest route.

           printf("%.3f", 3.1415926535);       # prints 3.142

       The POSIX module (part of the standard Perl distribution) implements <u>ceil()</u>, <u>floor()</u>, and a number of
       other mathematical and trigonometric functions.

           use POSIX;
           $ceil   = ceil(3.5);                        # 4
           $floor  = floor(3.5);                       # 3

       In 5.000 to 5.003 perls, trigonometry was done in the Math::Complex module.  With 5.004, the
       Math::Trig module (part of the standard Perl distribution) implements the trigonometric functions.
       Internally it uses the Math::Complex module and some functions can break out from the real axis into
       the complex plane, for example the inverse sine of 2.

       Rounding in financial applications can have serious implications, and the rounding method used should
       be specified precisely.  In these cases, it probably pays not to trust whichever system rounding is
       being used by Perl, but to instead implement the rounding function you need yourself.

       To see why, notice how you'll still have an issue on half-way-point alternation:

           for ($i = 0; $i &lt; 1.01; $i += 0.05) { printf "%.1f ",$i}

           0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
           0.8 0.8 0.9 0.9 1.0 1.0

       Don't blame Perl.  It's the same as in C.  IEEE says we have to do this.  Perl numbers whose absolute
       values are integers under 2**31 (on 32 bit machines) will work pretty much like mathematical inte-
       gers.  Other numbers are not guaranteed.

       <b>How</b> <b>do</b> <b>I</b> <b>convert</b> <b>between</b> <b>numeric</b> <b>representations/bases/radixes?</b>

       As always with Perl there is more than one way to do it.  Below are a few examples of approaches to
       making common conversions between number representations.  This is intended to be representational
       rather than exhaustive.

       Some of the examples below use the Bit::Vector module from CPAN.  The reason you might choose
       Bit::Vector over the perl built in functions is that it works with numbers of ANY size, that it is
       optimized for speed on some operations, and for at least some programmers the notation might be
       familiar.

       How do I convert hexadecimal into decimal
           Using perl's built in conversion of 0x notation:

               $dec = 0xDEADBEEF;

           Using the hex function:

               $dec = hex("DEADBEEF");

           Using pack:

               $dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", -8)));

           Using the CPAN module Bit::Vector:

               use Bit::Vector;
               $vec = Bit::Vector-&gt;new_Hex(32, "DEADBEEF");
               $dec = $vec-&gt;to_Dec();

       How do I convert from decimal to hexadecimal
           Using sprintf:

               $hex = sprintf("%X", 3735928559); # upper case A-F
               $hex = sprintf("%x", 3735928559); # lower case a-f

           Using unpack:

               $hex = unpack("H*", pack("N", 3735928559));

           Using Bit::Vector:

               use Bit::Vector;
               $vec = Bit::Vector-&gt;new_Dec(32, -559038737);
               $hex = $vec-&gt;to_Hex();

           And Bit::Vector supports odd bit counts:

               use Bit::Vector;
               $vec = Bit::Vector-&gt;new_Dec(33, 3735928559);
               $vec-&gt;Resize(32); # suppress leading 0 if unwanted
               $hex = $vec-&gt;to_Hex();

       How do I convert from octal to decimal
           Using Perl's built in conversion of numbers with leading zeros:

               $dec = 033653337357; # note the leading 0!

           Using the oct function:

               $dec = oct("33653337357");

           Using Bit::Vector:

               use Bit::Vector;
               $vec = Bit::Vector-&gt;new(32);
               $vec-&gt;Chunk_List_Store(3, split(//, reverse "33653337357"));
               $dec = $vec-&gt;to_Dec();

       How do I convert from decimal to octal
           Using sprintf:

               $oct = sprintf("%o", 3735928559);

           Using Bit::Vector:

               use Bit::Vector;
               $vec = Bit::Vector-&gt;new_Dec(32, -559038737);
               $oct = reverse join('', $vec-&gt;Chunk_List_Read(3));

       How do I convert from binary to decimal
           Perl 5.6 lets you write binary numbers directly with the 0b notation:

               $number = 0b10110110;

           Using oct:

               my $input = "10110110";
               $decimal = oct( "0b$input" );

           Using pack and ord:

               $decimal = ord(pack('B8', '10110110'));

           Using pack and unpack for larger strings:

               $int = unpack("N", pack("B32",
                   substr("0" x 32 . "11110101011011011111011101111", -32)));
               $dec = sprintf("%d", $int);

               # substr() is used to left pad a 32 character string with zeros.

           Using Bit::Vector:

               $vec = Bit::Vector-&gt;new_Bin(32, "11011110101011011011111011101111");
               $dec = $vec-&gt;to_Dec();

       How do I convert from decimal to binary
           Using sprintf (perl 5.6+):

               $bin = sprintf("%b", 3735928559);

           Using unpack:

               $bin = unpack("B*", pack("N", 3735928559));

           Using Bit::Vector:

               use Bit::Vector;
               $vec = Bit::Vector-&gt;new_Dec(32, -559038737);
               $bin = $vec-&gt;to_Bin();

           The remaining transformations (e.g. hex -&gt; oct, bin -&gt; hex, etc.)  are left as an exercise to the
           inclined reader.

       <b>Why</b> <b>doesn't</b> <b>&amp;</b> <b>work</b> <b>the</b> <b>way</b> <b>I</b> <b>want</b> <b>it</b> <b>to?</b>

       The behavior of binary arithmetic operators depends on whether they're used on numbers or strings.
       The operators treat a string as a series of bits and work with that (the string "3" is the bit pat-<font color="#ffffff" class="whiteout">tern&nbsp;pattern</font>
       tern 00110011).  The operators work with the binary form of a number (the number 3 is treated as the
       bit pattern 00000011).

       So, saying "11 &amp; 3" performs the "and" operation on numbers (yielding 3).  Saying "11" &amp; "3" performs
       the "and" operation on strings (yielding "1").

       Most problems with "&amp;" and "|" arise because the programmer thinks they have a number but really it's
       a string.  The rest arise because the programmer says:

           if ("\020\020" &amp; "\101\101") {
               # ...
           }

       but a string consisting of two null bytes (the result of ""\020\020" &amp; "\101\101"") is not a false
       value in Perl.  You need:

           if ( ("\020\020" &amp; "\101\101") !~ /[^\000]/) {
               # ...
           }

       <b>How</b> <b>do</b> <b>I</b> <b>multiply</b> <b>matrices?</b>

       Use the Math::Matrix or Math::MatrixReal modules (available from CPAN) or the PDL extension (also
       available from CPAN).

       <b>How</b> <b>do</b> <b>I</b> <b>perform</b> <b>an</b> <b>operation</b> <b>on</b> <b>a</b> <b>series</b> <b>of</b> <b>integers?</b>

       To call a function on each element in an array, and collect the results, use:

           @results = map { my_func($_) } @array;

       For example:

           @triple = map { 3 * $_ } @single;

       To call a function on each element of an array, but ignore the results:

           foreach $iterator (@array) {
               some_func($iterator);
           }

       To call a function on each integer in a (small) range, you <b>can</b> use:

           @results = map { some_func($_) } (5 .. 25);

       but you should be aware that the ".." operator creates an array of all integers in the range.  This
       can take a lot of memory for large ranges.  Instead use:

           @results = ();
           for ($i=5; $i &lt; 500_005; $i++) {
               push(@results, some_func($i));
           }

       This situation has been fixed in Perl5.005. Use of ".." in a "for" loop will iterate over the range,
       without creating the entire range.

           for my $i (5 .. 500_005) {
               push(@results, some_func($i));
           }

       will not create a list of 500,000 integers.

       <b>How</b> <b>can</b> <b>I</b> <b>output</b> <b>Roman</b> <b>numerals?</b>

       Get the <a href="http://www.cpan.org/modules/by-module/Roman">http://www.cpan.org/modules/by-module/Roman</a> module.

       <b>Why</b> <b>aren't</b> <b>my</b> <b>random</b> <b>numbers</b> <b>random?</b>

       If you're using a version of Perl before 5.004, you must call "srand" once at the start of your pro-
       gram to seed the random number generator.

                BEGIN { srand() if $] &lt; 5.004 }

       5.004 and later automatically call "srand" at the beginning.  Don't call "srand" more than once---you
       make your numbers less random, rather than more.

       Computers are good at being predictable and bad at being random (despite appearances caused by bugs
       in your programs :-).  see the <u>random</u> article in the "Far More Than You Ever Wanted To Know" collec-
       tion in <a href="http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz">http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz</a> , courtesy of Tom Phoenix, talks more about
       this.  John von Neumann said, "Anyone who attempts to generate random numbers by deterministic means
       is, of course, living in a state of sin."

       If you want numbers that are more random than "rand" with "srand" provides, you should also check out
       the Math::TrulyRandom module from CPAN.  It uses the imperfections in your system's timer to generate
       random numbers, but this takes quite a while.  If you want a better pseudorandom generator than comes
       with your operating system, look at "Numerical Recipes in C" at <a href="http://www.nr.com/">http://www.nr.com/</a> .

       <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>a</b> <b>random</b> <b>number</b> <b>between</b> <b>X</b> <b>and</b> <b>Y?</b>

       "rand($x)" returns a number such that "0 &lt;= rand($x) &lt; $x". Thus what you want to have perl figure
       out is a random number in the range from 0 to the difference between your <u>X</u> and <u>Y</u>.

       That is, to get a number between 10 and 15, inclusive, you want a random number between 0 and 5 that
       you can then add to 10.

           my $number = 10 + int rand( 15-10+1 );

       Hence you derive the following simple function to abstract that. It selects a random integer between
       the two given integers (inclusive), For example: "random_int_in(50,120)".

          sub random_int_in ($$) {
            my($min, $max) = @_;
             # Assumes that the two arguments are integers themselves!
            return $min if $min == $max;
            ($min, $max) = ($max, $min)  if  $min &gt; $max;
            return $min + int rand(1 + $max - $min);
          }

<b>Data:</b> <b>Dates</b>
       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>the</b> <b>day</b> <b>or</b> <b>week</b> <b>of</b> <b>the</b> <b>year?</b>

       The localtime function returns the day of the year.  Without an argument localtime uses the current
       time.

               $day_of_year = (localtime)[7];

       The POSIX module can also format a date as the day of the year or week of the year.

               use POSIX qw/strftime/;
               my $day_of_year  = strftime "%j", localtime;
               my $week_of_year = strftime "%W", localtime;

       To get the day of year for any date, use the Time::Local module to get a time in epoch seconds for
       the argument to localtime.

               use POSIX qw/strftime/;
               use Time::Local;
               my $week_of_year = strftime "%W",
                       localtime( timelocal( 0, 0, 0, 18, 11, 1987 ) );

       The Date::Calc module provides two functions to calculate these.

               use Date::Calc;
               my $day_of_year  = Day_of_Year(  1987, 12, 18 );
               my $week_of_year = Week_of_Year( 1987, 12, 18 );

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>the</b> <b>current</b> <b>century</b> <b>or</b> <b>millennium?</b>

       Use the following simple functions:

           sub get_century    {
               return int((((localtime(shift || time))[5] + 1999))/100);
           }

           sub get_millennium {
               return 1+int((((localtime(shift || time))[5] + 1899))/1000);
           }

       On some systems, the POSIX module's <u>strftime()</u> function has been extended in a non-standard way to
       use a %C format, which they sometimes claim is the "century".  It isn't, because on most such sys-
       tems, this is only the first two digits of the four-digit year, and thus cannot be used to reliably
       determine the current century or millennium.

       <b>How</b> <b>can</b> <b>I</b> <b>compare</b> <b>two</b> <b>dates</b> <b>and</b> <b>find</b> <b>the</b> <b>difference?</b>

       (contributed by brian d foy)

       You could just store all your dates as a number and then subtract. Life isn't always that simple
       though. If you want to work with formatted dates, the Date::Manip, Date::Calc, or DateTime modules
       can help you.

       <b>How</b> <b>can</b> <b>I</b> <b>take</b> <b>a</b> <b>string</b> <b>and</b> <b>turn</b> <b>it</b> <b>into</b> <b>epoch</b> <b>seconds?</b>

       If it's a regular enough string that it always has the same format, you can split it up and pass the
       parts to "timelocal" in the standard Time::Local module.  Otherwise, you should look into the
       Date::Calc and Date::Manip modules from CPAN.

       <b>How</b> <b>can</b> <b>I</b> <b>find</b> <b>the</b> <b>Julian</b> <b>Day?</b>

       (contributed by brian d foy and Dave Cross)

       You can use the Time::JulianDay module available on CPAN.  Ensure that you really want to find a
       Julian day, though, as many people have different ideas about Julian days.  See <a href="http://www.hermetic.ch/cal_stud/jdn.htm">http://www.her-</a>
       <a href="http://www.hermetic.ch/cal_stud/jdn.htm">metic.ch/cal_stud/jdn.htm</a> for instance.

       You can also try the DateTime module, which can convert a date/time to a Julian Day.

         $ perl -MDateTime -le'print DateTime-&gt;today-&gt;jd'
         2453401.5

       Or the modified Julian Day

         $ perl -MDateTime -le'print DateTime-&gt;today-&gt;mjd'
         53401

       Or even the day of the year (which is what some people think of as a Julian day)

         $ perl -MDateTime -le'print DateTime-&gt;today-&gt;doy'
         31

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>yesterday's</b> <b>date?</b>

       (contributed by brian d foy)

       Use one of the Date modules. The "DateTime" module makes it simple, and give you the same time of
       day, only the day before.

               use DateTime;

               my $yesterday = DateTime-&gt;now-&gt;subtract( days =&gt; 1 );

               print "Yesterday was $yesterday\n";

       You can also use the "Date::Calc" module using its Today_and_Now function.

               use Date::Calc qw( Today_and_Now Add_Delta_DHMS );

               my @date_time = Add_Delta_DHMS( Today_and_Now(), -1, 0, 0, 0 );

               print "@date\n";

       Most people try to use the time rather than the calendar to figure out dates, but that assumes that
       days are twenty-four hours each.  For most people, there are two days a year when they aren't: the
       switch to and from summer time throws this off. Let the modules do the work.

       <b>Does</b> <b>Perl</b> <b>have</b> <b>a</b> <b>Year</b> <b>2000</b> <b>problem?</b>  <b>Is</b> <b>Perl</b> <b>Y2K</b> <b>compliant?</b>

       Short answer: No, Perl does not have a Year 2000 problem.  Yes, Perl is Y2K compliant (whatever that
       means).  The programmers you've hired to use it, however, probably are not.

       Long answer: The question belies a true understanding of the issue.  Perl is just as Y2K compliant as
       your pencil--no more, and no less.  Can you use your pencil to write a non-Y2K-compliant memo?  Of
       course you can.  Is that the pencil's fault?  Of course it isn't.

       The date and time functions supplied with Perl (gmtime and localtime) supply adequate information to
       determine the year well beyond 2000 (2038 is when trouble strikes for 32-bit machines).  The year
       returned by these functions when used in a list context is the year minus 1900.  For years between
       1910 and 1999 this <u>happens</u> to be a 2-digit decimal number. To avoid the year 2000 problem simply do
       not treat the year as a 2-digit number.  It isn't.

       When <u>gmtime()</u> and <u>localtime()</u> are used in scalar context they return a timestamp string that contains
       a fully-expanded year.  For example, "$timestamp = <!-- a -->gmtime(1005613200)<!-- /a -->" sets $timestamp to "Tue Nov 13
       01:00:00 2001".  There's no year 2000 problem here.

       That doesn't mean that Perl can't be used to create non-Y2K compliant programs.  It can.  But so can
       your pencil.  It's the fault of the user, not the language.  At the risk of inflaming the NRA: "Perl
       doesn't break Y2K, people do."  See <a href="http://www.perl.org/about/y2k.html">http://www.perl.org/about/y2k.html</a> for a longer exposition.

<b>Data:</b> <b>Strings</b>
       <b>How</b> <b>do</b> <b>I</b> <b>validate</b> <b>input?</b>

       (contributed by brian d foy)

       There are many ways to ensure that values are what you expect or want to accept. Besides the specific
       examples that we cover in the perlfaq, you can also look at the modules with "Assert" and "Validate"
       in their names, along with other modules such as "Regexp::Common".

       Some modules have validation for particular types of input, such as "Business::ISBN", "Busi-
       ness::CreditCard", "Email::Valid", and "Data::Validate::IP".

       <b>How</b> <b>do</b> <b>I</b> <b>unescape</b> <b>a</b> <b>string?</b>

       It depends just what you mean by "escape".  URL escapes are dealt with in perlfaq9.  Shell escapes
       with the backslash ("\") character are removed with

           s/\\(.)/$1/g;

       This won't expand "\n" or "\t" or any other special escapes.

       <b>How</b> <b>do</b> <b>I</b> <b>remove</b> <b>consecutive</b> <b>pairs</b> <b>of</b> <b>characters?</b>

       (contributed by brian d foy)

       You can use the substitution operator to find pairs of characters (or runs of characters) and replace
       them with a single instance. In this substitution, we find a character in "(.)". The memory parenthe-
       ses store the matched character in the back-reference "\1" and we use that to require that the same
       thing immediately follow it. We replace that part of the string with the character in $1.

           s/(.)\1/$1/g;

       We can also use the transliteration operator, "tr///". In this example, the search list side of our
       "tr///" contains nothing, but the "c" option complements that so it contains everything. The replace-
       ment list also contains nothing, so the transliteration is almost a no-op since it won't do any
       replacements (or more exactly, replace the character with itself). However, the "s" option squashes
       duplicated and consecutive characters in the string so a character does not show up next to itself

               my $str = 'Haarlem';   # in the Netherlands
           $str =~ tr///cs;       # Now Harlem, like in New York

       <b>How</b> <b>do</b> <b>I</b> <b>expand</b> <b>function</b> <b>calls</b> <b>in</b> <b>a</b> <b>string?</b>

       (contributed by brian d foy)

       This is documented in perlref, and although it's not the easiest thing to read, it does work. In each
       of these examples, we call the function inside the braces used to dereference a reference. If we have
       a more than one return value, we can construct and dereference an anonymous array. In this case, we
       call the function in list context.

               print "The time values are @{ [localtime] }.\n";

       If we want to call the function in scalar context, we have to do a bit more work. We can really have
       any code we like inside the braces, so we simply have to end with the scalar reference, although how
       you do that is up to you, and you can use code inside the braces.

               print "The time is ${\(scalar localtime)}.\n"

               print "The time is ${ my $x = localtime; \$x }.\n";

       If your function already returns a reference, you don't need to create the reference yourself.

               sub timestamp { my $t = localtime; \$t }

               print "The time is ${ timestamp() }.\n";

       The "Interpolation" module can also do a lot of magic for you. You can specify a variable name, in
       this case "E", to set up a tied hash that does the interpolation for you. It has several other meth-
       ods to do this as well.

               use Interpolation E =&gt; 'eval';
               print "The time values are $E{localtime()}.\n";

       In most cases, it is probably easier to simply use string concatenation, which also forces scalar
       context.

               print "The time is " . localtime . ".\n";

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>matching/nesting</b> <b>anything?</b>

       This isn't something that can be done in one regular expression, no matter how complicated.  To find
       something between two single characters, a pattern like "/x([^x]*)x/" will get the intervening bits
       in $1. For multiple ones, then something more like "/alpha(.*?)omega/" would be needed.  But none of
       these deals with nested patterns.  For balanced expressions using "(", "{", "[" or "&lt;" as delimiters,
       use the CPAN module Regexp::Common, or see "(??{ code })" in perlre.  For other cases, you'll have to
       write a parser.

       If you are serious about writing a parser, there are a number of modules or oddities that will make
       your life a lot easier.  There are the CPAN modules Parse::RecDescent, Parse::Yapp, and Text::Bal-
       anced; and the byacc program.   Starting from perl 5.8 the Text::Balanced is part of the standard
       distribution.

       One simple destructive, inside-out approach that you might try is to pull out the smallest nesting
       parts one at a time:

           while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {
               # do something with $1
           }

       A more complicated and sneaky approach is to make Perl's regular expression engine do it for you.
       This is courtesy Dean Inada, and rather has the nature of an Obfuscated Perl Contest entry, but it
       really does work:

           # $_ contains the string to parse
           # BEGIN and END are the opening and closing markers for the
           # nested text.

           @( = ('(','');
           @) = (')','');
           ($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;
           @$ = (eval{/$re/},$@!~/unmatched/i);
           print join("\n",@$[0..$#$]) if( $$[-1] );

       <b>How</b> <b>do</b> <b>I</b> <b>reverse</b> <b>a</b> <b>string?</b>

       Use <u>reverse()</u> in scalar context, as documented in "reverse" in perlfunc.

           $reversed = reverse $string;

       <b>How</b> <b>do</b> <b>I</b> <b>expand</b> <b>tabs</b> <b>in</b> <b>a</b> <b>string?</b>

       You can do it yourself:

           1 while $string =~ s/\t+/' ' x (length($&amp;) * 8 - length($`) % 8)/e;

       Or you can just use the Text::Tabs module (part of the standard Perl distribution).

           use Text::Tabs;
           @expanded_lines = expand(@lines_with_tabs);

       <b>How</b> <b>do</b> <b>I</b> <b>reformat</b> <b>a</b> <b>paragraph?</b>

       Use Text::Wrap (part of the standard Perl distribution):

           use Text::Wrap;
           print wrap("\t", '  ', @paragraphs);

       The paragraphs you give to Text::Wrap should not contain embedded newlines.  Text::Wrap doesn't jus-
       tify the lines (flush-right).

       Or use the CPAN module Text::Autoformat.  Formatting files can be easily done by making a shell
       alias, like so:

           alias fmt="perl -i -MText::Autoformat -n0777 \
               -e 'print autoformat $_, {all=&gt;1}' $*"

       See the documentation for Text::Autoformat to appreciate its many capabilities.

       <b>How</b> <b>can</b> <b>I</b> <b>access</b> <b>or</b> <b>change</b> <b>N</b> <b>characters</b> <b>of</b> <b>a</b> <b>string?</b>

       You can access the first characters of a string with <u>substr()</u>.  To get the first character, for exam-
       ple, start at position 0 and grab the string of length 1.

               $string = "Just another Perl Hacker";
           $first_char = substr( $string, 0, 1 );  #  'J'

       To change part of a string, you can use the optional fourth argument which is the replacement string.

           substr( $string, 13, 4, "Perl 5.8.0" );

       You can also use <u>substr()</u> as an lvalue.

           substr( $string, 13, 4 ) =  "Perl 5.8.0";

       <b>How</b> <b>do</b> <b>I</b> <b>change</b> <b>the</b> <b>Nth</b> <b>occurrence</b> <b>of</b> <b>something?</b>

       You have to keep track of N yourself.  For example, let's say you want to change the fifth occurrence
       of "whoever" or "whomever" into "whosoever" or "whomsoever", case insensitively.  These all assume
       that $_ contains the string to be altered.

           $count = 0;
           s{((whom?)ever)}{
               ++$count == 5           # is it the 5th?
                   ? "${2}soever"      # yes, swap
                   : $1                # renege and leave it there
           }ige;

       In the more general case, you can use the "/g" modifier in a "while" loop, keeping count of matches.

           $WANT = 3;
           $count = 0;
           $_ = "One fish two fish red fish blue fish";
           while (/(\w+)\s+fish\b/gi) {
               if (++$count == $WANT) {
                   print "The third fish is a $1 one.\n";
               }
           }

       That prints out: "The third fish is a red one."  You can also use a repetition count and repeated
       pattern like this:

           /(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;

       <b>How</b> <b>can</b> <b>I</b> <b>count</b> <b>the</b> <b>number</b> <b>of</b> <b>occurrences</b> <b>of</b> <b>a</b> <b>substring</b> <b>within</b> <b>a</b> <b>string?</b>

       There are a number of ways, with varying efficiency.  If you want a count of a certain single charac-
       ter (X) within a string, you can use the "tr///" function like so:

           $string = "ThisXlineXhasXsomeXx'sXinXit";
           $count = ($string =~ tr/X//);
           print "There are $count X characters in the string";

       This is fine if you are just looking for a single character.  However, if you are trying to count
       multiple character substrings within a larger string, "tr///" won't work.  What you can do is wrap a
       <u>while()</u> loop around a global pattern match.  For example, let's count negative integers:

           $string = "-9 55 48 -2 23 -76 4 14 -44";
           while ($string =~ /-\d+/g) { $count++ }
           print "There are $count negative numbers in the string";

       Another version uses a global match in list context, then assigns the result to a scalar, producing a
       count of the number of matches.

               $count = () = $string =~ /-\d+/g;

       <b>How</b> <b>do</b> <b>I</b> <b>capitalize</b> <b>all</b> <b>the</b> <b>words</b> <b>on</b> <b>one</b> <b>line?</b>

       To make the first letter of each word upper case:

               $line =~ s/\b(\w)/\U$1/g;

       This has the strange effect of turning ""don't do it"" into ""Don'T Do It"".  Sometimes you might
       want this.  Other times you might need a more thorough solution (Suggested by brian d foy):

           $string =~ s/ (
                        (^\w)    #at the beginning of the line
                          |      # or
                        (\s\w)   #preceded by whitespace
                          )
                       /\U$1/xg;
           $string =~ /([\w']+)/\u\L$1/g;

       To make the whole line upper case:

               $line = uc($line);

       To force each word to be lower case, with the first letter upper case:

               $line =~ s/(\w+)/\u\L$1/g;

       You can (and probably should) enable locale awareness of those characters by placing a "use locale"
       pragma in your program.  See perllocale for endless details on locales.

       This is sometimes referred to as putting something into "title case", but that's not quite accurate.
       Consider the proper capitalization of the movie <u>Dr.</u> <u>Strangelove</u> <u>or:</u> <u>How</u> <u>I</u> <u>Learned</u> <u>to</u> <u>Stop</u> <u>Worrying</u>
       <u>and</u> <u>Love</u> <u>the</u> <u>Bomb</u>, for example.

       Damian Conway's Text::Autoformat module provides some smart case transformations:

           use Text::Autoformat;
           my $x = "Dr. Strangelove or: How I Learned to Stop ".
             "Worrying and Love the Bomb";

           print $x, "\n";
           for my $style (qw( sentence title highlight ))
           {
               print autoformat($x, { case =&gt; $style }), "\n";
           }

       <b>How</b> <b>can</b> <b>I</b> <b>split</b> <b>a</b> <b>[character]</b> <b>delimited</b> <b>string</b> <b>except</b> <b>when</b> <b>inside</b> <b>[character]?</b>

       Several modules can handle this sort of pasing---Text::Balanced, Text::CSV, Text::CSV_XS, and
       Text::ParseWords, among others.

       Take the example case of trying to split a string that is comma-separated into its different fields.
       You can't use "split(/,/)" because you shouldn't split if the comma is inside quotes.  For example,
       take a data line like this:

           SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"

       Due to the restriction of the quotes, this is a fairly complex problem.  Thankfully, we have Jeffrey
       Friedl, author of <u>Mastering</u> <u>Regular</u> <u>Expressions</u>, to handle these for us.  He suggests (assuming your
       string is contained in $text):

            @new = ();
            push(@new, $+) while $text =~ m{
                "([^\"\\]*(?:\\.[^\"\\]*)*)",?  # groups the phrase inside the quotes
              | ([^,]+),?
              | ,
            }gx;
            push(@new, undef) if substr($text,-1,1) eq ',';

       If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with
       backslashes (eg, "like \"this\"".

       Alternatively, the Text::ParseWords module (part of the standard Perl distribution) lets you say:

           use Text::ParseWords;
           @new = quotewords(",", 0, $text);

       There's also a Text::CSV (Comma-Separated Values) module on CPAN.

       <b>How</b> <b>do</b> <b>I</b> <b>strip</b> <b>blank</b> <b>space</b> <b>from</b> <b>the</b> <b>beginning/end</b> <b>of</b> <b>a</b> <b>string?</b>

       (contributed by brian d foy)

       A substitution can do this for you. For a single line, you want to replace all the leading or trail-
       ing whitespace with nothing. You can do that with a pair of substitutions.

               s/^\s+//;
               s/\s+$//;

       You can also write that as a single substitution, although it turns out the combined statement is
       slower than the separate ones. That might not matter to you, though.

               s/^\s+|\s+$//g;

       In this regular expression, the alternation matches either at the beginning or the end of the string
       since the anchors have a lower precedence than the alternation. With the "/g" flag, the substitution
       makes all possible matches, so it gets both. Remember, the trailing newline matches the "\s+", and
       the "$" anchor can match to the physical end of the string, so the newline disappears too. Just add
       the newline to the output, which has the added benefit of preserving "blank" (consisting entirely of
       whitespace) lines which the "^\s+" would remove all by itself.

               while( &lt;&gt; )
                       {
                       s/^\s+|\s+$//g;
                       print "$_\n";
                       }

       For a multi-line string, you can apply the regular expression to each logical line in the string by
       adding the "/m" flag (for "multi-line"). With the "/m" flag, the "$" matches <u>before</u> an embedded new-
       line, so it doesn't remove it. It still removes the newline at the end of the string.

           $string =~ s/^\s+|\s+$//gm;

       Remember that lines consisting entirely of whitespace will disappear, since the first part of the
       alternation can match the entire string and replace it with nothing. If need to keep embedded blank
       lines, you have to do a little more work. Instead of matching any whitespace (since that includes a
       newline), just match the other whitespace.

               $string =~ s/^[\t\f ]+|[\t\f ]+$//mg;

       <b>How</b> <b>do</b> <b>I</b> <b>pad</b> <b>a</b> <b>string</b> <b>with</b> <b>blanks</b> <b>or</b> <b>pad</b> <b>a</b> <b>number</b> <b>with</b> <b>zeroes?</b>

       In the following examples, $pad_len is the length to which you wish to pad the string, $text or $num
       contains the string to be padded, and $pad_char contains the padding character. You can use a single
       character string constant instead of the $pad_char variable if you know what it is in advance. And in
       the same way you can use an integer in place of $pad_len if you know the pad length in advance.

       The simplest method uses the "sprintf" function. It can pad on the left or right with blanks and on
       the left with zeroes and it will not truncate the result. The "pack" function can only pad strings on
       the right with blanks and it will truncate the result to a maximum length of $pad_len.

           # Left padding a string with blanks (no truncation):
               $padded = sprintf("%${pad_len}s", $text);
               $padded = sprintf("%*s", $pad_len, $text);  # same thing

           # Right padding a string with blanks (no truncation):
               $padded = sprintf("%-${pad_len}s", $text);
               $padded = sprintf("%-*s", $pad_len, $text); # same thing

           # Left padding a number with 0 (no truncation):
               $padded = sprintf("%0${pad_len}d", $num);
               $padded = sprintf("%0*d", $pad_len, $num); # same thing

           # Right padding a string with blanks using pack (will truncate):
           $padded = pack("A$pad_len",$text);

       If you need to pad with a character other than blank or zero you can use one of the following meth-
       ods.  They all generate a pad string with the "x" operator and combine that with $text. These methods
       do not truncate $text.

       Left and right padding with any character, creating a new string:

           $padded = $pad_char x ( $pad_len - length( $text ) ) . $text;
           $padded = $text . $pad_char x ( $pad_len - length( $text ) );

       Left and right padding with any character, modifying $text directly:

           substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) );
           $text .= $pad_char x ( $pad_len - length( $text ) );

       <b>How</b> <b>do</b> <b>I</b> <b>extract</b> <b>selected</b> <b>columns</b> <b>from</b> <b>a</b> <b>string?</b>

       Use <u>substr()</u> or <u>unpack()</u>, both documented in perlfunc.  If you prefer thinking in terms of columns
       instead of widths, you can use this kind of thing:

           # determine the unpack format needed to split Linux ps output
           # arguments are cut columns
           my $fmt = cut2fmt(8, 14, 20, 26, 30, 34, 41, 47, 59, 63, 67, 72);

           sub cut2fmt {
               my(@positions) = @_;
               my $template  = '';
               my $lastpos   = 1;
               for my $place (@positions) {
                   $template .= "A" . ($place - $lastpos) . " ";
                   $lastpos   = $place;
               }
               $template .= "A*";
               return $template;
           }

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>the</b> <b>soundex</b> <b>value</b> <b>of</b> <b>a</b> <b>string?</b>

       (contributed by brian d foy)

       You can use the Text::Soundex module. If you want to do fuzzy or close matching, you might also try
       the String::Approx, and Text::Metaphone, and Text::DoubleMetaphone modules.

       <b>How</b> <b>can</b> <b>I</b> <b>expand</b> <b>variables</b> <b>in</b> <b>text</b> <b>strings?</b>

       Let's assume that you have a string that contains placeholder variables.

           $text = 'this has a $foo in it and a $bar';

       You can use a substitution with a double evaluation.  The first /e turns $1 into $foo, and the second
       /e turns $foo into its value.  You may want to wrap this in an "eval": if you try to get the value of
       an undeclared variable while running under "use strict", you get a fatal error.

           eval { $text =~ s/(\$\w+)/$1/eeg };
           die if $@;

       It's probably better in the general case to treat those variables as entries in some special hash.
       For example:

           %user_defs = (
               foo  =&gt; 23,
               bar  =&gt; 19,
           );
           $text =~ s/\$(\w+)/$user_defs{$1}/g;

       <b>What's</b> <b>wrong</b> <b>with</b> <b>always</b> <b>quoting</b> <b>"$vars"?</b>

       The problem is that those double-quotes force stringification-- coercing numbers and references into
       strings--even when you don't want them to be strings.  Think of it this way: double-quote expansion
       is used to produce new strings.  If you already have a string, why do you need more?

       If you get used to writing odd things like these:

           print "$var";       # BAD
           $new = "$old";      # BAD
           somefunc("$var");   # BAD

       You'll be in trouble.  Those should (in 99.8% of the cases) be the simpler and more direct:

           print $var;
           $new = $old;
           somefunc($var);

       Otherwise, besides slowing you down, you're going to break code when the thing in the scalar is actu-
       ally neither a string nor a number, but a reference:

           func(\@array);
           sub func {
               my $aref = shift;
               my $oref = "$aref";  # WRONG
           }

       You can also get into subtle problems on those few operations in Perl that actually do care about the
       difference between a string and a number, such as the magical "++" autoincrement operator or the
       <u>syscall()</u> function.

       Stringification also destroys arrays.

           @lines = `command`;
           print "@lines";             # WRONG - extra blanks
           print @lines;               # right

       <b>Why</b> <b>don't</b> <b>my</b> <b>&lt;&lt;HERE</b> <b>documents</b> <b>work?</b>

       Check for these three things:

       There must be no space after the &lt;&lt; part.
       There (probably) should be a semicolon at the end.
       You can't (easily) have any space in front of the tag.

       If you want to indent the text in the here document, you can do this:

           # all in one
           ($VAR = &lt;&lt;HERE_TARGET) =~ s/^\s+//gm;
               your text
               goes here
           HERE_TARGET

       But the HERE_TARGET must still be flush against the margin.  If you want that indented also, you'll
       have to quote in the indentation.

           ($quote = &lt;&lt;'    FINIS') =~ s/^\s+//gm;
                   ...we will have peace, when you and all your works have
                   perished--and the works of your dark master to whom you
                   would deliver us. You are a liar, Saruman, and a corrupter
                   of men's hearts.  --Theoden in /usr/src/perl/taint.c
               FINIS
           $quote =~ s/\s+--/\n--/;

       A nice general-purpose fixer-upper function for indented here documents follows.  It expects to be
       called with a here document as its argument.  It looks to see whether each line begins with a common
       substring, and if so, strips that substring off.  Otherwise, it takes the amount of leading white-
       space found on the first line and removes that much off each subsequent line.

           sub fix {
               local $_ = shift;
               my ($white, $leader);  # common whitespace and common leading string
               if (/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/) {
                   ($white, $leader) = ($2, quotemeta($1));
               } else {
                   ($white, $leader) = (/^(\s+)/, '');
               }
               s/^\s*?$leader(?:$white)?//gm;
               return $_;
           }

       This works with leading special strings, dynamically determined:

           $remember_the_main = fix&lt;&lt;'    MAIN_INTERPRETER_LOOP';
               @@@ int
               @@@ runops() {
               @@@     SAVEI32(runlevel);
               @@@     runlevel++;
               @@@     while ( op = (*op-&gt;op_ppaddr)() );
               @@@     TAINT_NOT;
               @@@     return 0;
               @@@ }
           MAIN_INTERPRETER_LOOP

       Or with a fixed amount of leading whitespace, with remaining indentation correctly preserved:

           $poem = fix&lt;&lt;EVER_ON_AND_ON;
              Now far ahead the Road has gone,
                 And I must follow, if I can,
              Pursuing it with eager feet,
                 Until it joins some larger way
              Where many paths and errands meet.
                 And whither then? I cannot say.
                       --Bilbo in /usr/src/perl/pp_ctl.c
           EVER_ON_AND_ON

<b>Data:</b> <b>Arrays</b>
       <b>What</b> <b>is</b> <b>the</b> <b>difference</b> <b>between</b> <b>a</b> <b>list</b> <b>and</b> <b>an</b> <b>array?</b>

       An array has a changeable length.  A list does not.  An array is something you can push or pop, while
       a list is a set of values.  Some people make the distinction that a list is a value while an array is
       a variable.  Subroutines are passed and return lists, you put things into list context, you initial-
       ize arrays with lists, and you <u>foreach()</u> across a list.  "@" variables are arrays, anonymous arrays
       are arrays, arrays in scalar context behave like the number of elements in them, subroutines access
       their arguments through the array @_, and push/pop/shift only work on arrays.

       As a side note, there's no such thing as a list in scalar context.  When you say

           $scalar = (2, 5, 7, 9);

       you're using the comma operator in scalar context, so it uses the scalar comma operator.  There never
       was a list there at all!  This causes the last value to be returned: 9.

       <b>What</b> <b>is</b> <b>the</b> <b>difference</b> <b>between</b> <b>$array</b>[1] and @array[1]?

       The former is a scalar value; the latter an array slice, making it a list with one (scalar) value.
       You should use $ when you want a scalar value (most of the time) and @ when you want a list with one
       scalar value in it (very, very rarely; nearly never, in fact).

       Sometimes it doesn't make a difference, but sometimes it does.  For example, compare:

           $good[0] = `some program that outputs several lines`;

       with

           @bad[0]  = `same program that outputs several lines`;

       The "use warnings" pragma and the <b>-w</b> flag will warn you about these matters.

       <b>How</b> <b>can</b> <b>I</b> <b>remove</b> <b>duplicate</b> <b>elements</b> <b>from</b> <b>a</b> <b>list</b> <b>or</b> <b>array?</b>

       (contributed by brian d foy)

       Use a hash. When you think the words "unique" or "duplicated", think "hash keys".

       If you don't care about the order of the elements, you could just create the hash then extract the
       keys. It's not important how you create that hash: just that you use "keys" to get the unique ele-
       ments.

          my %hash   = map { $_, 1 } @array;
          # or a hash slice: @hash{ @array } = ();
          # or a foreach: $hash{$_} = 1 foreach ( @array );

          my @unique = keys %hash;

       You can also go through each element and skip the ones you've seen before. Use a hash to keep track.
       The first time the loop sees an element, that element has no key in %Seen. The "next" statement cre-
       ates the key and immediately uses its value, which is "undef", so the loop continues to the "push"
       and increments the value for that key. The next time the loop sees that same element, its key exists
       in the hash <u>and</u> the value for that key is true (since it's not 0 or undef), so the next skips that
       iteration and the loop goes to the next element.

               my @unique = ();
               my %seen   = ();

               foreach my $elem ( @array )
                       {
                       next if $seen{ $elem }++;
                       push @unique, $elem;
                       }

       You can write this more briefly using a grep, which does the same thing.

          my %seen = ();
          my @unique = grep { ! $seen{ $_ }++ } @array;

       <b>How</b> <b>can</b> <b>I</b> <b>tell</b> <b>whether</b> <b>a</b> <b>certain</b> <b>element</b> <b>is</b> <b>contained</b> <b>in</b> <b>a</b> <b>list</b> <b>or</b> <b>array?</b>

       (portions of this answer contributed by Anno Siegel)

       Hearing the word "in" is an <u>in</u>dication that you probably should have used a hash, not a list or
       array, to store your data.  Hashes are designed to answer this question quickly and efficiently.
       Arrays aren't.

       That being said, there are several ways to approach this.  If you are going to make this query many
       times over arbitrary string values, the fastest way is probably to invert the original array and
       maintain a hash whose keys are the first array's values.

           @blues = qw/azure cerulean teal turquoise lapis-lazuli/;
           %is_blue = ();
           for (@blues) { $is_blue{$_} = 1 }

       Now you can check whether $is_blue{$some_color}.  It might have been a good idea to keep the blues
       all in a hash in the first place.

       If the values are all small integers, you could use a simple indexed array.  This kind of an array
       will take up less space:

           @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
           @is_tiny_prime = ();
           for (@primes) { $is_tiny_prime[$_] = 1 }
           # or simply  @istiny_prime[@primes] = (1) x @primes;

       Now you check whether $is_tiny_prime[$some_number].

       If the values in question are integers instead of strings, you can save quite a lot of space by using
       bit strings instead:

           @articles = ( 1..10, 150..2000, 2017 );
           undef $read;
           for (@articles) { vec($read,$_,1) = 1 }

       Now check whether "vec($read,$n,1)" is true for some $n.

       These methods guarantee fast individual tests but require a re-organization of the original list or
       array.  They only pay off if you have to test multiple values against the same array.

       If you are testing only once, the standard module List::Util exports the function "first" for this
       purpose.  It works by stopping once it finds the element. It's written in C for speed, and its Perl
       equivalant looks like this subroutine:

               sub first (&amp;@) {
                       my $code = shift;
                       foreach (@_) {
                               return $_ if &amp;{$code}();
                       }
                       undef;
               }

       If speed is of little concern, the common idiom uses grep in scalar context (which returns the number
       of items that passed its condition) to traverse the entire list. This does have the benefit of
       telling you how many matches it found, though.

               my $is_there = grep $_ eq $whatever, @array;

       If you want to actually extract the matching elements, simply use grep in list context.

               my @matches = grep $_ eq $whatever, @array;

       <b>How</b> <b>do</b> <b>I</b> <b>compute</b> <b>the</b> <b>difference</b> <b>of</b> <b>two</b> <b>arrays?</b>  <b>How</b> <b>do</b> <b>I</b> <b>compute</b> <b>the</b> <b>intersection</b> <b>of</b> <b>two</b> <b>arrays?</b>

       Use a hash.  Here's code to do both and more.  It assumes that each element is unique in a given
       array:

           @union = @intersection = @difference = ();
           %count = ();
           foreach $element (@array1, @array2) { $count{$element}++ }
           foreach $element (keys %count) {
               push @union, $element;
               push @{ $count{$element} &gt; 1 ? \@intersection : \@difference }, $element;
           }

       Note that this is the <u>symmetric</u> <u>difference</u>, that is, all elements in either A or in B but not in
       both.  Think of it as an xor operation.

       <b>How</b> <b>do</b> <b>I</b> <b>test</b> <b>whether</b> <b>two</b> <b>arrays</b> <b>or</b> <b>hashes</b> <b>are</b> <b>equal?</b>

       The following code works for single-level arrays.  It uses a stringwise comparison, and does not dis-
       tinguish defined versus undefined empty strings.  Modify if you have other needs.

           $are_equal = compare_arrays(\@frogs, \@toads);

           sub compare_arrays {
               my ($first, $second) = @_;
               no warnings;  # silence spurious -w undef complaints
               return 0 unless @$first == @$second;
               for (my $i = 0; $i &lt; @$first; $i++) {
                   return 0 if $first-&gt;[$i] ne $second-&gt;[$i];
               }
               return 1;
           }

       For multilevel structures, you may wish to use an approach more like this one.  It uses the CPAN mod-
       ule FreezeThaw:

           use FreezeThaw qw(cmpStr);
           @a = @b = ( "this", "that", [ "more", "stuff" ] );

           printf "a and b contain %s arrays\n",
               cmpStr(\@a, \@b) == 0
                   ? "the same"
                   : "different";

       This approach also works for comparing hashes.  Here we'll demonstrate two different answers:

           use FreezeThaw qw(cmpStr cmpStrHard);

           %a = %b = ( "this" =&gt; "that", "extra" =&gt; [ "more", "stuff" ] );
           $a{EXTRA} = \%b;
           $b{EXTRA} = \%a;

           printf "a and b contain %s hashes\n",
               cmpStr(\%a, \%b) == 0 ? "the same" : "different";

           printf "a and b contain %s hashes\n",
               cmpStrHard(\%a, \%b) == 0 ? "the same" : "different";

       The first reports that both those the hashes contain the same data, while the second reports that
       they do not.  Which you prefer is left as an exercise to the reader.

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>the</b> <b>first</b> <b>array</b> <b>element</b> <b>for</b> <b>which</b> <b>a</b> <b>condition</b> <b>is</b> <b>true?</b>

       To find the first array element which satisfies a condition, you can use the <u>first()</u> function in the
       List::Util module, which comes with Perl 5.8.  This example finds the first element that contains
       "Perl".

               use List::Util qw(first);

               my $element = first { /Perl/ } @array;

       If you cannot use List::Util, you can make your own loop to do the same thing.  Once you find the
       element, you stop the loop with last.

               my $found;
               foreach ( @array )
                       {
                       if( /Perl/ ) { $found = $_; last }
                       }

       If you want the array index, you can iterate through the indices and check the array element at each
       index until you find one that satisfies the condition.

               my( $found, $index ) = ( undef, -1 );
               for( $i = 0; $i &lt; @array; $i++ )
                       {
                       if( $array[$i] =~ /Perl/ )
                               {
                               $found = $array[$i];
                               $index = $i;
                               last;
                               }
                       }

       <b>How</b> <b>do</b> <b>I</b> <b>handle</b> <b>linked</b> <b>lists?</b>

       In general, you usually don't need a linked list in Perl, since with regular arrays, you can push and
       pop or shift and unshift at either end, or you can use splice to add and/or remove arbitrary number
       of elements at arbitrary points.  Both pop and shift are both <!-- a -->O(1)<!-- /a --> operations on Perl's dynamic
       arrays.  In the absence of shifts and pops, push in general needs to reallocate on the order every
       <!-- a -->log(N)<!-- /a --> times, and unshift will need to copy pointers each time.

       If you really, really wanted, you could use structures as described in perldsc or perltoot and do
       just what the algorithm book tells you to do.  For example, imagine a list node like this:

           $node = {
               VALUE =&gt; 42,
               LINK  =&gt; undef,
           };

       You could walk the list this way:

           print "List: ";
           for ($node = $head;  $node; $node = $node-&gt;{LINK}) {
               print $node-&gt;{VALUE}, " ";
           }
           print "\n";

       You could add to the list this way:

           my ($head, $tail);
           $tail = append($head, 1);       # grow a new head
           for $value ( 2 .. 10 ) {
               $tail = append($tail, $value);
           }

           sub append {
               my($list, $value) = @_;
               my $node = { VALUE =&gt; $value };
               if ($list) {
                   $node-&gt;{LINK} = $list-&gt;{LINK};
                   $list-&gt;{LINK} = $node;
               } else {
                   $_[0] = $node;      # replace caller's version
               }
               return $node;
           }

       But again, Perl's built-in are virtually always good enough.

       <b>How</b> <b>do</b> <b>I</b> <b>handle</b> <b>circular</b> <b>lists?</b>

       Circular lists could be handled in the traditional fashion with linked lists, or you could just do
       something like this with an array:

           unshift(@array, pop(@array));  # the last shall be first
           push(@array, shift(@array));   # and vice versa

       <b>How</b> <b>do</b> <b>I</b> <b>shuffle</b> <b>an</b> <b>array</b> <b>randomly?</b>

       If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later
       installed, you can say:

           use List::Util 'shuffle';

               @shuffled = shuffle(@list);

       If not, you can use a Fisher-Yates shuffle.

           sub fisher_yates_shuffle {
               my $deck = shift;  # $deck is a reference to an array
               my $i = @$deck;
               while (--$i) {
                   my $j = int rand ($i+1);
                   @$deck[$i,$j] = @$deck[$j,$i];
               }
           }

           # shuffle my mpeg collection
           #
           my @mpeg = &lt;audio/*/*.mp3&gt;;
           fisher_yates_shuffle( \@mpeg );    # randomize @mpeg in place
           print @mpeg;

       Note that the above implementation shuffles an array in place, unlike the <u>List::Util::shuffle()</u> which
       takes a list and returns a new shuffled list.

       You've probably seen shuffling algorithms that work using splice, randomly picking another element to
       swap the current element with

           srand;
           @new = ();
           @old = 1 .. 10;  # just a demo
           while (@old) {
               push(@new, splice(@old, rand @old, 1));
           }

       This is bad because splice is already <!-- a -->O(N)<!-- /a -->, and since you do it N times, you just invented a quadrat-
       ic algorithm; that is, O(N**2).  This does not scale, although Perl is so efficient that you probably
       won't notice this until you have rather largish arrays.

       <b>How</b> <b>do</b> <b>I</b> <b>process/modify</b> <b>each</b> <b>element</b> <b>of</b> <b>an</b> <b>array?</b>

       Use "for"/"foreach":

           for (@lines) {
                       s/foo/bar/;     # change that word
                       tr/XZ/ZX/;      # swap those letters
           }

       Here's another; let's compute spherical volumes:

           for (@volumes = @radii) {   # @volumes has changed parts
                       $_ **= 3;
                       $_ *= (4/3) * 3.14159;  # this will be constant folded
           }

       which can also be done with <u>map()</u> which is made to transform one list into another:

               @volumes = map {$_ ** 3 * (4/3) * 3.14159} @radii;

       If you want to do the same thing to modify the values of the hash, you can use the "values" function.
       As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the
       value.

           for $orbit ( values %orbits ) {
                       ($orbit **= 3) *= (4/3) * 3.14159;
           }

       Prior to perl 5.6 "values" returned copies of the values, so older perl code often contains construc-
       tions such as @orbits{keys %orbits} instead of "values %orbits" where the hash is to be modified.

       <b>How</b> <b>do</b> <b>I</b> <b>select</b> <b>a</b> <b>random</b> <b>element</b> <b>from</b> <b>an</b> <b>array?</b>

       Use the <u>rand()</u> function (see "rand" in perlfunc):

           $index   = rand @array;
           $element = $array[$index];

       Or, simply:
           my $element = $array[ rand @array ];

       <b>How</b> <b>do</b> <b>I</b> <b>permute</b> <b>N</b> <b>elements</b> <b>of</b> <b>a</b> <b>list?</b>

       Use the List::Permutor module on CPAN.  If the list is actually an array, try the Algorithm::Permute
       module (also on CPAN).  It's written in XS code and is very efficient.

               use Algorithm::Permute;
               my @array = 'a'..'d';
               my $p_iterator = Algorithm::Permute-&gt;new ( \@array );
               while (my @perm = $p_iterator-&gt;next) {
                  print "next permutation: (@perm)\n";
               }

       For even faster execution, you could do:

          use Algorithm::Permute;
          my @array = 'a'..'d';
          Algorithm::Permute::permute {
             print "next permutation: (@array)\n";
          } @array;

       Here's a little program that generates all permutations of all the words on each line of input. The
       algorithm embodied in the <u>permute()</u> function is discussed in Volume 4 (still unpublished) of Knuth's
       <u>The</u> <u>Art</u> <u>of</u> <u>Computer</u> <u>Programming</u> and will work on any list:

               #!/usr/bin/perl -n
               # Fischer-Kause ordered permutation generator

               sub permute (&amp;@) {
                       my $code = shift;
                       my @idx = 0..$#_;
                       while ( $code-&gt;(@_[@idx]) ) {
                               my $p = $#idx;
                               --$p while $idx[$p-1] &gt; $idx[$p];
                               my $q = $p or return;
                               push @idx, reverse splice @idx, $p;
                               ++$q while $idx[$p-1] &gt; $idx[$q];
                               @idx[$p-1,$q]=@idx[$q,$p-1];
                       }
               }

               permute {print"@_\n"} split;

       <b>How</b> <b>do</b> <b>I</b> <b>sort</b> <b>an</b> <b>array</b> <b>by</b> <b>(anything)?</b>

       Supply a comparison function to <u>sort()</u> (described in "sort" in perlfunc):

           @list = sort { $a &lt;=&gt; $b } @list;

       The default sort function is cmp, string comparison, which would sort "(1, 2, 10)" into "(1, 10, 2)".
       "&lt;=&gt;", used above, is the numerical comparison operator.

       If you have a complicated function needed to pull out the part you want to sort on, then don't do it
       inside the sort function.  Pull it out first, because the sort BLOCK can be called many times for the
       same element.  Here's an example of how to pull out the first word after the first number on each
       item, and then sort those words case-insensitively.

           @idx = ();
           for (@data) {
               ($item) = /\d+\s*(\S+)/;
               push @idx, uc($item);
           }
           @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];

       which could also be written this way, using a trick that's come to be known as the Schwartzian Trans-
       form:

           @sorted = map  { $_-&gt;[0] }
                     sort { $a-&gt;[1] cmp $b-&gt;[1] }
                     map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @data;

       If you need to sort on several fields, the following paradigm is useful.

           @sorted = sort { field1($a) &lt;=&gt; field1($b) ||
                            field2($a) cmp field2($b) ||
                            field3($a) cmp field3($b)
                          }     @data;

       This can be conveniently combined with precalculation of keys as given above.

       See the <u>sort</u> article in the "Far More Than You Ever Wanted To Know" collection in
       <a href="http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz">http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz</a> for more about this approach.

       See also the question below on sorting hashes.

       <b>How</b> <b>do</b> <b>I</b> <b>manipulate</b> <b>arrays</b> <b>of</b> <b>bits?</b>

       Use <u>pack()</u> and <u>unpack()</u>, or else <u>vec()</u> and the bitwise operations.

       For example, this sets $vec to have bit N set if $ints[N] was set:

           $vec = '';
           foreach(@ints) { vec($vec,$_,1) = 1 }

       Here's how, given a vector in $vec, you can get those bits into your @ints array:

           sub bitvec_to_list {
               my $vec = shift;
               my @ints;
               # Find null-byte density then select best algorithm
               if ($vec =~ tr/\0// / length $vec &gt; 0.95) {
                   use integer;
                   my $i;
                   # This method is faster with mostly null-bytes
                   while($vec =~ /[^\0]/g ) {
                       $i = -9 + 8 * pos $vec;
                       push @ints, $i if vec($vec, ++$i, 1);
                       push @ints, $i if vec($vec, ++$i, 1);
                       push @ints, $i if vec($vec, ++$i, 1);
                       push @ints, $i if vec($vec, ++$i, 1);
                       push @ints, $i if vec($vec, ++$i, 1);
                       push @ints, $i if vec($vec, ++$i, 1);
                       push @ints, $i if vec($vec, ++$i, 1);
                       push @ints, $i if vec($vec, ++$i, 1);
                   }
               } else {
                   # This method is a fast general algorithm
                   use integer;
                   my $bits = unpack "b*", $vec;
                   push @ints, 0 if $bits =~ s/^(\d)// &amp;&amp; $1;
                   push @ints, pos $bits while($bits =~ /1/g);
               }
               return \@ints;
           }

       This method gets faster the more sparse the bit vector is.  (Courtesy of Tim Bunce and Winfried
       Koenig.)

       You can make the while loop a lot shorter with this suggestion from Benjamin Goldberg:

               while($vec =~ /[^\0]+/g ) {
                  push @ints, grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
               }

       Or use the CPAN module Bit::Vector:

           $vector = Bit::Vector-&gt;new($num_of_bits);
           $vector-&gt;Index_List_Store(@ints);
           @ints = $vector-&gt;Index_List_Read();

       Bit::Vector provides efficient methods for bit vector, sets of small integers and "big int" math.

       Here's a more extensive illustration using <u>vec()</u>:

           # vec demo
           $vector = "\xff\x0f\xef\xfe";
           print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ",
               unpack("N", $vector), "\n";
           $is_set = vec($vector, 23, 1);
           print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\n";
           pvec($vector);

           set_vec(1,1,1);
           set_vec(3,1,1);
           set_vec(23,1,1);

           set_vec(3,1,3);
           set_vec(3,2,3);
           set_vec(3,4,3);
           set_vec(3,4,7);
           set_vec(3,8,3);
           set_vec(3,8,7);

           set_vec(0,32,17);
           set_vec(1,32,17);

           sub set_vec {
               my ($offset, $width, $value) = @_;
               my $vector = '';
               vec($vector, $offset, $width) = $value;
               print "offset=$offset width=$width value=$value\n";
               pvec($vector);
           }

           sub pvec {
               my $vector = shift;
               my $bits = unpack("b*", $vector);
               my $i = 0;
               my $BASE = 8;

               print "vector length in bytes: ", length($vector), "\n";
               @bytes = unpack("A8" x length($vector), $bits);
               print "bits are: @bytes\n\n";
           }

       <b>Why</b> <b>does</b> <u>defined()</u> <b>return</b> <b>true</b> <b>on</b> <b>empty</b> <b>arrays</b> <b>and</b> <b>hashes?</b>

       The short story is that you should probably only use defined on scalars or functions, not on aggre-
       gates (arrays and hashes).  See "defined" in perlfunc in the 5.004 release or later of Perl for more
       detail.

<b>Data:</b> <b>Hashes</b> <b>(Associative</b> <b>Arrays)</b>
       <b>How</b> <b>do</b> <b>I</b> <b>process</b> <b>an</b> <b>entire</b> <b>hash?</b>

       Use the <u>each()</u> function (see "each" in perlfunc) if you don't care whether it's sorted:

           while ( ($key, $value) = each %hash) {
               print "$key = $value\n";
           }

       If you want it sorted, you'll have to use <u>foreach()</u> on the result of sorting the keys as shown in an
       earlier question.

       <b>What</b> <b>happens</b> <b>if</b> <b>I</b> <b>add</b> <b>or</b> <b>remove</b> <b>keys</b> <b>from</b> <b>a</b> <b>hash</b> <b>while</b> <b>iterating</b> <b>over</b> <b>it?</b>

       (contributed by brian d foy)

       The easy answer is "Don't do that!"

       If you iterate through the hash with <u>each()</u>, you can delete the key most recently returned without
       worrying about it.  If you delete or add other keys, the iterator may skip or double up on them since
       perl may rearrange the hash table.  See the entry for "each()" in perlfunc.

       <b>How</b> <b>do</b> <b>I</b> <b>look</b> <b>up</b> <b>a</b> <b>hash</b> <b>element</b> <b>by</b> <b>value?</b>

       Create a reverse hash:

           %by_value = reverse %by_key;
           $key = $by_value{$value};

       That's not particularly efficient.  It would be more space-efficient to use:

           while (($key, $value) = each %by_key) {
               $by_value{$value} = $key;
           }

       If your hash could have repeated values, the methods above will only find one of the associated keys.
       This may or may not worry you.  If it does worry you, you can always reverse the hash into a hash of
       arrays instead:

            while (($key, $value) = each %by_key) {
                push @{$key_list_by_value{$value}}, $key;
            }

       <b>How</b> <b>can</b> <b>I</b> <b>know</b> <b>how</b> <b>many</b> <b>entries</b> <b>are</b> <b>in</b> <b>a</b> <b>hash?</b>

       If you mean how many keys, then all you have to do is use the <u>keys()</u> function in a scalar context:

           $num_keys = keys %hash;

       The <u>keys()</u> function also resets the iterator, which means that you may see strange results if you use
       this between uses of other hash operators such as <u>each()</u>.

       <b>How</b> <b>do</b> <b>I</b> <b>sort</b> <b>a</b> <b>hash</b> <b>(optionally</b> <b>by</b> <b>value</b> <b>instead</b> <b>of</b> <b>key)?</b>

       (contributed by brian d foy)

       To sort a hash, start with the keys. In this example, we give the list of keys to the sort function
       which then compares them ASCIIbetically (which might be affected by your locale settings). The output
       list has the keys in ASCIIbetical order. Once we have the keys, we can go through them to create a
       report which lists the keys in ASCIIbetical order.

               my @keys = sort { $a cmp $b } keys %hash;

               foreach my $key ( @keys )
                       {
                       printf "%-20s %6d\n", $key, $hash{$value};
                       }

       We could get more fancy in the "sort()" block though. Instead of comparing the keys, we can compute a
       value with them and use that value as the comparison.

       For instance, to make our report order case-insensitive, we use the "\L" sequence in a double-quoted
       string to make everything lowercase. The "sort()" block then compares the lowercased values to deter-
       mine in which order to put the keys.

               my @keys = sort { "\L$a" cmp "\L$b" } keys %hash;

       Note: if the computation is expensive or the hash has many elements, you may want to look at the
       Schwartzian Transform to cache the computation results.

       If we want to sort by the hash value instead, we use the hash key to look it up. We still get out a
       list of keys, but this time they are ordered by their value.

               my @keys = sort { $hash{$a} &lt;=&gt; $hash{$b} } keys %hash;

       From there we can get more complex. If the hash values are the same, we can provide a secondary sort
       on the hash key.

               my @keys = sort {
                       $hash{$a} &lt;=&gt; $hash{$b}
                               or
                       "\L$a" cmp "\L$b"
                       } keys %hash;

       <b>How</b> <b>can</b> <b>I</b> <b>always</b> <b>keep</b> <b>my</b> <b>hash</b> <b>sorted?</b>

       You can look into using the DB_File module and <u>tie()</u> using the $DB_BTREE hash bindings as documented
       in "In Memory Databases" in DB_File.  The Tie::IxHash module from CPAN might also be instructive.

       <b>What's</b> <b>the</b> <b>difference</b> <b>between</b> <b>"delete"</b> <b>and</b> <b>"undef"</b> <b>with</b> <b>hashes?</b>

       Hashes contain pairs of scalars: the first is the key, the second is the value.  The key will be
       coerced to a string, although the value can be any kind of scalar: string, number, or reference.  If
       a key $key is present in %hash, "exists($hash{$key})" will return true.  The value for a given key
       can be "undef", in which case $hash{$key} will be "undef" while "exists $hash{$key}" will return
       true.  This corresponds to ($key, "undef") being in the hash.

       Pictures help...  here's the %hash table:

                 keys  values
               +------+------+
               |  a   |  3   |
               |  x   |  7   |
               |  d   |  0   |
               |  e   |  2   |
               +------+------+

       And these conditions hold

               $hash{'a'}                       is true
               $hash{'d'}                       is false
               defined $hash{'d'}               is true
               defined $hash{'a'}               is true
               exists $hash{'a'}                is true (Perl5 only)
               grep ($_ eq 'a', keys %hash)     is true

       If you now say

               undef $hash{'a'}

       your table now reads:

                 keys  values
               +------+------+
               |  a   | undef|
               |  x   |  7   |
               |  d   |  0   |
               |  e   |  2   |
               +------+------+

       and these conditions now hold; changes in caps:

               $hash{'a'}                       is FALSE
               $hash{'d'}                       is false
               defined $hash{'d'}               is true
               defined $hash{'a'}               is FALSE
               exists $hash{'a'}                is true (Perl5 only)
               grep ($_ eq 'a', keys %hash)     is true

       Notice the last two: you have an undef value, but a defined key!

       Now, consider this:

               delete $hash{'a'}

       your table now reads:

                 keys  values
               +------+------+
               |  x   |  7   |
               |  d   |  0   |
               |  e   |  2   |
               +------+------+

       and these conditions now hold; changes in caps:

               $hash{'a'}                       is false
               $hash{'d'}                       is false
               defined $hash{'d'}               is true
               defined $hash{'a'}               is false
               exists $hash{'a'}                is FALSE (Perl5 only)
               grep ($_ eq 'a', keys %hash)     is FALSE

       See, the whole entry is gone!

       <b>Why</b> <b>don't</b> <b>my</b> <b>tied</b> <b>hashes</b> <b>make</b> <b>the</b> <b>defined/exists</b> <b>distinction?</b>

       This depends on the tied hash's implementation of <u>EXISTS()</u>.  For example, there isn't the concept of
       undef with hashes that are tied to DBM* files. It also means that <u>exists()</u> and <u>defined()</u> do the same
       thing with a DBM* file, and what they end up doing is not what they do with ordinary hashes.

       <b>How</b> <b>do</b> <b>I</b> <b>reset</b> <b>an</b> <u>each()</u> <b>operation</b> <b>part-way</b> <b>through?</b>

       Using "keys %hash" in scalar context returns the number of keys in the hash <u>and</u> resets the iterator
       associated with the hash.  You may need to do this if you use "last" to exit a loop early so that
       when you re-enter it, the hash iterator has been reset.

       <b>How</b> <b>can</b> <b>I</b> <b>get</b> <b>the</b> <b>unique</b> <b>keys</b> <b>from</b> <b>two</b> <b>hashes?</b>

       First you extract the keys from the hashes into lists, then solve the "removing duplicates" problem
       described above.  For example:

           %seen = ();
           for $element (keys(%foo), keys(%bar)) {
               $seen{$element}++;
           }
           @uniq = keys %seen;

       Or more succinctly:

           @uniq = keys %{{%foo,%bar}};

       Or if you really want to save space:

           %seen = ();
           while (defined ($key = each %foo)) {
               $seen{$key}++;
           }
           while (defined ($key = each %bar)) {
               $seen{$key}++;
           }
           @uniq = keys %seen;

       <b>How</b> <b>can</b> <b>I</b> <b>store</b> <b>a</b> <b>multidimensional</b> <b>array</b> <b>in</b> <b>a</b> <b>DBM</b> <b>file?</b>

       Either stringify the structure yourself (no fun), or else get the MLDBM (which uses Data::Dumper)
       module from CPAN and layer it on top of either DB_File or GDBM_File.

       <b>How</b> <b>can</b> <b>I</b> <b>make</b> <b>my</b> <b>hash</b> <b>remember</b> <b>the</b> <b>order</b> <b>I</b> <b>put</b> <b>elements</b> <b>into</b> <b>it?</b>

       Use the Tie::IxHash from CPAN.

           use Tie::IxHash;
           tie my %myhash, 'Tie::IxHash';
           for (my $i=0; $i&lt;20; $i++) {
               $myhash{$i} = 2*$i;
           }
           my @keys = keys %myhash;
           # @keys = (0,1,2,3,...)

       <b>Why</b> <b>does</b> <b>passing</b> <b>a</b> <b>subroutine</b> <b>an</b> <b>undefined</b> <b>element</b> <b>in</b> <b>a</b> <b>hash</b> <b>create</b> <b>it?</b>

       If you say something like:

           somefunc($hash{"nonesuch key here"});

       Then that element "autovivifies"; that is, it springs into existence whether you store something
       there or not.  That's because functions get scalars passed in by reference.  If <u>somefunc()</u> modifies
       $_[0], it has to be ready to write it back into the caller's version.

       This has been fixed as of Perl5.004.

       Normally, merely accessing a key's value for a nonexistent key does <u>not</u> cause that key to be forever
       there.  This is different than awk's behavior.

       <b>How</b> <b>can</b> <b>I</b> <b>make</b> <b>the</b> <b>Perl</b> <b>equivalent</b> <b>of</b> <b>a</b> <b>C</b> <b>structure/C++</b> <b>class/hash</b> <b>or</b> <b>array</b> <b>of</b> <b>hashes</b> <b>or</b> <b>arrays?</b>

       Usually a hash ref, perhaps like this:

           $record = {
               NAME   =&gt; "Jason",
               EMPNO  =&gt; 132,
               TITLE  =&gt; "deputy peon",
               AGE    =&gt; 23,
               SALARY =&gt; 37_000,
               PALS   =&gt; [ "Norbert", "Rhys", "Phineas"],
           };

       References are documented in perlref and the upcoming perlreftut.  Examples of complex data struc-
       tures are given in perldsc and perllol.  Examples of structures and object-oriented classes are in
       perltoot.

       <b>How</b> <b>can</b> <b>I</b> <b>use</b> <b>a</b> <b>reference</b> <b>as</b> <b>a</b> <b>hash</b> <b>key?</b>

       (contributed by brian d foy)

       Hash keys are strings, so you can't really use a reference as the key.  When you try to do that, perl
       turns the reference into its stringified form (for instance, "HASH(0xDEADBEEF)"). From there you
       can't get back the reference from the stringified form, at least without doing some extra work on
       your own. Also remember that hash keys must be unique, but two different variables can store the same
       reference (and those variables can change later).

       The Tie::RefHash module, which is distributed with perl, might be what you want. It handles that
       extra work.

<b>Data:</b> <b>Misc</b>
       <b>How</b> <b>do</b> <b>I</b> <b>handle</b> <b>binary</b> <b>data</b> <b>correctly?</b>

       Perl is binary clean, so this shouldn't be a problem.  For example, this works fine (assuming the
       files are found):

           if (`cat /vmunix` =~ /gzip/) {
               print "Your kernel is GNU-zip enabled!\n";
           }

       On less elegant (read: Byzantine) systems, however, you have to play tedious games with "text" versus
       "binary" files.  See "binmode" in perlfunc or perlopentut.

       If you're concerned about 8-bit ASCII data, then see perllocale.

       If you want to deal with multibyte characters, however, there are some gotchas.  See the section on
       Regular Expressions.

       <b>How</b> <b>do</b> <b>I</b> <b>determine</b> <b>whether</b> <b>a</b> <b>scalar</b> <b>is</b> <b>a</b> <b>number/whole/integer/float?</b>

       Assuming that you don't care about IEEE notations like "NaN" or "Infinity", you probably just want to
       use a regular expression.

          if (/\D/)            { print "has nondigits\n" }
          if (/^\d+$/)         { print "is a whole number\n" }
          if (/^-?\d+$/)       { print "is an integer\n" }
          if (/^[+-]?\d+$/)    { print "is a +/- integer\n" }
          if (/^-?\d+\.?\d*$/) { print "is a real number\n" }
          if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number\n" }
          if (/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
                               { print "a C float\n" }

       There are also some commonly used modules for the task.  Scalar::Util (distributed with 5.8) provides
       access to perl's internal function "looks_like_number" for determining whether a variable looks like
       a number.  Data::Types exports functions that validate data types using both the above and other reg-
       ular expressions. Thirdly, there is "Regexp::Common" which has regular expressions to match various
       types of numbers. Those three modules are available from the CPAN.

       If you're on a POSIX system, Perl supports the "POSIX::strtod" function.  Its semantics are somewhat
       cumbersome, so here's a "getnum" wrapper function for more convenient access.  This function takes a
       string and returns the number it found, or "undef" for input that isn't a C float.  The "is_numeric"
       function is a front end to "getnum" if you just want to say, "Is this a float?"

           sub getnum {
               use POSIX qw(strtod);
               my $str = shift;
               $str =~ s/^\s+//;
               $str =~ s/\s+$//;
               $! = 0;
               my($num, $unparsed) = strtod($str);
               if (($str eq '') || ($unparsed != 0) || $!) {
                   return undef;
               } else {
                   return $num;
               }
           }

           sub is_numeric { defined getnum($_[0]) }

       Or you could check out the String::Scanf module on the CPAN instead. The POSIX module (part of the
       standard Perl distribution) provides the "strtod" and "strtol" for converting strings to double and
       longs, respectively.

       <b>How</b> <b>do</b> <b>I</b> <b>keep</b> <b>persistent</b> <b>data</b> <b>across</b> <b>program</b> <b>calls?</b>

       For some specific applications, you can use one of the DBM modules.  See AnyDBM_File.  More generi-
       cally, you should consult the FreezeThaw or Storable modules from CPAN.  Starting from Perl 5.8
       Storable is part of the standard distribution.  Here's one example using Storable's "store" and
       "retrieve" functions:

           use Storable;
           store(\%hash, "filename");

           # later on...
           $href = retrieve("filename");        # by ref
           %hash = %{ retrieve("filename") };   # direct to hash

       <b>How</b> <b>do</b> <b>I</b> <b>print</b> <b>out</b> <b>or</b> <b>copy</b> <b>a</b> <b>recursive</b> <b>data</b> <b>structure?</b>

       The Data::Dumper module on CPAN (or the 5.005 release of Perl) is great for printing out data struc-
       tures.  The Storable module on CPAN (or the 5.8 release of Perl), provides a function called "dclone"
       that recursively copies its argument.

           use Storable qw(dclone);
           $r2 = dclone($r1);

       Where $r1 can be a reference to any kind of data structure you'd like.  It will be deeply copied.
       Because "dclone" takes and returns references, you'd have to add extra punctuation if you had a hash
       of arrays that you wanted to copy.

           %newhash = %{ dclone(\%oldhash) };

       <b>How</b> <b>do</b> <b>I</b> <b>define</b> <b>methods</b> <b>for</b> <b>every</b> <b>class/object?</b>

       Use the UNIVERSAL class (see UNIVERSAL).

       <b>How</b> <b>do</b> <b>I</b> <b>verify</b> <b>a</b> <b>credit</b> <b>card</b> <b>checksum?</b>

       Get the Business::CreditCard module from CPAN.

       <b>How</b> <b>do</b> <b>I</b> <b>pack</b> <b>arrays</b> <b>of</b> <b>doubles</b> <b>or</b> <b>floats</b> <b>for</b> <b>XS</b> <b>code?</b>

       The kgbpack.c code in the PGPLOT module on CPAN does just this.  If you're doing a lot of float or
       double processing, consider using the PDL module from CPAN instead--it makes number-crunching easy.

<b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b>
       Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and other authors as noted. All rights
       reserved.

       This documentation is free; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       Irrespective of its distribution, all code examples in this file are hereby placed into the public
       domain.  You are permitted and encouraged to use this code in your own programs for fun or for profit
       as you see fit.  A simple comment in the code giving credit would be courteous but is not required.



perl v5.8.8                                      2006-01-07                                      PERLFAQ4(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq4.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq4.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq4.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
