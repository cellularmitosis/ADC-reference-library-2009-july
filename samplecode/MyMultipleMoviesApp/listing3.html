<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MyMultipleMoviesApp - /MyApplication Shell (2.0).c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">MyMultipleMoviesApp</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MyMultipleMoviesApp</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MyApplication Shell (2.0).c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BetterFlattenMovie.c</option>
<option value="listing2.html">/BetterFlattenMovie.h</option>
<option value="listing3.html">/MyApplication Shell (2.0).c</option>
<option value="listing4.html">/MyApplication Shell (2.0).h</option>
<option value="listing5.html">/MyApplication.c</option>
<option value="listing6.html">/MyApplication.h</option>
<option value="listing7.html">/MyMovieStuff.c</option>
<option value="listing8.html">/MyMovieStuff.h</option></select>
				</p>
				</form>
				<p><strong><a href="MyMultipleMoviesApp.zip">Download Sample</a></strong> (&#147;MyMultipleMoviesApp.zip&#148;, 20.5K)<BR>
<strong><a href="MyMultipleMoviesApp.dmg">Download Sample</a></strong> (&#147;MyMultipleMoviesApp.dmg&#148;, 76.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MyApplication Shell (2.0).c    Contains:  My Application Shell.  Written by:  John Wang  Copyright:  &copy; 1994 by Apple Computer, Inc., all rights reserved.  Change History (most recent first):    &lt;1&gt;    03/14/94  JW    Re-Created for Universal Headers.  To Do:  */#ifdef THINK_C#define    applec#endif#include  &lt;Types.h&gt;#include  &lt;Memory.h&gt;#include  &lt;QuickDraw.h&gt;#include  &lt;Palettes.h&gt;#include  &lt;QDOffscreen.h&gt;#include  &lt;Errors.h&gt;#include  &lt;Fonts.h&gt;#include  &lt;Dialogs.h&gt;#include  &lt;Windows.h&gt;#include  &lt;Menus.h&gt;#include  &lt;Events.h&gt;#include  &lt;Desk.h&gt;#include  &lt;DiskInit.h&gt;#include  &lt;OSUtils.h&gt;#include  &lt;Resources.h&gt;#include  &lt;ToolUtils.h&gt;#include  &lt;AppleEvents.h&gt;#include  &lt;EPPC.h&gt;#include  &lt;GestaltEqu.h&gt;#include  &lt;Processes.h&gt;#include  &lt;Balloons.h&gt;#include  &lt;Aliases.h&gt;#include  &lt;MixedMode.h&gt;#include  &lt;Scrap.h&gt;#include  &lt;LowMem.h&gt;#include  &quot;MyApplication Shell (2.0).h&quot;#include  &quot;MyApplication.h&quot;#ifdef powercQDGlobals    qd;#endifBoolean      gDoneFlag;      //  Set to true if you want to Application to kindly quit.Boolean      gHasAppleEvents;  //  true if Gestalt returns saying AppleEvents is available.short      gScrapCount;    //  Keep track of scrap count.OSType      gScrapType;      //  Needed to know what type scrap it is.Handle      gScrap;        //  Must keep a handle to the scrap for update events that                  //  happen in the background.  The reason is that when the app                  //  is in the background, it does not have access to GetScrap()./* ------------------------------------------------------------------------- */void main(){  EventRecord   myEvent;  long      yieldTime;  WindowPtr    foundWindow;  short      windowPart;  Boolean      isEvent;  GrafPtr      savePort;  GDHandle    saveGD;  PScrapStuff    myScrapStuff;  //  Initialize here.  Set the yield time too.  Initialize();  yieldTime = MyYieldTime(suspendResumeMessage);  //  Event loop.  for ( ; ; ) {    //  Get the event.    isEvent = WaitNextEvent(everyEvent, &amp;myEvent, yieldTime, nil);    //  Allow application specific event handling.  We have three cases:    //    MYEVENTDEF == 2: MyEvent gets called for each window.    //    MYEVENTDEF == 1: MyEvent gets once with window parameter = nil.    //    MYEVENTDEF == 0: MyEvent never gets called.    //  MyEvent returns true to indicate that the event is handled and can be ignored.    //  As the safe thing to do, we always set the port if we know what window is being used.    #if kMYEVENTDEF == 2      if ( isEvent ) {        foundWindow = (WindowPtr) LMGetWindowList();        while ( foundWindow != nil ) {          if ( IsMyWindow(foundWindow) ) {            GetPort(&amp;savePort);            saveGD = GetGDevice();            SetPort(foundWindow);            SetGDevice(GetMainDevice());            if ( MyEvent(foundWindow, &amp;myEvent) )              isEvent = false;            SetPort(savePort);            SetGDevice(saveGD);          }          foundWindow = (WindowPtr) ((CWindowPeek) foundWindow)-&gt;nextWindow;        }      }    #elif kMYEVENTDEF == 1      if ( isEvent ) {        if ( MyEvent(nil, &amp;myEvent) ) {          isEvent = false;        }      }    #elif kMYEVENTDEF == 0    #endif        //  If the event is unhandled by app specific event handling, then we proceed.    if ( isEvent ) {      switch ( myEvent.what ) {        case mouseDown:          //  Get current port and device.          GetPort(&amp;savePort);          saveGD = GetGDevice();                    //  Set the port and gdevice to the window if we own the window.          //  We can then assume anytime the event occured in one of our windows,          //     that the port and gdevice are set correctly.          windowPart = FindWindow(myEvent.where, &amp;foundWindow);          if ( IsMyWindow(foundWindow) || IsMyClipWindow(foundWindow) ) {            SetPort(foundWindow);            SetGDevice(GetMainDevice());          }                    //  Handle the different mouse down events.          switch ( windowPart ) {            case inSysWindow:              SystemClick(&amp;myEvent, foundWindow);              break;            case inMenuBar:              AdjustMenus();              DoCommand(MenuSelect(myEvent.where));              break;            case inContent:              //  If in the content area of application's window, then select              //  the window and call app specific routine.              if ( IsMyWindow(foundWindow) ) {                SelectWindow(foundWindow);                MyInContent(foundWindow, myEvent.where);              } else if ( IsMyClipWindow(foundWindow) ) {                SelectWindow(foundWindow);              }              break;            case inDrag:              //  If dragging one of the application's windows, then handle it.              //  However, if we are dragging a zoomed window, we              //  must remember to save the new window location into the              //  zoomed rect in the data handle.  Otherwise, the event              //  manager will think that we are no longer zoomed.              if ( IsMyWindow(foundWindow) || IsMyClipWindow(foundWindow) ) {                WStateData  *zoomData;                Rect    windowRect;                                //  Get window location before drag.                GetGlobalWindow(foundWindow, &amp;windowRect);                                //  Drag window.                DragWindow (foundWindow, myEvent.where, &amp;qd.screenBits.bounds);                //  If the windowRect in global coordinates matches the zoom rect,                //  then assume that we are dragging the zoomed window.  update                //  zoom rect.                zoomData = (WStateData *) *(((CWindowPeek) foundWindow)-&gt;dataHandle);                if ( EqualRect(&amp;(zoomData-&gt;stdState), &amp;windowRect) ) {                  GetGlobalWindow(foundWindow, &amp;windowRect);                  zoomData = (WStateData *) *(((CWindowPeek) foundWindow)-&gt;dataHandle);                  zoomData-&gt;stdState = windowRect;                }              }              break;            case inGrow:              //  If growing one of the application's windows, then handle it.              //  This also includes the clip window.              //  See inDrag for details.              if ( IsMyWindow(foundWindow) || IsMyClipWindow(foundWindow) ) {                WStateData  *zoomData;                Rect    windowRect;                Rect    tempRect;                long    tempLong;                Str255    tempStr;                                //  Get window location before drag.                GetGlobalWindow(foundWindow, &amp;windowRect);                                //  Grow the window.                tempRect = qd.screenBits.bounds;                tempRect.left = tempRect.top = 50;                GetWTitle(foundWindow, tempStr);                tempRect.left = StringWidth(tempStr) + 50;                tempLong = GrowWindow(foundWindow, myEvent.where, &amp;tempRect);                if ( tempLong ) {                  tempRect = foundWindow-&gt;portRect;                  InvalRect(&amp;tempRect);                  EraseRect(&amp;tempRect);                  InvalRect(&amp;tempRect);                  SizeWindow(foundWindow, tempLong, tempLong &gt;&gt; 16, true);                }                //  If the windowRect in global coordinates matches the zoom rect,                //  then assume that we are dragging the zoomed window.  update                //  zoom rect.                zoomData = (WStateData *) *(((CWindowPeek) foundWindow)-&gt;dataHandle);                if ( EqualRect(&amp;(zoomData-&gt;stdState), &amp;windowRect) ) {                  GetGlobalWindow(foundWindow, &amp;windowRect);                  zoomData = (WStateData *) *(((CWindowPeek) foundWindow)-&gt;dataHandle);                  zoomData-&gt;stdState = windowRect;                }              }              break;            case inGoAway:              //  Handle clicking on the go away.  If it is the clip window,              //  then hide it.              if ( TrackGoAway (foundWindow, myEvent.where) ) {                if ( IsMyWindow(foundWindow) ) {                  BringToFront(foundWindow);                  MyClose();                } else if ( IsMyClipWindow(foundWindow) ) {                  SetItem(GetMHandle(kMENU_EDITID), kMENU_EDITSHOWCLIP, &quot;\pShow Clipboard&quot;);                  HideClip(foundWindow);                }              }              break;            case inZoomIn:            case inZoomOut:              //  Zoom application window and the clip window.              if ( TrackBox(foundWindow, myEvent.where, windowPart) ) {                if ( IsMyWindow(foundWindow) )                  MyZoomWindow(foundWindow, windowPart);                else if ( IsMyClipWindow(foundWindow) )                  ZoomClip(foundWindow, windowPart);              }              break;              break;            default:              break;          }                    //  Restore port and device.          SetPort(savePort);          SetGDevice(saveGD);                    break;        case keyDown:        case autoKey:          if ( myEvent.modifiers &amp; cmdKey ) {            if ( myEvent.what == keyDown ) {              AdjustMenus();              DoCommand(MenuKey(myEvent.message &amp; charCodeMask));            }          } else            MyDoKeyDown(&amp;myEvent);          break;        case updateEvt:          //  Handle update events for window and clip window.          foundWindow = (WindowPtr) myEvent.message;          GetPort(&amp;savePort);          saveGD = GetGDevice();          SetPort(foundWindow);          SetGDevice(GetMainDevice());          BeginUpdate(foundWindow);          if ( IsMyWindow(foundWindow) )            MyDraw(foundWindow);          else if ( IsMyClipWindow(foundWindow) )            DrawClip(foundWindow);          EndUpdate(foundWindow);          SetPort(savePort);          SetGDevice(saveGD);          break;        case diskEvt:          //  This handles a bad disk.  Otherwise the disk will not eject.          if ( myEvent.message &gt;&gt; 16 ) {            Point  tempPoint;            tempPoint.v = 50; tempPoint.h = 50;            DIBadMount(tempPoint, myEvent.message);          }          break;        case activateEvt:          break;        case app4Evt:          switch ( myEvent.message &gt;&gt; 24 ) {            case suspendResumeMessage:              yieldTime = MyYieldTime(myEvent.message &amp; 0x01);              break;            default:              DebugStr(&quot;\pUnexpected suspend/resume message.&quot;);          }          break;        case kHighLevelEvent:          if ( gHasAppleEvents )            AEProcessAppleEvent(&amp;myEvent);        default:          break;      }    }      //  If DoneFlag set, then quit.    if ( gDoneFlag )      Finishup();    //  Do Idle routine.    //    MYIDLEDEF == 2: MyEvent gets called for each window.    //    MYIDLEDEF == 1: MyEvent gets once with window parameter = nil.    //    MYIDLEDEF == 0: MyEvent never gets called.    //  As the safe thing to do, we always set the port if we know what window is being used.    #if kMYIDLEDEF == 2      foundWindow = (WindowPtr) LMGetWindowList();      while ( foundWindow != nil ) {        if ( IsMyWindow(foundWindow) ) {          GetPort(&amp;savePort);          saveGD = GetGDevice();          SetPort(foundWindow);          SetGDevice(GetMainDevice());          MyIdle(foundWindow);          SetPort(savePort);          SetGDevice(saveGD);        }        foundWindow = (WindowPtr) ((CWindowPeek) foundWindow)-&gt;nextWindow;      }    #elif kMYIDLEDEF == 1      MyIdle(nil);    #elif kMYIDLEDEF == 0    #endif    //  See if scrap changed.  If so, redraw if the clip window is found.    myScrapStuff = InfoScrap();    if ( gScrapCount != myScrapStuff-&gt;scrapCount ) {      foundWindow = (WindowPtr) LMGetWindowList();      while ( foundWindow != nil ) {        if ( IsMyClipWindow(foundWindow) ) {          GetPort(&amp;savePort);          saveGD = GetGDevice();          SetPort(foundWindow);          SetGDevice(GetMainDevice());          DrawClip(foundWindow);          SetPort(savePort);          SetGDevice(saveGD);        }        foundWindow = (WindowPtr) ((CWindowPeek) foundWindow)-&gt;nextWindow;      }    }  }}/* ------------------------------------------------------------------------- *///  MyApplication Shell support routines (Initialize, DoCommand, and Finishup):void Initialize(){  OSErr        err;  long        vers;  Handle        myMenu;    //  Initialize Managaer.  MaxApplZone();  MoreMasters(); MoreMasters(); MoreMasters(); MoreMasters();  MoreMasters(); MoreMasters(); MoreMasters(); MoreMasters();  MoreMasters(); MoreMasters(); MoreMasters(); MoreMasters();  MoreMasters(); MoreMasters(); MoreMasters(); MoreMasters();  InitGraf(&amp;qd.thePort);  FlushEvents(everyEvent, 0);  InitWindows();  InitDialogs(nil);  InitCursor();  //  Set up menus.  myMenu = GetNewMBar(kMENUBAR);  SetMenuBar(myMenu);  DisposHandle(myMenu);  AddResMenu(GetMHandle(kMENU_APPLEID), 'DRVR');  DrawMenuBar();    //  Require at least System 7.0 and Color QuickDraw.  We don't really need to be strict  //  about this.  So, this can be removed if necessary.  But, test thoroughly with  //  System 6 and non-color if you do.  Gestalt(gestaltSystemVersion, &amp;vers);  vers = (vers &gt;&gt; 8) &amp; 0x0f;  if ( vers &lt; 7 ) {    ReportError(&quot;\pThis Application does not run under System 6!&quot;, -1);    ExitToShell();  }  Gestalt(gestaltQuickdrawVersion, &amp;vers);  if ( vers &lt; 0x100 ) {    ReportError(&quot;\pThis Application requires Color QuickDraw!&quot;, -1);    ExitToShell();  }    //  Initialize AppleEvents if available.  gHasAppleEvents = (Gestalt(gestaltAppleEventsAttr, &amp;vers) == noErr);  if ( gHasAppleEvents ) {    err = AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(AEOpenHandler), 0, false);    if ( err ) {      ReportError(&quot;\pError installing AppleEvent handlers.&quot;, err);      ExitToShell();    }    err = AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, NewAEEventHandlerProc(AEOpenDocHandler), 0, false);    if ( err ) {      ReportError(&quot;\pError installing AppleEvent handlers.&quot;, err);      ExitToShell();    }    err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(AEQuitHandler), 0, false);    if ( err ) {      ReportError(&quot;\pError installing AppleEvent handlers.&quot;, err);      ExitToShell();    }    err = AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, NewAEEventHandlerProc(AEPrintHandler), 0, false);    if ( err ) {      ReportError(&quot;\pError installing AppleEvent handlers.&quot;, err);      ExitToShell();    }  }    //  Setup other globals.  gDoneFlag = false;  //  Call app specific Intialization.  if ( ReportError(&quot;\pError returned from MyInitialize:&quot;, MyInitialize()) )    ExitToShell();}void DoCommand(long mResult){  short       theMenu, theItem;  Str255      myStr;  GrafPtr      savePort;  GDHandle    saveGD;  WindowPtr    foundWindow;    theItem = LoWord(mResult);  theMenu = HiWord(mResult);    if ( theItem != 0 || theMenu != 0 ) {    switch ( theMenu ) {      case kMENU_APPLEID:        if ( theItem == 1 ) {          ParamText(gMyAboutTitle, gMyAboutDesc, nil, nil);          Alert(kALERT_ABOUT, nil);        } else {          GetItem(GetMHandle(kMENU_APPLEID), theItem, myStr);          GetPort(&amp;savePort);          saveGD = GetGDevice();          (void) OpenDeskAcc(myStr);          SetPort(savePort);          SetGDevice(saveGD);        }        break;        case kMENU_FILEID:        switch ( theItem ) {          case kMENU_FILENEW:            MyNew();            break;          case kMENU_FILEOPEN:            MyOpen(nil);            break;          case kMENU_FILECLOSE:            if ( IsMyClipWindow(FrontWindow()) ) {              SetItem(GetMHandle(kMENU_EDITID), kMENU_EDITSHOWCLIP, &quot;\pShow Clipboard&quot;);              HideClip(FrontWindow());            } else if ( IsMyWindow(FrontWindow()) )              MyClose();            else              SysBeep(50);            break;          case kMENU_FILESAVE:            if ( IsMyWindow(FrontWindow()) )              MySave();            else              SysBeep(50);            break;          case kMENU_FILESAVEAS:            if ( IsMyWindow(FrontWindow()) )              MySaveAs();            else              SysBeep(50);            break;          case kMENU_FILEPAGESETUP:            if ( IsMyWindow(FrontWindow()) )              MyPageSetup();            else              SysBeep(50);            break;          case kMENU_FILEPRINT:            if ( IsMyWindow(FrontWindow()) )              MyPrint();            else              SysBeep(50);            break;          case kMENU_FILEQUIT:            gDoneFlag = true;            break;          default:            if ( ReportError(&quot;\pError in handling file menu:&quot;, theItem) )              ExitToShell();        }        break;        case kMENU_EDITID:        switch ( theItem ) {          case kMENU_EDITUNDO:            MyUndo();            break;          case kMENU_EDITCUT:            MyCut();            break;          case kMENU_EDITCOPY:            MyCopy();            break;          case kMENU_EDITPASTE:            MyPaste();            break;          case kMENU_EDITCLEAR:            MyClear();            break;          case kMENU_EDITSELECTALL:            MySelectAll();            break;          case kMENU_EDITSHOWCLIP:            GetItem(GetMHandle(kMENU_EDITID), kMENU_EDITSHOWCLIP, myStr);            if ( myStr[1] == 'S' ) {    //  Obviously not very internationalizeable.              ShowClip();              SetItem(GetMHandle(kMENU_EDITID), kMENU_EDITSHOWCLIP, &quot;\pHide Clipboard&quot;);            } else {              foundWindow = (WindowPtr) LMGetWindowList();              while ( foundWindow != nil ) {                if ( IsMyClipWindow(foundWindow) ) {                  SetItem(GetMHandle(kMENU_EDITID), kMENU_EDITSHOWCLIP, &quot;\pShow Clipboard&quot;);                  HideClip(foundWindow);                }                foundWindow = (WindowPtr) ((CWindowPeek) foundWindow)-&gt;nextWindow;              }            }            break;          default:            if ( ReportError(&quot;\pError in handling edit menu:&quot;, theItem) )              ExitToShell();        }        break;      default:        //  If not handled above, then allow app specific handling to occur.        if ( ReportError(&quot;\pError returned from MyDoCommand:&quot;, MyDoCommand(theMenu, theItem)) )          ExitToShell();    }  }  HiliteMenu(0);  return;}void AdjustMenus(){  MenuHandle    mHandle;    if ( IsMyClipWindow(FrontWindow()) ) {    mHandle = GetMHandle(kMENU_FILEID);    DisableItem(mHandle, kMENU_FILESAVE);    DisableItem(mHandle, kMENU_FILESAVEAS);    DisableItem(mHandle, kMENU_FILEPAGESETUP);    DisableItem(mHandle, kMENU_FILEPRINT);    mHandle = GetMHandle(kMENU_EDITID);    DisableItem(mHandle, kMENU_EDITUNDO);    DisableItem(mHandle, kMENU_EDITCUT);    DisableItem(mHandle, kMENU_EDITCOPY);    DisableItem(mHandle, kMENU_EDITPASTE);    DisableItem(mHandle, kMENU_EDITCLEAR);    DisableItem(mHandle, kMENU_EDITSELECTALL);  } else {    mHandle = GetMHandle(kMENU_FILEID);    if (IsMyWindow(FrontWindow())) {      EnableItem(mHandle, kMENU_FILESAVE);      EnableItem(mHandle, kMENU_FILESAVEAS);      EnableItem(mHandle, kMENU_FILEPAGESETUP);      EnableItem(mHandle, kMENU_FILEPRINT);    } else {      DisableItem(mHandle, kMENU_FILESAVE);      DisableItem(mHandle, kMENU_FILESAVEAS);      DisableItem(mHandle, kMENU_FILEPAGESETUP);      DisableItem(mHandle, kMENU_FILEPRINT);    }    mHandle = GetMHandle(kMENU_EDITID);    EnableItem(mHandle, kMENU_EDITUNDO);    EnableItem(mHandle, kMENU_EDITCUT);    EnableItem(mHandle, kMENU_EDITCOPY);    EnableItem(mHandle, kMENU_EDITPASTE);    EnableItem(mHandle, kMENU_EDITCLEAR);    EnableItem(mHandle, kMENU_EDITSELECTALL);  }    MyAdjustMenus();}void Finishup(){  WindowPtr    frontWindow, nxtWindow;    frontWindow = FrontWindow();  while ( frontWindow != nil ) {    nxtWindow = (WindowPtr) ((WindowPeek)frontWindow)-&gt;nextWindow;    if ( IsMyClipWindow(frontWindow) ) {      HideClip(frontWindow);    }    frontWindow = nxtWindow;  }    //  Cleanup app specific stuff since all of the shell handles will be disposed of  //  when the heap disappears...  MyFinishup();  //  Finally, quit app.  ExitToShell();}/* ------------------------------------------------------------------------- *///  Clip Window support (ShowClip, DrawClip, HideClip, and ZoomClip):void ShowClip(){  WindowPtr  myWindow;  Rect    clipBounds;    myWindow = (WindowPtr) LMGetWindowList();  while ( myWindow != nil ) {    if ( IsMyClipWindow(myWindow) ) {      return;    }    myWindow = (WindowPtr) ((CWindowPeek) myWindow)-&gt;nextWindow;  }    SetRect(&amp;clipBounds, 10, 400, 510, 480);    myWindow = NewCWindow(0L, &amp;clipBounds, &quot;\pClipboard&quot;, true, zoomDocProc, (WindowPtr) -1, true, 0L);  SetMyClipWindow(myWindow);  SetPort(myWindow);  gScrapCount = 0;  gScrapType = 'NONE';    if ( (gScrap = NewHandle(0)) == nil ) {    ReportError(&quot;\pCould not create handle for scrap storage:&quot;, -1);    ExitToShell();  }}void DrawClip(WindowPtr clipWindow){  PScrapStuff  myScrapStuff;  long    scrapOffset, scrapLength;  Rect    myFrame;  Str255    myStr;  short    moveSize;    //  See if scrap changed.  myScrapStuff = InfoScrap();  if ( gScrapCount != myScrapStuff-&gt;scrapCount ) {    gScrapCount = myScrapStuff-&gt;scrapCount;    if ( (scrapLength = GetScrap(gScrap, 'PICT', &amp;scrapOffset)) &gt; 0 ) {      gScrapType = 'PICT';      } else if ( (scrapLength = GetScrap(gScrap, 'TEXT', &amp;scrapOffset)) &gt; 0 ) {      gScrapType = 'TEXT';      } else      gScrapType = 'NONE';    }  //  Erase the window.  EraseRect(&amp;(clipWindow-&gt;portRect));  //  Draw something  if ( gScrapType == 'PICT' ) {    myFrame = (**(PicHandle) gScrap).picFrame;    SetWTitle(clipWindow, &quot;\pClipboard contents: picture&quot;);    DrawPicture((PicHandle) gScrap, &amp;myFrame);  } else if ( gScrapType == 'TEXT' ) {    SetWTitle(clipWindow, &quot;\pClipboard contents: text&quot;);    moveSize = GetHandleSize(gScrap);    if ( moveSize &gt; 255 )      moveSize = 255;    BlockMove(*gScrap, myStr+1, moveSize);    myStr[0] = moveSize;    MoveTo(10, 40);    DrawString(myStr);  } else    SetWTitle(clipWindow, &quot;\pNo PICT or TEXT to display.&quot;);}void HideClip(WindowPtr clipWindow){  DisposeWindow(clipWindow);  gScrapCount = 0;  gScrapType = 'NONE';  DisposeHandle(gScrap);}void ZoomClip(WindowPtr clipWindow, short windowPart){  WStateData  *zoomData;    //  IMPORTANT: Must not change stdState if not zooming out.  Otherwise, it will fool  //  the WDEF into thinking that it is not zoomed out when it really is.    //  Don't call anything else since zoomData handle is not locked.  zoomData = (WStateData *) *(((CWindowPeek) clipWindow)-&gt;dataHandle);    if ( gScrapType == 'PICT' ) {    if ( windowPart == 8 ) {      (zoomData-&gt;stdState).right = (zoomData-&gt;stdState).left +                      ((**(PicHandle) gScrap).picFrame).right;      (zoomData-&gt;stdState).bottom = (zoomData-&gt;stdState).top +                      ((**(PicHandle) gScrap).picFrame).bottom;    }  } else if ( gScrapType == 'TEXT' ) {    if ( windowPart == 8 ) {      (zoomData-&gt;stdState).right = (zoomData-&gt;stdState).left + 620;    }    }  ZoomWindow(clipWindow, windowPart, true);}/* ------------------------------------------------------------------------- *///  Shell utilities (ReportError, and GetGlobalWindow)://  Show Alert.  Then, return true is err != noErr.Boolean ReportError(Str255 procStr, OSErr err){  long  longerr = err;  Str255  myStr;    if ( longerr ) {    NumToString(longerr, myStr);    ParamText(&quot;\pFATAL ERROR&quot;, procStr, myStr, nil);    Alert(kALERT_ERROR, nil);    return ( true );  } else    return ( false );}void GetGlobalWindow(WindowPtr theWindow, Rect *windowRect){  //  Get the windowRect in global coordinates.  *windowRect = theWindow-&gt;portRect;  LocalToGlobal(&amp;topLeft(*windowRect));  LocalToGlobal(&amp;botRight(*windowRect));}/* ------------------------------------------------------------------------- *///  AppleEvents handling (AEOpenHandler, AEOpenDocHandler, AEPrintHandler,//     and AECloseHandler) :pascal OSErr AEOpenHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){  //  We don't do anything more than simply call MyNew().  //  Thus, when app is opened from finder, MyNew will be called because the Finder  //  will send an open app AppleEvent message.  if ( kNEWDOCATSTARTUP )    MyNew();    return ( noErr );}pascal OSErr AEOpenDocHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){  OSErr      err;  AEDescList    docList;  long      numItems;  FSSpec      myFSS;  Size      actualSize;  long      i;  DescType    typeCode;  AEKeyword    theKeyword;    err = AEGetParamDesc(messagein, keyDirectObject, typeAEList, &amp;docList);  if ( err )    return ( err );    err = AECountItems(&amp;docList, &amp;numItems);  if ( err )    return ( err );      for ( i=1; i&lt;=numItems; i++ ) {    err = AEGetNthPtr(&amp;docList, i, typeFSS, &amp;theKeyword, &amp;typeCode, (Ptr) &amp;myFSS,              sizeof(FSSpec), &amp;actualSize);    if ( err )      return ( err );        MyOpen(&amp;myFSS);  }    return ( noErr );}pascal OSErr AEPrintHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){  OSErr      err;  AEDescList    docList;  long      numItems;  FSSpec      myFSS;  Size      actualSize;  long      i;  DescType    typeCode;  AEKeyword    theKeyword;    err = AEGetParamDesc(messagein, keyDirectObject, typeAEList, &amp;docList);  if ( err )    return ( err );    err = AECountItems(&amp;docList, &amp;numItems);  if ( err )    return ( err );    for ( i=1; i&lt;=numItems; i++ ) {    err = AEGetNthPtr(&amp;docList, i, typeFSS, &amp;theKeyword, &amp;typeCode, (Ptr) &amp;myFSS,              sizeof(FSSpec), &amp;actualSize);    if ( err )      return ( err );        //  Open each file.  Print it.  Then close it.  MyOpen must make window frontmost.    MyOpen(&amp;myFSS);    MyPrint();    MyClose();  }    return ( noErr );}pascal OSErr AEQuitHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){  gDoneFlag = true;    return ( noErr );}/* ------------------------------------------------------------------------- *///  Called to determine if the window is owned by app.Boolean IsMyWindow(WindowPtr theWindow){  if ( theWindow )    return ( ((CWindowPeek) theWindow)-&gt;windowKind == kWINDOWDOC );  else    return ( false );}//  Called to set the window's creator.void SetMyWindow(WindowPtr theWindow){  if ( theWindow )    ((CWindowPeek) theWindow)-&gt;windowKind = kWINDOWDOC;}//  Called to determine if window is a show clipboard window.Boolean IsMyClipWindow(WindowPtr theWindow){  if ( theWindow )    return ( ((CWindowPeek) theWindow)-&gt;windowKind == kWINDOWCLIP );  else    return ( false );}//  Called to set the creator as the window clip.void SetMyClipWindow(WindowPtr theWindow){  if ( theWindow )    ((CWindowPeek) theWindow)-&gt;windowKind = kWINDOWCLIP;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MyMultipleMoviesApp/listing3.html%3Fid%3DDTS10000329-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MyMultipleMoviesApp/listing3.html%3Fid%3DDTS10000329-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MyMultipleMoviesApp/listing3.html%3Fid%3DDTS10000329-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>