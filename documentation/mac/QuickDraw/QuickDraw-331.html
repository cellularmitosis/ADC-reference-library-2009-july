<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of Offscreen Graphics Worlds (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING331></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-330.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-332.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-302.html"><B>Chapter 6 - Offscreen Graphics Worlds</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING331-0></A>
<H1>Summary of Offscreen Graphics Worlds</H1>
<A NAME=HEADING331-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING331-2></A>
<H3>Constants</H3>
<PRE>
CONST
   cDepthErr            = -157;  {invalid pixel depth}
   pixPurgeBit          = 0;     {set to to make base address for  }
                                 { offscreen pixel image purgeable}
   noNewDeviceBit       = 1;     {set to not create a new GDevice }
                                 { record for offscreen world} 
   useTempMemBit        = 2;     {set to create base address for offscreen }
                                 { pixel image in temporary memory} 
   keepLocalBit         = 3;     {set to keep offscreen pixel image in }
                                 { main memory}
   pixelsPurgeableBit   = 6;     {set to make base address for pixel image }
                                 { purgeable}
   pixelsLockedBit      = 7;     {set to lock base address for offscreen }
                                 { pixel image}
   mapPixBit            = 16;    {set by UpdateGWorld if it remapped }
                                 { colors to a new color table}
   newDepthBit          = 17;    {set by UpdateGWorld if it translated }
                                 { pixel map to a different pixel depth}
   alignPixBit          = 18;    {set by UpdateGWorld if it realigned }
                                 { pixel image to onscreen window} 
   newRowBytesBit       = 19;    {set by UpdateGWorld if it changed }
                                 { rowBytes field of PixMap record}
   reallocPixBit        = 20;    {set by UpdateGWorld if it reallocated }
                                 { base address for offscreen pixel image}
   clipPixBit           = 28;    {set to clip pixel image} 
   stretchPixBit        = 29;    {set to stretch or shrink pixel image} 
   ditherPixBit         = 30;    {set to dither pixel image} 
   gwFlagErrBit         = 31;    {set by UpdateGWorld if it failed} 
</PRE>
<A NAME=HEADING331-4></A>
<H3>Data Types</H3>
<PRE>
TYPE GWorldPtr = CGrafPtr;
TYPE GWorldFlags = 
   SET OF (
      pixPurge,         {specify to NewGWorld to make base address for }
                        { offscreen pixel image purgeable}
      noNewDevice,      {specify to NewGWorld to not create a new GDevice }
                        { record for offscreen world}
      useTempMem,       {specify to NewGWorld to create base address for }
                        { offscreen pixel image in temporary memory}
      keepLocal,        {specify to NewGWorld to keep offscreen pixel image }
                        { in main memory}
      gWorldFlag4,      {reserved}
      gWorldFlag5,      {reserved}
      pixelsPurgeable,  {returned by GetPixelsState to indicate that base }
                        { address for offscreen pixel image is purgeable; }
                        { specify to SetPixelsState to make base address }
                        { for pixel image purgeable}
      pixelsLocked,     {returned by GetPixelsState to indicate that base }
                        { address for offscreen pixel image is locked; }
                        { specify to SetPixelsState to lock base address }
                        { for offscreen pixel image}
      gWorldFlag8,      {reserved}
      gWorldFlag9,      {reserved}
      gWorldFlag10,     {reserved}
      gWorldFlag11,     {reserved}
      gWorldFlag12,     {reserved}
      gWorldFlag13,     {reserved}
      gWorldFlag14,     {reserved}
      gWorldFlag15,     {reserved}
      mapPix,           {returned by UpdateGWorld if it remapped colors to }
                        { a new color table}
      newDepth,         {returned by UpdateGWorld if it translated pixel } 
                        { map to a different pixel depth}
      alignPix,         {returned by UpdateGWorld if it realigned pixel }
                        { image to onscreen window} 
      newRowBytes,      {returned by UpdateGWorld if it changed rowBytes } 
                        { field of PixMap record}
      reallocPix,       {returned by UpdateGWorld if it reallocated }
                        { base address for offscreen pixel image}
      gWorldFlag21,     {reserved}
      gWorldFlag22,     {reserved}
      gWorldFlag23,     {reserved}
      gWorldFlag24,     {reserved}
      gWorldFlag25,     {reserved}
      gWorldFlag26,     {reserved}
      gWorldFlag27,     {reserved}
      clipPix,          {specify to UpdateGWorld to update and clip pixel }
                        { image}
      stretchPix,       {specify to UpdateGWorld to update and stretch or }
                        { shrink pixel image}
      ditherPix,        {specify to UpdateGWorld to dither pixel image}
      gwFlagErr,        {returned by UpdateGWorld if it failed}
   );
</PRE>
<A NAME=HEADING331-7></A>
<H3>Routines</H3>
<A NAME=HEADING331-8></A>
<H4>Creating, Altering, and Disposing of Offscreen Graphics Worlds</H4>
<PRE>
FUNCTION NewGWorld       (VAR offscreenGWorld: GWorldPtr; 
                          pixelDepth: Integer; boundsRect: Rect; 
                          cTable: CTabHandle; aGDevice: GDHandle; 
                          flags: GWorldFlags): QDErr;
FUNCTION NewScreenBuffer (globalRect: Rect; 
                          purgeable: Boolean; VAR gdh: GDHandle; 
                          VAR offscreenPixMap: PixMapHandle): QDErr;
FUNCTION NewTempScreenBuffer 
                         (globalRect: Rect; 
                          purgeable: Boolean; 
                          VAR gdh: GDHandle; 
                          VAR offscreenPixMap: PixMapHandle): QDErr;
FUNCTION UpdateGWorld    (VAR offscreenGWorld: GWorldPtr; 
                          pixelDepth: Integer; boundsRect: Rect; 
                          cTable: CTabHandle; aGDevice: GDHandle; 
                          flags: GWorldFlags): GWorldFlags;
PROCEDURE DisposeGWorld  (offscreenGWorld: GWorldPtr);
PROCEDURE DisposeScreenBuffer 
                         (offscreenPixMap: PixMapHandle);
</PRE>
<A NAME=HEADING331-17></A>
<H4>Saving and Restoring Graphics Ports and Offscreen Graphics Worlds</H4>
<PRE>
PROCEDURE GetGWorld      (VAR port: CGrafPtr; VAR gdh: GDHandle);
PROCEDURE SetGWorld      (port: CGrafPtr; gdh: GDHandle);
FUNCTION GetGWorldDevice (offscreenGWorld: GWorldPtr): GDHandle;
</PRE>
<A NAME=HEADING331-21></A>
<H4>Managing an Offscreen Graphics World's Pixel Image</H4>
<PRE>
FUNCTION GetGWorldPixMap     (offscreenGWorld: GWorldPtr): PixMapHandle;
FUNCTION LockPixels          (pm: PixMapHandle): Boolean;
PROCEDURE UnlockPixels       (pm: PixMapHandle);
PROCEDURE AllowPurgePixels   (pm: PixMapHandle);
PROCEDURE NoPurgePixels      (pm: PixMapHandle);
FUNCTION GetPixelsState      (pm: PixMapHandle): GWorldFlags;
PROCEDURE SetPixelsState     (pm: PixMapHandle; state: GWorldFlags);
FUNCTION GetPixBaseAddr      (pm: PixMapHandle): Ptr;
FUNCTION PixMap32Bit         (pmHandle: PixMapHandle): Boolean;
</PRE>
<A NAME=HEADING331-31></A>
<H2>C Summary</H2>
<A NAME=HEADING331-32></A>
<H3>Constants</H3>
<PRE>
enum {                        /* bit assignments for GWorldFlags data type */
   pixPurgeBit          = 0,  /* set to to make base address for   
                                 offscreen pixel image purgeable */
   noNewDeviceBit       = 1,  /* set to not create a new GDevice 
                                 record for offscreen world */
   useTempMemBit        = 2,  /* set to create base address for offscreen
                                 pixel image in temporary memory */
   keepLocalBit         = 3,  /* set to keep offscreen pixel image in 
                                 main memory */
   pixelsPurgeableBit   = 6,  /* set to make base address for pixel image
                                 purgeable */
   pixelsLockedBit      = 7,  /* set to lock base address for offscreen
                                 pixel image */
   mapPixBit            = 16, /* set by UpdateGWorld if it remapped 
                                 colors to a new color table */
   newDepthBit          = 17, /* set by UpdateGWorld if it translated 
                                 pixel map to a different pixel depth */
   alignPixBit          = 18, /* set by UpdateGWorld if it realigned 
                                 pixel image to onscreen window */
   newRowBytesBit       = 19, /* set by UpdateGWorld if it changed 
                                 rowBytes field of PixMap record */
   reallocPixBit        = 20, /* set by UpdateGWorld if it reallocated 
                                 base address for offscreen pixel image */
   clipPixBit           = 28, /* set to update and clip pixel image */
   stretchPixBit        = 29, /* set to update and stretch or shrink pixel 
                                 image */
   ditherPixBit         = 30, /* set to dither pixel image */
   gwFlagErrBit         = 31  /* set by UpdateGWorld if it failed */
};
enum {                  /* constants for GWorldFlags data type */
   pixPurge          = 1 &lt;&lt; pixPurgeBit,
   noNewDevice       = 1 &lt;&lt; noNewDeviceBit,
   useTempMem        = 1 &lt;&lt; useTempMemBit,
   keepLocal         = 1 &lt;&lt; keepLocalBit,
   pixelsPurgeable   = 1 &lt;&lt; pixelsPurgeableBit,
   pixelsLocked      = 1 &lt;&lt; pixelsLockedBit,
   mapPix            = 1 &lt;&lt; mapPixBit,
   newDepth          = 1 &lt;&lt; newDepthBit,
   alignPix          = 1 &lt;&lt; alignPixBit,
   newRowBytes       = 1 &lt;&lt; newRowBytesBit,
   reallocPix        = 1 &lt;&lt; reallocPixBit,
   clipPix           = 1 &lt;&lt; clipPixBit,
   stretchPix        = 1 &lt;&lt; stretchPixBit,
   ditherPix         = 1 &lt;&lt; ditherPixBit,
   gwFlagErr         = 1 &lt;&lt; gwFlagErrBit
};
enum {
   cDepthErr         = -157   /* invalid pixel depth */
};
</PRE>
<A NAME=HEADING331-36></A>
<H3>Data Types</H3>
<PRE>
typedef CGrafPtr GWorldPtr;
typedef unsigned long GWorldFlags;
</PRE>
<A NAME=HEADING331-39></A>
<H3>Functions</H3>
<A NAME=HEADING331-40></A>
<H4>Creating, Altering, and Disposing of Offscreen Graphics Worlds</H4>
<PRE>
pascal QDErr NewGWorld        (GWorldPtr *offscreenGWorld, short PixelDepth, 
                               const Rect *boundsRect, CTabHandle cTable, 
                               GDHandle aGDevice, GWorldFlags flags); 
pascal QDErr NewScreenBuffer
                              (const Rect *globalRect, Boolean purgeable, GDHandle *gdh, PixMapHandle *offscreenPixMap); 
pascal QDErr NewTempScreenBuffer
                              (const Rect *globalRect, Boolean purgeable, GDHandle *gdh, PixMapHandle *offscreenPixMap); 
pascal GWorldFlags UpdateGWorld
                              (GWorldPtr *offscreenGWorld, short pixelDepth,  const Rect *boundsRect, CTabHandle cTable, GDHandle aGDevice, GWorldFlags flags); 
pascal void DisposeGWorld     (GWorldPtr offscreenGWorld); 
pascal void DisposeScreenBuffer
                              (PixMapHandle offscreenPixMap); 
</PRE>
<A NAME=HEADING331-51></A>
<H4>Saving and Restoring Graphics Ports and Offscreen Graphics Worlds</H4>
<PRE>
pascal void GetGWorld         (CGrafPtr *port, GDHandle *gdh); 
pascal void SetGWorld         (CGrafPtr port, GDHandle gdh); 
pascal GDHandle GetGWorldDevice
                              (GWorldPtr offscreenGWorld);
</PRE>
<A NAME=HEADING331-56></A>
<H4>Managing an Offscreen Graphics World's Pixel Image</H4>
<PRE>
pascal PixMapHandle GetGWorldPixMap
                              (GWorldPtr offscreenGWorld); 
pascal Boolean LockPixels     (PixMapHandle pm); 
pascal void UnlockPixels      (PixMapHandle pm); 
pascal void AllowPurgePixels
                              (PixMapHandle pm); 
pascal void NoPurgePixels     (PixMapHandle pm); 
pascal GWorldFlags GetPixelsState
                              (PixMapHandle pm); 
pascal void SetPixelsState    (PixMapHandle pm, GWorldFlags state); 
pascal Ptr GetPixBaseAddr     (PixMapHandle pm); 
pascal Boolean PixMap32Bit    (PixMapHandle pmHandle); 
</PRE>
<A NAME=HEADING331-69></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING331-70></A>
<H4>Trap Macros Requiring Routine Selectors</H4>
<PRE>
_QDExtensions
</PRE>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$00160000<TD>NewGWorld<TR>
<TD>$00040001<TD>LockPixels<TR>
<TD>$00040002<TD>UnlockPixels<TR>
<TD>$00160003<TD>UpdateGWorld<TR>
<TD>$00040004<TD>DisposeGWorld<TR>
<TD>$00080005<TD>GetGWorld<TR>
<TD>$00080006<TD>SetGWorld<TR>
<TD>$0004000B<TD>AllowPurgePixels<TR>
<TD>$0004000C<TD>NoPurgePixels<TR>
<TD>$0004000D<TD>GetPixelsState<TR>
<TD>$0008000E<TD>SetPixelsState<TR>
<TD>$0004000F<TD>GetPixBaseAddr<TR>
<TD>$000E0010<TD>NewScreenBuffer<TR>
<TD>$00040011<TD>DisposeScreenBuffer<TR>
<TD>$00040012<TD>GetGWorldDevice<TR>
<TD>$000E0015<TD>NewTempScreenBuffer<TR>
<TD>$00040016<TD>PixMap32Bit<TR>
<TD>$00040017<TD>GetGWorldPixMap</TABLE>


<A NAME=HEADING331-72></A>
<H2>Result Codes</H2>
<TABLE BORDER="0" CELLPADDING=3><TD>noErr<TD>0<TD>No error<TR>
<TD>paramErr<TD>-50<TD>Illegal parameter<TR>
<TD>cNoMemErr<TD>-152<TD>Failed to allocate memory for structures<TR>
<TD>cDepthErr<TD>-157<TD>Invalid pixel depth</TABLE>
<A NAME=MARKER-9-76></A>


</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-330.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-332.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
