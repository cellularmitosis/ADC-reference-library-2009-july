<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Text Input(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING33></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-32.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-34.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-13.html"><B>Chapter 1 - Introduction to Text on the Macintosh</B></A> / <A HREF="Text-29.html"><B>How Script Systems Work</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING33-0></A>
<H2>Text Input</H2>
 <A NAME=MARKER-2-322></A>Typically, your application accepts text input from the user through the keyboard. The Macintosh script management system allows you to accept text input in any script system, and to switch easily among input script systems.<P>
 Keyboard input is a complex process that involves conversion of hardware <A NAME=MARKER-2-324></A>keypresses to software <B>raw key codes,</B> then to <B>virtual key codes,</B> and finally to character codes. Subsequent display of those input characters on the screen involves conversion of character codes to the glyphs of a font, and the drawing of those glyphs on the screen. As noted under <A HREF=Text-15.html#MARKER-9-15>"Separation of Tasks" beginning on page 1-4</A>, text input and text display are completely independent of each other.<P>
 The conversion of keypresses to character codes is complex because the Macintosh computer has to support many different physical keyboards and many script systems. The conversion of raw key codes to virtual key codes accommodates the spectrum of keyboards; the conversion of virtual key codes to character codes accommodates the spectrum of script systems.<P>
 For 1-byte script systems, characters are generated directly from keypresses. For 2-byte script systems, the large number of characters makes direct keyboard input impractical; those systems provide input methods to make text input more convenient.<P>
<A NAME=HEADING33-5></A>
<H3><A NAME=MARKER-9-399></A>Keyboards and Key Translation</H3>
 <A NAME=MARKER-2-327></A>Every Macintosh keyboard has a specific physical arrangement of keys. An example is shown in <A HREF=#MARKER-9-401>Figure 1-52</A>. The figure shows the physical arrangement of keys on the domestic (U.S.) layout of the Apple Keyboard II. It also shows the virtual key codes produced when each key is pressed, as well as the character generated (for U.S. system software) by each key.<P>
<A NAME=MARKER-9-401></A><B>Figure 1-52  Apple Keyboard II (domestic layout)</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IS_L-32.jpg">
 Other keyboards produce a similar set of virtual key codes, although the keys and their codes may be arranged differently. Apple supports at least 13 separate physical keyboards, listed in the appendix "Keyboard Resources" in this book. All can produce a set of hardware-independent virtual key codes, which translate directly into the characters of any script system. That process is called <A NAME=MARKER-2-95></A><B>key translation.</B><A NAME=MARKER-2-361></A><P>
 As far as the application is concerned, text input for all keyboards and for all script systems is hardware-independent. Except for a few minor hardware-specific characteristics, the function of the keyboard is completely determined by a script system's keyboard-layout (<CODE>'KCHR'</CODE>) resources. Tables within the keyboard-layout resource specify the characters produced by each key in combination with each modifier key (Command, Shift, Caps Lock, Control, and Option).<P>
 <A NAME=MARKER-9-296></A><A HREF=#MARKER-9-406>Figure 1-53</A> illustrates the process of key translation. A keypress initially produces a raw key code. The keyboard driver uses the hardware-dependent key-map (<CODE>'KMAP'</CODE>) resource to map the raw key code into a hardware-independent virtual key code and to set bits indicating the state (up or down) of the modifier keys. It then calls the Event Manager <CODE><A NAME=MARKER-2-333></A>KeyTranslate</CODE> function.<P>
 If the optional key-remap (<CODE>'itlk'</CODE>) resource is present, <CODE>KeyTranslate</CODE> uses it to remap certain key combinations on certain keyboards before performing additional processing. The key-remap resource transforms this information based on which keyboard is in use. It reintroduces hardware dependence because certain writing systems, languages, and regions need subtle differences in layout for specific keyboards. Generally, the key-remap resource affects only a few keys.<P>
 The <CODE>KeyTranslate</CODE> function then uses the current script's keyboard-layout resource to map the virtual key code and modifier state into a character code. <CODE>KeyTranslate</CODE> returns the character code, and the keyboard driver posts the key-down event into the event queue. The application receives the original virtual key code and a character code in the <CODE>message</CODE> field of the event record, and modifier-key information in the <CODE>modifiers</CODE> field of the event record.<P>
<B>Figure 1-53  <A NAME=MARKER-9-406></A>Key translation</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IS_L-34.jpg">
 The <CODE>KeyTranslate</CODE> function is described in the chapter "Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>. For additional information on the <CODE>KeyTranslate</CODE> function and the keyboard-layout resource, see the appendix "Keyboard Resources" in this book.<P>
<DL>
<DT><B>Dead keys</B>
<DD><A NAME=MARKER-2-359></A>The keyboard-layout resource also handles dead keys, by means of additional subtables. A <B>dead key</B> is a key combination that has no immediate effect, but sets a state that affects the results of the next keypress (typically, the generation of one or two characters). Dead keys are commonly used to generate accents and accented characters. Dead-key processing is discussed in more detail in the appendix "Keyboard Resources" in this book.<EM></EM><A NAME=MARKER-2-362></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING33-19></A>
<H4><A NAME=MARKER-9-409></A>Font and Keyboard Synchronization</H4>
 <A NAME=MARKER-2-900></A>Whenever your application displays text as it is being entered at the keyboard, it needs to keep the font script coordinated with the keyboard script (see <A HREF=Text-28.html#MARKER-9-245>"Font Script and Keyboard Script" beginning on page 1-51</A>). The upper half of <A HREF=#MARKER-9-411>Figure 1-54</A> shows an example of font and keyboard synchronization with the user entering the characters for <I>Nihongo</I> when the font script corresponds to the keyboard script, which is Japanese. The lower half of <A HREF=#MARKER-9-411>Figure 1-54</A> provides an example of the characters that are displayed when the user enters the same characters when the font script does not match the keyboard script. If the two scripts don't match, the results are meaningless to the user.<P>
<B>Figure 1-54  <A NAME=MARKER-9-411></A>Font script and keyboard script synchronization</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IS_L-38.jpg">
 You use the Script Manager <CODE>KeyScript</CODE> procedure to set the keyboard script when, for example, the user chooses a new font from your Fonts menu or when the user clicks in an area of text that has a font different from the current one. The Operating System automatically changes the keyboard script (or keyboard layout or input method) when the user chooses a new one from the Keyboard menu (see <A HREF=Text-38.html#MARKER-9-485>Figure 1-62 on page 1-106</A>). When that happens you need to set the font script to equal the keyboard script.<P>
 The Operating System also automatically changes the keyboard script (or keyboard layout or input method) when the user presses certain key combinations, as specified by the keyboard-swap (<CODE>'KSWP'</CODE>) resource. When that happens you should set the font script to equal the keyboard script.<P>
 You can force a particular keyboard layout to be used with your application by using the Script Manager to define the default keyboard layout for a script system and then calling <CODE>KeyScript</CODE>.<P>
 For more information on setting the font script and keyboard script, see the discussion on making keyboard settings and the description of the <CODE>KeyScript</CODE> procedure in the chapter "Script Manager" in this book. For more information on the keyboard-swap resource, see the appendix "Keyboard Resources" in this book.<A NAME=MARKER-9-46></A><P>
<A NAME=HEADING33-27></A>
<H4>Handling Keyboard Equivalents</H4>
 <A NAME=MARKER-2-134></A>Many applications support keyboard commands or keyboard equivalents to menu commands. This can be a problem in a multiscript environment. Be careful of these issues in the keyboard equivalents that you allow:<P>
<UL>
<LI>Avoid keyboard equivalents that use the Space bar in combination with the Command key and other modifier keys. Command-Space bar and Command-Option-Space bar are already commonly used for switching among script systems and keyboard layouts. See the discussion of the <CODE>KeyScript</CODE> procedure in the chapter "Script Manager" and the description of the keyboard-swap resource in the appendix "Keyboard Resources" in this book.
<LI>When the Command key is pressed, some characters--such as the period or question mark--cannot be produced on certain keyboard layouts. To make Command-key handling work in these cases, it may be necessary to use the virtual key code to determine which character code <I>would have been produced</I> if the Command key had not been pressed. For more information, see the discussion of special uses for the <CODE>KeyTranslate</CODE> function in the appendix "Keyboard Resources" in this book.
<LI>If your application extends the set of standard Macintosh modifier-plus-key combinations for specific purposes, your keyboard equivalents might not function properly in all script systems. Be sure to supply alternative methods--such as menu or dialog-box items--for gaining access to such features.<A NAME=MARKER-2-336></A><P>
</UL>
<A NAME=HEADING33-32></A>
<H3><A NAME=MARKER-9-415></A>Input Methods</H3>
 <A NAME=MARKER-2-542></A>Script systems for ideographic writing systems such as Japanese cannot simply use a larger keyboard or multiple dead keys for effective text input. The sheer numbers of their characters demand a more complex solution, such as providing ways to convert phonetic text into ideographic text and vice versa. Most script systems with large character sets provide for the complex parsing of phonetic sequences to produce ideograms and character clusters.<P>
 Automatic conversion of phonetic glyphs into final representations is performed by an input method. For example, the Japanese script system supplements the keyboard by providing software for transcribing Kana (phonetic Japanese) into ideographic Kanji. Each Kanji character can correspond to more than one possible Kana sequence, and vice versa. The input method must grammatically parse sentences or phrases of Kana text (which has no word separations), and select the best combination of Kanji and Kana characters to represent that text.<P>
<A NAME=HEADING33-35></A>
<H4>Entry and Conversion</H4>
 <A NAME=MARKER-2-417></A>When a user types a character, one kind of input method opens a window (called a <A NAME=MARKER-2-158></A><B>floating input window</B> or <A NAME=MARKER-2-833></A><B>bottomline input window</B>) at the bottom of the screen for text entry; see <A HREF=#MARKER-9-420>Figure 1-55</A>. In Japanese, the user can type using either Roman or Kana characters. When the converted glyphs are in the window, the user can freely cut and paste or convert them to any of the other subscripts.<P>
<B>Figure 1-55  <A NAME=MARKER-9-420></A>Bottomline input window for Japanese input method</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IS_S-16.jpg">
 <A NAME=MARKER-2-39></A>The Text Services Manager supplies an interface for input methods that use <B>inline input.</B> In inline input, the user types directly into an <B>active input area</B> within a document, as shown in <A HREF=#MARKER-9-422>Figure 1-56</A>. Conversion then occurs within the active input area.<P>
<B>Figure 1-56  <A NAME=MARKER-9-422></A>Active input area (underlined) for inline input</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IS_S-14.jpg">
 Input methods are often extended so that glyphs may be converted in extremely precise ways. For example, in the Japanese script system, when the text is converted to Kanji, the user has the option of changing any individual phrase: lengthening it, shortening it, or selecting different possible interpretations. All of the commands that perform these changes have both mouse and keyboard equivalents. Once the user presses the Return key, the text is entered as if it had been typed directly from the keyboard.<P>
<A NAME=HEADING33-43></A>
<H4>Differences Among Script Systems</H4>
 <A NAME=MARKER-2-423></A>In Japanese and Chinese input methods, the principal conversion is from Roman or other phonetic input to <A NAME=MARKER-2-136></A><B>Han</B> (Chinese) characters. In Japanese the input can be Romaji (Roman), Hiragana (phonetic), or Katakana (phonetic); the output is Kanji (Chinese characters). In Chinese the input can be <A NAME=MARKER-2-425></A><B>Pinyin</B> (Roman) or<B> <A NAME=MARKER-9-733></A>Zhuyinfuhao</B> (phonetic; also called<B> <A NAME=MARKER-2-353></A>Bopomofo</B>), and the output is Hanzi (Chinese characters). Chinese and Japanese use a semi-automatic conversion to Han characters that requires user confirmation.<P>
 The Korean script system's input method converts from Jamo (phonetic) to Hangul (clusters of Jamo). Transcription to Hanja (Chinese characters) is optional. Furthermore, the Korean input method uses a completely automatic conversion from Jamo to Hangul; user confirmation is not required.<P>
 <A NAME=MARKER-2-892></A><A HREF=#MARKER-9-429>Figure 1-57</A> illustrates the process of constructing Hangul from Jamo during bottomline input. Note that an added Jamo can appear in various positions (beside, beneath, and so on) relative to the Jamo or Hangul that it is added to.<P>
<B>Figure 1-57  <A NAME=MARKER-9-429></A>Bottomline input in Korean</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IS_S-15.jpg">
 To gain the greatest acceptance worldwide, your application should support text input, and preferably inline input, in 2-byte script systems. For additional information on input methods, inline input, and input-method dictionaries, see the chapters "Text Services Manager" and "Dictionary Manager" in this book. <A NAME=MARKER-2-586></A>  <A NAME=MARKER-2-456></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-32.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-34.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
