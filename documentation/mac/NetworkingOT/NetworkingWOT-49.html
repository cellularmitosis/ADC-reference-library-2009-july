<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>No-Copy Receiving</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING49></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-48.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-50.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-46.html"><B>Chapter 10 - Advanced Topics</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING49-0></A>
<H1><A NAME=MARKER-9-29></A>No-Copy Receiving</H1>
 Open Transport allows you to receive data without doing the extra copying that is normally involved in receiving data, which can save time and resources.<P>
 Normally, when you call one of the receive functions to get data, you pass the address of a buffer you have allocated, and Open Transport copies data from its own internal buffers to the buffer you specify. Doing a no-copy receive means that Open Transport does not copy data from its buffers into yours, but instead allows you to access its internal buffers directly. For example, you might have received some data that needs to be written to disk and you have four files, each with a different buffer, that are expecting data. Normally what you would do is store the data in a temporary buffer while you determined which of the four files was the right destination. When you identified the target, you'd then copy the data from the temporary buffer into that file's buffer. <P>
 A no-copy receive allows you to peek at the data when you receive it and write it out immediately. Open Transport does this by giving you access to a special <A NAME=MARKER-13-29></A>no-copy receive buffer, <A NAME=MARKER-13-32></A><CODE>OTBuffer</CODE>. To use this buffer correctly, you must<P>
<UL>
<P><LI>not write to it; if you do, you can crash the system
<P><LI>release it quickly
<P><LI>only release it once; don't release it multiple times<P>
</UL>
 You need to release the no-copy receive buffer (with the <A NAME=MARKER-13-40></A><CODE>OTReleaseBuffer</CODE> function) as soon as you are finished using it so that you are not tying up system resources required elsewhere. One consequence of holding on to a buffer too long is that your link layer driver starts allocating more buffers as it receives more data and, if it isn't well designed, it may run out of space and lose packets.<P>
 In many cases, for performance reasons, drivers pass their actual DMA buffers when they return data. If this is the case, when you do a no-copy receive, you are getting the actual DMA buffers from the driver. If you hold on to the buffer for too long, you may begin to starve the driver for DMA buffers, which adversely affects the performance of the system. It is very important that if you are doing a no-copy receive, you hold onto the buffer for as short a time as possible. If it seems necessary to hold on to the buffer for any length of time, overall performance is better if you instead make a copy of the data and return the buffer to the system. <P>
<DL>
<DT><B>WARNING</B>
<DD>On PPC systems no-copy receives are only supported for PPC Open Transport clients. Emulated 68000 clients may not use no-copy receives on PPC systems.   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-33>Figure 10-2</A> shows the structure of Open Transport's internal receive buffers. You will be accessing data referenced in these buffers when you do a no-copy receive. To do this, you allocate a variable that holds the address of the first <CODE>OTBuffer</CODE> structure and then access additional buffers using the <CODE>fNext</CODE> field of each buffer.<P>
<B>Figure 10-2  <A NAME=MARKER-9-33></A>OTBuffer structures</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-13.gif"><P>
 In <A HREF=#MARKER-9-33>Figure 10-2</A> the variable <CODE>MyOTB</CODE> holds the address of the first <CODE>OTBuffer</CODE> structure. The unused fields of the structure are shaded. The <CODE>fData</CODE> field of the structure points to the first data packet; the <CODE>fLen</CODE> field specifies the length of the data packet, and the <CODE>fNext</CODE> field holds the address of the second <CODE>OTBuffer</CODE> structure, which provides the location and size of the second data packet. <P>
 The no-copy receive buffer is actually a linked chain of buffers, with the next buffer pointed to by the <CODE>fNext</CODE> field in each buffer. You can access all of the received data by tracing the chain of <CODE>fNext</CODE> pointers. For your convenience, Open Transport provides the <A NAME=MARKER-13-34></A><CODE>OTBufferInfo</CODE> structure and the utility functions, <A NAME=MARKER-13-45></A><CODE>OTReadBuffer</CODE> and <A NAME=MARKER-13-36></A><CODE>OTBufferDataSize</CODE>, to read through the <CODE>OTBuffer</CODE> structure. <A NAME=MARKER-13-37></A><P>
 In order to do a no-copy receive, you must <P>
<OL>
<P><LI>Allocate a local variable into which Open Transport will store the address of the first <CODE>OTBuffer</CODE> structure. The <CODE>OTBufferInfo</CODE> type is especially useful for this local variable.
<P><LI>Pass the constant <CODE>kOTNetbufDataIsOTBufferStar</CODE> for the <CODE>nbytes</CODE> parameter of the <CODE>OTRcv</CODE> function or the <CODE>udata.maxlen</CODE> field used with other receive functions to indicate that you are doing a no-copy receive.
<P><LI>Use the utility function <CODE>OTBufferDataSize</CODE> to determine the size of the no-copy receive buffer.
<P><LI>Use the utility function <CODE>OTReadBuffer</CODE> to read bytes from the data buffers. The <CODE>fOffset</CODE> field of the <CODE>OTBufferInfo</CODE> structure specifies how much of the buffer has been read.
<P><LI>Use the <CODE>OTReleaseBuffer</CODE> function to return the no-copy receive buffer to the system when you are finished copying data from the buffer. <P>
</OL>
 The following two listings show two different methods of doing nocopy receives. <A HREF=#MARKER-9-40>Listing 10-1</A> shows the <CODE>NoCopyReceiveUsingOTReadBuffer </CODE>user-defined function<CODE>.</CODE> This function reads data from the endpoint (<CODE>ep</CODE>) using a no-copy receive. The data is then copied out of the <CODE>OTBuffer</CODE> chain using the <CODE>OTReadBuffer</CODE> utility function. This method is useful if you need to look at a small chunk of data, which you can copy using <CODE>OTReadBUffer</CODE>, to decide what to do with the rest. <A NAME=MARKER-0-95></A><A NAME=MARKER-0-95></A><P>
<B>Listing 10-1  <A NAME=MARKER-9-40></A>Doing a no-copy receive: method 1</B><P>
<PRE>
<A NAME=MARKER-0-95></A>enum {
   kTransferBufferSize = 1024
};

static char gTransferBuffer[kTransferBufferSize];

static OSStatus NoCopyReceiveUsingOTReadBuffer(EndpointRef ep, SInt16 
destFileRefNum)
{
   OSStatus err;
   OTResult result;
   OTBufferInfo bufferInfo;
   OTFlags junkFlags;
   UInt32 bytesRemaining;
   UInt32 bytesThisTime;
   SInt32 count;
   
   err = noErr;
   
   /* Initialise the bufferInfo data structure. */
   
   bufferInfo.fOffset = 0;
   bufferInfo.fBuffer = nil;
      
   /* Read the data.  Use the constant kOTNetbufDataIsOTBufferStar */ 
   /* to indicate that you want to do a no-copy receive. */
   
   result = OTRcv(ep, &amp;bufferInfo.fBuffer, kOTNetbufDataIsOTBufferStar,
                                    &amp;junkFlags);
   if (result &gt;= 0) {

      /* Use OTBufferDataSize to calculate how much data is returned */
      bytesRemaining = OTBufferDataSize(bufferInfo.fBuffer);

      /* Write that data to the file.  We do this in chunks, */
      /* copying each chunk of data out of the OTBuffer chain */
      /* and into our transfer buffer using OTReadBuffer, then */
      /* writing each chunk of data, until there is no 
      /* more data left in the buffer chain. */
      while (err == noErr &amp;&amp; bytesRemaining &gt; 0) {
         if (bytesRemaining &gt; kTransferBufferSize) {
            bytesThisTime = kTransferBufferSize;
         } else {
            bytesThisTime = bytesRemaining;
         }
         (void) OTReadBuffer(&amp;bufferInfo, gTransferBuffer,
                                    &amp;bytesThisTime);
         count = bytesThisTime;
         err = FSWrite(destFileRefNum, &amp;count, gTransferBuffer);
         bytesRemaining -= bytesThisTime;
      }
      
      err = noErr;
   } else {
      err = result;
   }
   
   /* Clean up.  We MUST release the OTBuffer chain back to OT */
   /* so that it can reuse it. OTReleaseBuffer does not tolerate */
   /* the parameter being nil, so we check for that case first. */
   
   if (bufferInfo.fBuffer != nil) {
      OTReleaseBuffer(bufferInfo.fBuffer);
   }
   
   return err;
}
</PRE>
 The method shown in the previous listing is not particularly efficient, but it does demonstrate the use of the <CODE>OTReadBuffer</CODE> function. The second method, shown in <A HREF=#MARKER-9-42>Listing 10-2</A>, uses the <CODE>NoCopyReceiveWalkingBufferChain</CODE> user-defined function to read data from the endpoint (<CODE>ep</CODE>) using a no-copy receive. The code walks through the resulting buffer chain, writing out chunks of data directly to the file from the buffers returned to us by Open Transport.<P>
<B>Listing 10-2  <A NAME=MARKER-9-42></A>Doing a no-copy receive: method 2</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OSStatus NoCopyReceiveWalkingBufferChain(EndpointRef ep, 
                                 SInt16 destFileRefNum)
{
   OSStatus err;
   OTResult result;
   OTBufferInfo bufferInfo;
   OTBuffer *thisBuffer;
   OTFlags junkFlags;
   SInt32 count;
   
   err = noErr;

   /* Initialise the bufferInfo data structure. */

   bufferInfo.fOffset = 0;
   bufferInfo.fBuffer = nil;
   
   /* Read the data.  Use the constant kOTNetbufDataIsOTBufferStar */
   /* to indicate that you want to do a no-copy receive. */

   result = OTRcv(ep, &amp;bufferInfo.fBuffer, kOTNetbufDataIsOTBufferStar,
                                       &amp;junkFlags);
   if (result &gt;= 0) {
   
   /* Walk the returned buffer chain, writing out each chunk to file */
      
      thisBuffer = bufferInfo.fBuffer;
      while (err == noErr &amp;&amp; thisBuffer != nil) {
         
         count = thisBuffer-&gt;fLen;
         err = FSWrite(destFileRefNum, &amp;count, thisBuffer-&gt;fData);
         
         thisBuffer = thisBuffer-&gt;fNext;
      }
   } else {
      err = result;
   }

   /* Clean up.  We MUST release the OTBuffer chain to Open Transport */
   /* so that it can reuse it., OTReleaseBuffer does not tolerate */
   /* the parameter being nil, so we check for that case first. */

   if (bufferInfo.fBuffer != nil) {
      OTReleaseBuffer(bufferInfo.fBuffer);
   }

   return err;
}
</PRE>
</BLOCKQUOTE><HR>
<center>
<A HREF="NetworkingWOT-48.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-50.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
