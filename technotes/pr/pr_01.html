<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../style.css" TYPE="text/css"><title>Technical Note PR01: Color Printing</title><meta name="categories" content="Printing"><meta name="week-posted" content="Jan 27, 1986 - Feb 7, 1986"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002622" title="Color Printing"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PR01</div>
<div id="pageheadsub">Color Printing</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">Part 1, ImageWriters</A><BR><BR><A HREF="#Section3">Part 2, Laserwriters</A><BR><BR><A HREF="#References">References</A><BR><BR> <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext"> This discusses color printing in a Macintosh application.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Feb 01 1986]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Introduction</h2><p>Whereas the original eight-color model of QuickDraw was sufficient for printingin color on the ImageWriter II, the introduction of Color QuickDraw has createdthe need for more sophisticated printing methods.</p><p>The first section describes using the eight-color QuickDraw model with theImageWriter II and ImageWriter LQ drivers. Since the current Print Manager doesnot support Color GrafPorts, the eight-color model is the only method availablefor the ImageWriters.</p><p>The next section describes a technique that can be used for printing halftoneimages using PostScript (when it is available). It also describes a device-independent technique for sending the PostScript data. This technique can beused on any LaserWriter driver 3.0 or later. It will work with all LaserWritersexcept the the LaserWriter IISC.</p><p>It is very likely that better color support will be added to the Print Managerin the future. Until then, these are the best methods available.</p><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><H2>Part 1, ImageWriters</h2><p>The ImageWriter drivers are capable of generating each of the eight standardcolors defined in QuickDraw by the following constants:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    whiteColor    blackColor    redColor    greenColor    blueColor    cyanColor    magentaColor</pre>	</TD></TR></TABLE></CENTER><p>To generate color all you need to do is set the foreground and backgroundcolors before you begin drawing (initially they are set to <code>blackColor</code>foreground and <code>whiteColor</code> background). To do this you call the QuickDrawroutines <code>ForeColor</code> and <code>BackColor</code> as described in <i>InsideMacintosh</i>. If you are using QuickDraw pictures, make sure you set theforeground and background colors before you call <code>ClosePicture</code> so thatthey are recorded in the picture. Setting the colors before calling<code>DrawPicture</code> doesn't work.</p><p>The drivers also recognize two of the transfer modes: <code>srcCopy</code> and<code>srcOr</code>. The effect of the other transfer modes is not well defined andhas not been tested. It may be best to stay away from them.</p><h3>Caveats</h3><p>When printing a large area of more than one color you will encounter a problemwith the ribbon. When you print a large area of one color, the printer's pinspick up the color from the back of the ribbon. When another large area of coloris printed, the pins deposit the previous color onto the back of the ribbon.Eventually the first color will come through to the front of the ribbon,contaminating the second color. You can get the same kind of effect if you set,for example, a foreground color of yellow and a background color of blue. Theribbon will pick up the blue as it tries to print yellow on top of it. Thisproblem is partially alleviated in the 2.3 version of the ImageWriter driver byusing a different printing technique.</p><p>The ribbon goes through the printer rather quickly when printing large areas.When the ribbon comes through the second time the colors don't look toogreat.</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><H2>Part 2, LaserWriters</h2><H2>Using the PostScript 'image' Operator to Print Halftones</h2><h3>About 'image'</h3><p>The PostScript image operator is used to send Bitmaps or Pixmaps to theLaserWriter. The image operator can handle depths from 1 to 8 bits per pixel.Our current LaserWriters can only image about twenty shades of gray, but theprinted page will look like there's more. Being that the image operator isstill a PostScript operator, it expects its data in the form of hexidecimalbytes. The bytes are represented by two ASCII characters(0-9,A-F). The imageoperator takes these parameters:</p><p>The first three are the width, height, and depth of the image, and the matrixis the transformation matrix to be applied to the current matrix. See the<i>PostScript Language Reference Manual</i> for more information. The imagedata is where the actual hex data should go. Instead of inserting the databetween the first parameters and the image operator itself, it is better to usea small, PostScript procedure to read the data starting from right after theimage operator. For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    640 480 8 [640 0 0 480 0 0]    {currentfile picstr readhexstring pop}    image</pre>	</TD></TR></TABLE></CENTER><p>In the above example, the width of the image is 640, the height is 480, and thedepth is 8. The matrix (enclosed in brackets) is setup to draw the imagestarting at QuickDraw's 0,0 (top left of page), and with no scaling. ThePostScript code (enclosed in braces) is not executed. Instead, it is passed tothe image operator, and the image operator will call it repeatedly until it hasenough data to draw the image. In this case, it will be expecting 640*480bytes. When the image operator calls the procedure, it does the following:</p><ol type="1" start="1">	<li>Pushes the current file which in this case is the stream of data coming to the LaserWriter over AppleTalk. This is the first parameter to <code>readhexstring</code>.</li>	<li>Next <code>picstr</code> is pushed. <code>picstr</code> is a string variable defined to hold one row of hex data. The PostScript to create the picstr is:</li></ol><ol type="1" start="3">	<li>Now <code>readhexstring</code> is called to fill <code>picstr</code> with data from the current file. It begins reading bytes which are the characters following the image operator.</li>	<li>Since <code>readhexstring</code> leaves both the string we want, and a boolean that we don't want on the stack, we do one pop to kill of the boolean. Now the string is left behind for the image operator to use.</li></ol><p>So using the above PostScript code you can easily print an image. Just fill inthe width height and depth, and send the hex data immediately following thePostScript code.</p><h3>Setting Up for 'image'</h3><p>Most of the users of this technique are going to want to print a ColorQuickDraw <code>PixMap</code>. Although the image command does a lot of the work for you,there are still a couple of tricks that are recommended for performance.</p><h3>Assume the Maximum Depth</h3><p>Since the current version of the image operator has a maximum depth of 8bits/pixel, it is wise to convert the source image to the same depth beforeimaging. This can be done very simply by using an offscreen <code>GrafPort</code> that isset to 8 bits/pixel, and then using <code>CopyBits</code> to do the depth conversion foryou. This will do a nice job of converting lower resolution images to 8bits/pixel.</p><h3>Build a Color Table</h3><p>An 8-bit deep image can only use 256 colors. Since the image that you arestarting with is probably color, and the image you get will be grayscale, youneed to convert the colors in the source color table into PostScript grayscalevalues. This is actually easy to do using the Color Manager. First create atable that can hold 512 bytes. This is 2 bytes for each color value from 0 to255. Since PostScript wants the values in ASCII, you need two characters foreach pixel. Now loop through the colors in the color table. Call <code>Index2Color</code> toget the real RGB color for that index, and then call <code>RGB2HSL</code> to convert the RGBcolor into a luminance value. This value will be expressed as a <code>SmallFract</code>which can then be scaled into a value from 0 to 255. This value should then beconverted to ASCII, and stored at the appropriate location in the table. Whenyou are done, you should be able to use a pixel value as an index into yourtable of PostScript color values. For each pixel in the image, send twocharacters to the LaserWriter.</p><h3>Sending the Data</h3><p>Once you have set up the color table, all that left to do is to loop throughall of the pixels, and send their PostScript representation to the LaserWriter.There are a couple of ways to do this. First is to use the low-level PrintManager interface and stream the PostScript using the <code>stdBuf PrCtlCall</code>.Although this seems like it would be the fastest way, the latest version of theLaserWriter driver (5.0) converts all low-level calls to their high levelequivalent before executing them. Because of this, the low-level interface isno longer faster than the high level. In an FKEY I have written, I use thehigh-level Print Manager interface, and send the data via the <code>PostScriptHandle</code>PicComment. This way, I can buffer a large amount of data, before actuallysending it. Using this technique, I have been able to image a Mac II screen inabout 5 minutes on a LaserWriter Plus, and about 1.5 minutes on a LaserWriterII NTX.</p><P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><P>QuickDraw</p><P>The Printing Manager</p><P>PostScript Language Reference Manual, Adobe Systems</p>         <P><A HREF="#top">Back to top</A></P><a name=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (44K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pr_01.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pr/pr_01.html%3Fid%3DDTS10002622-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pr/pr_01.html%3Fid%3DDTS10002622-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pr/pr_01.html%3Fid%3DDTS10002622-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>