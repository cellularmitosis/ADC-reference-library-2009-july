/*	File:		GDevice.cp	Contains:	TGDevice is a GDevice utility class, finding out GDevice information.  				GDevice.cp contains the class body information for the TGDevice class.	Written by: Kent Sandvik		Copyright:	Copyright © 1991-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				8/18/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/// Include files#ifndef _GDEVICE_#include "GDevice.h"#endif// _________________________________________________________________________________________________________ //// TGDevice class member function implementations//	CONSTRUCTORS & DESTRUCTORS#pragma segment GDevice  				 TGDevice::TGDevice()// The default constructor will just call the IGDevice method which will search// and hopefully find the GDList (if not the fStatus is false in the class).{	fFirstTime = true;							// indicate we are inside the constructor	fLast = false;								// no wrap yet (constructor time)	Boolean fState = this->IGDevice();			// initialize the object	fFirstTime = false;							// out, we are no longer in a cvt	fFirstGDList = fGDList;						// record the first in the list}#pragma segment GDeviceTGDevice::~TGDevice()// Destructor, we are not doing anything inside this one just now.{}//	INITIATION ROUTINES#pragma segment GDeviceBoolean TGDevice::IGDevice()// Look for the GDList, return true if found, false if not.{	if (fFirstTime)								// first time we are critical about NULL!	{		fGDList = ::GetDeviceList();			// get the device list		ASSERT(fGDList != NULL, "\pGetDeviceList returned NULL");		this->GetGDeviceValues();				// fill in the proper values ASAP		if (fGDList == NULL)					// we had a problem			goto IGDeviceFalse;		else			goto IGDeviceOK;					// OK	}	else										// we are now called from Next, OK with NULL		{			fGDList = ::GetNextDevice(fGDList);	// continue the iteration			if (fGDList == NULL)				// beyond the last one?			{				fGDList = fFirstGDList;			// back to the first one				fLast = true;					// signal this was the last one				goto IGDeviceOK;			}			goto IGDeviceOK;					// OK anyway!		}IGDeviceFalse:return false;IGDeviceOK:return true;}#pragma segment GDevice  				 void TGDevice::Next()// Gets the information from the following devices.{	this->IGDevice();	this->GetGDeviceValues();}#pragma segment GDevice  				 void TGDevice::First()// Reset to the first GDevice we found.{	fGDList = fFirstGDList;}#pragma segment GDevice  				 Ptr TGDevice::GetBase() const// Return the pointer of the GDevice base, not the address (more flexible that way){	return fBase;}#pragma segment GDevice  				 long TGDevice::GetRow() const// Return row value.{	return fRow;}#pragma segment GDevice  				 short TGDevice::GetDepth() const// Return the depth level of the GDevice.{	return fDepth;}#pragma segment GDevice  				 Boolean TGDevice::Last() const// Just return the Boolean value if this was the last GDevice or not.{	return fLast;}//	PRIVATE MEMBER FUNCTIONS#pragma segment GDevicevoid TGDevice::GetGDeviceValues()// Get the GDevice information from the GDList device{	fBase = (*(*fGDList)->gdPMap)->baseAddr;	fRow = (*(*fGDList)->gdPMap)->rowBytes;	fRow = fRow & 0x0000FFFF;	fDepth = (*(*fGDList)->gdPMap)->pixelSize;	fDepth = fDepth & 0x0000FFFF;}// _________________________________________________________________________________________________________ ///*	Change History (most recent last):  No		Init.	Date		Comment  1			khs		6/2/92		New file  2			khs		7/5/92		First decent release  3			khs		9/7/92		More hacking for multi-dev platform use*/