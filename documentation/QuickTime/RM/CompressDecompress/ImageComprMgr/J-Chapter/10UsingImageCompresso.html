<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>QuickTime Compression and Decompression Guide: Using Image Compressor Components</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using Image Compressor Components"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents" title="Using Image Compressor Components"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000433" target="_top">QuickTime</a> &gt; <a href="../../../../CompressionDecompression-date.html#//apple_ref/doc/uid/TP30000440-TP30000433-TP30000498" target="_top">Compression &amp; Decompression</a> &gt; <a href="../A-Intro/1Introduction.html#//apple_ref/doc/uid/TP40000878-IntroductiontoQuickTimeCompressionandDecompressionGuide-DontLinkElementID_145">QuickTime Compression and Decompression Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../I-Chapter/9AboutImageCompresso.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../K-Chapter/11CodecComponentsAPI.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-SW1" title="Using Image Compressor Components"></a>
<h1>Using Image Compressor Components</h1>

<p>This chapter shows you how to use compressors and decompressors in conjunction with the Image Compression Manager.</p>



<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_77">Performing Image Compression</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_80">Decompressing an Image</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_84">Asynchronous Decompression</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_85">Hardware Cursors</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_86">Timecode Support</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_87">Working With Video Fields</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_88">Accelerated Video Support</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_89">Packetization Information</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_90">DV Image Compressor Component</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_91">DV Image Decompressor Component</a>
				
			<br/>
			
        
			
			
				<a href="10UsingImageCompresso.html#//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_92">Specifying the Size of an Image Buffer</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_77" title="Performing Image Compression"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-PerformingImageCompression" title="Performing Image Compression"></a>Performing Image Compression</h2>
<p>This section describes what the Image Compression Manager does that affects compressors. It then provides sample code that shows how the compressor components prepare for image compression and how to compress an entire image or a horizontal band of an image.</p>
<p>When compressing an image, the Image Compression Manager performs three major tasks:</p>
<ul class="ul">
<li class="li"><p>The Image Compression Manager first determines which compressor is best able to compress the image. To do so, the Image Compression Manager examines the source image as well as the parameters specified by the application. If the application requested a specific compressor, the Image Compression Manager uses that compressor (unless it is not installed, in which case the Image Compression Manager returns an error to the application). If the application did not request a compressor, the Image Compression Manager chooses the compressor that will do the best job. The Image Compression Manager collects the information it needs to choose a compressor by issuing the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreCompress" target="_top">ImageCodecPreCompress</a></code> request to each qualifying compressor.</p></li>
<li class="li"><p>If the chosen compressor can handle the image directly, the Image Compression Manager passes the request through to the compressor. The compressor then processes the image and returns the compressed data to the specified location.</p></li>
<li class="li"><p>If none of the compressors can handle it directly, the Image Compression Manager allocates an offscreen buffer and passes image bands to the compressor by issuing a <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecBandCompress" target="_top">ImageCodecBandCompress</a></code> request. The compressor processes each band, accumulating the compressed data as it goes. When the image has been completely compressed, the Image Compression Manager returns control to the application.</p></li>
</ul>
<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_78" title="Choosing a Compressor"></a>
<h3><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-ChoosingaCompressor" title="Choosing a Compressor"></a>Choosing a Compressor</h3>
<p>Listing&#160;9-1 shows how the Image Compression Manager calls the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreCompress" target="_top">ImageCodecPreCompress</a></code> function before an image is compressed. The compressor component returns information about how it is able to compress the image to the Image Compression Manager, so that it can fit the destination data to the requirements of the compressor component. This information includes compressor capabilities for</p>
<ul class="spaceabove">
<li class="li"><p>depth of input pixels</p></li>
<li class="li"><p>minimum buffer band size</p></li>
<li class="li"><p>band increment size</p></li>
<li class="li"><p>extension width and height</p></li>
</ul>
<p>When your compressor component is called with the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreCompress" target="_top">ImageCodecPreCompress</a></code> function, it can handle all aspects of the function itself, or only the most common ones. All image compressor components must handle at least one case.</p>
<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_172" title="Listing 9-1Preparing for simple compression operations"></a>
<p class="codesample"><strong>Listing 9-1&nbsp;&nbsp;</strong>Preparing for simple compression operations</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal long ImageCodecPreCompress (Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;register CodecCompressParams *p) <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;CodecCapabilities *capabilities = p-&#62;capabilities;<span></span></pre></td></tr><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;First the compressor returns which depth input pixels it<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;supports based on what the application has available. This<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;compressor can only work with 32-bit input pixels.<span></span></pre></td></tr><tr><td scope="row"><pre>*/&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;switch ( (*p-&#62;imageDescription)-&#62;depth ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 16:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;capabilities-&#62;wantedPixelSize = 32;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return(codecConditionErr);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;If the buffer gets banded, return the smallest one the<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;compressor can handle.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;bandMin = 2;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;If the buffer gets banded, return the increment<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;by which it should increase.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;bandInc = 2;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;extendWidth = (*p-&#62;imageDescription)-&#62;width &#38; 1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;extendHeight = (*p-&#62;imageDescription)-&#62;height &#38; 1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;    &#160;For efficiency, if the compressor could perform extension,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;    these flags would be set to 0.<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return(noErr);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

<p>Here is a list of some of the operations your compressor component can perform during compression. It describes parameters in the compression parameters structure and indicates the operations that are required and which flags in the compressor capabilities flags field of the compressor capabilities structure must be set to allow your compressor to handle them (see <span class="content_text"><a href="../K-Chapter/11CodecComponentsAPI.html#//apple_ref/doc/uid/TP40000878-CodecComponentsAPI-DataStructures">Data Structures</a></span> and <span class="content_text"><a href="../K-Chapter/11CodecComponentsAPI.html#//apple_ref/doc/uid/TP40000878-CodecComponentsAPI-DataStructures">Data Structures</a></span>).</p>
<ul class="spaceabove">
<li class="li"><p><strong>Depth</strong> <strong>conversion.</strong>  If your compressor component can compress from the pixel depth indicated by the <code>pixelSize</code> field (in the pixel map structure pointed to by the <code>srcPixmap</code> field of the compression parameters structure), it should set the <code>wantedPixelSize</code> field of the compressor capability structure to the same value. If it cannot handle that depth, it should specify the closest depth it can support in the <code>wantedPixelSize</code> field. The Image Compression Manager will convert the source image to that depth.</p></li>
<li class="li"><p><strong>Extension.</strong> <strong></strong>  If the format for the compressed data is block oriented, the compressor component can request that the Image Compression Manager allocate a buffer that is a multiple of the proper block size by setting the <code>extendWidth</code> and <code>extendHeight</code> parameters of the compressor capability structure. The new pixels are replicated from the left and bottom edges to fill the extended area. If your compressor can perform this extension itself, it should leave the <code>extendWidth</code> and <code>extendHeight</code> fields set to 0. In this case, the Image Compression Manager can avoid copying the source image to attain more efficient operation.</p></li>
<li class="li"><p><strong>Pixel</strong> <strong>shifting.</strong> <strong></strong>  For pixel sizes less than 8 bits per pixel, it may be necessary to shift the source pixels so that they are at an aligned address. If the <code>pixelSize</code> field of the source pixel map structure is less than 8, and your compressor component handles that depth directly, and the left address of the image (<code>srcRect<code></code></code>.<code>left</code> <code>-</code> <code>srcPixMap<code></code></code>.<code>bounds</code>.<code>left</code>) is not aligned and your compressor component can handle these pixels directly, then it should set the <code>codecCanShift</code> flag in the <code>flags</code> field of the compressor capabilities structure. If your compressor component does not set this flag, then the data will be copied to a buffer with the image shifted so the first pixel is in the most significant bit of an aligned long-word address.</p></li>
<li class="li"><p><strong>Updating</strong> <strong>previous</strong> <strong>pixel</strong> <strong>maps.</strong>  Compressors that perform temporal compression may keep their own copy of the previous frame&#8217;s pixel map, or they may update the previous frame&#8217;s pixel map as they perform the compression. In these cases, the compressor component should set the <code>codecCanCopyPrev</code> flag if it updates the previous pixel map with the original data from the current frame, or it should set the <code>codecCanCopyPrevComp</code> flag if it updates the previous pixel map with a compressed copy of the current frame.</p></li>
</ul>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_79" title="Compressing a Horizontal Band of an Image"></a>
<h3><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-CompressingaHorizontalBandofanImage" title="Compressing a Horizontal Band of an Image"></a>Compressing a Horizontal Band of an Image</h3>
<p>Listing&#160;9-2 shows how the Image Compression Manager calls the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecBandCompress" target="_top">ImageCodecBandCompress</a></code> function when it wants the compressor to compress a horizontal band of an image.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_173" title="Note"></a>
<p><strong>Note:</strong>&nbsp;
This example does not perform compression on bands with a bit depth of more than 1 or an extension of width and height. If the example did do so, it would handle these cases faster.  </p>
</div>
<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_174" title="Listing 9-2Performing simple compression on a horizontal band of an image"></a>
<p class="codesample"><strong>Listing 9-2&nbsp;&nbsp;</strong>Performing simple compression on a horizontal band of an image</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal long ImageCodecBandCompress (Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;register CodecCompressParams *p) <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;short&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width,height;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;Ptr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cDataPtr,dataStart;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;short&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;depth;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;Rect&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sRect;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offsetH,offsetV;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;Globals&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;**glob = (Globals **)storage;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;register char &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*baseAddr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numLines,numStrips;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;short&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mmuMode = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;register short&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;ImageDescription&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;**desc = p-&#62;imageDescription;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;OSErr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;If there is a progress function, give it an open call at<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;the start of this band.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if (p-&#62;progressProcRecord.progressProc)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressProc (codecProgressOpen, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressRefCon);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;width = (*desc)-&#62;width;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;height = (*desc)-&#62;height;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;depth = (*desc)-&#62;depth;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;dataStart = cDataPtr = p-&#62;data;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Figure out offset to first pixel in baseAddr from the<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pixel size and bounds.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160; */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;rowBytes = p-&#62;srcPixMap.rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;sRect = p-&#62;srcPixMap.bounds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;numLines = p-&#62;stopLine - p-&#62;startLine; /* number of scan lines */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;numStrips = (numLines+1)&#62;&#62;1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* number of strips in */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;stripBytes = ((width+1)&#62;&#62;1) * 5;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Adjust the source baseAddress to be at the beginning<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;of the desired rect.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;switch ( p-&#62;srcPixMap.pixelSize ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;case 32:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offsetH = sRect.left&#60;&#60;2;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;case 16:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offsetH = sRect.left&#60;&#60;1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;case 8:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offsetH = sRect.left;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;This compressor does not handle the other cases directly.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;default:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = codecErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;offsetV = sRect.top * rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;baseAddr = p-&#62;srcPixMap.baseAddr + offsetH + offsetV;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;If there is not a data-unloading function,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;adjust the pointer to the next band.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( p-&#62;flushProcRecord.flushProc == nil ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cDataPtr += (p-&#62;startLine&#62;&#62;1) * stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;else { /*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Make sure the compressor can deal with the<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; data-unloading function in this case.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( p-&#62;bufferSize &#60; stripBytes ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = codecSpoolErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Perform the slower data-loading or progress operation, as<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;required.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( p-&#62;flushProcRecord.flushProc ||<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressProc ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SharedGlobals *sg = (*glob)-&#62;sharedGlob;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( y=0; y &#60; numStrips; y++) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SwapMMUMode(&#38;mmuMode);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CompressStrip(cDataPtr,baseAddr,rowBytes,width,sg);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SwapMMUMode(&#38;mmuMode);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;baseAddr += rowBytes&#60;&#60;1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( p-&#62;flushProcRecord.flushProc ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( (result=<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;flushProcRecord.flushProc(cDataPtr,stripBytes,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;flushProcRecord.flushRefCon)) != noErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = codecSpoolErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cDataPtr += stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (p-&#62;progressProcRecord.progressProc) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( (result=<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressProc)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;codecProgressUpdatePercent,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FixDiv(y,numStrips),<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressRefCon)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;) &#160;&#160;!= noErr ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = codecAbortErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;} else {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SharedGlobals *sg = (*glob)-&#62;sharedGlob;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;short tRowBytes = rowBytes&#60;&#60;1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SwapMMUMode(&#38;mmuMode);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( y=numStrips; y--; ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CompressStrip(cDataPtr,baseAddr,rowBytes,width,sg);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cDataPtr += stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;baseAddr += tRowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SwapMMUMode(&#38;mmuMode);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>



<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_80" title="Decompressing an Image"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DecompressinganImage" title="Decompressing an Image"></a>Decompressing an Image</h2>
<p>When decompressing an image, the Image Compression Manager performs these three major tasks:</p>
<ul class="ul">
<li class="li"><p>The Image Compression Manager first determines which decompressor is best able to decompress the image. To do so, the Image Compression Manager examines the source image as well as the parameters specified by the application. If the application requested a specific decompressor, the Image Compression Manager uses that decompressor (unless it is not installed, in which case the Image Compression Manager returns an error to the application). If the application did not request a decompressor, the Image Compression Manager chooses the decompressor that will do the best job. The Image Compression Manager collects the information it needs to choose a decompressor by issuing the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> request to each qualifying decompressor.</p></li>
<li class="li"><p>If the chosen decompressor can handle the image directly, the Image Compression Manager passes the request through to the decompressor. The decompressor then processes the image and returns the image to the specified location.</p></li>
<li class="li"><p>If none of the decompressors can handle all of the conditions (matrix mapping, masking or matting, depth conversion, and so on) the Image Compression Manager allocates an offscreen buffer and passes image bands to the decompressor at a depth that the decompressor can handle by issuing a <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecBandDecompress" target="_top">ImageCodecBandDecompress</a></code> request. The decompressor processes each band, building the image as it goes. When the image has been completely decompressed, the Image Compression Manager returns control to the application.</p></li>
</ul>
<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_81" title="Choosing a Decompressor"></a>
<h3><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-ChoosingaDecompressor" title="Choosing a Decompressor"></a>Choosing a Decompressor</h3>
<p>Listing&#160;9-3 provides an example of how a decompressor is chosen. The Image Compression Manager calls the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> function before an image is decompressed. The decompressor returns information about how it can decompress an image. The Image Compression Manager can fit the destination pixel map to your decompressor&#8217;s requirements if it is not able to support decompression to the destination directly. The capability information the decompressor returns includes</p>
<ul class="spaceabove">
<li class="li"><p>depth of pixels for the destination pixel map</p></li>
<li class="li"><p>minimum band size handled</p></li>
<li class="li"><p>extension width and height required</p></li>
<li class="li"><p>band increment size</p></li>
</ul>
<p>When your decompressor component is called with the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> function, it can handle all aspects of the call itself, or only the most common ones. All decompressors must handle at least one case.</p>
<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_175" title="Listing 9-3Preparing for simple decompression"></a>
<p class="codesample"><strong>Listing 9-3&nbsp;&nbsp;</strong>Preparing for simple decompression</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal long ImageCodecPreDecompress( Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;register CodecDecompressParams *p)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;register CodecCapabilities*capabilities = p-&#62;capabilities;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;RectdRect = p-&#62;srcRect;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Check if the matrix is OK for this decompressor.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;This decompressor doesn't do anything fancy.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( !TransformRect(p-&#62;matrix,&#38;dRect,nil) )<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return(codecConditionErr);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Decide which depth compressed data this decompressor can<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;deal with.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;switch ( (*p-&#62;imageDescription)-&#62;depth ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 16:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return(codecConditionErr);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;This decompressor can deal only with 32-bit pixels.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;wantedPixelSize = 32;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;The smallest possible band the decompressor can handle is<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 scan lines.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;bandMin = 2;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/* This decompressor can deal with 2 scan line high bands. */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;bandInc = 2;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;If this decompressor needed its pixels be aligned on<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;some integer multiple, you would set extendWidth and<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;extendHeight to the number of pixels by which you need the<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;destination extended. If you don't have such requirements<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;or if you take care of them yourself, you set extendWidth<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and extendHeight to 0.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;extendWidth = p-&#62;srcRect.right &#38; 1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;extendHeight = p-&#62;srcRect.bottom &#38; 1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return(noErr);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_82" title="Decompressor Operations"></a>
<h3><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DecompressorOperations" title="Decompressor Operations"></a>Decompressor Operations</h3>
<p>This section contains a bulleted list of some of the operations your decompressor component can perform during the decompression operation. The list describes which parameters in the decompression parameters structure indicate that the operations are required and which flags in the flags field of the compressor capabilities structure must be set to allow your decompressor to handle them (see <span class="content_text"><a href="../K-Chapter/11CodecComponentsAPI.html#//apple_ref/doc/uid/TP40000878-CodecComponentsAPI-DataStructures">Data Structures</a></span>).</p>
<p>For sequences of images the <code>conditionFlags</code> field in the decompression parameters structure can be used to determine which parameters may have changed since the last decompression operation. These parameters are also indicated in the bulleted list.</p>
<p>Since your decompressor&#8217;s capabilities depend on the full combination of parameters, it must inspect all the relevant parameters before indicating that it will perform one of the operations itself. For instance, if your decompressor has hardware that can perform scaling only if the destination pixel depth is 32 and there is no clipping, then the pre-decompression operation would have to check the following fields in the decompression parameters structure: the <code>matrix</code> field, the <code>pixelSize</code> field of the destination pixel map structure pointed to by the <code>destPixMap</code> field, and the <code>maskBits</code> fields. Only then could the decompressor decide whether to set the <code>codecCanScale</code> flag in the <code>capabilities</code> field of the decompression parameters structure.</p>
<ul class="spaceabove">
<li class="li"><p><strong>Scaling.</strong> The decompressor component can look at the matrix and selectively decide which scaling operations it wishes to handle. If the scaling factor specified by the matrix is not unity and your decompressor can perform the scaling operation, it must set the <code>codecCanScale</code> flag in the <code>capabilities</code> field. If it does not, then the decompressor is asked to decompress without scaling, and the Image Compression Manager performs the scaling operation afterward.</p></li>
<li class="li"><p><strong>Depth</strong> <strong>conversion.</strong> If your component can decompress to the pixel depth indicated by the <code>pixelSize</code> field (of the pixel map structure pointed to by the <code>dstPixmap</code> field of the decompression parameters structure), it should set the <code>wantedPixelSize</code> field of the compressor capability structure to the same value. If it cannot handle that depth, it should specify the closest depth it can handle in the <code>wantedPixelSize</code> field.</p></li>
<li class="li"><p><strong>Dithering.</strong> When determining whether depth conversion can be performed (for converting an image to a lower bit depth, or to a similar bit depth with a different color table), dithering may be required. This is specified by the dither bit in the <code>transferMode</code> field (<code>0x40</code>) of the decompression parameters structure being set. The <code>accuracy</code> field of the decompression parameters structure indicates whether fast dithering is acceptable (<code>accuracy</code> less than or equal to <code>codecNormalQuality</code>) or whether true error diffusion dithering should be used (<code>accuracy</code> greater than <code>codecNormalQuality</code>). Most decompressors do not perform true error diffusion dithering, although they can. When a decompressor cannot perform the dither operation, it should specify the higher bit depth in the <code>wantedPixelSize</code> field of the compressor capability structure and let the Image Compression Manager perform the depth conversion with dithering. Dithering to 16-bit destinations is normally done only if the <code>accuracy</code> field is set to the <code>codecNormalQuality</code> value. However, if your decompressor component can perform dithering fast enough, it could be performed at the lower accuracy settings as well. To indicate that your decompressor can perform dithering as specified, it should set the <code>codecCanTransferMode</code> flag in the <code>capabilities</code> field of the decompression parameters structure.</p></li>
<li class="li"><p><strong>Color</strong> <strong>remapping.</strong> If the compressed data has an associated color lookup table that is different from the color lookup table of the destination pixel map, then the decompressor can remap the color indices to the closest available ones in the destination itself, or it can let the Image Compression Manager do the remapping. If the decompressor can do the mapping itself, it should set the <code>codecCanRemap</code> flag in the <code>capabilities</code> flags field of the decompression parameters structure.</p></li>
<li class="li"><p><strong>Extending.</strong> If the format for the compressed data is block-oriented, the decompressor can ask that the Image Compression Manager to allocate a buffer which is a multiple of the proper block size by setting the <code>extendWidth</code> and <code>extendHeight</code> fields of the compressor capabilities structure. If the right and bottom edges of the destination image (as determined by the transformed <code>srcRect</code> and <code>dstPixMap<code></code></code>.<code>bounds</code> fields of the decompression parameters structure) are not a multiple of the block size that your decompressor handles, and your decompressor cannot handle partial blocks (writing only the pixels that are needed for blocks that cross the left or bottom edge of the destination), then your decompressor component must set the <code>extendWidth</code> and <code>extendHeight</code> fields in the compressor capabilities structure. In this case, the Image Compression Manager creates a buffer large enough so that no partial blocks are needed. Your component can decompress into that buffer. This is then copied to the destination by the Image Compression Manager. Your component can avoid this extra step if it can handle partial blocks. In this case, it should leave the <code>extendWidth</code> and <code>extendHeight</code> fields set to 0.</p></li>
<li class="li"><p><strong>Clipping.</strong> If clipping must be performed on the image to be decompressed, the <code>maskBits</code> field of the decompression parameters structure is nonzero. In the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> function, it will be a region handle to the actual clipping region. If your decompressor can handle the clipping operation as specified by this region, it should set the <code>codecCanMask</code> bit in the <code>capabilities</code> flags field of the decompression parameters structure. If it does this, then the parameter passed to the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecBandDecompress" target="_top">ImageCodecBandDecompress</a></code> function in the <code>maskBits</code> field will be a <code>bitmap</code> instead of a region. If desired, your decompressor can save a copy of the actual region structure during the pre-decompression operation.</p></li>
<li class="li"><p><strong>Matting.</strong> If a matte must be applied to the decompressed image, the <code>transferMode</code> field of the decompression parameters structure is set to blend and the <code>mattePixMap</code> field is a handle to the pixel map to be used as the matte. If your decompressor can perform the matte operation, then it should set the <code>codecCanMatte</code> field in the compressor capabilities structure. If it does not, then the Image Compression Manager will perform the matte operation after the decompression is complete.</p></li>
<li class="li"><p><strong>Pixel</strong> <strong>shifting.</strong> For pixel sizes less than 8 bits per pixel, it may be necessary to shift the destination pixels so that they are at an aligned address. If the pixel size of the destination pixel map is less than 8 and your component handles that depth directly, and the left address of the image is not aligned and your component can handle these pixels directly, then it should set the <code>codecCanShift</code> flag in the <code>capabilities</code> field of the decompression parameters structure. If your component does not set this flag, the Image Compression Manager allocates a buffer for and performs the shifting after the decompression is completed.</p></li>
<li class="li"><p><strong>Partial</strong> <strong>extraction.</strong> If the source rectangle is not the entire image and the component can decompress only the part of the image specified by the source rectangle, it should set the <code>codecCanSrcExtract</code> flag in the <code>capabilities</code> field of the decompression parameters structure. If it does not, the Image Compression Manger asks the component to decompress the entire image and copy only the required part to the destination.</p></li>
</ul>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_83" title="Decompressing a Horizontal Band of an Image"></a>
<h3><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DecompressingaHorizontalBandofanImage" title="Decompressing a Horizontal Band of an Image"></a>Decompressing a Horizontal Band of an Image</h3>
<p>Listing&#160;9-4 shows how to decompress the horizontal band of an image. The Image Compression Manager calls the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecBandDecompress" target="_top">ImageCodecBandDecompress</a></code> function when it wants a decompressor to decompress an image or a horizontal band of an image. The pixel data indicated by the <code>baseAddr</code> field is guaranteed to conform to the criteria your decompressor specified in the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> function.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_176" title="Note"></a>
<p><strong>Note:</strong>&nbsp;
This example does not perform decompression on bands with a bit depth of more than one or an extension of width and height. If the example did do so, it would handle these cases faster.  </p>
</div>
<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_177" title="Listing 9-4Performing a decompression operation"></a>
<p class="codesample"><strong>Listing 9-4&nbsp;&nbsp;</strong>Performing a decompression operation</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal long ImageCodecBandDecompress( Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;register CodecDecompressParams *p) <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;Rect&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dRect;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offsetH,offsetV;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;Globals&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;**glob = (Globals **)storage;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numLines,numStrips;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;short&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;short&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;register short&#160;&#160;&#160;&#160;&#160;&#160;y;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;register char*&#160;&#160;&#160;&#160;&#160;&#160;baseAddr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*cDataPtr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mmuMode = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;OSErr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Calculate the real base address based on the boundary<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rectangle. If it's not a linear transformation, this<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;decompressor does not perform the operation.<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;dRect = p-&#62;srcRect;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( !TransformRect(p-&#62;matrix,&#38;dRect,nil) )<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return(paramErr);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/* &#160;If there is a progress function, give it an open call at<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;the start of this band.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if (p-&#62;progressProcRecord.progressProc)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressProc(codecProgressOpen,0,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressRefCon);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Initialize some local variables.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;width = (*p-&#62;imageDescription)-&#62;width;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;rowBytes = p-&#62;dstPixMap.rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;numLines = p-&#62;stopLine - p-&#62;startLine; /* number of scan lines<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in this band */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;numStrips = (numLines+1)&#62;&#62;1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* number of strips in<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this band */ <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;stripBytes = ((width+1)&#62;&#62;1) * 5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* number of bytes in<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1 strip of blocks */  <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;cDataPtr = p-&#62;data;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Adjust the destination base address to be at the beginning<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;of the desired rectangle.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;offsetH = (dRect.left - p-&#62;dstPixMap.bounds.left);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;switch ( p-&#62;dstPixMap.pixelSize ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 32:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offsetH &#60;&#60;=2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 1 pixel = 4 bytes */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 16:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offsetH &#60;&#60;=1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 1 pixel = 2 bytes */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 8:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 1 pixel = 1 byte */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = codecErr;&#160;&#160;/* This decompressor doesn't handle<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;these cases, although it could. */ <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;offsetV = (dRect.top - p-&#62;dstPixMap.bounds.top) * rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;baseAddr = p-&#62;dstPixMap.baseAddr + offsetH + offsetV;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;If your decompressor component is skipping some data,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;it just skips it here. You can tell because<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;firstBandInFrame indicates this is the first band for a new<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;frame, and if startLine is not 0, then that many lines were<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;clipped out.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160; */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( (p-&#62;conditionFlags &#38; codecConditionFirstBand) &#38;&#38;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;startLine != 0 ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( p-&#62;dataProcRecord.dataProc ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( y=0; y &#60; p-&#62;startLine&#62;&#62;1; y++ ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( (result=p-&#62;dataProcRecord.dataProc<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (&#38;cDataPtr,stripBytes,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;dataProcRecord.dataRefCon)) != noErr ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = codecSpoolErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cDataPtr += stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cDataPtr += (p-&#62;startLine&#62;&#62;1) * stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;    &#160;&#160;&#160;If there is a data-loading function spooling the data to your<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;    &#160;&#160;&#160;decompressor, then you have to decompress the data in the<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;    &#160;chunk size that is specified, or, if there is a progress<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;    &#160;function, you must make sure to call it as you go along.<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( p-&#62;dataProcRecord.dataProc ||<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; p-&#62;progressProcRecord.progressProc ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SharedGlobals *sg = (*glob)-&#62;sharedGlob;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (y=0; y &#60; numStrips; y++) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (p-&#62;dataProcRecord.dataProc) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( (result=p-&#62;dataProcRecord.dataProc<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (&#38;cDataPtr,stripBytes,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;dataProcRecord.dataRefCon)) != noErr ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = codecSpoolErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SwapMMUMode(&#38;mmuMode);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DecompressStrip(cDataPtr,baseAddr,rowBytes,width,sg);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SwapMMUMode(&#38;mmuMode);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;baseAddr += rowBytes&#60;&#60;1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cDataPtr += stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (p-&#62;progressProcRecord.progressProc) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( (result=p-&#62;progressProcRecord.progressProc<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(codecProgressUpdatePercent,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FixDiv(y, numStrips),<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressRefCon)) != noErr ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = codecAbortErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;Otherwise, do the fast case.<span></span></pre></td></tr><tr><td scope="row"><pre>*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;} else {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SharedGlobals *sg = (*glob)-&#62;sharedGlob;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shorttRowBytes = rowBytes&#60;&#60;1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SwapMMUMode(&#38;mmuMode);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( y=numStrips; y--; ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DecompressStrip(cDataPtr,baseAddr,rowBytes,width,sg);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;baseAddr += tRowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cDataPtr += stripBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SwapMMUMode(&#38;mmuMode);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;IMPORTANT: Update the pointer to data in the decompression<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;parameters structure, so that when your decompressor gets the<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;next band, you'll be at the right place in your data.<span></span></pre></td></tr><tr><td scope="row"><pre>*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;p-&#62;data = cDataPtr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( p-&#62;conditionFlags &#38; codecConditionLastBand ) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Tie up any loose ends on the last band of the frame.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/*<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;If there is a progress function, give it a close call<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at the end of this band.<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;*/<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if (p-&#62;progressProcRecord.progressProc)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressProc(codecProgressClose,0,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p-&#62;progressProcRecord.progressRefCon);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return(result);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>



<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_84" title="Asynchronous Decompression"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-AsynchronousDecompression" title="Asynchronous Decompression"></a>Asynchronous Decompression</h2>
<p>The Image Compression Manager (ICM) supports scheduled asynchronous decompression operations. By calling the Image Compression Manager function <code><a href="../../../../Reference/QTRef_CompDecomp/Reference/reference.html#//apple_ref/c/func/DecompressSequenceFrameWhen" target="_top">DecompressSequenceFrameWhen</a></code>, applications can schedule decompression requests in advance. This allows decompressor components that support this functionality to provide reliable playback performance under a wider range of conditions.</p>
<p>The Apple Cinepak, Video, Animation, Component Video, and Graphics decompressors provided in QuickTime support scheduled asynchronous decompression to 8-, 16-, and 32-bit destinations (the Cinepak decompressor also supports 4-bit grayscale destinations). QuickTime&#160;also adds asynchronous decompression support to the JPEG and None decompressor components on PowerPC systems (with the QuickTime PowerPlug extension installed).</p>
<p>If you want to support this functionality, you must modify your decompressor component in the following ways:</p>
<ul class="ul">
<li class="li"><p>Report your component&#8217;s new capabilities in its compressor capability structure by setting the <code>codecCanAsyncWhen</code> and <code>codecCanAsync</code> flags.</p></li>
<li class="li"><p>Modify your component&#8217;s  <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecFlush" target="_top">ImageCodecFlush</a></code> function to accept scheduled asynchronous decompression requests and process them correctly.</p></li>
<li class="li"><p>Implement the new function  <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecFlush" target="_top">ImageCodecFlush</a></code>; this function allows the Image Compression Manager to instruct you to empty your input queue.</p></li>
<li class="li"><p>Optionally, implement logic to manage the shielding of the cursor during decompression operations.</p></li>
</ul>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_85" title="Hardware Cursors"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-HardwareCursors" title="Hardware Cursors"></a>Hardware Cursors</h2>
<p>The Image Compression Manager supports hardware cursors introduced in PCI-based Macintosh computers, which eliminates cursor flicker. For all software codecs, this support requires no changes.</p>
<p>For codecs that manage the cursor themselves, QuickTime has a flag, <code>codecCompletionDontUnshield</code>, for use when calling the  <code><a href="../../../../Reference/QTRef_CompDecomp/Reference/reference.html#//apple_ref/c/func/ICMDecompressComplete" target="_top">ICMDecompressComplete</a></code> function. Use this flag to prevent the Image Compression Manager from unshielding the cursor when <code><a href="../../../../Reference/QTRef_CompDecomp/Reference/reference.html#//apple_ref/c/func/ICMDecompressComplete" target="_top">ICMDecompressComplete</a></code> is called.</p>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_86" title="Timecode Support"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-TimecodeSupport" title="Timecode Support"></a>Timecode Support</h2>
<p>QuickTime provides timecode information to decompressor components when movies are played. To support timecodes, your codec must support the function <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecSetTimeCode" target="_top">ImageCodecSetTimeCode</a></code>, which allows the Image Compression Manager to set the timecode value for the next frame to be decompressed.</p>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_87" title="Working With Video Fields"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-WorkingWithVideoFields" title="Working With Video Fields"></a>Working With Video Fields</h2>
<p>The functionality of the <code><a href="../../../../Reference/QTRef_CompDecomp/Reference/reference.html#//apple_ref/c/func/ImageFieldSequenceExtractCombine" target="_top">ImageFieldSequenceExtractCombine</a></code> function is performed by individual image codecs. This is because the way in which fields are stored is different for every compression format. A codec component function, <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecExtractAndCombineFields" target="_top">ImageCodecExtractAndCombineFields</a></code>, is defined for this purpose. Apple encourages developers of codecs to incorporate this function, if their compressed data format is capable of separately storing both fields of a video frame.</p>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_88" title="Accelerated Video Support"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-AcceleratedVideoSupport" title="Accelerated Video Support"></a>Accelerated Video Support</h2>
<p>QuickTime supports codecs that accelerate certain image decompression operations. These features are most likely used by developers of video hardware boards that provide special acceleration features, such as arbitrary scaling or color space conversion.</p>
<p>If a codec cannot decompress directly to the screen it has the option of specifying that it can decompress to one or more types of non-RGB pixel spaces, specified as an <code>OSType</code> (e.g., <code>'yuvs'</code>). The ICM then attempts to find a decompressor component of that type (a transfer codec) that can transfer the image to the screen. Since the ICM does not define non-RGB pixel types, the transfer codec must support additional calls to set up the offscreen. If a transfer codec cannot be found that supports the specified non-RGB pixel types, the ICM uses the None codec with an RGB offscreen buffer.</p>
<p>The real speed benefit comes from the fact that since the transfer codec defines the offscreen buffer, it can place the buffer in on-board memory, or even point to an overlay plane so that the offscreen image really is on the screen. In this case, the additional step of transferring the bits from offscreen memory on to the screen is avoided.</p>
<p>For an image decompressor component to indicate that it can decompress to non-RGB pixel types, it should, in the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> call, fill in the <code>wantedDestinationPixelTypes</code> field with a handle to a zero-terminated list of pixel types that it can decompress to. The ICM immediately makes a copy of the handle. Cinepak, for example, returns a 12-byte handle containing <code>yuvs</code>, <code>yuvu</code>, and $00000000. Since <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> can be called often, it is suggested that codecs allocate this handle when their component is opened and simply fill in the <code>wantedDestinationPixelTypes</code> field with this handle during <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code>. Components that use this method should be sure to dispose the handle at close.</p>
<p>Apple&#8217;s Cinepak decompressor supports decompressing to <code>'yuvs'</code> and <code>'yuvu'</code> pixel types. Type <code>'yuvs'</code> is a YUV format with u and <code>v</code> components signed (center point at $00), while <code>'yuvu'</code> has the u and <code>v</code> component centered at $80.</p>
<p>As an example, suppose XYZ Co. had a video board that had a YUV overlay plane capable of doing arbitrary scaling. The overlay plane takes data in the same format as Cinepak&#8217;s <code>'yuvs'</code> format. In this case, XYZ would make a component of type <code>'imdc'</code> and subtype <code>'yuvs'</code>.</p>
<p>The <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> call would set the <code>codecCanScale</code>, <code>codecHasVolatileBuffer</code>, and <code>codecImageBufferIsOnScreen</code> bits in the <code>capabilities</code> <code>flags</code> field. The <code>codecImageBufferIsOnScreen</code> bit is necessary to inform the ICM that the codec is a direct screen transfer codec. A direct screen transfer codec is one that sets up an offscreen buffer that is actually onscreen (such as an overlay plane). Not setting this bit correctly can cause unpredictable results.</p>
<p>The real work of the codec takes place in the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecNewImageBufferMemory" target="_top">ImageCodecNewImageBufferMemory</a></code> call. This is where the codec is instructed to prepare the non-RGB pixel buffer. The codec must fill in the <code>baseAddr</code> and <code>rowBytes</code> fields of the <code>dstPixMap</code> structure in <code><!--a target="_top" -->CodecDecompressParams<!--/a--></code>. The ICM then passes these values to the original codec (e.g., Cinepak) to decompress into.</p>
<p>The codec must also implement <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecDisposeMemory" target="_top">ImageCodecDisposeMemory</a></code> to balance <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecNewImageBufferMemory" target="_top">ImageCodecNewImageBufferMemory</a></code>.</p>
<p>Since Cinepak then decompresses into the card&#8217;s overlay plane, <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecBandDecompress" target="_top">ImageCodecBandDecompress</a></code> needs to do nothing aside from calling <code><a href="../../../../Reference/QTRef_CompDecomp/Reference/reference.html#//apple_ref/c/func/ICMDecompressComplete" target="_top">ICMDecompressComplete</a></code>.</p>

<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult<span></span></pre></td></tr><tr><td scope="row"><pre>ImageCodecPreDecompress(Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CodecDecompressParams *p)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;CodecCapabilities&#160;&#160;&#160;*capabilities = p-&#62;capabilities;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;// only allow 16 bpp source<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ((**p-&#62;imageDescription).depth != 16)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return codecConditionErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/* we only support 16 bits per pixel dest */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if (p-&#62;dstPixMap.pixelSize != 16)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return codecConditionErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;wantedPixelSize = p-&#62;dstPixMap.pixelSize;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;bandInc = capabilities-&#62;bandMin =<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(*p-&#62;imageDescription)-&#62;height;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;extendWidth = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;extendHeight = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;capabilities-&#62;flags =<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;codecCanScale | codecImageBufferIsOnScreen |<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;codecHasVolatileBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ImageCodecBandDecompress(Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CodecDecompressParams *p)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;ICMDecompressComplete(p-&#62;sequenceID, noErr,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;codecCompletionSource | codecCompletionDest,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;p-&#62;completionProcRecord);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult<span></span></pre></td></tr><tr><td scope="row"><pre>ImageCodecNewImageBufferMemory(Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CodecDecompressParams *p, long flags,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ICMMemoryDisposedUPP memoryGoneProc,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void *refCon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long offsetH, offsetV;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;Ptr baseAddr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;// call predecompress to check to make sure we can handle<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;// this destination<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;err = ImageCodecPreDecompress(storage, p);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if (err) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;// set video board registers with the scale<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;XYZVideoSetScale(p-&#62;matrix);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;// calculate a base address to write to<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;offsetH = (p-&#62;dstRect.left - p-&#62;dstPixMap.bounds.left);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;offsetV = (p-&#62;dstRect.top - p-&#62;dstPixMap.bounds.top);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;XYZVideoGetBaseAddress(p-&#62;dstPixMap, offsetH, offsetV,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;baseAddr, &#38;rowBytes);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;p-&#62;dstPixMap.baseAddr = baseAddr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;p-&#62;dstPixMap.rowBytes = rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;p-&#62;capabilities-&#62;flags = codecImageBufferIsOnScreen;<span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult<span></span></pre></td></tr><tr><td scope="row"><pre>ImageCodecDisposeMemory(Handle storage, Ptr data)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

<p>Some video hardware boards that use an overlay plane require that the image area on screen be flooded with a particular RGB value or alpha-channel in order to have the overlay buffer &#8220;show through&#8221; at that location. Codecs that require this support should set the <code>screenFloodMethod</code> and <code>screenFloodValue</code> fields of the <code><!--a target="_top" -->CodecDecompressParams<!--/a--></code> record during <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code>. The ICM then manages the flooding of the screen buffer. This method is more reliable than having the codec attempt to flood the screen itself, and will ensure compatibility with future versions of QuickTime.</p>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_89" title="Packetization Information"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-PacketizationInformation" title="Packetization Information"></a>Packetization Information</h2>
<p>QuickTime functions support packetizing compressed data streams, primarily for video conferencing applications. For this purpose, the field <code>preferredPacketSizeInBytes</code> was added to the compression parameters structure. Codec developers need only use this field.</p>
<p>Packet information is appended, word-aligned, to the end of video data. It is a variable-length array of 4-byte integers, each representing the offset in bits of the end of a packet, followed by another integer containing the number of packet hints, and finally a four-byte identifier indicating the type of appended data:</p>

<div class="codesample"><table><tr><td scope="row"><pre>[boundary #1][boundary #2]...[boundary #N][N]['pkts']<span></span></pre></td></tr></table></div>

<p>Packets are given in bits, because some types of compressed image data (such as H.261) are cut up on bit-boundaries rather than byte-boundaries.</p>

<div class="codesample"><table><tr><td scope="row"><pre>// given:  image data, length, and a packet number<span></span></pre></td></tr><tr><td scope="row"><pre>// returns: a pointer to the start of the packet and a packet size, plus<span></span></pre></td></tr><tr><td scope="row"><pre>// information about leading and trailing bits<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>char* GetNextPacket(char* data, int len, int packet, long* packet_size,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;char* leading_bits, char* trailing_bits)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;long *lp, packets;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;lp = (long*) data;&#160;&#160;// 'data' must be word-aligned<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;lp += len/4 - 1;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if (*lp != 'pkts')<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;packets = *lp[ -1 ];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// negative indexing is good for you<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if (packet &#62;= packets)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return nil;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// out of bounds<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;lp -= packets;&#160;&#160;&#160;&#160;&#160;&#160;// now 0-indexing into the packet array will work<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if (packet == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*packet_size = (lp[0] + 7)/8;&#160;&#160;&#160;// count the bits<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*leading_bits = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*trailing_bits = lp[0] % 8;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return data;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// in case of 0-length packet <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;else<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*packet_size = ( lp[pktnum] - lp[pktnum-1] + 7) / 8;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*leading_bits = lp[packet-1] % 8 ? 8 - lp[packet-1] % 8 : 0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*trailing_bits = lp[packet] % 8;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return data + lp[packet-1] / 8;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

<p>Note that this technique can be used for further extensions by the addition of further appended formats. The last two words are always the number of words and an extension identifier.</p>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_90" title="DV Image Compressor Component"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DVImageCompressorComponent" title="DV Image Compressor Component"></a>DV Image Compressor Component</h2>
<p>The DV image compressor component makes it possible to compress QuickTime video data into DV format. It is invoked automatically by the Image Compression Manager when an application requests output of type <code>kDVCNTSCCodecType</code> for NTSC DV data or <code>kDVCPALCodecType</code> for PAL DV data.</p>
<p>When creating NTSC video, the DV image compressor component generates 720 X 480 frames. When creating PAL video, it generates 720 X 576 frames.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_178" title="Note"></a>
<p><strong>Note:</strong>&nbsp;
Many DV devices use IEEE 1394 (FireWire) serial connections for input/output operations. QuickTime supports compression and decompression of DV data, but it does not include support for FireWire communication. You need additional software to communicate with DV devices.  </p>
</div>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_91" title="DV Image Decompressor Component"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DVImageDecompressorComponent" title="DV Image Decompressor Component"></a>DV Image Decompressor Component</h2>
<p>The DV image decompressor component makes it possible to decompress DV video data. It is invoked automatically by the Image Compression Manager when an application specifies input of type <code>kDVCNTSCCodecType</code> for NTSC DV data or <code>kDVCPALCodecType</code> for PAL DV data.</p>
<p>There are two quality modes for DV decompression:</p>
<ul class="ul">
<li class="li"><p>In the low-quality mode, which is the default, the DV image decompressor component generates a 1/4-screen image. When operating in this mode, the component uses approximately 25% of the video data in the DV stream and correspondingly fewer system resources.</p></li>
<li class="li"><p>In the high-quality mode, the component processes all of the video data in the DV stream. Applications can specify the high-quality modem by calling the <code><a href="../../../../Reference/QTRef_MovieToolkit/Reference/reference.html#//apple_ref/c/func/SetMediaPlayHints" target="_top">SetMediaPlayHints</a></code> function with the <code>hintsHighQuality</code> flag set.</p></li>
</ul>
<p>When a computer includes a video display adapter that performs YUV decompression in hardware, the DV image decompressor can use a YUV decompressor component written to use the hardware decompression capabilities in place of the software YUV decompressor in QuickTime, resulting in even higher performance.</p>

<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_92" title="Specifying the Size of an Image Buffer"></a>
<h2><a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-SpecifyingtheSizeofanImageBuffer" title="Specifying the Size of an Image Buffer"></a>Specifying the Size of an Image Buffer</h2>
<p>You can specify the size of the image buffer used by your image compressor or decompressor component. When your component calls the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> or <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreCompress" target="_top">ImageCodecPreCompress</a></code> function, you can specify the size of the buffer as follows:</p>
<ul class="ul">
<li class="li"><p>In the <code><!--a target="_top" -->CodecDecompressParams<!--/a--></code> or <code><!--a target="_top" -->CodecCompressParams<!--/a--></code> record, set the <code>codecWantsSpecialScaling</code> flag in the <code>flags</code> field of the <code><!--a target="_top" -->CodecCapabilities<!--/a--></code> record.</p></li>
<li class="li"><p>Provide values for the <code>requestedBufferWidth</code> and <code>requestedBufferHeight</code> fields in the <code><!--a target="_top" -->CodecDecompressParams<!--/a--></code> or <code><!--a target="_top" -->CodecCompressParams<!--/a--></code> record.</p></li>
</ul>
<p>This is illustrated in Listing&#160;9-5.</p>
<a name="//apple_ref/doc/uid/TP40000878-UsingImageCompressorComponents-DontLinkElementID_179" title="Listing 9-5Specifying the size of an image buffer for a codec"></a>
<p class="codesample"><strong>Listing 9-5&nbsp;&nbsp;</strong>Specifying the size of an image buffer for a codec</p>
<div class="codesample"><table><tr><td scope="row"><pre>p-&#62;capabilities-&#62;flags |= codecWantsSpecialScaling;<span></span></pre></td></tr><tr><td scope="row"><pre>p-&#62;requestedBufferWidth = 720;<span></span></pre></td></tr><tr><td scope="row"><pre>p-&#62;requestedBufferHeight = 480;<span></span></pre></td></tr></table></div>





        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../I-Chapter/9AboutImageCompresso.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../K-Chapter/11CodecComponentsAPI.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-01-10<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/RM/CompressDecompress/ImageComprMgr/J-Chapter/10UsingImageCompresso.html%3Fid%3DTP40000878-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/RM/CompressDecompress/ImageComprMgr/J-Chapter/10UsingImageCompresso.html%3Fid%3DTP40000878-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/RM/CompressDecompress/ImageComprMgr/J-Chapter/10UsingImageCompresso.html%3Fid%3DTP40000878-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>