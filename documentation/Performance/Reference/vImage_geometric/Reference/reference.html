<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>vImage Geometry Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="vImage Geometry Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005490-DontLinkChapterID_1" title="vImage Geometry Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> &gt; <a href="../../../../../reference/Performance/index.html#//apple_ref/doc/uid/TP30001281-TP30000430" target="_top">Performance</a> &gt; <a href="../../../../../reference/Performance/idxGraphicsImaging-date.html#//apple_ref/doc/uid/TP30001281-TP30000430-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../index.html" target="_top">vImage Geometry Reference</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005490-DontLinkChapterID_1-DontLinkElementID_10" title="vImage Geometry Reference"></a><h1>vImage Geometry Reference</h1><div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr><td scope="row"><strong><span style="white-space: nowrap;">Framework</span></strong></td><td><div style="margin-bottom:1px"><a href="../../vDSP_Reference_Collection/index.html#//apple_ref/doc/uid/TP40006226" target="_top">Accelerate</a>/vImage</div></td></tr><tr><td scope="row"><strong><span class="noWrap">Companion guide</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text"><a href="../../../Conceptual/vImage/index.html#//apple_ref/doc/uid/TP30001001" target="_top">vImage Programming Guide</a></span><br/></div></td></tr><tr><td scope="row"><strong><span style="white-space: nowrap;">Declared in</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text">Geometry.h</span><br/></div></td></tr></table></div><br/><a name="//apple_ref/doc/uid/TP40005490-CH1-DontLinkElementID_7" title="Overview"></a><h2>Overview</h2><p>Geometric functions rotate, resize, and distort the geometry of images. vImage provides both high-level (rotation, scaling, and warping) and low-level geometric functions (reflection, shearing, and low-level rotation). </p><p>Most vImage geometric functions resample image data  to avoid creating artifacts, such as interference patterns, in the destination image. vImage uses resampling kernels, which combine data from a target pixel and other nearby pixels to calculate a value for the destination pixel, a procedure somewhat similar to that used for convolution. However, for geometric operations, the resampling kernel itself is resampled during the process of pairing kernel values against the sampled pixel data. The kernel is evaluated at both fractional and integral pixel locations. This has implications for the nature of the kernel—which must be supplied as a function rather than as an M by N matrix. A resampling kernel function is also called a resampling filter, or simply a filter.</p><p>For almost all geometric operations, vImage supplies a default resampling filter unless you set the flag <code>kvImageHighQualityResampling</code>, in which case vImage uses a  higher-quality filter, but that filter may be slower to use.</p><p>The reflection and high-level rotation functions don’t resample. The shear functions can either use a default resampling filter or, if you require more control, a custom filter that you provide. </p><a name="//apple_ref/doc/uid/TP40005490-DontLinkChapterID_1-DontLinkElementID_8" title="Functions by Task"></a><h2>Functions by Task</h2>
<a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_1" title="Applying Affine Transforms"></a>
    
    <h3 class="tasks">Applying Affine Transforms</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageAffineWarp_ARGBFFFF">vImageAffineWarp_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies an affine transform to an ARGBFFFF source image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageAffineWarp_ARGB8888">vImageAffineWarp_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies an affine transform to an ARGB8888 source image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageAffineWarp_PlanarF">vImageAffineWarp_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies an affine transform to a PlanarF source image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageAffineWarp_Planar8">vImageAffineWarp_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies an affine transform to a Planar8 source image.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_2" title="Reflecting"></a>
    
    <h3 class="tasks">Reflecting</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageHorizontalReflect_ARGBFFFF">vImageHorizontalReflect_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reflects an ARGBFFFF source image left to right across the center vertical line of the image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageHorizontalReflect_PlanarF">vImageHorizontalReflect_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reflects a PlanarF source image left to right across the center vertical line of the image, placing the result in a destination buffer. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageHorizontalReflect_Planar8">vImageHorizontalReflect_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reflects a Planar9 source image left to right across the center vertical line of the image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageHorizontalReflect_ARGB8888">vImageHorizontalReflect_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reflects an ARGB8888 source image left to right across the center vertical line of the image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageVerticalReflect_ARGBFFFF">vImageVerticalReflect_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reflects an ARGBFFFF source image top to bottom across the center vertical line of the image. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageVerticalReflect_ARGB8888">vImageVerticalReflect_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reflects an ARGBFFFF source image top to bottom across the center vertical line of the image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageVerticalReflect_PlanarF">vImageVerticalReflect_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reflects a PlanarF source image top to bottom across the center vertical line of the image. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageVerticalReflect_Planar8">vImageVerticalReflect_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Reflects a Planar 8 source image top to bottom across the center vertical line of the image.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_3" title="Shearing"></a>
    
    <h3 class="tasks">Shearing</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageHorizontalShear_ARGBFFFF">vImageHorizontalShear_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Performs a horizontal shear operation on a region of interest of an ARGBFFFF source image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageHorizontalShear_ARGB8888">vImageHorizontalShear_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Performs a horizontal shear operation on a region of interest of an ARGB8888 source image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageHorizontalShear_PlanarF">vImageHorizontalShear_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Performs a horizontal shear operation on a region of interest of a PlanarF source image. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageHorizontalShear_Planar8">vImageHorizontalShear_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Performs a horizontal shear operation on a region of interest of a Planar8 source image. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageVerticalShear_ARGBFFFF">vImageVerticalShear_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Performs a vertical shear operation on a region of interest of an ARGBFFFF source image. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageVerticalShear_ARGB8888">vImageVerticalShear_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Performs a vertical shear operation on a region of interest of an ARGB8888 source image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageVerticalShear_PlanarF">vImageVerticalShear_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Performs a vertical shear operation on a region of interest of a PlanarF source image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageVerticalShear_Planar8">vImageVerticalShear_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Performs a vertical shear operation on a region of interest of a Planar8 source image.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_4" title="Rotating"></a>
    
    <h3 class="tasks">Rotating</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRotate90_ARGBFFFF">vImageRotate90_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Rotates an ARGBFFFF source image by the provided factor of 90.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRotate90_ARGB8888">vImageRotate90_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Rotates an ARGB8888 source image by the provided factor of 90.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRotate90_PlanarF">vImageRotate90_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Rotates a PlanarF source image by the provided factor of 90.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRotate90_Planar8">vImageRotate90_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Rotates a Planar8 source image by the provided factor of 90.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRotate_ARGBFFFF">vImageRotate_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Rotates an ARGBFFFF source image by the provided angle.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRotate_ARGB8888">vImageRotate_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Rotates an ARGB8888 source image by the provided angle.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRotate_PlanarF">vImageRotate_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Rotates a PlanarF source image by the provided angle.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRotate_Planar8">vImageRotate_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Rotates a  Planar8 source image by the provided angle.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005490-CH210-145717" title="Scaling"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-TPXREF108" title="Scaling"></a>
    
    <h3 class="tasks">Scaling</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageScale_ARGBFFFF">vImageScale_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Scales an ARGBFFFF source image to fit a destination buffer.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageScale_ARGB8888">vImageScale_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Scales an ARGB8888 source image to fit a destination buffer.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageScale_PlanarF">vImageScale_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Scales a PlanarF source image to fit a destination buffer.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageScale_Planar8">vImageScale_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Scales a Planar8 source image to fit a destination buffer.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_5" title="Resampling"></a>
    
    <h3 class="tasks">Resampling</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageDestroyResamplingFilter">vImageDestroyResamplingFilter</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Disposes of a resampling filter object.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageGetResamplingFilterSize">vImageGetResamplingFilterSize</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Returns the minimum size, in bytes, for the buffer needed by the function <code>vImageNewResamplingFilterForFunctionUsingBuffer</code>.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Creates a resampling filter object that corresponds to the default kernel supplied by the vImage framework.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Creates a resampling filter object that encapsulates a resampling kernel function that you provide.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_6" title="Getting the Buffer Size"></a>
    
    <h3 class="tasks">Getting the Buffer Size</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageGetMinimumGeometryTempBufferSize">vImageGetMinimumGeometryTempBufferSize</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Returns the minimum size, in bytes, for the temporary buffer needed by a high-level geometry function.&#032;(<font color="red">Deprecated.</font>&#032;Use the <code>kvImageGetTempBufferSize</code> flag with the appropriate geometry function instead of calling this function.)'/>
            </span></li>
    </ul>

<a name="//apple_ref/doc/uid/TP40005490-CH210-222475" title="Functions"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-BBCCEIDH" title="Functions"></a><h2><a name="//apple_ref/doc/uid/TP40005490-CH210-TPXREF102" title="Functions"></a>Functions</h2>                                      <a name="//apple_ref/c/func/vImageAffineWarp_ARGB8888" title="vImageAffineWarp_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageAffineWarp_ARGB8888" title="vImageAffineWarp_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageAffineWarp_ARGB8888" title="vImageAffineWarp_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_12"></a><h3 class="tight">vImageAffineWarp_ARGB8888</h3> <p class="spaceabove">Applies an affine transform to an ARGB8888 source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageAffineWarp_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   const <!--a-->vImage_AffineTransform<!--/a--> *transform,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to transform.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>transform</em></dt> <dd><p>The affine transformation matrix to apply to the source image.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the transform. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps each pixel in the source image <code>[x, y]</code> to a new position <code>[x’, y’]</code> in the destination image by the formula:</p><div class="codesample"><table><tr><td scope="row"><pre>(x', y') = (x, y) * transform<span></span></pre></td></tr></table></div><p> where <code>transform</code> is the 3x3 affine transformation matrix. </p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageAffineWarp_ARGBFFFF" title="vImageAffineWarp_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageAffineWarp_ARGBFFFF" title="vImageAffineWarp_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageAffineWarp_ARGBFFFF" title="vImageAffineWarp_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_13"></a><h3 class="tight">vImageAffineWarp_ARGBFFFF</h3> <p class="spaceabove">Applies an affine transform to an ARGBFFFF source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageAffineWarp_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   const <!--a-->vImage_AffineTransform<!--/a--> *transform,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to transform.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>transform</em></dt> <dd><p>The affine transformation matrix to apply to the source image.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when applying the transform. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>This function maps each pixel in the source image <code>[x, y]</code> to a new position <code>[x’, y’]</code> in the destination image by the formula:</p><div class="codesample"><table><tr><td scope="row"><pre>(x', y') = (x, y) * transform<span></span></pre></td></tr></table></div><p> where <code>transform</code> is the 3x3 affine transformation matrix. </p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageAffineWarp_Planar8" title="vImageAffineWarp_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageAffineWarp_Planar8" title="vImageAffineWarp_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageAffineWarp_Planar8" title="vImageAffineWarp_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_14"></a><h3 class="tight">vImageAffineWarp_Planar8</h3> <p class="spaceabove">Applies an affine transform to a Planar8 source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageAffineWarp_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   const <!--a-->vImage_AffineTransform<!--/a--> *transform,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to transform.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>transform</em></dt> <dd><p>The affine transformation matrix to apply to the source image.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the transform. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps each pixel in the source image <code>[x, y]</code> to a new position <code>[x’, y’]</code> in the destination image by the formula:</p><div class="codesample"><table><tr><td scope="row"><pre>(x', y') = (x, y) * transform<span></span></pre></td></tr></table></div><p> where <code>transform</code> is the 3x3 affine transformation matrix. </p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageAffineWarp_PlanarF" title="vImageAffineWarp_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageAffineWarp_PlanarF" title="vImageAffineWarp_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageAffineWarp_PlanarF" title="vImageAffineWarp_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_15"></a><h3 class="tight">vImageAffineWarp_PlanarF</h3> <p class="spaceabove">Applies an affine transform to a PlanarF source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageAffineWarp_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   const <!--a-->vImage_AffineTransform<!--/a--> *transform,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to transform.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>transform</em></dt> <dd><p>The affine transformation matrix to apply to the source image.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the transform. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps each pixel in the source image <code>[x, y]</code> to a new position <code>[x’, y’]</code> in the destination image by the formula:</p><div class="codesample"><table><tr><td scope="row"><pre>(x', y') = (x, y) * transform<span></span></pre></td></tr></table></div><p> where <code>transform</code> is the 3x3 affine transformation matrix. </p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageDestroyResamplingFilter" title="vImageDestroyResamplingFilter"></a><a name="//apple_ref/doc/c_ref/vImageDestroyResamplingFilter" title="vImageDestroyResamplingFilter"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageDestroyResamplingFilter" title="vImageDestroyResamplingFilter"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_16"></a><h3 class="tight">vImageDestroyResamplingFilter</h3> <p class="spaceabove">Disposes of a resampling filter object.</p> <p class="spaceabove"><pre>
void vImageDestroyResamplingFilter (
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>filter</em></dt> <dd><p>The resampling filter object to dispose of.</p></dd></dl> <h5 class="tight">Discussion</h5> <p>This function deallocates the memory associated with a resampling filter object that was created by calling the function <code><a href="reference.html#//apple_ref/c/func/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code>. Do not directly deallocate this memory yourself.</p> <p>Do not pass this function a resampling filter object created by the function <code><a href="reference.html#//apple_ref/c/func/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code>. You are responsible for deallocating the memory associated with resampling filter objects created by that call yourself.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageNewResamplingFilterForFunctionUsingBuffer" target="_self">vImageNewResamplingFilterForFunctionUsingBuffer</a></code></li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageGetMinimumGeometryTempBufferSize" title="vImageGetMinimumGeometryTempBufferSize"></a><a name="//apple_ref/doc/c_ref/vImageGetMinimumGeometryTempBufferSize" title="vImageGetMinimumGeometryTempBufferSize"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageGetMinimumGeometryTempBufferSize" title="vImageGetMinimumGeometryTempBufferSize"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_17"></a><h3 class="tight">vImageGetMinimumGeometryTempBufferSize</h3> <p class="spaceabove">Returns the minimum size, in bytes, for the temporary buffer needed by a high-level geometry function.&#032;(<strong>Deprecated.</strong>&#032;Use the <code>kvImageGetTempBufferSize</code> flag with the appropriate geometry function instead of calling this function.)</p> <p class="spaceabove"><pre>
size_t vImageGetMinimumGeometryTempBufferSize (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags,
   size_t bytesPerPixel
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that  you plan to pass to the geometry function.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer structure that  you plan to pass to the geometry function. You must set the fields of this structure yourself, and allocate memory for its data.  When you are done with the buffer structure, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The flags that you plan to pass to the geometry function.</p></dd> <dt><em>bytesPerPixel</em></dt> <dd><p>The number of bytes in a pixel. Make sure to pass the value appropriate for the format of the pixel.</p></dd></dl> <h5 class="tight">Return Value</h5> <p>The minimum size, in bytes, of the temporary buffer.</p> <h5 class="tight">Discussion</h5><p>This function does not depend on the <em>data</em> or <em>rowBytes</em> fields of the <em>src</em> or <em>dest</em> parameters; it only uses the <em>height</em> and <em>width</em> fields from those parameters. If the size of the images you are processing stay the same, then the required size of the buffer will also stay the same. More specifically, if, between two calls to <code><a href="reference.html#//apple_ref/doc/c_ref/vImageGetMinimumGeometryTempBufferSize">vImageGetMinimumGeometryTempBufferSize</a></code>, the <code>height</code> and <code>width</code> of the <em>src</em> and <em>dest</em> parameters do not increase, and the and the other parameters remain the same, then the result of the <code><a href="reference.html#//apple_ref/doc/c_ref/vImageGetMinimumGeometryTempBufferSize">vImageGetMinimumGeometryTempBufferSize</a></code> will not increase. This makes it easy to reuse the same temporary buffer when you are processing a number of images of the same size, as in tiling. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li><li class="availability">Deprecated in Mac OS X v10.4.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageGetResamplingFilterSize" title="vImageGetResamplingFilterSize"></a><a name="//apple_ref/doc/c_ref/vImageGetResamplingFilterSize" title="vImageGetResamplingFilterSize"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageGetResamplingFilterSize" title="vImageGetResamplingFilterSize"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_18"></a><h3 class="tight">vImageGetResamplingFilterSize</h3> <p class="spaceabove">Returns the minimum size, in bytes, for the buffer needed by the function <code>vImageNewResamplingFilterForFunctionUsingBuffer</code>.</p> <p class="spaceabove"><pre>
size_t vImageGetResamplingFilterSize (
   const float *xArray,
   float *yArray,
   unsigned long count,
   void *userData
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>scale</em></dt> <dd><p>The scale factor that you plan to pass to the function <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code>.</p></dd> <dt><em>kernelFunc</em></dt> <dd><p>The function pointer that you plan to pass to the function <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code>.</p></dd> <dt><em>userData</em></dt> <dd><p>The user data pointer that you plan to pass to the function <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code>.</p></dd> <dt><em>kernelWidth</em></dt> <dd><p>The kernel width that you plan to pass to the function <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code>.</p></dd> <dt><em>flags</em></dt> <dd><p>The flags that you plan to pass to the function <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code>.</p></dd></dl> <h5 class="tight">Return Value</h5> <p>The minimum size, in bytes, of the buffer.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageHorizontalReflect_ARGB8888" title="vImageHorizontalReflect_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageHorizontalReflect_ARGB8888" title="vImageHorizontalReflect_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageHorizontalReflect_ARGB8888" title="vImageHorizontalReflect_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_19"></a><h3 class="tight">vImageHorizontalReflect_ARGB8888</h3> <p class="spaceabove">Reflects an ARGB8888 source image left to right across the center vertical line of the image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageHorizontalReflect_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to reflect.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the reflection. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function does not scale or resample. The source and destination buffers must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageHorizontalReflect_ARGBFFFF" title="vImageHorizontalReflect_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageHorizontalReflect_ARGBFFFF" title="vImageHorizontalReflect_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageHorizontalReflect_ARGBFFFF" title="vImageHorizontalReflect_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_20"></a><h3 class="tight">vImageHorizontalReflect_ARGBFFFF</h3> <p class="spaceabove">Reflects an ARGBFFFF source image left to right across the center vertical line of the image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageHorizontalReflect_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to reflect.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the reflection. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>This function does not scale or resample. The source and destination buffers must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageHorizontalReflect_Planar8" title="vImageHorizontalReflect_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageHorizontalReflect_Planar8" title="vImageHorizontalReflect_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageHorizontalReflect_Planar8" title="vImageHorizontalReflect_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_21"></a><h3 class="tight">vImageHorizontalReflect_Planar8</h3> <p class="spaceabove">Reflects a Planar9 source image left to right across the center vertical line of the image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageHorizontalReflect_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to reflect.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the reflection. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function does not scale or resample. The source and destination buffers must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageHorizontalReflect_PlanarF" title="vImageHorizontalReflect_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageHorizontalReflect_PlanarF" title="vImageHorizontalReflect_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageHorizontalReflect_PlanarF" title="vImageHorizontalReflect_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_22"></a><h3 class="tight">vImageHorizontalReflect_PlanarF</h3> <p class="spaceabove">Reflects a PlanarF source image left to right across the center vertical line of the image, placing the result in a destination buffer. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageHorizontalReflect_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to reflect.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the reflection. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function does not scale or resample. The source and destination buffers must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageHorizontalShear_ARGB8888" title="vImageHorizontalShear_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageHorizontalShear_ARGB8888" title="vImageHorizontalShear_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageHorizontalShear_ARGB8888" title="vImageHorizontalShear_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_23"></a><h3 class="tight">vImageHorizontalShear_ARGB8888</h3> <p class="spaceabove">Performs a horizontal shear operation on a region of interest of an ARGB8888 source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageHorizontalShear_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   float xTranslate,
   float shearSlope,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to shear.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>This parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width as the destination image buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>xTranslate</em></dt> <dd><p>A translation value for the horizontal direction.</p></dd> <dt><em>shearSlope</em></dt> <dd><p>The slope of the front edge of the sheared image, measured in a clockwise direction.</p></dd> <dt><em>filter</em></dt> <dd><p>The resampling filter to be used with this function. You create this object by calling <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code> (to use a default resampling filter supplied by vImage) or <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code> (to use a custom resampling filter that you supply). When the resampling filter is created, you can also set a scale factor that will be used in the horizontal shear operation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the shear. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code> flags are mutually exclusive. You must set exactly one of these flags.  </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function also translates and scales the image, both in the horizontal direction. The function transforms as much of the source image as it needs in order to attempt to fill the destination buffer, which means it can transform pixels outside the region of interest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageHorizontalShear_ARGBFFFF" title="vImageHorizontalShear_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageHorizontalShear_ARGBFFFF" title="vImageHorizontalShear_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageHorizontalShear_ARGBFFFF" title="vImageHorizontalShear_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_24"></a><h3 class="tight">vImageHorizontalShear_ARGBFFFF</h3> <p class="spaceabove">Performs a horizontal shear operation on a region of interest of an ARGBFFFF source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageHorizontalShear_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   float xTranslate,
   float shearSlope,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to shear.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>This parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width as the destination image buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>xTranslate</em></dt> <dd><p>A translation value for the horizontal direction.</p></dd> <dt><em>shearSlope</em></dt> <dd><p>The slope of the front edge of the sheared image, measured in a clockwise direction.</p></dd> <dt><em>filter</em></dt> <dd><p>The resampling filter to be used with this function. You create this object by calling <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code> (to use a default resampling filter supplied by vImage) or <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code> (to use a custom resampling filter that you supply). When the resampling filter is created, you can also set a scale factor that will be used in the horizontal shear operation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the shear. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading.</p><p>The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code> flags are mutually exclusive. You must set exactly one of these flags.  </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>This function also translates and scales the image, both in the horizontal direction. The function transforms as much of the source image as it needs in order to attempt to fill the destination buffer, which means it can transform pixels outside the region of interest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageHorizontalShear_Planar8" title="vImageHorizontalShear_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageHorizontalShear_Planar8" title="vImageHorizontalShear_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageHorizontalShear_Planar8" title="vImageHorizontalShear_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_25"></a><h3 class="tight">vImageHorizontalShear_Planar8</h3> <p class="spaceabove">Performs a horizontal shear operation on a region of interest of a Planar8 source image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageHorizontalShear_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   float xTranslate,
   float shearSlope,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to shear.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>This parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width as the destination image buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>xTranslate</em></dt> <dd><p>A translation value for the horizontal direction.</p></dd> <dt><em>shearSlope</em></dt> <dd><p>The slope of the front edge of the sheared image, measured in a clockwise direction.</p></dd> <dt><em>filter</em></dt> <dd><p>The resampling filter to be used with this function. You create this object by calling <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code> (to use a default resampling filter supplied by vImage) or <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code> (to use a custom resampling filter that you supply). When the resampling filter is created, you can also set a scale factor that will be used in the horizontal shear operation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the shear. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code> flags are mutually exclusive. You must set exactly one of these flags.  </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function also translates and scales the image, both in the horizontal direction. The function transforms as much of the source image as it needs in order to attempt to fill the destination buffer, which means it can transform pixels outside the region of interest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageHorizontalShear_PlanarF" title="vImageHorizontalShear_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageHorizontalShear_PlanarF" title="vImageHorizontalShear_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageHorizontalShear_PlanarF" title="vImageHorizontalShear_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_26"></a><h3 class="tight">vImageHorizontalShear_PlanarF</h3> <p class="spaceabove">Performs a horizontal shear operation on a region of interest of a PlanarF source image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageHorizontalShear_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   float xTranslate,
   float shearSlope,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to shear.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>This parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width as the destination image buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>xTranslate</em></dt> <dd><p>A translation value for the horizontal direction.</p></dd> <dt><em>shearSlope</em></dt> <dd><p>The slope of the front edge of the sheared image, measured in a clockwise direction.</p></dd> <dt><em>filter</em></dt> <dd><p>The resampling filter to be used with this function. You create this object by calling <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code> (to use a default resampling filter supplied by vImage) or <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code> (to use a custom resampling filter that you supply). When the resampling filter is created, you can also set a scale factor that will be used in the horizontal shear operation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the shear. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code> flags are mutually exclusive. You must set exactly one of these flags.  </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function also translates and scales the image, both in the horizontal direction. The function transforms as much of the source image as it needs in order to attempt to fill the destination buffer, which means it can transform pixels outside the region of interest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageNewResamplingFilter" title="vImageNewResamplingFilter"></a><a name="//apple_ref/doc/c_ref/vImageNewResamplingFilter" title="vImageNewResamplingFilter"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageNewResamplingFilter" title="vImageNewResamplingFilter"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_27"></a><h3 class="tight">vImageNewResamplingFilter</h3> <p class="spaceabove">Creates a resampling filter object that corresponds to the default kernel supplied by the vImage framework.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> vImageNewResamplingFilter (
   float scale,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>scale</em></dt> <dd><p>A scale factor to associated with the resampling filter object. Shear functions to which you pass the resampling filter object use this factor when performing a shear operation. The shear function applies the scale factor  to the entire image, in a direction appropriate to the shear function, either horizontal or vertical. </p></dd> <dt><em>flags</em></dt><dd><p>The options to use when creating the resampling filter object. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5> <p>A pointer to a newly created resampling filter object; otherwise <code>NULL</code>.  </p> <h5 class="tight">Discussion</h5> <p>This function creates a reusable resampling filter object  that you can pass to a shear function. The resampling filter encapsulated by the object is the default kernel for vImage This function allocates the memory needed for the resampling filter object. To deallocate this memory, call the function <code><a href="reference.html#//apple_ref/c/func/vImageDestroyResamplingFilter">vImageDestroyResamplingFilter</a></code>. Do not attempt to deallocate the memory yourself.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageNewResamplingFilterForFunctionUsingBuffer" target="_self">vImageNewResamplingFilterForFunctionUsingBuffer</a></code></li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageNewResamplingFilterForFunctionUsingBuffer" title="vImageNewResamplingFilterForFunctionUsingBuffer"></a><a name="//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer" title="vImageNewResamplingFilterForFunctionUsingBuffer"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageNewResamplingFilterForFunctionUsingBuffer" title="vImageNewResamplingFilterForFunctionUsingBuffer"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_28"></a><h3 class="tight">vImageNewResamplingFilterForFunctionUsingBuffer</h3> <p class="spaceabove">Creates a resampling filter object that encapsulates a resampling kernel function that you provide.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageNewResamplingFilterForFunctionUsingBuffer (
   const float *xArray,
   float *yArray,
   unsigned long count,
   void *userData
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>filter</em></dt> <dd><p>A pointer to a buffer. On return, the buffer contains a resampling filter object. You must allocate the memory for this buffer yourself. Call the function <code><a href="reference.html#//apple_ref/c/func/vImageGetResamplingFilterSize">vImageGetResamplingFilterSize</a></code>  to obtain the size of this buffer. </p></dd> <dt><em>scale</em></dt> <dd><p>A scale factor to associated with the resampling filter object. Shear functions to which you pass the resampling filter object use this factor when performing a shear operation. The shear function applies the scale factor  to the entire image, in a direction appropriate to the shear function, either horizontal or vertical. </p></dd> <dt><em>kernelFunc</em></dt> <dd><p>A pointer to your custom resampling kernel function. If this pointer is <code>NULL</code>, vImage creates a resampling filter object that corresponds to its default kernel. The kernel function must remain valid for the life of the resampling filter object.</p><p>If you need precise control over the memory used for a resampling filter object  but want to use the default, pass <code>NULL</code> as the <code>kernelFunc</code> parameter. This causes vImage to create a resampling filter object that corresponds to its default kernel. You can then determine where in memory the resampling filter object is located. You can reuse the buffer to reduce memory allocation, and so on. Note that a resampling filter object created in this way is not necessarily the same as one created by the function <code><a href="reference.html#//apple_ref/c/func/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code>. You must still  deallocate the object yourself; you can not pass it to the function <code><a href="reference.html#//apple_ref/c/func/vImageDestroyResamplingFilter">vImageDestroyResamplingFilter</a></code>.</p></dd> <dt><em>kernelWidth</em></dt> <dd><p>A bounding value for the domain of your resampling kernel function. When your function is called, the x-values it will be passed will lie between –<em>kernelWidth</em> and +<em>kernelWidth</em>, inclusive.</p></dd> <dt><em>userData</em></dt> <dd><p>A pointer to custom data that you want to use when calculating your resampling kernel function. When vImage invokes your resampling kernel function, this pointer is passed to the function. The data can be anything you want to use in calculating your resampling kernel function—a table, a list of pointers to related functions, or so on. The data must remain valid for the life of the resampling kernel object. </p><p>If your resampling kernel function does nor require user data, pass <code>NULL</code>.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when creating the resampling filter object. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function creates a reusable resampling filter object  that you can pass to a shear function. Before calling this function, you must allocate a buffer to contain the resampling filter object returned by this function. You can get the necessary size by calling the function <code><a href="reference.html#//apple_ref/c/func/vImageGetResamplingFilterSize">vImageGetResamplingFilterSize</a></code>. When you no longer need this object, you are responsible for deallocating its memory. (Do not use the function <code><a href="reference.html#//apple_ref/c/func/vImageDestroyResamplingFilter">vImageDestroyResamplingFilter</a></code> to deallocate custom resampling filter objects; it is not designed to deallocate them.)</p><p>If you need precise control over the memory used for a resampling filter object  but want to use the default, pass <code>NULL</code> as the <code>kernelFunc</code> parameter. This causes vImage to create a resampling filter object that corresponds to its default kernel. You can then determine where in memory the resampling filter object is located. You can reuse the buffer to reduce memory allocation, and so on. Note that a resampling filter object created in this way is not necessarily the same as one created by the function <code><a href="reference.html#//apple_ref/c/func/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code>. You must still  deallocate the object yourself; you can not pass it to the function <code><a href="reference.html#//apple_ref/c/func/vImageDestroyResamplingFilter">vImageDestroyResamplingFilter</a></code>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageRotate90_ARGB8888" title="vImageRotate90_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageRotate90_ARGB8888" title="vImageRotate90_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageRotate90_ARGB8888" title="vImageRotate90_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_29"></a><h3 class="tight">vImageRotate90_ARGB8888</h3> <p class="spaceabove">Rotates an ARGB8888 source image by the provided factor of 90.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRotate90_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t rotationConstant,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to rotate.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>rotationConstant</em></dt> <dd><p>A value specifying the angle of rotation. </p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the rotation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps the center point of the source image to the center point of the destination image. It does not scale or resample, instead, the function copies individual pixels unchanged to new locations.</p><p>This function places certain restrictions on the pixel height and widths of the source and destination buffers, so that it can map the center of the source to the center of the destination precisely. The restrictions are:</p><ul class="ul"><li class="li"><p>If you are rotating the image 90 or 270 degrees, the height of the source image and the width of the destination image must both be even or both be odd; and the width of the source image and the height of the destination image must both be even or both be odd.</p></li></ul><p>If your images do not meet these restrictions, you can use the general (high-level) Rotate function instead, with an angle of 90 or 270 degrees.</p><p>Depending on the relative sizes of the source image and the destination buffer, parts of the source image may be clipped. Areas outside the source image may appear in the destination image the background color passed to the function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageRotate90_ARGBFFFF" title="vImageRotate90_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageRotate90_ARGBFFFF" title="vImageRotate90_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageRotate90_ARGBFFFF" title="vImageRotate90_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_30"></a><h3 class="tight">vImageRotate90_ARGBFFFF</h3> <p class="spaceabove">Rotates an ARGBFFFF source image by the provided factor of 90.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRotate90_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t rotationConstant,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to rotate.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>rotationConstant</em></dt> <dd><p>A value specifying the angle of rotation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the rotation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>This function maps the center point of the source image to the center point of the destination image. It does not scale or resample, instead, the function copies individual pixels unchanged to new locations.</p><p>This function places certain restrictions on the pixel height and widths of the source and destination buffers, so that it can map the center of the source to the center of the destination precisely. The restrictions are:</p><ul class="ul"><li class="li"><p>If you are rotating the image 90 or 270 degrees, the height of the source image and the width of the destination image must both be even or both be odd; and the width of the source image and the height of the destination image must both be even or both be odd.</p></li></ul> <p>If your images do not meet these restrictions, you can use the general (high-level) Rotate function instead, with an angle of 90 or 270 degrees.</p> <p>Depending on the relative sizes of the source image and the destination buffer, parts of the source image may be clipped. Areas outside the source image may appear in the destination image the background color passed to the function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageRotate90_Planar8" title="vImageRotate90_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageRotate90_Planar8" title="vImageRotate90_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageRotate90_Planar8" title="vImageRotate90_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_31"></a><h3 class="tight">vImageRotate90_Planar8</h3> <p class="spaceabove">Rotates a Planar8 source image by the provided factor of 90.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRotate90_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t rotationConstant,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to rotate.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>rotationConstant</em></dt> <dd><p>A value specifying the angle of rotation. </p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the rotation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps the center point of the source image to the center point of the destination image. It does not scale or resample, instead, the function copies individual pixels unchanged to new locations.</p><p>This function places certain restrictions on the pixel height and widths of the source and destination buffers, so that it can map the center of the source to the center of the destination precisely. The restrictions are:</p><ul class="ul"><li class="li"><p>If you are rotating the image 90 or 270 degrees, the height of the source image and the width of the destination image must both be even or both be odd; and the width of the source image and the height of the destination image must both be even or both be odd.</p></li></ul><p>If your images do not meet these restrictions, you can use the general (high-level) Rotate function instead, with an angle of 90 or 270 degrees.</p><p>Depending on the relative sizes of the source image and the destination buffer, parts of the source image may be clipped. Areas outside the source image may appear in the destination image the background color passed to the function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageRotate90_PlanarF" title="vImageRotate90_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageRotate90_PlanarF" title="vImageRotate90_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageRotate90_PlanarF" title="vImageRotate90_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_32"></a><h3 class="tight">vImageRotate90_PlanarF</h3> <p class="spaceabove">Rotates a PlanarF source image by the provided factor of 90.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRotate90_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint8_t rotationConstant,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to rotate.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>rotationConstant</em></dt> <dd><p>A value specifying the angle of rotation. </p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the rotation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps the center point of the source image to the center point of the destination image. It does not scale or resample, instead, the function copies individual pixels unchanged to new locations.</p><p>This function places certain restrictions on the pixel height and widths of the source and destination buffers, so that it can map the center of the source to the center of the destination precisely. The restrictions are:</p><ul class="ul"><li class="li"><p>If you are rotating the image 90 or 270 degrees, the height of the source image and the width of the destination image must both be even or both be odd; and the width of the source image and the height of the destination image must both be even or both be odd.</p></li></ul><p>If your images do not meet these restrictions, you can use the general (high-level) Rotate function instead, with an angle of 90 or 270 degrees.</p><p>Depending on the relative sizes of the source image and the destination buffer, parts of the source image may be clipped. Areas outside the source image may appear in the destination image the background color passed to the function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageRotate_ARGB8888" title="vImageRotate_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageRotate_ARGB8888" title="vImageRotate_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageRotate_ARGB8888" title="vImageRotate_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_33"></a><h3 class="tight">vImageRotate_ARGB8888</h3> <p class="spaceabove">Rotates an ARGB8888 source image by the provided angle.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRotate_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   float angleInRadians,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to rotate.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>angleInRadians</em></dt> <dd><p>The angle of rotation, in radians.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code>kvImageBackgroundColorFill</code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the rotation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps the center point of the source image to the center point of the destination image. It does not scale, but it resamples. Depending on the relative sizes of the source image and the destination buffer, parts of the source image may be clipped. Areas outside the source image may appear in the destination image the background color passed to the function.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageRotate_ARGBFFFF" title="vImageRotate_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageRotate_ARGBFFFF" title="vImageRotate_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageRotate_ARGBFFFF" title="vImageRotate_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_34"></a><h3 class="tight">vImageRotate_ARGBFFFF</h3> <p class="spaceabove">Rotates an ARGBFFFF source image by the provided angle.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRotate_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   float angleInRadians,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to rotate.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>angleInRadians</em></dt> <dd><p>The angle of rotation, in radians.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code>kvImageBackgroundColorFill</code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the rotation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps the center point of the source image to the center point of the destination image. It does not scale, but it resamples. Depending on the relative sizes of the source image and the destination buffer, parts of the source image may be clipped. Areas outside the source image may appear in the destination image the background color passed to the function.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageRotate_Planar8" title="vImageRotate_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageRotate_Planar8" title="vImageRotate_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageRotate_Planar8" title="vImageRotate_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_35"></a><h3 class="tight">vImageRotate_Planar8</h3> <p class="spaceabove">Rotates a  Planar8 source image by the provided angle.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRotate_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   float angleInRadians,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to rotate.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>angleInRadians</em></dt> <dd><p>The angle of rotation, in radians.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code>kvImageBackgroundColorFill</code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the rotation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps the center point of the source image to the center point of the destination image. It does not scale, but it resamples. Depending on the relative sizes of the source image and the destination buffer, parts of the source image may be clipped. Areas outside the source image may appear in the destination image the background color passed to the function.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageRotate_PlanarF" title="vImageRotate_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageRotate_PlanarF" title="vImageRotate_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageRotate_PlanarF" title="vImageRotate_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_36"></a><h3 class="tight">vImageRotate_PlanarF</h3> <p class="spaceabove">Rotates a PlanarF source image by the provided angle.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRotate_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   float angleInRadians,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to rotate.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>angleInRadians</em></dt> <dd><p>The angle of rotation, in radians.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code>kvImageBackgroundColorFill</code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the rotation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function maps the center point of the source image to the center point of the destination image. It does not scale, but it resamples. Depending on the relative sizes of the source image and the destination buffer, parts of the source image may be clipped. Areas outside the source image may appear in the destination image the background color passed to the function.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageScale_ARGB8888" title="vImageScale_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageScale_ARGB8888" title="vImageScale_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageScale_ARGB8888" title="vImageScale_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_37"></a><h3 class="tight">vImageScale_ARGB8888</h3> <p class="spaceabove">Scales an ARGB8888 source image to fit a destination buffer.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageScale_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image whose data you want to scale.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the scaling. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag. The function uses edge extend (see <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/c/econst/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>) to assign values to pixels that are outside the source buffer. Edge extend prevents a background color from impinging on the edges of the scaled image.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The relative size of the source image and the destination buffer determine the scaling factors, which may be different in the X and Y directions.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageScale_ARGBFFFF" title="vImageScale_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageScale_ARGBFFFF" title="vImageScale_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageScale_ARGBFFFF" title="vImageScale_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_38"></a><h3 class="tight">vImageScale_ARGBFFFF</h3> <p class="spaceabove">Scales an ARGBFFFF source image to fit a destination buffer.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageScale_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to scale.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the scaling. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The relative size of the source image and the destination buffer determine the scaling factors, which may be different in the X and Y directions.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageScale_Planar8" title="vImageScale_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageScale_Planar8" title="vImageScale_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageScale_Planar8" title="vImageScale_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_39"></a><h3 class="tight">vImageScale_Planar8</h3> <p class="spaceabove">Scales a Planar8 source image to fit a destination buffer.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageScale_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image whose data you want to scale.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the scaling. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter.</p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag. The function uses edge extend (see <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/c/econst/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>) to assign values to pixels that are outside the source buffer. Edge extend prevents a background color from impinging on the edges of the scaled image.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The relative size of the source image and the destination buffer determine the scaling factors, which may be different in the X and Y directions.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageScale_PlanarF" title="vImageScale_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageScale_PlanarF" title="vImageScale_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageScale_PlanarF" title="vImageScale_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_40"></a><h3 class="tight">vImageScale_PlanarF</h3> <p class="spaceabove">Scales a PlanarF source image to fit a destination buffer.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageScale_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image whose data you want to scale.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when applying the scaling. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter.</p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>This function ignores the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag. The function uses edge extend (see <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/c/econst/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>) to assign values to pixels that are outside the source buffer. Edge extend prevents a background color from impinging on the edges of the scaled image.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The relative size of the source image and the destination buffer determine the scaling factors, which may be different in the X and Y directions.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageVerticalReflect_ARGB8888" title="vImageVerticalReflect_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageVerticalReflect_ARGB8888" title="vImageVerticalReflect_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageVerticalReflect_ARGB8888" title="vImageVerticalReflect_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_41"></a><h3 class="tight">vImageVerticalReflect_ARGB8888</h3> <p class="spaceabove">Reflects an ARGBFFFF source image top to bottom across the center vertical line of the image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageVerticalReflect_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to reflect.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the reflection. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The resulting image appears upside down, as if seen from the back of the image.</p><p>This function does not scale or resample. The source and destination buffers must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Related Sample Code</h5><ul class="availability"><li class="availability">  <span class="content_text"><a href="../../../../../samplecode/QTCoreVideo103/index.html#//apple_ref/doc/uid/DTS40007782" target="_top">QTCoreVideo103</a></span></li><li class="availability">  <span class="content_text"><a href="../../../../../samplecode/QTCoreVideo202/index.html#//apple_ref/doc/uid/DTS40007786" target="_top">QTCoreVideo202</a></span></li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageVerticalReflect_ARGBFFFF" title="vImageVerticalReflect_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageVerticalReflect_ARGBFFFF" title="vImageVerticalReflect_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageVerticalReflect_ARGBFFFF" title="vImageVerticalReflect_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_42"></a><h3 class="tight">vImageVerticalReflect_ARGBFFFF</h3> <p class="spaceabove">Reflects an ARGBFFFF source image top to bottom across the center vertical line of the image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageVerticalReflect_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to reflect.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the reflection. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The resulting image appears upside down, as if seen from the back of the image.</p><p>This function does not scale or resample. The source and destination buffers must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageVerticalReflect_Planar8" title="vImageVerticalReflect_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageVerticalReflect_Planar8" title="vImageVerticalReflect_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageVerticalReflect_Planar8" title="vImageVerticalReflect_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_43"></a><h3 class="tight">vImageVerticalReflect_Planar8</h3> <p class="spaceabove">Reflects a Planar 8 source image top to bottom across the center vertical line of the image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageVerticalReflect_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to reflect.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the reflection. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The resulting image appears upside down, as if seen from the back of the image.</p><p>This function does not scale or resample. The source and destination buffers must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageVerticalReflect_PlanarF" title="vImageVerticalReflect_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageVerticalReflect_PlanarF" title="vImageVerticalReflect_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageVerticalReflect_PlanarF" title="vImageVerticalReflect_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_44"></a><h3 class="tight">vImageVerticalReflect_PlanarF</h3> <p class="spaceabove">Reflects a PlanarF source image top to bottom across the center vertical line of the image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageVerticalReflect_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a structure of type <code>vImage_Buffer</code> containing the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the reflection. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The resulting image appears upside down, as if seen from the back of the image.</p><p>This function does not scale or resample. The source and destination buffers must have the same height and the same width.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageVerticalShear_ARGB8888" title="vImageVerticalShear_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageVerticalShear_ARGB8888" title="vImageVerticalShear_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageVerticalShear_ARGB8888" title="vImageVerticalShear_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_45"></a><h3 class="tight">vImageVerticalShear_ARGB8888</h3> <p class="spaceabove">Performs a vertical shear operation on a region of interest of an ARGB8888 source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageVerticalShear_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   float yTranslate,
   float shearSlope,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to shear.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>This parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width as the destination image buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>yTranslate</em></dt> <dd><p>A translation value for the vertical direction.</p></dd> <dt><em>shearSlope</em></dt> <dd><p>The slope of the top edge of the sheared image, measured in a clockwise direction.</p></dd> <dt><em>filter</em></dt> <dd><p>The resampling filter to be used with this function. You create this object by calling <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code> (to use a default resampling filter supplied by vImage) or <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code> (to use a custom resampling filter that you supply). When the resampling filter is created, you can also set a scale factor that will be used in the horizontal shear operation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the shear. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code> flags are mutually exclusive. You must set exactly one of these flags.  </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function also translates and scales the image, both in the vertical direction. The function transforms as much of the source image as it needs in order to attempt to fill the destination buffer, which means it can transform pixels outside the region of interest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageVerticalShear_ARGBFFFF" title="vImageVerticalShear_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageVerticalShear_ARGBFFFF" title="vImageVerticalShear_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageVerticalShear_ARGBFFFF" title="vImageVerticalShear_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_46"></a><h3 class="tight">vImageVerticalShear_ARGBFFFF</h3> <p class="spaceabove">Performs a vertical shear operation on a region of interest of an ARGBFFFF source image. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageVerticalShear_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   float yTranslate,
   float shearSlope,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to shear.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>This parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width as the destination image buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>yTranslate</em></dt> <dd><p>A translation value for the vertical direction.</p></dd> <dt><em>shearSlope</em></dt> <dd><p>The slope of the top edge of the sheared image, measured in a clockwise direction.</p></dd> <dt><em>filter</em></dt> <dd><p>The resampling filter to be used with this function. You create this object by calling <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code> (to use a default resampling filter supplied by vImage) or <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code> (to use a custom resampling filter that you supply). When the resampling filter is created, you can also set a scale factor that will be used in the horizontal shear operation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the shear. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code> flags are mutually exclusive. You must set exactly one of these flags.  </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function also translates and scales the image, both in the vertical direction. The function transforms as much of the source image as it needs in order to attempt to fill the destination buffer, which means it can transform pixels outside the region of interest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageVerticalShear_Planar8" title="vImageVerticalShear_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageVerticalShear_Planar8" title="vImageVerticalShear_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageVerticalShear_Planar8" title="vImageVerticalShear_Planar8"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_47"></a><h3 class="tight">vImageVerticalShear_Planar8</h3> <p class="spaceabove">Performs a vertical shear operation on a region of interest of a Planar8 source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageVerticalShear_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   float yTranslate,
   float shearSlope,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to shear.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>This parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width as the destination image buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>yTranslate</em></dt> <dd><p>A translation value for the vertical direction.</p></dd> <dt><em>shearSlope</em></dt> <dd><p>The slope of the top edge of the sheared image, measured in a clockwise direction.</p></dd> <dt><em>filter</em></dt> <dd><p>The resampling filter to be used with this function. You create this object by calling <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code> (to use a default resampling filter supplied by vImage) or <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code> (to use a custom resampling filter that you supply). When the resampling filter is created, you can also set a scale factor that will be used in the horizontal shear operation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the shear. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code> flags are mutually exclusive. You must set exactly one of these flags.  </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function also translates and scales the image, both in the vertical direction. The function transforms as much of the source image as it needs in order to attempt to fill the destination buffer, which means it can transform pixels outside the region of interest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/c/func/vImageVerticalShear_PlanarF" title="vImageVerticalShear_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageVerticalShear_PlanarF" title="vImageVerticalShear_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-vImageVerticalShear_PlanarF" title="vImageVerticalShear_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005490-CH210-DontLinkElementID_48"></a><h3 class="tight">vImageVerticalShear_PlanarF</h3> <p class="spaceabove">Performs a vertical shear operation on a region of interest of a PlanarF source image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageVerticalShear_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   float yTranslate,
   float shearSlope,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/ResamplingFilter" target="_top">ResamplingFilter</a> filter,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> backColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image whose data you want to shear.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>This parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width as the destination image buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>yTranslate</em></dt> <dd><p>A translation value for the vertical direction.</p></dd> <dt><em>shearSlope</em></dt> <dd><p>The slope of the top edge of the sheared image, measured in a clockwise direction.</p></dd> <dt><em>filter</em></dt> <dd><p>The resampling filter to be used with this function. You create this object by calling <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilter">vImageNewResamplingFilter</a></code> (to use a default resampling filter supplied by vImage) or <code><a href="reference.html#//apple_ref/doc/c_ref/vImageNewResamplingFilterForFunctionUsingBuffer">vImageNewResamplingFilterForFunctionUsingBuffer</a></code> (to use a custom resampling filter that you supply). When the resampling filter is created, you can also set a scale factor that will be used in the horizontal shear operation.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. Pass a pixel value only if you also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag.</p></dd> <dt><em>flags</em></dt><dd><p>The options to use when performing the shear. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:   <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageHighQualityResampling" target="_top">kvImageHighQualityResampling</a></code> flag if you want vImage to use a higher quality, but slower, resampling filter. </p><p>Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. </p><p>The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code> flags are mutually exclusive. You must set exactly one of these flags.  </p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function also translates and scales the image, both in the vertical direction. The function transforms as much of the source image as it needs in order to attempt to fill the destination buffer, which means it can transform pixels outside the region of interest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Geometry.h</code><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_9" title="Constants"></a><h2>Constants</h2><a name="//apple_ref/doc/constant_group/Rotation_Constants" title="Rotation Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-RotationConstantsforUseWithRotate90Function" title="Rotation Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_49"></a><h3 class="tight">Rotation Constants</h3><p class="spaceabove">The number of degrees in the clockwise direction.</p><p class="spaceabove"><pre>
enum
{
   <a href="reference.html#//apple_ref/doc/c_ref/kRotate0DegreesClockwise">kRotate0DegreesClockwise</a>        = 0,
   <a href="reference.html#//apple_ref/doc/c_ref/kRotate90DegreesClockwise">kRotate90DegreesClockwise</a>       = 3,
   <a href="reference.html#//apple_ref/doc/c_ref/kRotate180DegreesClockwise">kRotate180DegreesClockwise</a>      = 2,
   <a href="reference.html#//apple_ref/doc/c_ref/kRotate270DegreesClockwise">kRotate270DegreesClockwise</a>      = 1
   <a href="reference.html#//apple_ref/doc/c_ref/kRotate0DegreesCounterClockwise">kRotate0DegreesCounterClockwise</a> = 0,
   <a href="reference.html#//apple_ref/doc/c_ref/kRotate90DegreesCounterClockwise">kRotate90DegreesCounterClockwise</a>= 1,
   <a href="reference.html#//apple_ref/doc/c_ref/kRotate180DegreesCounterClockwise">kRotate180DegreesCounterClockwise</a>= 2,
   <a href="reference.html#//apple_ref/doc/c_ref/kRotate270DegreesCounterClockwise">kRotate270DegreesCounterClockwise</a>= 3
};
</pre></p><h5 class="tight">Constants</h5><dl class="termdef"><a name="//apple_ref/c/econst/kRotate0DegreesClockwise" title="kRotate0DegreesClockwise"></a><a name="//apple_ref/doc/c_ref/kRotate0DegreesClockwise" title="kRotate0DegreesClockwise"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_50"></a><dt><code>kRotate0DegreesClockwise</code></dt><dd><p>Rotate 0 degrees (that is, copy without rotating).</p><p>Available in Mac OS X v10.3 and later.</p><p>Declared in <code>Geometry.h</code>.</p></dd><a name="//apple_ref/c/econst/kRotate90DegreesClockwise" title="kRotate90DegreesClockwise"></a><a name="//apple_ref/doc/c_ref/kRotate90DegreesClockwise" title="kRotate90DegreesClockwise"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_51"></a><dt><code>kRotate90DegreesClockwise</code></dt><dd><p>Rotate 90 degrees clockwise.</p><p>Available in Mac OS X v10.3 and later.</p><p>Declared in <code>Geometry.h</code>.</p></dd><a name="//apple_ref/c/econst/kRotate180DegreesClockwise" title="kRotate180DegreesClockwise"></a><a name="//apple_ref/doc/c_ref/kRotate180DegreesClockwise" title="kRotate180DegreesClockwise"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_52"></a><dt><code>kRotate180DegreesClockwise</code></dt><dd><p>Rotate 180 degrees clockwise.</p><p>Available in Mac OS X v10.3 and later.</p><p>Declared in <code>Geometry.h</code>.</p></dd><a name="//apple_ref/c/econst/kRotate270DegreesClockwise" title="kRotate270DegreesClockwise"></a><a name="//apple_ref/doc/c_ref/kRotate270DegreesClockwise" title="kRotate270DegreesClockwise"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_53"></a><dt><code>kRotate270DegreesClockwise</code></dt><dd><p>Rotate 270 degrees clockwise.</p><p>Available in Mac OS X v10.3 and later.</p><p>Declared in <code>Geometry.h</code>.</p></dd><a name="//apple_ref/c/econst/kRotate0DegreesCounterClockwise" title="kRotate0DegreesCounterClockwise"></a><a name="//apple_ref/doc/c_ref/kRotate0DegreesCounterClockwise" title="kRotate0DegreesCounterClockwise"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_54"></a><dt><code>kRotate0DegreesCounterClockwise</code></dt><dd><p>Rotate 0 degrees (that is, copy without rotating).</p><p>Available in Mac OS X v10.3 and later.</p><p>Declared in <code>Geometry.h</code>.</p></dd><a name="//apple_ref/c/econst/kRotate90DegreesCounterClockwise" title="kRotate90DegreesCounterClockwise"></a><a name="//apple_ref/doc/c_ref/kRotate90DegreesCounterClockwise" title="kRotate90DegreesCounterClockwise"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_55"></a><dt><code>kRotate90DegreesCounterClockwise</code></dt><dd><p>Rotate 90 degrees counter-clockwise.</p><p>Available in Mac OS X v10.3 and later.</p><p>Declared in <code>Geometry.h</code>.</p></dd><a name="//apple_ref/c/econst/kRotate180DegreesCounterClockwise" title="kRotate180DegreesCounterClockwise"></a><a name="//apple_ref/doc/c_ref/kRotate180DegreesCounterClockwise" title="kRotate180DegreesCounterClockwise"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_56"></a><dt><code>kRotate180DegreesCounterClockwise</code></dt><dd><p>Rotate 180 degrees counter-clockwise.</p><p>Available in Mac OS X v10.3 and later.</p><p>Declared in <code>Geometry.h</code>.</p></dd><a name="//apple_ref/c/econst/kRotate270DegreesCounterClockwise" title="kRotate270DegreesCounterClockwise"></a><a name="//apple_ref/doc/c_ref/kRotate270DegreesCounterClockwise" title="kRotate270DegreesCounterClockwise"></a><a name="//apple_ref/doc/uid/TP40005490-CH211-DontLinkElementID_57"></a><dt><code>kRotate270DegreesCounterClockwise</code></dt><dd><p>Rotate 270 degrees counter-clockwise.</p><p>Available in Mac OS X v10.3 and later.</p><p>Declared in <code>Geometry.h</code>.</p></dd></dl><h5 class="tight">Declared In</h5><code>Geometry.h</code>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-12<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Reference/vImage_geometric/Reference/reference.html%3Fid%3DTP40005490-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Reference/vImage_geometric/Reference/reference.html%3Fid%3DTP40005490-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Reference/vImage_geometric/Reference/reference.html%3Fid%3DTP40005490-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>