<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Concordia - /ChooseTkl.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">Concordia</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Concordia</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/ChooseTkl.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ChooseTkl.c</option>
<option value="listing2.html">/ChooseTkl.h</option>
<option value="listing3.html">/Concordia.c</option>
<option value="listing4.html">/Concordia.h</option>
<option value="listing5.html">/Concordia.r</option>
<option value="listing6.html">/DrawTkl.c</option>
<option value="listing7.html">/DrawTkl.h</option>
<option value="listing8.html">/PopUpTkl.c</option>
<option value="listing9.html">/PopUpTkl.h</option>
<option value="listing10.html">/SizeTkl.c</option>
<option value="listing11.html">/SizeTkl.h</option></select>
				</p>
				</form>
				<p><strong><a href="Concordia.zip">Download Sample</a></strong> (&#147;Concordia.zip&#148;, 35.8K)<BR>
<strong><a href="Concordia.dmg">Download Sample</a></strong> (&#147;Concordia.dmg&#148;, 94.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    ChooseTkl.c  Contains:  just one enourmously long routine, DoChooseMsg.  This        routine handles the display of a menu after it's been pulled down or popped up        and before it's erased.  Written by:     Copyright:  Copyright &copy; 1991-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/10/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        *//******************************************************************************\* Header Files\******************************************************************************/#include &lt;Memory.h&gt;#include &lt;Menus.h&gt;#include &lt;Quickdraw.h&gt;#include &lt;Types.h&gt;#include &quot;ChooseTkl.h&quot;#include &quot;Concordia.h&quot;#include &quot;DrawTkl.h&quot;#include &quot;SizeTkl.h&quot;/******************************************************************************\* Constants &amp; Macros\******************************************************************************/#define noScroll   ((short) 0) //Must not scroll#define upScroll   ((short) 1) //Must scroll up#define downScroll ((short) 2) //Must scroll down/* System Globals */#define sgHuhRect     *((Rect *) 0x09FA)  //MenuSelect seems to need this#define sgMenuDisable *((long *) 0x0B54)  //MenuDisable system global (IM-V)/******************************************************************************\* Function Prototypes\******************************************************************************/void RedrawItem (MenuHandle, short, Rect *, short);#pragma segment Main/******************************************************************************\* DoChooseMsg - Choose a menu item** DoChooseMsg is an unbelievably long routine which processes the mChooseMsg* menu message for the menu specified by TheMenu.  DoChooseMsg will determine* which menu items must be hilighted and unhighlighted, and will highlight and* unhighlight those items appropriately.  If TheMenu has scroll arrows and the* location of the mouse (given in HitPt), is located in these scroll arrows,* DoChooseMsg will scroll the menu.  DoChooseMsg will then draw any newly-* exposed menu items.  When the end of TheMenu is reached while scrolling, the* scroll arrow at that end will be erased and the menu item behind it will be* drawn.  If a scrolling menu was at one end when it's scrolled, DoChooseMsg* will draw a new scroll arrow at that end.  The item number of the chosen item* is returned, or 0 if no item is chosen.** Coding Notes* #A# - This loop calculates the item number and item rectangle of the item*       being chosen, the item rectangle of the item that was chosen the last*       time DoChooseMsg was called, and the sum of the heights of all of the*       items in TheMenu.  If no item is chosen or if the item is disabled, the*       item number will be calculated as 0.* #B# - Read as: If the vertical coordinate in the TopMenuItem system global*       doesn't coincide with the top of the menu rectangle, this menu has a top*       scroll arrow.* #C# - Read as: If the vertical coordinate in the AtMenuBottom system global*       doesn't coincide with the bottom of the menu rectangle, this menu has a*       bottom scroll arrow.* #D# - If the menu has a top or bottom scroll arrow, set the clipping region so*       that the scroll arrows won't be stomped on when items are hilighted and*       unhilighted.* #E# - If we're scrolling and there's no scroll bar at the other end, it must*       be drawn and the scroll rectangle adjusted for that.* #F# - If we've scrolled to an end of a menu, the scroll bar at that end must*       be drawn over.* #G# - This loop draws the menu items that intersect with UpdateRect.* #H# - If we saved the clip region, we'd better restore it.* #I# - Side Effect: System globals TopMenuItem and AtMenuBottom are modified*       here.  Icky, Poo!* #J# - Set high word of MenuDisable system global to menu ID, and low word to*       the item number.  Yes folks, even if the item is disabled.* #K# - If the item is disabled, its item number will be the 2's complement of*       whatever it should be.* #L# - Why do I have to do this?  BEATS THE HELL OUT OF ME!* #M# - Even if the new item isn't hierarchical, it might still get stomped on*       when a hierarchical menu is erased.* #N# - We don't need the menuEnabled bit any more so get rid of it by shifting*       it out.  Then we have to set the high bit so that all items beyond the*       31st will be enabled.  With arithmetic right shifting, this high bit*       will be preserved.* #O# - If a hierarchical menu is up right at the top or bottom of the screen*       and the user moves the mouse into the scroll area of the main menu, we*       get a mChooseMsg with the hit point in the scroll area before the child*       menu is brought down.  That would cause DoChooseMsg to scroll the main*       menu while the child menu is still up.  Because the Menu Bar Definition*       Procedure saves the bits behind the child menu and because the child*       menu slightly overlaps the main menu, scrolling while the hierarchical*       menu is up causes a little bit of garbage to appear on the screen.  To*       prevent this, the DoDrawMsg routine clears a field in the MBSaveLoc*       record to 0.  DoChooseMsg checks this field.  If it's set to 1, then*       scrolling is done as usual.  If it's clear, then scrolling is supressed*       to give the menu bar definition procedure some time to bring down the*       hierarchical menu first.\******************************************************************************/shortDoChooseMsg (MenuHandle TheMenu,Rect* MenuRect,Point HitPt,short WhichItem){  Str255        *ItemString; //-&gt; Menu item's string  ItemInfoPtr   ItemInfo;    //-&gt; Item info record  short         ItemHeight;  //Height of menu item in pixels  Rect          ItemRect;    //Item's rectangle in screen coords  short         TotHeight;   //Total height of menu in pixels  Rect          NewRect;     //Rectangle of newly-chosen item in global coords  short         NewItem;     //Item number of newly-chosen item  Rect          OldRect;     //Rectangle of old chosen item in global coords  short         OldItem;     //Item number of old chosen item  short         CurrItem;    //Item number of item being processed  short         NewIsHier;   //True if NewItem specifies hierarchical item  short         OldIsHier;   //True if OldItem specifies hierarchical item  short         HasTopScrl;  //True if menu has top scroll arrow  short         HasBotScrl;  //True if menu has bottom scroll arrow  short         MustScrl;    //Which direction must menu scroll, if any?  short         ScrollAmt;   //Scrolling distance in pixels  RgnHandle     SavedClip;   //=&gt; Clip region before DoChooseMsg is called  Rect          MenuClip;    //Menu's clip rectangle, if scroll icons present  RgnHandle     UpdateRgn;   //=&gt; Menu update region when scrolled  Rect          UpdateRect;  //Menu update rectangle when scrolled  long          EnableFlags; //Menu's enable flags  Boolean       dontScroll;  /* True if scrolling shouldn't take place */  EnableFlags = (unsigned long) (**TheMenu).enableFlags;  if (EnableFlags &amp; 1)    {    EnableFlags &gt;&gt;= (unsigned long) 1; //#N#    EnableFlags |= 0x80000000;    }  else    EnableFlags = (unsigned long) 0;  SavedClip = (RgnHandle) null;  NewRect = OldRect = *MenuRect;  NewRect.top = NewRect.bottom = OldRect.top = OldRect.bottom = sgTopMenuItem;  NewItem = 0;  OldItem = 0;  CurrItem = 1;  TotHeight = 0;  NewIsHier = OldIsHier = false;  dontScroll = *((short *) ((*sgMBSaveLoc) + 16)) == 1; //#O#  if (dontScroll)    *((short *) ((*sgMBSaveLoc) + 16)) = 0;  HLock ((Handle) TheMenu);  ItemString = (Str255 *) (**TheMenu).menuData;  ItemString = (Str255 *) ((Byte *) ItemString + strSize (*ItemString));  while ((*ItemString) [0] != '\0') //#A#    {    ItemInfo = (ItemInfoPtr) ((Byte *) *ItemString + strSize (*ItemString));    ItemHeight = CalcItemHeight (*ItemString, ItemInfo);    if (NewItem == 0)      {      NewRect.bottom = NewRect.top + ItemHeight;      if (HitPt.v &gt; NewRect.top &amp;&amp; HitPt.v &lt;= NewRect.bottom)        {        if (EnableFlags &amp; 1) //#K#          NewItem = CurrItem;        else          NewItem = -CurrItem;        if (ItemInfo-&gt;kbdEquiv == (char) hMenuCmd)          NewIsHier = true;        }      else        NewRect.top += ItemHeight;      }    if (OldItem == 0)      if (WhichItem == CurrItem)        {        OldRect.bottom = OldRect.top + ItemHeight;        OldItem = WhichItem;        if (ItemInfo-&gt;kbdEquiv == (char) hMenuCmd)          OldIsHier = true;        }      else        OldRect.top += ItemHeight;    TotHeight += ItemHeight;    CurrItem += 1;    ItemString = (Str255 *) (ItemInfo + 1);    EnableFlags &gt;&gt;= 1;    }  HUnlock ((Handle) TheMenu);  if (HitPt.h &lt; MenuRect-&gt;left || HitPt.h &gt; MenuRect-&gt;right)    NewItem = 0;  MustScrl = noScroll;  HasTopScrl = HasBotScrl = false;  if (sgTopMenuItem != MenuRect-&gt;top) //#B#    {    HasTopScrl = true;    if (HitPt.v &lt; MenuRect-&gt;top + scrlIconHeight)      {      NewItem = 0;      MustScrl = downScroll;      }    }  if (sgAtMenuBottom != MenuRect-&gt;bottom) //#C#    {    HasBotScrl = true;    if (HitPt.v &gt; MenuRect-&gt;bottom - scrlIconHeight)      {      NewItem = 0;      MustScrl = upScroll;      }    }  if (HasBotScrl || HasTopScrl) //#D#    {    MenuClip = *MenuRect;    if (HasBotScrl)      MenuClip.bottom -= scrlIconHeight;    if (HasTopScrl)      MenuClip.top += scrlIconHeight;    SavedClip = NewRgn ();    GetClip (SavedClip);    ClipRect (&amp;MenuClip);    }  if (NewItem == 0)    sgMenuDisable = 0L;  else    {     sgMenuDisable = (**TheMenu).menuID &lt;&lt; (sizeof(long) / 2) | (NewItem &gt; 0 ?        NewItem : -NewItem); //#J# #K#    if (NewItem &lt; 0)      NewItem = 0;    }  if (NewItem != 0 &amp;&amp; NewIsHier) //#L#    {    sgHuhRect = NewRect;    *((Rect *) ((*sgMBSaveLoc) + 6)) = NewRect;    }  if (NewItem != OldItem)    {    if (OldItem != 0)      if (OldIsHier)        RedrawItem (TheMenu, OldItem, &amp;OldRect, false);      else        InvertRect (&amp;OldRect);    if (NewItem != 0)      if (OldIsHier) //#M#        RedrawItem (TheMenu, NewItem, &amp;NewRect, true);      else        InvertRect (&amp;NewRect);    }  if (!dontScroll &amp;&amp; MustScrl &amp;&amp; HitPt.h &gt;= MenuRect-&gt;left &amp;&amp; HitPt.h &lt;=      MenuRect-&gt;right)    {    if (MustScrl == upScroll)      {      if (! HasTopScrl) //#E#        {        DrawScroll (MenuRect, topScroll);        MenuClip.top += scrlIconHeight;        }      ScrollAmt = MenuClip.bottom - HitPt.v;      if (ScrollAmt &lt; MenuRect-&gt;bottom - sgAtMenuBottom)        ScrollAmt = MenuRect-&gt;bottom - sgAtMenuBottom;      UpdateRgn = NewRgn ();      ScrollRect (&amp;MenuClip, 0, ScrollAmt, UpdateRgn);      UpdateRect = (**UpdateRgn).rgnBBox;      DisposeRgn (UpdateRgn);      sgTopMenuItem += ScrollAmt; //#I#      sgAtMenuBottom += ScrollAmt;      if (sgAtMenuBottom == MenuRect-&gt;bottom) //#F#        UpdateRect.bottom += scrlIconHeight;      if (SavedClip == (RgnHandle) null)        {        SavedClip = NewRgn ();        GetClip (SavedClip);        }      ClipRect (&amp;UpdateRect);      EraseRect (&amp;UpdateRect);      }    else      {      if (! HasBotScrl) //#E#        {        DrawScroll (MenuRect, botScroll);        MenuClip.bottom -= scrlIconHeight;        }      ScrollAmt = MenuClip.top - HitPt.v;      if (ScrollAmt &gt; MenuRect-&gt;top - sgTopMenuItem)        ScrollAmt = MenuRect-&gt;top - sgTopMenuItem;      UpdateRgn = NewRgn ();      ScrollRect (&amp;MenuClip, 0, ScrollAmt, UpdateRgn);      UpdateRect = (**UpdateRgn).rgnBBox;      DisposeRgn (UpdateRgn);      sgTopMenuItem += ScrollAmt;      sgAtMenuBottom += ScrollAmt;      if (sgTopMenuItem == MenuRect-&gt;top) //#F#        UpdateRect.top -= scrlIconHeight;      if (SavedClip == (RgnHandle) null)        {        SavedClip = NewRgn ();        GetClip (SavedClip);        }      ClipRect (&amp;UpdateRect);      EraseRect (&amp;UpdateRect);      }    SetRect (&amp;ItemRect, MenuRect-&gt;left, sgTopMenuItem, MenuRect-&gt;right,        sgTopMenuItem);    EnableFlags = (unsigned long) (**TheMenu).enableFlags;    if (EnableFlags &amp; 1)      {      EnableFlags &gt;&gt;= (unsigned long) 1;      EnableFlags |= 0x80000000;      }    else      EnableFlags = (unsigned long) 0;    HLock ((Handle) TheMenu);    ItemString = (Str255 *) (**TheMenu).menuData;    ItemString = (Str255 *) ((Byte *) ItemString + strSize (*ItemString));    while ((*ItemString) [0] != '\0') //#G#      {      ItemInfo = (ItemInfoPtr) ((Byte *) *ItemString + strSize          (*ItemString));      ItemRect.bottom = ItemRect.top + CalcItemHeight (*ItemString,          ItemInfo);      if (ItemRect.top &lt; UpdateRect.bottom &amp;&amp; ItemRect.bottom &gt;          UpdateRect.top)        DrawItem (*ItemString, ItemInfo, &amp;ItemRect, EnableFlags &amp; 1);      EnableFlags &gt;&gt;= 1;      ItemRect.top = ItemRect.bottom;      ItemString = (Str255 *) (ItemInfo + 1);      }    HUnlock ((Handle) TheMenu);    }  if (SavedClip != (RgnHandle) null) //#H#    {    SetClip (SavedClip);    DisposeRgn (SavedClip);    }  return NewItem;  }#pragma segment Main/******************************************************************************\* RedrawItem - Redraw a menu item for hierarchical menus** RedrawItem redraws a menu item that's been clobbered by a hierarchical menu.* The affected menu is specified by TheMenu.  The item number of the menu item* to redraw is given in ItemNum, while the item's rectangle is given in* ItemRect.  If the item is going to be selected, Select must be true so that* the item will be redrawn in inverse.  Otherwise Select must be false so that* the item will be redrawn normally.\******************************************************************************/static voidRedrawItem (MenuHandle TheMenu,short ItemNum,Rect* ItemRect,short Select){  Str255       *ItemString; //-&gt; Menu item's string  ItemInfoPtr  ItemInfo;    //-&gt; Item info record  short        CurrItem;    //Item number of item being checked  TextStateRec TextState;   //Current text modes, etc.  CurrItem = 0;  HLock ((Handle) TheMenu);  ItemString = (Str255 *) (**TheMenu).menuData;  ItemString = (Str255 *) ((Byte *) ItemString + strSize (*ItemString));  while (ItemNum != CurrItem &amp;&amp; (*ItemString) [0] != '\0')    {    ItemInfo = (ItemInfoPtr) ((Byte *) *ItemString + strSize        (*ItemString));    CurrItem += 1;    if (ItemNum == CurrItem)      {      GetTextState (&amp;TextState);      EraseRect (ItemRect);      DrawItem (*ItemString, ItemInfo, ItemRect, true);      if (Select)        InvertRect (ItemRect);      SetTextState (&amp;TextState);      }    else      ItemString = (Str255 *) (ItemInfo + 1);    }  HUnlock ((Handle) TheMenu);  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Concordia/listing1.html%3Fid%3DDTS10000181-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Concordia/listing1.html%3Fid%3DDTS10000181-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Concordia/listing1.html%3Fid%3DDTS10000181-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>