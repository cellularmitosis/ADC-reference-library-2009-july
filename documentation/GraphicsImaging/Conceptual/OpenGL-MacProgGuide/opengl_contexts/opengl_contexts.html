<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>OpenGL Programming Guide for Mac OS X: Techniques for Working with Rendering Contexts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Techniques for Working with Rendering Contexts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001987-CH216" title="Techniques for Working with Rendering Contexts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../OpenGL-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000549" target="_top">OpenGL</a> &gt; <a href="../opengl_intro/opengl_intro.html#//apple_ref/doc/uid/TP40001987-CH207-TP9">OpenGL Programming Guide for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_general/opengl_gen_tasks.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_pixelformats/opengl_pixelformats.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001987-CH216-SW12" title="Techniques for Working with Rendering Contexts"></a><h1>Techniques for Working with Rendering Contexts</h1><p>A rendering context is a container for state information. When you designate a rendering context as the current rendering context, subsequent OpenGL commands modify the drawable object associated with that context. The actual drawing surfaces are never really owned by the rendering context but are created, as needed, only when the rendering context is actually attached to a drawable object. You can attach multiple rendering contexts to a set of drawing surfaces. Each context draws with its own unique “pen” represented by its current state.</p><p><span class="content_text"><a href="../opengl_drawing/opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW8">“Drawing to a Window or View,”</a></span> <span class="content_text"><a href="../opengl_fullscreen/opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW6">“Drawing to the Full Screen,”</a></span> and <span class="content_text"><a href="../opengl_offscreen/opengl_offscreen.html#//apple_ref/doc/uid/TP40001987-CH403-SW2">“Drawing Offscreen”</a></span> show how to create a rendering context and attach it to a drawable object. As you'll recall, each of the Apple-specific OpenGL APIs provides a routine that's fairly easy to use for creating a rendering context. This chapter goes beyond creating rendering contexts; it shows how to set context parameters, update rendering contexts, and set up a shared context. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW23">Context Parameters</a>
				
			<br/>
			
        
			
			
				<a href="opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW5">Updating a Rendering Context</a>
				
			<br/>
			
        
			
			
				<a href="opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW7">Sharing Rendering Contexts</a>
				
			<br/>
			
        
			
			
				<a href="opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW34">See Also</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001987-CH216-SW23" title="Context Parameters"></a><h2>Context Parameters</h2><p>A rendering context has a variety of parameters that you can set to suit the needs of your OpenGL drawing. Some of the most useful, and often overlooked, context parameters are discussed in this section: swap interval, surface opacity, surface drawing order, and back-buffer size control.</p><p>Each of the Apple-specific OpenGL APIs provides a routine for setting and getting rendering context parameters:</p><ul class="ul"><li class="li"><p>The <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/setValues:forParameter:" target="_top">setValues:forParameter:</a></code> method of the <code>NSOpenGLContext</code> class  takes as arguments a list of values and a list of parameters.</p></li><li class="li"><p>The <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglSetInteger" target="_top">aglSetInteger</a></code> function takes as parameters a rendering context, a constant that specifies an option, and a value for that option.</p></li><li class="li"><p>The <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/c/func/CGLSetParameter" target="_top">CGLSetParameter</a></code> function takes as parameters a rendering context, a constant that specifies an option, and a value for that option.</p></li></ul><p>Some parameters need to be enabled for their values to take effect. The reference documentation for a parameter indicates whether a parameter needs to be enabled. See <em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/index.html#//apple_ref/doc/uid/TP40004074" target="_top">NSOpenGLContext Class Reference</a></em>, <em><a href="../../../Reference/AGL_OpenGL/index.html#//apple_ref/doc/uid/TP30001068" target="_top">AGL Reference</a></em>, and <em><a href="../../../Reference/CGL_OpenGL/index.html#//apple_ref/doc/uid/TP40001186" target="_top">CGL Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW24" title="Swap Interval"></a><h3>Swap Interval</h3><p>The <strong>swap interval</strong> parameter synchronizes the vertical retrace.  If the swap interval is set to <code>0</code> (the default), buffers are swapped as soon as possible, without regard to the vertical refresh rate of the monitor. If the swap interval is set to any other value, the buffers are swapped only during the vertical retrace of the monitor. For more information, see <span class="content_text"><a href="../opengl_performance/opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW3">“Draw Only When Necessary.”</a></span></p><p>You can use the following constants to specify that you are setting the swap interval value:</p><ul class="spaceabove"><li class="li"><p>For Cocoa, use <code>NSOpenGLCPSwapInterval</code>. </p></li><li class="li"><p>For Carbon, use <code>AGL_SWAP_INTERVAL</code>. </p></li><li class="li"><p>If you are using the CGL API, use <code>kCGLCPSwapInterval</code>. See <span class="content_text">Listing 6-1</span>.</p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH216-SW20" title="Listing 6-1Using CGL to set up synchronization"></a><p class="codesample"><strong>Listing 6-1&nbsp;&nbsp;</strong>Using CGL to set up synchronization</p><div class="codesample"><table><tr><td scope="row"><pre>long sync = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>// ctx must be a valid context<span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetParameter (ctx, kCGLCPSwapInterval, &amp;sync);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW25" title="Surface Opacity"></a><h3>Surface Opacity</h3><p>OpenGL surfaces are typically rendered as opaque. Thus the background color for pixels with alpha values of <code>0.0</code> is the surface background color. If you set the value of the <strong>surface opacity</strong> parameter to <code>0</code>, then the contents of the surface are blended with the contents of surfaces behind the OpenGL surface. This operation is equivalent to OpenGL blending with a source contribution proportional to the source alpha and a background contribution proportional to <code>1</code> minus the source alpha. A value of <code>1</code> means the surface is opaque (the default); <code>0</code> means completely transparent. </p><p>You can use the following constants to specify that you are setting the surface opacity value:</p><ul class="spaceabove"><li class="li"><p>For Cocoa, use <code>NSOpenGLCPSurfaceOpacity</code>. </p></li><li class="li"><p>For Carbon, use <code>AGL_SURFACE_OPACITY</code>. </p></li><li class="li"><p>If you are using the CGL API, use <code>kCGLCPSurfaceOpacity</code>. See <span class="content_text">Listing 6-2</span>.</p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH216-SW19" title="Listing 6-2Using CGL to set surface opacity"></a><p class="codesample"><strong>Listing 6-2&nbsp;&nbsp;</strong>Using CGL to set surface opacity</p><div class="codesample"><table><tr><td scope="row"><pre>long opaque = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>// ctx must be a valid context<span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetParameter (ctx, kCGLCPSurfaceOpacity, &amp;opaque);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW21" title="Surface Drawing Order"></a><h3>Surface Drawing Order</h3><p>The <strong>surface drawing order</strong> parameter specifies the position of the OpenGL surface relative to the window. A value of <code>1</code> means that the position is above the window; a value of <code>–1</code> specifies a position that is below the window. When you have overlapping views, setting the order to <code>-1</code> causes OpenGL to draw underneath, <code>1</code> causes OpGL to draw on top. This parameter is useful for drawing user interface controls on top of an OpenGL view.</p><p>You can use the following constants to specify that you are setting the surface drawing order value:</p><ul class="spaceabove"><li class="li"><p>For Cocoa, use <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/c/econst/NSOpenGLCPSurfaceOrder" target="_top">NSOpenGLCPSurfaceOrder</a></code>. </p></li><li class="li"><p>For Carbon, use <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/macro/AGL_SURFACE_ORDER" target="_top">AGL_SURFACE_ORDER</a></code>. </p></li><li class="li"><p>If you are using the CGL API, use <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/c/econst/kCGLCPSurfaceOrder" target="_top">kCGLCPSurfaceOrder</a></code>. See <span class="content_text">Listing 6-3</span>.</p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH216-SW18" title="Listing 6-3Using CGL to set surface drawing order"></a><p class="codesample"><strong>Listing 6-3&nbsp;&nbsp;</strong>Using CGL to set surface drawing order</p><div class="codesample"><table><tr><td scope="row"><pre>long order = –1; // below window<span></span></pre></td></tr><tr><td scope="row"><pre>// ctx must be a valid context<span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetParameter (ctx, kCGLCPSurfaceOrder, &amp;order);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW22" title="Vertex and Fragment Processing"></a><h3>Vertex and Fragment Processing</h3><p>CGL provides two parameters for checking whether the system is using the GPU for processing: <code>kCGLCPGPUVertexProcessing</code> and <code>kCGLCPGPUFragmentProcessing</code>. To check vertex processing, pass the vertex constant to the <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/c/func/CGLGetParameter" target="_top">CGLGetParameter</a></code> function. To check fragment processing, pass the fragment constant to <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/c/func/CGLGetParameter" target="_top">CGLGetParameter</a></code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH216-SW26" title="Important"></a><p><strong>Important:</strong>&nbsp;Although you can perform these queries at any time, keep in mind that such queries force an internal state validation, which can impact performance. For best performance, do not use these queries inside your drawing loop. Instead, perform the queries once at initialization or context setup time to determine whether OpenGL is using the CPU or the GPU for processing, and then act appropriately in your drawing loop.</p></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW27" title="Listing 6-4Using CGL to check whether the GPU is processing vertices and fragments"></a><p class="codesample"><strong>Listing 6-4&nbsp;&nbsp;</strong>Using CGL to check whether the GPU is processing vertices and fragments</p><div class="codesample"><table><tr><td scope="row"><pre>BOOL gpuProcessing;<span></span></pre></td></tr><tr><td scope="row"><pre>GLint fragmentGPUProcessing, vertexGPUProcessing;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLGetParameter (CGLGetCurrentContext(), kCGLCPGPUFragmentProcessing,<span></span></pre></td></tr><tr><td scope="row"><pre>                                         &amp;fragmentGPUProcessing);<span></span></pre></td></tr><tr><td scope="row"><pre>CGLGetParameter(CGLGetCurrentContext(), kCGLCPGPUVertexProcessing,<span></span></pre></td></tr><tr><td scope="row"><pre>                                         &amp;vertexGPUProcessing);<span></span></pre></td></tr><tr><td scope="row"><pre>gpuProcessing = (fragmentGPUProcessing &amp;&amp; vertexGPUProcessing) ? YES : NO;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW28" title="Back Buffer Size Control"></a><h3>Back Buffer Size Control</h3><p>Normally, the back buffer is the same size as the window or view that it's drawn into, and it changes size when the window or view changes size. For a window whose size is 720 by 480 pixels, the OpenGL back buffer is sized to match. If the window grows to 1024 by 768 pixels, for example, then the back buffer tracks this growth. If you do not want this behavior, use the <strong>back buffer size control</strong> parameter.</p><p>Using this parameter fixes the size of the back buffer and lets the system scale the image automatically when it moves the data to a variable size buffer (see <span class="content_text">Figure 6-1</span>). The size of the back buffer remains fixed at the size that you set up regardless of whether the image is resized to display larger onscreen. </p><p>You can use the following constants to specify that you are setting the surface drawing order value:</p><ul class="spaceabove"><li class="li"><p>If you are using the CGL API, use <code>kCGLCPSurfaceBackingSize</code>, as shown in <span class="content_text">Listing 6-5</span>.</p></li><li class="li"><p>For Carbon, use <code>AGL_SURFACE_BACKING_SIZE</code>. </p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH216-SW17" title="Listing 6-5Using CGL to set up back buffer size control"></a><p class="codesample"><strong>Listing 6-5&nbsp;&nbsp;</strong>Using CGL to set up back buffer size control</p><div class="codesample"><table><tr><td scope="row"><pre>long dim[2] = {720, 480};<span></span></pre></td></tr><tr><td scope="row"><pre>// ctx must be a valid context<span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetParameter(ctx, kCGLCPSurfaceBackingSize, dim);<span></span></pre></td></tr><tr><td scope="row"><pre>CGLEnable (ctx, kCGLCESurfaceBackingSize);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW4" title="Figure 6-1A fixed size back buffer and variable size front buffer"></a><p><strong>Figure 6-1&nbsp;&nbsp;</strong>A fixed size back buffer and variable size front buffer</p><img src = "../art/scaled_swapping.jpg" alt = "A fixed size back buffer and variable size front buffer" ></div><br/><a name="//apple_ref/doc/uid/TP40001987-CH216-SW5" title="Updating a Rendering Context"></a><h2>Updating a Rendering Context</h2><p>A rendering context must be updated whenever the renderer or geometry changes. A renderer change can occur when the user drags a window from one display to another. Geometry changes occur when the display mode changes or when a a window is resized or moved. If the system does not update the context automatically, then your application must perform the update. You need to track the appropriate events and call the update function provided by the Apple-specific OpenGL API that you're using. </p><p>Updating a rendering context is not the same as flushing graphics buffers. An update notifies the rendering context of geometry changes; it doesn't flush content. Calling an update function  allows the OpenGL engine to ensure that the surface size is set and that the renderer is properly updated for any virtual screen changes. If you don't update the rendering context you either do not see any OpenGL rendering or you see rendering artifacts.</p><p>The routine that you call for updating determines how  events related to renderer and geometry changes are handled. For applications that subclass <code>NSOpenGLView</code>, Cocoa calls the <code>update</code> method automatically. Applications that use the <code>NSOpenGLContext</code> class without subclassing its view must call the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/update" target="_top">update</a></code>  method of <code>NSOpenGLContext</code> directly. For a full-screen Cocoa application, calling the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/setFullScreen" target="_top">setFullScreen</a></code> method of <code>NSOpenGLContext</code> ensures  that depth, size, or display changes take affect. </p><p>Carbon applications drawing OpenGL content to a window should call the function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglUpdateContext" target="_top">aglUpdateContext</a></code>. For full-screen CGL and AGL applications, you need to call <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/c/func/CGLSetFullScreen" target="_top">CGLSetFullScreen</a></code> and <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglSetFullScreen" target="_top">aglSetFullScreen</a></code> respectively to ensure that depth, size, or display changes take affect rather than calling an update function. </p><p>Your application must update the rendering context after the system event but before drawing to the context. If the drawable object is resized, you may want to issue a <code>glViewport</code> command  to ensure that the content scales properly.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH216-SW29" title="Note"></a><p><strong>Note:</strong>&nbsp;Some system-level events (such as display mode changes) that require a context update could reallocate the  buffers of the context, thus you need to redraw the entire scene after all context updates. </p></div><p>It's important that you don't update rendering contexts more than necessary. Your application should respond to system-level events and notifications rather than updating every frame. For example, you'll want to respond to window move and resize operations and to display configuration changes such as a color depth change.</p><p>The sections that follow describe in more detail how to use Cocoa, AGL, and CGL to update a rendering context, but you'll want to read <span class="content_text">“Tracking Renderer Changes”</span> before going on to the sections specific to the three APIs.</p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW1" title="Tracking Renderer Changes"></a><h3>Tracking Renderer Changes</h3><p>It's fairly straightforward to track geometry changes, but how are renderer changes tracked? This is where the concept of a virtual screen becomes important (see  <span class="content_text"><a href="../opengl_pg_concepts/opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW16">“Virtual Screens”</a></span>). A change in the virtual screen indicates a renderer change, a change in renderer capability, or both. When your application detects a window resize event, window move event, or display change, it can then check for a virtual screen change and respond to the change appropriately. This ensures that the current application state reflects any changes in renderer capabilities.</p><p>Each of the Apple-specific OpenGL APIs has a function that returns the current virtual screen number:</p><ul class="spaceabove"><li class="li"><p>The <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/currentVirtualScreen" target="_top">currentVirtualScreen</a></code> method of the <code>NSOpenGLContext</code> class</p></li><li class="li"><p>The <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglGetVirtualScreen" target="_top">aglGetVirtualScreen</a></code> function</p></li><li class="li"><p>The <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/c/func/CGLGetVirtualScreen" target="_top">CGLGetVirtualScreen</a></code> function</p></li></ul><p>The virtual screen number represents an index in the list of virtual screens that were set up specifically for the pixel format object used for the rendering context. The number is unique to the list but is meaningless otherwise.</p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW30" title="Updating a Rendering Context for a Custom Cocoa View"></a><h3>Updating a Rendering Context for a Custom Cocoa View</h3><p>If you subclass <code>NSView</code> instead of using the <code>NSOpenGLView</code> class, your application must update the rendering context. That's due to a slight difference between the events normally handled by the <code>NSView</code> class and those handled by the <code>NSOpenGLView</code> class. Cocoa does not call a <code>reshape</code> method for the <code>NSView</code> class when the size changes because that class does not export a <code>reshape</code> method to override. Instead, you need to perform reshape operations directly in your <code>drawRect:</code> method, looking for changes in view bounds prior to actually drawing content. Using this approach provides results that are equivalent to using the <code>reshape</code> method of the <code>NSOpenGLView</code> class.</p><p><span class="content_text">Listing 6-6</span> is a partial implementation of a custom view that shows how to handle context updates. The <code>update</code> method is called after move, resize, and display change events and when the surface needs updating. The class adds an observer to the notification <code>NSViewGlobalFrameDidChangeNotification</code>, giving a callback upon which to base context updates. This notification is posted whenever an <code>NSView</code> object that has attached surfaces (that is, <code>NSOpenGLContext</code> objects) resizes, moves, or changes coordinate offsets.</p><p>It's slightly more complicated to handle changes in the display configuration. For that, you need to register for the notification <code>NSApplicationDidChangeScreenParametersNotification</code> through the <code>NSApplication</code> class. This notification is posted whenever the configuration of any of the displays attached to the computer is changed (either programmatically or when the user changes the settings in the interface).</p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW8" title="Listing 6-6Handling context updates for a custom view "></a><p class="codesample"><strong>Listing 6-6&nbsp;&nbsp;</strong>Handling context updates for a custom view </p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Cocoa/Cocoa.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;OpenGL/OpenGL.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;OpenGL/gl.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@class NSOpenGLContext, NSOpenGLPixelFormat;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface CustomOpenGLView : NSView<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  @private<span></span></pre></td></tr><tr><td scope="row"><pre>  NSOpenGLContext*   _openGLContext;<span></span></pre></td></tr><tr><td scope="row"><pre>  NSOpenGLPixelFormat* _pixelFormat;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithFrame:(NSRect)frameRect<span></span></pre></td></tr><tr><td scope="row"><pre>        pixelFormat:(NSOpenGLPixelFormat*)format;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)update;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation CustomOpenGLView<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithFrame:(NSRect)frameRect<span></span></pre></td></tr><tr><td scope="row"><pre>        pixelFormat:(NSOpenGLPixelFormat*)format<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  self = [super initWithFrame:frameRect];<span></span></pre></td></tr><tr><td scope="row"><pre>  if (self != nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>    _pixelFormat   = [format retain];<span></span></pre></td></tr><tr><td scope="row"><pre>  [[NSNotificationCenter defaultCenter] addObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                   selector:@selector(_surfaceNeedsUpdate:)<span></span></pre></td></tr><tr><td scope="row"><pre>                   name:NSViewGlobalFrameDidChangeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                   object:self];<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>  return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)dealloc<span></span></pre></td></tr><tr><td scope="row"><pre>  [[NSNotificationCenter defaultCenter] removeObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                     name:NSViewGlobalFrameDidChangeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                     object:self];<span></span></pre></td></tr><tr><td scope="row"><pre>  [self clearGLContext];<span></span></pre></td></tr><tr><td scope="row"><pre>  [_pixelFormat release];<span></span></pre></td></tr><tr><td scope="row"><pre>  [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)update<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  if ([_openGLContext view] == self) {<span></span></pre></td></tr><tr><td scope="row"><pre>    [_openGLContext update];<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void) _surfaceNeedsUpdate:(NSNotification*)notification<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  [self update];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW31" title="Updating a Rendering Context for a Carbon Window"></a><h3>Updating a Rendering Context for a Carbon Window</h3><p>The simplest way to handle resize and move events is by using Carbon events. To cover window resize and move operations, your application can handle the events <code>kEventWindowBoundsChanged</code> and <code>kEventWindowZoomed</code>. The system generates the event <code>kEventWindowBoundsChanged</code> for window resize  and window drag operations, which takes care of most cases other than a window zoom operation. For that, track the event <code>kEventWindowZoomed</code>. For more information on these and other Carbon events see <em><a href="../../../../Carbon/Conceptual/Carbon_Event_Manager/index.html#//apple_ref/doc/uid/TP30000989" target="_top">Carbon Event Manager Programming Guide</a></em> and <em><a href="../../../../Carbon/Reference/Carbon_Event_Manager_Ref/index.html#//apple_ref/doc/uid/TP30000135" target="_top">Carbon Event Manager Reference</a></em>. </p><p><span class="content_text">Listing 6-7</span> demonstrates a simple window event handler. Note that the supporting routines needed by the window event handler—<code>MyHandleWindowUpdate</code>, <code>MyDisposeGL</code>, and <code>MyBuildGL</code>—are not shown in the listing. These are routines that you need to write. A detailed explanation for each numbered line of code appears following the listing. </p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW9" title="Listing 6-7Handling Carbon events associated with an AGL context"></a><p class="codesample"><strong>Listing 6-7&nbsp;&nbsp;</strong>Handling Carbon events associated with an AGL context</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;Carbon/Carbon.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static pascal OSStatus windowEvtHndlr (EventHandlerCallRef myHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                                       EventRef event,<span></span></pre></td></tr><tr><td scope="row"><pre>                                       void* userData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  WindowRef     window;<span></span></pre></td></tr><tr><td scope="row"><pre>  AGLContext    aglContext = (AGLContext) userData; <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>  Rect          rectPort = {0,0,0,0};<span></span></pre></td></tr><tr><td scope="row"><pre>  OSStatus      result = eventNotHandledErr;<span></span></pre></td></tr><tr><td scope="row"><pre>  UInt32        class = GetEventClass (event);<span></span></pre></td></tr><tr><td scope="row"><pre>  UInt32        kind = GetEventKind (event);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>  GetEventParameter(event, kEventParamDirectObject, typeWindowRef,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL, sizeof(WindowRef), NULL, &amp;window);<span></span></pre></td></tr><tr><td scope="row"><pre>  if (window) {<span></span></pre></td></tr><tr><td scope="row"><pre>    GetWindowPortBounds (window, &amp;rectPort);<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>  switch (class) {<span></span></pre></td></tr><tr><td scope="row"><pre>    case kEventClassWindow:<span></span></pre></td></tr><tr><td scope="row"><pre>      switch (kind) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowActivated: <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowDrawContent: <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>          MyHandleWindowUpdate(window);<span></span></pre></td></tr><tr><td scope="row"><pre>          break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowClose: <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>          HideWindow (window);<span></span></pre></td></tr><tr><td scope="row"><pre>          MyDisposeGL (window);<span></span></pre></td></tr><tr><td scope="row"><pre>          break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowShown: <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>          MyBuildGL (window);<span></span></pre></td></tr><tr><td scope="row"><pre>          if (window == FrontWindow ())<span></span></pre></td></tr><tr><td scope="row"><pre>                SetUserFocusWindow (window);<span></span></pre></td></tr><tr><td scope="row"><pre>          InvalWindowRect (window, &amp;rectPort);<span></span></pre></td></tr><tr><td scope="row"><pre>          break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowBoundsChanged: //6)<span></span></pre></td></tr><tr><td scope="row"><pre>          MyResizeGL (window, aglContext);<span></span></pre></td></tr><tr><td scope="row"><pre>          MyHandleWindowUpdate(window);<span></span></pre></td></tr><tr><td scope="row"><pre>          break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowZoomed: <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>          MyResizeGL (window, aglContext);<span></span></pre></td></tr><tr><td scope="row"><pre>          break;<span></span></pre></td></tr><tr><td scope="row"><pre>      }<span></span></pre></td></tr><tr><td scope="row"><pre>      break;<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>  return result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here's what the code does:</p><ol class="ol"><li class="li"><p>Stores the rendering context, which is passed to the event handler through the <code>userData</code> parameter.</p></li><li class="li"><p>Passes the activation event through, which prevents an initial flash of the screen.</p></li><li class="li"><p>Handles a draw content event by calling your window update function.</p></li><li class="li"><p>Handles a window close event by calling your dispose function to perform the necessary cleanup work.</p></li><li class="li"><p>Handles a window shown event by calling your function that performs the necessary work to render OpenGL to the window and to make the window frontmost with user focus.</p></li><li class="li"><p>Handles a window bounds changed event by resizing the window appropriately and then updating the content. </p></li><li class="li"><p>Handles a zoom event by resizing the window.</p></li></ol><p>The code to handle the context update is shown in <span class="content_text">Listing 6-8</span>. In its simplest form this code ensures the context of interest is current and then updates the context. Your application can also call the function <code><!--a-->glViewport<!--/a--></code> to update the size of the drawable object to the current window size or to some other meaningful value. You might also want to update the projection matrix because the window dimensions have changed, and thus the relative geometry of the window has changed. </p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW10" title="Listing 6-8Updating a context using AGL"></a><p class="codesample"><strong>Listing 6-8&nbsp;&nbsp;</strong>Updating a context using AGL</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;Carbon/Carbon.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;AGL/agl.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;OpenGL/OpenGL.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyUpdateContextAGL (WindowRef window, AGLContext aglContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  Rect rectPort;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>  aglSetCurrentContext (aglContext);<span></span></pre></td></tr><tr><td scope="row"><pre>  aglUpdateContext (aglContext);<span></span></pre></td></tr><tr><td scope="row"><pre>  GetWindowPortBounds (window, &amp;rectPort);<span></span></pre></td></tr><tr><td scope="row"><pre>  glViewport (0, 0, rectPort.right - rectPort.left,<span></span></pre></td></tr><tr><td scope="row"><pre>                    rectPort.bottom - rectPort.top);<span></span></pre></td></tr><tr><td scope="row"><pre>  /* Your code to update the projection matrix if needed */<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>It's slightly more complicated to handle changes in display configuration. You can detect these using Display Manager callback functions.  (See <em><a href="../../../../Carbon/Reference/Display_Manager/index.html#//apple_ref/doc/uid/TP30000151" target="_top">Display Manager Reference</a></em> and <em><a href="../../../../Carbon/Conceptual/Optimizing_DisplayManager/index.html#//apple_ref/doc/uid/TP40000920" target="_top">Optimizing Display Modes and Window Arrangement With the Display Manager</a></em>.) You need to provide a callback function that conforms to the <code>DMExtendedNotificationProcPtr</code> callback. Then, after creating a universal procedure pointer to this function by calling the function <code>NewDMExtendedNotificationUPP</code>, register this UPP by calling the function <code>DMRegisterExtendedNotifyProc</code>. </p><p><span class="content_text">Listing 6-9</span> shows the callback, the UPP creation and registration tasks, and other tasks you need for perform when handling display configuration changes. The callback function <code>handleWindowDMEvent</code> is  simple. It calls the context update routine and invalidates the full window graphics port bounds to force an update event. Make sure to check for the <code>kDMNotifyEvent</code> message type; otherwise, the event is probably not one for which you need to update the context. If you use multiple rendering contexts or windows, it may be helpful to add the window or context to the user data. </p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW11" title="Listing 6-9Handling display configuration changes"></a><p class="codesample"><strong>Listing 6-9&nbsp;&nbsp;</strong>Handling display configuration changes</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;Carbon/Carbon.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;AGL/agl.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void handleWindowDMEvent (void *userData,<span></span></pre></td></tr><tr><td scope="row"><pre>                            short msg, void *notifyData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  AGLContext aglContext = (AGLContext) userData;<span></span></pre></td></tr><tr><td scope="row"><pre>  if (kDMNotifyEvent == msg) {<span></span></pre></td></tr><tr><td scope="row"><pre>    MyUpdateContextAGL (window, aglContext);<span></span></pre></td></tr><tr><td scope="row"><pre>    GetWindowPortBounds (window, &amp;rectPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    InvalWindowRect (window, &amp;rectPort);<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void setupDMNotify (WindowRef window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  gWindowEDMUPP = NewDMExtendedNotificationUPP(handleWindowDMEvent);<span></span></pre></td></tr><tr><td scope="row"><pre>  DMRegisterExtendedNotifyProc (gWindowEDMUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                     (void *)window, NULL, &amp;psn);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus disposeDM Notify (WindowRef window)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  if (gWindowEDMUPP) {<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeDMExtendedNotificationUPP (gWindowEDMUPP);<span></span></pre></td></tr><tr><td scope="row"><pre>    gWindowEDMUPP = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW32" title="Updating Full-screen AGL and CGL Rendering Contexts"></a><h3>Updating Full-screen AGL and CGL Rendering Contexts</h3><p>It's easier to update full-screen drawable objects than it is windowed ones since the drawable object position is fixed. Its size is directly linked to the display configuration, so full-screen applications need to perform updates only when they actually change the configuration. Instead of calling a context update routine, a full-screen application issues a set-full-screen call. <span class="content_text">Listing 6-10</span> and  <span class="content_text"><a href="opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW15">Listing 6-11</a></span> show examples of AGL and CGL routines, respectively, to reset the full-screen context.</p><p>For AGL, the <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglSetFullScreen" target="_top">aglSetFullScreen</a></code> function handles screen capture and display resizing; thus you just need  to ensure that a valid full-screen pixel format object and rendering context are created prior to resizing. For CGL, you can use the Quartz Display Services functions <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGCaptureAllDisplays" target="_top">CGCaptureAllDisplays</a></code>, <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplayBestModeForParametersAndRefreshRate" target="_top">CGDisplayBestModeForParametersAndRefreshRate</a></code> (or similar function), and <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplaySwitchToMode" target="_top">CGDisplaySwitchToMode</a></code> to set the requested display configuration. Then set the pixel format for the display and call the resize function.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH216-SW33" title="Note"></a><p><strong>Note:</strong>&nbsp;When you capture all displays, using either the function <code>aglSetFullScreen</code> (but without setting <code>AGL_FS_CAPTURE_SINGLE</code>) or the function <code>CGCaptureAllDisplays</code>, your application does not see any Display Manager notifications, because the display configuration is fixed and does not change until released. If  you do not capture all displays, the application still receives display configuration changes for the noncaptured displays. Normally full-screen applications do not need to handle these display notifications, because they are for the displays not currently in use or of interest.</p></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW14" title="Listing 6-10Handling full-screen updates using AGL"></a><p class="codesample"><strong>Listing 6-10&nbsp;&nbsp;</strong>Handling full-screen updates using AGL</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;Carbon/Carbon.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;AGL/agl.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;OpenGL/gl.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyResizeAGLFullScreen (AGLContext aglContext, GLSizei width,<span></span></pre></td></tr><tr><td scope="row"><pre>                    GLSizei height)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  GLint displayCaps [3];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>  if (!aglContext) <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>  aglSetCurrentContext (aglContext);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>  aglSetFullScreen (aglContext, width, height, 0, 0); <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>  aglGetInteger (aglContext, AGL_FULLSCREEN, displayCaps); <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>  glViewport (0, 0, displayCaps[0], displayCaps[1]); <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>  // Your code to update the projection matrix here if needed<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here's what the code does:</p><ol class="ol"><li class="li"><p>Checks for a valid context and returns if the context is not valid. Note that the <code>MyResizeAGLFullScreen</code> function assumes that the pixel format object associated with the context was created with the full-screen attribute.</p></li><li class="li"><p>Sets the context to the current context.</p></li><li class="li"><p>Attaches a full-screen drawable object to the context to ensure the context is updated.</p></li><li class="li"><p>Gets the display capabilities of the display, which are the width, height, and screen resolution.</p></li><li class="li"><p>Sets the viewport, specifying <code>(0,0)</code> as the left corner of the viewport rectangle, and the width and height of the screen (which were obtained with the previous call to <code>aglGetInteger</code>).</p></li></ol><p><span class="content_text">Listing 6-11</span> assumes that the pixel format object associated with the context was created with the full-screen, single display, and pixel depth attributes. Additionally, this code assumes that the screen is captured and set to the requested dimensions. The viewport is not set here since the calling routine actually sets the display size. </p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW15" title="Listing 6-11Handling full-screen updates using CGL"></a><p class="codesample"><strong>Listing 6-11&nbsp;&nbsp;</strong>Handling full-screen updates using CGL</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;Carbon/Carbon.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;OpenGL/OpenGL.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;OpenGL/gl.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyResizeCGL (CGLContextObj cglContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  if (!cglContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>  CGLSetCurrentContext (cglContext);<span></span></pre></td></tr><tr><td scope="row"><pre>  CGLSetFullScreen (cglContext);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW7" title="Sharing Rendering Contexts"></a><h2>Sharing Rendering Contexts</h2><p>A rendering context does not own the drawing objects attached to it, which leaves open the option for sharing. Rendering contexts can share resources and can be attached to the same drawable object (see <span class="content_text">Figure 6-2</span>) or to different drawable objects (see <span class="content_text">Figure 6-3</span>). You set up context sharing—either with more than one drawable object or with another context—at the time you create a rendering context.</p><p>Contexts can share <em>object resources</em> and their associated <em>object state</em> by indicating a shared context at context creation time. Shared contexts share all texture objects, display lists, vertex programs, fragment programs, and buffer objects created before and after sharing is initiated. The state of the objects are also shared but not other context state, such as current color, texture coordinate settings, matrix and lighting settings, rasterization state, and texture environment settings. You need to duplicate context state changes as required, but you need to set up individual objects only once. </p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW3" title="Figure 6-2Shared contexts attached to the same drawable object"></a><p><strong>Figure 6-2&nbsp;&nbsp;</strong>Shared contexts attached to the same drawable object</p><img src = "../art/shared_state_one_object.jpg" alt = "Shared contexts attached to the same drawable object" ></div><br/><p>When you create an OpenGL context you can designate a second context to share object resources. All sharing is peer to peer. Shared resources are reference-counted and thus are maintained until explicitly released or when the last context sharing resource is released. </p><p>Not every context can be shared with every other context. Much depends on ensuring that the same set of renderers supports both contexts. You can meet this requirement by ensuring each context uses the same virtual screen list, using either of the following techniques:</p><ul class="ul"><li class="li"><p>Use the same pixel format object to create all the rendering contexts that you want to share.</p></li><li class="li"><p>Create pixel format objects using attributes that narrow down the choice to a single display. This practice ensures that the virtual screen is identical for each pixel format object. </p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW2" title="Figure 6-3Shared contexts and more than one drawable object"></a><p><strong>Figure 6-3&nbsp;&nbsp;</strong>Shared contexts and more than one drawable object</p><img src = "../art/shared_state_objects.jpg" alt = "Shared contexts and more than one drawable object" ></div><br/><p>Setting up shared rendering contexts is very straightforward. Each Apple-specific OpenGL API provides functions with an option to specify a context to share in its context creation routine.</p><ul class="ul"><li class="li"><p>Use the <code>share</code> argument for the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/initWithFormat:shareContext:" target="_top">initWithFormat:shareContext:</a></code> method of the <code>NSOpenGLContext</code> class. See <span class="content_text"><a href="opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW13">Listing 6-12</a></span>.</p></li><li class="li"><p>Use the <code>share</code> parameter for the function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglCreateContext" target="_top">aglCreateContext</a></code>. See <span class="content_text"><a href="opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW6">Listing 6-13</a></span>.</p></li><li class="li"><p>Use the <code>share</code> parameter for the function <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/c/func/CGLCreateContext" target="_top">CGLCreateContext</a></code>. See <span class="content_text"><a href="opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW16">Listing 6-14</a></span>.</p></li></ul><p><span class="content_text">Listing 6-12</span> ensures the same virtual screen list by using the same pixel format object for each of the shared contexts.</p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW13" title="Listing 6-12Setting up an NSOpenGLContext object for sharing"></a><p class="codesample"><strong>Listing 6-12&nbsp;&nbsp;</strong>Setting up an NSOpenGLContext object for sharing</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Cocoa/Cocoa.h><span></span></pre></td></tr><tr><td scope="row"><pre>+ (NSOpenGLPixelFormat*)defaultPixelFormat<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> NSOpenGLPixelFormatAttribute attributes [] = {<span></span></pre></td></tr><tr><td scope="row"><pre>                    NSOpenGLPFADoubleBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                    (NSOpenGLPixelFormatAttribute)nil };<span></span></pre></td></tr><tr><td scope="row"><pre>return [[(NSOpenGLPixelFormat *)[NSOpenGLPixelFormat alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                        initWithAttributes:attribs] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSOpenGLContext*)openGLContextWithShareContext:(NSOpenGLContext*)context<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>     if (_openGLContext == NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>            _openGLContext = [[NSOpenGLContext alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                    initWithFormat:[[self class] defaultPixelFormat]<span></span></pre></td></tr><tr><td scope="row"><pre>                    shareContext:context];<span></span></pre></td></tr><tr><td scope="row"><pre>        [_openGLContext makeCurrentContext];<span></span></pre></td></tr><tr><td scope="row"><pre>        [self prepareOpenGL];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>    return _openGLContext;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)prepareOpenGL<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>     // Your code here to initialize the OpenGL state<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 6-13</span> sets up two pixel formats objects—<code>aglPixFmt</code> and <code>aglPixFmt2</code>—that share the same display.</p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW6" title="Listing 6-13Getting the same virtual screen list with different attributes"></a><p class="codesample"><strong>Listing 6-13&nbsp;&nbsp;</strong>Getting the same virtual screen list with different attributes</p><div class="codesample"><table><tr><td scope="row"><pre>GLint attrib[] = {AGL_RGBA, AGL_DOUBLEBUFFER, AGL_FULL_SCREEN, AGL_NONE};<span></span></pre></td></tr><tr><td scope="row"><pre>GLint attrib2[] = {AGL_RGBA, AGL_DOUBLEBUFFER, AGL_NONE};<span></span></pre></td></tr><tr><td scope="row"><pre>disp = GetMainDevice();<span></span></pre></td></tr><tr><td scope="row"><pre>aglPixFmt = aglChoosePixelFormat(&amp;disp, 1, attrib);<span></span></pre></td></tr><tr><td scope="row"><pre>aglContext = aglCreateContext(aglPixFmt, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>//Use same display<span></span></pre></td></tr><tr><td scope="row"><pre>aglPixFmt2 = aglChoosePixelFormat (&amp;disp, 1, attrib2);<span></span></pre></td></tr><tr><td scope="row"><pre>aglContext2 = aglCreateContext(aglPixFmt2, aglContext);<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 6-14</span> ensures the same virtual screen list by using the same pixel format object for each of the shared contexts. </p><a name="//apple_ref/doc/uid/TP40001987-CH216-SW16" title="Listing 6-14Setting up a CGL context for sharing"></a><p class="codesample"><strong>Listing 6-14&nbsp;&nbsp;</strong>Setting up a CGL context for sharing</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;OpenGL/OpenGL.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGLPixelFormatAttribute attrib[] = {kCGLPFADoubleBuffer, 0};<span></span></pre></td></tr><tr><td scope="row"><pre>CGLPixelFormatObj pixelFormat = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>long numPixelFormats = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLContextObj cglContext1 = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLContextObj cglContext2 = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLChoosePixelFormat (attribs, &amp;pixelFormat, &amp;numPixelFormats);<span></span></pre></td></tr><tr><td scope="row"><pre>CGLCreateContext(pixelFormat, NULL, &amp;cglContext1);<span></span></pre></td></tr><tr><td scope="row"><pre>CGLCreateContext(pixelFormat, cglContext1, &amp;cglContext2);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH216-SW34" title="See Also"></a><h2>See Also</h2><p>OpenGL sample code projects (<span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxOpenGL-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000549" target="_top">Sample Code > Graphics &amp; Imaging > OpenGL</a></span>):</p><ul class="ul"><li class="li"><p><em><a href="../../../../../samplecode/GLCarbon1ContextPbuffer/index.html#//apple_ref/doc/uid/DTS10003144" target="_top">GLCarbon1ContextPbuffer</a></em> demonstrates using a single shared rendering context with OpenGL pixel buffer objects.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_general/opengl_gen_tasks.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_pixelformats/opengl_pixelformats.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_contexts/opengl_contexts.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_contexts/opengl_contexts.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_contexts/opengl_contexts.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>