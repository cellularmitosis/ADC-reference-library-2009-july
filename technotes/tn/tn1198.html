<HTML><!--This file created 6/17/2002 4:46 PM by Claris Home Page version 3.0--><HEAD>   <title>Technical Note TN1198: SndPlayDoubleBuffer and Carbon</title>   <META NAME=GENERATOR CONTENT="Claris Home Page 3.0">   <X-CLARIS-WINDOW TOP=42 BOTTOM=755 LEFT=4 RIGHT=746>   <X-CLARIS-TAGVIEW MODE=full><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><meta name="keywords" content="SndPlayDoubleBuffer, Carbon, CarbonLib, Sound, SoundManager, Sound Input Manager, Carbonizing"><meta name="Description" content="Technical Note TN1198: This Technote          describes theremoval of the SndPlayDoubleBuffer and other APIs from the         Carbon API set and what can be done to make existingsound          code based on these now defunct APIs Carboncompatible."><meta name="categories" content="Sound"><meta name="week-posted" content="Jun 10, 2002 - Jun 14, 2002"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003037" title="SndPlayDoubleBuffer and Carbon"></a><P><A NAME=top></A> <!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxMusicAudio-date.html" target="_blank">Carbon > Audio</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --> <!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1198</div>
<div id="pageheadsub">SndPlayDoubleBuffer and Carbon</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --></P><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600>   <TR>      <td align="left">         <P><!-- begin_header_box -->         <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=600>            <TR>               <td valign=top width=300 align=left>                  <P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=300>                     <TR>                        <td width=300 align=left>                           <P><img src="images/tnmenutop.gif" width=300 height=7 align=bottom></P>                        </TD>                     </TR>                     <TR BGCOLOR="#E6E6E6">                        <td background="images/tnmenubody.gif" width=300 align=left>                           <P><span id="menutitle"> CONTENTS<BR>                           <BR></span></P>                        </TD>                     </TR>                     <TR BGCOLOR="#E6E6E6">                        <td background="images/tnmenubody.gif" width=300 align=left>                           <P><!-- begin_toc --></P>                                                      <P id=menutext><A HREF="#APIs">The loss of                           the APIs</A><BR>                           <BR>                           <A HREF="#Removed">Why the were                           removed</A><BR>                           <BR>                           <A HREF="#Did">What they did and how they                           can be replaced</A><BR>                           <BR>                           <A HREF="#SndStartFilePlay"><CODE>SndStartFilePlay</CODE></A><BR>                           <BR>                           <A HREF="#SndRecordToFile"><CODE>SndRecordToFile</CODE>                           and <CODE>SPBRecordToFile</CODE></A><BR>                           <BR>                           <A HREF="#Summary">Summary</A><BR>                           <BR>                           <A HREF="#References">References</A><BR>                           <BR>                           <A HREF="#Downloads">Downloadables</A></P>                        </TD>                     </TR>                     <TR>                        <td width=300 align=left>                           <P><img src="images/tnmenubottom.gif" width=300 height=16 align=bottom></P>                        </TD>                     </TR>                  </TABLE>                  </P>               </TD>               <td valign=top width=300 align=left>                  <P><!-- begin_intro_text --></P>                                    <P id=introtext>This Technote is directed at                  application developers who have code that calls                  functions that are not in the Carbon Sound Manager                  and who want to move that code over to Carbon.</P>                                    <P><!-- end_intro_text --> <!-- begin_date --></P>                                    <H3><CENTER>[Jun 18 2002]</CENTER></H3>                                    <P><!-- end_date --></P>               </TD>            </TR>         </TABLE>          <!-- end_header_box --><BR>         <BR>                  <hr width=500 align=center>                  <BR>         <BR>         <!-- begin_content --> <A NAME=APIs></A></P>                  <H2>The loss of the APIs</H2>                  <P><BR>         These sound functions are not in Carbon:</P>                  <UL>            <LI><CODE>SndControl</CODE></LI>                        <LI><CODE>SndStartFilePlay</CODE></LI>                        <LI><CODE>SndPauseFilePlay</CODE></LI>                        <LI><CODE>SndStopFilePlay</CODE></LI>                        <LI><CODE>SndPlayDoubleBuffer</CODE></LI>                        <LI><CODE>MACEVersion</CODE></LI>                        <LI><CODE>Comp3to1</CODE></LI>                        <LI><CODE>Exp1to3</CODE></LI>                        <LI><CODE>Comp6to1</CODE></LI>                        <LI><CODE>Exp1to6</CODE></LI>                        <LI><CODE>AudioGetVolume</CODE></LI>                        <LI><CODE>AudioSetVolume</CODE></LI>                        <LI><CODE>AudioGetMute</CODE></LI>                        <LI><CODE>AudioSetMute</CODE></LI>                        <LI><CODE>AudioSetToDefaults</CODE></LI>                        <LI><CODE>AudioGetInfo</CODE></LI>                        <LI><CODE>AudioGetBass</CODE></LI>                        <LI><CODE>AudioSetBass</CODE></LI>                        <LI><CODE>AudioGetTreble</CODE></LI>                        <LI><CODE>AudioSetTreble</CODE></LI>                        <LI><CODE>AudioGetOutputDevice</CODE></LI>                        <LI><CODE>AudioMuteOnEvent</CODE></LI>                        <LI><CODE>SndRecordToFile</CODE></LI>                        <LI><CODE>SPBRecordToFile</CODE></LI>         </UL>                  <P>These <CODE>SndCommand</CODE> numbers are not supported         by the Carbon Sound Manager:</P>                  <UL>            <LI><CODE>initCmd</CODE></LI>                        <LI><CODE>freeCmd</CODE></LI>                        <LI><CODE>totalLoadCmd</CODE></LI>                        <LI><CODE>loadCmd</CODE></LI>                        <LI><CODE>freqDurationCmd</CODE></LI>                        <LI><CODE>restCmd</CODE></LI>                        <LI><CODE>freqCmd</CODE></LI>                        <LI><CODE>ampCmd</CODE></LI>                        <LI><CODE>timbreCmd</CODE></LI>                        <LI><CODE>getAmpCmd</CODE></LI>                        <LI><CODE>waveTableCmd</CODE></LI>                        <LI><CODE>phaseCmd</CODE></LI>                        <LI><CODE>rateCmd</CODE></LI>                        <LI><CODE>continueCmd</CODE></LI>                        <LI><CODE>doubleBufferCmd</CODE></LI>                        <LI><CODE>getRateCmd</CODE></LI>                        <LI><CODE>sizeCmd /*obsolete command*/</CODE></LI>                        <LI><CODE>convertCmd /*obsolete MACE            command*/</CODE></LI>         </UL>                  <P>If you have code that relies on any of the above calls or         <CODE>SndCommands</CODE>, you will have to rewrite it if you         want to make your application Carbon compatible. This Note         will describe how to duplicate the functionality of these         APIs with Carbon-compatible code.</P>                  <P><BR>         </P>                  <P><A HREF="#top">Back to top</A></P>                  <P><BR>         <A NAME=Removed></A></P>                  <H2>Why they were removed</H2>                  <P><BR>         The low-level calls were removed because there are better,         more compatible, ways of accomplishing what these calls         accomplished. In some cases, the calls had ceased to be         useful so their removal should not affect any modern code         base.</P>                  <P>The high-level calls, <CODE>SndStartFilePlay</CODE>,         <CODE>SPBRecordToFile</CODE>, etc., were removed because         their functionality is largely subsumed by QuickTime. Using         QuickTime in place of these routines should increase the         functionality of your program (for instance, you will be         able to play a more varied list of sound files) without         adding much work or code to your existing code base.</P>                  <P>The <CODE>SndCommands</CODE> were removed because they         either operate on non-wave data which is no long supported,         or there are newer <CODE>SndCommands</CODE> that supercede         their functionality.</P>                  <P><BR>         </P>                  <P><A HREF="#top">Back to top</A></P>                  <P><BR>         <A NAME=Did></A></P>                  <H2>What they did and how they can be replaced</H2>                  <P>This is a brief description of what these functions did         in the past and how they can be replaced in Carbon. For a         complete description, see <A href="../../documentation/mac/Sound/Sound-2.html">Inside         Macintosh: Sound.</A></P>                  <UL>            <LI><CODE>SndControl</CODE>                        <UL>               <LI>In Sound Manager 2.0 this returned information               about the sound hardware.</LI>                              <LI>This call was made obsolete by Sound Manager 3.0               and should be replaced by calls to               <CODE>Gestalt</CODE>.</LI>            </UL>            </LI>                        <LI><CODE>SndStartFilePlay</CODE>                        <UL>               <LI>Starts a file playing from disk. This function is               basically a wrapper around               <CODE>SndPlayDoubleBuffer</CODE>.</LI>                              <LI>Can be mimicked with QuickTime.</LI>            </UL>            </LI>                        <LI><CODE>SndPauseFilePlay</CODE>                        <UL>               <LI>Toggles the playing state of a file that is being               played by <CODE>SndStartFilePlay</CODE>.</LI>                              <LI>When using QuickTime, use QuickTime's control               commands.</LI>            </UL>            </LI>                        <LI><CODE>SndStopFilePlay</CODE>                        <UL>               <LI>Stops a sound that is being played by               <CODE>SndStartFilePlay</CODE>.</LI>                              <LI>When using QuickTime, use QuickTime's control               commands.</LI>            </UL>            </LI>                        <LI><CODE>SndPlayDoubleBuffer</CODE>                        <UL>               <LI>Plays a sound by first playing one buffer of audio               and then a second.</LI>                              <LI>Can be mimicked with <CODE>bufferCmd</CODE> and               <CODE>callBackCmd</CODE>, or to some extent,               QuickTime.</LI>            </UL>            </LI>                        <LI><CODE>MACEVersion</CODE>                        <UL>               <LI>Gets the version of the MACE               compressor/decompressor.</LI>                              <LI>This call should never be needed. The current               version of MACE is 1.0.2 and it hasn't changed in               years.</LI>            </UL>            </LI>                        <LI><CODE>Comp3to1</CODE>                        <UL>               <LI>Compresses a sound with MACE 3:1.</LI>                              <LI>Can be replaced with the appropriate calls to the               <CODE>SoundConverter</CODE> APIs.</LI>            </UL>            </LI>                        <LI><CODE>Exp1to3</CODE>                        <UL>               <LI>Decompresses a sound compressed with MACE               3:1.</LI>                              <LI>Can be replaced with the appropriate calls to the               <CODE>SoundConverter</CODE> APIs.</LI>            </UL>            </LI>                        <LI><CODE>Comp6to1</CODE>                        <UL>               <LI>Compresses a sound with MACE 6:1.</LI>                              <LI>Can be replaced with the appropriate calls to the               <CODE>SoundConverter</CODE> APIs.</LI>            </UL>            </LI>                        <LI><CODE>Exp1to6</CODE>                        <UL>               <LI>Decompresses a sound compressed with MACE               6:1.</LI>                              <LI>Can be replaced with the appropriate calls to the               <CODE>SoundConverter</CODE> APIs.</LI>            </UL>            </LI>                        <LI><CODE>AudioGetVolume</CODE>                        <UL>               <LI>Called by the Sound Manager to get an output               component's volume.</LI>                              <LI>Can be replaced with               <CODE>SoundComponentGetInfo</CODE> and the               <CODE>siHardwareVolume</CODE> selector.</LI>            </UL>            </LI>                        <LI><CODE>AudioSetVolume</CODE>                        <UL>               <LI>Called by the Sound Manager to set an output               component's volume.</LI>                              <LI>Can be replaced with               <CODE>SoundComponentSetInfo</CODE> and the               <CODE>siHardwareVolume</CODE> selector.</LI>            </UL>            </LI>                        <LI><CODE>AudioGetMute</CODE>                        <UL>               <LI>Called by the Sound Manager to get the mute state               of an output component.</LI>                              <LI>Can be replaced with               <CODE>SoundComponentGetInfo</CODE> and the               <CODE>siHardwareMute</CODE> selector.</LI>            </UL>            </LI>                        <LI><CODE>AudioSetMute</CODE>                        <UL>               <LI>Called by the Sound Manager to set the mute state               of an output component.</LI>                              <LI>Can be replaced with               <CODE>SoundComponentSetInfo</CODE> and the               <CODE>siHardwareMute</CODE> selector.</LI>            </UL>            </LI>                        <LI><CODE>AudioSetToDefaults</CODE>                        <UL>               <LI>Called by the Sound Manager to return an output               component to its defaults.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>                        <LI><CODE>AudioGetInfo</CODE>                        <UL>               <LI>Called by the Sound Manager to get information               about an output component.</LI>                              <LI>Can be replaced with calls to               <CODE>SoundComponentGetInfo</CODE> and the appropriate               selectors.</LI>            </UL>            </LI>                        <LI><CODE>AudioGetBass</CODE>                        <UL>               <LI>Called by the Sound Manager to get an output               component's bass volume.</LI>                              <LI>Can be replaced with               <CODE>SoundComponentGetInfo</CODE> and the               <CODE>siHardwareBass</CODE> selector.</LI>            </UL>            </LI>                        <LI><CODE>AudioSetBass</CODE>                        <UL>               <LI>Called by the Sound Manager to set an output               component's bass volume.</LI>                              <LI>Can be replaced with               <CODE>SoundComponentSetInfo</CODE> and the               <CODE>siHardwareBass</CODE> selector.</LI>            </UL>            </LI>                        <LI><CODE>AudioGetTreble</CODE>                        <UL>               <LI>Called by the Sound Manager to get an output               component's treble volume.</LI>                              <LI>Can be replaced with               <CODE>SoundComponentGetInfo</CODE> and the               <CODE>siHardwareTreble</CODE> selector.</LI>            </UL>            </LI>                        <LI><CODE>AudioSetTreble</CODE>                        <UL>               <LI>Called by the Sound Manager to set an output               component's treble volume.</LI>                              <LI>Can be replaced with               <CODE>SoundComponentSetInfo</CODE> and the               <CODE>siHardwareTreble</CODE> selector.</LI>            </UL>            </LI>                        <LI><CODE>AudioGetOutputDevice</CODE>                        <UL>               <LI>Not documented.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>                        <LI><CODE>AudioMuteOnEvent</CODE>                        <UL>               <LI>Not documented.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>                        <LI><CODE>SndRecordToFile</CODE>                        <UL>               <LI>Records sound data to a file in a synchronous               operation.</LI>                              <LI>Can be mimicked with QuickTime using the Sequence               Grabber Component.</LI>            </UL>            </LI>                        <LI><CODE>SPBRecordToFile</CODE>                        <UL>               <LI>Records sound data to a file, optionally doing it               asynchronously.</LI>                              <LI>Can be mimicked with appropriate calls               <CODE>SPBRecord</CODE> and <CODE>PBWriteAsync</CODE>               for the asynchronous case. QuickTime Sequence Grabber               Component can also be used to replace it.</LI>            </UL>            </LI>         </UL>                  <P>&nbsp;</P>                  <UL>            <LI><CODE>initCmd</CODE>                        <UL>               <LI>Not documented.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>                        <LI><CODE>freeCmd</CODE>                        <UL>               <LI>Not documented.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>                        <LI><CODE>totalLoadCmd</CODE>                        <UL>               <LI>Sent using the obsolete <CODE>SndControl</CODE>               function, it reported the total CPU load factor for               all existing sound activity.</LI>                              <LI>No replacement, but it was not accurate or useful               starting with Sound Manager 3.1.</LI>            </UL>            </LI>                        <LI><CODE>loadCmd</CODE>                        <UL>               <LI>Sent using the obsolete <CODE>SndControl</CODE>               function, it reported the percentage of CPU processing               power that the sound channel would require.</LI>                              <LI>No replacement, but it was not accurate or useful               starting with Sound Manager 3.1.</LI>            </UL>            </LI>                        <LI><CODE>freqDurationCmd</CODE>                        <UL>               <LI>Play the note specified in <CODE>param2</CODE> for               the duration specified in <CODE>param1</CODE>.</LI>                              <LI>Replace the pitch shift functionality with               <CODE>rateMultiplierCmd</CODE>.</LI>            </UL>            </LI>                        <LI><CODE>freqCmd</CODE>                        <UL>               <LI>Change the frequency (or pitch) of a sound. Could               be used to loop a sampled-sound data sound installed               with a <CODE>soundCmd</CODE>.</LI>                              <LI>Replace the pitch shift and duration functionality               with <CODE>rateMultiplierCmd</CODE>. You can no longer               loop a sound. To loop a sound play it over and over               again using <CODE>bufferCmd</CODE> and               <CODE>callBackCmd</CODE>.</LI>            </UL>            </LI>                        <LI><CODE>restCmd</CODE>                        <UL>               <LI>Rest a channel for a specified duration.</LI>                              <LI>No replacement as square wave data sound and wave               table data sound are not supported by the Carbon Sound               Manager.</LI>            </UL>            </LI>                        <LI><CODE>ampCmd</CODE>                        <UL>               <LI>Change the amplitude (or loudness) of a               sound.</LI>                              <LI>Use <CODE>volumeCmd</CODE> instead.</LI>            </UL>            </LI>                        <LI><CODE>timbreCmd</CODE>                        <UL>               <LI>Change the timbre (or tone) of a sound currently               being defined using square-wave data.</LI>                              <LI>No replacement as square wave data sound and wave               table data sound are not supported by the Carbon Sound               Manager.</LI>            </UL>            </LI>                        <LI><CODE>getAmpCmd</CODE>                        <UL>               <LI>Determine the current amplitude (or loudness) of a               sound.</LI>                              <LI>Use <CODE>volumeCmd</CODE> instead.</LI>            </UL>            </LI>                        <LI><CODE>waveTableCmd</CODE>                        <UL>               <LI>Install a wave table as a voice in the specified               channel.</LI>                              <LI>No replacement as wave table data sound are not               supported by the Carbon Sound Manager.</LI>            </UL>            </LI>                        <LI><CODE>phaseCmd</CODE>                        <UL>               <LI>Not documented.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>                        <LI><CODE>rateCmd</CODE>                        <UL>               <LI>Set the rate of a sampled sound that is currently               playing, thus effectively altering its pitch and               duration.</LI>                              <LI>Use <CODE>rateMultiplierCmd</CODE> instead.</LI>            </UL>            </LI>                        <LI><CODE>continueCmd</CODE>                        <UL>               <LI>Not documented.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>                        <LI><CODE>doubleBufferCmd</CODE>                        <UL>               <LI>This is the command used by               <CODE>SndPlayDoubleBuffer</CODE>.</LI>                              <LI>This is the command used by               <CODE>SndPlayDoubleBuffer</CODE>. No direct               replacement. You can use <CODE>bufferCmd</CODE> and               <CODE>callBackCmd</CODE> to simulate, see <A HREF="#ReplacingSndPlayDoubleBuffer">Replacing               <CODE>SndPlayDoubleBuffer</CODE></A> below.</LI>            </UL>            </LI>                        <LI><CODE>getRateCmd</CODE>                        <UL>               <LI>Determine the sample rate of the sampled sound               currently playing.</LI>                              <LI>Use <CODE>getRateMultiplierCmd</CODE>               instead.</LI>            </UL>            </LI>                        <LI><CODE>sizeCmd /*obsolete command*/</CODE>                        <UL>               <LI>Not documented.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>                        <LI><CODE>convertCmd /*obsolete MACE command*/</CODE>                        <UL>               <LI>Not documented.</LI>                              <LI>No replacement.</LI>            </UL>            </LI>         </UL>                  <P><BR>         </P>                  <P><A HREF="#top">Back to top</A></P>                  <P><BR>         <A NAME=ReplacingSndPlayDoubleBuffer></A></P>                  <H2>Replacing SndPlayDoubleBuffer</H2>                  <P>Replacing <CODE>SndPlayDoubleBuffer</CODE> is a bit         tricky because of the subtle ways it does its work.         Replacing it a simple stream of <CODE>bufferCmd</CODE>s and         <CODE>callBackCmd</CODE>s does not do exactly the same thing         for code that was expecting the real         <CODE>SndPlayDoubleBuffer</CODE>.</P>                  <P>This is because the real <CODE>SndPlayDoubleBuffer</CODE>         call is a single command in the sound channel's queue, a         <CODE>doubleBufferCmd</CODE>, but the replacement is two         commands. Furthermore, the <CODE>doubleBufferCmd</CODE>         stays in the channel's queue until the sound is done         playing, but the <CODE>bufferCmd</CODE> and         <CODE>callBackCmd</CODE> are constantly being added and         removed. This is an issue for any commands that might be         waiting in the queue after the <CODE>doubleBufferCmd</CODE>         and the code that relies on those commands being after the         <CODE>doubleBufferCmd</CODE>. This doesn't immediately kill         the prospect of simulating <CODE>SndPlayDoubleBuffer</CODE>,         but it means that the work is a little more complicated for         the simulating code.</P>                  <P>The first issue is that information about the currently         playing sound will need to be kept for each sound channel.         This information is kept by the Sound Manager when using the         real <CODE>SndPlayDoubleBuffer</CODE>.</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>// Structsstruct PerChanInfo {    QElemPtr             qLink;    /* next queue entry */    short                qType;    /* queue type = 0 */    short                stopping;    #if DEBUG        OSType           magic;    #endif    SndCallBackUPP        usersCallBack;    SndDoubleBufferHeader theParams;    CmpSoundHeader        soundHeader;};typedef struct PerChanInfo   PerChanInfo;typedef struct PerChanInfo * PerChanInfoPtr;// Globals    Boolean              gNMRecBusy;    NMRecPtr             gNMRecPtr;    QHdrPtr              gFreeList;    Ptr                  gSilenceTwos;    Ptr                  gSilenceOnes;</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         </P>                  <P>The queue structure is used to keep track of the         per-channel sound information, such as the format of the         sound, the parameters to <CODE>SndPlayDoubleBuffer</CODE>,         the callback function that was originally in the sound         channel (before the simulating code users it for its own         use) and some housekeeping information. This queue structure         will allow us to enqueue the channel information using         <CODE>PBEnqueue</CODE> at interrupt time so that at task         time we can dispose of the per-channel structure and         associated memory.</P>                  <P>The simulation has to set up its simple state machine and         the first buffer of sound has to be played. That code looks         like this:</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>// This function is only callable at system task time.//    Note: CarbonSndPlayDoubleBuffer calls NewPtrClear,//          which is only callable at system task time,//          this means that CarbonSndPlayDoubleBuffer itself//          is only callable at system task time.OSErr CarbonSndPlayDoubleBuffer (SndChannelPtr chan,  SndDoubleBufferHeaderPtr theParams) {    OSErr                            err;    CompressionInfo                  compInfo;    PerChanInfoPtr                   perChanInfoPtr;    SndCommand                       playCmd;    SndCommand                       callBack;    if (chan == nil) {        err = badChannel;        goto exit;    }    if (theParams == nil) {        err = paramErr;        goto exit;    }    if (gFreeList == nil) {        // This can't ever be disposed since we don't know when        // we might need to use it (at interrupt time)        gFreeList = (QHdrPtr)NewPtrClear (sizeof (QHdr));        err = MemError ();        if (noErr != err) goto exit;    }    if (gSilenceOnes == nil) {        short        i;        // This can't ever be disposed since we don't know when        // we might need to use it (at interrupt time)        gSilenceOnes = NewPtr (kBufSize);        err = MemError ();        if (noErr != err) goto exit;        for (i = 0; i &lt; kBufSize; i++) {            gSilenceOnes[i] = (char)0x80;        }    }    if (gSilenceTwos == nil) {        // This can't ever be disposed since we don't know when        // we might need to use it (at interrupt time)        gSilenceTwos = NewPtrClear (kBufSize);        err = MemError ();        if (noErr != err) goto exit;    }    if (gNMRecPtr == nil) {        // This can't ever be disposed since we don't know when        // we might need to use it (at interrupt time)        gNMRecPtr = (NMRecPtr)NewPtr (sizeof (NMRec));        err = MemError ();        if (noErr != err) goto exit;        // Set up our NMProc info that will dispose of most        // (but not all) of our memory        gNMRecPtr-&gt;qLink = nil;        gNMRecPtr-&gt;qType = 8;        gNMRecPtr-&gt;nmFlags = 0;        gNMRecPtr-&gt;nmPrivate = 0;        gNMRecPtr-&gt;nmReserved = 0;        gNMRecPtr-&gt;nmMark = nil;        gNMRecPtr-&gt;nmIcon = nil;        gNMRecPtr-&gt;nmSound = nil;        gNMRecPtr-&gt;nmStr = nil;        gNMRecPtr-&gt;nmResp = NewNMProc (NMResponseProc);        gNMRecPtr-&gt;nmRefCon = 0;    }    perChanInfoPtr = (PerChanInfoPtr)NewPtr (sizeof (PerChanInfo));    err = MemError ();    if (noErr != err) goto exit;    // Init basic per channel information    perChanInfoPtr-&gt;qLink = nil;    perChanInfoPtr-&gt;qType = 0;                // not used    perChanInfoPtr-&gt;stopping = 0;    #if DEBUG        perChanInfoPtr-&gt;magic = 'SANE';    #endif    perChanInfoPtr-&gt;theParams = *theParams;    // Have to remember the user's callback function from the sound because    // we are going to overwrite it with our own callback function.    perChanInfoPtr-&gt;usersCallBack = chan-&gt;callBack;    // Set up the sound header for the bufferCmd that will be used to play    // the buffers passed in by the SndPlayDoubleBuffer call.    perChanInfoPtr-&gt;soundHeader.samplePtr =         (Ptr)(theParams-&gt;dbhBufferPtr[0]-&gt;dbSoundData);    perChanInfoPtr-&gt;soundHeader.numChannels =         theParams-&gt;dbhNumChannels;    perChanInfoPtr-&gt;soundHeader.sampleRate =         theParams-&gt;dbhSampleRate;    perChanInfoPtr-&gt;soundHeader.loopStart = 0;    perChanInfoPtr-&gt;soundHeader.loopEnd = 0;    perChanInfoPtr-&gt;soundHeader.encode = cmpSH;    perChanInfoPtr-&gt;soundHeader.baseFrequency = kMiddleC;    perChanInfoPtr-&gt;soundHeader.numFrames =         (unsigned long)theParams-&gt;dbhBufferPtr[0]-&gt;dbNumFrames;    //    perChanInfoPtr-&gt;soundHeader.AIFFSampleRate = 0;          // unused    perChanInfoPtr-&gt;soundHeader.markerChunk = nil;    perChanInfoPtr-&gt;soundHeader.futureUse2 = nil;    perChanInfoPtr-&gt;soundHeader.stateVars = nil;    perChanInfoPtr-&gt;soundHeader.leftOverSamples = nil;    perChanInfoPtr-&gt;soundHeader.compressionID =         theParams-&gt;dbhCompressionID;    perChanInfoPtr-&gt;soundHeader.packetSize =         (unsigned short)theParams-&gt;dbhPacketSize;    perChanInfoPtr-&gt;soundHeader.snthID = 0;    perChanInfoPtr-&gt;soundHeader.sampleSize =         (unsigned short)theParams-&gt;dbhSampleSize;    perChanInfoPtr-&gt;soundHeader.sampleArea[0] = 0;    // Is the sound compressed?  If so, we need to treat    // theParams as a SndDoubleBufferHeader2Ptr.    if (theParams-&gt;dbhCompressionID != 0 ) {        // Sound is compressed        err = GetCompressionInfo (theParams-&gt;dbhCompressionID,               ((SndDoubleBufferHeader2Ptr)theParams)-&gt;dbhFormat,               theParams-&gt;dbhNumChannels,               theParams-&gt;dbhSampleSize,               &amp;compInfo);        if (noErr != err) goto exitDispose;        perChanInfoPtr-&gt;soundHeader.format = compInfo.format;    } else {        // Sound is not compressed        perChanInfoPtr-&gt;soundHeader.format = kSoundNotCompressed;    }    playCmd.cmd = bufferCmd;    playCmd.param1 = 0;          // unused    playCmd.param2 = (long)&amp;perChanInfoPtr-&gt;soundHeader;    callBack.cmd = callBackCmd;    callBack.param1 = 0;          // which buffer to fill, 0 buffer, 1, 0, ...    callBack.param2 = (long)perChanInfoPtr;    // Install our callback function pointer straight into    // the sound channel structure    if (gCarbonSndPlayDoubleBufferCallBackUPP == nil) {        gCarbonSndPlayDoubleBufferCallBackUPP =             NewSndCallBackProc (CarbonSndPlayDoubleBufferCallBackProc);    }    chan-&gt;callBack = gCarbonSndPlayDoubleBufferCallBackUPP;    if (gCarbonSndPlayDoubleBufferCleanUpUPP == nil) {        #if !TARGET_API_MAC_CARBON            gCarbonSndPlayDoubleBufferCleanUpUPP =                 NewSndCallBackProc (CarbonSndPlayDoubleBufferCleanUpProc);        #endif    }    err = SndDoCommand (chan, &amp;playCmd, true);    if (noErr != err) goto exitDispose;    err = SndDoCommand (chan, &amp;callBack, true);    if (noErr != err) goto exitDispose;exit:    return err;exitDispose:    if (perChanInfoPtr != nil)        DisposePtr ((Ptr)perChanInfoPtr);    goto exit;}</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         </P>                  <P>In Carbon there is no UPP for the         <CODE>SndDoubleBackProc</CODE>, but that's OK. Since all         code in Carbon is PowerPC, and this code will be compiled         into the calling program (therefore not needing to worry         about CFM&lt;-&gt;Mach-O calling conventions) the         <CODE>SndDoubleBackProc</CODE> will just be treated as a         regular C function pointer.</P>                  <P>The callback function that tells the user's code to         refill the now empty buffer and begins playing the alternate         buffer looks like this:</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>static pascal void    CarbonSndPlayDoubleBufferCallBackProc               (SndChannelPtr theChannel, SndCommand * theCallBackCmd) {    SndDoubleBufferHeaderPtr        theParams;    SndDoubleBufferPtr                emptyBuf;    SndDoubleBufferPtr                nextBuf;    PerChanInfoPtr                    perChanInfoPtr;    SndCommand                        playCmd;    perChanInfoPtr = (PerChanInfoPtr)(theCallBackCmd-&gt;param2);    #if DEBUG        if (perChanInfoPtr-&gt;magic != 'SANE')                    DebugStr("\pBAD in CarbonSndPlayDoubleBufferCallBackProc");    #endif    if (perChanInfoPtr-&gt;stopping == true) goto exit;    theParams = &amp;(perChanInfoPtr-&gt;theParams);    // The buffer that just played and needs to be filled    emptyBuf = theParams-&gt;dbhBufferPtr[theCallBackCmd-&gt;param1];    // Clear the ready flag    emptyBuf-&gt;dbFlags ^= dbBufferReady;    // This is the buffer to play now    nextBuf = theParams-&gt;dbhBufferPtr[!theCallBackCmd-&gt;param1];    // Check to see if it is ready, or if we have to wait a bit    if (nextBuf-&gt;dbFlags &amp; dbBufferReady) {         perChanInfoPtr-&gt;soundHeader.numFrames = (unsigned long)nextBuf-&gt;dbNumFrames;         perChanInfoPtr-&gt;soundHeader.samplePtr = (Ptr)(nextBuf-&gt;dbSoundData);         // Flip the bit telling us which buffer is next         theCallBackCmd-&gt;param1 = !theCallBackCmd-&gt;param1;         // If this isn't the last buffer, call the user's fill routine         if (!(nextBuf-&gt;dbFlags &amp; dbLastBuffer)) {            #if TARGET_API_MAC_CARBON              // Declare a function pointer to the user's double back proc              void (*doubleBackProc)(SndChannel*, SndDoubleBuffer*);               // Call user's double back proc              doubleBackProc = (void*)theParams-&gt;dbhDoubleBack;              (*doubleBackProc) (theChannel, emptyBuf);            #else              CallSndDoubleBackProc (theParams-&gt;dbhDoubleBack, theChannel, emptyBuf);            #endif        } else {            // Call our clean up proc when the last buffer finishes            theChannel-&gt;callBack = gCarbonSndPlayDoubleBufferCleanUpUPP;        }    } else {        // We have to wait for the buffer to become ready.        // The real SndPlayDoubleBuffer would play a short bit of silence        // waiting for the user to read the audio from disk,        // so that's what we do here.        #if DEBUG            DebugStr ("\p buffer is not ready!");        #endif        // Play a short section of silence so that we can check the        // ready flag again        if (theParams-&gt;dbhSampleSize == 8) {            perChanInfoPtr-&gt;soundHeader.numFrames =                   (UInt32)(kBufSize / theParams-&gt;dbhNumChannels);            perChanInfoPtr-&gt;soundHeader.samplePtr = gSilenceOnes;        } else {            perChanInfoPtr-&gt;soundHeader.numFrames =                   (UInt32)(kBufSize / (theParams-&gt;dbhNumChannels *                   (theParams-&gt;dbhSampleSize / 8)));            perChanInfoPtr-&gt;soundHeader.samplePtr = gSilenceTwos;        }    }    // Insert our callback command    InsertSndDoCommand (theChannel, theCallBackCmd);    // Play the next buffer    playCmd.cmd = bufferCmd;    playCmd.param1 = 0;    playCmd.param2 = (long)&amp;(perChanInfoPtr-&gt;soundHeader);    InsertSndDoCommand(theChannel, &amp;playCmd);exit:    return;}</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         </P>                  <P>There is a further callback function that runs only once         the application has signaled that we have played the last         buffer of its data. This function queues the per-channel         sound information so that the Notification Manager callback         can dispose of the per-channel memory.</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>static pascal void    CarbonSndPlayDoubleBufferCleanUpProc              (SndChannelPtr theChannel, SndCommand * theCallBackCmd) {    PerChanInfoPtr perChanInfoPtr;    perChanInfoPtr = (PerChanInfoPtr)(theCallBackCmd-&gt;param2);    #if DEBUG        if (perChanInfoPtr-&gt;magic != 'SANE') DebugStr("\pBAD in             CarbonSndPlayDoubleBufferCleanUpProc");    #endif    // Put our per channel data on the free queue so we can    // clean up later    Enqueue ((QElemPtr)perChanInfoPtr, gFreeList);    // Have to put the user's callback proc back so    // they get called when the next buffer finishes    theChannel-&gt;callBack = perChanInfoPtr-&gt;usersCallBack;    // Have to install our Notification Manager routine so that    // we can clean up the gFreeList    if (!OTAtomicSetBit (&amp;gNMRecBusy, 0)) {        NMInstall (gNMRecPtr);    }}</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         </P>                  <P>The next issue is that because the simulating code will         not be called once the sound has finished, it doesn't have a         good opportunity to clean up after itself because it will be         called at interrupt time when it wants to dispose of the         associated memory for the completed sound. This can be         partially alleviated by using the Notification Manager to         dispose of most of the memory, but there is no easy way to         clean up the Notification Manager record that is allocated         for this.</P>                  <P>The Notification Manager callback code looks like         this:</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>static pascal void NMResponseProc (NMRecPtr nmReqPtr) {    PerChanInfoPtr                    perChanInfoPtr;    OSErr                            err;    NMRemove (nmReqPtr);    gNMRecBusy = false;    do {        perChanInfoPtr = (PerChanInfoPtr)gFreeList-&gt;qHead;        if (nil != perChanInfoPtr) {            err = Dequeue ((QElemPtr)perChanInfoPtr, gFreeList);            if (noErr == err) {                DisposePtr ((Ptr)perChanInfoPtr);            }        }    } while (nil != perChanInfoPtr &amp;&amp; noErr == err);}</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         </P>                  <P>Because existing code will assume that once it has called         <CODE>SndPlayDoubleBuffer</CODE> that it can install a         <CODE>callBackCmd</CODE> without affecting the playing of         the sound, the code replacing         <CODE>SndPlayDoubleBuffer</CODE> must insert its         <CODE>bufferCmd</CODE>s and <CODE>callBackCmd</CODE>s at the         head of the sound queue. This means directly manipulating         the sound channel's command queue.</P>                  <P>The code to do that looks like:</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>static void    InsertSndDoCommand (SndChannelPtr chan, SndCommand * newCmd) {    if (-1 == chan-&gt;qHead) {        chan-&gt;qHead = chan-&gt;qTail;    }    if (1 &lt;= chan-&gt;qHead) {        chan-&gt;qHead--;    } else {        chan-&gt;qHead = chan-&gt;qLength - 1;    }    chan-&gt;queue[chan-&gt;qHead] = *newCmd;}</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         </P>                  <P>This also means that <CODE>SndDoImmediate</CODE> must be         wrapped so as to allow the original code to use the         <CODE>quietCmd</CODE> as it always has. Here is code that         shows how to wrap <CODE>SndDoImmediate</CODE> to make sure         that a <CODE>quietCmd</CODE> stops the sound and calls the         correct function for any <CODE>callBackCmd</CODE> that might         have been installed after the call to         <CODE>SndPlayDoubleBuffer</CODE>.</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>// Remember this routine could be called at interrupt time,// so don't allocate or deallocate memory.OSErr    MySndDoImmediate (SndChannelPtr chan, SndCommand * cmd) {    PerChanInfoPtr                    perChanInfoPtr;    // Is this being called on one of the sound channels we are manipulating?    // If so, we need to pull our callback out of the way so    // that the user's commands run    if (nil != gFreeList &amp;&amp; gCarbonSndPlayDoubleBufferCallBackUPP ==                        chan-&gt;callBack) {        if (quietCmd == cmd-&gt;cmd || flushCmd == cmd-&gt;cmd) {            // We know that our callBackCmd is the first item in the queue            // if this is our channel            perChanInfoPtr = (PerChanInfoPtr)                      (chan-&gt;queue[chan-&gt;qHead].param2);            #if DEBUG                if (perChanInfoPtr-&gt;magic != 'SANE')                          DebugStr("\pBAD in MySndDoImmediate");            #endif            perChanInfoPtr-&gt;stopping = true;            Enqueue ((QElemPtr)perChanInfoPtr, gFreeList);            if (! OTAtomicSetBit (&amp;gNMRecBusy, 0)) {                NMInstall (gNMRecPtr);            }            chan-&gt;callBack = perChanInfoPtr-&gt;usersCallBack;        }    }    return (SndDoImmediate (chan, cmd));}</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         <BR>         </P>                  <P><A HREF="#top">Back to top</A></P>                  <P><BR>         <A NAME=SndStartFilePlay></A></P>                  <H2><CODE>SndStartFilePlay</CODE></H2>                  <P>If you use <CODE>SndStartFilePlay</CODE> to play sound         resources (resources of type <CODE>'snd '</CODE>) using         limited amounts of memory (rather than loading the entire         sound into memory and playing it), your only solution is to         write a wrapper around the         <CODE>CarbonSndPlayDoubleBuffer</CODE> code using         <CODE>ReadPartialResource</CODE> to extract only a portion         of the sound resource at a time.</P>                  <P>QuickTime doesn't give you the option of playing a         resource handle whose data hasn't been completely loaded.         QuickTime will play a sound resource, but it expects that         the resource has been fully loaded into memory.</P>                  <P>If you use <CODE>SndStartFilePlay</CODE> to play sound         files from disk, this is probably a good fit for QuickTime.         You can even have QuickTime start playing the sound from a         specific time, just like <CODE>SndStartFilePlay</CODE>,         though you have to poll to know when the sound is done,         there is no QuickTime callback for this information.</P>                  <P>The code to have QuickTime play a file from disk looks         like:</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>    OSErr            err;    Movie            theSound;    short            fileRefNum;    err = OpenMovieFile (&amp;theSpec, &amp;fileRefNum, fsRdPerm);    if (noErr == err) {          err = NewMovieFromFile (&amp;theSound, fileRefNum, 0, nil,             newMovieActive, nil);    }    if (noErr == err) {        GoToBeginningOfMovie (theSound);    }    if (noErr == err) {        StartMovie (theSound);    }    if (noErr == err) {        while (!IsMovieDone (theSound) {            MoviesTask (theSound, 0);        }    }</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         </P>                  <P>This code will open a file on disk, pointed to by a         <CODE>FSSpec</CODE>, and play it synchronously from the         beginning of the sound to the end.         <CODE>SndStartFilePlay</CODE> required you to already have         the file open and pass it a file reference number, so you         probably already have a <CODE>FSSpec</CODE> to the file you         want to play.</P>                  <P>If you want to start the sound at some place other than         the start, you would use QuickTime's         <CODE>SetMovieTime</CODE> function to set the current time         in the movie.</P>                  <P>If you want to play the sound asynchronously, then you         will need to make <CODE>theSound</CODE> a global and in your         main event loop call <CODE>MoviesTask</CODE> about every         quarter of a second to keep the movie running with any         glitches. What this implies is that if you cannot call         <CODE>MoviesTask</CODE>, for instance, because your user is         holding down the mouse button and you are inside a call to         <CODE>TrackDrag</CODE>, then the sound will stop. If that is         unacceptable, then you will probably want to convert to         using the <CODE>CarbonSndPlayDoubleBuffer</CODE> code which         does not require task time to continue playing a sound.</P>                  <P><BR>         </P>                  <P><A HREF="#top">Back to top</A></P>                  <P><BR>         <A NAME=SndRecordToFile></A></P>                  <H2><CODE>SndRecordToFile</CODE> and         <CODE>SPBRecordToFile</CODE></H2>                  <P>If you use <CODE>SndRecordToFile</CODE> to record sound         to disk, the easiest way to convert to Carbon is to use         QuickTime. The following code shows how you would use         QuickTime's Sequence Grabber to record audio in a         synchronous manner.</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>    SGChannel               sgSoundChan;    ComponentInstance        sgSoundComp;    short                  numChannels,                          sampleSize;    OSType                 compressionType,                          inputSource;    err = SGInitialize (sgSoundComp);    if (err == noErr) {        err = SGNewChannel (sgSoundComp, SoundMediaType, &amp;sgSoundChan);    }    if (err == noErr) {        err = SGSetChannelUsage (sgSoundChan, seqGrabRecord);    }    if (err == noErr) {        err = SGSetSoundInputRate (sgSoundChan, sampleRate);    }    if (err == noErr) {        err = SGSetSoundInputParameters                  (sgSoundChan, sampleSize, numChannels, compressionType);    }    if (err == noErr) {        err = SPBSetDeviceInfo                  (SGGetSoundInputDriver (sgSoundChan),                  siOSTypeInputSource, &amp;inputSource);    }    if (err == noErr) {        err = SGSoundInputDriverChanged (sgSoundChan);    }    if (err == noErr) {        err = SGSetDataOutput (sgSoundComp, &amp;theSpec, seqGrabToDisk);    }    if (err == noErr) {        err = SGStartRecord (sgSoundComp);    }    if (err == noErr) {        EventRecord        event;        Boolean            done = false;        while (!done &amp;&amp; err == noErr) {            WaitNextEvent (mDownMask | keyDownMask, &amp;event, 6, nil);            err = SGIdle (sgSoundComp);            switch (event.what) {                case mouseDown:                case keyDown:                    done = true;                    break;            }        }        err = SGStop (sgSoundComp);    }    if (sgSoundComp != nil) {        err = CloseComponent (sgSoundComp);    }</pre>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         </P>                  <P>If you would prefer to use the Sequence Grabber's user         interface to have the user configure the recording (which is         recommended if you don't have your own interface already)         then you can skip the calls to         <CODE>SGSetSoundInputRate</CODE>,         <CODE>SGSetSoundInputParameters</CODE>, and         <CODE>SPBSetDeviceInfo</CODE> with the         <CODE>siOSTypeInputSource</CODE> selector, and         <CODE>SGSoundInputDriverChanged</CODE> and replace them all         with a single call to <CODE>SGSettingsDialog</CODE>.</P>                  <P>If you want to record asynchronously (something that         <CODE>SndRecordToFile</CODE> will not do but         <CODE>SPBRecordToFile</CODE> would), then you will need to         make <CODE>sgSoundComp</CODE> a global and call         <CODE>SGIdle</CODE> from your main event loop at least once         every quarter of a second.</P>                  <P>One nice feature of using the Sequence Grabber to record         is that it will record in any compression format currently         installed on the Mac. It does not limit you to only MACE 3:1         and MACE 6:1 compression.</P>                  <P><BR>         </P>                  <P><A HREF="#top">Back to top</A></P>                  <P><BR>         <A NAME=Summary></A></P>                  <H2>Summary</H2>                  <P>Many of the Sound Manager functions not in Carbon were         not used and so their loss will not cause any difficulties.         For the other functions, QuickTime and a little extra Sound         Manager Carbon compatible code is all that is required.</P>                  <P>Since QuickTime is very easy to use (at least in these         cases) and has most of the functionality of the non-Carbon         Sound Manager calls, converting your code to use QuickTime         when converting the rest of your code to Carbon should not         be difficult.</P>                  <P>For those applications that made heavy use of         <CODE>SndPlayDoubleBuffer</CODE> and required its interrupt         driven nature to deliver uninterrupted audio, the         <CODE>CarbonSndPlayDoubleBuffer</CODE> and associated         functions allow you to do this with a minimum of change to         your existing code base.</P>                  <P><BR>         </P>                  <P><A HREF="#top">Back to top</A></P>                  <P><BR>         <A NAME=References></A></P>                  <H2>References</H2>                  <P><A href="../../documentation/carbon/carbon.html">Carbon         Developer Documentation</A></P>                  <P><A HREF="tn1108.html">Technote 1108: Unknown Sound         Features</A></P>                  <P><A HREF="tn1048.html">Technote 1048: Some Sound Advice:         Getting the Most Out of the Sound Manager</A></P>                  <P><A href="../../documentation/mac/Sound/Sound-2.html">Inside         Macintosh: Sound</A></P>                  <P><BR>         </P>                  <P><A HREF="#top">Back to top</A></P>                  <P><BR>         <A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=600>            <TR>               <td width=50 align=left>                  <CENTER><img src="images/acrobatsmall.gif" alt="Acrobat" width=22 height=23 align=middle></CENTER>               </TD>               <td align="left">                  <P>Acrobat version of this Note (96K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1198.pdf">Download</A></P>               </TD>            </TR>            <TR>               <td width=50 align=left>                  <CENTER><img src="images/bluebook.gif" alt="Bluebook" width=22 height=23 align=middle></CENTER>               </TD>               <td align="left">                  <P>CarbonSndPlayDoubleBuffer code</P>               </TD>               <td width=60 align=left>                  <P><A href="../../samplecode/Sample_Code/Sound/CarbonSndPlayDB.htm">Download</A></P>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         <BR>         </P>                  <P><A HREF="#top">Back to top</A></P>      </TD>   </TR></TABLE></CENTER><P><!-- end_content --> <!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1198.html%3Fid%3DDTS10003037-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1198.html%3Fid%3DDTS10003037-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1198.html%3Fid%3DDTS10003037-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></P></BODY></HTML>