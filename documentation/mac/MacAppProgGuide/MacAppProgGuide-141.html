<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--PowerTalk Mailers (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING141></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-140.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-142.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-139.html"><B>Chapter 29 - Working With PowerTalk Mailers</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING141-0></A>
<H1><A NAME=MARKER-2-24></A>Recipes--PowerTalk Mailers</H1>
 The recipes and sample code in this section describe how to add MacApp's PowerTalk support to your application and how to define a document class that supports PowerTalk mailers.<P>
<A NAME=HEADING141-2></A>
<H2><A NAME=MARKER-9-25></A><A NAME=MARKER-2-26></A>Recipe--Adding PowerTalk Support to Your Application</H2>
 To add MacApp's PowerTalk support to your application, you perform these steps:<P>
<OL>
<LI>Build your application to include MacApp's PowerTalk support.
<LI>Include the Mail menu in your application.
<LI>Initialize MacApp's mailer support by calling <CODE>InitUMailer</CODE> from your application's <CODE>main</CODE> routine.
<LI>Define an application class that is a subclass of <CODE>TMailingApplication</CODE>.
<LI>Decide whether to define a new file type for your letter files.<P>
</OL>
 The sample code in this recipe is from the DemoText application.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>This recipe describes how to include MacApp's PowerTalk support in your application. To <I>use</I> that support, you also must follow the steps in <A HREF=#MARKER-9-30>"Recipe--Adding Mailer Support to a Document Class," beginning on page 628</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING141-11></A>
<H3>Build Your Application to Include MacApp's PowerTalk Support</H3>
 Not all applications need electronic mail, so MacApp's PowerTalk support is conditionally compiled--that is, the mailer code isn't included unless you specifically ask for it. For example, if you build your application with MPW and the MABuild tool (described in <A HREF=MacAppProgGuide-148.html#MARKER-9-10>Appendix A</A>), you include MacApp's PowerTalk support with a build line similar to the following:<P>
<PRE>
MABuild YourAppName [-options] -PowerTalk
</PRE>
 Building with the <CODE>-PowerTalk</CODE> option sets the <CODE>qPowerTalk</CODE> compiler flag to <CODE>TRUE</CODE>. You can use the following line to specifically build your application <I>without</I> PowerTalk support:<P>
<PRE>
MABuild YourAppName [-options] -noPowerTalk
</PRE>
<A NAME=HEADING141-16></A>
<H3><A NAME=MARKER-9-27></A>Include the Mail Menu in Your Application</H3>
 MacApp's <CODE>Defaults.r</CODE> file defines a <CODE>'CMNU'</CODE> resource for the Mail menu used to perform mail operations. The Mail menu contains the commands Add Mailer/Remove Mailer, Send, Reply, Forward, and Open Next Letter.<P>
 You can add the Mail menu from MacApp's <CODE>Defaults.r</CODE> file to your application's resource definition file by cutting and pasting the text or by adding the following lines to your resource file:<P>
<PRE>
#if qPowerTalk
include &quot;Defaults.rsrc&quot; 'CMNU' (mMail);
#endif
</PRE>
 Code between the <CODE>#if</CODE> and <CODE>#endif</CODE> compiler directives will not be part of your application unless <CODE>qPowerTalk</CODE> is defined as <CODE>TRUE</CODE> when the code is compiled (which is the case when you build with the -PowerTalk option). The constant <CODE>mMail</CODE> is defined in the file <CODE>MacAppTypes.r</CODE>. You can include that file into your resource definition file with the following lines:<P>
<PRE>
#ifndef __MacAppTypes__
#include &quot;MacAppTypes.r&quot;
#endif
</PRE>
 You also add the Mail menu to your application's menu-bar resource, as shown in this code fragment from the resource definition file of the DemoText application:<P>
<PRE>
resource 'MBAR' (kMBarDisplayed,
#if qNames
&quot;kHierDisplayedMBar&quot;,
#endif
nonpurgeable) {
   {
      mApple; 
      mFile; 
      mEdit; 
      mText; 
      mFormat
#if qPowerTalk
      ;mMail
#endif
   }
};
</PRE>
 If you don't have room in your application's menu bar for the Mail menu, you can add it as a hierarchical menu in your File menu.<P>
<A NAME=HEADING141-25></A>
<H3>Initialize MacApp's Mailer Support</H3>
 Your application initializes MacApp's mailer support by calling <CODE>InitUMailer</CODE> from its <CODE>main</CODE> routine. You should call <CODE>InitUMailer</CODE> after calling <CODE>InitUMacApp</CODE>, with code similar to the following:<P>
<PRE>
#if qPowerTalk
   if (HasAOCEToolBox())
      InitUMailer();
#endif
</PRE>
 The line<P>
<PRE>
if (HasAOCEToolBox())
</PRE>
 determines whether the PowerTalk system software is available on the current machine. Use this test to isolate code that should not be performed unless PowerTalk support is available.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>You should be careful to isolate code that deals with mailers, using either conditional compilation (the <CODE>qPowerTalk</CODE> flag) or conditional testing (HasAOCEToolBox). Otherwise, your application may try to call MacApp code or reference a MacApp compile time variable that was not included in the current build. This can cause the program to crash.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING141-32></A>
<H3>Define an Application Subclass of TMailingApplication</H3>
 The TMailingApplication class contains application-level support for working with PowerTalk mailers, both in its own methods and in methods and fields inherited from the mixin class <CODE>MMailing</CODE>. To take advantage of this support, your application class must be a subclass of TMailingApplication. The DemoText application begins its application class definition as follows:<P>
<PRE>
class TDemoTextApplication : public TMailingApplication
</PRE>
<A NAME=HEADING141-35></A>
<H3>Decide Whether to Define a New Type for Letter Files</H3>
 MacApp defines a default file type for the letters your application creates:<P>
<PRE>
const DescType typeLetterDesc = 'lttr';
const DescType kStandardLetterFileType = typeLetterDesc;
</PRE>
 The <CODE>MMailing</CODE> class field <CODE>fMainLetterFileType</CODE> stores the principal file type your application uses for letters. The field is set to <CODE>kStandardLetterType</CODE> in the constructor for <CODE>TMailingApplication</CODE>. By default, a letter file has the same Finder icon as the document it is added to, because MacApp does not supply special icons or bundle information for the letter file type.<P>
 You can specify a different file type for your application's letters by passing it to the <CODE>IMailingApplication</CODE> method. You can specify new icons for your letters by adding icon and bundle information to your application's resource definition file. See the "Finder Interface" chapter of <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for more information about application icons and bundle information.<A NAME=MARKER-2-28></A><P>
<A NAME=HEADING141-40></A>
<H2><A NAME=MARKER-2-29></A><A NAME=MARKER-9-30></A>Recipe--Adding Mailer Support to a Document Class</H2>
 MacApp's PowerTalk mailer support helps you add mailers to your documents, turning them into electronic mail. To add mailer support to your document class, you perform the following steps:<P>
<OL>
<LI>Decide which mail formats your document will support.
<LI>Define a subclass of <CODE>TMailableDocument</CODE> for your mailer document.
<LI>In the constructor method for your mailable document class, set the <CODE>fSendFormats</CODE> field to match the formats you support.
<LI>Override document methods to get and set the mailer's data for the formats you support. You may need to override the following methods:<P>
<UL>
<LI><CODE>AddNativeMailContent</CODE>
<LI><CODE>AddSnapshotMailContent</CODE>
<LI><CODE>AddStandardMailContent</CODE>
<LI><CODE>ImageDocumentForMailer</CODE>
<LI><CODE>ReadNativeMailContent</CODE>
<LI><CODE>ReadSnapshotMailContent</CODE>
<LI><CODE>ReadStandardMailContent</CODE><P>
</UL>
<LI>If necessary, override the <CODE>MMailable::SetReplyContents</CODE> method to set up a reply mailer.
<LI>If necessary, override the <CODE>MMailable::MakeRoomForMailer</CODE> method.
<LI>If necessary, override the <CODE>TLetter::OpenLetter</CODE> method.<P>
</OL>
 The sample code in this recipe is from the DemoText application.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>This recipe describes how to add PowerTalk support to a document class. To implement this recipe, you must also perform the steps in <A HREF=#MARKER-9-25>"Recipe--Adding PowerTalk Support to Your Application," beginning on page 624</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING141-58></A>
<H3><A NAME=MARKER-9-31></A>Decide Which Mail Formats to Support</H3>
 When you use a mailer to send a document as a letter, you can send the document in a <I>native format</I> (that is, any of the internal document formats supported by your application), in <I>snapshot format</I> (an image or "snapshot" of the document), in a special format called standard interchange format, or in any combination of these formats simultaneously. <I>Standard interchange format</I> is a set of data formats that consists of plain text, styled text, sound (AIFF), images (<CODE>'PICT'</CODE>), and QuickTime movies (<CODE>'MooV'</CODE>).<P>
 The DemoText application sends letters containing both native and standard interchange format.<P>
<A NAME=HEADING141-61></A>
<H3>Define a Subclass of TMailableDocument for Your Mailer Document</H3>
 Your application adds to MacApp's PowerTalk support primarily by overriding methods of the <CODE>MMailable</CODE> class. Since <CODE>MMailable</CODE> is mixed in with the <CODE>TMailableDocument</CODE> class, you normally override methods of <CODE>MMailable</CODE> by defining a document class that descends from <CODE>TMailableDocument</CODE>. The DemoText application begins its document class definition as follows:<P>
<PRE>
class TTEDocument : public TMailableDocument
</PRE>
<A NAME=HEADING141-64></A>
<H3>Set the Document's fSendFormats Field</H3>
 In the constructor method for your mailable document class, you set the <CODE>fSendFormats</CODE> field to match the formats you support. The value for this field is computed by adding the constants for each of the three standard mail formats supported by your application. For example, the following line from the constructor method of the <CODE>MMailable</CODE> class indicates that the default setting is to support all three standard formats:<P>
<PRE>
fSendFormats = kSMPNativeMask + kSMPImageMask +
            kSMPStandardInterchangeMask;
</PRE>
 In its constructor method, the <CODE>TTEDocument</CODE> class changes the setting for fSendFormats with the following lines:<P>
<PRE>
#if qPowerTalk
fSendFormats = kSMPNativeMask + kSMPStandardInterchangeMask;
#endif
</PRE>
 In the DemoText application, the <CODE>TTEDocument</CODE> class supports native and standard interchange formats only.<P>
<A NAME=HEADING141-70></A>
<H3><A NAME=MARKER-9-32></A>Override Methods to Get and Set Mailer Data</H3>
 Your document class may need to override certain methods, as described in the following sections, to get and set mailer data for the formats it supports.<P>
<A NAME=HEADING141-72></A>
<H4>AddNativeMailContent, ReadNativeMailContent</H4>
 If your document class supplies <CODE>DoRead</CODE> and <CODE>DoWrite</CODE> methods to read and write its data, MacApp handles native format automatically. If your document class doesn't supply <CODE>DoRead</CODE> and <CODE>DoWrite</CODE> methods, or if you need to modify MacApp's default behavior, your document class can override the <CODE>AddNativeMailContent</CODE> and <CODE>ReadNativeMailContent</CODE> methods.<P>
 In the DemoText application, the <CODE>TTEDocument</CODE> class overrides the <CODE>ReadNativeMailContent</CODE> method:<P>
<PRE>
Boolean TTEDocument::ReadNativeMailContent()
{  
   Boolean readContent = TMailableDocument::ReadNativeMailContent();
   
   // fStyles and fElements are native to DemoText (see
   // TTEDocument::DoRead) so they can be used as a valid check
   // for native content.
   if (fDocText &amp;&amp; fStyles &amp;&amp; fElements)
   {
      this-&gt;ShowReverted();
      readContent = TRUE;
   }
   return readContent;
}
</PRE>
 This method calls TMailableDocument::ReadNativeMailContent to read the native format content, then calls <CODE>ShowReverted</CODE> so that the TTEDocument class can set up its text display.<P>
<A NAME=HEADING141-77></A>
<H4>AddSnapshotMailContent, ImageDocumentForMailer, ReadSnapshotMailContent</H4>
 To support the snapshot format, your document class overrides the <CODE>ImageDocumentForLetter</CODE> and <CODE>ReadSnapshotMailContent</CODE> methods. The <CODE>AddSnapshotMailContent</CODE> method calls <CODE>ImageDocumentForLetter</CODE>, so you don't normally need to override <CODE>AddSnapshotMailContent</CODE> itself.<P>
 Your version of the <CODE>ImageDocumentForLetter</CODE> method provides a suitable image of your document. Your version of <CODE>ReadSnapshotMailContent</CODE> extracts the document image. The DemoText application does not support snapshot format, but you can find an example of an image-drawing routine in the "Standard Mail Package" chapter of <I>Inside Macintosh: AOCE Application Interfaces</I>.<P>
<A NAME=HEADING141-80></A>
<H4>AddStandardMailContent, ReadStandardMailContent</H4>
 To support the standard mail format, your document class overrides the <CODE>AddStandardMailContent</CODE> and <CODE>ReadStandardMailContent</CODE> methods.<P>
 In the DemoText application, the <CODE>TTEDocument</CODE> class overrides the <CODE>AddStandardMailContent</CODE> method to add styled text content:<P>
<PRE>
void TTEDocument::AddStandardMailContent(Boolean&amp; okToSend)
{
   WindowRef theWindow = fTEView-&gt;GetGrafPort();
   Boolean appendFlag = FALSE;
   Handle theText = fTEView-&gt;ExtractText();
   SignedByte wasTextState = LockHandleHigh(theText);
   Ptr buffer = *theText;
   unsigned long bufferSize = GetHandleSize(theText);
   StScrpHandle theStyles = (StScrpHandle)NewHandle(10);
   fTEView-&gt;GivePasteData((Handle)theStyles, 'styl');
   SignedByte wasStyleState = LockHandleHigh((Handle)theStyles);
   Boolean startNewScript = TRUE;
   short scriptID = smRoman;
   FailOSErr(SMPAddContent(theWindow, kMailStyledTextSegmentType,
                     appendFlag,buffer, bufferSize, *theStyles,
                     startNewScript, scriptID));
   HSetState(theText, wasTextState);
   HSetState((Handle)theStyles, wasStyleState);
   DisposeIfHandle((Handle)theStyles);
   okToSend = TRUE;
}
</PRE>
 This method extracts text from the document's <CODE>fTEView</CODE> field, calls a method of the view (<CODE>GivePasteData</CODE>) to extract the style information, then calls the Standard Mail Package routine SMPAddContent to add the styled text content.<P>
 The <CODE>TTEDocument</CODE> class overrides the <CODE>ReadStandardMailContent</CODE> method to perform the opposite operation--to extract styled text content from the mailer and install it in the document's own view. The <CODE>ReadStandardMailContent</CODE> method is implemented as follows:<P>
<PRE>
Boolean TTEDocument::ReadStandardMailContent()
{
   Boolean        readContent = FALSE;
   const unsigned long kBufferSize = 10000;
   MailSegmentMasksegmentTypeMask = kMailStyledTextSegmentMask;
   Handle         buffer = NewHandle(kBufferSize);
   FailNIL(buffer);
   
   const short kNumStyles  = 200;
   const long  kStyleBufferSize = (sizeof(ScrpSTElement) * kNumStyles) + 4;
   StScrpHandle theStyles  = (StScrpHandle)NewHandleClear(kStyleBufferSize);
   FailNIL(theStyles);
   
   Boolean endOfContent = FALSE;
   OSErr err = noErr;
   Boolean allContentExtracted = TRUE;
   
   while ((err == noErr) &amp;&amp; !endOfContent)
   {
      // Skip past empty text segments.
      ScriptCode  script   = 0;
      unsigned    longdataSize = 0;
      long        segmentLength = 0;
      long        segmentID = 0;
      Boolean     endOfScript = FALSE;
      Boolean     endOfSegment = FALSE;
      MailSegmentTypesegmentType;
      
      endOfContent = FALSE;
   
      unsigned long bufferSize = kBufferSize;
      SetHandleSize(buffer, bufferSize);
      SetHandleSize((Handle)theStyles, kStyleBufferSize);
      (**theStyles).scrpNStyles = kNumStyles;
      SignedByte wasStylesState = LockHandle((Handle)theStyles);
      SignedByte wasBufferState = LockHandle(buffer);
      err = SMPReadContent(fLetter-&gt;GetMailerWindowRef(), segmentTypeMask,
                      *buffer, bufferSize, &amp;dataSize, *theStyles, &amp;script,
                      &amp;segmentType, &amp;endOfScript, &amp;endOfSegment, &amp;endOfContent,
                      &amp;segmentLength, &amp;segmentID);
      
      if(allContentExtracted &amp;&amp; (dataSize &gt; 0) &amp;&amp; !endOfContent)
         allContentExtracted = FALSE;
      
      if ((err == noErr) &amp;&amp; (dataSize &gt; 0))
      {
         HSetState(buffer, wasBufferState);
         HSetState((Handle)theStyles, wasStylesState);
         SetHandleSize(buffer, dataSize);
         unsigned long textSize = dataSize;
         dataSize = (sizeof(ScrpSTElement) * (**theStyles).scrpNStyles) + 4;
         SetHandleSize((Handle)theStyles, dataSize);
         TEStyleInsert(*buffer, textSize, (StScrpHandle)theStyles, fTEView-&gt;fHTE);
         fTEView-&gt;SynchView(FALSE);
         readContent = TRUE;
      }
   }
   
   DisposeIfHandle(buffer);
   DisposeIfHandle((Handle)theStyles);
   
   if(!allContentExtracted)
   {
      MacAppAlert(kContentNotExtracted, NULL);
   }

   return readContent;
}  // TTEDocument::ReadStandardMailContent
</PRE>
 This method repeatedly calls SMPReadContent (a Standard Mail Package routine) to extract text and style data, and TEStyleInsert (a Toolbox routine) to insert the data into the document's <CODE>fTEView</CODE> field. If ReadStandardMailContent cannot extract all the content (text style, PICT, or any other format), it displays an alert box. The constant kContentNotExtracted identifies <CODE>'ALRT'</CODE> and <CODE>'DITL'</CODE> resources defined in the file <CODE>TTEDocument.r</CODE>. The MacApp routine MacAppAlert displays a dialog box with the text "This letter includes Standard Mail Format DemoText cannot display."<P>
<A NAME=HEADING141-88></A>
<H3>If Necessary, Override SetReplyContents</H3>
 When a user chooses the Reply command from the Mail menu, an application typically creates a reply mailer document addressed to the sender of the original letter, with the same or a similar subject and recipient list. The reply letter may also contain the text from the original letter, perhaps separated by a dashed line or other border.<P>
 MacApp uses its standard (if somewhat complex) Apple event mechanism to respond to the Reply command. The <CODE>DoMailMenuCommand</CODE> method of the <CODE>TLetter</CODE> class handles the Reply menu command by calling the letter's <CODE>DoReply</CODE> method. <CODE>DoReply</CODE> creates and sends a Create Element (<CODE>cAECreateElement</CODE>) event. The event is dispatched to the application object and handled by the <CODE>MScriptableObject::DoScriptCommand</CODE> method, which calls <CODE>DoAECreateElement</CODE>. In the <CODE>TMailingApplication</CODE> class, <CODE>DoAECreateElement</CODE> creates a document object and calls the document's <CODE>DoAECreateReply</CODE> method. That method in turn calls the letter's <CODE>DoAECreateReply</CODE> method.<P>
 The <CODE>TLetter::DoAECreateReply</CODE> method takes care of certain overhead, including setting up the mailer view, then calls the document's <CODE>SetReplyContents</CODE> method, at last reaching the subject of this section.<P>
 In the <CODE>MMailable</CODE> class, which is mixed into <CODE>TMailableDocument</CODE>, the <CODE>SetReplyContents</CODE> method does nothing. To set up the reply letter in your desired format, you override <CODE>SetReplyContents</CODE> in your mailable document class. The <CODE>TTEDocument</CODE> class overrides <CODE>SetReplyContents</CODE> to set up a reply containing a dashed line followed by the text from the original letter, using the following code:<P>
<PRE>
void TTEDocument::SetReplyContents(TDocument* replyToDoc)
{  
   // Extract text from original document and copy into this document.
   DisposeIfHandle(fDocText);
   fDocText = ((TTEDocument*)replyToDoc)-&gt;fDocText;
   FailOSErr(HandToHand(&amp;fDocText));
   
   // Do the same for all style information.
   DisposeIfHandle((Handle)fElements);
   fElements = ((TTEDocument*)replyToDoc)-&gt;fElements;
   if (fElements != NULL)
      FailOSErr(HandToHand((Handle*)&amp;fElements));
   
   DisposeIfHandle((Handle)fStyles);
   fStyles = ((TTEDocument*)replyToDoc)-&gt;fStyles;
   if (fStyles != NULL)
      FailOSErr(HandToHand((Handle*)&amp;fStyles));
   
   // Call ShowReverted to adjust display.
   ShowReverted();
   
   // Insert a dashed-line spacer above the styled text.
   if (fTEView-&gt;Focus())
   {
      (*fTEView-&gt;fHTE)-&gt;selStart = 0;
      (*fTEView-&gt;fHTE)-&gt;selEnd = 0;
      
      CStr255 replySpacer;
      GetIndString(replySpacer, kPromptsRsrcID, kReplySpacer);
      TextStyle newStyle;
      newStyle.tsFace = 0;
      TESetStyle(doFace,&amp;newStyle,FALSE,fTEView-&gt;fHTE);
      TEInsert((Ptr)&amp;replySpacer.fStr[1], replySpacer.Length(),
               fTEView-&gt;fHTE);
      
      (*fTEView-&gt;fHTE)-&gt;selStart = 0;
      (*fTEView-&gt;fHTE)-&gt;selEnd = 0;
      fTEView-&gt;SynchView(FALSE);
   }
}
</PRE>
 This code copies the text and style information from the original letter to the reply letter, then inserts a dashed line above the text as a spacer. The insertion point is placed above the space to allow the user to enter a reply to the original letter.<P>
<A NAME=HEADING141-95></A>
<H3>If Necessary, Override MMailable::MakeRoomForMailer</H3>
 When you add a mailer to a document, MacApp attempts to create and position a mailer view automatically. It calls the document's <CODE>MakeRoomForMailer</CODE> method to make room for the new mailer view.<P>
 The <CODE>MakeRoomForMailer</CODE> method is defined in the <CODE>TLetter</CODE> and <CODE>MMailable</CODE> classes (<CODE>MMailable</CODE> is mixed in with the <CODE>TMailableDocument</CODE> class). In <CODE>TLetter</CODE>, <CODE>MakeRoomForMailer</CODE> calls the <CODE>MakeRoomForMailer</CODE> method of its document. In <CODE>MMailable</CODE>, <CODE>MakeRoomForMailer</CODE> adjusts the document's window to make room for a mailer view. <CODE>MakeRoomForMailer</CODE> operates on the assumption that the main content view, containing all other views, is a scroller with ID <CODE>'SCLR'</CODE>.<P>
 If you have a simple document view in which one scroller view serves as the superview, set the view ID of the scroller to <CODE>'SCLR'</CODE>. The default version of <CODE>MakeRoomForMailer</CODE> will then resize the mailer view appropriately as the document view changes size. The <CODE>TTEDocument</CODE> class creates a view that matches this format, but if your document view hierarchy contains views that are outside the scroller view, you must override <CODE>MakeRoomForMailer</CODE> to adjust for your hierarchy.<P>
<A NAME=HEADING141-99></A>
<H3>If Necessary, Override TLetter::OpenLetter</H3>
 When a user opens an existing document with a mailer, the <CODE>TMailingApplication::OpenOld</CODE> method calls the application object's <CODE>DoMakeDocument</CODE> method to create a document. <CODE>OpenOld</CODE> calls various methods of the document to read data and create views, then calls the document's <CODE>OpenLetter</CODE> method.<P>
 The document's <CODE>OpenLetter</CODE> method is defined in the <CODE>MMailable</CODE> mixin class. It calls the <CODE>OpenLetter</CODE> method of its <CODE>fLetter</CODE> field. The <CODE>TLetter::OpenLetter</CODE> method contains this code:<P>
<PRE>
Boolean readContent;
readContent = fMailDoc-&gt;ReadNativeMailContent();
if (!readContent)
   readContent = fMailDoc-&gt;ReadSnapshotMailContent();
if (!readContent)
   fMailDoc-&gt;ReadStandardMailContent();
</PRE>
 This code first tries to read content in native mail format. If it is unsuccessful, it tries to read snapshot format. If it is still unsuccessful, it finally tries to read standard mail format. If your application needs to change this ordering, you can override the <CODE>OpenLetter</CODE> method in either your mailable document class or in a subclass of <CODE>TLetter</CODE> (or of <CODE>TFileBasedLetter</CODE>).<A NAME=MARKER-2-33></A><A NAME=MARKER-2-34></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-140.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-142.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
