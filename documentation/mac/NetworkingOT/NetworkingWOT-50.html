<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Using Raw Mode</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING50></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-49.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-51.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-46.html"><B>Chapter 10 - Advanced Topics</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING50-0></A>
<H1>Using Raw Mode</H1>
 <B>Raw mode</B> refers to the ability of some connectionless providers to pass packet header information, which would normally be stripped at the appropriate protocol level, up to a higher level. For example, if you open a DDP endpoint, you can send and receive data in raw mode in order to determine how many routers a packet had passed through before you receive it. Normally, hop count information is stored in the DDP packet header; by using raw mode you can access this information, which would otherwise be stripped off before you received the packet. <P>
 There are two methods for anabling raw mode packet handling. At the link layer (Ethernet and TokenRing), use the <CODE>OTOptionManagement</CODE> function to enable raw mode packet processing. Above the link layer, the AppleTalk DDP protocol supports raw mode in a different manner. For more information, see the description of the <CODE>OTSndUData</CODE> function in <A HREF=NetworkingWOT-68.html#MARKER-9-49>"Using General Open Transport Functions With DDP"</A>. Your protocol might support specific options; for example RawIP supports the IP header include option.<P>
<A NAME=HEADING50-3></A>
<H2>Using Option Management to Set Raw Mode</H2>
 If you want to use raw mode at the link layer level, you should use the option <CODE>OPT_SETRAWMODE</CODE>. <A HREF=#MARKER-9-44>Listing 10-3</A> shows the user function <CODE>DoNegotiateRawModeOption </CODE>as an example of how you negotiate raw mode using options.<P>
<B>Listing 10-3  <A NAME=MARKER-9-44></A>Negotiating raw mode using options</B><P>
<PRE>
<A NAME=MARKER-0-95></A>#include &lt;OpenTransport.h&gt;
#include &lt;OpenTptLinks.h&gt;

OSStatus DoNegotiateRawModeOption(EndpointRef ep, UInt32 rawModeOption);

/* use the options as defined in the OpenTptLinks.h header
   when setting the rawModeOption parameter. */

OSStatus DoNegotiateRawModeOption(EndpointRef ep, UInt32 rawModeOption)

{
   UInt8 buf[kOTFourByteOptionSize];
                  /* buffer for fourByte Option size */
   TOption* opt;  /* option ptr to make items easier to access */
   TOptMgmt req;
   TOptMgmt ret;
   OSStatus err;
   
   opt = (TOption*)buf;/* set option ptr to buffer */
   req.opt.buf= buf;
   req.opt.len= sizeof(buf);
   req.flags= T_NEGOTIATE;/* negotiate for rawmode option */

   ret.opt.buf = buf;
   ret.opt.maxlen = kOTFourByteOptionSize;
   

   opt-&gt;level= LNK_TPI; /* dealing with tpi */
   opt-&gt;name= OPT_SETRAWMODE;/* specify raw mode */
   opt-&gt;len= kOTFourByteOptionSize;
   opt-&gt;status = 0;
   *(UInt32*)opt-&gt;value = rawModeOption;
            /* set the desired option level, true or false */
            
   err = OTOptionManagement(ep, &amp;req, &amp;ret);
      
      /* if no error then return the option status value */
   if (err == kOTNoError)
   {
      if (opt-&gt;status != T_SUCCESS)
         err = opt-&gt;status;
      else
         err = kOTNoError;
   }
      
   return err;
}
</PRE>
 The function assumes the endpoint is in synchronous mode. It defines buffers that contain option negotiation information and then calls the <CODE>OTOptionMangement</CODE> function. <P>
<A NAME=HEADING50-8></A>
<H2>Testing for Raw Mode Support</H2>
 To use raw mode you need to determine whether the provider you are using supports it by examining the <CODE>T_CAN_SUPPORT_MDATA</CODE> bit of the endpoint information structure for your endpoint. <A HREF=#MARKER-9-46>Listing 10-4</A> shows a function <CODE>CanDoRawMode</CODE> that you can call to determine whether your endpoint provider supports sending or receiving raw data. The function calls the OTGetEndpointInfo function and examines the<CODE> info.flags</CODE> field to see if the T_CAN_SUPPORT_MDATA bit is set. If it is, the function returns <CODE>true</CODE>.<P>
<B>Listing 10-4  <A NAME=MARKER-9-46></A>Testing for raw data support</B><P>
<PRE>
<A NAME=MARKER-0-95></A>Boolean CanDoRawMode(EndpointRef ep)
{
   TEndpointInfoinfo;
   OSStatus    err;
   Boolean     result;
   
   err = OTGetEndpointInfo(ep, &amp;info);
   if (err != kOTNoError)
      result = false;
   else if (info.flags &amp; T_CAN_SUPPORT_MDATA)
      result = true;/* this also means that the src addr info is
                     in the info record */
   else
      result = false;

   return result;
}
</PRE>
<A NAME=HEADING50-12></A>
<H2>Sending and Receiving in Raw Mode at the Protocol Level</H2>
 Currently raw mode is supported only for DDP endpoints. To enable or disable raw mode packet processing of data under DDP, you modify the <CODE>TNetBuf</CODE> <CODE>addr</CODE> field that is sent in the OTSendUdata function. Once raw mode processing is enabled with the OTSndUData call, it stays in effect until you explicitly disable it. <P>
 To enable raw mode, you must<P>
<OL>
<P><LI>Specify <CODE>0xffffffffUL</CODE> for the <CODE>unitdata.addr.len</CODE> field of the <CODE>TNetBuf</CODE> structure containing the address information. Set the <CODE>opt.len</CODE>, <CODE>opt.buf</CODE>, and <CODE>addr.buf</CODE> fields to 0. 
<P><LI>Place DDP header information in the buffer referenced by the <CODE>udata.udata.buf</CODE> field of the <CODE>TNetBuf</CODE> structure describing data being sent. The DDP header begins with the hop count byte. With raw mode enabled, the data in the <CODE>unitdata.udata.bu</CODE>f field must be the complete DDP packet. <P>
</OL>
 Once you have sent a raw mode pocket, the protocol will deliver incoming packets in raw mode as well. When using raw mode on receives, you should <P>
<OL>
<P><LI>Set the <CODE>opt.len</CODE> field and the <CODE>udata.addr.maxlen</CODE> field to 0. However it is set, Open Transport does not fill this field with address information. Instead it returns the complete DDP packet (including the header) in the data buffer described in step 2.
<P><LI>Allocate a buffer (into which the data is stored when the function returns) that is large enough to hold header information as well as the data being received.<P>
</OL>
 Be careful when using raw mode packets because you can no longer tell a full incoming packet from a partial read without remembering that the <CODE>T_MORE</CODE> flag was set on the previous read.<P>
 To disable raw mode packet processing, send a normal DDP packet with the <CODE>unitdata.addr.len</CODE> and the <CODE>unitdata.addr.buf</CODE> fields set for an <CODE>AF_ATALK_DDP</CODE> or similar structure.<P>
 <A HREF=#MARKER-9-48>Listing 10-5</A> shows how you send an echo packet using a DDP endpoint. The sample code includes a call to <CODE>CanDoMDataMode</CODE>, a function that looks at the flags associated with creating the endpoint to determine whether the endpoint supports <CODE>M_DATA</CODE> mode. It is assumed that the endpoint is bound and that it is in synchronous mode.<P>
<B>Listing 10-5  <A NAME=MARKER-9-48></A>Testing for raw mode support for a DDP endpoint</B><P>
<PRE>
<A NAME=MARKER-0-95></A>#include &lt;OpenTransport.h&gt;
#include &lt;OpenTptAppleTalk.h&gt;
#include &lt;Types.h&gt;
#include &lt;Events.h&gt;
#include &lt;stdio.h&gt;

void doOpenTptEcho(EndpointRef ep, UInt16 destNet, UInt8 destNode);
extern Boolean CanDoMDataMode(EndpointRef ep);

enum {
   kddpMaxNormData = 586,
   kddpMaxRawData= 599
};
enum {
   kEchoSocketID= 4
};
enum {
   kEchoRequest= 1,
   kEchoType= 4
};

void doOpenTptEcho(EndpointRef ep, UInt16 destNet, UInt8 destNode)
{
   TBind       boundAddr;
   DDPAddressd dpAddr, destAddr;
   TUnitData   unitdata;
   OSStatus    err = kOTNoError;
   OTResult    result;
   OTFlags     flags;
   
   UInt8    buf[kddpMaxRawData];
   UInt8    buf1[64] = &quot;This is a sample string for the first part
                                       of the buffer&quot;;
   Boolean  done = false;
   Boolean  useMDataMode;
      
   if (!OTIsSynchronous(ep))
   {
      fprintf(stderr, &quot;endpoint must be synchronous for this sample&quot;);
      return;
   }

   /* verify that the endpoint is bound first. */
   result = OTGetEndpointState(ep);
   if (result != T_IDLE)
   {
      fprintf(stderr, &quot;endpoint must be bound for this sample&quot;);
      return;
   }
   
      /* check for support of M_DATA mode so that we get the */
      /* header info along with the datagram */
   useMDataMode = CanDoMDataMode(ep);
      
   if (useMDataMode == true)
   {
/* set up data buffer to send Echo Request as a DDP M_DATA packet */
/* get our protocol address to fill into the M_DATA packet */
      
      boundAddr.addr.buf = (UInt8*)&amp;ddpAddr;
      boundAddr.addr.maxlen = sizeof(ddpAddr);
      err = OTGetProtAddress(ep, &amp;boundAddr, nil);
      
      if (err != kOTNoError)
      {
         fprintf(stderr, &quot;error occurred calling OTGetProtAddress 
                              - %ld\n&quot;, err);
         return;
      }
      else
      {
         /* packet length */

         /* clear hopcount, but set the upper 2 bits of the length */
         buf[0] = (UInt8)(kddpMaxRawData &gt;&gt; 8) &amp; 0x0003;
         /* set the lower byte of the length field */
         buf[1] = (UInt8)(kddpMaxRawData &amp; 0x00FF);

         /* packet checksum */
         
         buf[2] = 0;// no checksum
         buf[3] = 0;// no checksum

         /* dest network */
         
         buf[4] = (UInt8)(destNet &gt;&gt; 8);
         buf[5] = (UInt8)(destNet &amp; 0x00FF);

         
         /* src network */
         
         buf[6] = (UInt8)(ddpAddr.fNetwork &gt;&gt; 8);
         buf[7] = (UInt8)(ddpAddr.fNetwork &amp; 0x00FF);

         buf[8] = (UInt8)destNode;/* dest node */
         buf[9] = (UInt8)ddpAddr.fNodeID;/* src node */
         
         buf[10] = kEchoSocketID;/* set dest socket to echo socket */
         buf[11] = (UInt8)ddpAddr.fSocket;/* src socket */
         
         buf[12] = kEchoType;/* set packet type to echo packet */
         buf[13] = kEchoRequest; /* packet is echo request packet */
         BlockMove((Ptr)&amp;buf1, (Ptr)&amp;buf[14], sizeof(buf1));
         
            /* set up the unitdata structure */
         unitdata.udata.buf = (UInt8*)buf;/* data area */
         unitdata.udata.len = kddpMaxRawData;
         unitdata.addr.buf = nil;/* address area*/

/* by sending the packet with the addr.len field set to 0xFFFFFFFFUL,*/
/* one enables M_DATA mode with DDP.  Once you send a packet in this */
/* manner, all packet deliveries will also be in M_DATA mode.  This */
/* continues until a packet is sent with the addr.len field set to a */ 
/* value other than 0xFFFFFFFFUL. */
         unitdata.addr.len = (size_t)0xffffffffUL;
         unitdata.opt.buf = nil;
         unitdata.opt.len = 0; /* no options being sent */
      }     
   }
   else
   {
      /* Set up DDP Address field with the destination address */
      /* for the Echo request */
      
      destAddr.fAddressType = AF_ATALK_DDP;
      destAddr.fNetwork = destNet;
      destAddr.fNodeID = destNode;
      destAddr.fSocket = kEchoSocketID;
      destAddr.fDDPType = kEchoType;
      
      /* Set up data buffer for the Echo Request */

      /* indicate packet is an echo request packet */
      buf[0] = kEchoRequest;
      
         /* fill in the buffer with the string */
      BlockMove((Ptr)&amp;buf1, (Ptr)&amp;buf[1], sizeof(buf1));

      /* set up unitdata fields */
      //
      unitdata.udata.buf = (UInt8*)buf;// data area
      unitdata.udata.len = kddpMaxNormData;
      unitdata.addr.buf = (UInt8*)&amp;destAddr;// address area
      unitdata.addr.len = kDDPAddressLength;
      unitdata.opt.len = 0; // no options being sent
   }
   
   /* Send the data */
   err = OTSndUData(ep, &amp;unitdata);
   
   /* If no error occured sending the data, then process */
   /* expected the Echo Response.*/
   if (err == kOTNoError)
   {
      while (done == false)
      {
         result = OTLook(ep);
         if ( result == T_DATA )
         {
            while (done == false)
            {
      /* Set up the UnitData structure to recieve response packet */
      /* Set up the udata and address area to accomodate either an */
      /* M_DATA response or the typical response where the data */
      /* and addr fields are filled in. */
               
               unitdata.udata.buf = (UInt8*)buf;/* data area */
               unitdata.udata.len = 0;
               unitdata.udata.maxlen = kddpMaxRawData;
               unitdata.addr.buf = (UInt8*)&amp;destAddr;/* address area 
               unitdata.addr.maxlen = kDDPAddressLength;
               unitdata.opt.maxlen = 0; /* no options are expected */
               
      /* note that we reuse the buffer we used to send the echo */
      /* request packet with.  After the OTSnd completes in */
      /* synchronous mode successfully, the buffer has been released */
      /* for use by the program. */
                result = OTRcvUData(ep, &amp;unitdata, &amp;flags);
               
                if (result == kOTNoDataErr)
                {
                  done = true;
   /* whenever there is a data indication, it's best to read the data */
   /* until the kOTNoDataErr since this releases memory that OT has */
   /* reserved for the data. In this case, we've consumed all */
   /* available data and are ready to exit this function. */
                }
                else if (result &lt; 0)
                {
                  fprintf(stderr, &quot;unknown error occurred reading
                                 data - %ld\n&quot;, result);
                  done = true;
                }
                else if (result == kOTNoError)
                {
                  /* read echo reply successfully */
                  /* continue to read until kOTNoDataErr occurs. */
                  fprintf(stderr, &quot;%ld bytes read.\n&quot;,
                                    unitdata.udata.len);
                }
            }
            
         }
         else
         {
         /* an event other than T_DATA occurred */
            
         }
         /* another way to escape this routine. */
         if (Button())
            done = true;
      }
   }
}

</PRE>
 <P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-50.html#HEADING50-3">Using Option Management to Set Raw Mode</A>
<DD>
<DT><A HREF="NetworkingWOT-50.html#HEADING50-8">Testing for Raw Mode Support</A>
<DD>
<DT><A HREF="NetworkingWOT-50.html#HEADING50-12">Sending and Receiving in Raw Mode at the Protocol Level</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-49.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-51.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
