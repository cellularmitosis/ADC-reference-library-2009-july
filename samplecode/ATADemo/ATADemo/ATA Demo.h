#ifndef __ATA_DEMO_H__#define __ATA_DEMO_H__//------------------------------------------------------------------------------------#pragma mark Defines//------------------------------------------------------------------------------------//// Identifies the bus protocol type.//enum {	kDevUnknown		=	0,	kDevATA			=	1,	kDevATAPI		=	2,	kDevPCMCIA		=	3};//// Identifies the Socket type.//enum {	kSocketUnknown		=	0,	kSocketInternal		=	1,	kSocketMediaBay		=	2,	kkSocketPCMCIA		=	3};// .AppleCD contants enum	{	csSetPowerMode	=	70,	csQuiescence	=	0x437	};enum	{	pmActive		=	0,	pmStandby		=	1,	pmIdle			=	2,	pmSleep			=	3	};enum	{	quiescenceON	=	0,	quiescenceOFF	=	1	};//------------------------------------------------------------------------------------#pragma mark Macros//------------------------------------------------------------------------------------#define CLEAR(what) do {						\		register Ptr		_ptr = (Ptr) &what;	\		register Size		_len = sizeof what;	\		for (; _len > 0; --_len)					\			*_ptr++ = 0;						\	} while (0)#define IF_ERROR(_err_,_str_) if (_err_ != noErr) { printf(_str_); return (_err_); }//------------------------------------------------------------------------------------#pragma mark -//------------------------------------------------------------------------------------#pragma mark Identify Drive Info//------------------------------------------------------------------------------------////  Bit fields returned from Identify Drive command//enum {	magdrv_bit		=	15,			/* WORD 0: bit number of mag drive indicator	*/	rcd_bit			=	7,			/* WORD 0: bit number of removable indicator	*/	fixed_bit		=	6,			/* WORD 0: bit number of fixed disk indicator	*/	lbamode_bit		=	9,			/* bit number of lba support indicator			*/	iordy_bit		=	11,			/* bit number of IORDY support indicator		*/	extvalid_bit	=	1,			/* bit number of valid extension word			*/	mode3_bit		=	0,			/* WORD 64: bit number of mode 3 support		*/		kMagDrv			=	1 << magdrv_bit,	/* Bit 15 = 0 -> a magnetic drive		*/	kRemovable		=	1 << rcd_bit,		/* Bit 7 != 0 -> removable cartridge	*/	kFixed			=	1 << fixed_bit,		/* Bit 6 != 0 -> indicates fixed drive	*/	kLBAMode		=	1 << lbamode_bit,	/* LBA support indicator				*/	kIORDY			=	1 << iordy_bit,		/* IORDY support indicator				*/	kExtValid		=	1 << extvalid_bit,	/* Extension word valid					*/	MODE3BIT		=	1 << mode3_bit		/* mode 3 bit in word 64 of ident data	*/};//// This is returned by the device in response to an IDENTIFY command (512 bytes).//typedef	struct IdentifyBlock {	/* Structure of Identify data						*/	short	Signature;			/* Word 00: Constant value							*/	short	NumCyls;			/* Word 01:	Number of cylinders (default mode)			*/	short	RSVD0;				/* Word 02:	Constant value of 0						*/	short	NumHds;				/* Word 03:	Number of heads (default mode)			*/	short	TrkBytes;			/* Word 04:	Number of unformatted bytes/track		*/	short	SecBytes;			/* Word 05:	Number of unformatted bytes/sector		*/	short	NumSecs;			/* Word 06:	Number of sectors/track					*/	short	VU0;				/* Word 07:	Vendor unique							*/	short	VU1;				/* Word 08:	Vendor unique							*/	short	VU2;				/* Word 09:	Vendor unique							*/	short	Serial[10];			/* Word 10-19:	Serial Number (right-justified)		*/	short	BufType;			/* Word 20:	Buffer Type								*/	short	BufSize;			/* Word 21:	Buffer size in 512 byte increments		*/	short	NumECC;				/* Word 22:	Number of ECC bytes						*/	short	FirmRev[4];			/* Word 23-26:	Firmware revision (left-justified)	*/	short	ModelNum[20];		/* Word 27-46:	Model number (left-justified)		*/	short	MultCmds;			/* Word 47:	R/W multiple commands not impl = 0		*/	short	DblXferFlag;		/* Word 48:	Double transfer flag					*/	short	Capabilities;		/* Word 49: LBA, DMA, IORDY support indicator		*/	short	Reserved1;			/* Word 50: Reserved								*/	short	PIOTiming;			/* Word 51: PIO transfer timing mode				*/	short	DMATiming;			/* Word 52:	DMA transfer timing mode				*/	short	Extension;			/* Word 53: extended info support					*/	short	CurCylinders;		/* Word 54: number of current cylinders				*/	short	CurHeads;			/* Word 55: number of current heads					*/	short	CurSPT;				/* Word 56: number of current sectors per track		*/	short	CurCapacity[2];		/* Word 57-58: current capacity in sectors			*/	short	MultSectors;		/* Word 59: Multiple sector setting					*/	short	LBACapacity[2];		/* Word 60-61: total sectors in LBA mode			*/	short	SWDMA;				/* Word 62: single word DMA support					*/	short	MWDMA;				/* Word 63: multi word DMA support					*/	short	APIOModes;			/* Word 64:	Advanced PIO Xfr mode supported			*/	short	MDMATiming;			/* Word 65:	Minimum Multiword DMA Xfr Cycle			*/	short	RDMATiming;			/* Word 66:	Recommended Multiword DMA Cycle			*/	short	MPIOTiming;			/* Word 67:	Min PIO XFR Time W/O Flow Control		*/	short	PIOwRDYTiming;		/* Word 68:	Min PIO XFR Time with IORDY flow ctrl	*/	short	Reserved[187];		/* Word 69-255: Reserved							*/} IdentifyBlock;//// The following structure and table simplifies the formatting.//enum {	kEndOfTable = 0,			/* Marker											*/	kDecimal,					/* Signed integer (two words are high..low)			*/	kHex,						/* Bitfield											*/	kLeftJust,					/* Ascii, left-justified, space padded				*/	kRightJust					/* Ascii, right-justified, space padded				*/};struct FormatTable {	short		firstWord;		/* First word in IdentifyBlock cast to short vector	*/	short		lastWord;		/* Last word in IdentifyBlock cast to short vector	*/	short		format;			/* Format from above enum							*/	const char	*label;			/* Text to display									*/};typedef struct FormatTable FormatTable, *FormatTablePtr;//------------------------------------------------------------------------------------#pragma mark Prototypes//------------------------------------------------------------------------------------Boolean 	ATAManagerPresent	(void);Boolean 	ATAHardwarePresent	(void);Boolean 	TrapAvailable		(short theTrap);void 		PrintNumVersion		(char *label, NumVersion version );OSErr 		DisplayATAManagerInquiryInfo (void);OSErr 		ScanATABusses 		(void);OSErr 		DisplayATADriveIdentity (UInt32 deviceID );void		DumpRawBuffer		( UInt8 *bufferPtr, int length );void		DumpFormatedBuffer	(void* p, const  FormatTablePtr formatPtr);char*		DrvrRefToName		(short refNum);OSErr 		DisableCDDriver 	(SInt16 refNum);OSErr 		EnableCDDriver 		(SInt16 refNum);OSErr 		WakeUpCDDrive 		(SInt16 refNum);OSErr 		SetQuiescence 		(SInt16 refNum, UInt16 mode);OSErr		ATARead( UInt32 deviceID, UInt8* buffer );OSErr		ATAPIRead( UInt32 deviceID, UInt8* buffer );//------------------------------------------------------------------------------------#pragma mark -#endif