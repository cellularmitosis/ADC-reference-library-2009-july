<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing a Query Definition Function(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING486></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-485.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-487.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-469.html"><B>Chapter 12 - Data Access Manager</B></A> / <A HREF="IAC-482.html"><B>Creating a Query Document</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING486-0></A>
<H2><A NAME=MARKER-9-238></A><A NAME=MARKER-21-239></A>Writing a Query Definition Function</H2>
 Before the <CODE>DBStartQuery</CODE> function sends a query to a data server, it calls the query definition function specified by the <CODE>queryProc</CODE> field in the query record. The purpose of the query definition function is to modify the query and the query record before the query is sent to the data server. The query definition function can use dialog boxes to request information from the user. Because a query document is most useful if it can be used by many different applications, no query definition function should depend on the presence of a particular application.<P>
 If you want to include a query definition function, you must make it the first piece of code in a resource of type <CODE>'qdef'</CODE> in the query document. <P>
 Here is a function declaration for a query definition function. <A NAME=MARKER-2-240></A><P>
<PRE>
FUNCTION MyQDef (VAR sessID: LongInt; query: QueryHandle): OSErr;
</PRE>
 If the application has already initiated a session with the data server, the <CODE>DBStartQuery</CODE> function passes the session ID for that session in the <CODE>sessID</CODE> parameter to the query definition function. If the query definition function receives a 0 in this parameter, then the Data Access Manager has not initiated a session. In this case, the query definition function can return a 0 in the <CODE>sessID</CODE> parameter, or it can call the <CODE>DBInit</CODE> function to initiate a session and then return the session ID in this parameter. <P>
 If the query definition function returns a 0 in the <CODE>sessID</CODE> parameter, the <CODE>DBStartQuery</CODE> function calls the <CODE>DBInit</CODE> function and then calls the <CODE>DBSend</CODE> function to send a query to the data server. If the query definition function returns a session ID in this parameter, the <CODE>DBStartQuery</CODE> function calls the <CODE>DBSend</CODE> function immediately.<P>
 The <CODE>query</CODE> parameter to the query definition function specifies a handle to the query record. The query definition function can modify any of the fields in the query record, including the <CODE>currQuery</CODE> field that specifies which query is to be sent to the data server. In addition, the query definition function can modify an existing query or create a new query, adding the handle to the new query to the query list. Note that, because a query in memory consists only of a 2-byte length value followed by a character string, the query definition function has to know the exact contents and structure of a query in order to modify it.<P>
 The query definition function must return the <CODE>noErr</CODE> result code as the function result if the function executed successfully. If it returns any other value, the <CODE>DBStartQuery</CODE> function does not call the <CODE>DBSend</CODE> function. The query definition function can return any result code, including <CODE>noErr</CODE>, <CODE>userCanceledErr</CODE>, or <CODE>rcDBError</CODE>.<P>
 When the <CODE>DBStartQuery</CODE> function calls the query definition function, the current resource file is the file that contains the <CODE>'qrsc'</CODE> resource from which the Data Access Manager created the query record. When the query definition function returns control to the Data Access Manager, the current resource file must be unchanged. See the chapter "Resource Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I> for more information on the current resource file.<P>
 The query definition function can allocate memory and use the <CODE>dataHandle</CODE> field in the query record to store a handle to it. The query definition function must free any memory it allocates before terminating.<P>
 <A HREF=#MARKER-9-241>Listing 12-7</A> shows a query definition function that uses a dialog box to prompt the user for a user name and password and then modifies the query record accordingly.<P>
<B>Listing 12-7  <A NAME=MARKER-9-241></A><A NAME=MARKER-21-242></A>A query definition function</B><P>
<PRE>
FUNCTION MyQDef(VAR sessID: LongInt; query: QueryHandle): OSErr;
CONST
   myNameItem        =  7;
   myPassWordItem    =  8;
VAR
   myNumRes:         Integer;
   myResList:        ResListHandle;
   myResLPtr:        ResListPtr;
   myIndex:          Integer;
   myDialog:         DialogPtr;
   myDlogID:         Integer;
   itemType:         Integer;
   itemHName:        Handle;
   itemHPasswd:      Handle;
   itemBox:          Rect;
   mySTR:            ARRAY[1..2] OF Str255;
   itemHit:          Integer;
   myQErr:           OsErr;
BEGIN
   {If sessID = 0 no session has been initiated. Your qdef may }
   { optionally initiate a session, or it can let DBStartQuery }
   { take care of this.  In this example, the qdef doesn't }
   { check the sessID parameter.}
   HLock(Handle(query));
   myNumRes := query^^.numRes;
   myResList := query^^.resList;
   HLock(Handle(myResList));
   myResLPtr := myResList^;
   myIndex := 0;
   {look for a 'DLOG' resource}
   WHILE (myIndex &lt; myNumRes) AND
         (myResLPtr^[myIndex].theType &lt;&gt; 'DLOG') DO
   BEGIN
      myIndex := myIndex + 1;
   END;
   IF (myIndex &lt; myNumRes) THEN  {found the 'DLOG' resource}
      myDlogID := myResLPtr^[myIndex].id
   ELSE
   BEGIN
      {The 'DLOG' wasn't found; exit with no error.  This }
      { is probably OK; it just means that the query }
      { and the query record don't get modified.}
      MyQDEF := noErr;
      HUnlock(Handle(query));
      HUnlock(Handle(myResList));
      EXIT(MyQDef);
   END;
   {found the 'DLOG' and its ID; now display the dialog box}
   myDialog := GetNewDialog(myDlogID, Ptr(NIL), WindowPtr(-1));
   SetPort(GrafPtr(myDialog));
   REPEAT
      ModalDialog(@MyEventFilter, itemHit);
   UNTIL ((itemHit = kOK) OR (itemHit = kCancel));
   IF itemHit = kOK THEN
   BEGIN
      {The user clicked the OK button. Update the user }
      { and password fields of the query record.}
      GetDialogItem(myDialog, myNameItem, itemType, itemHName,
                    itemBox);
      GetDialogItemText(itemHName, mySTR[1]);
      GetDialogItem(myDialog, myPassWordItem, itemType, 
                  itemHPasswd, itemBox);
      GetDialogItemText(itemHPasswd, mySTR[2]);
      {Now you can change the query record or the query itself. }
      { What you change is entirely up to you. In this example, }
      { the qdef changes only the user and password fields }
      { of the query record.}
      query^^.user := mySTR[1];
      query^^.password := mySTR[2];
      MyQDef := noErr;
   END
   ELSE 
      MyQDef := userCanceledErr;
   HUnlock(Handle(query));
   HUnlock(Handle(myResList));
   DisposDialog(myDialog);
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-485.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-487.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
