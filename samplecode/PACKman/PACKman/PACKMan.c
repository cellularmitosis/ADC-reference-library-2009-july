//--------------------------------------------------------------------------//																			//		PACKman													//			by Scott “Zz” Zimmerman & Nick Thompson													//																			//		Description:	This snippet shows how to implement a simple//						Chooser Package, updated from Scott “Zz” Zimmerman's //						PACKman pascal sample										//																			//		Version:		1.0 Completed 10/19/94								// ////	Copyright:	© 1989-94 by Apple Computer, Inc., all rights reserved.//// Modification History:////	10/18/94		nick	converted from Pascal//	10/19/94		nick	updated to reflect info in IM: Devices (pages 1-42 ff)//							this sample is think C specific//// To do://		implement for metrowerks and MPW C//--------------------------------------------------------------------------#define	CHOOSERLISTSTRS		1024pascal OSErr MyPackage( short message, short caller, StringPtr objName, StringPtr objectName, long p1, long p2){	OSErr			theError ;		// store errors in here		Str255			tempStr1, tempStr2 ;		Str255			mainDevStr ;	// read in from resources	Str255			monitorStr ;		short			index ;		Cell			cellLoc;	short			deviceCount;	Handle			selectedItem;		SysEnvRec		sysInfo;	GDHandle		theDevice;		theError = noErr;	switch( message ) {			case newSelMsg: 			// Called to record the newly selected device. 			DebugStr("\pnewSel" ) ;			selectedItem = GetResource('STR ', -4099);			if( selectedItem != nil ) 			{				cellLoc.h = 0 ;				cellLoc.v = 0 ;				if(  LGetSelect(true, &cellLoc, (ListHandle)p1 ) ) {					(**((short **)selectedItem)) = cellLoc.v ;				}				else {					(**((short **)selectedItem)) = 0 ;				}								ChangedResource( selectedItem );				WriteResource( selectedItem );			}			break ;				case fillListMsg: 						// Count the gDevices (monitors) available on this Macintosh.						deviceCount = 1 ;				if((theError = SysEnvirons(1, &sysInfo)) == noErr ) 			{				// Okay, we got the system info, now see					// if we have Color Quickdraw.								if( sysInfo.hasColorQD )  {										// Okay, we have CQD, now how many monitors are connected?										theDevice = GetDeviceList();					while( (**theDevice).gdNextGD != nil ) {						deviceCount++;						theDevice = GetNextDevice(theDevice);					}										// Okay, p1 is the device list handle.						// So call the List Mangler to add some						// items.																		LAddRow(deviceCount, 0, (ListHandle)p1 ) ;					cellLoc.h = 0 ;					cellLoc.v = 0 ;										// load the strings we are going to use					GetIndString( mainDevStr, CHOOSERLISTSTRS, 1 ) ;					GetIndString( monitorStr, CHOOSERLISTSTRS, 2 ) ;										for( index = 1; index <= deviceCount; index++ ) {											if( index == 1 ) 						{							cellLoc.v = 0 ;															LSetCell(&mainDevStr[1], mainDevStr[0], cellLoc, (ListHandle)p1 ) ;													} 						else {								// get the device number converted to a string							NumToString(index, tempStr1) ;														// copy the monitor string into the other temp string							BlockMove( &monitorStr[1], &tempStr2[1], monitorStr[0] ) ;														// and adjust the length byte							tempStr2[0] = monitorStr[0];														// concatenate our monitor string and the monitor number							BlockMove( &tempStr1[1], &tempStr2[ tempStr2[0] + 1 ], tempStr1[0] ) ;									// and adjust the length byte							tempStr2[0] += tempStr1[0] ;														cellLoc.v = index - 1;							LSetCell(&tempStr2[1], tempStr2[0], cellLoc, (ListHandle)p1 ) ;						}					}				}			}			break ;		// This message is sent when the Chooser wants us to reselect the		// device that was selected the last time our PACK was used.  The		// ID of this item is stored in a string resource.						case getSelMsg: 		cellLoc.h = 0;		cellLoc.v = 0;		selectedItem = GetResource('STR ', -4099) ;		if(  selectedItem != nil ) 		{					while( LNextCell(false, true, &cellLoc, (ListHandle)p1) ) {							if(  cellLoc.v == (**((short **)selectedItem)) )					LSetSelect(true, cellLoc, (ListHandle)p1) ;				else					LSetSelect(false, cellLoc, (ListHandle)p1);			}		} 		else {					selectedItem = NewHandle(sizeof(short));			if(  selectedItem != nil ) {				(**((short **)selectedItem)) = cellLoc.v;				AddResource(selectedItem, 'STR ', -4099, "\p" );				WriteResource(selectedItem);			}			LSetSelect(true, cellLoc, (ListHandle)p1) ;		}		break ;		// Ignore these for now, since we don't know what they do, and it		// doesn't appear that we need them.									//	case selectMsg: 		DebugStr("\pselectMsg" );		break;			case deselectMsg: 		DebugStr("\pdeselectMsg" );		break;			case terminateMsg: 		DebugStr("\pterminateMsg" );		break;			case buttonMsg: 		DebugStr("\pbuttonMsg" );		break;		}	return theError;}