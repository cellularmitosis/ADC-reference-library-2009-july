<html><head><title>Mac OS X
 Manual Page For DBI::DBD(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/DBI::DBD" title="Mac OS X
 Manual Page for DBI::DBD(3pm)"><a name="//apple_ref/doc/man/3/DBI::DBD" title="Mac OS X
 Manual Page for DBI::DBD(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/DBI::DBD"; name=DBI::DBD(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
DBI::DBD(3)                          User Contributed Perl Documentation                         DBI::DBD(3)



<b>NAME</b>
       DBI::DBD - Perl DBI Database Driver Writer's Guide

<b>SYNOPSIS</b>
         perldoc DBI::DBD

       <b>Version</b> <b>and</b> <b>volatility</b>

       This document is <u>still</u> a minimal draft which is in need of further work.

       The changes will occur both because the DBI specification is changing and hence the requirements on
       DBD drivers change, and because feedback from people reading this document will suggest improvements
       to it.

       Please read the DBI documentation first and fully, including the DBI FAQ.  Then reread the DBI
       specification again as you're reading this. It'll help.

       This document is a patchwork of contributions from various authors.  More contributions (preferably
       as patches) are very welcome.

<b>DESCRIPTION</b>
       This document is primarily intended to help people writing new database drivers for the Perl Database
       Interface (Perl DBI).  It may also help others interested in discovering why the internals of a DBD
       driver are written the way they are.

       This is a guide.  Few (if any) of the statements in it are completely authoritative under all
       possible circumstances.  This means you will need to use judgement in applying the guidelines in this
       document.  If in <u>any</u> doubt at all, please do contact the dbi-dev mailing list (details given below)
       where Tim Bunce and other driver authors can help.

<b>CREATING</b> <b>A</b> <b>NEW</b> <b>DRIVER</b>
       The first rule for creating a new database driver for the Perl DBI is very simple: "DON'T!"

       There is usually a driver already available for the database you want to use, almost regardless of
       which database you choose.  And very often, the database will provide an ODBC driver interface, so
       you can often use DBD::ODBC to access the database.  This is typically less convenient on a Unix box
       than on a Microsoft Windows box, but there are numerous options for ODBC driver managers on Unix too,
       and very often the ODBC driver is provided by the database supplier.  Before deciding that you need
       to write a driver, do your homework to ensure that you are not wasting your energies.

       [As of December 2002, the consensus is that if you need an ODBC driver manager on Unix, then the
       unixODBC driver (available from &lt;<a href="http://www.unixodbc.org/">http://www.unixodbc.org/</a>) is the way to go.]

       The second rule for creating a new database driver for the Perl DBI is also very simple: "Don't --<font color="#ffffff" class="whiteout">get&nbsp;-get</font>
       get someone else to do it for you!"

       Nevertheless, there are occasions when it is necessary to write a new driver, often to use a
       proprietary language or API to access the database more swiftly, or more comprehensively, than an
       ODBC driver can.  Then you should read this document very carefully, but with a suitably sceptical
       eye.  If there is something in here that does not make any sense, question it.  You might be right
       that the information is bogus.  But don't come to that conclusion too quickly.

       <b>URLs</b> <b>and</b> <b>mailing</b> <b>lists</b>

       The primary web-site for locating DBI software and information is

         <a href="http://dbi.perl.org/">http://dbi.perl.org/</a>

       There are two main and one auxilliary mailing lists for people working with DBI.  The primary lists
       are dbi-users@perl.org for general users of DBI and DBD drivers, and dbi-dev@perl.org mainly for DBD
       driver writers (don't join the dbi-dev list unless you have a good reason).  The auxilliary list is
       dbi-announce@perl.org for announcing new releases of DBI or DBD drivers.

       You can join these lists by accessing the web-site &lt;<a href="http://dbi.perl.org/">http://dbi.perl.org/</a>.  The lists are closed so
       you cannot send email to any of the lists unless you join the list first.

       You should also consider monitoring the comp.lang.perl.* newsgroups, especially
       comp.lang.perl.modules.

       <b>The</b> <b>Cheetah</b> <b>book</b>

       The definitive book on Perl DBI is the Cheetah book, so called because of the picture on the cover.
       Its proper title is 'Programming the Perl DBI: Database programming with Perl' by Alligator Descartes
       and Tim Bunce, published by O'Reilly Associates, February 2000, ISBN 1-56592-699-4.  Buy it now if
       you have not already done so, and read it.

       <b>Locating</b> <b>drivers</b>

       Before writing a new driver, it is in your interests to find out whether there already is a driver
       for your database.  If there is such a driver, it would be much easier to make use of it than to
       write your own!

       The primary web-site for locating Perl software is &lt;<a href="http://search.cpan.org/">http://search.cpan.org/</a>.  You should look under
       the various modules listings for the software you are after. For example:

         <a href="http://search.cpan.org/modlist/Database_Interfaces">http://search.cpan.org/modlist/Database_Interfaces</a>

       Follow the DBD:: and DBIx:: links at the top to see those subsets.

       See the DBI docs for information on DBI web sites and mailing lists.

       <b>Registering</b> <b>a</b> <b>new</b> <b>driver</b>

       Before going through any official registration process, you will need to establish that there is no
       driver already in the works.  You'll do that by asking the DBI mailing lists whether there is such a
       driver available, or whether anybody is working on one.

       When you get the go ahead, you will need to establish the name of the driver and a prefix for the
       driver.  Typically, the name is based on the name of the database software it uses, and the prefix is
       a contraction of that.  Hence, DBD::Oracle has the name Oracle and the prefix 'ora_'.  This
       information will be recorded in the DBI module.  Apart from documentation purposes, registration is a
       prerequisite for installing private methods.

       This document assumes you are writing a driver called DBD::Driver, and that the prefix 'drv_' is
       assigned to the driver.

       <b>Two</b> <b>styles</b> <b>of</b> <b>database</b> <b>driver</b>

       There are two distinct styles of database driver that can be written to work with the Perl DBI.

       Your driver can be written in pure Perl, requiring no C compiler.  When feasible, this is the best
       solution, but most databases are not written in such a way that this can be done.  Some example pure
       Perl drivers are DBD::File and DBD::CSV.

       Alternatively, and most commonly, your driver will need to use some C code to gain access to the
       database.  This will be classified as a C/XS driver.

       <b>What</b> <b>code</b> <b>will</b> <b>you</b> <b>write?</b>

       There are a number of files that need to be written for either a pure Perl driver or a C/XS driver.
       There are no extra files needed only by a pure Perl driver, but there are several extra files needed
       only by a C/XS driver.

       <u>Files</u> <u>common</u> <u>to</u> <u>pure</u> <u>Perl</u> <u>and</u> <u>C/XS</u> <u>drivers</u>

       Assuming that your driver is called DBD::Driver, these files are:

          Makefile.PL

          README

          MANIFEST

          Driver.pm

          lib/Bundle/DBD/Driver.pm

          lib/DBD/Driver/Summary.pm

          t/*.t

       The first four files are mandatory.  Makefile.PL is used to control how the driver is built and
       installed.  The README file tells people who download the file about how to build the module and any
       prerequisite software that must be installed.  The MANIFEST file is used by the standard Perl module
       distribution mechanism.  It lists all the source files that need to be distributed with your module.
       Driver.pm is what is loaded by the DBI code; it contains the methods peculiar to your driver.

       The lib/Bundle/DBD/Driver.pm file allows you to specify other Perl modules on which yours depends in
       a format that allows someone to type a simple command and ensure that all the pre-requisites are in
       place as well as building your driver.  The lib/DBD/Driver/Summary.pm file contains (an updated
       version of) the information that was included - or that would have been included - in the appendices
       of the Cheetah book as a summary of the abilities of your driver and the associated database.

       The files in the t subdirectory are unit tests for your driver.  You should write your tests as
       stringently as possible, while taking into account the diversity of installations that you can
       encounter.  Your tests should not casually modify operational databases.  You should never damage
       existing tables in a database.  You should code your tests to use a constrained name space within the
       database.  For example, the tables (and all other named objects) that are created could all begin
       with 'dbd_drv_'.  At the end of a test run, there should be no testing objects left behind in the
       database.  If you create any databases, you should remove them.  If your database supports temporary
       tables that are automatically removed at the end of a session, then exploit them as often as
       possible.  Try to make your tests independent of each other.  If you have a test t/t11dowhat.t that
       depends upon the successful running of t/t10thingamy.t, people cannot run the single test case
       t/t11dowhat.t.  Further, running t/t11dowhat.t twice in a row is likely to fail (at least, if
       t/t11dowhat.t modifies the database at all) because the database at the start of the second run is
       not what you saw at the start of the first run.  Document in your README file what you do, and what
       privileges people need to do it.  You can, and probably should, sequence your tests by including a
       test number before an abbreviated version of the test name; the tests are run in the order in which
       the names are expanded by shell-style globbing.

       Many drivers also install sub-modules DBD::Driver::SubModule for any of a variety of different
       reasons, such as to support the metadata methods (see the discussion of "METADATA METHODS" below).
       Such sub-modules are conventionally stored in the directory lib/DBD/Driver.  The module itself would
       usually be in a file SubModule.pm.  All such sub-modules should themselves be version stamped (see
       the discussions far below).

       <u>Extra</u> <u>files</u> <u>needed</u> <u>by</u> <u>C/XS</u> <u>drivers</u>

       The software for a C/XS driver will typically contain at least four extra files that are not relevant
       to a pure Perl driver.

          Driver.xs

          Driver.h

          dbdimp.h

          dbdimp.c

       The Driver.xs file is used to generate C code that Perl can call to gain access to the C functions
       you write that will, in turn, call down onto your database software.

       The Driver.h header is a stylized header that ensures you can access the necessary Perl and DBI
       macros, types, and function declarations.

       The dbdimp.h is used to specify which functions have been implemented by your driver.

       The dbdimp.c file is where you write the C code that does the real work of translating between Perl-
       ish data types and what the database expects to use and return.

       There are some (mainly small, but very important) differences between the contents of Makefile.PL and
       Driver.pm for pure Perl and C/XS drivers, so those files are described both in the section on
       creating a pure Perl driver and in the section on creating a C/XS driver.

       Obviously, you can add extra source code files to the list.

       <b>Requirements</b> <b>on</b> <b>a</b> <b>driver</b> <b>and</b> <b>driver</b> <b>writer</b>

       To be remotely useful, your driver must be implemented in a format that allows it to be distributed
       via CPAN, the Comprehensive Perl Archive Network (<a href="http://www.cpan.org/">http://www.cpan.org/</a> and <a href="http://search.cpan.org)">http://search.cpan.org)</a>
       Of course, it is easier if you do not have to meet this criterion, but you will not be able to ask
       for much help if you do not do so, and no-one is likely to want to install your module if they have
       to learn a new installation mechanism.

<b>CREATING</b> <b>A</b> <b>PURE</b> <b>PERL</b> <b>DRIVER</b>
       Writing a pure Perl driver is surprisingly simple. However, there are some problems you should be
       aware of. The best option is of course picking up an existing driver and carefully modifying one
       method after the other.

       Also look carefully at DBD::AnyData and DBD::Template.

       As an example we take a look at the <u>DBD::File</u> driver, a driver for accessing plain files as tables,
       which is part of the <u>DBD::CSV</u> package.  In what follows I assume the name "Driver" for your new
       package and the prefix 'drv_'.  The minimal set of files we have to implement are <u>Makefile.PL</u>,
       <u>README</u>, <u>MANIFEST</u> and <u>Driver.pm</u>.

       <b>Pure</b> <b>Perl</b> <b>version</b> <b>of</b> <b>Makefile.PL</b>

       You typically start with writing "Makefile.PL", a Makefile generator.  The contents of this file are
       described in detail in the "ExtUtils::MakeMaker" man pages.  It is definitely a good idea if you
       start reading them.  At least you should know about the variables <u>CONFIGURE</u>, <u>DEFINED</u>, <u>PM</u>, <u>DIR</u>,
       <u>EXE</u><b>_</b><u>FILES</u>, <u>INC</u>, <u>LIBS</u>, <u>LINKTYPE</u>, <u>NAME</u>, <u>OPTIMIZE</u>, <u>PL</u><b>_</b><u>FILES</u>, <u>VERSION</u>, <u>VERSION</u><b>_</b><u>FROM</u>, <u>clean</u>, <u>depend</u>,
       <u>realclean</u> from the "ExtUtils::MakeMaker" man page: These are used in almost any Makefile.PL.
       Additionally read the section on <u>Overriding</u> <u>MakeMaker</u> <u>Methods</u> and the descriptions of the <u>distcheck</u>,
       <u>disttest</u> and <u>dist</u> targets: They will definitely be useful for you.

       Of special importance for DBI drivers is the <u>postamble</u> method from the "ExtUtils::MM_Unix" man page.
       And, for Emacs users, I recommend the <u>libscan</u> method, which removes Emacs backup files (file names
       which end with a tilde '~') from lists of files.

       Now an example, I use the word "Driver" wherever you should insert your driver's name:

         # -*- perl -*-

         use DBI 1.03;
         use DBI::DBD;
         use ExtUtils::MakeMaker;

         WriteMakefile(
             dbd_edit_mm_attribs( {
                 'NAME'         =&gt; 'DBD::Driver',
                 'VERSION_FROM' =&gt; 'Driver.pm',
                 'INC'          =&gt; $DBI_INC_DIR,
                 'dist'         =&gt; { 'SUFFIX'   =&gt; '.gz',
                                     'COMPRESS' =&gt; 'gzip -9f' },
                 'realclean'    =&gt; { FILES =&gt; '*.xsi' },
             },
             { create_pp_tests =&gt; 1})
         );

         package MY;
         sub postamble { return main::dbd_postamble(@_); }
         sub libscan {
             my ($self, $path) = @_;
             ($path =~ m/\~$/) ? undef : $path;
         }

       Note the calls to "dbd_edit_mm_attribs"() and "dbd_postamble"().  The second hash reference in the
       call to "dbd_edit_mm_attribs" (containing "create_pp_tests") is optional; you should not use it
       unless your driver is a pure Perl driver (that is, it does not use C and XS code).  Therefore, the
       call to "dbd_edit_mm_attribs" is not relevant for C/XS drivers and may be omitted; simply use the
       (single) hash reference containing NAME etc as the only argument to "WriteMakefile"().  Note that the
       "dbd_edit_mm_attribs" code will fail if you do not have a "t" sub-directory containing at least one
       test case.  All drivers must use "dbd_postamble" or risk running into problems.

       Note the specification of VERSION_FROM; the named file (Driver.pm) will be scanned for the first line
       that looks like an assignment to $VERSION, and the subsequent text will be used to determine the
       version number.  Note the commentary in ExtUtils::MakeMaker on the subject of correctly formatted
       version numbers.

       If your driver depends upon external software (it usually will), you will need to add code to ensure
       that your environment is workable before the call to "WriteMakefile"().  A full-fledged Makefile.PL
       can be quite large (for example, the files for DBD::Oracle and DBD::Informix are both over 1000 lines
       long, and the Informix one uses - and creates - auxilliary modules too).

       See also ExtUtils::MakeMaker and ExtUtils::MM_Unix.  Consider using CPAN::MakeMaker in place of
       ExtUtils::MakeMaker.

       <b>README</b>

       The README file should describe what the driver is for, the pre-requisites for the build process, the
       actual build process, how to report errors, and who to report them to.  Users will find ways of
       breaking the driver build and test process which you would never even have dreamed to be possible in
       your worst nightmares.  Therefore, you need to write this document defensively, precisely and
       concisely.  Also, it is in your interests to ensure that your tests work as widely as possible.  As
       always, use the README from one of the established drivers as a basis for your own; the version in
       DBD::Informix is worth a look as it has been quite successful in heading off problems.

        Note that users will have versions of Perl and DBI that are both older and newer than you expected,
         but this will seldom cause much trouble.  When it does, it will be because you are using features
         of DBI that are not supported in the version they are using.

        Note that users will have versions of the database software that are both older and newer than you
         expected.  You will save yourself time in the long run if you can identify the range of versions
         which have been tested and warn about versions which are not known to be OK.

        Note that many people trying to install your driver will not be experts in the database software.

        Note that many people trying to install your driver will not be experts in C or Perl.

       <b>MANIFEST</b>

       The MANIFEST will be used by the Makefile's dist target to build the distribution tar file that is
       uploaded to CPAN. It should list every file that you want to include in your distribution, one per
       line.

       <b>lib/Bundle/DBD/Driver.pm</b>

       The CPAN module provides an extremely powerful bundle mechanism that allows you to specify pre-
       requisites for your driver.  The primary pre-requisite is Bundle::DBI; you may want or need to add
       some more.  With the bundle set up correctly, the user can type:

               perl -MCPAN -e 'install Bundle::DBD::Driver'

       and Perl will download, compile, test and install all the Perl modules needed to build your driver.

       A suitable skeleton for this file is shown below.  The prerequisite modules are listed in the
       "CONTENTS" section, with the official name of the module followed by a dash and an informal name or
       description.  Listing Bundle::DBI as the main pre-requisite simplifies life.  Don't forget to list
       your driver.  Note that unless the DBMS is itself a Perl module, you cannot list it as a pre-
       requisite in this file.  You should keep the version of the bundle the same as the version of your
       driver.  You should add configuration management, copyright, and licencing information at the top.

         package Bundle::DBD::Driver;

         $VERSION = '0.01';

         1;

         __END__

         =head1 NAME

         Bundle::DBD::Driver - A bundle to install all DBD::Driver related modules

         =head1 SYNOPSIS

         C&lt;perl -MCPAN -e 'install Bundle::DBD::Driver'&gt;

         =head1 CONTENTS

         Bundle::DBI  - Bundle for DBI by TIMB (Tim Bunce)

         DBD::Driver  - DBD::Driver by YOU (Your Name)

         =head1 DESCRIPTION

         This bundle includes all the modules used by the Perl Database
         Interface (DBI) driver for Driver (DBD::Driver), assuming the
         use of DBI version 1.13 or later, created by Tim Bunce.

         If you've not previously used the CPAN module to install any
         bundles, you will be interrogated during its setup phase.
         But when you've done it once, it remembers what you told it.
         You could start by running:

           C&lt;perl -MCPAN -e 'install Bundle::CPAN'&gt;

         =head1 SEE ALSO

         Bundle::DBI

         =head1 AUTHOR

         Your Name E&lt;lt&gt;F&lt;you@yourdomain.com&gt;E&lt;gt&gt;

         =head1 THANKS

         This bundle was created by ripping off Bundle::libnet created by
         Graham Barr E&lt;lt&gt;F&lt;gbarr@ti.com&gt;E&lt;gt&gt;, and radically simplified
         with some information from Jochen Wiedmann E&lt;lt&gt;F&lt;joe@ispsoft.de&gt;E&lt;gt&gt;.
         The template was then included in the DBI::DBD documentation by
         Jonathan Leffler E&lt;lt&gt;F&lt;jleffler@informix.com&gt;E&lt;gt&gt;.

         =cut

       <b>lib/DBD/Driver/Summary.pm</b>

       There is no substitute for taking the summary file from a driver that was documented in the Perl book
       (such as DBD::Oracle or DBD::Informix or DBD::ODBC, to name but three), and adapting it to describe
       the facilities available via DBD::Driver when accessing the Driver database.

       <b>Pure</b> <b>Perl</b> <b>version</b> <b>of</b> <b>Driver.pm</b>

       The "Driver.pm" file defines the Perl module DBD::Driver for your driver.  It will define a package
       DBD::Driver along with some version information, some variable definitions, and a function <u>driver()</u>
       which will have a more or less standard structure.

       It will also define three sub-packages of DBD::Driver:

       DBD::Driver::dr
         with methods <u>connect()</u>, <u>data</u><b>_</b><u>sources()</u> and <u>disconnect</u><b>_</b><u>all()</u>;

       DBD::Driver::db
         with methods such as <u>prepare()</u>;

       DBD::Driver::st
         with methods such as <u>execute()</u> and <u>fetch()</u>.

       The Driver.pm file will also contain the documentation specific to DBD::Driver in the format used by
       perldoc.

       In a pure Perl driver, the Driver.pm file is the core of the implementation.  You will need to
       provide all the key methods needed by DBI.

       Now let's take a closer look at an excerpt of File.pm as an example.  We ignore things that are
       common to any module (even non-DBI modules) or really specific to the DBD::File package.

       <u>The</u> <u>DBD::Driver</u> <u>package</u>

       The header

         package DBD::File;

         use strict;
         use vars qw($VERSION $drh);

         $VERSION = "1.23.00"  # Version number of DBD::File

       This is where the version number of your driver is specified.  The code in Makefile.PL is told to
       look in this file for the information.  It is recommended that you use a two-part (1.23) or three-
       part (1.23.45) version number.  Please ensure that any other modules added with your driver are also
       version stamped so that CPAN does not get confused.  Also consider the CPAN system, which gets
       confused and considers version 1.10 to precede version 1.9, so that using a raw CVS, RCS or SCCS
       version number is probably not appropriate (despite being very common). For RCS or CVS you can use
       this code:

         $VERSION = sprintf "%d.%02d", '$Revision: 11.21 $ ' =~ /(\d+)\.(\d+)/;

       which pads out the fractional part with leading zeros so all is well (so long as you don't go past
       x.99)

         $drh = undef;         # holds driver handle once initialized

       This is where the driver handle will be stored, once created.  Note that you may assume there is only
       one handle for your driver.

       The driver constructor

       Note that the <u>driver</u> method is in the DBD::Driver package, not in one of the sub-packages
       DBD::Driver::dr, DBD::Driver::db, or DBD::Driver::db.

         sub driver
         {
             return $drh if $drh;      # already created - return same one
             my ($class, $attr) = @_;

             $class .= "::dr";

             # not a 'my' since we use it above to prevent multiple drivers
             $drh = DBI::_new_drh($class, {
                     'Name'        =&gt; 'File',
                     'Version'     =&gt; $VERSION,
                     'Attribution' =&gt; 'DBD::File by Jochen Wiedmann',
                 })
                 or return undef;

             return $drh;
         }

       The <u>driver</u> method is the driver handle constructor. It's a reasonable example of how DBI implements
       its handles. There are three kinds: <b>driver</b> <b>handles</b> (typically stored in $drh; from now on called
       "drh" or $drh), <b>database</b> <b>handles</b> (from now on called "dbh" or $dbh) and <b>statement</b> <b>handles</b> (from now
       on called "sth" or $sth).

       The prototype of DBI::_new_drh is

         $drh = DBI::_new_drh($class, $public_attrs, $private_attrs);

       with the following arguments:

       <u>$class</u>
           is typically the class for your driver, (for example, "DBD::File::dr"), passed as the first
           argument to the <u>driver</u> method.

       <u>$public</u><b>_</b><u>attrs</u>
           is a hash ref to attributes like <u>Name</u>, <u>Version</u>, and <u>Attribution</u>.  These are processed and used by
           DBI.  You had better not make any assumptions about them nor should you add private attributes
           here.

       <u>$private</u><b>_</b><u>attrs</u>
           This is another (optional) hash ref with your private attributes.  DBI will store them and
           otherwise leave them alone.

       The <u>DBI::new</u><b>_</b><u>drh</u> method and the <u>driver</u> method both return "undef" for failure (in which case you must
       look at $DBI::err and $DBI::errstr for the failure information, because you have no driver handle to
       use).

       The CLONE special subroutine

       Also needed here, in the DBD::Driver package, is a <u>CLONE()</u> method that will be called by perl when an
       intrepreter is cloned. All your CLONE method needs to do, currently, is clear the cached $drh so the
       new interpreter won't start using the cached $drh from the old interpreter:

         sub CLONE {
           undef $drh;
         }

       See &lt;<a href="http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe">http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe</a> for details.

       <u>The</u> <u>DBD::Driver::dr</u> <u>package</u>

       The database handle constructor

       The next lines of code look as follows:

         package DBD::Driver::dr; # ====== DRIVER ======

         $DBD::Driver::dr::imp_data_size = 0;

       Note that no @ISA is needed here, or for the other DBD::Driver::* classes, because the DBI takes care
       of that for you when the driver is loaded.

       The database handle constructor is a driver method, thus we have to change the namespace.

         sub connect
         {
             my ($drh, $dr_dsn, $user, $auth, $attr) = @_;

             # Some database specific verifications, default settings
             # and the like can go here. This should only include
             # syntax checks or similar stuff where it's legal to
             # 'die' in case of errors.
             # For example, many database packages requires specific
             # environment variables to be set; this could be where you
             # validate that they are set, or default them if they are not set.

             my $driver_prefix = "drv_"; # the assigned prefix for this driver

             # Process attributes from the DSN; we assume ODBC syntax
             # here, that is, the DSN looks like var1=val1;...;varN=valN
             foreach my $var ( split /;/, $dr_dsn ) {
                 my ($attr_name, $attr_value) = split '=', $var, 2;
                 return $drh-&gt;set_err(1, "Can't parse DSN part '$var'")
                     unless defined $attr_value;

                 # add driver prefix to attribute name if it doesn't have it already
                 $attr_name = $driver_prefix.$attr_name
                     unless $attr_name =~ /^$driver_prefix/o;

                 # Store attribute into %$attr, replacing any existing value.
                 # The DBI will STORE() these into $dbh after we've connected
                 $attr-&gt;{$attr_name} = $attr_value;
             }

             # Get the attributes we'll use to connect.
             # We use delete here because these no need to STORE them
             my $db = delete $attr-&gt;{drv_database} || delete $attr-&gt;{drv_db}
                 or return $drh-&gt;set_err(1, "No database name given in DSN '$dr_dsn'");
             my $host = delete $attr-&gt;{drv_host} || 'localhost';
             my $port = delete $attr-&gt;{drv_port} || 123456;

             # Assume you can attach to your database via drv_connect:
             my $connection = drv_connect($db, $host, $port, $user, $auth)
                 or return $drh-&gt;set_err(1, "Can't connect to $dr_dsn: ...");

             # create a 'blank' dbh (call superclass constructor)
             my ($outer, $dbh) = DBI::_new_dbh($drh, { Name =&gt; $dr_dsn });

             $dbh-&gt;STORE('Active', 1 );
             $dbh-&gt;{drv_connection} = $connection;

             return $outer;
         }

       The Name attribute is a standard DBI attribute.

       This is mostly the same as in the <u>driver</u> <u>handle</u> <u>constructor</u> above.  The arguments are described in
       the DBI man page.  See DBI.  The constructor _new_dbh is called, returning a database handle.  The
       constructor's prototype is:

         ($outer, $inner) = DBI::_new_dbh($drh, $public_attr, $private_attr);

       with similar arguments to those in the <u>driver</u> <u>handle</u> <u>constructor</u>, except that the $class is replaced
       by $drh.

       In scalar context, only the outer handle is returned.

       Note the use of the <u>STORE</u> method for setting the dbh attributes.  That's because within the driver
       code, the handle object you have is the 'inner' handle of a tied hash, not the outer handle that the
       users of your driver have.

       Because you have the inner handle, tie magic doesn't get invoked when you get or set values in the
       hash. This is often very handy for speed when you want to get or set simple non-special driver-<font color="#ffffff" class="whiteout">specific&nbsp;driverspecific</font>
       specific attributes.

       However, some attribute values, such as those handled by the DBI like PrintError, don't actually
       exist in the hash and must be read via $h-&gt;FETCH($attrib) and set via $h-&gt;STORE($attrib, $value).  If
       in any doubt, use these methods.

       The data_sources method

       The data_sources method must populate and return a list of valid data sources, prefixed with the
       "dbi:Driver" incantation that allows them to be used in the first argument of the "DBI-&gt;connect"
       method.  An example of this might be scanning the <u>$HOME/.odbcini</u> file on Unix for ODBC data sources
       (DSNs).  As a trivial example, consider a fixed list of data sources:

         sub data_sources
         {
             my($drh, $attr) = @_;
             my(@list) = ();
             # You need more sophisticated code than this to set @list...
             push @list, "dbi:Driver:abc";
             push @list, "dbi:Driver:def";
             push @list, "dbi:Driver:ghi";
             # End of code to set @list
             return @list;
         }

       Error handling

       It is quite likely that something fails in the connect method.  With DBD::File for example, you might
       catch an error when setting the current directory to something not existent by using the (driver-<font color="#ffffff" class="whiteout">specific)&nbsp;(driverspecific)</font>
       specific) f_dir attribute.

       To report an error, you use the "set_err" method:

         $h-&gt;set_err($err, $errmsg, $state);

       This will ensure that the error is recorded correctly and that RaiseError and PrintError etc are
       handled correctly.  Typically you'll always use the method instance, aka your method's first
       argument.

       As set_err always returns undef your error handling code can usually be simplified to something like
       this:

         return $h-&gt;set_err($err, $errmsg, $state) if ...;

       The disconnect_all method

       If you need to release any resources when the driver is unloaded, you can provide a disconnect_all
       method.

       Other driver handle methods

       If you need any other driver handle methods, they can follow here.

       <u>The</u> <u>DBD::Driver::db</u> <u>package</u>

       The statement handle constructor

       There's nothing much new in the statement handle constructor.

         package DBD::Driver::db; # ====== DATABASE ======

         $DBD::Driver::db::imp_data_size = 0;

         sub prepare
         {
             my ($dbh, $statement, @attribs) = @_;

             # create a 'blank' sth
             my ($outer, $sth) = DBI::_new_sth($dbh, { Statement =&gt; $statement });

             $sth-&gt;STORE('NUM_OF_PARAMS', ($statement =~ tr/?//));

             $sth-&gt;{drv_params} = [];

             return $outer;
         }

       This is still the same: check the arguments and call the super class constructor <u>DBI::</u><b>_</b><u>new</u><b>_</b><u>sth</u>.
       Again, in scalar context, only the outer handle is returned.  The "Statement" attribute should be
       cached as shown.

       Note the prefix <u>drv</u><b>_</b> in the attribute names: it is required that all your private attributes use a
       lowercase prefix unique to your driver.  The DBI contains a registry of known driver prefixes and may
       one day warn about unknown attributes that don't have a registered prefix.

       Note that we parse the statement here in order to set the attribute <u>NUM</u><b>_</b><u>OF</u><b>_</b><u>PARAMS</u>.  The technique
       illustrated is not very reliable; it can be confused by question marks appearing in quoted strings,
       delimited identifiers or in SQL comments that are part of the SQL statement.  We could set
       <u>NUM</u><b>_</b><u>OF</u><b>_</b><u>PARAMS</u> in the <u>execute</u> method instead because the DBI specification explicitly allows a driver
       to defer this, but then the user could not call <u>bind</u><b>_</b><u>param</u>.

       Transaction handling

       Pure Perl drivers will rarely support transactions. Thus your <u>commit</u> and <u>rollback</u> methods will
       typically be quite simple:

         sub commit
         {
             my ($dbh) = @_;
             if ($dbh-&gt;FETCH('Warn')) {
                 warn("Commit ineffective while AutoCommit is on");
             }
             0;
         }

         sub rollback {
             my ($dbh) = @_;
             if ($dbh-&gt;FETCH('Warn')) {
                 warn("Rollback ineffective while AutoCommit is on");
             }
             0;
         }

       Or even simpler, just use the default methods provided by the DBI that do nothing except return
       undef.

       The DBI's default begin_work method can be used by inheritance.

       The STORE and FETCH methods

       These methods (that we have already used, see above) are called for you, whenever the user does a:

         $dbh-&gt;{$attr} = $val;

       or, respectively,

         $val = $dbh-&gt;{$attr};

       See perltie for details on tied hash refs to understand why these methods are required.

       The DBI will handle most attributes for you, in particular attributes like <u>RaiseError</u> or <u>PrintError</u>.
       All you have to do is handle your driver's private attributes and any attributes, like AutoCommit and
       ChopBlanks, that the DBI can't handle for you.  A good example might look like this:

         sub STORE
         {
             my ($dbh, $attr, $val) = @_;
             if ($attr eq 'AutoCommit') {
                 # AutoCommit is currently the only standard attribute we have
                 # to consider.
                 if (!$val) { die "Can't disable AutoCommit"; }
                 return 1;
             }
             if ($attr =~ m/^drv_/) {
                 # Handle only our private attributes here
                 # Note that we could trigger arbitrary actions.
                 # Ideally we should warn about unknown attributes.
                 $dbh-&gt;{$attr} = $val; # Yes, we are allowed to do this,
                 return 1;             # but only for our private attributes
             }
             # Else pass up to DBI to handle for us
             $dbh-&gt;SUPER::STORE($attr, $val);
         }

         sub FETCH
         {
             my ($dbh, $attr) = @_;
             if ($attr eq 'AutoCommit') { return 1; }
             if ($attr =~ m/^drv_/) {
                 # Handle only our private attributes here
                 # Note that we could trigger arbitrary actions.
                 return $dbh-&gt;{$attr}; # Yes, we are allowed to do this,
                                       # but only for our private attributes
             }
             # Else pass up to DBI to handle
             $dbh-&gt;SUPER::FETCH($attr);
         }

       The DBI will actually store and fetch driver-specific attributes (with all lowercase names) without
       warning or error, so there's actually no need to implement driver-specific any code in your FETCH and
       STORE methods unless you need extra logic/checks, beyond getting or setting the value.

       Unless your driver documentation indicates otherwise, the return value of the STORE method is
       unspecified and the caller shouldn't use that value.

       Other database handle methods

       As with the driver package, other database handle methods may follow here.  In particular you should
       consider a (possibly empty) <u>disconnect</u> method and possibly a <u>quote</u> method if DBI's default isn't
       correct for you.

       Where reasonable use $h-&gt;<u>SUPER::foo()</u> to call the DBI's method in some or all cases and just wrap
       your custom behavior around that.

       If you want to use private trace flags you'll probably want to be able to set them by name. To do
       that you'll need to define a <u>parse</u><b>_</b><u>trace</u><b>_</b><u>flag()</u> method (note that's parse_trace_flag not
       parse_trace_flags).

         sub parse_trace_flag {
             my ($h, $name) = @_;
             return 0x01000000 if $name eq 'foo';
             return 0x02000000 if $name eq 'bar';
             return 0x04000000 if $name eq 'baz';
             return 0x08000000 if $name eq 'boo';
             return 0x10000000 if $name eq 'bop';
             return $h-&gt;SUPER::parse_trace_flag($name);
         }

       All private flag names must be lowercase, and all private flags must be in the top 8 of the 32 bits.

       <u>The</u> <u>DBD::Driver::st</u> <u>package</u>

       The execute method

       This is perhaps the most difficult method because we have to consider parameter bindings here. We
       present a simplified implementation by using the <u>drv</u><b>_</b><u>params</u> attribute from above:

         package DBD::Driver::st;

         $DBD::Driver::st::imp_data_size = 0;

         sub bind_param
         {
             my ($sth, $pNum, $val, $attr) = @_;
             my $type = (ref $attr) ? $attr-&gt;{TYPE} : $attr;
             if ($type) {
                 my $dbh = $sth-&gt;{Database};
                 $val = $dbh-&gt;quote($sth, $type);
             }
             my $params = $sth-&gt;{drv_params};
             $params-&gt;[$pNum-1] = $val;
             1;
         }

         sub execute
         {
             my ($sth, @bind_values) = @_;

             # start of by finishing any previous execution if still active
             $sth-&gt;finish if $sth-&gt;FETCH('Active');

             my $params = (@bind_values) ?
                 \@bind_values : $sth-&gt;{drv_params};
             my $numParam = $sth-&gt;FETCH('NUM_OF_PARAMS');
             return $sth-&gt;set_err(1, "Wrong number of parameters")
                 if @$params != $numParam;
             my $statement = $sth-&gt;{'Statement'};
             for (my $i = 0;  $i &lt; $numParam;  $i++) {
                 $statement =~ s/?/$params-&gt;[$i]/; # XXX doesn't deal with quoting etc!
             }
             # Do anything ... we assume that an array ref of rows is
             # created and store it:
             $sth-&gt;{'drv_data'} = $data;
             $sth-&gt;{'drv_rows'} = @$data; # number of rows
             $sth-&gt;STORE('NUM_OF_FIELDS') = $numFields;
             @$data || '0E0';
         }

       There are a number of things you should note here.  We setup the NUM_OF_FIELDS attribute here,
       because this is essential for <u>bind</u><b>_</b><u>columns</u> to work.  We use attribute "$sth-&gt;{Statement}" which we
       created within <u>prepare</u>. The attribute "$sth-&gt;{Database}", which is nothing else than the <u>dbh</u>, was
       automatically created by DBI.

       Finally note that (as specified in the DBI specification) we return the string '0E0' instead of the
       number 0, so that the result tests true but equal to zero.

         $sth-&gt;execute() or die $sth-&gt;errstr;

       Fetching data

       We should not implement the methods <u>fetchrow</u><b>_</b><u>array</u>, <u>fetchall</u><b>_</b><u>arrayref</u>, ... because these are already
       part of DBI.  All we need is the method <u>fetchrow</u><b>_</b><u>arrayref</u>:

         sub fetchrow_arrayref
         {
             my ($sth) = @_;
             my $data = $sth-&gt;{drv_data};
             my $row = shift @$data;
             if (!$row) {
                 $sth-&gt;STORE(Active =&gt; 0); # mark as no longer active
                 return undef;
             }
             if ($sth-&gt;FETCH('ChopBlanks')) {
                 map { $_ =~ s/\s+$//; } @$row;
             }
             return $sth-&gt;_set_fbav($row);
         }
         *fetch = \&amp;fetchrow_arrayref; # required alias for fetchrow_arrayref

       Note the use of the method <b>_</b><u>set</u><b>_</b><u>fbav</u>: This is required so that <u>bind</u><b>_</b><u>col</u> and <u>bind</u><b>_</b><u>columns</u> work.

       If an error occurs which leaves the $sth in a state where remaining rows can't be fetched then Active
       should be turned off before the method returns.

       The rows method for this driver can be implemented like this:

         sub rows { shift-&gt;{drv_rows} }

       because it knows in advance how many rows it has fetched.  Alternatively you could delete that method
       and so fallback to the DBI's own method which does the right thing based on the number of calls to
       <b>_</b><u>set</u><b>_</b><u>fbav()</u>.

       Statement attributes

       The main difference between dbh and sth attributes is, that you should implement a lot of attributes
       here that are required by the DBI, such as <u>NAME</u>, <u>NULLABLE</u>, <u>TYPE</u>, ...

       Besides that the STORE and FETCH methods are mainly the same as above for dbh's.

       Other statement methods

       A trivial "finish" method to discard the stored data and do $sth-&gt;SUPER::finish;

       If you've defined a <u>parse</u><b>_</b><u>trace</u><b>_</b><u>flag()</u> method in ::db you'll also want it in ::st, so just alias it
       in:

         *parse_trace_flag = \&amp;DBD::foo:db::parse_trace_flag;

       And perhaps some other methods that are not part of the DBI specification, in particular to make
       metadata available.  Remember that they must have names that begin with your drivers registered
       prefix so they can be installed using <u>install</u><b>_</b><u>method()</u>.

       If <u>DESTROY()</u> is called on a statement handle that's still active ($sth-&gt;{Active} is true) then it
       should effectively call <u>finish()</u>.

           sub DESTROY {
               my $sth = shift;
               $sth-&gt;finish if $sth-&gt;FETCH('Active');
           }

       <b>Tests</b>

       The test process should conform as closely as possibly to the Perl standard test harness.

       In particular, most (all) of the tests should be run in the t sub-directory, and should simply
       produce an 'ok' when run under 'make test'.  For details on how this is done, see the Camel book and
       the section in Chapter 7, "The Standard Perl Library" on Test::Harness.

       The tests may need to adapt to the type of database which is being used for testing, and to the
       privileges of the user testing the driver.

       The DBD::Informix test code has to adapt in a number of places to the type of database to which it is
       connected as different Informix databases have different capabilities.  For example, some of the
       tests are for databases without transaction logs; others are for databases with a transaction log.
       Some versions of the server have support for blobs, or stored procedures, or user-defined data types,
       and others do not.  When a complete file of tests must be skipped, you can provide a reason in a
       pseudo-comment:

           if ($no_transactions_available)
           {
               print "1..0 # Skip: No transactions available\n";
               exit 0;
           }

       Consider downloading the DBD::Informix code and look at the code in DBD/Informix/TestHarness.pm which
       is used throughout the DBD::Informix tests in the t sub-directory.

<b>CREATING</b> <b>A</b> <b>C/XS</b> <b>DRIVER</b>
       Creating a new C/XS driver from scratch will always be a daunting task.  You can and should greatly
       simplify your task by taking a good reference driver implementation and modifying that to match the
       database product for which you are writing a driver.

       The de facto reference driver has been the one for DBD::Oracle written by Tim Bunce, who is also the
       author of the DBI package. The DBD::Oracle module is a good example of a driver implemented around a
       C-level API.

       Nowadays it it seems better to base on DBD::ODBC, another driver maintained by Tim and Jeff Urlwin,
       because it offers a lot of metadata and seems to become the guideline for the future development.
       (Also as DBD::Oracle digs deeper into the Oracle 8 OCI interface it'll get even more hairy than it is
       now.)

       The DBD::Informix driver is one driver implemented using embedded SQL instead of a function-based
       API.  DBD::Ingres may also be worth a look.

       <b>C/XS</b> <b>version</b> <b>of</b> <b>Driver.pm</b>

       A lot of the code in the Driver.pm file is very similar to the code for pure Perl modules - see
       above.  However, there are also some subtle (and not so subtle) differences, including:

              The variables $DBD::File::{dr|db|st}::imp_data_size are not defined here, but in the XS code,
               because they declare the size of certain C structures.

              Some methods are typically moved to the XS code, in particular <u>prepare</u>, <u>execute</u>, <u>disconnect</u>,
               <u>disconnect</u><b>_</b><u>all</u> and the STORE and FETCH methods.

              Other methods are still part of "Driver.pm", but have callbacks to the XS code.

              If the driver-specific parts of the imp_drh_t structure need to be formally initialized
               (which does not seem to be a common requirement), then you need to add a call to an
               appropriate XS function in the driver method of DBD::Driver::driver, and you define the
               corresponding function in Driver.xs, and you define the C code in dbdimp.c and the prototype
               in dbdimp.h.

               For example, DBD::Informix has such a requirement, and adds the following call after the call
               to _new_drh in Informix.pm:

                 DBD::Informix::dr::driver_init($drh);

               and the following code in Informix.xs:

                 # Initialize the DBD::Informix driver data structure
                 void
                 driver_init(drh)
                     SV *drh
                     CODE:
                     ST(0) = dbd_ix_dr_driver_init(drh) ? &amp;sv_yes : &amp;sv_no;

               and the code in dbdimp.h declares:

                 extern int dbd_ix_dr_driver_init(SV *drh);

               and the code in dbdimp.ec (equivalent to dbdimp.c) defines:

                 /* Formally initialize the DBD::Informix driver structure */
                 int
                 dbd_ix_dr_driver(SV *drh)
                 {
                     D_imp_drh(drh);
                     imp_drh-&gt;n_connections = 0;       /* No active connections */
                     imp_drh-&gt;current_connection = 0;  /* No current connection */
                     imp_drh-&gt;multipleconnections = (ESQLC_VERSION &gt;= 600) ? True : False;
                     dbd_ix_link_newhead(&amp;imp_drh-&gt;head);  /* Empty linked list of connections */
                     return 1;
                 }

               DBD::Oracle has a similar requirement but gets around it by checking whether the private data
               part of the driver handle is all zeroed out, rather than add extra functions.

       Now let's take a closer look at an excerpt from Oracle.pm (revised heavily to remove idiosyncrasies)
       as an example.  We also ignore things that are already discussed for pure Perl drivers.

       <u>The</u> <u>connect</u> <u>method</u>

       The connect method is the database handle constructor.  You could write either of two versions of
       this method: either one which takes connection attributes (new code) and one which ignores them (old
       code only).  If you ignore the connection attributes, then you omit all mention of the $auth variable
       (which is a reference to a hash of attributes), and the XS system manages the differences for you.

         sub connect
         {
             my ($drh, $dbname, $user, $auth, $attr) = @_;

             # Some database specific verifications, default settings
             # and the like following here. This should only include
             # syntax checks or similar stuff where it's legal to
             # 'die' in case of errors.

             my $dbh = DBI::_new_dbh($drh, {
                     'Name'   =&gt; $dbname,
                 })
                 or return undef;

             # Call the driver-specific function _login in Driver.xs file which
             # calls the DBMS-specific <!-- a -->function(s)<!-- /a --> to connect to the database,
             # and populate internal handle data.
             DBD::Driver::db::_login($dbh, $dbname, $user, $auth, $attr)
                 or return undef;

             $dbh;
         }

       This is mostly the same as in the pure Perl case, the exception being the use of the private <b>_</b><u>login</u>
       callback, which is the function that will really connect to the database.  It is implemented in
       Driver.xst (you should not implement it) and calls <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u> from <u>dbdimp.c</u>.  See below for
       details.

        *FIX ME* Discuss removing attributes from hash reference as an optimization
        to skip later calls to $dbh-&gt;STORE made by DBI-&gt;connect.

        *FIX ME* Discuss removing attributes in Perl code.

        *FIX ME* Discuss removing attributes in C code.

       <u>The</u> <u>disconnect</u><b>_</b><u>all</u> <u>method</u>

        *FIX ME* T.B.S

       <u>The</u> <u>data</u><b>_</b><u>sources</u> <u>method</u>

       If your <u>data</u><b>_</b><u>sources</u> method can be implemented in pure Perl, then do so because it is easier than
       doing it in XS code (see the section above for pure Perl drivers).  If your <u>data</u><b>_</b><u>sources</u> method must
       call onto compiled functions, then you will need to define dbd_dr_data_sources in your dbdimp.h file,
       which will trigger Driver.xst (in DBI v1.33 or greater) to generate the XS code that calls your
       actual C function (see the discussion below for details) and you do not code anything in Driver.pm to
       handle it.

       <u>The</u> <u>prepare</u> <u>method</u>

       The prepare method is the statement handle constructor, and most of it is not new.  Like the <u>connect</u>
       method, it now has a C callback:

         package DBD::Driver::db; # ====== DATABASE ======
         use strict;

         sub prepare
         {
             my ($dbh, $statement, $attribs) = @_;

             # create a 'blank' sth
             my $sth = DBI::_new_sth($dbh, {
                 'Statement' =&gt; $statement,
                 })
                 or return undef;

             # Call the driver-specific function _prepare in Driver.xs file
             # which calls the DBMS-specific <!-- a -->function(s)<!-- /a --> to prepare a statement
             # and populate internal handle data.
             DBD::Driver::st::_prepare($sth, $statement, $attribs)
                 or return undef;
             $sth;
         }

       <u>The</u> <u>execute</u> <u>method</u>

        *FIX ME* T.B.S

       <u>The</u> <u>fetchrow</u><b>_</b><u>arrayref</u> <u>method</u>

        *FIX ME* T.B.S

       <u>Other</u> <u>methods?</u>

        *FIX ME* T.B.S

       <b>Driver.xs</b>

       Driver.xs should look something like this:

         #include "Driver.h"

         DBISTATE_DECLARE;

         INCLUDE: Driver.xsi

         MODULE = DBD::Driver    PACKAGE = DBD::Driver::dr

         /* Non-standard drh XS methods following here, if any.       */
         /* If none (the usual case), omit the MODULE line above too. */

         MODULE = DBD::Driver    PACKAGE = DBD::Driver::db

         /* Non-standard dbh XS methods following here, if any.       */
         /* Currently this includes things like _list_tables from     */
         /* DBD::mSQL and DBD::mysql.                                 */

         MODULE = DBD::Driver    PACKAGE = DBD::Driver::st

         /* Non-standard sth XS methods following here, if any.       */
         /* In particular this includes things like _list_fields from */
         /* DBD::mSQL and DBD::mysql for accessing metadata.          */

       Note especially the include of <u>Driver.xsi</u> here: DBI inserts stub functions for almost all private
       methods here which will typically do much work for you.  Wherever you really have to implement
       something, it will call a private function in <u>dbdimp.c</u>, and this is what you have to implement.

       You need to set up an extra routine if your driver needs to export constants of its own, analogous to
       the SQL types available when you say:

         use DBI qw(:sql_types);

        *FIX ME* T.B.S

       <b>Driver.h</b>

       Driver.h is very simple and the operational contents should look like this:

         #ifndef DRIVER_H_INCLUDED
         #define DRIVER_H_INCLUDED

         #define NEED_DBIXS_VERSION 93    /* 93 for DBI versions 1.00 to 1.51+ */
         #define PERL_NO_GET_CONTEXT      /* if used require DBI 1.51+ */

         #include &lt;DBIXS.h&gt;      /* installed by the DBI module  */

         #include "dbdimp.h"

         #include "dbivport.h"   /* see below                    */

         #include &lt;dbd_xsh.h&gt;    /* installed by the DBI module  */

         #endif /* DRIVER_H_INCLUDED */

       The "DBIXS.h" header defines most of the interesting information that the writer of a driver needs.
       The file "dbd_xsh.h" header provides prototype declarations for the C functions that you might decide
       to implement.  Note that you should normally only define one of <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login</u> and <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u> unless
       you are intent on supporting really old versions of DBI (prior to DBI 1.06) as well as modern
       versions.  The only standard, DBI-mandated functions that you need write are those specified in the
       dbd_xsh.h header.  You might also add extra driver-specific functions in Driver.xs.

       The dbivport.h file should be <u>copied</u> from the latest DBI release into your distribution each time you
       enhance your driver to use new features for which the DBI is offering backwards compatibility via
       dbivport.h.

       Its job is to allow you to enhance your code to work with the latest DBI API while still allowing
       your driver to be compiled and used with older versions of the DBI. For example, when the
       DBIh_SET_ERR_CHAR macro was added to DBI 1.41 in an emulation of it was added to dbivport.h.

       Copying dbivport.h into your driver distribution and #including it in Driver.h, as shown above, lets
       you enhance your driver to use the new DBIh_SET_ERR_CHAR macro even with versions of the DBI earlier
       than 1.41. This makes users happy and your life easier.

       Always read the notes in dbivport.h to check for any limitations in the emulation that you should be
       aware of.

       With DBI v1.51 or better I recommend that the driver defines PERL_NO_GET_CONTEXT before <u>DBIXS.h</u> is
       included. This can significantly improve efficiency when running under a thread enabled perl.
       (Remember that the standard perl in most Linux distributions is built with threads enabled.  So is
       ActiveState perl for Windows, and perl built for Apache mod_perl2.)  If you do this there are some
       things to keep in mind:

       <b>*</b> If PERL_NO_GET_CONTEXT is defined, then every function that calls the Perl API will need to start
       out with a "dTHX;" declaration.

       <b>*</b> You'll know which functions need this, because the C compiler will complain that the undeclared
       identifier "my_perl" is used if <u>and</u> <u>only</u> <u>if</u> the perl you are using to develop and test your driver
       has threads enabled.

       <b>*</b> So if you don't remember to test with a thread-enabled perl before making a release it's likely
       that you'll get failure reports from users who are.

       <b>*</b> For driver private functions it is possible to gain even more efficiency by replacing "dTHX;" with
       "pTHX_" prepended to the parameter list and then "aTHX_" prepended to the argument list where the
       function is called.

       See "How multiple interpreters and concurrency are supported" in perlguts for additional information
       about PERL_NO_GET_CONTEXT.

       <b>Implementation</b> <b>header</b> <b>dbdimp.h</b>

       This header file has two jobs:

       First it defines data structures for your private part of the handles.

       Second it defines macros that rename the generic names like <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login</u> to database specific names
       like <u>ora</u><b>_</b><u>db</u><b>_</b><u>login</u>. This avoids name clashes and enables use of different drivers when you work with a
       statically linked perl.

       It also will have the important task of disabling XS methods that you don't want to implement.

       Finally, the macros will also be used to select alternate implementations of some functions.  For
       example, the <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login</u> function is not passed the attribute hash.  Since DBI v1.06, if a
       <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u> macro is defined (for a function with 6 arguments), it will be used instead with the
       attribute hash passed as the sixth argument.

       People used to just pick Oracle's dbdimp.c and use the same names, structures and types.  I strongly
       recommend against that.  At first glance this saves time, but your implementation will be less
       readable.  It was just hell when I had to separate DBI specific parts, Oracle specific parts, mSQL
       specific parts and mysql specific parts in DBD::mysql's <u>dbdimp.h</u> and <u>dbdimp.c</u>.  (DBD::mysql was a
       port of DBD::mSQL which was based on DBD::Oracle.)  [Seconded, based on the experience taking
       DBD::Informix apart, even though the version inherited in 1996 was only based on DBD::Oracle.]

       This part of the driver is <u>your</u> <u>exclusive</u> <u>part</u>.  Rewrite it from scratch, so it will be clean and
       short: in other words, a better piece of code.  (Of course keep an eye on other people's work.)

         struct imp_drh_st {
             dbih_drc_t com;           /* MUST be first element in structure   */
             /* Insert your driver handle attributes here */
         };

         struct imp_dbh_st {
             dbih_dbc_t com;           /* MUST be first element in structure   */
             /* Insert your database handle attributes here */
         };

         struct imp_sth_st {
             dbih_stc_t com;           /* MUST be first element in structure   */
             /* Insert your statement handle attributes here */
         };

         /*  Rename functions for avoiding name clashes; prototypes are  */
         /*  in dbd_xst.h                                                */
         #define dbd_init         drv_dr_init
         #define dbd_db_login6    drv_db_login
         #define dbd_db_do        drv_db_do
         ... many more here ...

       These structures implement your private part of the handles.  You <u>have</u> to use the name
       <u>imp</u><b>_</b><u>dbh</u><b>_</b><u>{dr|db|st}</u> and the first field <u>must</u> be of type <u>dbih</u><b>_</b><u>drc</u><b>_</b><u>t|</u><b>_</b><u>dbc</u><b>_</b><u>t|</u><b>_</b><u>stc</u><b>_</b><u>t</u> and <u>must</u> be called
       "com".  You should never access these fields directly, except by using the <u>DBIc</u><b>_</b><u>xxx</u> macros below.

       <b>Implementation</b> <b>source</b> <b>dbdimp.c</b>

       Conventionally, <u>dbdimp.c</u> is the main implementation file (but DBD::Informix calls the file
       dbdimp.ec).  This section includes a short note on each function that is used in the Driver.xsi
       template and thus <b>has</b> to be implemented.

       Of course, you will probably also need to implement other support functions, which should usually be
       file static if the are placed in <u>dbdimp.c</u>.  If they are placed in other files, you need to list those
       files in Makefile.PL (and MANIFEST) to handle them correctly.

       It is wise to adhere to a namespace convention for your functions to avoid conflicts.  For example,
       for a driver with prefix "drv", you might call externally visible functions "dbd_drv_xxxx".  You
       should also avoid non-constant global variables as much as possible to improve the support for
       threading.

       Since Perl requires support for function prototypes (ANSI or ISO or Standard C), you should write
       your code using function prototypes too.

       It is possible to use either the unmapped names such as "dbd_init" or the mapped names such as
       "dbd_ix_dr_init" in the "dbdimp.c" file.  DBD::Informix uses the mapped names which makes it easier
       to identify where to look for linkage problems at runtime (which will report errors using the mapped
       names).  Most other drivers, and in particular DBD::Oracle, use the unmapped names in the source code
       which makes it a little easier to compare code between drivers and eases discussions on the dbi-dev
       mailing list.  The majority of the code fragments here will use the unmapped names.

       Ultimately, you should provide implementations for most fo the functions listed in the <u>dbd</u><b>_</b><u>xsh.h</u>
       header.  The exceptions are optional functions (such as <u>dbd</u><b>_</b><u>st</u><b>_</b><u>rows</u>) and those functions with
       alternative signatures, such as <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u> and <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login</u>.  Then you should only implement one
       of the alternatives, and generally the newer one of the alternatives.

       <u>The</u> <u>dbd</u><b>_</b><u>init</u> <u>method</u>

         #include "Driver.h"

         DBISTATE_DECLARE;

         void dbd_init(dbistate_t* dbistate)
         {
             DBISTATE_INIT;  /*  Initialize the DBI macros  */
         }

       The "dbd_init" function will be called when your driver is first loaded; the bootstrap command in
       DBD::Driver::dr::driver triggers this, and the call is generated in the BOOT section of Driver.xst.
       These statements are needed to allow your driver to use the DBI macros.  They will include your
       private header file <u>dbdimp.h</u> in turn.  Note that DBISTATE_INIT requires the name of the argument to
       <u>dbd</u><b>_</b><u>init</u> to be called <u>dbistate</u>.

       <u>The</u> <u>dbd</u><b>_</b><u>drv</u><b>_</b><u>error</u> <u>method</u>

       You need a function to record errors so DBI can access them properly.  You can call it whatever you
       like, but we'll call it "dbd_drv_error" here.  The argument list depends on your database software;
       different systems provide different ways to get at error information.

         static void dbd_drv_error(SV *h, int rc, const char *what)
         {

       Note that <u>h</u> is a generic handle, may it be a driver handle, a database or a statement handle.

             <!-- a -->D_imp_xxh(h)<!-- /a -->;

       This macro will declare and initialize a variable <u>imp</u><b>_</b><u>xxh</u> with a pointer to your private handle
       pointer. You may cast this to to <u>imp</u><b>_</b><u>drh</u><b>_</b><u>t</u>, <u>imp</u><b>_</b><u>dbh</u><b>_</b><u>t</u> or <u>imp</u><b>_</b><u>sth</u><b>_</b><u>t</u>.

       To record the error correctly, equivalent to the <u>set</u><b>_</b><u>err()</u> method, use one of the
       DBIh_SET_ERR_CHAR(...) or DBIh_SET_ERR_SV(...) macros, which were added in DBI 1.41:

         DBIh_SET_ERR_SV(h, imp_xxh, err, errstr, state, method);
         DBIh_SET_ERR_CHAR(h, imp_xxh, err_c, err_i, errstr, state, method);

       For DBIh_SET_ERR_SV the err, errstr, state, and method parameters are SV*.  For DBIh_SET_ERR_CHAR the
       err_c, errstr, state, method are char*.  The err_i parameter is an IV that's used instead of err_c is
       err_c is Null.  The method parameter can be ignored.

       The DBIh_SET_ERR_CHAR macro is usually the simplest to use when you just have an integer error code
       and an error message string:

         DBIh_SET_ERR_CHAR(h, imp_xxh, Nullch, rc, what, Nullch, Nullch);

       As you can see, any parameters that aren't relevant to you can be Null.

       To make drivers compatible with DBI &lt; 1.41 you should be using dbivport.h as described in "Driver.h"
       above.

       The (obsolete) macros such as DBIh_EVENT2 should be removed from drivers.

       The names <u>dbis</u> and <u>DBIS</u>, which were used in previous versions of this document, should be replaced
       with the "DBIc_STATE(imp_xxh)" macro.

       The name DBILOGFP, which was also used in previous  versions of this document, should be replaced by
       DBIc_LOGPIO(imp_xxh).

       Your code should not call the C "&lt;stdio.h&gt;" I/O functions; you should use "PerlIO_printf"() as shown:

             if (DBIc_TRACE_LEVEL(imp_xxh) &gt;= 2)
                 PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar %s: %s\n",
                     foo, neatsvpv(errstr,0));

       That's the first time we see how tracing works within a DBI driver.  Make use of this as often as you
       can! But don't output anything at a trace level less than 3. Levels 1 and 2 are reserved for the DBI.

       You can define up to 8 private trace flags using the top 8 bits of DBIc_TRACE_FLAGS(imp), that is:
       0xFF000000. See the <u>parse</u><b>_</b><u>trace</u><b>_</b><u>flag()</u> method elsewhere in this document.

       <u>The</u> <u>dbd</u><b>_</b><u>dr</u><b>_</b><u>data</u><b>_</b><u>sources</u> <u>method</u>

       This method is optional; the support for it was added in DBI v1.33.

       As noted in the discussion of Driver.pm, if the data sources can be determined by pure Perl code, do
       it that way.  If, as in DBD::Informix, the information is obtained by a C function call, then you
       need to define a function that matches the prototype:

         extern AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attrs);

       An outline implementation for DBD::Informix follows, assuming that the <u>sqgetdbs()</u> function call shown
       will return up to 100 databases names, with the pointers to each name in the array dbsname and the
       name strings themselves being stores in dbsarea.  The actual DBD::Informix implementation has a
       number of extra lines of code, logs function entry and exit, reports the error from <u>sqgetdbs()</u>, and
       uses #define'd constatnts for the array sizes.

         AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attr)
         {
             int ndbs;
             int i;
             char *dbsname[100];
             char  dbsarea[10000];
             AV *av = Nullav;

             if (sqgetdbs(&amp;ndbs, dbsname, 100, dbsarea, sizeof(dbsarea)) == 0)
             {
                 av = NewAV();
                 av_extend(av, (I32)ndbs);
                 sv_2mortal((SV *)av);
                 for (i = 0; i &lt; ndbs; i++)
                   av_store(av, i, newSVpvf("dbi:Informix:%s", dbsname[i]));
             }
             return(av);
         }

       <u>The</u> <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u> <u>method</u>

         int dbd_db_login6(SV* dbh, imp_dbh_t* imp_dbh, char* dbname,
                          char* user, char* auth, SV *attr);

       This function will really connect to the database.  The argument <u>dbh</u> is the database handle.  <u>imp</u><b>_</b><u>dbh</u>
       is the pointer to the handles private data, as is <u>imp</u><b>_</b><u>xxx</u> in <u>dbd</u><b>_</b><u>drv</u><b>_</b><u>error</u> above.  The arguments
       <u>dbname</u>, <u>user</u>, <u>auth</u> and <u>attr</u> correspond to the arguments of the driver handle's <u>connect</u> method.

       You will quite often use database specific attributes here, that are specified in the DSN.  I
       recommend you parse the DSN (using Perl) within the <u>connect</u> method and pass the segments of the DSN
       via the attributes parameter through <b>_</b><u>login</u> to <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u>.  Here's how you fetch them; as an
       example we use <u>hostname</u> attribute, which can be up to 12 characters long excluding null terminator:

         SV** svp;
         STRLEN len;
         char* hostname;

         if ( (svp = DBD_ATTRIB_GET_SVP(attr, "drv_hostname", 12)) &amp;&amp; SvTRUE(*svp)) {
             hostname = SvPV(*svp, len);
             DBD__ATTRIB_DELETE(attr, "drv_hostname", 12); /* avoid later STORE */
         } else {
             hostname = "localhost";
         }

       Note that you can also obtain standard attributes such as AutoCommit and ChopBlanks from the
       attributes parameter, using DBD_ATTRIB_GET_IV for integer attributes.  If, for example, your database
       does not support transactions but AutoCommit is set off (requesting transaction support), then you
       can emulate a 'failure to connect'.

       Now you should really connect to the database.  In general, if the connection fails, it is best to
       ensure that all allocated resources are released so that the handle does not need to be destroyed
       separately.  If you are successful (and possibly even if you fail but you have allocated some
       resources), you should use the following macros:

         DBIc_IMPSET_on(imp_dbh);

       This indicates that the driver (implementor) has allocated resources in the imp_dbh structure and
       that the implementors private dbd_db_destroy function should be called when the handle is destroyed.

         DBIc_ACTIVE_on(imp_dbh);

       This indicates that the handle has an active connection to the server and that the dbd_db_disconnect
       function should be called before the handle is destroyed.

       Note that if you do need to fail, you should report errors via the drh or imp_drh rather than via dbh
       or imp_dbh because imp_dbh will be destroyed by the failure, so errors recorded in that handle will
       not be visible to DBI, and hence not the user either.  Note to that the function is passed dbh and
       imp_dbh, and there is a macro D_imp_drh_from_dbh which can recover the imp_drh from the imp_dbh, but
       there is no DBI macro to provide you with the drh given either the imp_dbh or the dbh or the imp_drh
       (and there's no way to recover the dbh given just the imp_dbh).  This suggests that despite the notes
       about dbd_drv_error above taking an SV *, it may be better to have two error routines, one taking
       imp_dbh and one taking imp_drh instead.  With care, you can factor most of the formatting code out so
       that these are small routines calling onto a common error formatter.  See the code in DBD::Informix
       1.05.00 for more information.

       The <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u> function should return TRUE for success, FALSE otherwise.

       Drivers implemented long ago may define the five-argument function <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login</u> instead of
       <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u>.  The missing argument is the attributes.  There are ways to work around the missing
       attributes, but they are ungainly; it is much better to use the 6-argument form.

       <u>The</u> <u>dbd</u><b>_</b><u>db</u><b>_</b><u>commit</u> <u>and</u> <u>dbd</u><b>_</b><u>db</u><b>_</b><u>rollback</u> <u>methods</u>

         int dbd_db_commit(SV *dbh, imp_dbh_t *imp_dbh);
         int dbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh);

       These are used for commit and rollback. They should return TRUE for success, FALSE for error.

       The arguments <u>dbh</u> and <u>imp</u><b>_</b><u>dbh</u> are the same as for <u>dbd</u><b>_</b><u>db</u><b>_</b><u>login6</u> above; I will omit describing them in
       what follows, as they appear always.

       These functions should return TRUE for success, FALSE otherwise.

       <u>The</u> <u>dbd</u><b>_</b><u>db</u><b>_</b><u>disconnect</u> <u>method</u>

       This is your private part of the <u>disconnect</u> method. Any dbh with the <u>ACTIVE</u> flag on must be
       disconnected. (Note that you have to set it in <u>dbd</u><b>_</b><u>db</u><b>_</b><u>connect</u> above.)

         int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh);

       The database handle will return TRUE for success, FALSE otherwise.  In any case it should do a:

         DBIc_ACTIVE_off(imp_dbh);

       before returning so DBI knows that <u>dbd</u><b>_</b><u>db</u><b>_</b><u>disconnect</u> was executed.

       Note that there's nothing to stop a dbh being <u>disconnected</u> while it still have active children.  If
       your database API reacts badly to trying to use an sth in this situation then you'll need to add code
       like this to all sth methods:

         if (!DBIc_ACTIVE(DBIc_PARENT_COM(imp_sth)))
           return 0;

       Alternatively, you can add code to your driver to keep explicit track of the statement handles that
       exist for each database handle and arrange to destroy those handles before disconnecting from the
       database.  There is code to do this in DBD::Informix.  Similar comments apply to the driver handle
       keeping track of all the database handles.  Note that the code which destroys the subordinate handles
       should only release the associated database resources and mark the handles inactive; it does not
       attempt to free the actual handle structures.

       This function should return TRUE for success, FALSE otherwise, but it is not clear what anything can
       do about a failure.

       <u>The</u> <u>dbd</u><b>_</b><u>db</u><b>_</b><u>discon</u><b>_</b><u>all</u> <u>method</u>

         int dbd_discon_all (SV *drh, imp_drh_t *imp_drh);

       This function may be called at shutdown time. It should make best-efforts to disconnect all database
       handles - if possible. Some databases don't support that, in which case you can do nothing but return
       'success'.

       This function should return TRUE for success, FALSE otherwise, but it is not clear what anything can
       do about a failure.

       <u>The</u> <u>dbd</u><b>_</b><u>db</u><b>_</b><u>destroy</u> <u>method</u>

       This is your private part of the database handle destructor. Any dbh with the <u>IMPSET</u> flag on must be
       destroyed, so that you can safely free resources. (Note that you have to set it in <u>dbd</u><b>_</b><u>db</u><b>_</b><u>connect</u>
       above.)

         void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh)
         {
             DBIc_IMPSET_off(imp_dbh);
         }

       The DBI Driver.xst code will have called dbd_db_disconnect for you, if the handle is still 'active',
       before calling dbd_db_destroy.

       Before returning the function must switch IMPSET to off, so DBI knows that the destructor was called.

       A DBI handle doesn't keep references to its children. But children do keep references to their
       parents. So a database handle won't be DESTROY'd until all its children have been DESTROY'd.

       <u>The</u> <u>dbd</u><b>_</b><u>db</u><b>_</b><u>STORE</u><b>_</b><u>attrib</u> <u>method</u>

       This function handles

         $dbh-&gt;{$key} = $value;

       Its prototype is:

         int dbd_db_STORE_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv,
                                 SV* valuesv);

       You do not handle all attributes; on the contrary, you should not handle DBI attributes here: leave
       this to DBI.  (There are two exceptions, <u>AutoCommit</u> and <u>ChopBlanks</u>, which you should care about.)

       The return value is TRUE if you have handled the attribute or FALSE otherwise. If you are handling an
       attribute and something fails, you should call <u>dbd</u><b>_</b><u>drv</u><b>_</b><u>error</u>, so DBI can raise exceptions, if
       desired.  If <u>dbd</u><b>_</b><u>drv</u><b>_</b><u>error</u> returns, however, you have a problem: the user will never know about the
       error, because he typically will not check "$dbh-&gt;errstr".

       I cannot recommend a general way of going on, if <u>dbd</u><b>_</b><u>drv</u><b>_</b><u>error</u> returns, but there are examples where
       even the DBI specification expects that you <u>croak()</u>. (See the <u>AutoCommit</u> method in DBI.)

       If you have to store attributes, you should either use your private data structure imp_xxx, the
       handle hash (via (HV*)SvRV(dbh)), or use the private imp_data.

       The first is best for internal C values like integers or pointers and where speed is important within
       the driver. The handle hash is best for values the user may want to get/set via driver-specific
       attributes.  The private imp_data is an additional SV attached to the handle. You could think of it
       as an unnamed handle attribute. It's not normally used.

       <u>The</u> <u>dbd</u><b>_</b><u>db</u><b>_</b><u>FETCH</u><b>_</b><u>attrib</u> <u>method</u>

       This is the counterpart of dbd_db_STORE_attrib, needed for:

         $value = $dbh-&gt;{$key};

       Its prototype is:

         SV* dbd_db_FETCH_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv);

       Unlike all previous methods this returns an SV with the value. Note that you should normally execute
       sv_2mortal, if you return a nonconstant value. (Constant values are &amp;sv_undef, &amp;sv_no and &amp;sv_yes.)

       Note, that DBI implements a caching algorithm for attribute values.  If you think, that an attribute
       may be fetched, you store it in the dbh itself:

         if (cacheit) /* cache value for later DBI 'quick' fetch? */
             hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);

       <u>The</u> <u>dbd</u><b>_</b><u>st</u><b>_</b><u>prepare</u> <u>method</u>

       This is the private part of the <u>prepare</u> method. Note that you <b>must</b> <b>not</b> really execute the statement
       here. You may, for example, preparse and validate the statement or do similar things.

         int dbd_st_prepare(SV* sth, imp_sth_t* imp_sth, char* statement,
                            SV* attribs);

       A typical, simple, possibility is to do nothing and rely on the perl <u>perpare()</u> code that set the
       Statement attribute on the handle. This attribute can then be used by dbd_st_execute.

       If the driver supports placeholders then the NUM_OF_PARAMS attribute must be set correctly by
       dbd_st_prepare:

         DBIc_NUM_PARAMS(imp_sth) = ...

       If you can, you should also setup attributes like NUM_OF_FIELDS, NAME, ... here, but DBI doesn't
       require that. However, if you do, document it.

       In any case you should set the IMPSET flag, as you did in <u>dbd</u><b>_</b><u>db</u><b>_</b><u>connect</u> above:

         DBIc_IMPSET_on(imp_sth);

       <u>The</u> <u>dbd</u><b>_</b><u>st</u><b>_</b><u>execute</u> <u>method</u>

       This is where a statement will really be executed.

         int dbd_st_execute(SV* sth, imp_sth_t* imp_sth);

       Note, that you must be aware, that a statement may be executed repeatedly.  Also, you should not
       expect, that <u>finish</u> will be called between two executions, so you'll might need code like the
       following near the start of the function:

         if (DBIc_ACTIVE(imp_sth))
             dbd_st_finish(h, imp_sth);

       If your driver supports the binding of parameters (it should!), but the database doesn't, you must do
       it here. This can be done as follows:

         SV *svp;
         char* statement = DBD_ATTRIB_GET_PV(h, "Statement", 9, svp, "");
         int numParam = DBIc_NUM_PARAMS(imp_sth);
         int i;

         for (i = 0; i &lt; numParam; i++)
         {
             char* value = dbd_db_get_param(sth, imp_sth, i);
             /* It is your drivers task to implement dbd_db_get_param,    */
             /* it must be setup as a counterpart of dbd_bind_ph.         */
             /* Look for '?' and replace it with 'value'.  Difficult      */
             /* task, note that you may have question marks inside        */
             /* quotes and comments the like ...  :-(                     */
             /* See DBD::mysql for an example. (Don't look too deep into  */
             /* the example, you will notice where I was lazy ...)        */
         }

       The next thing is you really execute the statement.  Note that you must set the attributes
       NUM_OF_FIELDS, NAME, etc when the statement is successfully executed if the driver has not already
       done so.  They may be used even before a potential <u>fetchrow</u>.  In particular you have to tell DBI the
       number of fields, that the statement has, because it will be used by DBI internally.  Thus the
       function will typically ends with:

         if (isSelectStatement) {
             DBIc_NUM_FIELDS(imp_sth) = numFields;
             DBIc_ACTIVE_on(imp_sth);
         }

       It is important that the ACTIVE flag only be set for "SELECT" statements (or any other statements
       that can return multiple sets of values from the database using a cursor-like mechanism).  See
       <u>dbd</u><b>_</b><u>db</u><b>_</b><u>connect</u> above for more explanations.

       There plans for a preparse function to be provided by DBI, but this has not reached fruition yet.
       Meantime, if you want to know how ugly it can get, try looking at the <u>dbd</u><b>_</b><u>ix</u><b>_</b><u>preparse</u> in
       DBD::Informix <u>dbdimp.ec</u> and the related functions in <u>iustoken.c</u> and <u>sqltoken.c</u>.

       <u>The</u> <u>dbd</u><b>_</b><u>st</u><b>_</b><u>fetch</u> <u>method</u>

       This function fetches a row of data. The row is stored in in an array, of SV's that DBI prepares for
       you. This has two advantages: it is fast (you even reuse the SV's, so they don't have to be created
       after the first fetchrow), and it guarantees that DBI handles <u>bind</u><b>_</b><u>cols</u> for you.

       What you do is the following:

         AV* av;
         int numFields = DBIc_NUM_FIELDS(imp_sth); /* Correct, if NUM_FIELDS
             is constant for this statement. There are drivers where this is
             not the case! */
         int chopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);
         int i;

         if (!fetch_new_row_of_data(...)) {
             ... /* check for error or end-of-data */
             DBIc_ACTIVE_off(imp_sth); /* turn off Active flag automatically */
             return Nullav;
         }
         /* get the fbav (field buffer array value) for this row       */
         /* it is very important to only call this after you know      */
         /* that you have a row of data to return.                     */
         av = DBIc_DBISTATE(imp_sth)-&gt;get_fbav(imp_sth);
         for (i = 0; i &lt; numFields; i++) {
             SV* sv = fetch_a_field(..., i);
             if (chopBlanks &amp;&amp; SvOK(sv) &amp;&amp; type_is_blank_padded(field_type[i])) {
                 /*  Remove white space from end (only) of sv  */
             }
             sv_setsv(AvARRAY(av)[i], sv); /* Note: (re)use! */
         }
         return av;

       There's no need to use a fetch_a_field function returning an SV*.  It's more common to use your
       database API functions to fetch the data as character strings and use code like this:

         sv_setpvn(AvARRAY(av)[i], char_ptr, char_count);

       NULL values must be returned as undef. You can use code like this:

         SvOK_off(AvARRAY(av)[i]);

       The function returns the AV prepared by DBI for success or "Nullav" otherwise.

        *FIX ME* Discuss what happens when there's no more data to fetch.
        Are errors permitted if another fetch occurs after the first fetch
        that reports no more data. (Permitted, not required.)

       If an error occurs which leaves the $sth in a state where remaining rows can't be fetched then Active
       should be turned off before the method returns.

       <u>The</u> <u>dbd</u><b>_</b><u>st</u><b>_</b><u>finish3</u> <u>method</u>

       The "$sth-&gt;finish" method can be called if the user wishes to indicate that no more rows will be
       fetched even if the database has more rows to offer, and the DBI code can call the function when
       handles are being destroyed.  See the DBI specification for more background details.  In both
       circumstances, the DBI code ends up calling the "dbd_st_finish3" method (if you provide a mapping for
       <u>dbd</u><b>_</b><u>st</u><b>_</b><u>finish3</u> in <u>dbdimp.h</u>), or <u>dbd</u><b>_</b><u>st</u><b>_</b><u>finish</u> otherwise.  The difference is that dbd_st_finish3 takes
       a third argument which is an "int" with the value 1 if it is being called from a destroy method and 0
       otherwise.

       Note that DBI v1.32 and earlier test on dbd_db_finish3 to call dbd_st_finish3; if you provide
       dbd_st_finish3, either define dbd_db_finish3 too, or insist on DBI v1.33 or later.

       All it <u>needs</u> to do is turn off the Active flag for the sth.  It will only be called by Driver.xst
       code, if the driver has set ACTIVE to on for the sth.

       Outline example:

         int dbd_st_finish3(SV* sth, imp_sth_t* imp_sth, int from_destroy) {
             if (DBIc_ACTIVE(imp_sth))
             {
                 /* close cursor or equivalent action */
                 DBIc_ACTIVE_off(imp_sth);
             }
             return 1;
         }

       The from_destroy parameter is true if dbd_st_finish3 is being called from DESTROY - and so the
       statement is about to be destroyed.  For many drivers there's no point in doing anything more than
       turing of the Active flag in this case.

       The function returns TRUE for success, FALSE otherwise, but there isn't a lot anyone can do to
       recover if there is an error.

       <u>The</u> <u>dbd</u><b>_</b><u>st</u><b>_</b><u>destroy</u> <u>method</u>

       This function is the private part of the statement handle destructor.

         void dbd_st_destroy(SV* sth, imp_sth_t* imp_sth) {
             ... /* any clean-up that's needed */
             DBIc_IMPSET_off(imp_sth); /* let DBI know we've done it   */
         }

       The DBI Driver.xst code will call dbd_st_finish for you, if the sth has the ACTIVE flag set, before
       calling dbd_st_destroy.

       <u>The</u> <u>dbd</u><b>_</b><u>st</u><b>_</b><u>STORE</u><b>_</b><u>attrib</u> <u>and</u> <u>dbd</u><b>_</b><u>st</u><b>_</b><u>FETCH</u><b>_</b><u>attrib</u> <u>methods</u>

       These functions correspond to dbd_db_STORE and dbd_db_FETCH attrib above, except that they are for
       statement handles.  See above.

         int dbd_st_STORE_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv,
                                 SV* valuesv);
         SV* dbd_st_FETCH_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv);

       <u>The</u> <u>dbd</u><b>_</b><u>bind</u><b>_</b><u>ph</u> <u>method</u>

       This function is internally used by the <u>bind</u><b>_</b><u>param</u> method, the <u>bind</u><b>_</b><u>param</u><b>_</b><u>inout</u> method and by the DBI
       Driver.xst code if "execute" is called with any bind parameters.

         int dbd_bind_ph (SV *sth, imp_sth_t *imp_sth, SV *param,
                          SV *value, IV sql_type, SV *attribs,
                          int is_inout, IV maxlen);

       The <u>param</u> argument holds an IV with the parameter number (1, 2, ...).  The <u>value</u> argument is the
       parameter value and <u>sql</u><b>_</b><u>type</u> is its type.

       If your driver does not support bind_param_inout then you should ignore <u>maxlen</u> and croak if <u>is</u><b>_</b><u>inout</u>
       is TRUE.

       If your driver <u>does</u> support bind_param_inout then you should note that <u>value</u> is the SV <u>after</u>
       dereferencing the reference passed to bind_param_inout.

       In drivers of simple databases the function will, for example, store the value in a parameter array
       and use it later in <u>dbd</u><b>_</b><u>st</u><b>_</b><u>execute</u>.  See the <u>DBD::mysql</u> driver for an example.

       <u>Implementing</u> <u>bind</u><b>_</b><u>param</u><b>_</b><u>inout</u> <u>support</u>

       To provide support for parameters bound by reference rather than by value, the driver must do a
       number of things.  First, and most importantly, it must note the references and stash them in its own
       driver structure.  Secondly, when a value is bound to a column, the driver must discard any previous
       reference bound to the column.  On each execute, the driver must evaluate the references and
       internally bind the values resulting from the references.  This is only applicable if the user
       writes:

         $sth-&gt;execute;

       If the user writes:

         $sth-&gt;execute(@values);

       then DBI automatically calls the binding code for each element of @values.  These calls are
       indistinguishable from explicit user calls to bind_param.

       <b>C/XS</b> <b>version</b> <b>of</b> <b>Makefile.PL</b>

       The <u>Makefile.PL</u> file for a C/XS driver is similar to the code needed for a pure Perl driver, but
       there are a number of extra bits of information needed by the build system.  For example, the
       attributes list passed to "WriteMakefile" needs to specify the object files that need to be compiled
       and built into the shared object (DLL).  This is often, but not necessarily, just dbdimp.o (unless
       that should be dbdimp.obj because you're building on MS Windows).  Note that you can reliably
       determine the extension of the object files from the $Config{obj_ext} values, and there are many
       other useful pieces of configuration information lurking in that hash.  You get access to it with:

           use Config;

       <b>Methods</b> <b>which</b> <b>do</b> <b>not</b> <b>need</b> <b>to</b> <b>be</b> <b>written</b>

       The DBI code implements the majority of the methods which are accessed using the notation
       DBI-&gt;<u>function()</u>, the only exceptions being DBI-&gt;<u>connect()</u> and DBI-&gt;<u>data</u><b>_</b><u>sources()</u> which require
       support from the driver.

       The DBI code implements the following documented driver, database and statement functions which do
       not need to be written by the DBD driver writer.

       $dbh-&gt;<u>do()</u>
           The default implementation of this function prepares, executes and destroys the statement.  This
           can be replaced if there is a better way to implement this, such as EXECUTE IMMEDIATE which can
           sometimes be used if there are no parameters.

       $h-&gt;<u>errstr()</u>
       $h-&gt;<u>err()</u>
       $h-&gt;<u>state()</u>
       $h-&gt;<u>trace()</u>
           The DBD driver does not need to worry about these routines at all.

       $h-&gt;{ChopBlanks}
           This attribute needs to be honured during fetch operations, but does not need to be handled by
           the attribute handling code.

       $h-&gt;{RaiseError}
           The DBD driver does not need to worry about this attribute at all.

       $h-&gt;{PrintError}
           The DBD driver does not need to worry about this attribute at all.

       $sth-&gt;<u>bind</u><b>_</b><u>col()</u>
           Assuming the driver uses the DBIc_DBISTATE(imp_xxh)-&gt;<u>get</u><b>_</b><u>fbav()</u> function (C drivers, see below),
           or the $sth-&gt;_set_fbav($data) method (Perl drivers) the driver does not need to do anything about
           this routine.

       $sth-&gt;<u>bind</u><b>_</b><u>columns()</u>
           Regardless of whether the driver uses DBIc_DBISTATE(imp_xxh)-&gt;<u>get</u><b>_</b><u>fbav()</u>, the driver does not
           need to do anything about this routine as it simply iteratively calls $sth-&gt;<u>bind</u><b>_</b><u>col()</u>.

       The DBI code implements a default implementation of the following functions which do not need to be
       written by the DBD driver writer unless the default implementation is incorrect for the Driver.

       $dbh-&gt;<u>quote()</u>
           This should only be written if the database does not accept the ANSI SQL standard for quoting
           strings, with the string enclosed in single quotes and any embedded single quotes replaced by two
           consecutive single quotes.

           For the two argument form of quote, you need to implement the "type_info" method to provide the
           information that quote needs.

       $dbh-&gt;<u>ping()</u>
           This should be implemented as a simple efficient way to determine whether the connection to the
           database is still alive. Typically code like this:

             sub ping {
                 my $dbh = shift;
                 $sth = $dbh-&gt;prepare_cached(q{
                     select * from A_TABLE_NAME where 1=0
                 }) or return 0;
                 $sth-&gt;execute or return 0;
                 $sth-&gt;finish;
                 return 1;
             }

           where A_TABLE_NAME is the name of a table that always exists (such as a database system
           catalogue).

<b>METADATA</b> <b>METHODS</b>
       The exposition above ignores the DBI MetaData methods.  The metadata methods are all associated with
       a database handle.

       <b>Using</b> <b>DBI::DBD::Metadata</b>

       The DBI::DBD::Metadata module is a good semi-automatic way for the developer of a DBD module to write
       the get_info and type_info functions quickly and accurately.

       <u>Generating</u> <u>the</u> <u>get</u><b>_</b><u>info</u> <u>method</u>

       Prior to DBI v1.33, this existed as the method write_getinfo_pm in the DBI::DBD module.  From DBI
       v1.33, it exists as the method write_getinfo_pm in the DBI::DBD::Metadata module.  This discussion
       assumes you have DBI v1.33 or later.

       You examine the documentation for write_getinfo_pm using:

           perldoc DBI::DBD::Metadata

       To use it, you need a Perl DBI driver for your database which implements the get_info method.  In
       practice, this means you need to install DBD::ODBC, an ODBC driver manager, and an ODBC driver for
       your database.  With the pre-requisites in place, you might type:

           perl -MDBI::DBD::Metadata -e write_getinfo_pm \
                   dbi:ODBC:foo_db username password Driver

       The procedure writes to standard output the code that should be added to your Driver.pm file and the
       code that should be written to lib/DBD/Driver/GetInfo.pm.  You should review the output to ensure
       that it is sensible.

       <u>Generating</u> <u>the</u> <u>type</u><b>_</b><u>info</u> <u>method</u>

       Given the idea of the write_getinfo_pm method, it was not hard to devise a parallel method,
       write_typeinfo_pm, which does the analogous job for the DBI type_info_all metadata method.  The the
       write_typeinfo_pm method was added to DBI v1.33.

       You examine the documentation for write_typeinfo_pm using:

           perldoc DBI::DBD::Metadata

       The setup is exactly analogous to the mechanism descibed in "Generating the get_info method" With the
       pre-requisites in place, you might type:

           perl -MDBI::DBD::Metadata -e write_typeinfo \
                   dbi:ODBC:foo_db username password Driver

       The procedure writes to standard output the code that should be added to your Driver.pm file and the
       code that should be written to lib/DBD/Driver/TypeInfo.pm.  You should review the output to ensure
       that it is sensible.

       <b>Writing</b> <b>DBD::Driver::db::get_info</b>

       If you use the DBI::DBD::Metadata module, then the code you need is generated for you.

       If you decide not to use the DBI::DBD::Metadata module, you should probably borrow the code from a
       driver that has done so (eg DBD::Informix from version 1.05 onwards) and crib the code from there, or
       look at the code that generates that module and follow that.  The method in Driver.pm will be very
       simple; the method in lib/DBD/Driver/GetInfo.pm is not very much more complex unless your DBMS itself
       is much more complex.

       Note that some of the DBI utility methods rely on information from the get_info method to perform
       their operations correctly.  See, for example, the quote_identifier and quote methods, discussed
       below.

       <b>Writing</b> <b>DBD::Driver::db::type_info_all</b>

       If you use the DBI::DBD::Metadata module, then the code you need is generated for you.

       If you decide not to use the DBI::DBD::Metadata module, you should probably borrow the code from a
       driver that has done so (eg DBD::Informix from version 1.05 onwards) and crib the code from there, or
       look at the code that generates that module and follow that.  The method in Driver.pm will be very
       simple; the method in lib/DBD/Driver/TypeInfo.pm is not very much more complex unless your DBMS
       itself is much more complex.

       <b>Writing</b> <b>DBD::Driver::db::type_info</b>

       The guidelines on writing this method are still not really clear.  No sample implementation is
       available.

       <b>Writing</b> <b>DBD::Driver::db::table_info</b>

        *FIX ME* The guidelines on writing this method have not been written yet.
        No sample implementation is available.

       <b>Writing</b> <b>DBD::Driver::db::column_info</b>

        *FIX ME* The guidelines on writing this method have not been written yet.
        No sample implementation is available.

       <b>Writing</b> <b>DBD::Driver::db::primary_key_info</b>

        *FIX ME* The guidelines on writing this method have not been written yet.
        No sample implementation is available.

       <b>Writing</b> <b>DBD::Driver::db::primary_key</b>

        *FIX ME* The guidelines on writing this method have not been written yet.
        No sample implementation is available.

       <b>Writing</b> <b>DBD::Driver::db::foreign_key_info</b>

        *FIX ME* The guidelines on writing this method have not been written yet.
        No sample implementation is available.

       <b>Writing</b> <b>DBD::Driver::db::tables</b>

       This method generates an array of names in a format suitable for being embedded in SQL statements in
       places where a table name is expected.

       If your database hews close enough to the SQL standard or if you have implemented an appropriate
       table_info function and and the appropriate quote_identifier function, then the DBI default version
       of this method will work for your driver too.

       Otherwise, you have to write a function yourself, such as:

           sub tables
           {
               my($dbh, $cat, $sch, $tab, $typ) = @_;
               my(@res);
               my($sth) = $dbh-&gt;table_info($cat, $sch, $tab, $typ);
               my(@arr);
               while (@arr = $sth-&gt;fetchrow_array)
               {
                   push @res, $dbh-&gt;quote_identifier($arr[0], $arr[1], $arr[2]);
               }
               return @res;
           }

       See also the default implementation in DBI.pm.

       <b>Writing</b> <b>DBD::Driver::db::quote</b>

       This method takes a value and converts it into a string suitable for embedding in an SQL statement as
       a string literal.

       If your DBMS accepts the SQL standard notation for strings (single quotes around the string as a
       whole with any embedded single quotes doubled up), then you do not need to write this method as DBI
       provides a default method that does it for you.  If your DBMS uses an alternative notation or escape
       mechanism, then you need to provide an equivalent function.  For example, suppose your DBMS used C
       notation with double quotes around the string and backslashes escaping both double quotes and
       backslashes themselves.  Then you might write the function as:

           sub quote
           {
               my($dbh, $str) = @_;
               $str =~ s/["\\]/\\$&amp;/gmo;
               return qq{"$str"};
           }

       Handling newlines and other control characters is left as an exercise for the reader.

       This sample method ignores the $data_type indicator which is the optional second argument to the
       method.

       <b>Writing</b> <b>DBD::Driver::db::quote_identifier</b>

       This method is called to ensure that the name of the given table (or other database object) can be
       embedded into an SQL statement without danger of misinterpretation.  The result string should be
       usable in the text of an SQL statement as the identifier for a table.

       If your DBMS accepts the SQL standard notation for quoted identifiers (which uses double quotes
       around the identifier as a whole, with any embedded double quotes doubled up) and accepts
       "schema"."identifier" (and "catalog"."schema"."identifier" when a catalog is specified), then you do
       not need to write this method as DBI provides a default method that does it for you.  In fact, even
       if your DBMS does not handle exactly that notation but you have implemented the get_info method and
       it gives the correct responses, then it will work for you.  If your database is fussier, then you
       need to implement your own version of the function.

       For example, DBD::Informix has to deal with an environment variable DELIMIDENT.  If it is not set,
       then the DBMS treats names enclosed in double quotes as strings rather than names, which is usually a
       syntax error.  Additionally, the catalog portion of the name is separated from the schema and table
       by a different delimiter (colon instead of dot), and the catalog portion is never enclosed in quotes.
       (Fortunately, valid strings for the catalog will never contain weird characters that might need to be
       escaped, unless you count dots, dashes, slashes and at-signs as weird.)  Finally, an Informix
       database can contain objects that cannot be accessed because they were created by a user with the
       DELIMIDENT environment variable set, but the current user does not have it set.  By design choice,
       the quote_identifier method encloses those identifiers in double quotes anyway, which generally
       triggers a syntax error, and the metadata methods which generate lists of tables etc omit those
       identifiers from the result sets.

           sub quote_identifier
           {
               my($dbh, $cat, $sch, $obj) = @_;
               my($rv) = "";
               my($qq) = (defined $ENV{DELIMIDENT}) ? '"' : '';
               $rv .= qq{$cat:} if (defined $cat);
               if (defined $sch)
               {
                   if ($sch !~ m/^\w+$/o)
                   {
                       $qq = '"';
                       $sch =~ s/$qq/$qq$qq/gm;
                   }
                   $rv .= qq{$qq$sch$qq.};
               }
               if (defined $obj)
               {
                   if ($obj !~ m/^\w+$/o)
                   {
                       $qq = '"';
                       $obj =~ s/$qq/$qq$qq/gm;
                   }
                   $rv .= qq{$qq$obj$qq};
               }
               return $rv;
           }

       Handling newlines and other control characters is left as an exercise for the reader.

       Note that there is an optional fourth parameter to this function which is a reference to a hash of
       attributes; this sample implementation ignores that.  This sample implementation also ignores the
       single-argument variant of the method.

<b>WRITING</b> <b>AN</b> <b>EMULATION</b> <b>LAYER</b> <b>FOR</b> <b>AN</b> <b>OLD</b> <b>PERL</b> <b>INTERFACE</b>
       Study Oraperl.pm (supplied with DBD::Oracle) and Ingperl.pm (supplied with DBD::Ingres) and the
       corresponding dbdimp.c files for ideas.

       Note that the emulation code sets $dbh-&gt;{CompatMode} = 1; for each connection so that the internals
       of the driver can implement behaviour compatible with the old interface when dealing with those
       handles.

       <b>Setting</b> <b>emulation</b> <b>perl</b> <b>variables</b>

       For example, ingperl has a $sql_rowcount variable. Rather than try to manually update this in
       Ingperl.pm it can be done faster in C code.  In <u>dbd</u><b>_</b><u>init()</u>:

         sql_rowcount = perl_get_sv("Ingperl::sql_rowcount", GV_ADDMULTI);

       In the relevant places do:

         if (DBIc_COMPAT(imp_sth))     /* only do this for compatibility mode handles */
             sv_setiv(sql_rowcount, the_row_count);

<b>OTHER</b> <b>MISCELLANEOUS</b> <b>INFORMATION</b>
       <b>The</b> <b>imp_xyz_t</b> <b>types</b>

       Any handle has a corresponding C structure filled with private data.  Some of this data is reserved
       for use by DBI (except for using the DBIc macros below), some is for you. See the description of the
       <u>dbdimp.h</u> file above for examples. The most functions in dbdimp.c are passed both the handle "xyz" and
       a pointer to "imp_xyz". In rare cases, however, you may use the following macros:

       D_imp_dbh(dbh)
         Given a function argument <u>dbh</u>, declare a variable <u>imp</u><b>_</b><u>dbh</u> and initialize it with a pointer to the
         handles private data. Note: This must be a part of the function header, because it declares a
         variable.

       D_imp_sth(sth)
         Likewise for statement handles.

       <!-- a -->D_imp_xxx(h)<!-- /a -->
         Given any handle, declare a variable <u>imp</u><b>_</b><u>xxx</u> and initialize it with a pointer to the handles
         private data. It is safe, for example, to cast <u>imp</u><b>_</b><u>xxx</u> to "imp_dbh_t*", if DBIc_TYPE(imp_xxx) ==
         DBIt_DB.  (You can also call sv_derived_from(h, "DBI::db"), but that's much slower.)

       D_imp_dbh_from_sth
         Given a imp_sth, declare a variable <u>imp</u><b>_</b><u>dbh</u> and initialize it with a pointer to the parent database
         handle's implementors structure.

       <b>Using</b> <b>DBIc_IMPSET_on</b>

       The driver code which initializes a handle should use <u>DBIc</u><b>_</b><u>IMPSET</u><b>_</b><u>on()</u> as soon as its state is such
       that the cleanup code must be called.  When this happens is determined by your driver code.

       Failure to call this can lead to corruption of data structures.  For example, DBD::Informix maintains
       a linked list of database handles in the driver, and within each handle, a linked list of statements.
       Once a statement is added to the linked list, it is crucial that it is cleaned up (removed from the
       list).  When <u>DBIc</u><b>_</b><u>IMPSET</u><b>_</b><u>on()</u> was being called too late, it was able to cause all sorts of problems.

       <b>Using</b> <u>DBIc</u><b>_</b><u>is()</u><b>,</b> <u>DBIc</u><b>_</b><u>has()</u><b>,</b> <u>DBIc</u><b>_</b><u>on()</u> <b>and</b> <u>DBIc</u><b>_</b><u>off()</u>

       Once upon a long time ago, the only way of handling the internal DBI boolean flags/attributes was
       through macros such as:

         DBIc_WARN       DBIc_WARN_on        DBIc_WARN_off
         DBIc_COMPAT     DBIc_COMPAT_on      DBIc_COMPAT_off

       Each of these took an imp_xxh pointer as an argument.

       Since then, new attributes have been added such as ChopBlanks, RaiseError and PrintError, and these
       do not have the full set of macros.  The approved method for handling these is now the four macros:

         DBIc_is(imp, flag)
         DBIc_has(imp, flag)       an alias for DBIc_is
         DBIc_on(imp, flag)
         DBIc_off(imp, flag)
         DBIc_set(imp, flag, on)   set if on is true, else clear

       Consequently, the DBIc_XXXXX family of macros is now mostly deprecated and new drivers should avoid
       using them, even though the older drivers will probably continue to do so for quite a while yet.
       However...

       There is an <u>important</u> <u>exception</u> to that. The ACTIVE and IMPSET flags should be set via the
       DBIc_ACTIVE_on and DBIc_IMPSET_on macros, and unset via the DBIc_ACTIVE_off and DBIc_IMPSET_off
       macros.

       <b>Using</b> <b>the</b> <u>get</u><b>_</b><u>fbav()</u> <b>method</b>

       <b>THIS</b> <b>IS</b> <b>CRITICAL</b> for C/XS drivers.

       The $sth-&gt;<u>bind</u><b>_</b><u>col()</u> and $sth-&gt;<u>bind</u><b>_</b><u>columns()</u> documented in the DBI specification do not have to be
       implemented by the driver writer because DBI takes care of the details for you.  However, the key to
       ensuring that bound columns work is to call the function DBIc_DBISTATE(imp_xxh)-&gt;<u>get</u><b>_</b><u>fbav()</u> in the
       code which fetches a row of data.  This returns an AV, and each element of the AV contains the SV
       which should be set to contain the returned data.

       The pure Perl equivalent is the $sth-&gt;_set_fbav($data) method, as described in the part on pure Perl
       drivers.

<b>SUBCLASSING</b> <b>DBI</b> <b>DRIVERS</b>
       This is definitely an open subject. It can be done, as demonstrated by the <u>DBD::File</u> driver, but it
       is not as simple as one might think.

       (Note that this topic is different from subclassing the DBI. For an example of that, see the
       t/subclass.t file supplied with the DBI.)

       The main problem is that the dbh's and sth's that your <u>connect</u> and <u>prepare</u> methods return are not
       instances of your <u>DBD::Driver::db</u> or <u>DBD::Driver::st</u> packages, they are not even derived from it.
       Instead they are instances of the <u>DBI::db</u> or <u>DBI::st</u> classes or a derived subclass. Thus, if you
       write a method <u>mymethod</u> and do a

         $dbh-&gt;mymethod()

       then the autoloader will search for that method in the package <u>DBI::db</u>.  Of course you can instead to
       a

         $dbh-&gt;func('mymethod')

       and that will indeed work, even if <u>mymethod</u> is inherited, but not without additional work. Setting
       @ISA is not sufficient.

       <b>Overwriting</b> <b>methods</b>

       The first problem is, that the <u>connect</u> method has no idea of subclasses. For example, you cannot
       implement base class and subclass in the same file: The <u>install</u><b>_</b><u>driver</u> method wants to do a

         require DBD::Driver;

       In particular, your subclass <b>has</b> to be a separate driver, from the view of DBI, and you cannot share
       driver handles.

       Of course that's not much of a problem. You should even be able to inherit the base classes <u>connect</u>
       method. But you cannot simply overwrite the method, unless you do something like this, quoted from
       <u>DBD::CSV</u>:

         sub connect ($$;$$$) {
             my ($drh, $dbname, $user, $auth, $attr) = @_;

             my $this = $drh-&gt;DBD::File::dr::connect($dbname, $user, $auth, $attr);
             if (!exists($this-&gt;{csv_tables})) {
                 $this-&gt;{csv_tables} = {};
             }

             $this;
         }

       Note that we cannot do a

         $drh-&gt;SUPER::connect($dbname, $user, $auth, $attr);

       as we would usually do in a an OO environment, because $drh is an instance of <u>DBI::dr</u>. And note, that
       the <u>connect</u> method of <u>DBD::File</u> is able to handle subclass attributes. See the description of Pure
       Perl drivers above.

       It is essential that you always call superclass method in the above manner. However, that should do.

       <b>Attribute</b> <b>handling</b>

       Fortunately the DBI specifications allow a simple, but still performant way of handling attributes.
       The idea is based on the convention that any driver uses a prefix <u>driver</u><b>_</b> for its private methods.
       Thus it's always clear whether to pass attributes to the super class or not.  For example, consider
       this STORE method from the <u>DBD::CSV</u> class:

         sub STORE {
             my ($dbh, $attr, $val) = @_;
             if ($attr !~ /^driver_/) {
                 return $dbh-&gt;DBD::File::db::STORE($attr, $val);
             }
             if ($attr eq 'driver_foo') {
             ...
         }

<b>AUTHORS</b>
       Jonathan Leffler &lt;jleffler@us.ibm.com&gt; (previously &lt;jleffler@informix.com&gt;), Jochen Wiedmann
       &lt;joe@ispsoft.de&gt;, Steffen Goeldner &lt;sgoeldner@cpan.org&gt;, and Tim Bunce &lt;dbi-users@perl.org&gt;.



perl v5.8.8                                      2006-05-10                                      DBI::DBD(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/DBI__DBD.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/DBI__DBD.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/DBI__DBD.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
