unit PicComments; { 5/9/92 - 7/9/92: fixed TDashedLineRec }interface	const		TextBegin = 150;		TextEnd = 151;		StringBegin = 152;		StringEnd = 153;		TextCenter = 154;		LineLayoutOff = 155;		LineLayoutOn = 156;		ClientLineLayout = 157;		PolyBegin = 160;		PolyEnd = 161;		PolyIgnore = 163;		PolySmooth = 164;		PolyClose = 165;		DashedLine = 180;		DashedStop = 181;		SetLineWidth = 182;		PostScriptBegin = 190;		PostScriptEnd = 191;		PostScriptHandle = 192;		PostScriptFile = 193;		TextIsPostScript = 194;		ResourcePS = 195;		PSBeginNoSave = 196;		SetGrayLevel = 197;		RotateBegin = 200;		RotateEnd = 201;		RotateCenter = 202;		FormsPrinting = 210;		EndFormsPrinting = 211;   { Values for the tJus field of the TTxtPicRec record }		tJusNone = 0;		tJusLeft = 1;		tJusCenter = 2;		tJusRight = 3;		tJusFull = 4;   { Values for the tFlip field of the TTxtPicRec record }		tFlipNone = 0;		tFlipHorizontal = 1;		tFlipVertical = 2;		magicPen = 23; { the infamous penMode - hides drawing from QuickDraw devices }	type		TTxtPicHdl = ^TTxtPicPtr;		TTxtPicPtr = ^TTxtPicRec;		TTxtPicRec = packed record				tJus: Byte;				tFlip: Byte;				tAngle: Integer;  {clockwise rotation in degrees 0..360 }				tLine: Byte;    {Unused/Ignored }				tCmnt: Byte;    {Reserved }				tAngleFixed: Fixed; { the same as "angle" in Fixed precision   }			end; { TTxtPicRec }		TRotationHdl = ^TRotationPtr;		TRotationPtr = ^TRotationRec;		TRotationRec = record				rFlip: Integer;				rAngle: Integer;    { Clockwise rotation in degrees (0..360) }				rAngleFixed: Fixed; { the same as "angle" in Fixed precision  }			end; { TRotation }		TCenterHdl = ^TCenterPtr;		TCenterPtr = ^TCenterRec;		TCenterRec = record  {offset from current pen location to center of rotation}				y: Fixed;				x: Fixed;			end; { TCenter }		TPolyVerbHdl = ^TPolyVerbPtr;		TPolyVerbPtr = ^TPolyVerbRec;		TPolyVerbRec = packed record				f7, f6, f5, f4, f3,     { Reserved }				fPolyClose,          { TRUE = Polygon should be closed }				fPolyFill,           { TRUE = Polygon should be filled }				fPolyFrame: BOOLEAN; { TRUE = Polygon should be framed }			end;		TDashedLineHdl = ^TDashedLinePtr;		TDashedLinePtr = ^TDashedLineRec;		TDashedLineRec = packed record				offset: SignedByte;  { Offset into pattern for first dash }				centered: SignedByte;  { (Ignored) }				intervals: array[0..5] of SignedByte; { Array of dash intervals; }                          { intervals[0] contains the number of intervals }			end;		TLineWidthHdl = ^TLineWidthPtr;		TLineWidthPtr = ^TLineWidth;		TLineWidth = Point;  { v = numerator, h = denominator }		TClientLLHdl = ^TClientLLPtr;  { used in the ClientLineLayout picture comment }		TClientLLPtr = ^TClientLLRec;		TClientLLRec = record				chCount: Integer;  { Apply for so many characters. }				major: Fixed;    { Percentage of line layout error to be }                                         { distributed among space characters.   }				spcChar: Integer;  { Code of character that is to absorb   }                                         { the "major" line layout error.        }				minor: Fixed;    { Percentage of intercharacter distrib. }				ulLength: Fixed;    { Underline length.                     }			end;{---------------------------------------------------}{ -- Definitions for obsolete picture comments deleted. -- }{---------------------------------------------------}	procedure FlushGrafPortState;	procedure FlushPostScriptState;implementation	procedure FlushGrafPortState;		var			penInfo: PenState;	begin		GetPenState(penInfo);		PenSize(0, 0);		Line(0, 0);		PenSize(penInfo.pnSize.h, penInfo.pnSize.v);	end;	procedure FlushPostScriptState;	begin		PicComment(PostScriptBegin, 0, nil);		PicComment(PostScriptEnd, 0, nil);	end;end.