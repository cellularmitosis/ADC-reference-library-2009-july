<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Drawing Guide: Advanced Drawing Techniques</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Advanced Drawing Techniques"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003290-CH207" title="Advanced Drawing Techniques"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290-CH201-SW1">Cocoa Drawing Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Text/Text.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../QuartzOpenGL/QuartzOpenGL.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40003290-CH207-CJBFEEJA" title="Advanced Drawing Techniques"></a><h1>Advanced Drawing Techniques</h1><p>Creating an effective and beautiful Mac OS X application often requires the use of many different techniques. Beyond the basic drawing of paths and images in views, there are other ways to create more complex imagery for your application. The following sections cover many of the most commonly used techniques supported by Cocoa. </p>

<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-SW1">Adding Shadows to Drawn Paths</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-SW9">Creating Gradient Fills</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-SW16">Drawing to the Screen</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-CJBIGIGG">Using NSTimer for Animated Content</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-CJBGBGDJ">Using Cocoa Animation Objects</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-CJBJDDEH">Optimizing Your Drawing Code</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003290-CH207-SW1" title="Adding Shadows to Drawn Paths"></a><h2>Adding Shadows to Drawn Paths</h2>
<p>Cocoa provides support for <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_22"></a><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_23"></a><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_24"></a>shadows through the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_25"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSShadow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSShadow" target="_top">NSShadow</a></code> class. A shadow mimics a light source cast on the object, making paths appear as if they’re floating above the surface of the view. <span class="content_text">Figure 8-1</span> shows the effect created by a shadow for a few paths. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH207-CJBIEHAG" title="Figure 8-1Shadows cast by rendered paths"></a><p><strong>Figure 8-1&nbsp;&nbsp;</strong>Shadows cast by rendered paths</p>
<img src = "../art/shadows.gif" alt = "Shadows cast by rendered paths" width="384" height="286"></div><br/>
<p>A shadow effect consists of horizontal and vertical offset values, a blur value, and the shadow color. These effects combine to give the illusion that there is a light above the canvas that is shining down on the shapes below. The offset and blur values effectively determine the position of the light and the height of the shapes above the canvas. </p>
<p>Shadow positions always use the base coordinate system of the view, ignoring any transforms you apply to the shapes in your view. This means that no matter how you manipulate the shapes in a view, the apparent position of the light generating the shadows never changes. If you want to change the apparent position of the light, you must change the shadow object attributes and apply the updated shadow object to the current graphics context before drawing your content.</p>
<p>To create a shadow, you create an <code>NSShadow</code> object and call its methods to set the desired shadow attributes. If you anticipate one or more paths overlapping each other, you should be sure to choose a color that has an alpha value; otherwise, shadows that intersect other objects might look flat and ruin the effect. To apply the shadow, invoke its <code>set</code> method. </p>
<p><span class="content_text">Listing 8-1</span> shows the code used to create the shadow for the paths in <span class="content_text"><a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-CJBIEHAG">Figure 8-1</a></span>. A partially transparent color is used to allow for overlapping paths and shadows. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW4" title="Listing 8-1Adding a shadow to a path"></a><p class="codesample"><strong>Listing 8-1&nbsp;&nbsp;</strong>Adding a shadow to a path</p><div class="codesample"><table><tr><td scope="row"><pre>[NSGraphicsContext saveGraphicsState];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create the shadow below and to the right of the shape.<span></span></pre></td></tr><tr><td scope="row"><pre>NSShadow* theShadow = [[NSShadow alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>[theShadow setShadowOffset:NSMakeSize(10.0, -10.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[theShadow setShadowBlurRadius:3.0];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Use a partially transparent color for shapes that overlap.<span></span></pre></td></tr><tr><td scope="row"><pre>[theShadow setShadowColor:[[NSColor blackColor]<span></span></pre></td></tr><tr><td scope="row"><pre>             colorWithAlphaComponent:0.3]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[theShadow set];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Draw your custom content here. Anything you draw<span></span></pre></td></tr><tr><td scope="row"><pre>// automatically has the shadow effect applied to it.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[NSGraphicsContext restoreGraphicsState];<span></span></pre></td></tr><tr><td scope="row"><pre>[theShadow release];<span></span></pre></td></tr></table></div>
<p>Shadow effects are stored as part of the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_26"></a>graphics state, so once set, they affect all subsequent rendering commands in the current context. This is an important thing to remember because it might force you to think about the order in which you draw your content. For example, if you set up a shadow, fill a path, and then stroke the same path, you do not get a single shape with an outline, fill color, and shadow. Instead, you get two shapes—an outline and a fill shape—and two shadows, one for each shape. If you stroke the path after filling it, the shadow for the stroked path appears on top of the filled shape. In <span class="content_text"><a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-CJBIEHAG">Figure 8-1</a></span>, the desired effect was achieved by applying the shadow to only the fill shape of each path. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH207-SW10" title="Note"></a><p><strong>Note:</strong>&nbsp;Another way to a single shadow for multiple paths is using a Quartz transparency layer. For more information about using transparency layers, see <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>. </p></div><a name="//apple_ref/doc/uid/TP40003290-CH207-SW9" title="Creating Gradient Fills"></a><h2>Creating Gradient Fills</h2><p>A <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_27"></a><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_28"></a>gradient fill (also referred to as a <strong><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_29"></a>shading</strong> in Quartz) is a pattern that gradually changes from one color to another. Unlike the image-based patterns supported by <code>NSColor</code>, a gradient fill does not tile colors to fill the target shape. Instead, it uses a mathematical function to compute the color at individual points along the gradient. Because they are mathematical by nature, gradients are resolution independent and scale readily to any device.  </p><p><span class="content_text">Figure 8-2</span> shows some simple gradient fill patterns. Gradients a and b show linear gradients filling different Bezier shapes and aligned along different angles while gradients c and d show radial gradients. In the case of gradient c, the gradient was set to draw before and after the gradient’s starting and ending locations, thus creating both a white circle in the very center of the gradient and a black border surrounding the gradient. For gradient d, the center points of the circles used to draw the gradient are offset, creating a different sort of shading effect. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH207-CJBFEGJA" title="Figure 8-2Different types of gradients"></a><p><strong>Figure 8-2&nbsp;&nbsp;</strong>Different types of gradients</p><img src = "../art/assorted_gradients.jpg" alt = "Different types of gradients" ></div><br/><p>In Mac OS X v10.5 and later, Cocoa provides support for drawing gradients using the <code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/cl/NSGradient" target="_top">NSGradient</a></code> class. If your software runs on earlier versions of Mac OS X, you must use Quartz or Core Image to perform gradient fills.  </p><a name="//apple_ref/doc/uid/TP40003290-CH207-SW11" title="Using the NSGradient Class"></a><h3>Using the NSGradient Class</h3><p>In Mac OS X v10.5 and later, you can use the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_30"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/cl/NSGradient" target="_top">NSGradient</a></code> class to create complex gradient fill patterns without having to write your own color computation function. Gradient objects are immutable objects that store information about the colors in the gradient and provide an interface for drawing those colors to the current context. When you create an <code>NSGradient</code> object, you specify one or more <code>NSColor</code> objects and a set of optional location parameters. During drawing, the gradient object uses this information to compute the color transitions for the gradient.</p><p>The <code>NSGradient</code> class supports both high-level and primitive drawing methods. The high-level methods provide a simple interface for drawing gradients as a fill pattern for a Bezier path or rectangle. If you need additional control over the final shape and appearance of the gradient fill, you can set up the clipping path your self and use the primitive drawing methods of <code>NSGradient</code> to do your drawing.</p><a name="//apple_ref/doc/uid/TP40003290-CH207-SW12" title="Configuring the Colors of a Gradient Object"></a><h4>Configuring the Colors of a Gradient Object</h4><p>The <code>NSGradient</code> class uses color stops to determine the position of color changes in its gradient fill. A <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_31"></a><strong>color stop</strong> is a combination of an <code>NSColor</code> object and a floating-point number in the range 0.0 to 1.0. The floating point number represents the relative position of the associated color along the drawing axis of the gradient, which can be either radial or axial.</p><p>By definition, gradients must have at least two color stops. Typically, these color stops represent the start and end points  of the gradient. Although the start point is often located at 0.0 and the end point at 1.0, that may not always be the case. You can position the start and end points anywhere along the gradient’s drawing axis. As it creates the gradient, the gradient object fills the area prior to the start point with the start color and similarly fills the area after the end point with the end color.  </p><p>You can use the same gradient object to draw multiple gradient fills and you can freely mix the creation of radial and axial gradients using the same gradient object. Although you configure the colors of a gradient when you create the gradient object, you configure the drawing axis of the gradient only when you go to draw it. The <code>NSGradient</code> class defines the following methods for configuring the colors and color stops of a gradient. </p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/initWithStartingColor:endingColor:" target="_top">initWithStartingColor:endingColor:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/initWithColors:" target="_top">initWithColors:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/initWithColorsAndLocations:" target="_top">initWithColorsAndLocations:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/initWithColors:atLocations:colorSpace:" target="_top">initWithColors:atLocations:colorSpace:</a></code></p></li></ul><p>Although you cannot change the colors of a gradient object after you initialize it, you can get information about the colors it contains using accessor methods. The <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_32"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/numberOfColorStops" target="_top">numberOfColorStops</a></code> method returns the number of colors that the gradient uses to draw itself and the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_33"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/getColor:location:atIndex:" target="_top">getColor:location:atIndex:</a></code> method retrieves the color stop information for each of those colors. If you want to know what color would be drawn for the gradient in between two color stops, you can use the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_34"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/interpolatedColorAtLocation:" target="_top">interpolatedColorAtLocation:</a></code> method to get it.</p><a name="//apple_ref/doc/uid/TP40003290-CH207-SW13" title="Drawing to a High-Level Path"></a><h4>Drawing to a High-Level Path</h4><p>The <code>NSGradient</code> class defines several convenience methods for drawing both radial and axial gradients:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_35"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/drawInRect:angle:" target="_top">drawInRect:angle:</a></code></p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_36"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/drawInRect:relativeCenterPosition:" target="_top">drawInRect:relativeCenterPosition:</a></code></p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_37"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/drawInBezierPath:angle:" target="_top">drawInBezierPath:angle:</a></code></p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_38"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/drawInBezierPath:relativeCenterPosition:" target="_top">drawInBezierPath:relativeCenterPosition:</a></code></p></li></ul><p>These convenience methods are easily identified by the fact that they take either an <code>NSBezierPath</code> or a rectangle as their first parameter. This parameter is used as a clipping region for the gradient when it is drawn. You might use these methods to draw a gradient fill inside an existing shape in your interface.</p><p><span class="content_text">Listing 8-2</span> shows some code that draws an axial gradient pattern. The <code>NSBezierPath</code> object containing the rounded rectangle shape acts as the clipping region for the gradient when it is drawn. <span class="content_text"><a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-SW8">Figure 8-3</a></span> shows the resulting gradient. </p><a name="//apple_ref/doc/uid/TP40003290-CH207-SW7" title="Listing 8-2Clipping an axial gradient to a rounded rectangle"></a><p class="codesample"><strong>Listing 8-2&nbsp;&nbsp;</strong>Clipping an axial gradient to a rounded rectangle</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)drawRect:(NSRect)rect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect        bounds = [self bounds];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSBezierPath*    clipShape = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre>    [clipShape appendBezierPathWithRoundedRect:bounds xRadius:40 yRadius:30];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSGradient* aGradient = [[[NSGradient alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                    initWithColorsAndLocations:[NSColor redColor], (CGFloat)0.0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            [NSColor orangeColor], (CGFloat)0.166,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            [NSColor yellowColor], (CGFloat)0.33,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            [NSColor greenColor], (CGFloat)0.5,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            [NSColor blueColor], (CGFloat)0.75,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            [NSColor purpleColor], (CGFloat)1.0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            nil] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [aGradient drawInBezierPath:clipShape angle:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP40003290-CH207-SW8" title="Figure 8-3Axial gradient drawn inside a Bezier path"></a><p><strong>Figure 8-3&nbsp;&nbsp;</strong>Axial gradient drawn inside a Bezier path</p><img src = "../art/bezier_gradient.jpg" alt = "Axial gradient drawn inside a Bezier path" ></div><br/><a name="//apple_ref/doc/uid/TP40003290-CH207-SW14" title="Using the Primitive Drawing Routines"></a><h4>Using the Primitive Drawing Routines</h4><p>In addition to the high-level convenience methods, the <code>NSGradient</code> class defines two primitive methods for drawing gradients:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_39"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/drawFromPoint:toPoint:options:" target="_top">drawFromPoint:toPoint:options:</a></code></p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_40"></a><code><a href="../../../Reference/NSGradient_class/Reference/Reference.html#//apple_ref/occ/instm/NSGradient/drawFromCenter:radius:toCenter:radius:options:" target="_top">drawFromCenter:radius:toCenter:radius:options:</a></code></p></li></ul><p>These methods give you more flexibility over the gradient parameters, including the ability to extend the gradient colors beyond their start and end points. Unlike the high-level routines, these methods do not change the clip region prior to drawing. If you do not set up a custom clip region prior to drawing, the resulting gradient could potentially expand to fill your entire view, depending on the gradient options.</p><p><span class="content_text">Listing 8-3</span> shows the code for drawing a radial gradient in a view using the primitive drawing routine of <code>NSGradient</code>. The second circle in the gradient is offset from the first one by 60 points in both the horizontal and vertical directions, causing the overall gradient to skew towards the upper-right of the circle. Because the code passes the value 0 for the <code>options</code> parameter, the gradient does not draw beyond the start and end colors and therefore does not fill the entire view. <span class="content_text"><a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-SW6">Figure 8-4</a></span> shows the gradient resulting from this code.</p><a name="//apple_ref/doc/uid/TP40003290-CH207-SW5" title="Listing 8-3Drawing a radial gradient using primitive routine"></a><p class="codesample"><strong>Listing 8-3&nbsp;&nbsp;</strong>Drawing a radial gradient using primitive routine</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)drawRect:(NSRect)rect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect bounds = [self bounds];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSGradient* aGradient = [[[NSGradient alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                                    initWithStartingColor:[NSColor orangeColor]<span></span></pre></td></tr><tr><td scope="row"><pre>                                    endingColor:[NSColor cyanColor]] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint centerPoint = NSMakePoint(NSMidX(bounds), NSMidY(bounds));<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint otherPoint = NSMakePoint(centerPoint.x + 60.0, centerPoint.y + 60.0);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGFloat firstRadius = MIN( ((bounds.size.width/2.0) - 2.0),<span></span></pre></td></tr><tr><td scope="row"><pre>                               ((bounds.size.height/2.0) -2.0) );<span></span></pre></td></tr><tr><td scope="row"><pre>    [aGradient drawFromCenter:centerPoint radius:firstRadius<span></span></pre></td></tr><tr><td scope="row"><pre>                toCenter:otherPoint radius:5.0<span></span></pre></td></tr><tr><td scope="row"><pre>                options:0];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP40003290-CH207-SW6" title="Figure 8-4Gradient created using primitive drawing method"></a><p><strong>Figure 8-4&nbsp;&nbsp;</strong>Gradient created using primitive drawing method</p><img src = "../art/radial_gradient.jpg" alt = "Gradient created using primitive drawing method" ></div><br/>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW15" title="Using Quartz Shadings in Cocoa"></a><h3>Using Quartz Shadings in Cocoa</h3><p>Because the <code>NSGradient</code> class is available only in Mac OS X v10.5 and later, software that runs on earlier versions of Mac OS X must use Quartz or <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_41"></a>Core Image to draw gradient fills. Quartz supports the creation of both <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_42"></a>radial and <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_43"></a>axial gradients in different color spaces using a mathematical computation function you provide. The use of a mathematical function means that the gradients you create using Quartz scale well to any resolution. Core Image, on the other hand, provides filters for creating a fixed-resolution image consisting of a radial, axial, or <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_44"></a>Gaussian gradient. Because the end result is an image, however, Core Image gradients may be less desirable for PDF and other print-based drawing.</p><p>To draw a Quartz shading in your Cocoa program, you would do the following from your <code>drawRect:</code> method:</p><ol class="ol"><li class="li"><p>Get a <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/tdef/CGContextRef" target="_top">CGContextRef</a></code> using the <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/graphicsPort" target="_top">graphicsPort</a></code> method of <code>NSGraphicsContext</code>. (You will pass this reference to other Quartz functions.)</p></li><li class="li"><p>Create a <code><a href="../../../../GraphicsImaging/Reference/CGShading/Reference/reference.html#//apple_ref/c/tdef/CGShadingRef" target="_top">CGShadingRef</a></code> using Quartz; see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_shadings/dq_shadings.html#//apple_ref/doc/uid/TP30001066-CH207" target="_top">Gradients</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p></li><li class="li"><p>Configure the current clipping path to the desired shape for your shading; see <span class="content_text"><a href="../GraphicsContexts/GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIIADBC">“Setting the Clipping Region.”</a></span> </p></li><li class="li"><p>Draw the shading using <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawShading" target="_top">CGContextDrawShading</a></code>.</p></li></ol><p>For information on using Core Image to create images with gradient fills, see <em><a href="../../../../GraphicsImaging/Conceptual/CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em>.</p>

<a name="//apple_ref/doc/uid/TP40003290-CH207-SW16" title="Drawing to the Screen"></a><h2>Drawing to the Screen</h2>
<p>If you want to take over the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_45"></a>entire <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_46"></a><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_47"></a>screen for your drawing, you can do so from a Cocoa application. Entering full-screen drawing mode is a two-step process:</p>
<ol class="ol"><li class="li"><p>Capture the desired screen (or screens) for drawing.</p></li>
<li class="li"><p>Configure your drawing environment.</p></li></ol>
<p>After capturing the screen, the way you configure your drawing environment depends on whether you are using Cocoa or OpenGL to draw. In OpenGL, you create an <code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOpenGLContext" target="_top">NSOpenGLContext</a></code> object and invoke several of its methods to enter full-screen mode. In Cocoa, you have to create a window that fills the screen and configure that window. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-CJBGBCBH" title="Capturing the Screen"></a><h3>Capturing the Screen</h3>
<p>Cocoa does not provide direct support for capturing and releasing <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_48"></a>screens. The <code>NSScreen</code> class provides read-only access to information about the available screens. To capture or manipulate a screen, you must use the functions found in <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_49"></a>Quartz Services. </p>
<p>To <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_50"></a>capture all of the available screens, you can simply call the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_51"></a><code><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGCaptureAllDisplays" target="_top">CGCaptureAllDisplays</a></code> function. To capture an individual display, you must get the ID of the desired display and call the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_52"></a><code><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplayCapture" target="_top">CGDisplayCapture</a></code> function to capture it. The following example shows how to use information provided by an <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_53"></a><code>NSScreen</code> object to capture the main screen of a system.</p>
<div class="codesample"><table><tr><td scope="row"><pre>- (BOOL) captureMainScreen<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the ID of the main screen.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSScreen* mainScreen = [NSScreen mainScreen];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSDictionary* screenInfo = [mainScreen deviceDescription];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber* screenID = [screenInfo objectForKey:@"NSScreenNumber"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Capture the display.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDisplayErr err = CGDisplayCapture([screenID longValue]);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err != CGDisplayNoErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        return NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>To release a display you previously captured, use the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_54"></a><code><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplayRelease" target="_top">CGDisplayRelease</a></code> function. If you captured all of the active displays, you can release them all by calling the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_55"></a><code><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGReleaseAllDisplays" target="_top">CGReleaseAllDisplays</a></code> function. </p>
<p>For more information about capturing and manipulating screens, see <em><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/index.html#//apple_ref/doc/uid/TP30001070" target="_top">Quartz Display Services Reference</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW17" title="Full-Screen Drawing in OpenGL"></a><h3>Full-Screen Drawing in OpenGL</h3>
<p>Applications that do full-screen <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_56"></a>drawing tend to be graphics intensive and thus use <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_57"></a>OpenGL to improve rendering speed. Creating a full-screen context using OpenGL is easy to do from Cocoa. After capturing the desired displays, create and configure an <code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOpenGLContext" target="_top">NSOpenGLContext</a></code> object and then invoke its <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_58"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/setFullScreen" target="_top">setFullScreen</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/makeCurrentContext" target="_top">makeCurrentContext</a></code> methods. After invoking these methods, your application goes immediately to full-screen mode and you can start drawing content.</p><p>When requesting a full-screen context in OpenGL, the pixel format for your context should include the following attributes: </p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLPixelFormat_Class/Reference/Reference.html#//apple_ref/c/econst/NSOpenGLPFAFullScreen" target="_top">NSOpenGLPFAFullScreen</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLPixelFormat_Class/Reference/Reference.html#//apple_ref/c/econst/NSOpenGLPFAScreenMask" target="_top">NSOpenGLPFAScreenMask</a></code> </p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLPixelFormat_Class/Reference/Reference.html#//apple_ref/c/econst/NSOpenGLPFAAccelerated" target="_top">NSOpenGLPFAAccelerated</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLPixelFormat_Class/Reference/Reference.html#//apple_ref/c/econst/NSOpenGLPFANoRecovery" target="_top">NSOpenGLPFANoRecovery</a></code> (only if your OpenGL graphics context is shared)</p></li></ul><p><span class="content_text">Listing 8-4</span> shows the basic steps for capturing all displays and setting up the OpenGL context for full-screen drawing. For information on how to create an <code>NSOpenGLContext</code> object, see <span class="content_text"><a href="../QuartzOpenGL/QuartzOpenGL.html#//apple_ref/doc/uid/TP40003290-CH211-BAAIFCFA">“Creating an OpenGL Graphics Context.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW2" title="Listing 8-4Creating an OpenGL full-screen context"></a><p class="codesample"><strong>Listing 8-4&nbsp;&nbsp;</strong>Creating an OpenGL full-screen context</p><div class="codesample"><table><tr><td scope="row"><pre>NSOpenGLContext* CreateScreenContext()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDisplayErr err;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = CGCaptureAllDisplays();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err != CGDisplayNoErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the context object.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLContext* glContext = CreateMyGLContext();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If the context is bad, release the displays.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!glContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGReleaseAllDisplays();<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Go to full screen mode.<span></span></pre></td></tr><tr><td scope="row"><pre>    [glContext setFullScreen];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Make this context current so that it receives OpenGL calls.<span></span></pre></td></tr><tr><td scope="row"><pre>    [glContext makeCurrentContext];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return glContext;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Once you go into full-screen mode with your graphics context, your application has full control of the screen. To exit full-screen mode, invoke the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_59"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/clearDrawable" target="_top">clearDrawable</a></code> method of your OpenGL context and call the <code><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGReleaseAllDisplays" target="_top">CGReleaseAllDisplays</a></code> function to release the screens back to the system.</p>
<p>For detailed sample code showing you how to enter full-screen mode using OpenGL and Cocoa, see the NSOpenGL Fullscreen sample in <span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxOpenGL-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000549" target="_top">Sample Code > Graphics &amp; Imaging > OpenGL</a></span>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW18" title="Full-Screen Drawing in Cocoa"></a><h3>Full-Screen Drawing in Cocoa</h3>
<p>All Cocoa drawing occurs in a window, but for full screen drawing, the window you create is a little different. Instead of a bordered window with a title bar, you need to create a borderless window that spans the entire screen area. </p>
<p>Although you create a full-<a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_60"></a>screen window using Cocoa classes, you still have to use <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_61"></a>Quartz Services to capture the display and configure the window properly. The capture process is described in <span class="content_text"><a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-CJBGBCBH">“Capturing the Screen.”</a></span> Once you capture the screen, the window server puts up a shield window that hides most other content. To make your full-screen window visible, you must adjust its level to sit above this shield. You can get the shield level using the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_62"></a><code><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGShieldingWindowLevel" target="_top">CGShieldingWindowLevel</a></code> function and pass the returned value to the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_63"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/setLevel:" target="_top">setLevel:</a></code> method of your window. </p>
<p><span class="content_text">Listing 8-5</span> shows an action method defined in a subclass of <code>NSDocument</code>. The document object uses this method to capture the main display and create the window to fill that screen space. The window itself contains a single view (of type <code>MyFullScreenView</code>) for drawing content. (In your own code, you would replace this view with your own custom drawing view.) A reference to the window is stored in the <code>myScreenWindow</code> class instance variable, which is initialized to <code>nil</code> when the class is first instantiated.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW3" title="Listing 8-5Creating a Cocoa full-screen context"></a><p class="codesample"><strong>Listing 8-5&nbsp;&nbsp;</strong>Creating a Cocoa full-screen context</p><div class="codesample"><table><tr><td scope="row"><pre>- (IBAction)goFullScreen:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the screen information.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSScreen* mainScreen = [NSScreen mainScreen];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSDictionary* screenInfo = [mainScreen deviceDescription];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber* screenID = [screenInfo objectForKey:@"NSScreenNumber"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Capture the screen.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDirectDisplayID displayID = (CGDirectDisplayID)[screenID longValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDisplayErr err = CGDisplayCapture(displayID);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err == CGDisplayNoErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Create the full-screen window if it doesn’t already  exist.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!myScreenWindow)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // Create the full-screen window.<span></span></pre></td></tr><tr><td scope="row"><pre>            NSRect winRect = [mainScreen frame];<span></span></pre></td></tr><tr><td scope="row"><pre>            myScreenWindow = [[NSWindow alloc] initWithContentRect:winRect<span></span></pre></td></tr><tr><td scope="row"><pre>                    styleMask:NSBorderlessWindowMask<span></span></pre></td></tr><tr><td scope="row"><pre>                    backing:NSBackingStoreBuffered<span></span></pre></td></tr><tr><td scope="row"><pre>                    defer:NO<span></span></pre></td></tr><tr><td scope="row"><pre>                    screen:[NSScreen mainScreen]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Establish the window attributes.<span></span></pre></td></tr><tr><td scope="row"><pre>            [myScreenWindow setReleasedWhenClosed:NO];<span></span></pre></td></tr><tr><td scope="row"><pre>            [myScreenWindow setDisplaysWhenScreenProfileChanges:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>            [myScreenWindow setDelegate:self];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Create the custom view for the window.<span></span></pre></td></tr><tr><td scope="row"><pre>            MyFullScreenView* theView = [[MyFullScreenView alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                                             initWithFrame:winRect];<span></span></pre></td></tr><tr><td scope="row"><pre>            [myScreenWindow setContentView:theView];<span></span></pre></td></tr><tr><td scope="row"><pre>            [theView setNeedsDisplay:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>            [theView release];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Make the screen window the current document window.<span></span></pre></td></tr><tr><td scope="row"><pre>        // Be sure to retain the previous window if you want to  use it again.<span></span></pre></td></tr><tr><td scope="row"><pre>        NSWindowController* winController = [[self windowControllers]<span></span></pre></td></tr><tr><td scope="row"><pre>                                                 objectAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>        [winController setWindow:myScreenWindow];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // The window has to be above the level of the shield window.<span></span></pre></td></tr><tr><td scope="row"><pre>        int32_t     shieldLevel = CGShieldingWindowLevel();<span></span></pre></td></tr><tr><td scope="row"><pre>        [myScreenWindow setLevel:shieldLevel];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Show the window.<span></span></pre></td></tr><tr><td scope="row"><pre>        [myScreenWindow makeKeyAndOrderFront:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>To exit full screen mode using Cocoa, simply release the captured display, resize your window so that it does not occupy the entire screen, and set its level back to <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/c/macro/NSNormalWindowLevel" target="_top">NSNormalWindowLevel</a></code>. For more information about the shield window, see <em><a href="../../../../GraphicsImaging/Reference/Quartz_Services_Ref/index.html#//apple_ref/doc/uid/TP30001070" target="_top">Quartz Display Services Reference</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW19" title="Disabling Screen Updates"></a><h3>Disabling Screen Updates</h3>
<p>You can disable and reenable all <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_64"></a><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_65"></a>screen flushes using the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_66"></a><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSDisableScreenUpdates" target="_top">NSDisableScreenUpdates</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_67"></a><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSEnableScreenUpdates" target="_top">NSEnableScreenUpdates</a></code> functions. (In Mac OS X v10.4 and later, you can also use the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_68"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/disableScreenUpdatesUntilFlush" target="_top">disableScreenUpdatesUntilFlush</a></code> method of <code>NSWindow</code>.) You can use this technique to synchronize flushes to both a parent and child window. As soon as you reenable screen updates, all windows are flushed simultaneously (or at least close to it). </p>
<p>To prevent the system from appearing frozen, the system may automatically reenable screen updates if your application leaves them disabled for a prolonged period of time. If you leave screen updates disabled for more than 1 second, the system automatically reenables them. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-CJBIGIGG" title="Using NSTimer for Animated Content"></a><h2>Using NSTimer for Animated Content</h2>
<p>By default, Cocoa sends a <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/drawRect:" target="_top">drawRect:</a></code> message to your views only when a user action causes something to change. If your view contains <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_69"></a>animated content, you probably want to update that content at more regular intervals. For both indeterminate-length and finite-length animations, you can do this using timers.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH207-SW20" title="Note"></a><p><strong>Note:</strong>&nbsp;For finite-length animations, you can also use an <code><a href="../../../Reference/ApplicationKit/Classes/NSAnimation_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAnimation" target="_top">NSAnimation</a></code> object to control the animation timing. For more information, see <span class="content_text"><a href="AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-CJBGBGDJ">“Using Cocoa Animation Objects.”</a></span> </p></div>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_70"></a><code><a href="../../../Reference/Foundation/Classes/NSTimer_Class/Reference/NSTimer.html#//apple_ref/occ/cl/NSTimer" target="_top">NSTimer</a></code> class provides a mechanism for generating periodic events in your application. When a preset time is reached, the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_71"></a>timer object sends a message to your application, giving you the chance to perform any desired actions. For animations, you would use a timer to tell your application that it is time to draw the next frame. </p>
<p>There are two steps involved with getting a timer to run. The first step is to create the <code>NSTimer</code> object itself and specify the object to notify, the message to send, the time interval for the notification, and whether the timer repeats. The second step is to install that timer object on the run loop of your thread. The methods <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_72"></a><code><a href="../../../Reference/Foundation/Classes/NSTimer_Class/Reference/NSTimer.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:" target="_top">scheduledTimerWithTimeInterval:invocation:repeats:</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_73"></a><code><a href="../../../Reference/Foundation/Classes/NSTimer_Class/Reference/NSTimer.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:" target="_top">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</a></code> perform both of these steps for you. Other methods of <code>NSTimer</code> create the timer but do not install it on the run loop. </p>
<p>For information and examples on how to create and use timers, see <em><a href="../../Timers/index.html#//apple_ref/doc/uid/10000061i" target="_top">Timer Programming Topics for Cocoa</a></em>.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-CJBGBGDJ" title="Using Cocoa Animation Objects"></a><h2>Using Cocoa Animation Objects</h2>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_74"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSAnimation_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAnimation" target="_top">NSAnimation</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_75"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSViewAnimation_Class/Reference/Reference.html#//apple_ref/occ/cl/NSViewAnimation" target="_top">NSViewAnimation</a></code> classes provide sophisticated behavior for animations that occur over a finite length of time. Mac OS X uses animation objects to implement transition animations for user interface elements. You can define custom <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_76"></a>animation objects to implement animations for your own code. Unlike <code>NSTimer</code>, animation notifications can occur at irregular intervals, allowing you to create animations that appear to speed up or slow down.</p><p>For information about how to use Cocoa animation objects, see <em><a href="../../AnimationGuide/index.html#//apple_ref/doc/uid/TP40003592" target="_top">Animation Programming Guide for Cocoa</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-CJBJDDEH" title="Optimizing Your Drawing Code"></a><h2>Optimizing Your Drawing Code</h2>
<p>The following sections provide some basic guidance for improving the overall performance of your drawing code. These are the things that you should definitely be doing in your code. For a more comprehensive list of <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_77"></a>drawing optimization techniques, see <em><a href="../../../../Performance/Conceptual/Drawing/index.html#//apple_ref/doc/uid/10000151i" target="_top">Drawing Performance Guidelines</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW21" title="Draw Minimally"></a><h3>Draw Minimally</h3>
<p>Even with modern graphics hardware, drawing is still an expensive operation. The best way to reduce the amount of time spent in your drawing code is to draw only what is needed in the first place. </p>
<p>During a view update, the <code>drawRect:</code> method receives a rectangle that specifies the portion of the view that needs to be updated. This rectangle is always limited to the portion of the view that is currently visible and in some cases may be even smaller. Your drawing code should pay attention to this rectangle and avoid drawing content outside of it. Because the rectangle passed to <code>drawRect:</code> might be a union of several smaller rectangles, an even better approach is to call the view’s <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_78"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/getRectsBeingDrawn:count:" target="_top">getRectsBeingDrawn:count:</a></code> method and constrain your drawing to the exact list of rectangles returned by that method. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW22" title="Avoid Forcing Synchronous Updates"></a><h3>Avoid Forcing Synchronous Updates</h3>
<p><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_79"></a>When <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_80"></a>invalidating portions of your <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_81"></a>views, you should avoid using the <code>display</code> family of methods to force an immediate update. These methods cause the system to send a <code>drawRect:</code> message to the affected view (and potentially other views in the hierarchy) immediately rather than wait until the next regular update cycle. If there are several areas to update, this may result in a lot of extra work for your drawing code. </p>
<p>Instead, you should use the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNeedsDisplay:" target="_top">setNeedsDisplay:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNeedsDisplayInRect:" target="_top">setNeedsDisplayInRect:</a></code> methods to mark areas as needing an update. When you call these methods, the system collects the rectangles you specify and coalesces them into a combined update region, which it then draws during the next update cycle. </p>
<p>If you are creating animated content, you should also be careful not to trigger visual updates more frequently than the screen refresh rate allows. Updating faster than the refresh rate results in your code drawing frames that are never seen by the user. In addition, updating faster than the refresh rate is not allowed in Mac OS X v10.4 and later. If you try to update the screen faster than the refresh rate, the window server may block the offending thread until the next update cycle. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW23" title="Reuse Your Objects"></a><h3>Reuse Your Objects</h3>
<p>If you have <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_82"></a>objects that you plan to use more than once, consider caching them for later use. Caching saves time by eliminating the need to recreate objects each time you want to draw them. Of course, caching requires more memory, so be judicious about what you cache. It is faster to recreate an object in memory than page it in from disk. </p>
<p>Many objects are <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_83"></a>cached automatically by Cocoa and do not need to be cached in your own code. For example, Cocoa caches <code>NSColor</code> objects representing commonly used colors as those colors are requested. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH207-SW24" title="Minimize State Changes"></a><h3>Minimize State Changes</h3>
<p>Every time you save the <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_84"></a><a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_85"></a>graphics state, you incur a small performance penalty. Whenever you have objects with the same rendering attributes, try to draw them all at the same time. If you save and restore the graphics state for each object, you may waste some CPU cycles. </p>
<p>With Cocoa, methods and functions that draw right away usually involve a change in graphics state. For example, when you call the <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/stroke" target="_top">stroke</a></code> method of <code>NSBezierPath</code>, the object automatically saves the graphics state and applies the options associated with that path. While you are building the path, however, the graphics state does not change. Thus, if you want to draw several shapes using the same graphics attributes, it is advantageous to fill a single <code>NSBezierPath</code> with all of the shapes and then draw them all as a group. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH207-SW25" title="Note"></a><p><strong>Note:</strong>&nbsp;There is a tradeoff between creating larger, more complex Bezier paths and using individual objects for each shape you want to draw. As <a name="//apple_ref/doc/uid/TP40003290-CH207-DontLinkElementID_86"></a>path complexity increases, so do the number of calculations required to determine fill characteristics and to perform hit detection—see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCFGAGF">“Reduce Path Complexity.”</a></span> When creating Bezier paths, you need to find an appropriate balance between path complexity and graphics state changes. </p></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Text/Text.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../QuartzOpenGL/QuartzOpenGL.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-01-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/AdvancedDrawing/AdvancedDrawing.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/AdvancedDrawing/AdvancedDrawing.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/AdvancedDrawing/AdvancedDrawing.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>