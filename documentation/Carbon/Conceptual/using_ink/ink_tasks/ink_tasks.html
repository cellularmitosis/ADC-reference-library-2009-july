<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Using Ink Services in Your Application: Ink Services Tasks</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Ink Services Tasks"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000844" title="Ink Services Tasks"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../EventsOtherInput-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000447" target="_top">Events &amp; Other Input</a> &gt; <a href="../ink_intro/ink_intro.html#//apple_ref/doc/uid/TP30000842-TPXREF101">Using Ink Services in Your Application</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ink_concepts/ink_concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ink_revhistory/ink_revhistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000844-TPXREF101" title="Ink Services Tasks"></a><h1>Ink Services Tasks</h1><p>This section shows how you can use the Ink Services API to accomplish the following tasks:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-TPXREF144">“Obtaining Parameters from Ink Text and Gesture Events,”</a></span> shows how your application can obtain the data associated with Ink input. </p></li><li class="li"><p><span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJDDEFJ">“Handling Phrase Termination,”</a></span> discusses how to override automatic phrase termination and request phrase termination at the appropriate time for your application.</p></li><li class="li"><p><span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJECEHA">“Supporting Text Editing With Ink Gestures,”</a></span> discusses the gestures you must handle and those you can let Ink Services handle for you.</p></li><li class="li"><p><span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJEABFD">“Implementing a Correction Model,”</a></span> shows how your application can access a list of alternate interpretations for Ink input and present those alternates in a contextual menu to your users.</p></li><li class="li"><p><span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJHCGDF">“Implementing Deferred Recognition,”</a></span> describes how to set the recognition state, collect tablet data, accumulate an Ink phrase, and request recognition at the appropriate time.</p></li></ul><a name="//apple_ref/doc/uid/TP30000844-TPXREF144" title="Obtaining Parameters from Ink Text and Gesture Events"></a><h2>Obtaining Parameters from Ink Text and Gesture Events</h2><p>If you want to perform any of the other tasks described in this chapter, you will need to obtain one or more event parameters from Ink-related Carbon events. This section shows you how to obtain the parameters associated with Ink text and gesture events. Before you read this section, you should be familiar with the events and event parameters discussed in <span class="content_text"><a href="../ink_concepts/ink_concepts.html#//apple_ref/doc/uid/TP30000843-TPXREF121">“Ink-Related Carbon Events.”</a></span></p><p>Ink Services generates Carbon events of class <code>kEventClassInk</code>. When Ink Services recognizes a phrase as text, it generates the event <code>kEventInkText</code>. You can extract the associated parameters—<code>kEventParamInkTextRef</code> and <code>kEventParamInkTextKeyboardShortcut</code>—by calling the Carbon Event Manager function <code><a href="../../../Reference/Carbon_Event_Manager_Ref/Reference/reference.html#//apple_ref/doc/c_ref/GetEventParameter" target="_top">GetEventParameter</a></code>, as shown in <span class="content_text">Listing 2-1</span>. Checking for the <code>kEventParamInkTextKeyboardShortcut</code> parameter provides an easy way for you to determine if the <code>InkTextRef</code> is likely to be a keyboard equivalent for a command instead of text. If this parameter is <code>false</code>, the you can use the function <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkTextCreateCFString" target="_top">InkTextCreateCFString</a></code> to obtain the recognized text associated with the Ink text object (<code>InkTextRef</code>). When you pass <code>0</code> to this function, you obtain the most likely interpretation.</p><a name="//apple_ref/doc/uid/TP30000844-BAJHBHEA" title="Listing 2-1Extracting parameters for the Ink text event"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Extracting parameters for the Ink text event</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>InkTextRef myInkTextRef;<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean  myKeyboardShorcut;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>status = GetEventParameter (myEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                kEventParamInkTextRef,<span></span></pre></td></tr><tr><td scope="row"><pre>                typePtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizeof (Ptr),<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;myInkTextRef);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>status = GetEventParameter (myEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                kEventParamInkTextKeyboardShortcut,<span></span></pre></td></tr><tr><td scope="row"><pre>                typeBoolean,<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizeof (Boolean),<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;myKeyboardShortcut);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (myKeyboardShortcut == false)<span></span></pre></td></tr><tr><td scope="row"><pre>        return (eventNotHandledErr);<span></span></pre></td></tr><tr><td scope="row"><pre>InkTextCreateCFString (myInkTextRef, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>// Your code to insert the text into the application document.<span></span></pre></td></tr></table></div><p>When Ink Services recognizes an Ink phrase as a gesture, Ink Services generates the event <code>kEventInkGesture</code>. You can extract the associated parameters—<code>kEventParamInkGestureKind</code>, <code>kEventParamInkGestureBounds</code>, and <code>kEventParamInkGestureHotspot</code>—using the code shown in <span class="content_text">Listing 2-2</span>.</p><a name="//apple_ref/doc/uid/TP30000844-BAJHEIDE" title="Listing 2-2Extracting parameters for the Ink gesture event"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Extracting parameters for the Ink gesture event</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 myGestureKind;<span></span></pre></td></tr><tr><td scope="row"><pre>HIRect myGestureBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>HIPoint myGestureHotspot;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>status = GetEventParameter (myEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                kEventParamInkGestureKind,<span></span></pre></td></tr><tr><td scope="row"><pre>                typeUInt32,<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizeof (UInt32),<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;myGestureKind);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>status = GetEventParameter (myEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                kEventParamInkGestureBounds,<span></span></pre></td></tr><tr><td scope="row"><pre>                typeHIRect,<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizeof (HIRect),<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;myGestureBounds);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>status = GetEventParameter (myEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                kEventParamInkGestureHotspot,<span></span></pre></td></tr><tr><td scope="row"><pre>                typeHIPoint,<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizeof (HIPoint),<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;myGestureHotspot);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000844-BAJDDEFJ" title="Handling Phrase Termination"></a><h2>Handling Phrase Termination</h2><p>The default behavior is for Ink Services to terminate a phrase when one of the following events occur: </p><ul class="ul"><li class="li"><p>The user removes the stylus from the proximity of the tablet</p></li><li class="li"><p>A specified period of time elapses in which the stylus is not pressed to the tablet (The user can control the period of time in the Ink preferences pane.)</p></li><li class="li"><p>The user writes sufficiently far away from the previous Ink—either horizontally, or on a new line</p></li></ul><p>You can use the function <code>InkSetPhraseTerminationMode</code> if your application does not want the default behavior or wants complete control over when Ink phrases are terminated. If you turn off automatic phrase termination, you must make sure you manage phrase termination appropriately for your application.</p><p>If you want to control phrase termination in your application, you must perform the following tasks:</p><ul class="ul"><li class="li"><p>Call the function <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkSetPhraseTerminationMode" target="_top">InkSetPhraseTerminationMode</a></code> to turn off automatic phrase termination. You can do so using the following line of code:</p><p><code>InkSetPhraseTerminationMode (kInkSourceUser, kInkTerminationNone);</code></p><p>The first parameter to this function specifies the source of the Ink data stream. This example shows how to control termination of an Ink phrase that originates from direct user input (<code>kInkSourceUser)</code> rather than from the application (<code>kInkSourceApplication</code>). </p></li><li class="li"><p>Write code that monitors Ink input and checks for the termination conditions you define. </p><p>The termination conditions you define determine how you should best carry out this step. For example, if you provide users with a “terminate phrase” button in the user interface, then your application should check for the command issued by the button press.</p><p>In such a case or if your phrase termination criteria depends on such data as where the user is writing, the proximity of the pen to the tablet, whether a modifier key is pressed, or the amount of pressure applied to the pen, you can install a Carbon event handler for the event <code>kEventInkPoint</code>, then monitor the location and other relevant parameters returned in this event.</p><p>You may find it useful to call the function <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkIsPhraseInProgress" target="_top">InkIsPhraseInProgress</a></code>. The function returns <code>true</code> when there is an Ink phrase that can be terminated. </p></li><li class="li"><p>When your application determines your termination conditions have been met, call the function <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkTerminateCurrentPhrase" target="_top">InkTerminateCurrentPhrase</a></code>. </p></li></ul><p><span class="content_text">Listing 2-3</span> shows an example of a handler for a hypothetical application that provides users with a “terminate phrase” button. The application must first install the handler (which, in this case, handles the event <code>kEventInkPoint</code>) and call the function <code>InkSetPhraseTermination</code> with the parameter <code>kInkTerminationNone</code>. A detailed explanation for each numbered line of code appears following the listing. </p><a name="//apple_ref/doc/uid/TP30000844-BAJDBCAJ" title="Listing 2-3Code that handles phrase termination"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Code that handles phrase termination</p><div class="codesample"><table><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GetEventParameter (myInkPointEventRef, kEventParamEventRef,<span></span></pre></td></tr><tr><td scope="row"><pre>                     typeEventRef, NULL, sizeof (EventRef), NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                     &amp;myMouseEventRef);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (GetEventKind (myMouseEventRef) == kEventMouseDown)<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (MyTestForButtonHit (myMouseEventRef) == true)<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (InkIsPhraseInProgress() == true)<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                InkTerminateCurrentPhrase(kInkSourceUser);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                return (noErr);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return (eventNotHandledErr);<span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Extracts the mouse event reference from the Ink point event.</p></li><li class="li"><p>Checks to see if the event is a mouse down event.</p></li><li class="li"><p>Checks to see if the mouse down event is in the termination button provided by the application. The <code>MyTestForButtonHit</code> function is an application-defined function that determines if the mouse event is within the bounds of the termination button.</p></li><li class="li"><p>Checks to see if Ink Services has an Ink phrase in progress; otherwise there is nothing to terminate. Note that the function <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkIsPhraseInProgress" target="_top">InkIsPhraseInProgress</a></code> should be called only to check whether a phrase is in progress for an Ink data stream that originate from the user, and not for one that originates from your application. See <em>Ink Services Reference</em> for more information.</p></li><li class="li"><p>Terminates the phrase and returns <code>noErr</code> to indicate the event has been handled. You must pass the constant <code>kInkSourceUser</code> to specify that the function <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkTerminateCurrentPhrase" target="_top">InkTerminateCurrentPhrase</a></code> should be applied to the Ink data stream that originates from direct user input.</p></li><li class="li"><p>Returns <code>eventNotHandledErr</code> if any of the previous <code>if</code> statements are false. If there is an Ink phrase in progress, it is not terminated.</p></li></ol><a name="//apple_ref/doc/uid/TP30000844-BAJECEHA" title="Supporting Text Editing With Ink Gestures"></a><h2>Supporting Text Editing With Ink Gestures</h2><p>Before you begin to write any code that supports text editing using Ink gestures, you should be thoroughly familiar with the terms “targeted gesture,” “untargeted gesture,” and “tentative gesture,” because you handle each of these gestures differently. These terms are described in <span class="content_text"><a href="../ink_concepts/ink_concepts.html#//apple_ref/doc/uid/TP30000843-TPXREF146">“Gestures.”</a></span> You should also be familiar with the Ink-gesture event and event parameters described in <span class="content_text"><a href="../ink_concepts/ink_concepts.html#//apple_ref/doc/uid/TP30000843-BAJBHIAE">“Ink Gesture Events,”</a></span> as gesture information is available to your application through Carbon events.</p><p>To support text editing with Ink gestures, your application must write and install an event handler for the Carbon event kind <code>kEventInkGesture</code>. The parameters associated with an Ink gesture event are:</p><ul class="ul"><li class="li"><p><code>kEventParamInkGestureKind</code>—The gesture kind can be any of the constants listed in <span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJIDFCE">Table 2-1</a></span>. These constants are defined as the <code>InkGestureKind</code> enumeration in the Ink Services API. The Horizontal Space and Return gestures are each represented by two constants because the user can write these gestures facing the opposite direction of what’s shown in the Ink pane of System Preferences. The left and right distinction for the Horizontal Space gesture indicates the side on which the long, horizontal tail is drawn. The left and right distinction for the Return gesture indicates the direction the small angle-bracket points.</p></li><li class="li"><p><code>kEventParamInkGestureBounds</code>—The gesture bounds is the rectangle to which some gestures should apply. You can use this information when your application handles targeted gestures.</p></li><li class="li"><p><code>kEventParamInkGestureHotspot</code>—The gesture hot spot is the area to which some gestures should apply. Only targeted gestures can have a hot spot. You can use this information when your application handles targeted gestures.</p></li></ul><a name="//apple_ref/doc/uid/TP30000844-BAJIDFCE" title="Table 2-1Gesture constants"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Gesture constants</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Gesture</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Gesture kind constant</p></th></tr><tr><td  scope="row"><p>Undo</p></td><td ><p><code>kInkGestureUndo</code></p></td></tr><tr><td  scope="row"><p>Clear</p></td><td ><p><code>kInkGestureClear</code></p></td></tr><tr><td  scope="row"><p>Select All</p></td><td ><p><code>kInkGestureSelectAll</code></p></td></tr><tr><td  scope="row"><p>Escape</p></td><td ><p><code>kInkGestureEscape</code></p></td></tr><tr><td  scope="row"><p>Cut</p></td><td ><p><code>kInkGestureCut</code></p></td></tr><tr><td  scope="row"><p>Copy</p></td><td ><p><code>kInkGestureCopy</code></p></td></tr><tr><td  scope="row"><p>Paste</p></td><td ><p><code>kInkGesturePaste</code></p></td></tr><tr><td  scope="row"><p>Horizontal Space </p></td><td ><p><code>kInkGestureLeftSpace</code></p></td></tr><tr><td  scope="row"><p>Horizontal Space </p></td><td ><p><code>kInkGestureRightSpace</code></p></td></tr><tr><td  scope="row"><p>Tab</p></td><td ><p><code>kInkGestureTab</code></p></td></tr><tr><td  scope="row"><p>Return</p></td><td ><p><code>kInkGestureLeftReturn</code></p></td></tr><tr><td  scope="row"><p>Return</p></td><td ><p><code>kInkGestureRightReturn</code></p></td></tr><tr><td  scope="row"><p>Delete </p></td><td ><p><code>kInkGestureDelete</code></p></td></tr><tr><td  scope="row"><p>Join</p></td><td ><p><code>kInkGestureJoin</code></p></td></tr></table></div><p>After your event handler obtains the gesture kind from the event parameter <code>kEventParamInkGestureKind</code> (see <span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJHEIDE">Listing 2-2</a></span>), it should handle gestures as follows:</p><ul class="ul"><li class="li"><p>For gestures that are always untargeted (Undo, Select All, Escape, and Delete), return <code>eventNotHandledErr</code>. Because these gestures are always untargeted, you can let Ink Services handle them for you. Ink Services converts the unhandled gesture to the command event (<code>HICommand</code>) associated with the editing action specified by the gesture. If a command event isn’t defined for the gesture, as in the case of the Escape and Delete, or if the command goes unhandled, then Ink Services posts the keyboard equivalent for the gesture. Untargeted gestures apply to the current selection or insertion point.</p><p>See <span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJEEIAD">“Handling Untargeted Gestures”</a></span> for more details.</p></li><li class="li"><p>For the Join gesture (which is a tentative gesture), check to see if the top-left and top-right points of the bounding box defined by the gesture are sufficiently close to the end and beginning of two words (or other editable objects), with a space between the words. If so, then your application should elide the space between the words and return <code>noErr</code>. See <span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJDIIDJ">“Handling Targeted Gestures”</a></span> for more details.</p><p>If not, then return <code>eventNotHandledErr</code> to signal to Ink Services to process the raw Ink as text and post the recognition results, which should be the letter “v.”</p><p>You must make sure that you return <code>eventNotHandledErr</code> when you determine the Ink is not a Join gesture, otherwise the user will never be able to enter the letter “v” as a standalone character.</p></li><li class="li"><p>For all other gestures, check to see if the gesture’s hot spot (or bounding box, as appropriate) is over a suitable target, such as a word, image, or other object. If so, then apply the gesture to that target. Note that any non-empty selection range is a suitable target, and should be treated as a single editable object for applying targeted gestures. (So if a gesture hot spot is anywhere in the selection, the gesture should be applied to the entire selection.) See <span class="content_text"><a href="ink_tasks.html#//apple_ref/doc/uid/TP30000844-BAJDIIDJ">“Handling Targeted Gestures”</a></span> for more details.</p><p>If the gesture is not over a suitable target, then it should be applied to the current selection, if it is non-empty, else it should be applied to the insertion point, like an untargeted gesture. </p><p>If the gesture is being applied to the selection or the insertion point, whether due to a hot spot in the selection or one that is not over any suitable target, your application may choose to return <code>eventNotHandledErr</code> to let Ink Services apply the editing action automatically.</p></li></ul><a name="//apple_ref/doc/uid/TP30000844-BAJDIIDJ" title="Handling Targeted Gestures"></a><h3>Handling Targeted Gestures</h3><p>You can use gesture and text relationships to determine the extent of the text modified by the gesture. Most targeted gestures have a defined hot spot that your application can use to determine the area to apply the editing action. </p><p><span class="content_text">Table 2-2</span> lists targeted gestures, whether the gesture has a hot spot, and the editing actions you should perform when you handle the gesture.</p><a name="//apple_ref/doc/uid/TP30000844-BAJBJHHA" title="Table 2-2Targeted gestures, hot spots, and editing actions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-2&nbsp;&nbsp;</strong>Targeted gestures, hot spots, and editing actions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Has a hot spot</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Perform the following action ...</p></th></tr><tr><td  scope="row"><p><code>kInkGestureClear</code></p></td><td ><p>No, use the gesture bounds</p></td><td ><p>delete the text if the gesture bounds overlaps by 50% or more.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureCut</code></p></td><td ><p>Yes, the starting  point of the gesture</p></td><td ><p>cut the text (a single word in Roman languages) the hot spot overlaps. </p></td></tr><tr><td  scope="row"><p><code>kInkGestureCopy</code></p></td><td ><p>Yes, the starting  point of the gesture</p></td><td ><p>copy the text (a single word in Roman languages) the hot spot overlaps.</p></td></tr><tr><td  scope="row"><p><code>kInkGesturePaste</code></p></td><td ><p>Yes, the starting  point of the gesture</p></td><td ><p>paste the Clipboard contents into the location specified by the hot spot. Paste over a word if the hot spot is on a word. </p></td></tr><tr><td  scope="row"><p><code>kInkGestureLeftSpace</code><code>kInkGestureRightSpace</code></p></td><td ><p>Yes, the topmost point of the gesture</p></td><td ><p>insert a single space character into the location specified by the hot spot.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureTab</code></p></td><td ><p>Yes, the starting  point of the gesture</p></td><td ><p>insert a single tab character into the location specified by the hot spot. </p></td></tr><tr><td  scope="row"><p><code>kInkGestureLeftReturn</code></p></td><td ><p>Yes, the leftmost point of the gesture</p></td><td ><p>insert a return (new line) character into the location specified by the hot spot. </p></td></tr><tr><td  scope="row"><p><code>kInkGestureRightReturn</code></p></td><td ><p>Yes, the rightmost point of the gesture</p></td><td ><p>insert a return (new line) character into the location specified by the hot spot. </p></td></tr><tr><td  scope="row"><p><code>kInkGestureJoin</code></p></td><td ><p>No, you must extract two points from the gesture bounds</p></td><td ><p>delete the space between the words specified by the top-left and top-right points of gesture bounds.</p></td></tr></table></div><p><span class="content_text">Figure 2-1</span> shows gesture bounds for four editing gestures—Cut, Horizontal Space, Clear, and Join. The Cut and Horizontal Space gestures have a hot spot but the Clear gesture does not. Rather, the bounds of the Clear gesture define its targeting area. The Join gesture doesn’t have a hot spot per se; instead it has two points that specify the two words that should be joined. These two points are contained in the gesture bounds, and your application must extract the points from the bounds.</p><br/><div><a name="//apple_ref/doc/uid/TP30000844-BAJHCCJB" title="Figure 2-1Gesture bounds and hot spots"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Gesture bounds and hot spots</p><img src = "../art/gesture_bounds.gif" alt = "Gesture bounds and hot spots" width="367" height="176"></div><br/><p>To handle the Clear gesture, which does not have a hot spot, your application should apply the editing action to all of the text the gesture overlaps (to a sufficient degree—say, more than 50% of the onscreen area of each word—on a word-by-word basis). For example, the Clear gesture in <span class="content_text">Figure 2-2</span> is written over the words “or insertion point” so your application should delete those words. To make that determination you would first obtain the gesture bounds from the event <code>kInkGestureEvent</code>, then determine the words the gesture is written over, and delete those words. </p><br/><div><a name="//apple_ref/doc/uid/TP30000844-BAJFBEGD" title="Figure 2-2The Clear gesture"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>The Clear gesture</p><img src = "../art/targeted_clear.gif" alt = "The Clear gesture" width="337" height="180"></div><br/><p>For targeted gestures that have a hot spot, only the hot spot is relevant to the editing action your application takes; the gesture bounds aren’t. For example, to handle the Horizontal Space gesture your application must obtain the hot spot from the event <code>kInkGestureEvent</code>.The Horizontal Space gesture in <span class="content_text">Figure 2-3</span> is positioned between the letters “r” and “g.” To process this gesture, your application would determine the characters on either side of the hot spot, then insert a space in that position.</p><br/><div><a name="//apple_ref/doc/uid/TP30000844-BAJIAJBI" title="Figure 2-3The Horizontal Space gesture"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>The Horizontal Space gesture</p><img src = "../art/targeted_space.gif" alt = "The Horizontal Space gesture" width="336" height="180"></div><br/><p>If the gesture hot spot is drawn outside your application’s windows or in a location where the gesture would not apply, the gesture should be treated as an untargeted gesture. That is, you should either return <code>kEventNotHandledErr</code> and let Ink Services handle the gesture for you, or you should apply the editing action to the current text selection or insertion point (if there is no selection).</p><a name="//apple_ref/doc/uid/TP30000844-BAJEEIAD" title="Handling Untargeted Gestures"></a><h3>Handling Untargeted Gestures</h3><p>Your application does not need to handle untargeted gestures; it can simply return <code>kEventNotHandledErr</code> and let Ink Services handle the gesture for you. If for some reason you decide to handle untargeted gestures, you should perform the actions listed in <span class="content_text">Table 2-3</span>. Note that the editing action for an untargeted gesture can depend on whether or not there is a selection. </p><a name="//apple_ref/doc/uid/TP30000844-TPXREF143" title="Table 2-3Actions specified by untargeted Ink gestures"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-3&nbsp;&nbsp;</strong>Actions specified by untargeted Ink gestures</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>If there is a selection, specifies to ... </p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>If there is no selection, specifies to ... </p></th></tr><tr><td  scope="row"><p><code>kInkGestureUndo</code></p></td><td ><p>undo the last action.</p></td><td ><p>undo the last action.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureClear</code></p></td><td ><p>clear the current selection.</p></td><td ><p>do nothing.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureSelectAll</code></p></td><td ><p>select all items in the window that has user focus.</p></td><td ><p>select all items in the window that has user focus.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureEscape</code></p></td><td ><p>act as if the Escape key is pressed.</p></td><td ><p>act as if the Escape key is pressed. </p></td></tr><tr><td  scope="row"><p><code>kInkGestureCut</code></p></td><td ><p>cut the current selection.</p></td><td ><p>do nothing.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureCopy</code></p></td><td ><p>copy the current selection.</p></td><td ><p>do nothing.</p></td></tr><tr><td  scope="row"><p><code>kInkGesturePaste</code></p></td><td ><p>paste the Clipboard contents over the current selection.</p></td><td ><p>paste the Clipboard contents into the insertion point.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureLeftSpace</code><code>kInkGestureRightSpace</code></p></td><td ><p>replace the current selection with a single space character. </p></td><td ><p>insert a single space character at the insertion point.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureTab</code></p></td><td ><p>replace the current selection with a single tab character.</p></td><td ><p>insert a single tab character.</p></td></tr><tr><td  scope="row"><p><code>kInkGestureLeftReturn</code><code>kInkGestureRightReturn</code></p></td><td ><p>replace the current selection with a return (new line) character. </p></td><td ><p>insert a return (new line) character. </p></td></tr><tr><td  scope="row"><p><code>kInkGestureDelete</code></p></td><td ><p>delete the current selection. </p></td><td ><p>delete the item immediately preceding the insertion point.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000844-BAJEABFD" title="Implementing a Correction Model"></a><h2>Implementing a Correction Model</h2><p>Ink Services communicates events through the Carbon Event Manager. Once Ink Services interprets an Ink phrase, it sends your application the Carbon event kind <code>kEventInkText</code> whose associated parameter is a reference to an opaque Ink text object (<code>InkTextRef</code>). The Ink text object contains the original Ink entered by the user and a list of interpretations for the Ink in ranked order. Ink Services creates a list of up to five possible interpretations. The most likely interpretation is the first item in the list, with less likely interpretations appearing in rank order after this item. (See <span class="content_text"><a href="../ink_concepts/ink_concepts.html#//apple_ref/doc/uid/TP30000843-TPXREF143">“Ink Window”</a></span> for details on how Ink orders the interpretations.)</p><p>Your application can implement an easy-to-use correction model by performing the following tasks:</p><ul class="ul"><li class="li"><p>Create a contextual menu.</p><p>Although the menu doesn’t have to be a contextual one, alternate interpretations are typically presented to the user in this way. See <span class="content_text"><a href="../ink_concepts/ink_concepts.html#//apple_ref/doc/uid/TP30000843-TPXREF143">“Ink Window”</a></span> for an example of what a contextual menu looks like when used for Ink.</p><p>You can create a menu any way you like. For example, you can: </p><ul class="nested"><li class="nested li"><p>Create the menu in Interface Builder and then unarchive the menu using the Interface Builder Services API. For more information, see <em>Unarchiving Interface Objects With Interface Builder Services</em>.</p></li><li class="nested li"><p>Use the Menu Manager API. For more information, see <em>Menu Manger Reference</em>.</p></li></ul><p>You can obtain either document from the developer documentation website, accessed through:</p><p><span class="content_text"><a href="http://developer.apple.com/" target="_top">http://developer.apple.com/</a></span></p></li><li class="li"><p>Insert the list of interpretations into the menu. </p><p>You can call the Ink Services function <code><!--a-->InkTextInsertAlternatesInMenu,<!--/a--></code> supplying the <code>InkTextRef</code> and a valid menu reference as parameters, as shown in the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>alternateItemsCount = InkTextInsertAlternatesInMenu (<span></span></pre></td></tr><tr><td scope="row"><pre>                myInkRef, // obtained through your Carbon event handler<span></span></pre></td></tr><tr><td scope="row"><pre>                myAlternatesMenu, // a valid menu reference<span></span></pre></td></tr><tr><td scope="row"><pre>                0); // location in menu to insert list<span></span></pre></td></tr></table></div></li><li class="li"><p>Show the contextual menu to the user and obtain the user’s selection, if any.</p><p>Your application should display the menu by calling the Menu Manager function <code><a href="../../../Reference/Menu_Manager/Reference/reference.html#//apple_ref/doc/c_ref/ContextualMenuSelect" target="_top">ContextualMenuSelect</a></code> (or other appropriate function, such as <code><a href="../../../Reference/Menu_Manager/Reference/reference.html#//apple_ref/doc/c_ref/PopUpMenuSelect" target="_top">PopUpMenuSelect</a></code>). </p><p>You can get the user’s selection by checking the return value of <code>outUserSelectionType</code>, as shown in the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>status = ContextualMenuSelect (myAlternatesMenu,<span></span></pre></td></tr><tr><td scope="row"><pre>                myMouseLocation, // the location to display the menu<span></span></pre></td></tr><tr><td scope="row"><pre>                false, // reserved for future use<span></span></pre></td></tr><tr><td scope="row"><pre>                kCMHelpItemRemoveHelp, // don’t provide a help item<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL. // a help string, which is not relevant here<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL, // no need for system to examine the selection<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;selectionType, //on output, indicates selection type<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;menuID, // on output, the menu ID of chosen item<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;menuItemIndex); // on output, menu item of chosen item<span></span></pre></td></tr></table></div></li><li class="li"><p>If the user chooses an item, you should obtain the string associated with the menu item and then call your function to replace the word in the document with the string returned by this function.</p><p>You can obtain the string associated with the user’s choice using one of the following two methods:</p><ul class="nested"><li class="nested li"><p>Call the Ink Services function <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkTextCreateCFString" target="_top">InkTextCreateCFString</a></code>, supplying <code>0</code> as the <code>iIndex</code> parameters.</p><p>This will always return the current top-choice interpretation, which will have been automatically altered by the user's selection. Note, however, that if the user selects the original first interpretation, the text may not have changed. Also, if you have placed other, non-Ink items in the menu, the user may have selected one of those instead of having made a selection from amongst the Ink alternates. So if you populate the menu with items unrelated to Ink, you may need to use the second method.</p></li><li class="nested li"><p>Call the Menu Manager function <code>CopyMenuItemTextAsCFString</code> supplying the values that were returned in the parameters <code>outMenuID</code> and <code>outMenuItem</code> when you called the Menu Manager function <code><a href="../../../Reference/Menu_Manager/Reference/reference.html#//apple_ref/doc/c_ref/ContextualMenuSelect" target="_top">ContextualMenuSelect</a></code> to display the menu.</p><p>This method will always return the user's selection, whether it is from amongst the Ink alternates or not, though the text interpretation still may or may not have changed, and it is your application's responsibility to determine the proper outcome of the user's selection.</p></li></ul></li><li class="li"><p>The next time you need to show the menu, you must rebuild the menu before you insert the list of interpretations. </p><p>Delete items you no longer want in the menu and then reinsert the appropriate menu items, making sure that you map the Ink Services alternates correctly to your menu. Text alternates supplied by Ink Services can be identified by the command ID <code>'inka'</code>. You can find out how many text alternates items are in the menu using the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>alternateItemsCount = CountMenuItemsWithCommandID (myAlternatesMenu,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    'inka');<span></span></pre></td></tr></table></div><p>If there are Ink Services items in the menu, you must delete the previous interpretations before you can add the current interpretations. If the Ink Services menu item had been placed at the beginning of the menu, you can do so with the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>if (alternateItemsCount > 0)<span></span></pre></td></tr><tr><td scope="row"><pre>        DeleteMenuItems (myAlternatesMenu, 1, alternateItemsCount);<span></span></pre></td></tr></table></div></li></ul><p>You would also have to remove the single separator item identified by <code>'inks'</code> and the Ink data item identified by <code>'inkd'</code>. Or you could simply dispose of the old <code>menuRef</code> and create and populate a new one.</p><p>When a user selects an item from the list of alternates, Ink Services reorders the internal alternates list within the source Ink text object (<code>InkTextRef</code>). Thus the user’s choice persists in the system data structures without requiring your application to call any additional functions. If it is important for your application to maintain the original order of alternates, then you must use your own internal data structures to keep track of the original list. </p><a name="//apple_ref/doc/uid/TP30000844-BAJHCGDF" title="Implementing Deferred Recognition"></a><h2>Implementing Deferred Recognition</h2><p><strong>Deferred recognition</strong> is the ability to convert pen strokes to text at some time other than when the strokes are first written by the user. If you want to implement deferred recognition, your application must be responsible for collecting Ink input and deciding when recognition occurs. Your application can draw its own Ink by either disabling Ink Services or by requesting that Ink Services doesn’t process events it would otherwise have handled. Your application can then access all relevant data directly from standard mouse events.</p><p>To implement deferred recognition, your application must perform the following tasks:</p><ul class="ul"><li class="li"><p>Inform Ink Services not to handle Ink events. </p><p>You can accomplish with the following call:</p><p><code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkSetApplicationRecognitionMode" target="_top">InkSetApplicationRecognitionMode (kInkWriteNowhereInApp);</a></code></p></li><li class="li"><p>Install a Carbon event handler to gather tablet data. </p><p>Your handler should handle <code>mouseDown</code>, <code>mouseUp</code>, and <code>mouseDragged</code> events. You should obtain the mouse location, tablet data, and key modifiers from each mouse event your application receives. </p><p>You obtain the mouse location by extracting the event parameter <code>kEventParamMouseLocation</code>. You get the tablet data record by extracting the event parameter <code>kEventParamTabletPointRec</code>. You obtain the key modifiers (if any) in use by extracting the event parameter <code>kEventParamKeyModifiers</code>. The following code shows how to obtain the relevant data from the event parameters:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>HIPoint location;<span></span></pre></td></tr><tr><td scope="row"><pre>TabletPointRec tabletPt;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 modifiers;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Get the full-resolution, floating point mouse location<span></span></pre></td></tr><tr><td scope="row"><pre>status = GetEventParameter (myInEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kEventParamMouseLocation,<span></span></pre></td></tr><tr><td scope="row"><pre>                    typeHIPoint,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL, // On output, the actual type<span></span></pre></td></tr><tr><td scope="row"><pre>                    sizeof (location),<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL, // On output, the actual size<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;location);<span></span></pre></td></tr><tr><td scope="row"><pre>require_noerr (status, TabletEvent_err); /* macro to handle error */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Get the tablet data record<span></span></pre></td></tr><tr><td scope="row"><pre>status = GetEventParameter (myInEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kEventParamTabletPointRec,<span></span></pre></td></tr><tr><td scope="row"><pre>                    typeTabletPointRec,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    sizeof (TabletPointRec),<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    (void*) &amp;tabletPt);<span></span></pre></td></tr><tr><td scope="row"><pre>require_noerr ( status, TabletEvent_err);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Get any keyboard modifiers in use<span></span></pre></td></tr><tr><td scope="row"><pre>status = GetEventParameter (myInEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kEventParamKeyModifiers,<span></span></pre></td></tr><tr><td scope="row"><pre>                    typeUInt32,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    sizeof (modifiers),<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;modifiers);<span></span></pre></td></tr><tr><td scope="row"><pre>require_noerr (status, TabletEvent_err);<span></span></pre></td></tr></table></div><p>If it is useful for your application, you can also obtain tablet proximity data. Proximity data defines events which occur when the stylus is near, but not touching, the tablet.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000844-SW1" title="Note"></a><p><strong>Note:</strong>&nbsp;You could gather the same data by handling the event <code>kEventInkPoint</code>, and while handling mouse events directly may incur slightly less overhead than handling Ink point events, gathering your own Ink in this fashion requires your application to manage all of the pen-vs.-mouse issues (has the pen moved far enough, soon enough, is the pen placed in an instant mouser, and so forth).</p>Your application would also have to manage event coalescing and phrase termination itself. Managing these requires additional work for you and is likely to produce a different user experience in your application. Thus we recommend against managing real-time user handwriting input using mouse events, and only show this example to indicate how raw data can be handled for applications where that is necessary and appropriate.</p></div></li><li class="li"><p>Store tablet data. </p><p>As your application collects tablet-generated data, it must store the data (<code>HIPoint</code>, <code>TabletPointRec</code>, and any key modifiers) in any way that makes sense for your application. However, it is advisable not to use an array. The number of points that can be generated by a single stroke is variable, and may be quite large. Using an array would require you to allocate large arrays and to check for an array-bounds overrun.</p></li><li class="li"><p> Add the stroke to the current Ink phrase. </p><p>When a stroke has been completed (as indicated by the first mouse-up event after a stroke has been initiated), you can add it to the current Ink phrase by building an array of <code>InkPoint</code> data structures, and filling the structures with the collected data. (The <code>InkPoint</code> data structure holds mouse location (<code>HIPoint</code>), tablet data (<code>TabletPointRec</code>), and key modifier information (<code>UInt32</code>).) The data must be in the chronological order in which it was generated. </p><p>Then, you must call the function <code>InkAddStrokeToCurrentPhrase</code> to add the stroke to the current Ink phrase. When you call the function, you must pass the number of structures in the array, as well as the array of <code>InkPoint</code> structures, as shown in the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>UInt32 myPointCount;<span></span></pre></td></tr><tr><td scope="row"><pre>InkPoint * myInkPointArray;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>InkAddStrokeToCurrentPhrase (myPointCount, myInkPointArray);<span></span></pre></td></tr></table></div><p>It’s best to dynamically assemble and destroy the <code>InkPoint</code> array when you need to call this function.</p></li><li class="li"><p>When your application determines that a phrase is complete and ready to be recognized, it can call the function <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkTerminateCurrentPhrase" target="_top">InkTerminateCurrentPhrase</a></code> with the <code>iSource</code> parameter set to <code>kInkSourceApplication</code>.</p><p>Calling this function terminates the phrase and triggers the Ink recognizer. </p></li><li class="li"><p>Handle the Ink event (<code>kEventInkText</code> or <code>kEventInkGesture</code>) that is generated by the recognizer when recognition is complete for the phrase. </p></li></ul><p>A similar approach may be used to import larger quantities of data, gathered in an offline mode, potentially using a proprietary data format, such as for a digital pen that stores ink written on paper pads. Converting such data into <code>InkPoint</code> arrays and invoking the functions <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkAddStrokeToCurrentPhrase" target="_top">InkAddStrokeToCurrentPhrase</a></code> and <code><a href="../../../Reference/ink_services_ref/Reference/reference.html#//apple_ref/doc/c_ref/InkTerminateCurrentPhrase" target="_top">InkTerminateCurrentPhrase</a></code> would allow such devices to use the recognition services provided by Ink Services.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ink_concepts/ink_concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ink_revhistory/ink_revhistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2003-07-24<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/using_ink/ink_tasks/ink_tasks.html%3Fid%3DTP40000959-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/using_ink/ink_tasks/ink_tasks.html%3Fid%3DTP40000959-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/using_ink/ink_tasks/ink_tasks.html%3Fid%3DTP40000959-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>