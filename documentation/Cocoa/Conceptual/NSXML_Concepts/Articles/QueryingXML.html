<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Tree-Based XML Programming Guide for Cocoa: Querying an XML Document</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Querying an XML Document"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001258" title="Querying an XML Document"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DataManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000445" target="_top">Data Management</a> &gt; <a href="../index.html" target="_top">Tree-Based XML Programming Guide for Cocoa</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="TraversingTree.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ModifyingXML.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40001258-SW1" title="Querying an XML Document"></a><hr /><H1><a name="//apple_ref/doc/uid/TP40001258-CJBFCGEG" title="Querying an XML Document"></a>Querying an XML Document</H1><a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_249"></a><a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_250"></a><p>One way to find items of interest in an XML document is to use the NSXML methods that traverse the nodes in a document tree (see <span class="content_text"><a href="TraversingTree.html#//apple_ref/doc/uid/TP40001257-BAJJGHAI">“Traversing an XML Tree”</a></span>). However, this can be a time-consuming approach, especially with large documents. A more efficient strategy is to perform XPath and XQuery queries on the document object or any of the nodes in the document. This article describes the basic steps for executing XQuery and XPath queries and suggests how you can integrate such queries with an application’s user interface.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="QueryingXML.html#//apple_ref/doc/uid/TP40001258-97181-CJBGGAIF">XPath and XQuery Basics</a>
				
			<br/>
			
        
			
			
				<a href="QueryingXML.html#//apple_ref/doc/uid/TP40001258-96877-CJBIBBGA">Integrating XQuery Into the User Interface</a>
				
			<br/>
			
        
			
			
				<a href="QueryingXML.html#//apple_ref/doc/uid/TP40001258-150788-CJBHCHAA">Resources For Learning XQuery</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001258-97181" title="XPath and XQuery Basics"></a><a name="//apple_ref/doc/uid/TP40001258-97181-CJBGGAIF" title="XPath and XQuery Basics"></a><h2>XPath and XQuery Basics</h2><a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_251"></a><p>XQuery 1.0<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_252"></a> and XPath 2.0<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_253"></a> are query languages so well integrated that it is easy to think of them as one language. Their formal semantics, data model, and functions and operators are defined in the same W3C specifications (see <span class="content_text"><a href="../NSXML.html#//apple_ref/doc/uid/TP40001263-96868">“See Also”</a></span> in the introduction). However there are distinctions, the primary one being that XPath uses a POSIX-style path syntax to describe the locations of nodes within an XML tree. In addition, XPath deals with nodes, while XQuery deals with nodes <em>and</em> atomic values. </p><p>The NSXMLNode class has two query-related methods, one for making XPath queries and the other for making XQuery queries:</p><ul class="simple"><li><p><code>- (NSArray *)nodesForXPath:<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_254"></a>(NSString *)xpath error:(NSError **)error</code></p></li><li><p><code>- (NSArray *)objectsForXQuery:<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_255"></a>(NSString *)xquery constants:(NSDictionary *)constants error:(NSError **)error</code></p></li></ul><p>Both methods return an array of found items—corresponding to a sequence<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_256"></a> in the data model—but the nature of the items differs, and this difference is reflected in the method names. The <code>nodesForXPath:error:</code> method returns an array of NSXMLNode objects<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_257"></a> while the <code>objectsForXQuery:constants:error:</code> method returns an array potentially containing both NSXMLNode objects and Foundation objects corresponding to the atomic types<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_258"></a> (NSNumber, NSString, NSCalendarDate, and so on). Even if these methods find only one item, they return it in an array.</p><p>Both methods also start a query with reference to an initial <em>context node<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_259"></a></em>. The context node is the node against which the evaluation of a location path or other expression is applied. In both methods the initial context node is the receiver of the message. In a query expression, you can also refer to the context node with a period (for example, <code>".//products"</code>). </p><p>You often begin an XPath expression<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_260"></a> with a double slash (<code>"//"</code>) <a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_261"></a>followed by an element name. This gives you all the descendent elements of the context node with that name, regardless of their level in the hierarchy. (You can also use a double slash<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_262"></a> elsewhere in a path.) Single slash<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_263"></a>es, followed by an element name, indicate a singular path down the tree hierarchy. Predicate<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_264"></a>s are Boolean tests within square brackets that select a subset of the nodes as evaluated to that point. Numbers within square brackets after elements identify particular child nodes by their index (which in this case is 1-based). To see this in practice, consider the following path expression:</p><div class="codesample"><table><tr><td scope="row"><pre>.//part/chapter[1]/section[title="Path Expressions"]<span></span></pre></td></tr></table></div><p>The evaluation of a path expression works from left to right. This expression first gets all the elements named <code>part</code> and from that selects the first element named <code>chapter</code>; from that it gets all child elements named <code>section</code>, and from that sequence it returns the section element whose title is “Path Expressions”. XPath also lets you find attributes by name by using an at-sign (@) <a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_265"></a><a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_266"></a>prefix. For example, the following path expression gets the modification date (an attribute) of the first chapter:</p><div class="codesample"><table><tr><td scope="row"><pre>.//part/chapter[1]/@modDate<span></span></pre></td></tr></table></div><p>XPath also has function-like type specifiers that let you refer to child nodes other than elements and attributes, including text nodes (<code>text()</code>), processing instructions (<code>processing-instruction()</code>), and comments <code>(comment()</code>). If a parent has more than one node of a given type, all are returned.</p><p><span class="content_text">Listing 1</span> is a fragment of code that illustrates how to make an XPath query using <code>nodesForXPath:error:</code>. It references a <code>city</code> element, which is a child of an <code>address</code> element, which is the third child element named <code>person</code> of the context node. If there are multiple elements named <code>city</code> at the end of this path, all of them are returned.</p><a name="//apple_ref/doc/uid/TP40001258-97336-CJBFBGGE" title="Listing 1Executing an XPath query"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001258-97336" title="Listing 1Executing an XPath query"></a><strong>Listing 1&nbsp;&nbsp;</strong>Executing an XPath query</p><div class="codesample"><table><tr><td scope="row"><pre>NSError *err=nil;<span></span></pre></td></tr><tr><td scope="row"><pre>NSXMLElement *thisCity;<span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *nodes = [theDocument nodesForXPath:@"./person[3]/address/city"<span></span></pre></td></tr><tr><td scope="row"><pre>        error:&amp;err];<span></span></pre></td></tr><tr><td scope="row"><pre>if ([nodes count] > 0 ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    thisCity = [nodes objectAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>    // do something with element<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>if (err != nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self handleError:err];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The initial context node for this query, an NSXMLDocument object (<code>theDocument</code>), is the receiver of the message. XPath returns the node or nodes that it finds in an array (a sequence). The code in <span class="content_text">Listing 1</span> is interested only in extracting the first node in the array, which it knows to be an NSXMLElement object. (Other kinds of child nodes can also be returned.) If XPath has trouble processing the query string—for example, the query has a syntax error—it directly returns <code>nil</code> and indirectly returns an NSError object<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_267"></a>. This code merely passes that object to another method to handle.</p><p>The NSXMLNode class defines an <code>XPath<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_268"></a></code> method that can be quite useful when making XPath queries. As the name suggests, you can send an <code>XPath</code> message to any node object to get an XPath string describing that node’s location in a tree. You can send or cache this string so that the node can easily be retrieved later via an XPath query. One possible scenario is that when a node changes its location within a tree, you can broadcast a notification that contains the new location as an XPath string in the <code>userInfo</code> dictionary.<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_269"></a></p><p><a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_270"></a>XQuery is a flexible and powerful query language that encompasses XPath. XQuery lets you compose logically complex queries using operators, quantifiers, functions and FLOWR expressions<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_271"></a><a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_272"></a> (referring to the keywords <code>for</code>, <code>let</code>, <code>order by</code>, <code>where</code>, and <code>return</code>). With XQuery you can sort returned values, construct nodes, perform joins, invert hierarchies, and dynamically create new XML documents. </p><p>As an example, consider the simple query shown in <span class="content_text">Listing 2</span>.</p><a name="//apple_ref/doc/uid/TP40001258-98004-CJBCAHED" title="Listing 2A simple XQuery query"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001258-98004" title="Listing 2A simple XQuery query"></a><strong>Listing 2&nbsp;&nbsp;</strong>A simple XQuery query</p><div class="codesample"><table><tr><td scope="row"><pre>for $p in .//person<span></span></pre></td></tr><tr><td scope="row"><pre>where $p/address/zip_code > 90000<span></span></pre></td></tr><tr><td scope="row"><pre>order by $p/last_name<span></span></pre></td></tr><tr><td scope="row"><pre>return $p<span></span></pre></td></tr></table></div><p>This query cycles through every descendent element of the context node named <code>person</code> and evaluates whether the child element at path <code>/address/zip_code</code> has a value greater than 90000. It sorts the elements that satisfy this test by the value of their <code>last_name</code> child element and returns the resulting sequence.</p><p>Executing an XQuery query<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_273"></a> in NSXML is largely a matter of passing in the query string when invoking the <code>objectsForXQuery:constants:error:</code> method. The example method in <span class="content_text">Listing 3</span> gets the string from a text view in the user interface.</p><a name="//apple_ref/doc/uid/TP40001258-97602-CJBJHDHC" title="Listing 3Executing an XQuery query"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001258-97602" title="Listing 3Executing an XQuery query"></a><strong>Listing 3&nbsp;&nbsp;</strong>Executing an XQuery query</p><div class="codesample"><table><tr><td scope="row"><pre>- (IBAction)applyXQuery:(id)sender {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (document) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSError *error;<span></span></pre></td></tr><tr><td scope="row"><pre>        NSArray *result = [document objectsForXQuery:<span></span></pre></td></tr><tr><td scope="row"><pre>            [xquerySourceTextView string] constants:nil error:&amp;error];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (result) {<span></span></pre></td></tr><tr><td scope="row"><pre>            unsigned count = [result count];<span></span></pre></td></tr><tr><td scope="row"><pre>            unsigned i;<span></span></pre></td></tr><tr><td scope="row"><pre>            NSMutableString *stringResult = [[NSMutableString alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>            for (i = 0; i &lt; count; i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>                [stringResult appendString:<span></span></pre></td></tr><tr><td scope="row"><pre>                    [NSString stringWithFormat:@"%d: {\r", i]];<span></span></pre></td></tr><tr><td scope="row"><pre>                [stringResult appendString:[[result objectAtIndex:i]<span></span></pre></td></tr><tr><td scope="row"><pre>                    description]];<span></span></pre></td></tr><tr><td scope="row"><pre>                [stringResult appendString:@"\r}\r"];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            [xqueryResultTextView setString:stringResult];<span></span></pre></td></tr><tr><td scope="row"><pre>            [stringResult release];<span></span></pre></td></tr><tr><td scope="row"><pre>        } else if (error) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self handleError:error];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This method applies the user-supplied query and formats the results before displaying it in another text view. If there is an error processing the request, it displays information about the error in an alert panel.</p><p>The second parameter of <code>objectsForXQuery:constants:error:</code> takes an NSDictionary object whose keys are the name of variables defined as external. The value of such a key is assigned as the value of the variable when it is used in a query. Through this mechanism, the constants dictionary<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_274"></a> lets you reuse a query string containing a variable whose value can change for each separate execution of a query. For more about the constants dictionary and its potential uses for a user interface, see the following section.</p><a name="//apple_ref/doc/uid/TP40001258-96877" title="Integrating XQuery Into the User Interface"></a><a name="//apple_ref/doc/uid/TP40001258-96877-CJBIBBGA" title="Integrating XQuery Into the User Interface"></a><h2>Integrating XQuery Into the User Interface</h2><a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_275"></a><p>Although you can make use of XPath and XQuery in your application, you can’t expect users to know enough about these query languages to construct their own queries. To use these languages effectively in your application, you need to find a way to incorporate the user’s intent into each query. There are various ways you could go about this. Two of them are discussed here, the constants dictionary and formatted strings.</p><a name="//apple_ref/doc/uid/TP40001258-98665" title="The Constants Dictionary"></a><a name="//apple_ref/doc/uid/TP40001258-98665-CJBGGDFI" title="The Constants Dictionary"></a><h3>The Constants Dictionary</h3><p>The constants dictionary<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_276"></a>, introduced in <span class="content_text"><a href="QueryingXML.html#//apple_ref/doc/uid/TP40001258-97181">“XPath and XQuery Basics,”</a></span> allows you to assign values to external variables<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_277"></a> in an XQuery query. You declare the variables in the prolog of the query and reference the variables where required in the query. (A prolog<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_278"></a> is a series of declarations and imports that creates the environment for query processing; it includes such things as variable definitions, module declarations, and schema imports.) The query can be reused as many times as you want. Then you create a dictionary containing key-value pairs where the key is the name of the variable and the value is whatever you want it to be. The value can be derived directly from a user-interface object.</p><p>With the constants dictionary you can, for instance, have a query that looks up user-supplied terms from an online dictionary. <span class="content_text">Figure 1</span> gives a simple example of the user interface for this query.</p><br/><div><a name="//apple_ref/doc/uid/TP40001258-98824-CJBDHAEG" title="Figure 1Simple user interface for a terminology query"></a><p><a name="//apple_ref/doc/uid/TP40001258-98824" title="Figure 1Simple user interface for a terminology query"></a><strong>Figure 1&nbsp;&nbsp;</strong>Simple user interface for a terminology query</p><img src = "Art/user_interface1.gif" alt = "Simple user interface for a terminology query" width="187" height="31"></div><br/><p>With the constants dictionary, you can assign the value of the term field to an external variable in the query string. </p><p>Let’s say a controller object connects the text field to an outlet named <code>termField</code> and connects the button to an action method. The following steps show how you might (in the action method) integrate the term variable into the query string: </p><ol class="ol"><li class="li"><p>Put the following line in the prolog of a query:</p><div class="codesample"><table><tr><td scope="row"><pre>declare variable $term as xs:string external;<span></span></pre></td></tr></table></div></li><li class="li"><p>Insert the variable (<code>$term</code>) in the query where you want the value to be used or evaluated.</p></li><li class="li"><p>Create a dictionary with a key of the same name as the variable and a value obtained from the user interface:</p><div class="codesample"><table><tr><td scope="row"><pre>NSDictionary *dict = [NSDictionary dictionaryWithObject:[termField stringValue] forKey:@"term"];<span></span></pre></td></tr></table></div></li><li class="li"><p>Send the <code>objectsForXQuery:constants:error:</code> method to the context node, passing in the dictionary:</p><div class="codesample"><table><tr><td scope="row"><pre>NSArray *result = [document objectsForXQuery:queryString constants:dict error:&amp;err];<span></span></pre></td></tr></table></div></li></ol><p>Keep in mind that external variables have assigned values, similar to the following expression: </p><div class="codesample"><table><tr><td scope="row"><pre>let $term := "a value"<span></span></pre></td></tr></table></div><p>External variables are not like macros where the value is substituted for a placeholder. Consequently, you cannot use the constants-dictionary mechanism to do things such as dynamically changing the XQuery functions used in a query string.</p><a name="//apple_ref/doc/uid/TP40001258-98691" title="Formatted Strings"></a><h3>Formatted Strings</h3><a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_279"></a><p>The <code>stringWithFormat:<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_280"></a></code> class method of NSString is a powerful tool. With it you can compose strings whose components can vary because of external factors, such as input from users. You can use format XQuery query strings in the same way. And unlike external variables, whose values are assigned from the constants dictionary, the “var-args” values in a formatted string are substituted for their place holders. Thus, formatted strings enable you to change language-related parts of the query string dynamically, including operators, function names, and path expressions.</p><p>To see how this might work, it helps to follow a simple example. <span class="content_text">Figure 2</span> shows a possible user interface for performing an XQuery query on an XML document.</p><br/><div><a name="//apple_ref/doc/uid/TP40001258-98998-CJBGJIEC" title="Figure 2User interface for a more complex query"></a><p><a name="//apple_ref/doc/uid/TP40001258-98998" title="Figure 2User interface for a more complex query"></a><strong>Figure 2&nbsp;&nbsp;</strong>User interface for a more complex query</p><img src = "Art/user_interface2.gif" alt = "User interface for a more complex query" width="521" height="68"></div><br/><p>The choices and entries a user makes with the pop-up lists and the text field become part of the query executed when the user clicks the Find button. For the specific choices and entry in the example above, the query string becomes the following:</p><div class="codesample"><table><tr><td scope="row"><pre>for $p in //person<span></span></pre></td></tr><tr><td scope="row"><pre>where starts-with($p/phone/text(), "(408)")<span></span></pre></td></tr><tr><td scope="row"><pre>order by $p/lastName<span></span></pre></td></tr><tr><td scope="row"><pre>return $p<span></span></pre></td></tr></table></div><p>For the pop-up lists, the incorporated values are “represented objects” associated with the items (NSMenuItem objects) of the lists. The represented objects of the first list’s items are XPath path expressions relative to a context node; the represented objects of the second list’s items are either operators or names of XQuery functions. <span class="content_text">Listing 4</span> is a method that dynamically creates the items of the second pop-up list and sets their represented objects.</p><a name="//apple_ref/doc/uid/TP40001258-99894-CJBHCAEJ" title="Listing 4Setting the represented objects for pop-up list items"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001258-99894" title="Listing 4Setting the represented objects for pop-up list items"></a><strong>Listing 4&nbsp;&nbsp;</strong>Setting the represented objects for pop-up list items</p><div class="codesample"><table><tr><td scope="row"><pre>- (IBAction)changeOperationsList:(id)sender {<span></span></pre></td></tr><tr><td scope="row"><pre>    [operationPopUp removeAllItems];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ([elementPopUp indexOfSelectedItem] > 4) { // operators<span></span></pre></td></tr><tr><td scope="row"><pre>        NSMenuItem *anItem;<span></span></pre></td></tr><tr><td scope="row"><pre>        [operationPopUp addItemsWithTitles:[NSArray arrayWithObjects:<span></span></pre></td></tr><tr><td scope="row"><pre>            @"equals", @"greater than", @"less than", nil]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        anItem = (NSMenuItem *)[operationPopUp itemAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (anItem) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [anItem setRepresentedObject:@"="];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        anItem = (NSMenuItem *)[operationPopUp itemAtIndex:1];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (anItem) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [anItem setRepresentedObject:@">"];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        // continued ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    } else { // functions<span></span></pre></td></tr><tr><td scope="row"><pre>        NSMenuItem *anItem;<span></span></pre></td></tr><tr><td scope="row"><pre>        [operationPopUp addItemsWithTitles:[NSArray arrayWithObjects:<span></span></pre></td></tr><tr><td scope="row"><pre>            @"is", @"contains", @"begins with", @"ends with", nil]];<span></span></pre></td></tr><tr><td scope="row"><pre>        anItem = (NSMenuItem *)[operationPopUp itemAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (anItem) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [anItem setRepresentedObject:@"matches"];<span></span></pre></td></tr><tr><td scope="row"><pre>            [anItem setTag:XQFunction];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        anItem = (NSMenuItem *)[operationPopUp itemAtIndex:1];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (anItem) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [anItem setRepresentedObject:@"contains"];<span></span></pre></td></tr><tr><td scope="row"><pre>            [anItem setTag:XQFunction];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        // continued ...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the user chooses popup-list items, enters a value for comparison in the text field, and clicks the Find button, the action method shown in <span class="content_text">Listing 5</span> is invoked. This method composes the query string—differently, according to whether a function or operator is required—from the represented objects and the value of the text field. It then sends the <code>objectsForXQuery:constants:error:</code> message to the context node (the document object) to execute the query.</p><a name="//apple_ref/doc/uid/TP40001258-100304-CJBIJIFF" title="Listing 5Composing and executing the query"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001258-100304" title="Listing 5Composing and executing the query"></a><strong>Listing 5&nbsp;&nbsp;</strong>Composing and executing the query</p><div class="codesample"><table><tr><td scope="row"><pre>- (IBAction)findByXQuery:(id)sender {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *queryString;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray *results;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSError *err=nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    [queryStatus setStringValue:@""];<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([[operationPopUp selectedItem] tag] == XQFunction ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        queryString = [NSString stringWithFormat:@" \<span></span></pre></td></tr><tr><td scope="row"><pre>            for $p in //person \<span></span></pre></td></tr><tr><td scope="row"><pre>            where %@($p/%@/text(), \"%@\") \<span></span></pre></td></tr><tr><td scope="row"><pre>            order by $p/lastName \<span></span></pre></td></tr><tr><td scope="row"><pre>            return $p",<span></span></pre></td></tr><tr><td scope="row"><pre>            [[operationPopUp selectedItem] representedObject],<span></span></pre></td></tr><tr><td scope="row"><pre>            [[elementPopUp selectedItem] representedObject],<span></span></pre></td></tr><tr><td scope="row"><pre>            [queryValue stringValue]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        queryString = [NSString stringWithFormat:@" \<span></span></pre></td></tr><tr><td scope="row"><pre>            for $p in //person \<span></span></pre></td></tr><tr><td scope="row"><pre>            where $p/%@/text() %@ \"%@\" \<span></span></pre></td></tr><tr><td scope="row"><pre>            order by $p/lastName \<span></span></pre></td></tr><tr><td scope="row"><pre>            return $p",<span></span></pre></td></tr><tr><td scope="row"><pre>            [[elementPopUp selectedItem] representedObject],<span></span></pre></td></tr><tr><td scope="row"><pre>            [[operationPopUp selectedItem] representedObject],<span></span></pre></td></tr><tr><td scope="row"><pre>            [queryValue stringValue]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    results = [xmlDoc objectsForXQuery:queryString constants:nil<span></span></pre></td></tr><tr><td scope="row"><pre>              error:&amp;err];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (results &amp;&amp; [results count] > 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self doSomethingWithQueryResults:results];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        [queryStatus setStringValue:[NSString stringWithFormat:<span></span></pre></td></tr><tr><td scope="row"><pre>            @"No records found, query errors: %@",<span></span></pre></td></tr><tr><td scope="row"><pre>            (err ? [err localizedDescription] : @"None")]];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Instead of fetching the string value of the <code>queryValue</code> field this way, you could declare an external variable in the query prolog, put the value of the <code>queryValue</code> field in the constants dictionary, and reference the variable in the query. See <span class="content_text"><a href="QueryingXML.html#//apple_ref/doc/uid/TP40001258-98665">“The Constants Dictionary”</a></span> for details on this approach.<a name="//apple_ref/doc/uid/TP40001258-DontLinkElementID_281"></a></p><a name="//apple_ref/doc/uid/TP40001258-150788" title="Resources For Learning XQuery"></a><a name="//apple_ref/doc/uid/TP40001258-150788-CJBHCHAA" title="Resources For Learning XQuery"></a><h2>Resources For Learning XQuery</h2><p>XQuery is a fairly complex language, and although this document summarizes the salient aspects of syntax and behavior, it does not attempt a thorough description of XQuery. Fortunately a number of excellent online and downloadable tutorials are available, as a search of the Internet reveals. Here are some notable XQuery tutorials:</p><ul class="ul"><li class="li"><p>“XQuery: A Guided Tour,” DataDirect Technologies, downloadable (PDF) from <span class="content_text"><a href="http://www.datadirect.com/news/whatsnew/xquerybook/index.ssp" target="_blank">http://www.datadirect.com/news/whatsnew/xquerybook/index.ssp</a></span></p><p>This tutorial is excerpted from <em>XQuery from the Experts: A Guide to  the W3C XML Query Language</em> by Howard Katz, Don Chamberlin, Denise Draper, Mary Fernandez, Michael  Kay, Jonathan Robie, Michael Rys, Jerome Simeon, Jim  Tivy, and Philip Wadler, (ISBN 0-321-18060-7), Addison-Wesley, 2004.</p></li><li class="li"><p>“XQuery Tutorial,” W3Schools, <span class="content_text"><a href="http://www.w3schools.com/xquery/default.asp" target="_blank">http://www.w3schools.com/xquery/default.asp</a></span></p></li><li class="li"><p>“XQuery Tutorial,” Ipedo, Inc., <span class="content_text"><a href="http://www.ipedo.com/html/xquery/xquery_tutorial/index.html" target="_blank">http://www.ipedo.com/html/xquery/xquery_tutorial/index.html</a></span></p></li></ul><p>Because resources on the web might occasionally become unavailable or outdated, it’s a good idea to perform your own web searches now and then for XQuery information.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="TraversingTree.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ModifyingXML.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/NSXML_Concepts/Articles/QueryingXML.html%3Fid%3DTP40001269-2.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/NSXML_Concepts/Articles/QueryingXML.html%3Fid%3DTP40001269-2.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/NSXML_Concepts/Articles/QueryingXML.html%3Fid%3DTP40001269-2.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
