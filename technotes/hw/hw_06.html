<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"        "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd"><HTML><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note HW06: Cache As Cache Can</title><meta name="categories" content="Hardware"><meta name="week-posted" content="Sep 25, 1989 - Oct 6, 1989"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002475" title="Cache As Cache Can"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --> <!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note HW06</div>
<div id="pageheadsub">Cache As Cache Can</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->                     <P id = "menutext"><A HREF = "#Section1">Cache Machines</a><BR><BR>         <A HREF = "#Section2">Stale Data (Baked Fresh Daily)</a><BR><BR>         <A HREF = "#Section3">Caching Consequences - LocalTalk</a><BR><BR> <A HREF = "#Section4">External Caches</a><BR><BR> <A HREF = "#References">References</a><BR><BR>  <A HREF = "#Changes">Change History</a><BR><BR>         <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note documents cache behavior, manipulation         of processor caches, and manipulation of external caches on         Macintosh models that incorporate these features. It also         describes how system software uses a memory management unit         (when available) to implement special caching options.</P><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1991]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><a name="Section1"></a>                  <h2>Cache Machines</h2>                  <P>The Motorola MC68020 microprocessor includes a 256-byte         internal instruction cache. The MC68030 includes a         similar-size instruction cache plus a 256-byte writethrough         data cache. The MC68040 has much larger caches, 4K of         instructions, and 4K of data. It also supports copyback         caching in addition to the writethrough caching used by the         MC68030.</P>                                    <P>The difference between writethrough and copyback caching         is a matter of whether data writes go directly and         immediately to main memory, or whether they go only as far         as the data cache to be copied back to main memory later (if         necessary) in a highly optimized fashion.</P>                                    <P>The MC68030 and MC68040 include memory management units         internally. Besides the ability to divide memory into         logical pages and provide memory access control, these         memory management units can also associate cacheability         attributes with individual pages of memory, affecting how         data is cached on a page-by-page basis.</P>         <P><A HREF="#top">Back to top</A></P>          <a name="Section2"></a>         <h2>Stale Data (Baked Fresh Daily)</h2>                  <P>Caching greatly improves overall system performance but         introduces the problem of stale data, or inconsistency         between cached data and the data in actual memory (RAM). In         certain cases, cache maintenance instructions are necessary         to maintain coherency between cache and main memory.</P>                  <h3>Stale Instructions</h3>                  <P>The first time when stale data becomes a problem occurs         when writing self-modifying code on the MC68020 or any other         processor with an instruction cache. The instruction cache         remembers, separately from main memory, many of the         instructions it has recently executed. If the processor         executes an instruction, later changes that instruction in         memory, and then tries to execute the new instruction at the         same address, there is a probability that the original         instruction is still cached. Since the cache is used before         main memory, the old instruction may be executed instead of         the new one, resulting in incorrect program operation.</P>                  <P>To prevent this, any time a program changes an executable         instruction in memory, it must flush the instruction cache         before attempting to execute the modified instruction.         Flushing a cache invalidates its entries, forcing the         processor to refill cache entries from main memory. In part,         this defeats the purpose of a cache and hurts performance.         Nevertheless, the alternative is incorrect program         operation. This serves to emphasize that caches must always         be flushed judiciously in order to maintain correct         operation and optimal performance.</P>                                    <P>As described, self-modifying code is not just code that         changes itself directly as it executes. It can be much more         subtle. Code that modifies a jump table entry is modifying         executable code and must flush the instruction cache. Patch         installation code often copies code from one block of memory         into another and may modify one or more <code>JMP</code>         instruction operands in order to get back to the original         routine--either technique requires flushing the instruction         cache.</P>                  <h3>Stale Data</h3>                  <P>With the addition of the data cache in the MC68030,         performance is further enhanced, but another cache offers         another source of stale data.</P>                   <P>Let's say that you have a whizzy disk controller card         that supports DMA. The board reads command buffers from the         main CPU's memory area and writes status information back to         the command buffer when done. Before the command is started,         the MC68030 sets up the command buffer and zeroes the status         code (the following figures are not to scale).</P>                  <P align=center><img src="images/hw_06_001.gif" alt="Write (Writethrough Cache)" width=352 height=201></P><P align=center><B>Figure 1</b>. Write (Writethrough Cache)</P>                  <P>At this point the cache and the memory both contain the         value 0, since the MC68030's cache is writethrough (that is,         it always writes data to memory immediately). Now the         MC68030 starts the command running and waits for an         interrupt from the disk controller card. It then reads back         the status from the command buffer, which is modified by the         DMA card.</P>                  <P align=center><img src="images/hw_06_002.gif" alt="Read (From Cache)" width=352 height=201></P><P align=center><B>Figure 2</b>. Read (From Cache)</P>                  <P>Oops! Because the status code's value is already cached,         the MC68030 thinks that the status is 0, even though the         actual value in memory is -23. This type of thing can cause         some very hard-to-find bugs in your driver.</P>                  <h3>Copyback Data and Stale Instructions</h3>                  <P>There is another type of cache called a copyback cache         that is supported by more advanced microprocessors like the         MC68040. A copyback cache further improves system         performance by writing data to external memory only when         necessary to make room in the cache for more recent         accesses, or when explicitly "pushed" by system software.         This is extremely valuable for relatively small, short-lived         data that are accessed frequently but don't need to persist         for a long time, like local stack frames in C and Pascal         function calls.</P>                           <P>This increase in performance again comes at some cost in         terms of maintaining cache coherency. Here, the problem is         twofold. Fundamentally, a datum that is "written to memory"         isn't really in memory (meaning main RAM) until it's pushed         out of the data cache. When performing DMA, it is necessary         to push data cache contents into memory before instructing         alternate bus masters to look for it; they'll only find         stale data if it's still cached. Second, and perhaps even         more important, the instruction and data caches are         completely independent of each other. When fetching         instructions, the processor looks in only two places: first         the instruction cache, then main memory. It does not look in         the data cache. When performing the types of operations         described above that can cause a stale instruction cache,         one must remember that it is impossible to make the         instruction cache and memory coherent if memory itself is         stale! The data cache must be flushed; then and only then         can the instruction cache refill with the valid data the         processor has written.</P>                    <P>Here, some code writes the <code>_LoadSeg</code> trap to memory as         part of a jump table update. Figure 3 indicates what happens         if only the instruction cache is flushed. When execution         later proceeds through that jump table entry, the processor         fetches the opcode from that address and gets zonked with an         illegal F-line exception. Why? <code>_LoadSeg</code> is still in the data         cache. The code responsible for maintaining the jump table         failed to push the contents of the data cache before         invalidating the instruction cache. This certainly causes         problems on the MC68040.</P>                  <P align=center><img src="images/hw_06_003.gif" alt="Write (Copyback Cache) and Fetch" width=352 height=201></P>                  <p align=center><B>Figure 3</b>. Write (Copyback Cache) and Fetch</P>                  <P>Another similar problem applies to the time at which         cache flushing is performed. When using a writethrough data         cache, it is acceptable to invalidate the instruction cache         first and then modify instructions in memory. With a         copyback data cache, it is imperative to make changes to         memory first and then flush caches. Again, this ensures that         copyback data is written to memory before the instruction         cache attempts to refill from memory. The key point to         remember is that the MC68040 instruction cache always reads         from memory, never from the data cache.</P>                  <P>Figure 4 shows the path that an instruction properly         takes when it is first written as data by a program that         modifies instructions in memory.</P>                  <P align=center><img src="images/hw_06_004.gif" alt="Write         (Copyback Cache), Push, and Fetch" width=352 height=201></p>          <P align=center><B>Figure 4</b>. Write         (Copyback Cache), Push, and Fetch</P>                  <P>It's worth noting here that although pushing copyback         data to memory and invalidating (flushing) the cache are         conceptually different operations, they are at least for the         MC68040 irrevocably connected. This makes flushing the data         cache for the sake of pushing its contents to memory a         potentially expensive one. Valid cache data is essentially         lost when it is pushed and must be read from main memory if         it is to be accessed again. This should be another         reinforcement that cache flushing must be performed         judiciously. It is possible to flush only a portion of the         MC68040 caches, and software that flushes caches frequently         should consider this optimization to avoid unnecessary         performance degradation when running on this processor. See         the interfaces provided below.</P>                  <h3>What Is Apple's Part in This?</h3>                  <P>There are two answers to this question. First, there are         things that Apple has done in ROM to make life easier while         dealing with a caching processor. Second, there are         functions provided in ROM or in system software to allow         developers to take some control of their own destinies.</P>                  <h3>Things That Happen for You</h3>                  <P>Ever since the Macintosh II made its debut, it has been         flushing the instruction cache. It does so at a number of         critical points where code may be moved to a new location,         potentially leaving memory and the instruction cache         incoherent. Specifically, there are a number of traps that         have the potential to move code around memory. In each of         these cases, the instruction cache is flushed by system         software or ROM.</P>                                    <P><code>_BlockMove _LoadSeg</code></P>                  <P><code>_Read _UnloadSeg</code></P>                  <P><B>Warning:</B> The <code>_BlockMove</code> trap is not         guaranteed to flush caches for block sizes 12 bytes or less.         This is a performance optimization. <code>_BlockMove</code> is         called often by system software to move small blocks of         memory that are not executable instructions. Flushing the         cache in all such cases causes significant performance         degradation. When moving very small blocks of code with         _BlockMove, use one of the explicit cache flushing routines         described below. </p>                           <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>C programmers should not         assume that the standard library function <code>memcpy()</code> invokes         <code>_BlockMove</code>. An explicit cache flush is required after moving         code with <code>memcpy()</code>.</P></TD></TR></TABLE></CENTER><BR>                  <P>In general, there may be others. As a rule of thumb, the         instruction cache needs to be flushed explicitly only as a         result of actions taken by user code, not as the result of         anything a trap might have done. Traps can take care of         themselves.</P>                                    <P>A memory management unit allows individual pages of         memory to be marked noncachable. In current Macintosh         implementations, NuBus(TM) and I/O address spaces are always         marked noncachable--the processor won't cache memory stored         at NuBus or I/O addresses. This solves any problems of stale         data when processor/DMA "mailboxes" are located in NuBus         memory and eliminates the fundamental problem of stale data         at memory-mapped I/O locations. Data at RAM and ROM         addresses are cachable, which makes sense and maximizes         performance.</P>                                    <P>Since DMA still poses a problem when common buffers are         located in main RAM, it would seem that there should be         greater intrinsic support for specifying cachability. There         is. In order for DMA masters to be compatible with abstract         memory architectures like those defined by the Macintosh         IIci and even more so by virtual memory, they must use the         GetPhysical routine. Before using <code>GetPhysical</code>, a range must         always be locked with <code>LockMemory</code>. Since this sequence is so         commonly required when performing DMA, the LockMemory         routine has the effect of either disabling the data cache or         marking the corresponding pages noncachable, depending on         what's possible and what makes the most sense. In many         cases, therefore, it is unnecessary to explicitly flush the         data cache. If common DMA buffers are locked with         LockMemory, the operating system ensures cache coherency at         least for those buffers.</P>                                    <P>To ensure compatibility with existing code while taking         advantage of copyback cache mode, the <code>FlushInstructionCache</code>         function on an MC68040 actually flushes both caches using         the CPUSHA BC instruction. This prevents the need for         modification of correct existing code which properly flushes         the instruction cache with <code>FlushInstructionCache</code>. If code is         written properly for the MC68020 and MC68030, it will work         on the MC68040 as well, without modification. If code is         written incorrectly or directly manipulates the CACR         register of these processors it will fail on the MC68040.         When modifying code in memory or moving code about memory,         use FlushInstructionCache before executing that code.</P>                  <h3>Facilities That Are Provided for You</h3>                  <P>Apple provides some system calls that let you flush the         data and instruction caches without using privileged         instructions (which is, as you should all know by now, a         major no-no).</P>                                    <P>Following are the interfaces for these calls, for MPW         Pascal and C (respectively):</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   FUNCTION SwapInstructionCache (cacheEnable: BOOLEAN) : BOOLEAN;   pascal Boolean SwapInstructionCache (Boolean cacheEnable);</pre>	</TD></TR></TABLE></CENTER>                  <P>This call enables or disables the instruction cache         according to the state passed in <code>cacheEnable</code> and         returns the previous state of the instruction cache as a         result.</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PROCEDURE FlushInstructionCache;pascal void FlushInstructionCache (void);</pre>	</TD></TR></TABLE></CENTER>                  <P>This call flushes the current contents of the instruction         cache. This has an adverse effect on CPU performance, so         only call it when absolutely necessary.</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   FUNCTION SwapDataCache (cacheEnable: BOOLEAN) : BOOLEAN;   pascal Boolean SwapDataCache (Boolean cacheEnable);</pre>	</TD></TR></TABLE></CENTER>                  <P>This call enables or disables the data cache according to         the state passed in <code>cacheEnable</code> and returns the         previous state of the data cache as a result.</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PROCEDURE FlushDataCache;pascal void FlushDataCache (void);</pre>	</TD></TR></TABLE></CENTER>                  <P>This call flushes the current contents of the data cache.         This has an adverse effect on CPU performance, so only call         it when absolutely necessary.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Before you call any of these routines, make         sure that the <code>_HwPriv</code> ($A198) trap is implemented, or your         program will crash. <code>_HwPriv</code> is implemented in the Macintosh         IIx ROMs and later, as well as System 6.0.3 and later. The         correct way to check for the trap is using the TrapAvailable         function documented in <I>Inside Macintosh </I>Volume VI         (pages 3-7 to 3-9).</P><P>These calls are provided as part of the MPW 3.1 library.         For those of you without MPW 3.1 or later, you can use the         following MPW assembly-language glue:</P></TD></TR></TABLE></CENTER><BR>                  <P></P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>            CASE OFF_HwPriv     OPWORD  $A198SwapInstructionCache PROC EXPORT            MOVEA.L (A7)+,A1        ; save return address            MOVEQ   #0,D0           ; clear D0 before we shove Boolean into it            MOVE.B  (A7)+,D0        ; D0 &lt;- new mode            MOVE.L  D0,A0           ; _HwPriv wants mode in A0            CLR.W   D0              ; set low word to 0 (routine selector)            _HwPriv            MOVE.W  A0,D0           ; move old state of cache to D0            TST.W   D0              ; if nonzero, cache was enabled            BEQ.S   WasFalse        ; if zero, leave result false            MOVEQ   #1,D0           ; set result to trueWasFalse:            MOVE.B  D0,(A7)         ; save result on stack            JMP     (A1)            ENDPROCFlushInstructionCache PROC EXPORT            MOVEA.L (A7)+,A1        ; save return address            MOVEQ   #1,D0           ; set low word to 1 (routine selector)            _HwPriv            JMP     (A1)            ENDPROCSwapDataCache PROC EXPORT            MOVEA.L (A7)+,A1        ; save return address            MOVEQ   #0,D0           ; clear D0 before we shove Boolean into it            MOVE.B  (A7)+,D0        ; D0 &lt;- new mode            MOVE.L  D0,A0           ; _HwPriv wants mode in A0            MOVE.W  #2,D0           ; set low word to 2 (routine selector)            _HwPriv            MOVE.W  A0,D0           ; move old state of cache to D0            TST.W   D0              ; if nonzero, cache was enabled            BEQ.S   WasFalse        ; if zero, leave result false            MOVEQ   #1,D0           ; set result to trueWasFalse:            MOVE.B  D0,(A7)         ; save result on stack            JMP     (A1)            ENDPROCFlushDataCache PROC EXPORT            MOVEA.L (A7)+,A1        ; save return address            MOVEQ   #$3,D0          ; set low word to 3 (routine selector)            _HwPriv            JMP     (A1)            ENDPROC</pre>	</TD></TR></TABLE></CENTER>                  <P>There are two additional calls whose interfaces follow.         Each requires a little explanation.</P>                                    <P>The first call is <code>FlushCodeCache</code>, which simply         invokes the <code>_CacheFlush </code>($A0BD)<code> </code>trap. This         trap's function is to make the instruction cache coherent         with memory. On the MC68020 and MC68030 it simply flushes         the instruction cache. On the MC68040 it also flushes the         data cache for copyback compatibility. The advantage of         <code>FlushCodeCache</code> as opposed to         <code>FlushInstructionCache</code> is that it was implemented         before the <code>_HwPriv</code> trap, and thus can be used on         the Macintosh II while running older system software.</P>                                    <P>In general, <code>FlushInstructionCache</code> is still the         preferred application-level cache flushing mechanism.         <code>FlushInstructionCache</code> calls <code>FlushCodeCache</code>         and is therefore a higher-level call conceptually.         <code>FlushCodeCache</code> may be useful where         <code>FlushInstructionCache</code> proves unsuitable, or as an         alternative to the next call, <code>FlushCodeCacheRange</code>.         Obviously, before calling <code>FlushCodeCache</code>, be         certain that <code>_CacheFlush</code> is implemented.</P>              <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If the processor has a cache to flush, this         trap should be properly implemented, because ROM and system         software use this trap's vector to do their own cache         flushing. In fact, <code>FlushInstructionCache</code> itself         uses this vector. This should be of particular interest to         accelerator card developers.</P></TD></TR></TABLE></CENTER><BR>                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>            MACRO            _FlushCodeCache            _CacheFlush            ENDMPROCEDURE FlushCodeCache;    INLINE $A0BD;void FlushCodeCache (void) = 0xA0BD;</pre>	</TD></TR></TABLE></CENTER>                  <P>The second call is <code>FlushCodeCacheRange</code>.         <code>FlushCodeCacheRange</code> is an optimization of         <code>FlushCodeCache</code> designed for processors like the         MC68040 which support flushing only a portion of the cache.         (The MC68020 and MC68030 do not support this feature and         <code>FlushCodeCacheRange</code> simply flushes the entire         instruction cache on those processors.) As described         earlier, pushing and flushing cache entries are linked and         flushing the entire cache after a small change like a jump         table entry can be expensive. <code>FlushCodeCacheRange</code>         allows one to request that only a specific memory range be         flushed, leaving the rest of the cache intact. Note that         this is only a request and that more than the requested         range may be flushed if it proves inefficient to satisfy the         request exactly. Also, <code>FlushCodeCacheRange</code> may not         be implemented for some older versions of system software         that are not MC68040-aware. If not,         <code>FlushCodeCacheRange</code> returns <code>hwParamErr</code>         (-502) and it is necessary to flush the entire cache         instead, probably using <code>FlushCodeCache</code>. If         <code>FlushCodeCacheRange</code> succeeds it returns         <code>noErr</code> (0). Before calling         <code>FlushCodeCacheRange</code>, be certain that         <code>_HwPriv</code> is implemented.</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>; _FlushCodeCacheRange takes/returns the following parameters:;    -&gt; A0.L =   Base of range to flush;    -&gt; A1.L =   Length of range to flush;    &lt;- D0.W =   Result code (noErr = 0, hwParamErr = -502)            MACRO            _FlushCodeCacheRange            moveq   #9,d0            _HwPriv            ENDMFUNCTION FlushCodeCacheRange (address: UNIV Ptr; count: LongInt) : OSErr;    INLINE $225F,   { MOVEA.L (SP)+,A1 }           $205F,   { MOVEA.L (SP)+,A0 }           $7009,   { MOVEQ   #9,D0    }           $A198,   { _HwPriv          }           $3E80;   { MOVE.W  D0,(SP)  }// MPW C 3.2 makes register-based inline calls very efficient.#pragma parameter __D0 FlushCodeCacheRange(__A0,__A1)OSErr FlushCodeCacheRange (void *address, unsigned long count) =    {0x7009, 0xA198};/* MPW C 3.1 and earlier, and THINK C(TM) should declare the function as   *//* "pascal" and use the same inline constants as the Pascal interface: */pascal OSErr FlushCodeCacheRange (void *address, unsigned long count) =    {0x225F, 0x205F, 0x7009, 0xA198, 0x3E80};</pre>	</TD></TR></TABLE></CENTER>         <P><A HREF="#top">Back to top</A></P>         <a name="Section3"></a>                  <h2>Caching Consequences - LocalTalk</h2>                  <P>As noted above, altering the state of the data/code cache         significantly affects the performance of the 68040         processor. This change in effective CPU speed may affect any         background process that is dependent on the processor speed         remaining constant. LocalTalk is an example of one such         affected process, as it employs speed sensitive timing         loops. The change in CPU speed affects the LocalTalk timers,         to the extent that the LocalTalk no longer functions         correctly if it is the current AppleTalk connection.</P>                                    <P>Fortunately, the AppleTalk Transition Queue mechanism can         be used to notify LocalTalk of the change in effective CPU         speed. Upon notification, LocalTalk recalculates its timer         values to match the current CPU speed. Refer to <I>Inside         Macintosh</I> Volume VI, page 32-17, and to Technical Note         #311, "What's New In AppleTalk Phase 2," for additional         information on the use of the AppleTalk Transition         Queue.</P>                                    <P>The following code demonstrates the use of the         <code>ATEvent</code> procedure to send the         <code>ATTransSpeedChange</code> event. The <code>ATEvent</code> call         is provided as part of the MPW 3.2 library.</P>                           <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Issue the         <code>ATTransSpeedChange</code> event <B>only</B> at         <code>SystemTask</code> time!</P></TD></TR></TABLE></CENTER><BR>                           <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>USES AppleTalk;  { ATEvent prototyped in AppleTalk unit, MPW 3.2 }CONST    ATTransSpeedChange = 'sped'; {change in cpu speed transition }PROCEDURE NotifyLocalTalkSpeedChange;    BEGIN        if LAPMgrExists THEN { check LAP Manager exists, see Technote 311 }                        { for the code for LAPMgrExists }            ATEvent(longint(ATTransSpeedChange), NIL);                        { notify speed change event }    END;</pre>	</TD></TR></TABLE></CENTER>                  <P>Note that only LocalTalk drivers that are included with         AppleTalk version 57 or greater, respond to the         <code>ATTranSpeedChange</code> event. System 7.0.1 for the Quadra's, is         supplied with AppleTalk version 56. AppleTalk version 57 is         available by using the AppleTalk Remote Access Installation         program, or the Network Software Installer version 1.1.         Licensing for AppleTalk can be arranged by contacting Apple         Software Licensing. Software Licensing can be reached as         follows:</P>                                    <P>Software Licensing<BR>                  Apple Computer, Inc.</p>                  <P>20525 Mariani Avenue, M/S 38-I<BR>                  Cupertino, CA 95014<BR>                  MCI: 312-5360<BR>                  AppleLink: SW.LICENSE<BR>                  Internet: SW.LICENSE@AppleLink.Apple.com<BR>                  (408) 974-4667</P>                                    <P>AppleTalk version 53 or greater is required to handle the         ATEvent call, however, nothing bad will happen if you issue         the <code>ATTranSpeedChange</code> transition event under AppleTalk         versions 53 - 56. It is important to check that the LAP         Manager is implemented before issuing the <code>ATEvent</code>         call. See Technote 311 for a description of the         <code>LAPMgrExists</code> function.</P>         <P><A HREF="#top">Back to top</A></P>  <a name="Section4"></a>           <h2>External Caches</h2>                  <P>The Macintosh IIci and Macintosh IIsi support external         cache cards. Because of the way these caches work, cache         coherency is not much of a problem. In fact these caches are         usually enabled full-time and their operations are totally         transparent to all well-behaved hardware and software.         Still, there are corresponding cache control functions to         enable, disable, and flush these cache cards. If _HwPriv is         implemented, the following routines may be used:</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>            MACRO            _EnableExtCache            moveq   #4,d0            _HwPriv            ENDMPROCEDURE EnableExtCache;    INLINE $7004,$A198;void EnableExtCache (void) = {0x7004, 0xA198};            MACRO            _DisableExtCache            moveq   #5,d0            _HwPriv            ENDMPROCEDURE DisableExtCache;    INLINE $7005,$A198;void DisableExtCache (void) = {0x7005, 0xA198};            MACRO            _FlushExtCache            moveq   #6,d0            _HwPriv            ENDMPROCEDURE FlushExtCache;    INLINE $7006,$A198;void FlushExtCache (void) = {0x7006, 0xA198};</pre>	</TD></TR></TABLE></CENTER>         <P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2>                              <p><I>Inside Macintosh</I>, Volume V, Operating System            Utilities</p>                        <p><I>Inside Macintosh</I>, Volume VI, Compatibility            Guidelines</p>                        <p><I>Designing Cards and Drivers for the Macintosh            Family</I></p>                        <p><I>M68000 Family Programmer's Reference            Manual</I></p>                        <p><I>M68020 32-Bit Microprocessor User's            Manual</I></p>                        <p><I>M68030 Enhanced 32-Bit Microprocessor User's            Manual</I></p>                        <p><I>M68040 32-Bit Third-Generation Microprocessor            User's Manual</I></p>                          <P>NuBus(TM) is a trademark of Texas Instruments.</P>                  <P>THINK C is a trademark of Symantec Corp.</p>         <P><A HREF="#top">Back to top</A></P>                 <P><A NAME=Changes></A></P>                  <H2>Change History</H2>         <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-October-1991</P>               </TD>               <td align="left">                  <P>Described use of         AppleTalk Transition Queue event, <code>ATTransSpeedChange</code>, when         altering the 68040 cache state on the fly. This call must be         issued so that LocalTalk can reevaluate its timers.         Otherwise LocalTalk becomes disabled.</P>               </TD>            </TR>            </table><BR>         <P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (144K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/hw_06.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/hw/hw_06.html%3Fid%3DDTS10002475-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/hw/hw_06.html%3Fid%3DDTS10002475-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/hw/hw_06.html%3Fid%3DDTS10002475-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>