<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note FL16: File Manager Performance and Caching</title><meta name="keywords" content="have creator list relevant keywords here"><meta name="Description" content="Technical Note FL16: "><meta name="categories" content="Files"><meta name="week-posted" content="Aug 28, 2000 - Sep 1, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002442" title="File Manager Performance and Caching"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxFileManagement-date.html">File Management</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note FL16</div>
<div id="pageheadsub">File Manager Performance and Caching</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext">                  <A HREF="#Section1">Introduction</A><BR>                  <BR>                  <A HREF="#Section2">Increase the Size of I/O         Requests</A><BR>                  <BR>                  <A HREF="#Section3">Block Align I/O Requests</A><BR>                  <BR>                  <A HREF="#Section4">File System Cache Control</A><BR>                  <BR>                  <A HREF="#Section5">Cached I/O versus Data Integrity</A><BR>                  <BR>         <A HREF="#Summary">Summary</A><BR>                  <BR>                  <A HREF="#References">References</A><BR>                  <BR>                  <A HREF="#changes">Change History</A><BR>                  <BR>                  <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technote         discusses Mac OS file system input/output performance issues         and the File Manager's volume cache. It is assumed the         reader of this technote has a         good understanding of basic File Manager I/O routines.</P>         <P id = "introtext">This technote is directed at         application developers who are interested in getting the         most performance out of the traditional Mac OS file system.</p>      <!-- end_intro_text --><!-- begin_date --><h3 align=center>[Sep 05 2000]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content -->         <A NAME="Section1"></A>                  <H2>Introduction</H2>                  <P>The File Manager's input/output programming interface         hasn't changed much since 1984. There are a half dozen new         ways to open a file, but when it gets down to accessing the         data in a file, you still end up using the same read and         write calls the Mac OS started with. Since little has         changed, most programmers pay little or no attention to how         their programs access files until they find the overall         performance of their program depends on file access speed.         This technote shows you how to         get the best throughput from the file system using a variety         of techniques.</P>                  <P>Although this technote's         primary focus is on the built-in HFS and HFS Plus file         systems, the techniques described will likely improve         performance when used with any other file system.</P>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The intent of this technote is to tell how to                  use the File Manager API to improve the performance                  of file I/O, not to describe in detail the                  processes and steps taken by the file system to                  perform file I/O. Thus, the descriptions of the                  processes and steps taken by the file system to                  perform file I/O are much simpler than what                  actually take place.</P></TD></TR></TABLE></CENTER><BR>                                                                     <P>Each time you read or write data to a file, a file system         must perform several steps which ultimately end up         transferring data between your buffer and the disk. For the         purposes of this technote,         we'll divide that time up into two categories: data transfer         time and request overhead time. The first step to improving         file I/O performance is to reduce the amount of request</p>      <P><A HREF="#top">Back to top</A></P>         <A NAME="Section2"></A>                  <H2>Increase the Size of I/O Requests</H2>                  <P>The size of your read and write requests can make more         difference to file I/O performance than any other factor         under your control. Here's why:</P>                  <UL>            <LI>Each request will incur some request overhead time.</li>                        <LI>Each request will involve one or more calls to a disk            driver through the file system cache, or to a network            device through a network driver.</li>                        <LI>Each request may cause one or more data transfers            from the disk driver and the disk device, or the network            driver and network device. A device access may be very            fast (reading data from or writing data to a disk            device's or disk driver's cache), or very slow (waiting            for a stopped floppy disk drive to come up to speed and            then reading or writing the data).</li>         </UL>                  <P>Let's look at an example: reads from a fast (by the         standards of the time this technote was written) SCSI hard disk         drive with an average access time of approximately 10         milliseconds and a Power Macintosh class system with a SCSI         transfer rate of approximately 5 megabytes per second or 0.1         milliseconds per 512-byte disk block. When a single disk         block (512 bytes) is read, the time spent reading the block         looks like that shown in Figure 1.</P>                  <P ALIGN=CENTER><img src="images/fl_16_001.gif" width=448 height=112 align=bottom alt="fl_16.1.gif"></P>                  <P ALIGN=CENTER><B>Figure 1.</B> One block transfer with 10 ms         average access time</P>                  <P>The overhead time on this single block read is over 99%         of the total time, giving you a throughput of 49.5K per         second (that's about half the transfer rate of a SuperDrive         floppy disk drive!). However, when the size of the read is         increased to 450K (Figure 2), the overhead time is reduced         to approximately 10% of the total time. That's because the         overhead remains essentially the same while the total number         of bytes transferred increases. This change makes the         adjusted throughput for this transfer 4.5 megabytes per         second.</P>         <P ALIGN=CENTER><img src="images/fl_16_002.gif" width=448 height=112 align=bottom alt="fl_16.2.gif"></P>                  <P ALIGN=CENTER><B>Figure 2.</B> 900 block transfer with 10 ms         average access time</P>                  <P>If you were to make a graph comparing the size of your         I/O requests to the throughput of that request, you'd see a         curve like that shown in Figure 3.</P>                  <P ALIGN=CENTER><img src="images/fl_16_003.gif" width=352 height=180 align=bottom alt="fl_16.3.gif"></P>                  <P ALIGN=CENTER><B>Figure 3.</B> Size of transfer versus         throughput of transfer</P>                  <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>By increasing the size of your I/O requests, you                  can maximize your usage of the device's ideal                  throughput. DTS strongly                  recommends an I/O size of at least 4 KB. 16 KB is                  better. 64 KB is even better, although it's                  approaching the point of diminishing                  returns.</P></TD></TR></TABLE></CENTER><BR>                                                         <P>One last note on the size of I/O requests.<B> </B>In some         cases, you may actually want to limit the size of your I/O         requests. For example, large reads and writes to a file over         a slow network connection may make it look like the system         has locked up to the users of your program. Your program can         use the <CODE>vmVolumeGrade</CODE> field of the         <CODE>GetVolParmsInfoBuffer</CODE> structure (returned by         <CODE>PBHGetVolParms</CODE>) to scale the size of its I/O         requests for a particular volume's speed. See DTS Technote         1121         <a href="../tn/tn1121.html#Finder%208.1">Mac         OS 8.1</A> for more information about how the Finder uses         this field.</p>     <P><A HREF="#top">Back to top</A></P>         <A NAME="Section3"></A>                  <H2>Block Align I/O Requests</H2>                  <P>After increasing the size of your I/O requests, the next         thing you should look at is the block alignment of your         requests.</P>                  <P>When reading from or writing to a file on file systems         that use block devices, data is read or written in complete         disk blocks. When a read or write begins or ends in the         middle of a disk block, the file system must read that         entire block into a buffer owned by the file system (a cache         buffer) and then move data to or from your application's I/O         buffer. The worst case is a write that doesn't begin or end         on a block boundary, but is large enough to write one or         more full blocks.</P>                  <P>For example, here are the steps the HFS Plus file system         must take to write 2048 bytes starting at offset 50 in the         file:</P>                  <OL>            <LI>Read the first block of the file into a file system            cache buffer.<BR>                        <img src="images/fl_16_004.gif" width=448 height=70 align=bottom alt="fl_16.4.gif"></li>                        <LI>Copy 462 bytes from the application's I/O buffer into            the cache buffer starting at offset 50.<BR>                        <img src="images/fl_16_005.gif" width=448 height=70 align=bottom alt="fl_16.5.gif"></li>                        <LI>Write the cache buffer containing the first block of            the file back to the disk.<BR>                        <img src="images/fl_16_006.gif" width=448 height=70 align=bottom alt="fl_16.6.gif"></li>                        <LI>Write 1536 bytes from the application's I/O buffer to            the second through fourth blocks of the file.<BR>                        <img src="images/fl_16_007.gif" width=448 height=70 align=bottom alt="fl_16.7.gif"></li>                        <LI>Read the fifth block of the file into a file system            cache buffer.<BR>                        <img src="images/fl_16_008.gif" width=448 height=82 align=bottom alt="FL_16.8.gif"></li>                        <LI>Copy 50 bytes from the application's I/O buffer into            the cache buffer starting at offset&nbsp;0.<BR>                        <img src="images/fl_16_009.gif" width=448 height=82 align=bottom alt="fl_16.9.gif"></li>                        <LI>Write the cache buffer containing the fifth block of            the file back to the disk.<BR>                        <img src="images/fl_16_010.gif" width=448 height=70 align=bottom alt="fl_16.10.gif"></li>         </OL>                  <P>By not block aligning your I/O, your program's single         non-block aligned write request generated two read request         and three write requests to the disk driver. The extra two         reads and two writes increased the request overhead time by         400%. If the same size write request started at offset 0 in         the file, then there would have been only one write to the         disk driver.</P>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>If you make your reads and writes start on a                  512-byte boundary and read or write in multiples of                  512-bytes, you'll avoid extra read and write                  requests and the request overhead time they                  generate. For even better                  results, align your I/O to 4 KB boundaries.</P></TD></TR></TABLE></CENTER><BR>                  <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Why is 4 KB alignment better than 512 byte                  alignment? On traditional Mac OS alignment beyond                  512 bytes is irrelevant. However, the Mac OS X file                  system is closely tied with the virtual memory                  system, and the virtual memory system uses a 4 KB                  page size. If you transfer data in 4 KB or larger                  requests and align those requests on 4 KB                  boundaries, you will get the best performance from                  the Mac OS X file system. This technique will also                  perform well on current and future traditional Mac                  OS File Manager implementations.</P></TD></TR></TABLE></CENTER><BR>                                                      <P>While this note does not                  cover all possible Mac OS X file system performance                  optimizations, this advice is sufficiently simple                  that it's worth covering here.</P>              <A NAME="NewCacheInfo"></A>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  One particularly interesting case of unaligned I/O                  occurs when you copy a file. A typical file copy                  algorithm is shown below.</P>                  </TD></TR></TABLE></CENTER><BR>                                   <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>on copyFile source, dest  set bytesRemaining to size of source  while bytesRemaining &gt; 0 do    if bytesRemaining &gt; size of buffer      set bytesThisTime to size of buffer    else      set bytesThisTime to bytesRemaining    end-if    read bytesThisTime from source into buffer    write bytesThisTime from buffer into dest    set bytesRemaining to bytesRemaining - bytesThisTime  end-while</pre>	</TD></TR></TABLE></CENTER>                  <P>If the size of the copy                  buffer is a multiple of 512 bytes, this algorithm                  does all of its I/O aligned on block boundaries and                  is very efficient. However, the last transfer can                  cause a loss of efficiency. If the source file is                  not an even multiple of 512 bytes long, the last                  write will often result in two disk operations. The                  first disk operation will write the bytes in the                  buffer that even fit into 512-byte blocks. The                  remaining bytes in the buffer will be placed in a                  disk cache block and will eventually be written in                  a separate disk I/O when that cache block is                  flushed. If you are copying a lot of files, these                  cache block flushes can represent a significant                  overhead.</P>                                    <P>One interesting workaround                  is to round up the last write to the nearest                  512-byte boundary -- which actually writes extra                  data to the end of the file -- and then call                  <CODE>SetEOF</CODE> to trim off the extra bytes. The                  exact algorithm is too complex to show here (for                  example, it only makes sense to do this on                  non-network volumes), but it is codified in the                  <a href="http://developer.apple.com/samplecode/Sample_Code/Files/MPFileCopy.htm">MPFileCopy</A> sample code.</P>               <P><A HREF="#top">Back to top</A></P>         <A NAME="Section4"></A>                  <H2>File System Cache Control</H2>                  <P>Next, you should look at how your programs use the data         they read and write.</P>                  <P>The File Manager's cache is a buffer in RAM memory that         holds recently accessed disk blocks. When data is read from the disk into the         cache, subsequent accesses to those disks blocks can come         from the cache instead of causing additional disk accesses.         When data is written into the cache instead of going         directly to the disk, subsequent writes to the same disk         block won't cause an additional writes to those disk         blocks. (Cache blocks that contain different data         than the disk block they are associated with are "dirty"         cache blocks.) When used this way, the cache can greatly         improve the performance of your file I/O.</P>                  <P>However, the File Manager's cache doesn't know <I>how</I> the         data in the cache is going to be used. When the File         Manager sends multi-block file I/O requests through the         cache, it always caches the blocks unless the size of the         request is very large or unless it's told not to in the read         or write request. The cached blocks stay in the cache until         they are reused, until the file is closed, or until the         volume is put offline, ejected, or unmounted.</P>                  <P>Unless you do something about it, <I>reads and writes         that have no reason to be cached will be cached</I> and that         can cause increases in request overhead two ways: cached I/O         requests have more request overhead and cached I/O requests         can force other more useful cached data out of the cache.         </P>                  <P>Cached I/O request overhead can be minimal as in the case         where the request is small enough to use only unused blocks         in the cache. Or, the request overhead can be very large as         in the case where all of the blocks in the cache are in use         and dirty, and must be flushed to the disk before they can         be reused.</P>                  <P>Cached I/O requests can force other more useful cached         data out of the cache. As an example, if you fill the cache         with data blocks from your file (that you won't be using         again in the near future), then cached catalog and volume         information used by the HFS Plus file system is flushed out         of the cache. The next time the HFS Plus file system needs         to read the catalog, it will have to flush your cached         blocks out of the cache just to reload the data it needs.         </P>                       <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>By following the following simple guidelines, most                  applications can avoid both of these problems and                  increase the file system performance for everyone.</P></TD></TR></TABLE></CENTER><BR>                        <UL>                     <LI>You should cache reads and writes if you                     read or write the same portion of a file                     multiple times.</li>                                          <LI>You should not cache reads and writes if you                     read or write data from a file only once.</li>                  </UL>                        <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Warning:</B><BR>                   An older version of this technote recommended                  manipulating the low-memory global                  <CODE>CacheCom</CODE> to control the File Manager's                  cache. This method should be avoided because:</P>                                    <UL>                     <LI><CODE>CacheCom</CODE> is no longer supported                     on Power Macintosh systems for native                     applications (it isn't in "LowMem.h") and it                     won't be supported by future versions of the                     File Manager.</li>                                          <LI><CODE>CacheCom</CODE> affects the system                     globally. That means that your code affects all                     other running programs that read or write and                     that's not a friendly thing to do in a                     multi-process environment.</li>                  </UL></TD></TR></TABLE></CENTER><BR>                        <P>So, how do you control what gets cached and what doesn't?         In a <code>PBRead</code> or <code>PBWrite</code> request, bits 4 and         5 of <code>ioPosMode</code> are cache usage hints passed on to         the file system that handles requests to the volume the file         is on (the cache control bits are also documented on pages         2-89 and 2-95 of <I><cite>Inside Macintosh: Files</cite> </I>and in DTS Technote 1041 <a href="../tn/tn1041.html">Inside         Macintosh--Files Errata</A>). Bit 4         (<CODE>pleaseCacheBit</CODE>) is a request that the data be         cached. Bit 5 (<CODE>noCacheBit</CODE>) is a request that         the data not be cached. Bits 4 and 5 are mutually exclusive         -- only one should be set at a time. However, if neither is         set, then the program has indicated that it doesn't care if         the data is cached or not.</P>                  <TABLE BORDER=1>            <TR>               <TH WIDTH=120>                  <P ALIGN=LEFT>Bit                  Number</p>               </TH><TH WIDTH=160>                  <P ALIGN=LEFT>Bit Mask</p>                              </TH><TH>                  <P ALIGN=LEFT>Description</p>               </TH></TR>            <TR>               <td valign=top width=120 align=left><P>                  n/a</p>               </TD><td valign=top width=160 align=left>                  0x0000               </TD><td valign=top align=left>                  I don't care if this                  request is cached or not cached.               </TD></TR>            <TR>               <td valign=top width=120 align=left>                  <CODE>pleaseCacheBit</CODE> (4)               </TD><td valign=top width=160 align=left>                  <CODE>pleaseCacheMask</CODE> (0x0010)               </TD><td valign=top align=left>                  Cache this request if                  possible.               </TD></TR>            <TR>               <td valign=top width=120 align=left>                  <CODE>noCacheBit</CODE> (5)               </TD><td valign=top width=160 align=left>                  <CODE>noCacheMask</CODE> (0x0020)               </TD><td valign=top align=left><P>                  I'd rather you didn't                  cache this request.</P>               </TD></TR>         </table><BR>                <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> A particular file system (HFS Plus, AppleShare,                  ISO-9660, and so on) may choose to ignore one or                  both of the cache usage hint bits. For example, the                  HFS Plus file system ignores bit 4. File systems                  may cache when you set bit 5, may not cache when                  you set the bit 4, may cache everything, or may                  cache nothing. However, if a program leaves both                  bits clear, then file systems which <I>do</I>                  respect the cache hint bits have no way of knowing                  if the data being read or written will be needed                  again by your program.</P></TD></TR></TABLE></CENTER><BR>         <P>The following high-level functions         show how to read and write with the no cache hint bit turned         on. These routines were taken from the <a href="http://developer.apple.com/samplecode/Sample_Code/Files/MoreFiles.htm">MoreFiles</A> sample code.</P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal  OSErr   FSReadNoCache(short refNum,                              long *count,                              void *buffPtr){    ParamBlockRec pb;    OSErr error;&nbsp;    pb.ioParam.ioRefNum = refNum;    pb.ioParam.ioBuffer = (Ptr)buffPtr;    pb.ioParam.ioReqCount = *count;    pb.ioParam.ioPosMode = fsAtMark + noCacheMask;    pb.ioParam.ioPosOffset = 0;    error = PBReadSync(&amp;pb);    *count = pb.ioParam.ioActCount;       /* always return count */    return ( error );}&nbsp;pascal  OSErr   FSWriteNoCache(short refNum,                               long *count,                               const void *buffPtr){    ParamBlockRec pb;    OSErr error;&nbsp;    pb.ioParam.ioRefNum = refNum;    pb.ioParam.ioBuffer = (Ptr)buffPtr;    pb.ioParam.ioReqCount = *count;    pb.ioParam.ioPosMode = fsAtMark + noCacheMask;    pb.ioParam.ioPosOffset = 0;    error = PBWriteSync(&amp;pb);    *count = pb.ioParam.ioActCount;       /* always return count */    return ( error );</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>         <A NAME="Section5"></A>                  <H2>Cached I/O versus Data Integrity</H2>                  <P>The File Manager's cache can increase the performance of         certain I/O operations. However, it does open a window of         time where data can be lost if a system crashes. If the         system crashes when cache blocks hold data that hasn't been         flushed to disk (dirty blocks), the data in the cache is         lost. That can cause lost file data, or can cause volume         catalog corruption problems.</P>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>In Mac OS 7.6 the disk cache was modified to                  periodically flush dirty blocks if the disk is                  idle. See DTS Technote 1090                  <a href="../tn/tn1090.html#FileManager">Mac                  OS 7.6</A> for details.</P></TD></TR></TABLE></CENTER><BR>                                                  <P><B>Flushing Files and Volumes</B></P>                  <P>The File Manager provides routines you can use to flush         cached file and volume blocks to disk. When a file or volume         is flushed, the dirty cache blocks associated with the file         or volume are written to disk. However, indiscriminate         flushing can affect performance, so an understanding of what         the flush calls actually do is an important part of using         the flush calls correctly.</P>                  <UL>            <LI><CODE>PBFlushFile</CODE> flushes an open file fork's            dirty cached data blocks, but may not flush catalog            information associated with the file. To ensure data            written to a file with <CODE>PBWrite</CODE> or            <CODE>FSWrite</CODE> is flushed to the volume, use            <CODE>PBFlushFile</CODE>.</li>                        <LI><CODE>PBFlushVol</CODE> flushes all open files on the            volume, and then, flushes all volume data structures. So            to ensure all changes to a volume, including the volume's            catalog and block allocation information, are flushed to            the volume, use <CODE>PBFlushVol</CODE>.</li>         </UL>                  <P>In addition to handling to <CODE>PBFlushFile</CODE> and         <CODE>PBFlushVol</CODE> requests, the file system flushes         files and volumes at other times:</P>                  <UL>            <LI>When a file fork is closed, the file is first flushed            and then, all cache blocks associated with the file are            removed from the cache. You don't need to flush a file            before closing it.</li>                        <LI>When a volume is unmounted, ejected, or put offline,            the volume is first flushed and then, all cache blocks            associated with the volume are removed from the cache.            You don't need to flush a volume before unmounting it,            ejecting it, or putting it offline.</li>         </UL>                  <P><B>File Block Preallocation</B></P>                  <P>Preallocating the space for a file can keep the file and         the volume from being fragmented. Accessing the data in an         unfragmented file will be         faster. The File Manager's <CODE>Allocate</CODE> and         <CODE>AllocContig</CODE> functions allow you to allocate         additional space to an open file. However, there are two         important points to note:</P>                  <UL>            <LI>The space allocated with <CODE>Allocate</CODE> and            <CODE>AllocContig</CODE> is not permanently assigned to            that file until the file's logical EOF is changed to            include the allocated space. You can use            <CODE>SetEOF</CODE> to change the file's logical EOF to            include the allocated space. When a file (or volume) is            flushed or closed, the space beyond the file's logical            EOF is made available for other purposes.</li>                        <LI><CODE>Allocate</CODE> and <CODE>AllocContig</CODE>            are not supported by all file systems. For example,            remote volumes mounted by the AppleShare file system do            not support <CODE>Allocate</CODE> and            <CODE>AllocContig</CODE>. To allocate space for a file on            any volume, use <CODE>SetEOF</CODE>.</li>         </UL>                  <P><B>A Simple Example of Balancing Cached I/O Performance         and Data Integrity</B></P>                  <P>Given the information just provided, you should be able         to use the flush calls along with preallocating space for         your file to ensure that your data is safely on a disk         without incurring performance penalties during your I/O         operations. However, a small commented example can't hurt,         so...</P>                           <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum{    /*    **  Set kMaxWrite to the largest amount of data your write proc will    **  write in one call. Then, set kMinWritesPerAllocate to the minimum    **  number of writes you want before more space is allocated.    */    kMaxWrite             = 0x10000,    kMinWritesPerAllocate = 4};&nbsp;/*****************************************************************************/&nbsp;/***    Prototype for the routine that writes data to a file.**    Your write procedure can make sure data is really written to disk by**    calling PBFlushFile, or you can block-align your requests and set the**    noCache ioPosMode bit in your calls to PBWrite (with the HFS file system,**    block-aligned requests with the noCache bit set are not cached).*/typedef pascal OSErr (*WriteProcPtr) (short refNum, Boolean *doneWriting,                                      void *yourDataPtr);&nbsp;/*****************************************************************************/&nbsp;/***    MoreSpace checks to see if more space should be allocated to an**    open file based on the current position and the current EOF and**    if so, then allocates the space by extending the EOF.**    If more space is allocated, the volume is flushed to ensure**    the additional space is recorded in the catalog file on disk.*/OSErr    MoreSpace(short    refNum, short vRefNum){    OSErr    result;    long    filePos, logEOF;    result = GetFPos(refNum, &amp;filePos);    if ( result == noErr )    {        result = GetEOF(refNum, &amp;logEOF);        if ( (result == noErr) &amp;&amp; ((logEOF - filePos) &lt;= kMaxWrite) )        {            result = SetEOF(refNum, logEOF + (kMaxWrite * kMinWritesPerAllocate));            if ( result == noErr )            {                result = FlushVol(NULL, vRefNum);            }        }    }    return ( result );}&nbsp;/*****************************************************************************/&nbsp;/***    Simple example of creating and writing to a file.*/OSErr    SafeWriteFile(const WriteProcPtr writeProc, void *yourDataPtr){    OSErr              result;    Str255             prompt       = &quot;\pSave this document as:&quot;;    Str255             defaultName  = &quot;\puntitled&quot;;    StandardFileReply  reply;    OSType             creator      = '????';    OSType             fileType     = 'TEXT';    short              refNum;    Boolean            doneWriting;    long               filePos;    StandardPutFile (prompt, defaultName,&amp; reply);    if ( reply.sfGood )    {        if ( reply.sfReplacing )        {            /* Delete old file */            (void) FSpDelete(&amp;reply.sfFile);        }        result = FSpCreate(&amp;reply.sfFile, creator, fileType, reply.sfScript);        if ( result == noErr )        {            result = FSpOpenDF(&amp;reply.sfFile, fsRdWrPerm, &amp;refNum);            if ( result == noErr )            {                /*                **    Preallocate some space and flush the volume.                **                **    Flushing the volume here makes sure the newly                **    created file in the catalog file is flushed to                **    disk and makes sure the space preallocated for                **    file data is allocated on disk.                */                result = MoreSpace(refNum, reply.sfFile.vRefNum);                /*                **    Write file in pieces until we're done writing, or until                **    an error occurs.                */                doneWriting = false;                while ( (result == noErr) &amp;&amp; !doneWriting )                {                    result = (*writeProc) (refNum, &amp;doneWriting, yourDataPtr);                    if ( result == noErr )                    {                        if ( !doneWriting )                        {                            /*                            **    We're not done writing. Check allocated space,                            **    then allocate more space and flush the volume                            **    (to make sure the space is really allocated                            **    on disk) if needed.                            */                            result = MoreSpace(refNum, reply.sfFile.vRefNum);                        }                        else                        {                            /*                            **    We're done writing. Truncate file to current                            **    file position.                            */                            result = GetFPos(refNum, &amp;filePos);                            if ( result == noErr )                            {                                result = SetEOF(refNum, filePos);                            }                        }                    }                }                /*                **    Close the file (which flushes the file) and then                **    flush the volume to ensure the file's final EOF                **    is written to the volume catalog.                */                (void) FSClose(refNum);                (void) FlushVol(NULL, reply.sfFile.vRefNum);            }        }    }    return ( result );</pre>	</TD></TR></TABLE></CENTER>                  <P>As shown in the example above:</P>                  <UL>            <LI>If changes are made to space that already exists in a            file (you are overwriting existing data before the file's            EOF), <CODE>PBFlushFile</CODE> will ensure everything            written to the file is written to disk. In this case, the            only possible data loss in a system crash will be the            file's modification date.</li>                        <LI>If changes are made to a file that affect the file's            EOF, the file's name, the file's Finder information, or            the file's location on the volume, then            <CODE>PBFlushVol</CODE> must be used to ensure the            changes to the file are written to disk.</li>         </UL>      <P><A HREF="#top">Back to top</A></P>         <A NAME="Summary"></A>                  <H2>Summary</H2>                  <P>To get the best performance from         the Mac OS File Manager, you should:</P>                  <UL>            <LI>buffer data so that transfers            are 4 KB or larger,</li>                        <LI>align all transfers to at least            512-byte boundaries (better yet 4 KB), and</li>                        <LI>disable caching on requests            where you will be only looking at the data once.</li>         </UL>                  <P>In addition, you may want to examine how and why you         flush files or volumes, and preallocate space for new files.         </P>                  <P>There are other useful techniques not discussed in this         technote that you may want to         consider.</P>                  <UL>            <LI>You could implement your own buffering scheme above            the File Manager. For example, the file stream libraries            supplied by many object-oriented development environments            allow you to perform file I/O using a pointer or handle            to a RAM buffer.</li>                        <LI>You can use asynchronous read or writes that overlap            with other non-File Manager operations, allowing your program to do            something besides show the watch cursor while file I/O is            performed. For example, the article, "Concurrent            Programming with the Thread Manager" in <I>develop</I>            issue #17 shows how to perform asynchronous I/O in            cooperative threads.</li>         </UL><P><A HREF="#top">Back to top</A></P><a name="References"></a><H2>References</H2>            <p><a href="http://developer.apple.com/documentation/mac/Files/Files-2.html">Inside            Macintosh: Files</A></p>                        <p>DTS Technote 1041            <a href="../tn/tn1041.html">Inside            Macintosh--Files Errata</A></p>                        <p>DTS Technote 1090            <a href="../tn/tn1090.html">Mac            OS 7.6</A></p>                        <p>DTS Technote 1121            <a href="../tn/tn1121.html#Finder%208.1">Mac            OS 8.1</A></p>                        <p><a href="http://developer.apple.com/dev/techsupport/develop/bysubject/toolbox.html">Asynchronous            Routines on the Macintosh</A>, Jim Luther, <I>develop</I>            Issue 13</p>                        <p><a href="http://developer.apple.com/dev/techsupport/develop/bysubject/toolbox.html">Concurrent            Programming with the Thread Manager</A>, Eric Anderson            and Brad Post, <I>develop</I> Issue 17</p>                        <p><a href="http://developer.apple.com/samplecode/Sample_Code/Files/MoreFiles.htm">MoreFiles</A>            sample code</p>                        <p><a href="http://developer.apple.com/samplecode/Sample_Code/Files/MPFileCopy.htm">MPFileCopy</A>            sample code</p>               <P><A HREF="#top">Back to top</A></P><P>&nbsp;<A NAME=changes></A></P>                  <H2>Change History</H2>                  <P>Add this section if there are changes. If you're writing         a new technote, then you can remove this section.</P>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-June-1986</P>               </TD>               <td align="left">                  <P>Originally written.</P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-March-1988</P>               </TD>               <td align="left">                  <P>Completely rewritten.</P>               </TD>            </TR>             <TR>               <td width=100 align=left>                  <P ALIGN=center>01-April-1995</P>               </TD>               <td align="left">                  <P>Revised.</P>               </TD>            </TR>                 <TR>               <td width=100 align=left>                  <P ALIGN=center>01-August-2000</P>               </TD>               <td align="left">                  <P>Updated to include a   specific hint about <A HREF="#NewCacheInfo">avoiding extra disk writes   while copying files</A>. Also made   numerous minor updates and cosmetic changes.</P>               </TD>            </TR>            </table>            <BR>            <P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (312K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/fl_16.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/fl/fl_16.html%3Fid%3DDTS10002442-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/fl/fl_16.html%3Fid%3DDTS10002442-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/fl/fl_16.html%3Fid%3DDTS10002442-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --><hr width=500 align=center></BODY></HTML>