<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html><head>
<!-- BEGIN META TAG INFO -->
<link rel="home" href="http://developer.apple.com/">
<link rel="find" href="http://developer.apple.com/search/">
<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
<script language="JavaScript" type="text/javascript" src="../../documentation/js/busnav.js"></script>
<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- END META TAG INFO -->
<!-- BEGIN TITLE -->
<title>Technical Note TN2185: C++ Tips and Tricks for Mac OS X</title>
<!-- END TITLE -->
</head>
<!-- BEGIN BODY OPEN -->
<body bgcolor="#ffffff"><a name="//apple_ref/doc/uid/DTS10004200" title="C++ Tips and Tricks for Mac OS X"></a>
<!--END BODY OPEN -->
<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->
<a name="top"></a>
<!-- BEGIN LOGO AND SEARCH -->
<!--#include virtual="/includes/adcnavbar"-->
<!-- END LOGO AND SEARCH -->
<!-- START BREADCRUMB -->
<div id="breadcrumb"><table width="680" border="0" cellpadding="0" cellspacing="0"><tr>
<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
<td><img width="340" height="10" src="images/1dot.gif" alt=""></td></tr><tr valign="middle"><td align="left" colspan="2">
<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/DeveloperTools/index.html">Tools</a> &gt; <a href="../../technicalnotes/DeveloperTools/idxCompilersDebuggers-date.html">Compiling & Debugging</a> &gt; 
</td></tr><tr><td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td></tr></table></div>
<!-- END BREADCRUMB -->

<!-- START MAIN CONTENT -->
<!-- START TITLE GRAPHIC AND INTRO-->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top">
<td><h1>
<div id="pagehead">Technical Note TN2185</div>
<div id="pageheadsub">C++ Tips and Tricks for Mac OS X</div>
</h1></td></tr></table>
<!-- END TITLE GRAPHIC AND INTRO -->
<!-- BEGIN WIDE COLUMN -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td align="left" width="680">
<!-- BEGIN CONTENTS -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td><p>Valuable points of interest for the C++ programmer</p></td></tr><tr><td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td width="680"><ul><li><a href="#TNTAG1">Introduction</a></li><li><a href="#TNTAG8">Choosing Visibility Options</a><ul><li><a href="#TNTAG9">Command Line Options for Visibility</a></li><li><a href="#TNTAG10">Setting Visibility With Pragmas</a></li><li><a href="#TNTAG11">Setting Visibility With Attributes</a></li><li><a href="#TNTAG12">Hiding Symbols With Export Lists</a></li><li><a href="#TNTAG13">Summing Symbol Visibility Up</a></li></ul></li><li><a href="#TNTAG2">Choosing an Xcode Template</a><ul><li><a href="#TNTAG3">The Application Templates</a></li><li><a href="#TNTAG4">Generic C++ Plugin</a></li><li><a href="#TNTAG5">C++ Command Line Tool</a></li><li><a href="#TNTAG6">Dynamic Library</a></li></ul></li><li><a href="#TNTAG7">Overriding new/delete</a></li><li><a href="#TNTAG14">The Strong Attribute for Namespace Using Declarations</a></li><li><a href="#TNTAG15">Using Namespaces to Manage Versions</a></li><li><a href="#TNTAG16">Which std C++ symbols are set in stone, and which aren't (ABI issues)</a></li><li><a href="#TNTAG17">How Best to Strip</a></li><li><a href="#TNTAG18">Using basic_string Instantiations Other Than string and wstring With libstdc++</a></li><li><a href="#TNTAG19">Release-to-Release Version Compatibility of Shared Libraries Using C APIs and C++ Implementations</a></li><li><a href="#TNTAG20">Release-to-Release Version Compatibility of Shared Libraries Using C++ APIs and C++ Implementations</a></li><li><a href="#TNT_HISTORY_TAG">Document Revision History</a></li></ul></td></tr><tr><td colspan="3" scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><A NAME="TNTAG1"></A><H2>Introduction</H2><p>This document seeks to ease the task of bringing modern, complex C++ Mach-O applications to Mac OS X. It addresses several issues which commonly arise with some helpful suggestions. While by no means a complete reference, it should get the perplexed C++ developer heading in the right direction, and equipped with the ability to find more in-depth information if necessary.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG8"></A><H2>Choosing Visibility Options</H2><p>In GCC visibility is akin to what other tools refer to as dynamic library import/export. However GCC symbols are either visible or hidden. The visible symbols are your shared library entry points. More detailed information is available at  <A HREF="../../documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html">Controlling Symbol Visibility</A>. Only a brief summary is offered here.</p><p>In C, it is relatively simple to decide which symbols need to be visible, and which hidden. The shared library entry points must be visible, and everything else can be hidden. In C++, many more definitions are found in header files instead of source files. C++ header files can contain both interface and private implementation details. Examples include templates (both class and function), class declarations, and inline functions (both member and non-member).</p><p>There are four techniques for declaring visibility:</p><ol><li><p>Command line options (e.g. <code>-fvisibility=hidden</code>)</p></li><li><p>pragmas</p></li><li><p>Attribute declarations on individual types and functions</p></li><li><p><code>Export/unexport</code> lists</p></li></ol><p>It is important to understand the role of each of these techniques and how they interact with each other. The first three techniques declare visibility at compile time. The fourth is a link time operation. Export lists can hide a symbol which the compiler marked visible, but one can not use export lists to make visible a symbol which the compiler has marked hidden.</p><A NAME="TNTAG9"></A><H3>Command Line Options for Visibility</H3><p>The visibility command line options are useful for setting the visibility defaults. This can be especially helpful when dealing with source code which is third party, or otherwise for some reason not practical to decorate with attributes or pragmas. If you do not specify a command line visibility option then symbols will be marked visible (unless overridden by one of the other three techniques). You can make this choice of default visibility explicit by placing the following on your command line:</p><pre class="sourcecodebox">
    -fvisibility=default
</pre><p>Specifying <code>-fvisibility=hidden</code> on the command line marks all symbols as hidden (unless overridden by pragmas or attributes - export lists can not make a hidden symbol visible).</p><p>There are two other visibility-related command options one may find useful:</p><ol><li><p>Use <code>-fvisibility-inlines-hidden</code> to declare that there will be no attempt to compare pointers to inlined member functions where the addresses of the two member functions were taken in different linkage units.</p><p>For many applications, <code>-fvisibility-inlines-hidden</code> is a safe and easy way to hide many symbols which in turn improves load time. The dynamic linker (at load time) does much more work for visible symbols than for hidden ones.</p><p>The behavior of this switch is not quite the same as marking the member function as hidden directly, because it does not affect static variables local to the function or cause the compiler to deduce that the function is defined in only one linkage unit. Any local statics will assume whatever visibility setting is in effect independent of this command line switch.</p><div class="notebox"><p><strong>Note:</strong> </p><ul><li><p><code>-fvisibility-inlines-hidden</code> has no effect when <code>-fvisibility=hidden</code> is also on the command line.</p></li><li><p><code>-fvisibility-inlines-hidden</code> has no effect on non-member inline functions.</p></li><li><p>Do not use <code>-fvisibility-inlines-hidden</code> if you compare pointers to inlined member functions across shared library boundaries.</p></li></ul></div></li><li><p><code>-fvisibility-ms-compat</code> sets the default visibility to hidden, except for the <code>type_info</code> data associated with types. The impact of this is to emulate the linkage model of Microsoft Visual Studio. Comparing types is important for catching exceptions, <code>dynamic_cast</code>, and comparing <code>type_info</code>'s obtained by a <code>typeid</code> expression.</p><div class="notebox"><p><strong>Note:</strong> </p><ul><li><p><code>-fvisibility=hidden</code> has no effect when <code>-fvisibility-ms-compat</code> is also on the command line.</p></li><li><p><code>-fvisibility-inlines-hidden</code> has no effect when <code>-fvisibility-ms-compat</code> is also on the command line.</p></li><li><p>Use of <code>-fvisibility-ms-compat</code> can cause two implementation detail classes which were independently developed within different shared libraries to accidently be mistaken for the same type.</p></li><li><p>The <code>-fvisibility-ms-compat</code> flag will hide any static data members of types, giving each linkage unit private copies (unless said data is otherwise marked visible).</p></li></ul></div></li></ol><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG10"></A><H3>Setting Visibility With Pragmas</H3><p>One can control the visibility of individual symbols or groups of symbols with the use of pragmas. Such use will make the visibility of the affected symbols independent of visibility command line options, and thus potentially make the source code more robust from a maintenance point of view.</p><p>To set the compiler's default mode to visible:</p><pre class="sourcecodebox">#pragma GCC visibility push(default)</pre><p>To set the compiler's default mode to hidden:</p><pre class="sourcecodebox"> #pragma GCC visibility push(hidden)</pre><p>To undo the last GCC visibility push pragma:</p><pre class="sourcecodebox"> #pragma GCC visibility pop</pre><p>Thus the visibility pragmas form a scope, and one can nest these scopes with the inner most scope providing the dominant effect.</p><div class="notebox"><p><strong>Note:</strong> A common error is to misspell one of the pragmas. This will cause it to silently do nothing unless compiled with <code>-Wunknown-pragmas</code> (which warns of unknown (misspelled) pragmas).</p><p>To control the visibility of the compiler's meta-data for a type (e.g. <code>type_info</code>) surround the type declaration:</p><pre class="sourcecodebox">
    #pragma GCC visibility push(default)

    class MyType
    {
        // ...
    };

    #pragma GCC visibility pop

</pre></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG11"></A><H3>Setting Visibility With Attributes</H3><p>One can control the visibility of individual symbols of attributes. This links the visibility of the declaration with the declaration itself, making it independent of both command line options, and pragmas. This technique makes it less error prone to move code from place to place with respect to visibility.</p><p>For example, to mark a function as visible:</p><pre class="sourcecodebox">  __attribute__((__visibility__(&quot;default&quot;))) void MyFunction1() {}</pre><p>And to mark a function as hidden:</p><pre class="sourcecodebox">__attribute__((__visibility__(&quot;hidden&quot;))) void MyFunction2() {}</pre><p>You may find it convenient to create macros for your application which encompass these visibility details. Such macros may make it easier to port your code to other environments which either do not have a visibility concept, or where the visibility specification has other syntax. For example:</p><pre class="sourcecodebox">
    #define PUBLIC  __attribute__((__visibility__(&quot;default&quot;)))
    #define PRIVATE __attribute__((__visibility__(&quot;hidden&quot;)))

    PUBLIC  void MyFunction1() {}
    PRIVATE void MyFunction2() {}
</pre><p>One can mark a <code>class</code> or <code>struct</code> like so:</p><pre class="sourcecodebox">
    class PUBLIC MyClass {/*...*/};
</pre><p>The attribute marks not only the <code>type_info</code> data, but also member functions, and static data members. One can also place attributes on the individual member functions of a class (e.g. private members).</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG12"></A><H3>Hiding Symbols With Export Lists</H3><p>The last tool in our tool chest is the export list. This is simply a list of symbols (which must be in mangled form) which tell the linker which symbols you want hidden. There are two forms:</p><ol><li><p>Tell the linker which symbols you want to make visible and hide everything else with <code>-exported_symbols_list $FILENAME</code>.</p><p><strong>Those symbols in the exported_symbols_list must have been marked visible by the compiler or they will be hidden.</strong></p></li><li><p>Tell the linker which symbols to hide with <code>-unexported_symbols_list $FILENAME</code>.</p><p><strong>Those symbols which were marked visible by the compiler and do not appear in the unexported_symbols_list will be visible.</strong></p></li></ol><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG13"></A><H3>Summing Symbol Visibility Up</H3><p>It can be convenient to rely on a combination of the above visibility tools. For example if your library has many symbols which should be hidden, with only a few that should be visible, you may wish to use <code>-fvisibility=hidden</code> and only decorate the source code of those few symbols which need to be visible.</p><p>For those types which you expect to <code>throw</code> or <code>dynamic_cast</code> across a shared library boundary, these types must be marked as visible by one of the above techniques. Failure to do so will result in run time errors such as a <code>catch</code> clause missing a thrown exception. For example.:</p><pre class="sourcecodebox">
    // MyException.h

    class MyException {};

    // shared library:

    #include &quot;MyException.h&quot;

    void my_func()
    {
        throw MyException();
    }

    // Application:

    #include &quot;MyException.h&quot;

    int main()
    {
        try
        {
            my_func();
        }
        catch (MyException&amp;)
        {
            // Catch will miss if MyException is hidden
            // If hidden, the MyException thrown is a different type, than
            //    the MyException referred to in the catch clause.
        }
    }
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG2"></A><H2>Choosing an Xcode Template</H2><p>When choosing &quot;New Project...&quot; in Xcode, there are a wide variety of Xcode templates to choose from. For the C++ developer, which template should you start with? One could start with any of the templates and set everything up yourself. However, if you choose the most relevant template from the beginning, your default settings are more likely to do what you want.</p><p>There are six Xcode templates especially tailored for the C++ developer, spread throughout four application types:</p><ul><li><p>Application</p><ul><li><p>Carbon C++ Application</p></li><li><p>Carbon C++ Standard Application</p></li></ul></li><li><p>Bundle</p><ul><li><p>Generic C++ Plugin</p></li></ul></li><li><p>Command Line Utility</p><ul><li><p>C++ Tool</p></li></ul></li><li><p>Dynamic Library</p><ul><li><p>C++ Dynamic Library</p></li><li><p>C++ Standard Dynamic Library</p></li></ul></li></ul><A NAME="TNTAG3"></A><H3>The Application Templates</H3><p>Choose one of the Carbon Application templates to create a starter C++ application based on the Carbon API. The starter application will display an OS X application window which responds to the usual windowing commands (new, close, minimize, etc.). There is also an example &quot;About&quot; window in this template. The template also demonstrates, in C++ style, how one can catch and customize events, and read from nib files.</p><p>The only difference between &quot;Carbon C++ Application&quot; and &quot;Carbon C++ Standard Application&quot; is the default <A HREF="#TNTAG8">visibility setting</A>. The &quot;Standard&quot; template defaults to visible, while the other template defaults to hidden. When choosing hidden visibility defaults, one must take care when linking to shared libraries that those symbols that must be known across a shared library are explicitly declared visible by using attribute decorations or pragmas. This includes <code>type_info</code> data which is used in the implementation of <code>try/catch</code> and <code>dynamic_cast</code>. Minimization of visible symbols makes ABI stability among linkage units simpler, and also minimizes load time. With the &quot;Standard&quot; template, all of these C++ language features work as expected with no further effort on the part of the developer.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG4"></A><H3>Generic C++ Plugin</H3><p>This project builds a generic C++ template that exposes a C interface, uses the static C++ standard library, and uses Dwarf for debugging.</p><p>This template creates a sample &quot;plug-in&quot; or bundle. This is a shared library that can be loaded and unloaded dynamically throughout the application's lifetime. The example plug-in, by design, exports only a C interface, and throws no exceptions. However it is implemented internally with C++. It has <A HREF="#TNTAG8">hidden visibility</A> by default, and links statically to libstdc++. This enables it to throw and catch exceptions internally, but keep its clients blissfully unaware of that fact.</p><p>The template demonstrates the use of pragmas to mark its C interface visible. It also demonstrates &quot;private headers&quot; which contain C++ declarations which are meant to be used internally only (and are marked with hidden visibility).</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG5"></A><H3>C++ Command Line Tool</H3><p>If you would like to write a simple HelloWorld, or a program that has no graphical user interface (limited to standard C++ console and file I/O), then this is the template to start with. It starts you off with a single main.cpp which only prints &quot;Hello, World!\n&quot;. When built and launched from Xcode, the console output is visible in Xcode's Run Log. This application can also be run from Terminal.app.</p><p>It has <A HREF="#TNTAG8">visibility</A> set to hidden by default. If you would prefer visible for the default, select &quot;Edit Active Target&quot; under the Project menu, type &quot;vis&quot; into the search box of the dialog that comes up, and uncheck &quot;Symbols Hidden by Default&quot; and &quot;Inline Functions Hidden&quot;.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG6"></A><H3>Dynamic Library</H3><p>These templates set up an example dynamic (shared) library. The example includes both a public (visible) interface and private (hidden) internal headers. Like the application templates, the &quot;Standard&quot; template defaults to everything <A HREF="#TNTAG8">visible</A>, while the template without the word &quot;Standard&quot; in the name defaults to hidden visibility.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG7"></A><H2>Overriding new/delete</H2><p>The C++ standard (ISO no. 14882-2003) says that the following 8 signatures can be replaced by client code:</p><pre class="sourcecodebox">
    void* operator new(std::size_t size) throw(std::bad_alloc);
    void* operator new(std::size_t size, const std::nothrow_t&amp;) throw();
    void  operator delete(void* ptr) throw();
    void  operator delete(void* ptr, const std::nothrow_t&amp;) throw();

    void* operator new[](std::size_t size) throw(std::bad_alloc);
    void* operator new[](std::size_t size, const std::nothrow_t&amp;) throw();
    void  operator delete[](void* ptr) throw();
    void  operator delete[](void* ptr, const std::nothrow_t&amp;) throw();
</pre><p>For complete control and portability, if you replace any of these signatures, you should replace all of them. However the default implementation of the array forms simply forward to the non-array forms. If you only replace the four non-array forms, expect the default array forms to forward to your replacements.</p><p>Your replacements will be in effect application wide. Even code in other linkage units (shared libraries) will call your custom <code>new </code> and <code>delete</code>. Throughout the application (all linkage units), there should be only one definition for the replaced <code>new </code> and <code>delete</code>. This will ensure that if memory ownership is transferred across a shared library boundary, it will be deleted correctly.</p><p>In general, shared libraries should not override these operators, unless that is the shared library's only job. Otherwise it becomes likely that an application will link to more than one definition of overridden <code>new/delete</code>.</p><p>In rare circumstances a shared library may find it convenient to have private definitions of these operators. This is done by linking with the -<code>unexported_symbols_list</code> filename flag and placing the following symbols in the <code>unexport file</code>:</p><pre class="sourcecodebox">
    __Znwm
    __Znwm.eh
    __ZnwmRKSt9nothrow_t
    __ZnwmRKSt9nothrow_t.eh
    __ZdlPv
    __ZdlPv.eh
    __ZdlPvRKSt9nothrow_t
    __ZdlPvRKSt9nothrow_t.eh

    __Znam
    __Znam.eh
    __ZnamRKSt9nothrow_t
    __ZnamRKSt9nothrow_t.eh
    __ZdaPv
    __ZdaPv.eh
    __ZdaPvRKSt9nothrow_t
    __ZdaPvRKSt9nothrow_t.eh
</pre><p>In doing so, the author must ensure that memory ownership is not transferred into, or out of, this shared library. Note that memory ownership transfer can happen in subtle ways such as passing reference counted objects (e.g. <code>std::string</code>), throwing exceptions which contain a heap allocated message (e.g. <code>std::runtime_error</code>) or having a resource-allocating constructor inlined, with the corresponding destructor not inlined (or vice-versa).</p><p>Our current tool set has a bug whereby if a translation unit replaces these operators and does not contain a symbol with weak linkage (e.g. an inline function or an implicit template instantiation), then the linker will not find the custom operator <code>new/delete</code>. Most real-world translation units will have weak symbols so this is usually not a problem. However should you be affected by this bug you can add the following line next to your operator definitions:</p><pre class="sourcecodebox">
    __attribute__((__weak__, __visibility__(&quot;default&quot;))) int dummy_weak_symbol_for_new;
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG14"></A><H2>The Strong Attribute for Namespace Using Declarations</H2><p>Consider the following code:</p><pre class="sourcecodebox">
    namespace Acme
    {

    template &lt;class T&gt;
    class V
    {
    };

    template &lt;class T&gt;
    void func1(T&amp;) {}

    template &lt;class T&gt;
    void func2(T&amp;) {}

    } // Acme

    // Acme client

    struct MyType {};

    namespace Acme
    {

    template &lt;&gt;
    class V&lt;MyType&gt;
    {
    };

    }  // Acme

    int main()
    {
        Acme::V&lt;int&gt; v_int;
        func1(v_int);
        Acme::func2(v_int);
        Acme::V&lt;MyType&gt; v_mytype;
        func1(v_mytype);
        Acme::func2(v_mytype);
    }
</pre><p>We have a library named Acme, and a client using it. The client calls functions within the Acme namespace (via argument dependent lookup), and also specializes an Acme template on a client-defined type. All is well.</p><p>Now consider that for some reason, Acme wants to put some of its functionality within a nested namespace of Acme, and then import it into the Acme namespace with a using declaration. The intent is to change the ABI of the library in a controlled manner while holding the API stable (i.e. code recompiled against the new library doesn't have to change, but gets new mangling). Why they might want to do this is covered later:</p><pre class="sourcecodebox">
// Acme library

namespace Acme
{

namespace _1
{

template &lt;class T&gt;
class V
{
};

template &lt;class T&gt;
void func1(T&amp;) {}

}  // _1

using namespace _1;

template &lt;class T&gt;
void func2(T&amp;) {}


} // Acme
</pre><p>This works for most customers, as they can be blissfully ignorant of the nested namespace and continue to just use <code>Acme::V</code> and <code>Acme::func1</code>. But it breaks the client code we showed earlier.</p><pre class="sourcecodebox">
error: specialization of 'template&lt;class T&gt; class Acme::_1::V' in different namespace
</pre><p>I.e. the client can no longer specialize <code>Acme::V&lt;T&gt;</code>. They must instead specialize <code>Acme::_1::V&lt;T&gt;</code>, which is unfortunate because we wanted to make the nested namespace transparent at the API level. However making this change still does not fix everything:</p><pre class="sourcecodebox">
error: 'func2' was not declared in this scope
</pre><p>This error refers to both of the uses of <code>func2</code> in the client's code:</p><pre class="sourcecodebox">
func2(v_int);
func2(v_mytype);
</pre><p>Since <code>V</code> now lives in <code>Acme::_1</code>, the namespace <code>Acme</code> is not searched for <code>func2</code>.</p><p>The GCC compiler has an extension to make this code work, and without the client having to be aware of the nested namespace:</p><pre class="sourcecodebox"> using namespace _1 __attribute__((__strong__));</pre><p>Now the client's original code, even the specialization of <code>Acme::V&lt;T&gt;</code>, just works. And yet, <code>V</code> and <code>func1</code> are now mangled with the nested namespace <code>Acme::_1</code>.</p><p>Why would Acme intentionally introduce this potentially confusing situation into their API?</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG15"></A><H2>Using Namespaces to Manage Versions</H2><p>If you have not read the section on <A HREF="#TNTAG14">The Strong Attribute for Namespace Using Declarations</A>, now would be a good time to do so. If you have just come from that section, this section is about answering that final question: Why?</p><p>As you may gather from this section's title, one can use the technique described in the previous section to version a library's ABI, without changing the library's API (or at least holding the API changes to backwards compatible ones). In the context of shared libraries, this means that one can simultaneously ship multiple versions of a shared library and a single application can indirectly link to multiple versions without fear of silent run time errors due to incompatible versions being mixed.</p><p>Consider the following:</p><p>Acme has shared library versions 1 and 2 which they ship: Acme.1.dylib and Acme.2.dylib. Other shared libraries (Lib_A and Lib_B) link with Acme for their valuable services. Lib_B has recompiled against Acme.2.dylib, but Lib_A is still using Acme.1.dylib. Finally, an application links to both Lib_A and Lib_B, effectively mixing both versions of Acme into the same process.</p><p>If, for example, Acme changed <code>Acme::func1</code> in a non-ABI preserving manner (say just by slightly changing its semantics, but not its signature), then it would be potentially disastrous to have two incompatible versions of <code>Acme::func1</code> running around in the same process. What if the main application calls <code>Acme::func1</code>? Which version should it get?</p><p>Versioning with namespaces addresses the above scenario. Because namespaces are mangled into the names of symbols, the hidden namespaces within namespace Acme are mangled into <code>func1</code>. At the object code level, the two different versions of <code>func1</code> are literally two distinct functions, with two distinct names. Yet at the source code level, both versions appear to have the name <code>Acme::func1</code>. The main application can call <code>func1</code> without problems. If it did so using Acme's version 1 headers, it will get <code>Acme::_1::func1</code>. If it used Acme's version 2 headers, it will get <code>Acme::_2::func1</code>. If it used the version 1 headers, but no longer links (directly or indirectly) against Acme.1.dylib, it will get a link or load time failure as <code>Acme::_1::func1</code> will not be found, even if <code>Acme::_2::func1</code> has been loaded into the process.</p><p>Thus this technique leverages the type-safety of C++ to have the dynamic linker enforce version compliance, even with multiple versions in the same process, and without introducing version numbers into the client's source code.</p><div class="notebox"><p><strong>Note:</strong> For further information on versioning with namespaces you can visit the following sites:</p><ul><li><p><A HREF="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2013.html">Versioning with Namespaces</A></p></li><li><p><A HREF="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1526.txt">Proposal to add namespace references to C++</A></p></li><li><p><A HREF="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1344.pdf">Namespaces and Library Versioning</A></p></li></ul></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG16"></A><H2>Which std C++ symbols are set in stone, and which aren't (ABI issues)</H2><p>If you have read <A HREF="#TNTAG14">The Strong Attribute for Namespace Using Declarations</A> and <A HREF="#TNTAG15">Using Namespaces to Manage Versions</A> then you may have already surmised that this is Apple's plan for the C++ standard library. As time goes on, and ABI-incompatible changes are made to our C++ standard library, we will version them as described above so that we can simultaneously offer older, ABI-compatible versions and newer, ABI-incompatible versions of the standard library. Clients will be able to choose versions based on their individual needs, and if an application happens to load third party shared libraries, there will be no danger of silently mixing incompatible <code>std::</code> components.</p><p>You may have also noticed that in our <A HREF="#TNTAG14">Acme example</A> above, there was one symbol (<code>func2</code>)) left outside of the nested versioning namespace. In this example, <code>func2</code> represents a symbol which Acme is guaranteeing to be ABI-stable, even across versions.</p><p>Likewise, Apple is guaranteeing that a small subset of the C++ standard library will not change ABI, even across new versions of this library. That subset of ABI-stable signatures is:</p><pre class="sourcecodebox">
    namespace std {

    // rtti

    class type_info;

    // exceptions

    class exception;
    class bad_exception;
    class bad_cast;
    class bad_typeid;
    class bad_alloc;
    class logic_error;
    class domain_error;
    class invalid_argument;
    class length_error;
    class out_of_range;
    class runtime_error;
    class range_error;
    class overflow_error;
    class underflow_error;

    // handlers

    unexpected_handler set_unexpected(unexpected_handler) throw();
    void unexpected();
    terminate_handler set_terminate(terminate_handler) throw();
    void terminate();
    uncaught_exception() throw();
    struct nothrow_t {};
    new_handler set_new_handler(new_handler) throw();

    }  // std

    // new / delete

    void* operator new(std::size_t) throw(std::bad_alloc);
    void* operator new(std::size_t, const std::nothrow_t&amp;) throw();
    void  operator delete(void*) throw();
    void  operator delete(void*, const std::nothrow_t&amp;) throw();
    void* operator new[](std::size_t) throw(std::bad_alloc);
    void* operator new[](std::size_t, const std::nothrow_t&amp;) throw();
    void  operator delete[](void*) throw();
    void  operator delete[](void*, const std::nothrow_t&amp;) throw();
    void* operator new  (std::size_t, void*) throw();
    void* operator new[](std::size_t, void*) throw();
    void  operator delete  (void*, void*) throw();
    void  operator delete[](void*, void*) throw();
</pre><p>Having ABI-stable exception classes is especially important as it is exceptions that tend to more easily cross shared library boundaries. And it is the exception classes which most often tend to get thrown. With this guarantee of ABI stability, code linked to any version of the standard library will be able to catch the standard exception classes thrown by another linkage unit which uses any other version of the standard library.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG17"></A><H2>How Best to Strip</H2><p>A linked Mach-O binary contains two kinds of symbols: global and local. Global symbols are used by <code>dyld</code> to do binding and are searchable at runtime using <code>dlsym()</code>. Local symbols are used by debuggers and CrashReporter when presenting symbolic names for addresses. All C++ constructs with visibility hidden become local symbols when linked.</p><p>It is very common to strip local symbols out of shipping products to reduce their size. Xcode does this by default in the Release configuration. On the other hand, stripping global symbols is a bit trickier because doing so can change the runtime meaning of a program.</p><p>The fastest way to remove local symbols is to have the linker never put them in the output binary. The linker option <code>-x</code> will do this. If you want to have two binaries one with and one without local symbols, you can have the linker generate local symbols, make of copy of the program, and use the <code>strip</code> tool with the <code>-x</code> option to remove the local symbols from the copy.</p><p>To control global symbols, you should use the four visibility options discussed in the section on <A HREF="#TNTAG8">choosing visibility options</A>.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG18"></A><H2>Using basic_string Instantiations Other Than string and wstring With libstdc++</H2><p>When using <code>std::basic_string</code>'s other than <code>string</code> and <code>wstring</code>, combined with hidden visibility, you should include the <code>string</code> header wrapped in <code>#pragma GCC visibility push(default)</code>. Failure to do so can result in a double delete associated with the empty string. This is considered an Apple bug <A HREF="rdar://problem/4940079">(r. 4940079)</A> and will be corrected in a future release.</p><p>Example:</p><pre class="sourcecodebox">
    $ cat library.h

        #ifndef LIBRARY_H
        #define LIBRARY_H

        #include &lt;string&gt;

        typedef unsigned short uchar;
        typedef std::basic_string&lt;uchar&gt; ustring;

        __attribute__ ((visibility(&quot;default&quot;))) ustring foo();

        #endif  // LIBRARY_H

    $ cat library.cpp

        #include &quot;library.h&quot;

        ustring foo()
        {
            ustring s;
            return s;
        }

    $ cat main.cpp

        #include &quot;library.h&quot;

        int main()
        {
            ustring s;
            s = foo();
        }

    $ export MallocBadFreeAbort=1
    $ g++ -fvisibility=hidden -dynamiclib -o library.so library.cpp
    $ g++ -fvisibility=hidden -o main main.cpp library.so
    $ ./main

        main(5585) malloc: ***  Deallocation of a pointer not malloced: 0xc0ac; This
        could be a double free(), or free() called with the middle of an allocated
        block; Try setting environment variable MallocHelp to see tools to help debug
        Abort trap

</pre><p>To fix, change <code>&lt;library.h&gt;</code> to:</p><pre class="sourcecodebox">
    $ cat library.h

        #ifndef LIBRARY_H
        #define LIBRARY_H

        #pragma GCC visibility push(default)   //added change
        #include &lt;string&gt;
        #pragma GCC visibility pop                 //added change

        typedef unsigned short uchar;
        typedef std::basic_string&lt;uchar&gt; ustring;

        __attribute__ ((visibility(&quot;default&quot;))) ustring foo();

        #endif  // LIBRARY_H

</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG19"></A><H2>Release-to-Release Version Compatibility of Shared Libraries Using C APIs and C++ Implementations</H2><p>One can maintain a pure C interface to a shared library while taking advantage of C++ in the shared library's implementation.</p><ul><li><p>Give all interface functions extern &quot;C&quot; linkage.</p></li><li><p>Give all functions which are not part of the interface hidden visibility.</p></li><li><p>Keep implementation details out of your interface headers as much as possible.</p></li><li><p>Decorate the symbols in your headers so that your symbols have the visibility you intend, rather than relying on the client to use visiblity command line options.</p></li><li><p>Monitor your visible symbols with <code>nm -mg</code>. You can ignore undefined symbols.</p></li><li><p>Do not let exceptions escape from the shared library.</p></li><li><p>Do not override new/delete, or if you do, make the overrides private to your library.</p></li><li><p>Avoid interface inline functions with local static variables. Give inline functions hidden visibility (even if they are part of your interface).</p></li><li><p>Never remove a visible symbol from your library unless you are willing to break ABI.</p></li><li><p>Encode the library's major version number into its filename, so that when you do have to break ABI clients can have a choice of library versions.</p></li></ul><p>For more details and good suggestions see the Apple reference documentation on <A HREF="../../documentation/DeveloperTools/Conceptual/DynamicLibraries/Articles/DynamicLibraryDesignGuidelines.html">dynamic library design guidelines</A>.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG20"></A><H2>Release-to-Release Version Compatibility of Shared Libraries Using C++ APIs and C++ Implementations</H2><p>One can also have a C++ interface to a shared library. In addition to following the points listed in the previous section, one should also consider the following to help maintain a stable ABI:</p><ul><li><p>Except for <A HREF="#TNTAG16">the symbols detailed in the section on ABI issues</A>, avoid the std C++ library in your interface. However do use it freely in your implementation.</p></li><li><p>If you propagate exceptions out of your shared library, or if you have types for which you expect your clients to be able to <code>dynamic_cast</code>, make sure these types are marked visible.</p></li><li><p>If not accessed by inline functions, consider giving private member functions hidden visibility.</p></li><li><p>Consider using the <A HREF="http://www.gotw.ca/gotw/024.htm">Pimpl idiom</A> when possible to hide your private data and functions from your client.</p></li><li><p>Consider using <A HREF="#TNTAG15">namespace versioning</A> to make the eventual ABI breakage less painful.</p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNT_HISTORY_TAG"></A><H2>Document Revision History</H2><table cellspacing="0" class="graybox" width="680"><tr><th width="100">Date</th><th width="580">Notes</th></tr><tr><td scope="row">2007-05-25</td><td>Correcting the section on setting function visibility via attributes:
    #define PUBLIC  __attribute__((__visibility__(&quot;hidden&quot;)))
    #define PRIVATE __attribute__((__visibility__(&quot;default&quot;)))

    PUBLIC  void MyFunction1() {}
    PRIVATE void MyFunction2() {}
had the PUBLIC and PRIVATE macros defined backwards.</td></tr><tr><td scope="row">2007-01-25</td><td>Tips and tricks for beginning to advanced C++ programmers on Mac OS X.</td></tr></table><p><b>Posted:</b> 2007-05-25</p>
<!-- END CONTENTS -->
</td></tr></table>
<!-- END WIDE COLUMN -->
<!-- END MAIN CONTENT -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn2007/tn2185.html%3Fid%3DDTS10004200-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn2007/tn2185.html%3Fid%3DDTS10004200-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn2007/tn2185.html%3Fid%3DDTS10004200-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

<!-- START BOTTOM APPLE NAVIGATION -->
<!--#include virtual="/includes/footer"-->
<!-- END BOTTOM APPLE NAVIGATION -->
<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->
</body></html>