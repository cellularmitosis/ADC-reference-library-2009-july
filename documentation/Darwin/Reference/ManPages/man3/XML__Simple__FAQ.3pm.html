<html><head><title>Mac OS X
 Manual Page For XML::Simple::FAQ(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/XML::Simple::FAQ" title="Mac OS X
 Manual Page for XML::Simple::FAQ(3pm)"><a name="//apple_ref/doc/man/3/XML::Simple::FAQ" title="Mac OS X
 Manual Page for XML::Simple::FAQ(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/XML::Simple::FAQ"; name=XML::Simple::FAQ(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
XML::Simple::FAQ(3)                  User Contributed Perl Documentation                 XML::Simple::FAQ(3)



<b>Frequently</b> <b>Asked</b> <b>Questions</b> <b>about</b> <b>XML::Simple</b>
<b>Basics</b>
       <b>What</b> <b>is</b> <b>XML::Simple</b> <b>designed</b> <b>to</b> <b>be</b> <b>used</b> <b>for?</b>

       XML::Simple is a Perl module that was originally developed as a tool for reading and writing
       configuration data in XML format.  You can use it for many other purposes that involve storing and
       retrieving structured data in XML.

       You might also find XML::Simple a good starting point for playing with XML from Perl.  It doesn't
       have a steep learning curve and if you outgrow its capabilities there are plenty of other Perl/XML
       modules to 'step up' to.

       <b>Why</b> <b>store</b> <b>configuration</b> <b>data</b> <b>in</b> <b>XML</b> <b>anyway?</b>

       The many advantages of using XML format for configuration data include:

          Using existing XML parsing tools requires less development time, is easier and more robust than
           developing your own config file parsing code

          XML can represent relationships between pieces of data, such as nesting of sections to arbitrary
           levels (not easily done with .INI files for example)

          XML is basically just text, so you can easily edit a config file (easier than editing a Win32
           registry)

          XML provides standard solutions for handling character sets and encoding beyond basic ASCII
           (important for internationalization)

          If it becomes necessary to change your configuration file format, there are many tools available
           for performing transformations on XML files

          XML is an open standard (the world does not need more proprietary binary file formats)

          Taking the extra step of developing a DTD allows the format of configuration files to be
           validated before your program reads them (not directly supported by XML::Simple)

          Combining a DTD with a good XML editor can give you a GUI config editor for minimal coding effort

       <b>What</b> <b>isn't</b> <b>XML::Simple</b> <b>good</b> <b>for?</b>

       The main limitation of XML::Simple is that it does not work with 'mixed content' (see the next
       question).  If you consider your XML files contain marked up text rather than structured data, you
       should probably use another module.

       If you are working with very large XML files, XML::Simple's approach of representing the whole file
       in memory as a 'tree' data structure may not be suitable.

       <b>What</b> <b>is</b> <b>mixed</b> <b>content?</b>

       Consider this example XML:

         &lt;document&gt;
           &lt;para&gt;This is &lt;em&gt;mixed&lt;/em&gt; content.&lt;/para&gt;
         &lt;/document&gt;

       This is said to be mixed content, because the &lt;para&gt; element contains both character data (text
       content) and nested elements.

       Here's some more XML:

         &lt;person&gt;
           &lt;first_name&gt;Joe&lt;/first_name&gt;
           &lt;last_name&gt;Bloggs&lt;/last_name&gt;
           &lt;dob&gt;25-April-1969&lt;/dob&gt;
         &lt;/person&gt;

       This second example is not generally considered to be mixed content.  The &lt;first_name&gt;, &lt;last_name&gt;
       and &lt;dob&gt; elements contain only character data and the  &lt;person&gt; element contains only nested
       elements.  (Note: Strictly speaking, the whitespace between the nested elements is character data,
       but it is ignored by XML::Simple).

       <b>Why</b> <b>doesn't</b> <b>XML::Simple</b> <b>handle</b> <b>mixed</b> <b>content?</b>

       Because if it did, it would no longer be simple :-)

       Seriously though, there are plenty of excellent modules that allow you to work with mixed content in
       a variety of ways.  Handling mixed content correctly is not easy and by ignoring these issues,
       XML::Simple is able to present an API without a steep learning curve.

       <b>Which</b> <b>Perl</b> <b>modules</b> <b>do</b> <b>handle</b> <b>mixed</b> <b>content?</b>

       Every one of them except XML::Simple :-)

       If you're looking for a recommendation, I'd suggest you look at the Perl-XML FAQ at:

         <a href="http://perl-xml.sourceforge.net/faq/">http://perl-xml.sourceforge.net/faq/</a>

<b>Installation</b>
       <b>How</b> <b>do</b> <b>I</b> <b>install</b> <b>XML::Simple?</b>

       If you're running ActiveState Perl, you've probably already got XML::Simple (although you may want to
       upgrade to version 1.09 or better for SAX support).

       If you do need to install XML::Simple, you'll need to install an XML parser module first.  Install
       either XML::Parser (which you may have already) or XML::SAX.  If you install both, XML::SAX will be
       used by default.

       Once you have a parser installed ...

       On Unix systems, try:

         perl -MCPAN -e 'install XML::Simple'

       If that doesn't work, download the latest distribution from
       <a href="ftp://ftp.cpan.org/pub/CPAN/authors/id/G/GR/GRANTM">ftp://ftp.cpan.org/pub/CPAN/authors/id/G/GR/GRANTM</a> , unpack it and run these commands:

         perl Makefile.PL
         make
         make test
         make install

       On Win32, if you have a recent build of ActiveState Perl (618 or better) try this command:

         ppm install XML::Simple

       If that doesn't work, you really only need the Simple.pm file, so extract it from the .tar.gz file
       (eg: using WinZIP) and save it in the \site\lib\XML directory under your Perl installation (typically
       C:\Perl).

       <b>I'm</b> <b>trying</b> <b>to</b> <b>install</b> <b>XML::Simple</b> <b>and</b> <b>'make</b> <b>test'</b> <b>fails</b>

       Is the directory where you've unpacked XML::Simple mounted from a file server using NFS, SMB or some
       other network file sharing?  If so, that may cause errors in the the following test scripts:

         3_Storable.t
         4_MemShare.t
         5_MemCopy.t

       The test suite is designed to exercise the boundary conditions of all XML::Simple's functionality and
       these three scripts exercise the caching functions.  If XML::Simple is asked to parse a file for
       which it has a cached copy of a previous parse, then it compares the timestamp on the XML file with
       the timestamp on the cached copy.  If the cached copy is *newer* then it will be used.  If the cached
       copy is older or the same age then the file is re-parsed.  The test scripts will get confused by
       networked filesystems if the workstation and server system clocks are not synchronised (to the
       second).

       If you get an error in one of these three test scripts but you don't plan to use the caching options
       (they're not enabled by default), then go right ahead and run 'make install'.  If you do plan to use
       caching, then try unpacking the distribution on local disk and doing the build/test there.

       It's probably not a good idea to use the caching options with networked filesystems in production.
       If the file server's clock is ahead of the local clock, XML::Simple will re-parse files when it could
       have used the cached copy.  However if the local clock is ahead of the file server clock and a file
       is changed immediately after it is cached, the old cached copy will be used.

       Is one of the three test scripts (above) failing but you're not running on a network filesystem?  Are
       you running Win32?  If so, you may be seeing a bug in Win32 where writes to a file do not affect its
       modfication timestamp.

       If none of these scenarios match your situation, please confirm you're running the latest version of
       XML::Simple and then email the output of 'make test' to me at grantm@cpan.org

       <b>Why</b> <b>is</b> <b>XML::Simple</b> <b>so</b> <b>slow?</b>

       If you find that XML::Simple is very slow reading XML, the most likely reason is that you have
       XML::SAX installed but no additional SAX parser module.  The XML::SAX distribution includes an XML
       parser written entirely in Perl.  This is very portable but not very fast.  For better performance
       install either XML::SAX::Expat or XML::LibXML.

<b>Usage</b>
       <b>How</b> <b>do</b> <b>I</b> <b>use</b> <b>XML::Simple?</b>

       If you had an XML document called /etc/appconfig/foo.xml you could 'slurp' it into a simple data
       structure (typically a hashref) with these lines of code:

         use XML::Simple;

         my $config = XMLin('/etc/appconfig/foo.xml');

       The <u>XMLin()</u> function accepts options after the filename.

       <b>There</b> <b>are</b> <b>so</b> <b>many</b> <b>options,</b> <b>which</b> <b>ones</b> <b>do</b> <b>I</b> <b>really</b> <b>need</b> <b>to</b> <b>know</b> <b>about?</b>

       Although you can get by without using any options, you shouldn't even consider using XML::Simple in
       production until you know what these two options do:

          forcearray

          keyattr

       The reason you really need to read about them is because the default values for these options will
       trip you up if you don't.  Although everyone agrees that these defaults are not ideal, there is not
       wide agreement on what they should be changed to.  The answer therefore is to read about them (see
       below) and select values which are right for you.

       <b>What</b> <b>is</b> <b>the</b> <b>forcearray</b> <b>option</b> <b>all</b> <b>about?</b>

       Consider this XML in a file called ./person.xml:

         &lt;person&gt;
           &lt;first_name&gt;Joe&lt;/first_name&gt;
           &lt;last_name&gt;Bloggs&lt;/last_name&gt;
           &lt;hobbie&gt;bungy jumping&lt;/hobbie&gt;
           &lt;hobbie&gt;sky diving&lt;/hobbie&gt;
           &lt;hobbie&gt;knitting&lt;/hobbie&gt;
         &lt;/person&gt;

       You could read it in with this line:

         my $person = XMLin('./person.xml');

       Which would give you a data structure like this:

         $person = {
           'first_name' =&gt; 'Joe',
           'last_name'  =&gt; 'Bloggs',
           'hobbie'     =&gt; [ 'bungy jumping', 'sky diving', 'knitting' ]
         };

       The &lt;first_name&gt; and &lt;last_name&gt; elements are represented as simple scalar values which you could
       refer to like this:

         print "$person-&gt;{first_name} $person-&gt;{last_name}\n";

       The &lt;hobbie&gt; elements are represented as an array - since there is more than one.  You could refer to
       the first one like this:

         print $person-&gt;{hobbie}-&gt;[0], "\n";

       Or the whole lot like this:

         print join(', ', @{$person-&gt;{hobbie}} ), "\n";

       The catch is, that these last two lines of code will only work for people who have more than one
       hobbie.  If there is only one &lt;hobbie&gt; element, it will be represented as a simple scalar (just like
       &lt;first_name&gt; and &lt;last_name&gt;).  Which might lead you to write code like this:

         if(ref($person-&gt;{hobbie})) {
           print join(', ', @{$person-&gt;{hobbie}} ), "\n";
         }
         else {
           print $person-&gt;{hobbie}, "\n";
         }

       Don't do that.

       One alternative approach is to set the forcearray option to a true value:

         my $person = XMLin('./person.xml', forcearray =&gt; 1);

       Which will give you a data structure like this:

         $person = {
           'first_name' =&gt; [ 'Joe' ],
           'last_name'  =&gt; [ 'Bloggs' ],
           'hobbie'     =&gt; [ 'bungy jumping', 'sky diving', 'knitting' ]
         };

       Then you can use this line to refer to all the list of hobbies even if there was only one:

         print join(', ', @{$person-&gt;{hobbie}} ), "\n";

       The downside of this approach is that the &lt;first_name&gt; and &lt;last_name&gt; elements will also always be
       represented as arrays even though there will never be more than one:

         print "$person-&gt;{first_name}-&gt;[0] $person-&gt;{last_name}-&gt;[0]\n";

       This might be OK if you change the XML to use attributes for things that will always be singular and
       nested elements for things that may be plural:

         &lt;person first_name="Jane" last_name="Bloggs"&gt;
           &lt;hobbie&gt;motorcycle maintenance&lt;/hobbie&gt;
         &lt;/person&gt;

       On the other hand, if you prefer not to use attributes, then you could specify that any &lt;hobbie&gt;
       elements should always be represented as arrays and all other nested elements should be simple scalar
       values unless there is more than one:

         my $person = XMLin('./person.xml', forcearray =&gt; [ 'hobbie' ]);

       The forcearray option accepts a list of element names which should always be forced to an array
       representation:

         forcearray =&gt; [ qw(hobbie qualification childs_name) ]

       See the XML::Simple manual page for more information.

       <b>What</b> <b>is</b> <b>the</b> <b>keyattr</b> <b>option</b> <b>all</b> <b>about?</b>

       Consider this sample XML:

         &lt;catalog&gt;
           &lt;part partnum="1842334" desc="High pressure flange" price="24.50" /&gt;
           &lt;part partnum="9344675" desc="Threaded gasket"      price="9.25" /&gt;
           &lt;part partnum="5634896" desc="Low voltage washer"   price="12.00" /&gt;
         &lt;/catalog&gt;

       You could slurp it in with this code:

         my $catalog = XMLin('./catalog.xml');

       Which would return a data structure like this:

         $catalog = {
             'part' =&gt; [
                 {
                   'partnum' =&gt; '1842334',
                   'desc'    =&gt; 'High pressure flange',
                   'price'   =&gt; '24.50'
                 },
                 {
                   'partnum' =&gt; '9344675',
                   'desc'    =&gt; 'Threaded gasket',
                   'price'   =&gt; '9.25'
                 },
                 {
                   'partnum' =&gt; '5634896',
                   'desc'    =&gt; 'Low voltage washer',
                   'price'   =&gt; '12.00'
                 }
             ]
         };

       Then you could access the description of the first part in the catalog with this code:

         print $catalog-&gt;{part}-&gt;[0]-&gt;{desc}, "\n";

       However, if you wanted to access the description of the part with the part number of "9344675" then
       you'd have to code a loop like this:

         foreach my $part (@{$catalog-&gt;{part}}) {
           if($part-&gt;{partnum} eq '9344675') {
             print $part-&gt;{desc}, "\n";
             last;
           }
         }

       The knowledge that each &lt;part&gt; element has a unique partnum attribute allows you to eliminate this
       search.  You can pass this knowledge on to XML::Simple like this:

         my $catalog = XMLin($xml, keyattr =&gt; ['partnum']);

       Which will return a data structure like this:

         $catalog = {
           'part' =&gt; {
             '5634896' =&gt; { 'desc' =&gt; 'Low voltage washer',   'price' =&gt; '12.00' },
             '1842334' =&gt; { 'desc' =&gt; 'High pressure flange', 'price' =&gt; '24.50' },
             '9344675' =&gt; { 'desc' =&gt; 'Threaded gasket',      'price' =&gt; '9.25'  }
           }
         };

       XML::Simple has been able to transform $catalog-&gt;{part} from an arrayref to a hashref (keyed on
       partnum).  This transformation is called 'array folding'.

       Through the use of array folding, you can now index directly to the description of the part you want:

         print $catalog-&gt;{part}-&gt;{9344675}-&gt;{desc}, "\n";

       The 'keyattr' option also enables array folding when the unique key is in a nested element rather
       than an attribute.  eg:

         &lt;catalog&gt;
           &lt;part&gt;
             &lt;partnum&gt;1842334&lt;/partnum&gt;
             &lt;desc&gt;High pressure flange&lt;/desc&gt;
             &lt;price&gt;24.50&lt;/price&gt;
           &lt;/part&gt;
           &lt;part&gt;
             &lt;partnum&gt;9344675&lt;/partnum&gt;
             &lt;desc&gt;Threaded gasket&lt;/desc&gt;
             &lt;price&gt;9.25&lt;/price&gt;
           &lt;/part&gt;
           &lt;part&gt;
             &lt;partnum&gt;5634896&lt;/partnum&gt;
             &lt;desc&gt;Low voltage washer&lt;/desc&gt;
             &lt;price&gt;12.00&lt;/price&gt;
           &lt;/part&gt;
         &lt;/catalog&gt;

       See the XML::Simple manual page for more information.

       <b>So</b> <b>what's</b> <b>the</b> <b>catch</b> <b>with</b> <b>'keyattr'?</b>

       One thing to watch out for is that you might get array folding even if you don't supply the keyattr
       option.  The default value for this option is:

         [ 'name', 'key', 'id']

       Which means if your XML elements have a 'name', 'key' or 'id' attribute (or nested element) then they
       may get folded on those values.  This means that you can take advantage of array folding simply
       through careful choice of attribute names.  On the hand, if you really don't want array folding at
       all, you'll need to set 'key attr to an empty list:

         my $ref = XMLin($xml, keyattr =&gt; []);

       A second 'gotcha' is that array folding only works on arrays.  That might seem obvious, but if
       there's only one record in your XML and you didn't set the 'forcearray' option then it won't be
       represented as an array and consequently won't get folded into a hash.  The moral is that if you're
       using array folding, you should always turn on the forcearray option.

       You probably want to be as specific as you can be too.  For instance, the safest way to parse the
       &lt;catalog&gt; example above would be:

         my $catalog = XMLin($xml, keyattr =&gt; { part =&gt; 'partnum'},
                                   forcearray =&gt; ['part']);

       By using the hashref for keyattr, you can specify that only &lt;part&gt; elements should be folded on the
       'partnum' attribute (and that the &lt;part&gt; elements should not be folded on any other attribute).

       By supplying a list of element names for forcearray, you're ensuring that folding will work even if
       there's only one &lt;part&gt;.  You're also ensuring that if the 'partnum' unique key is supplied in a
       nested element then that element won't get forced to an array too.

       <b>How</b> <b>do</b> <b>I</b> <b>know</b> <b>what</b> <b>my</b> <b>data</b> <b>structure</b> <b>should</b> <b>look</b> <b>like?</b>

       The rules are fairly straightforward:

          each element gets represented as a hash

          unless it contains only text, in which case it'll be a simple scalar value

          or unless there's more than one element with the same name, in which case they'll be represented
           as an array

          unless you've got array folding enabled, in which case they'll be folded into a hash

          empty elements (no text contents <b>and</b> no attributes) will either be represented as an empty hash,
           an empty string or undef - depending on the value of the 'suppressempty' option.

       If you're in any doubt, use Data::Dumper, eg:

         use XML::Simple;
         use Data::Dumper;

         my $ref = XMLin($xml);

         print Dumper($ref);

       <b>I'm</b> <b>getting</b> <b>'Use</b> <b>of</b> <b>uninitialized</b> <b>value'</b> <b>warnings</b>

       You're probably trying to index into a non-existant hash key - try Data::Dumper.

       <b>I'm</b> <b>getting</b> <b>a</b> <b>'Not</b> <b>an</b> <b>ARRAY</b> <b>reference'</b> <b>error</b>

       Something that you expect to be an array is not.  The two most likely causes are that you forgot to
       use 'forcearray' or that the array got folded into a hash - try Data::Dumper.

       <b>I'm</b> <b>getting</b> <b>a</b> <b>'No</b> <b>such</b> <b>array</b> <b>field'</b> <b>error</b>

       Something that you expect to be a hash is actually an array.  Perhaps array folding failed because
       one element was missing the key attribute - try Data::Dumper.

       <b>I'm</b> <b>getting</b> <b>an</b> <b>'Out</b> <b>of</b> <b>memory'</b> <b>error</b>

       Something in the data structure is not as you expect and Perl may be trying unsuccessfully to
       autovivify things - try Data::Dumper.

       If you're already using Data::Dumper, try calling <u>Dumper()</u> immediately after <u>XMLin()</u> - ie: before you
       attempt to access anything in the data structure.

       <b>My</b> <b>element</b> <b>order</b> <b>is</b> <b>getting</b> <b>jumbled</b> <b>up</b>

       If you read an XML file with <u>XMLin()</u> and then write it back out with <u>XMLout()</u>, the order of the
       elements will likely be different.  (However, if you read the file back in with <u>XMLin()</u> you'll get
       the same Perl data structure).

       The reordering happens because XML::Simple uses hashrefs to store your data and Perl hashes do not
       really have any order.

       It is possible that a future version of XML::Simple will use Tie::IxHash to store the data in
       hashrefs which do retain the order.  However this will not fix all cases of element order being lost.

       If your application really is sensitive to element order, don't use XML::Simple (and don't put order-
       sensitive values in attributes).

       <b>XML::Simple</b> <b>turns</b> <b>nested</b> <b>elements</b> <b>into</b> <b>attributes</b>

       If you read an XML file with <u>XMLin()</u> and then write it back out with <u>XMLout()</u>, some data which was
       originally stored in nested elements may end up in attributes.  (However, if you read the file back
       in with <u>XMLin()</u> you'll get the same Perl data structure).

       There are a number of ways you might handle this:

          use the 'forcearray' option with <u>XMLin()</u>

          use the 'noattr' option with <u>XMLout()</u>

          live with it

          don't use XML::Simple

       <b>Why</b> <b>does</b> <u>XMLout()</u> <b>insert</b> <b>&lt;name&gt;</b> <b>elements</b> <b>(or</b> <b>attributes)?</b>

       Try setting keyattr =&gt; [].

       When you call <u>XMLin()</u> to read XML, the 'keyattr' option controls whether arrays get 'folded' into
       hashes.  Similarly, when you call <u>XMLout()</u>, the 'keyattr' option controls whether hashes get
       'unfolded' into arrays.  As described above, 'keyattr' is enabled by default.

       <b>Why</b> <b>are</b> <b>empty</b> <b>elements</b> <b>represented</b> <b>as</b> <b>empty</b> <b>hashes?</b>

       An element is always represented as a hash unless it contains only text, in which case it is
       represented as a scalar string.

       If you would prefer empty elements to be represented as empty strings or the undefined value, set the
       'suppressempty' option to '' or undef respectively.

       <b>Why</b> <b>is</b> <b>ParserOpts</b> <b>deprecated?</b>

       The "ParserOpts" option is a remnant of the time when XML::Simple only worked with the XML::Parser
       API.  Its value is completely ignored if you're using a SAX parser, so writing code which relied on
       it would bar you from taking advantage of SAX.

       Even if you are using XML::Parser, it is seldom necessary to pass options to the parser object.  A
       number of people have written to say they use this option to set XML::Parser's "ProtocolEncoding"
       option.  Don't do that, it's wrong, Wrong, WRONG!  Fix the XML document so that it's well-formed and
       you won't have a problem.

       Having said all of that, as long as XML::Simple continues to support the XML::Parser API, this option
       will not be removed.  There are currently no plans to remove support for the XML::Parser API.



perl v5.8.8                                      2004-11-19                              XML::Simple::FAQ(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/XML__Simple__FAQ.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/XML__Simple__FAQ.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/XML__Simple__FAQ.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
