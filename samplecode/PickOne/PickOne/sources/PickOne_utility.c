/*  utility.c																				Nick Thompson	Michael Bishop - August 21 1996														(c)1994-96 Apple computer Inc., All Rights Reserved								*//* --------------------------------------------------------------------** INCLUDES*/#include	<QuickDraw.h>#include	<Events.h>#include	<math.h>#include	"PickOne_utility.h"#include	"QD3D.h"#include	"QD3DMath.h"#include	"QD3DGroup.h"/* --------------------------------------------------------------------** GLOBAL VARIABLES*//* --------------------------------------------------------------------** LOCAL FUNCTION DEFINITIONS*//*	--------------------------------------------------------------------**	Utility_HiWrd**	DESCRIPTION*/short Utility_HiWrd(long aLong){	return	(((aLong) >> 16) & 0xFFFF) ;}/*	--------------------------------------------------------------------**	Utility_LoWrd**	DESCRIPTION*/short Utility_LoWrd(long aLong){	return	((aLong) & 0xFFFF) ;}/*	--------------------------------------------------------------------**	Utility_DebugString**	Abstract GetMouse Function for Porting*/void Utility_DebugString(char	*theMessage){	DebugStr((const unsigned char *)theMessage);}/*	--------------------------------------------------------------------**	Utility_MyGetMouse**	Abstract GetMouse Function for Porting*/void Utility_MyGetMouse(TQ3Point2D *thePoint){	Point macPoint;		GetMouse(&macPoint);	/*	GlobalToLocal(&macPoint);*/		thePoint->x = (float)(macPoint.h);	thePoint->y = (float)(macPoint.v);}/*	--------------------------------------------------------------------**	Utility_MyStillDown**	Abstract StillDown Function for Porting*/int	Utility_MyStillDown(void){	return StillDown();}/*	--------------------------------------------------------------------**	Utility_GetUpVector**	Returns a default vector that points as much toward the y axis as it can.**	Expects the vectors to be normalized.**	At this point, what to do if the forward vector lies on the y axis is a**	point of thought. Currently, it returns vector pointing down the -Z axis.*/void	Utility_GetUpVector(const TQ3Vector3D *theForwardVector, TQ3Vector3D *theUpVector){	TQ3Vector3D	theOrthogonalVector,  tempVector, theForwardVectorCopy = *theForwardVector;		if ( (theForwardVectorCopy.x == 0.0) && (theForwardVectorCopy.z == 0.0) ) {		theUpVector->x = 0.0; theUpVector->y = 0.0; theUpVector->z = -1.0; 	} else {		Q3Vector3D_Set ( &tempVector, 0.0, 1.0, 0.0 ) ;		Q3Vector3D_Cross(&tempVector, (const TQ3Vector3D *)&theForwardVectorCopy, &theOrthogonalVector);		Q3Vector3D_Cross(&theForwardVectorCopy, (const TQ3Vector3D *)&theOrthogonalVector, &tempVector);				Q3Vector3D_Normalize(&tempVector, theUpVector);		}}/*	--------------------------------------------------------------------**	Utility_GetEnclosingGroup**	Takes a hit path and returns the group enclosing the leaf of the path*/TQ3Object	Utility_GetEnclosingGroup(const TQ3HitPath *theHitPath){	long			subGroupDepth;	TQ3GroupObject	group, subGroup;	long			i;	if ( theHitPath->depth < 1 ) {		return NULL;	}		if ( theHitPath->depth == 1 ) {		return theHitPath->rootGroup;	}		subGroupDepth = theHitPath->depth - 1;	group = theHitPath->rootGroup;		for (i = 0; i < subGroupDepth; i++) {		if (Q3Group_GetPositionObject(theHitPath->rootGroup, theHitPath->positions[i], &subGroup) == kQ3Success)		{			if ( group != theHitPath->rootGroup) {				Q3Object_Dispose(group);			}			group = subGroup;		}	}	return group;	}