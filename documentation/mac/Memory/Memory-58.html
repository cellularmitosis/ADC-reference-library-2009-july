<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Memory Manager (IM: M)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING58></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Memory-57.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-59.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Memory-2.html"><B>Memory</B></A> / <BR><DD><A HREF="Memory-56.html"><B>Chapter 2 - Memory Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING58-0></A>
<H1>Using the Memory Manager</H1>
 This section discusses the techniques you can use both to deal with memory outside of your application's partition and to manipulate your own application's partition.<P>
 You can use the techniques in this section to<P>
<UL>
<LI>read and write the values of system global variables when there is no Toolbox routine that would accomplish the work for you
<LI>check for the availability of temporary memory and use it to speed operations that depend on memory buffers
<LI>allocate memory in the system heap
<LI>install code into the system heap
<LI>allocate memory at the high end of the available RAM from within a system extension during the startup process
<LI>initialize new heap zones within your application heap zone, on your application's stack, or in the application global variables area
<LI>install a purge-warning procedure for your application heap zone<P>
</UL>
<A NAME=HEADING58-10></A>
<H2><A NAME=MARKER-9-110></A>Reading and Writing System Global Variables</H2>
 In general, you should avoid relying on the values of system global variables whenever possible. However, you might occasionally need to access the value of one of these variables. Because the actual values associated with global variables in MPW's <CODE>SysEqu.p</CODE> interface file are memory locations, you can access the value of a low-memory variable simply by dereferencing a memory location.<P>
 Many system global variables are process-independent, but some are process-specific. The Operating System swaps the values of the process-specific variables as it switches processes. If you write interrupt code that reads low memory, that code could execute at a time when another process's system global variables are installed. Therefore, before reading low memory from interrupt code, you should call the Process Manager to ensure that your process is the current process. If it is not, you should not rely on the value of system global variables that could conceivably be process-specific.<P>
<DL>
<DT><B>Note</B>
<DD>No available documentation distinguishes process-specific from process-independent system global variables.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-196></A>The routine defined in <A HREF=#MARKER-9-112>Listing 2-1</A> illustrates how you can read a system global variable, in this case the system global variable <CODE>BufPtr</CODE>, which gives the address of the highest byte of allocatable memory.<P>
<B>Listing 2-1  <A NAME=MARKER-9-112></A>Reading the value of a system global variable</B><P>
<PRE>
FUNCTION FindHighestByte: LongInt;
TYPE
   LongPtr = ^LongInt;
BEGIN
   FindHighestByte := LongPtr(BufPtr)^;
END;
</PRE>
 In Pascal, the main technique for reading system global variables is to define a new data type that points to the variable type you want to read. In this example, the address is stored as a long integer. Thus, the memory location <CODE>BufPtr</CODE> is really a pointer to a long integer. Because of Pascal's strict typing rules, you must cast the low-memory address into a pointer to a long integer. Then, you can dereference the pointer and return the long integer itself as the function result.<A NAME=MARKER-2-14></A><P>
 <A NAME=MARKER-2-114></A>You can use a similar technique to change the value of a system global variable. For example, suppose you are writing an extension that displays a window at startup time. To maintain compatibility with pre-Macintosh II systems, you need to clear the system global variable named <CODE>DeskHook</CODE>. This global variable holds a <CODE>ProcPtr</CODE> that references a procedure called by system software to paint the desktop. If the value of the pointer is <CODE>NIL</CODE>, the system software uses the standard desktop pattern. If you do not set <CODE>DeskHook</CODE> to <CODE>NIL</CODE>, the system software might attempt to use whatever random data it contains to call an updating procedure when you move or close your window. The procedure defined in <A HREF=#MARKER-9-117>Listing 2-2</A> sets <CODE>DeskHook</CODE> to <CODE>NIL</CODE>.<A NAME=MARKER-2-19></A><A NAME=MARKER-2-160></A><P>
<B>Listing 2-2  <A NAME=MARKER-9-117></A>Changing the value of a system global variable</B><P>
<PRE>
PROCEDURE ClearDeskHook;
TYPE
   ProcPtrPtr = ^ProcPtr;                 {pointer to ProcPtr}
VAR
   deskHookProc: ProcPtrPtr;              
BEGIN
   deskHookProc := ProcPtrPtr(DeskHook);  {initialize variable}
   deskHookProc^ := NIL;                  {clear DeskHook proc}
END;
</PRE>
 You can use a similar technique to change the value of any other documented system global variable.<P>
<A NAME=HEADING58-22></A>
<H2>Extending an Application's Memory</H2>
 Rather than using your application's <CODE>'SIZE'</CODE> resource to specify a preferred partition size that is large enough to contain the largest possible application heap, you should specify a smaller but adequate partition size. When you need more memory for temporary use, you can use a set of Memory Manager routines for the allocation <BR>of temporary memory.<P>
 By using the routines for allocating temporary memory, your application can request some additional memory for occasional short-term needs. For example, the Finder uses these temporary-memory routines to secure buffer space for use during file copy operations. Any available memory (that is, memory currently unallocated to any application's partition) is dedicated to this purpose. The Finder releases this memory as soon as the copy is completed, thus making the memory available to other applications or to the Operating System for launching new applications.<A NAME=MARKER-2-118></A><P>
 Because the requested amount of memory might not be available, you cannot be sure that every request for temporary memory will be honored. Thus, you should make sure that your application will work even if your request for temporary memory is denied. For example, if the Finder cannot allocate a large temporary copy buffer, it uses a reserved small copy buffer from within its own heap zone, prolonging the copying but performing it nonetheless.<P>
 Temporary memory is taken from RAM that is reserved for (but not yet used by) other applications. Thus, if you use too much temporary memory or hold temporary memory for long periods of time, you might prevent the user from being able to launch other applications. In certain circumstances, however, you can hold temporary memory indefinitely. For example, if the temporary memory is used for open files and the user can free that memory simply by closing those files, it is safe to hold onto that memory as long as necessary.<P>
 Temporary memory is tracked (or monitored) for each application, and so you must use it only for code that is running on an application's behalf. Moreover, the Operating System frees all temporary memory allocated to an application when the application quits or crashes. As a result, you should not use temporary memory for VBL tasks, Time Manager tasks, or other procedures that should continue to be executed after your application quits. Similarly, it is wise not to use temporary memory for an interprocess buffer (that is, a buffer whose address is passed to another application in a high-level event) because the originating application could crash, quit, or be terminated, thereby causing the temporary memory to be released before (or even while) the receiving application uses that memory.<A NAME=MARKER-9-71></A><A NAME=MARKER-2-99></A><A NAME=MARKER-2-90></A><A NAME=MARKER-2-80></A><P>
 Although you can usually perform ordinary Memory Manager operations on temporary memory, there are two restrictions. First, you must never lock temporary memory across calls to <CODE>GetNextEvent</CODE> or <CODE>WaitNextEvent</CODE>. Second, although you can determine the zone from which temporary memory is generated (using the <CODE>HandleZone</CODE> function), you should not use this information to make new blocks or perform heap operations on your own.<A NAME=MARKER-2-79></A><A NAME=MARKER-2-78></A><A NAME=MARKER-9-62></A><A NAME=MARKER-2-126></A><P>
<A NAME=HEADING58-29></A>
<H3><A NAME=MARKER-2-21></A>Allocating Temporary Memory</H3>
 You can request a block of memory for temporary use by calling the Memory Manager's <CODE>TempNewHandle</CODE> function. This function attempts to allocate a new relocatable block of the specified size for temporary use. For example, to request a block that is one-quarter megabyte in size, you might issue this command:<P>
<PRE>
myHandle := TempNewHandle($40000, myErr); {request temp memory}
</PRE>
 If the routine succeeds, it returns a handle to the block of memory. The block of memory returned by a successful call to <CODE>TempNewHandle</CODE> is initially unlocked. If an error occurs and <CODE>TempNewHandle</CODE> fails, it returns a <CODE>NIL</CODE> handle. You should always check for <CODE>NIL</CODE> handles before using any temporary memory. If you detect a <CODE>NIL</CODE> handle, the second parameter (in this example, <CODE>myErr</CODE>) contains the result code from the function.<A NAME=MARKER-2-128></A><P>
 Instead of asking for a specific amount of memory and then checking the returned handle to find out whether it was allocated, you might prefer to determine beforehand how much temporary memory is available. There are two functions that return information on the amount of free memory available for temporary allocation. The first is the <CODE>TempFreeMem</CODE> function, which you can use as follows:<P>
<PRE>
memFree := TempFreeMem;    {find amount of free temporary memory}
</PRE>
 The result is a long integer containing the amount, in bytes, of free memory available for temporary allocation. It usually isn't possible to allocate a block of this size because of fragmentation. Consequently, you'll probably want to use the second function, <CODE>TempMaxMem</CODE>, to determine the size of the largest contiguous block of space available. To allocate that block, you can write<P>
<PRE>
mySize := TempMaxMem(grow);
myHandle := TempNewHandle(mySize, myErr);
</PRE>
 The <CODE>TempMaxMem</CODE> function returns the size, in bytes, of the largest contiguous free block available for temporary allocation. (The <CODE>TempMaxMem</CODE> function is analogous to the <CODE>MaxMem</CODE> function.) The <CODE>grow</CODE> parameter is a variable parameter of type <CODE>Size</CODE>; after the function returns, it always contains 0, because the temporary memory does not come from the application's heap. Even when you use <CODE>TempMaxMem</CODE> to determine the size of the available memory, you should check that the handle returned by <CODE>TempNewHandle</CODE> <BR>is not <CODE>NIL</CODE>.<A NAME=MARKER-2-129></A><P>
<A NAME=HEADING58-38></A>
<H3><A NAME=MARKER-2-130></A>Determining the Features of Temporary Memory</H3>
 <A NAME=MARKER-2-131></A>Only computers running system software version 7.0 and later can use temporary memory as described in this chapter. For this reason, you should always check that the routines are available and that they have the features you require before calling them.<P>
<DL>
<DT><B>Note</B>
<DD>The temporary-memory routines are available in some earlier system software versions when MultiFinder is running. However, the handles to blocks of temporary memory are neither tracked nor real.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The <CODE>Gestalt</CODE> function includes a selector to determine whether the temporary-memory routines are present in the operating environment and, if they are, whether <BR>the temporary-memory handles are tracked and whether they are real. If temporary-memory handles are not tracked, you must release temporary memory before your next call to <CODE>GetNextEvent</CODE> or <CODE>WaitNextEvent</CODE>. If temporary-memory handles are not real, then you cannot use normal Memory Manager routines such as <CODE>HLock</CODE> to manipulate them.<P>
 To determine whether the temporary-memory routines are implemented, you can check the value returned by the <CODE>TempMemCallsAvailable</CODE> function, defined in <A HREF=#MARKER-9-132>Listing 2-3</A>.<P>
<B>Listing 2-3  <A NAME=MARKER-9-132></A>Determining whether temporary-memory routines are available</B><P>
<PRE>
FUNCTION TempMemCallsAvailable: Boolean;
VAR
   myErr:   OSErr;               {Gestalt result code}
   myRsp:   LongInt;             {response returned by Gestalt}
BEGIN
   TempMemCallsAvailable := FALSE;
   myErr := Gestalt(gestaltOSAttr, myRsp);
   IF myErr &lt;&gt; noErr THEN  
      DoError(myErr)          {Gestalt failed}
   ELSE                       {check bit for temp mem support}
      TempMemCallsAvailable :=
            BAND(myRsp, gestaltTempMemSupport) &lt;&gt; 0;
END;
</PRE>
 You can use similar code to determine whether temporary-memory handles are real and whether the temporary memory is tracked.<A NAME=MARKER-2-33></A><A NAME=MARKER-2-134></A><P>
<A NAME=HEADING58-46></A>
<H2><A NAME=MARKER-9-135></A>Using the System Heap</H2>
 The system heap is used to store most of the information needed by the Operating System and other system software components. As a result, it is ideal for storing information needed by a system extension (which by definition extends the capabilities of system software). You might also need to use the system heap to store a task record and the code for an interrupt task that should continue to be executed when your application is not the current application.<P>
 <A NAME=MARKER-2-31></A><A NAME=MARKER-2-30></A>Allocating blocks in the system heap is straightforward. Most ordinary Memory Manager routines have counterparts that allocate memory in the system heap zone instead of the current heap zone. For example, the counterpart of the <CODE>NewPtr</CODE> function is the <CODE>NewPtrSys</CODE> function. The following line of code allocates a new nonrelocatable block of memory in the system heap to store a Time Manager task record:<P>
<PRE>
myTaskPtr := QElemPtr(NewPtrSys(SizeOf(TMTask)));
</PRE>
 Alternatively, you can change the current zone and use ordinary Memory Manager operations, as follows:<P>
<PRE>
SetZone(SystemZone);
myTaskPtr := QElemPtr(NewPtr(SizeOf(TMTask)));
...
SetZone(ApplicationZone);
</PRE>
 <A NAME=MARKER-2-66></A>You might also need to store the interrupt code itself in the system heap. For example, when an application that installed a vertical retrace task with the <CODE>VInstall</CODE> function is in the background, the Vertical Retrace Manager executes the task only if the <CODE>vblAddr</CODE> field of the task record points to a routine in the system heap.<P>
 Unfortunately, manually copying a routine into the system heap is difficult in Pascal. <BR>The easiest way to install code into the system heap is to place the code into a separate stand-alone code resource in your application's resource fork. You should set the system heap bit and the locked bit of the code resource's attributes. Then, when you need to use the code, you must load the resource from the resource file and cast the resource handle's master pointer into a procedure pointer (a variable of type <CODE>ProcPtr</CODE>), as follows:<A NAME=MARKER-2-89></A><P>
<PRE>
myProcHandle := GetResource(kProcType, kProcID);
IF myProcHandle &lt;&gt; NIL THEN
   myTaskPtr^.vblAddr := ProcPtr(myProcHandle^);
</PRE>
 Because the resource is locked in memory, you don't have to worry about creating <BR>a dangling pointer when you dereference a handle to the resource. If you want the <BR>code to remain in the system heap after the user quits your application, you can call <BR>the Resource Manager procedure <CODE>DetachResource</CODE> so that closing your application's resource fork does not destroy the resource data. Note, however, that if you do so and your application crashes, the code still remains in the system heap.<A NAME=MARKER-2-140></A><P>
 Once you have loaded a code resource into memory and created a <CODE>ProcPtr</CODE> that references the entry point of the code resource, you can use that <CODE>ProcPtr</CODE> just as you can use any such variable. For example, you could assign the value of the variable to the <CODE>vblAddr</CODE> field of a vertical retrace task record (as shown just above). If you are programming in assembly language, you can then call the code directly. To call the routine from a high-level language such as Pascal, you'll need to use some inline assembly-language code. <A HREF=#MARKER-9-142>Listing 2-4</A> defines a routine that you can use to execute a procedure by address.<A NAME=MARKER-2-141></A><P>
<B>Listing 2-4  <A NAME=MARKER-9-142></A>Calling a procedure by address</B><P>
<PRE>
PROCEDURE CallByAddress (aRoutine: ProcPtr);
   INLINE   $205F,            {MOVE.L (SP)+,A0}
            $4ED0;            {JMP (A0)}
</PRE>
<A NAME=HEADING58-59></A>
<H2><A NAME=MARKER-2-143></A><A NAME=MARKER-2-144></A>Allocating Memory at Startup Time</H2>
 If you are implementing a system extension, you might need to allocate memory at startup time. As explained in the previous section, an ideal place to allocate such memory is in the system heap. To allocate memory in the system heap under system software version 7.0 and later, you merely need to call the appropriate Memory Manager routines, and the system heap expands dynamically to meet your request. In earlier versions of system software, you must use a <CODE>'sysz'</CODE> resource to indicate how much the Operating System should increase the size of the system zone.<A NAME=MARKER-2-145></A><A NAME=MARKER-9-91></A><A NAME=MARKER-2-147></A><P>
 <A NAME=MARKER-2-148></A>Alternatively, however, you can allocate blocks in high memory. The global variable <CODE>BufPtr</CODE> always references the highest byte in memory that might become part of an application partition. You can lower the value of <CODE>BufPtr</CODE> and then use the memory between the old and new values of <CODE>BufPtr</CODE>.<P>
<DL>
<DT><B>Note</B>
<DD>In general, if you are implementing a system extension, you should allocate memory in the system heap instead of high memory. In this way, you avoid the problems associated with lowering the value of <CODE>BufPtr</CODE> too far (described in the following paragraphs) and ensure that the extension is not paged out if virtual memory is operating.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-149></A>Lowering the value of <CODE>BufPtr</CODE> too far can be dangerous for several reasons. In 128K ROM Macintosh computers running system software version 4.1, you must avoid lowering the value of <CODE>BufPtr</CODE> so that it points in the system startup blocks. The highest byte of these blocks can always be found relative to the global variable <CODE>MemTop</CODE>, at <CODE>MemTop DIV 2 + 1024</CODE>.<P>
 In later versions of the Macintosh system software, the system startup blocks were no longer barriers to <CODE>BufPtr</CODE>, but new barriers arose, including Macintosh IIci video storage, for example. To maintain compatibility with extensions that rely on the ability to lower <CODE>BufPtr</CODE> relative to <CODE>MemTop</CODE>, the system software simply adjusts <CODE>MemTop</CODE> so that the formula still holds. Thus, at startup, the <CODE>MemTop</CODE> global variable currently does not reference any memory location in particular. Instead, it holds a value that guarantees that the formula allowing you to lower <CODE>BufPtr</CODE> as low as <CODE>MemTop DIV 2 + 1024</CODE> but no further still holds.<A NAME=MARKER-2-150></A><P>
 Beginning in system software version 7.0, the Operating System can detect excessive lowering of <CODE>BufPtr</CODE>, but only after the fact. When the Operating System does detect <BR>that the value of <CODE>BufPtr</CODE> has fallen too low, it generates an out-of-memory system error.<P>
<DL>
<DT><B>WARNING</B>
<DD>Although the above formula has been true since system software version 4.1, a bug in the Macintosh IIci and later ROMs made it invalid in certain versions of system software 6.x.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Because there is no calling interface for lowering <CODE>BufPtr</CODE>, you must do it manually, by changing the value of the system variable, as explained in <A HREF=#MARKER-9-110>"Reading and Writing System Global Variables" on page 2-8</A>. To obtain the value of the <CODE>MemTop</CODE> global variable, you can use the <CODE>TopMem</CODE> function.<A NAME=MARKER-2-151></A><A NAME=MARKER-2-152></A><A NAME=MARKER-2-102></A><P>
<A NAME=HEADING58-68></A>
<H2>Creating Heap Zones</H2>
 <A NAME=MARKER-2-204></A><A NAME=MARKER-2-156></A><A NAME=MARKER-2-157></A><A NAME=MARKER-2-158></A><A NAME=MARKER-2-159></A>You can create heap zones as subzones of your application heap zone or (in rare instances) either in space reserved for the application global variables or on the stack. You can also create heap zones in a block of temporary memory or within the system heap zone. This section describes how to create new heap zones by calling the <CODE>InitZone</CODE> procedure.<P>
<DL>
<DT><B>Note</B>
<DD>Most applications do not need to create heap zones.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To create a new heap zone in the application heap, you must allocate nonrelocatable blocks in your application heap to hold new subzones of the application heap. In addition to being able to create subzones of the application zone, you can create subzones of any other zone to which you have access, including a zone that is itself <BR>a subzone of another zone.<P>
 You create a heap zone by calling the <CODE>InitZone</CODE> procedure, which takes four parameters. The first parameter specifies a grow-zone function for the new zone, or <CODE>NIL</CODE> if you do not want the zone to have a grow-zone function. The second parameter specifies the number of new master pointers that you want each block of master pointers in the zone to contain. The <CODE>InitZone</CODE> procedure allocates one such block to start with, and you can allocate more by calling the <CODE>MoreMasters</CODE> procedure. The third and fourth parameters specify, respectively, the first byte beyond the end of the new zone and the first byte of the zone.<P>
 When initializing a zone with the <CODE>InitZone</CODE> procedure, make sure that you are subdividing the current zone. When <CODE>InitZone</CODE> returns, the new zone becomes <BR>current. Thus, if you subdivide the application zone into several subzones, you must <BR>call <CODE>SetZone(ApplicationZone)</CODE> before you create the second and each of the subsequent subzones. <A HREF=#MARKER-9-160>Listing 2-5</A> shows a technique for creating a single subzone of the original application zone, assuming that the application zone is the current zone. The technique for subdividing subzones is similar.<P>
<B>Listing 2-5  <A NAME=MARKER-9-160></A>Creating a subzone of the original application heap zone</B><P>
<PRE>
FUNCTION CreateSubZone: THz;
CONST
   kZoneSize = 10240;            {10K zone}
   kNumMasterPointers = 16;      {num of master ptrs for new zone}
VAR
   start:   Ptr;                 {first byte in zone}
   limit:   Ptr;                 {first byte beyond zone}
BEGIN
   start := NewPtr(kZoneSize);   {allocate storage for zone}
   IF MemError &lt;&gt; noErr THEN
   BEGIN                         {allocation successful}
      limit := Ptr(ORD4(start) + kZoneSize);
                                 {compute byte beyond end of zone}
      InitZone(NIL, kNumMasterPointers, limit, start);
                                 {initialize zone header, trailer}
   END;
   CreateSubZone := THz(start);  {cast storage to a zone pointer}
END;
</PRE>
 To create a subzone in the system heap zone, you can call <CODE>SetZone(SystemZone)</CODE> at the beginning of the procedure in <A HREF=#MARKER-9-160>Listing 2-5</A>. You might find this technique useful if you are implementing a system extension but want to manage your extension's memory much as you manage memory in an application. Instead of simply allocating blocks in the system heap, you can make your zone current whenever your extension is executed. Then, you can call regular Memory Manager routines to allocate memory in your subzone of the system heap, and you can compact and purge your subzone without compacting and purging the entire system heap zone.<A NAME=MARKER-2-161></A><P>
 When you allocate memory for a subzone, you must allocate that memory in a nonrelocatable block (as in <A HREF=#MARKER-9-160>Listing 2-5</A>) or in a locked relocatable block. If you create a subzone within an unlocked relocatable block, the Memory Manager might move your entire subzone during memory operations in the zone containing your subzone. If so, any references to nonrelocatable blocks that you allocated in the subzone would become invalid. Even handles to relocatable blocks in the subzone would no longer be valid, because the Memory Manager does not update the handles' master pointers correctly. This happens because the Memory Manager views a subzone of another zone as a <BR>single block. If that subzone is a relocatable block, the Memory Manager updates only that block's master pointer when moving it, and does not update the block's contents (that is, the blocks allocated within the subzone).<P>
 If you use a block of temporary memory as a heap zone, you must lock the temporary memory immediately after allocating it. Then, you can pass to <CODE>InitZone</CODE> a dereferenced copy of a handle to the temporary memory. If you find (after a call to the <CODE>Gestalt</CODE> function) that temporary memory handles are not real, then you must dispose of the new zone before any calls to <CODE>GetNextEvent</CODE> or <CODE>WaitNextEvent</CODE>. You must dispose of the new zone because you cannot lock a handle to temporary memory across event calls if the handle is not real.<A NAME=MARKER-2-162></A><P>
 Once you have created a subzone as a nonrelocatable block or a locked relocatable block, you can allocate both relocatable and nonrelocatable blocks within it. Although the Memory Manager can move such relocatable blocks only within the subzone, it correctly updates those blocks' master pointers, which are also in the subzone.<A NAME=MARKER-2-163></A><A NAME=MARKER-2-164></A><A NAME=MARKER-2-165></A><A NAME=MARKER-2-166></A><A NAME=MARKER-2-167></A><P>
<A NAME=HEADING58-80></A>
<H2><A NAME=MARKER-9-168></A>Installing a Purge-Warning Procedure<A NAME=MARKER-2-28></A></H2>
 You can define a <B>purge-warning procedure</B> that the Memory Manager calls whenever it is about to purge a block from your application heap. You can use this procedure to save the data in the block, if necessary, or to perform other processing in response to this notification.<A NAME=MARKER-2-34></A><P>
<DL>
<DT><B>Note</B>
<DD>Most applications don't need to install a purge-warning procedure. This capability is provided primarily for applications that require greater control over their heap. Examples are applications that maintain purgeable handles containing important data and applications that for any other reason need notification when a block is about to be purged.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 When your purge-warning procedure is called, the Memory Manager passes it a handle to the block about to be purged. In your procedure, you can test the handle to determine whether it contains data that needs to be saved; if so, you can save the data (possibly by writing it to some open file). <A HREF=#MARKER-9-171>Listing 2-6</A> defines a very simple purge-warning procedure.<P>
<B>Listing 2-6  <A NAME=MARKER-9-171></A>A purge-warning procedure<A NAME=MARKER-2-172></A></B><P>
<PRE>
PROCEDURE MyPurgeProc (h: Handle);
VAR
   theA5:   LongInt;             {value of A5 when procedure is called}
BEGIN
   theA5 := SetCurrentA5;        {remember current value of A5; install ours}
   IF BAND(HGetState(h), $20) = 0 THEN
      BEGIN                      {if the handle isn't a resource handle}
         IF InSaveList(h) THEN
            WriteData(h);        {save the data in the block}
      END;
   theA5 := SetA5(theA5);        {restore previous value of A5}
END;
</PRE>
 The <CODE>MyPurgeProc</CODE> procedure defined in <A HREF=#MARKER-9-171>Listing 2-6</A> inspects the handle's properties (using <CODE>HGetState</CODE>) to see whether its resource bit is clear. If so, the procedure next determines whether the handle is contained in an application-maintained list of <BR>handles whose data should be saved before purging. If the handle is in that list, the purge-warning procedure writes its data to disk. (The file into which the data is written should already be open at the time the procedure is called, because opening a file might cause memory to move.)<P>
 Note that <CODE>MyPurgeProc</CODE> sets up the A5 register with the application's A5 value upon entry and restores it to its previous value before exiting. This is necessary because you cannot rely on the A5 register within a purge-warning procedure.<P>
<DL>
<DT><B>WARNING</B>
<DD>Because of the optimizations performed by some compilers, the actual work of the purge-warning procedure and the setting and restoring of the A5 register might have to be placed in separate procedures. See the chapter "Vertical Retrace Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I> for an illustration of how you can do this.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To install a purge-warning procedure, you need to install the address of the <BR>procedure into the <CODE>purgeProc</CODE> field of your application's heap zone header. <BR><A HREF=#MARKER-9-173>Listing 2-7</A> illustrates one way to do this.<P>
<B>Listing 2-7  <A NAME=MARKER-9-173></A>Installing a purge-warning procedure</B><P>
<PRE>
PROCEDURE InstallPurgeProc;
VAR
   myZone:  THz;
BEGIN
   myZone := GetZone;                     {find the current zone header}
   gPrevProc := myZone^.purgeProc;        {remember previous procedure}
   myZone^.purgeProc := @MyPurgeProc;     {install new procedure}
END;
</PRE>
 The <CODE>InstallPurgeProc</CODE> procedure defined in <A HREF=#MARKER-9-173>Listing 2-7</A> first obtains the address of the current heap zone by calling the <CODE>GetZone</CODE> function. Then it saves the address of any existing purge-warning procedure in the global variable gPrevProc. Finally, <CODE>InstallPurgeProc</CODE> installs the new procedure by putting its address directly into the <CODE>purgeProc</CODE> field of the zone header. (For more information on zone headers, see <A HREF=Memory-59.html#MARKER-9-181>"Heap Zones" on page 2-19</A>.)<P>
 Keep in mind that the Memory Manager calls your purge-warning procedure each time it decides to purge any purgeable block, and it might call your procedure far more often than you would expect. Your purge-warning procedure might be passed handles not only to blocks that you explicitly mark as purgeable (by calling <CODE>HPurge</CODE>), but also to resources whose purgeable attribute is set. (In general, applications don't need to take any action on handles that belong to the Resource Manager.) Because of the potentially large number of times your purge-warning procedure might be called, it should be able to determine quickly whether a handle that is about to be purged needs additional processing.<P>
 Remember that a purge-warning procedure is called during the execution of some Memory Manager routine. As a result, your procedure cannot cause memory to be moved or purged. In addition, it should not dispose of the handle it is passed or change the purge status of the handle. See <A HREF=Memory-148.html#MARKER-9-522>"Purge-Warning Procedures" on page 2-90</A> for a complete description of the limitations on purge-warning procedures.<P>
<DL>
<DT><B>WARNING</B>
<DD>If your application calls the Resource Manager procedure <CODE>SetResPurge</CODE> with the parameter <CODE>TRUE</CODE> (to have the Resource Manager automatically save any modified resources that are about to be purged), you should avoid using a purge-warning procedure. This is because the Resource Manager installs its own purge-warning procedure when you call <CODE>SetResPurge</CODE> in this way. If you must install your own purge-warning procedure, you should remove your procedure, call <CODE>SetResPurge</CODE>, then reinstall your procedure as shown in <A HREF=#MARKER-9-173>Listing 2-7</A>. You then need to make sure that your procedure calls the Resource Manager's purge-warning procedure (which is saved in the global variable <CODE>gPrevProc</CODE>) before exiting. Most applications do not need to call <CODE>SetResPurge</CODE> at all.<EM></EM><A NAME=MARKER-2-84></A><A NAME=MARKER-2-90></A><A NAME=MARKER-2-29></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 If your application does call <CODE>SetResPurge(TRUE)</CODE>, you should use the version of <CODE>MyPurgeProc</CODE> defined in <A HREF=#MARKER-9-178>Listing 2-8</A>. It is just like the version defined in <A HREF=#MARKER-9-171>Listing 2-6</A> except that it calls the Resource Manager's purge-warning procedure before exiting.<P>
<B>Listing 2-8  <A NAME=MARKER-9-178></A>A purge-warning procedure that calls the Resource Manager's procedure</B><P>
<PRE>
PROCEDURE MyPurgeProc (h: Handle);
VAR
   theA5:   LongInt;             {value of A5 when procedure is called}
BEGIN
   theA5 := SetCurrentA5;        {remember current value of A5; install ours}
   IF BAND(HGetState(h), $20) = 0 THEN
      BEGIN                      {if the handle isn't a resource handle}
         IF InSaveList(h) THEN
            WriteData(h);        {save the data in the block}
      END
   ELSE IF gPrevProc &lt;&gt; NIL THEN
      CallByAddress(gPrevProc);
   theA5 := SetA5(theA5);        {restore previous value of A5}
END;
</PRE>
 See <A HREF=#MARKER-9-142>Listing 2-4</A> on <A HREF=#MARKER-9-142>page 2-13</A> for a definition of the procedure <CODE>CallByAddress</CODE>.<P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Memory-57.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-59.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Memory-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
