<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">

<script language="JavaScript" src="frametest.js"></script>

<TITLE> Defining Your Own Control Definition Function1</TITLE><LINK REL="stylesheet" TYPE="text/css" HREF="../../../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../../../Resources/JavaScript/page.js"></script>
</head>
<body bgcolor="#ffffff">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<a name="top"></a>
<!-- start of banner -->			
<!--#include virtual="/includes/framesetheader" -->
<!-- end of banner -->

<!-- start of path -->
<table border="0" cellpadding="0" cellspacing="2" width="432">	
	<tr>
	<td scope="row"><font face="Geneva,Helvetica,Arial" size="1">
	<b>PATH<img src="../../../images/space.gif" width="6" height="12"></b><a href="../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../mac8.html" target="_top">Mac OS 8 and 9</a> 
	<b>&gt;</b> Human Interface Toolbox
	<b>&gt;</b> <a href="../controlmanager.html" target="_top">Control Manager</a> 
	<b>&gt;</b>
	</font></td>
	</tr>
	<tr><td align="left" scope="row"><br>
	<img src="../../../images/im_smblue.gif" width="116" height="8"><img src="../../../images/space.gif" width="6" height="11">
	<font face="Geneva,Helvetica,Arial">Mac OS 8 Control Manager Reference</font>
	</td></tr>
</table><br>
<!-- end of path -->


<!-- top navigation -->
<DIV>
<P><A HREF="ControlMgrRef.2.html" border="0"><img src="images/up.gif" border="0"></A> <A HREF="ControlMgrRef.9.html"><img src="images/previous.gif" border="0"></A> <A HREF="ControlMgrRef.b.html"><img src="images/next.gif" border="0"></A>

<!-- insert Show/Hide frames -->
<a href="javascript:testFrame()">
<script>
<!--
document.write(frameLink);
//-->
</script><!-- end Show/Hide frames --></a></div>
<!-- end top navigation -->

<hr>

<H1 CLASS="RH2.RoutineHd2">
<A NAME="pgfId=84342">
 </A>
<A NAME="13057">
 </A>
Defining Your Own Control Definition Function</H1>
<P CLASS="T1.Text1">
<A NAME="pgfId=128231">
 </A>
A <A NAME="marker=205019">
 </A>
control definition function determines how a control generally looks and behaves. Various Control Manager functions call a control definition function whenever they need to perform a control-dependent action, such as drawing the control on the screen. In addition to standard control definition functions, defined by the system, you can make your own custom control definition functions.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=194545">
 </A>
The Control Manager calls the Resource Manager to access a control definition function with the given resource ID; for a description of how to derive a control definition function ID, see <A HREF="ControlMgrRef.10.html#38161" CLASS="XRef">Control Definition IDs</A>
. The Resource Manager reads a control definition function into memory and returns a handle to it. The Control Manager stores this handle in the <CODE>contrlDefProc</CODE>
 field of the control structure.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=194549">
 </A>
When various Control Manager functions need to perform a type-dependent action on the control, they call the control definition function and pass it the variation code for its type as a parameter. You can define your own variation codes; this allows you to use one <CODE>'CDEF'</CODE>
 resource to handle several variations of the same general control. see <A HREF="ControlMgrRef.e.html#18412" CLASS="XRef"><CODE>'CNTL'</CODE></A>
 for further discussion of controls, their resources, and their IDs.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=94875">
 </A>
If you choose to provide your own control definition functions, these functions should apply the user's desktop color choices the same way the standard control definition functions do. You can use control color tables of any desired size and define their contents in any way you wish, except that part indices and messages 0 through 127 are reserved for system definition.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=240236">
 </A>
The following Control Manager function for defining your own control definition function is changed with Appearance Manager 1.0:</P>
<UL>
<LI CLASS="B1.Bullet1">
<A NAME="pgfId=240240">
 </A>
<A HREF="ControlMgrRef.a.html#18871" CLASS="XRef"><CODE>MyControlDefProc</A></CODE>
 defines a custom control. Changed with Appearance Manager 1.0.</LI>
</UL>
<BR><H3 CLASS="RoH.RoutineHeading">
<A NAME="pgfId=84354">
 </A>
<A NAME="18871">
 </A>
MyControlDefProc </H3>
<P CLASS="T1.Text1">
<A NAME="pgfId=84356">
 </A>
If you wish to define new, nonstandard controls for your application, you must write a control definition function and store it in a resource file as a resource of type <CODE>'CDEF'</CODE>
.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=156972">
 </A>
The Control Manager declares the type for an application-defined control definition function as follows:</P>
<CODE CLASS="RD.RoutineDeclare">
<A NAME="pgfId=259874">
 </A>
typedef pascal SInt32 (*ControlDefProcPtr)(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SInt16 varCode, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ControlHandle theControl, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ControlDefProcMessage message, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SInt32 param);</CODE>
<P CLASS="T1.Text1">
<A NAME="pgfId=156975">
 </A>
The Control Manager defines the data type <CODE>ControlDefUPP</CODE>
 to identify the universal procedure pointer for this application-defined function:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=259880">
 </A>
typedef UniversalProcPtr ControlDefUPP;</CODE>
<P CLASS="T1.Text1">
<A NAME="pgfId=156978">
 </A>
You typically use the <CODE>NewControlDefProc</CODE>
 macro like this:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=259886">
 </A>
ControlDefUPP myControlDefUPP;<BR>
myControlDefUPP = NewControlDefProc (MyControl);</CODE>
<P CLASS="T1.Text1">
<A NAME="pgfId=201427">
 </A>
You typically use the <CODE>CallControlDefProc</CODE>
 macro like this:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=259890">
 </A>
CallControlDefProc(myControlDefUPP, varCode, theControl, message, param);</CODE>
<P CLASS="T1.Text1">
<A NAME="pgfId=84387">
 </A>
Here's how to declare the function <CODE>MyControlDefProc</CODE>
:</P>
<CODE CLASS="RD.RoutineDeclare">
<A NAME="pgfId=259894">
 </A>
pascal SInt32 MyControlDefProc (<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SInt16 varCode,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ControlHandle theControl,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ControlDefProcMessage message,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SInt32 param);</CODE>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259898">
 </A>
<CODE>varCode</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=71984">
 </A>
The control's variation code. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259908">
 </A>
<CODE>theControl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=71985">
 </A>
A handle to the control that the operation will affect.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259917">
 </A>
<CODE>message</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=90826">
 </A>
A code for the task to be performed. The <CODE>message</CODE>
 parameter contains one of the task codes defined in <A HREF="ControlMgrRef.a.html#12804" CLASS="XRef">Messages</A>
. The subsections that follow explain each of these tasks in detail. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259926">
 </A>
<CODE>param</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=71989">
 </A>
Data associated with the task specified by the <CODE>message</CODE>
 parameter. If the task requires no data, this parameter is ignored.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259935">
 </A>
<I CLASS="italics">
function result</I>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=71991">
 </A>
The function results that your control definition function returns depend on the value that the Control Manager passes in the <CODE>message</CODE>
 parameter.</DD>
</DL COMPACT>
<DIV>
<BR><H4 CLASS="RSb.RoutineSbhd">
<A NAME="pgfId=71992">
 </A>
DISCUSSION</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=92235">
 </A>
The Control Manager calls your control definition function under various circumstances; the Control Manager uses the <CODE>message</CODE>
 parameter to inform your control definition function what action it must perform. The data that the Control Manager passes in the <CODE>param</CODE>
 parameter, the action that your control definition function must undertake, and the function results that your control definition function returns all depend on the value that the Control Manager passes in the <CODE>message</CODE>
 parameter. The rest of this section describes how to respond to the various values that the Control Manager passes in the <CODE>message</CODE>
 parameter.</P>
</DIV>
<DIV>
<BR><H4 CLASS="RSb.RoutineSbhd">
<A NAME="pgfId=226018">
 </A>
VERSION NOTES</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=226019">
 </A>
Changed with Appearance Manager 1.0 to support new control definition messages.</P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=91027">
 </A>
<A NAME="12804">
 </A>
Messages</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=91145">
 </A>
The Control Manager passes constants of type <CODE>ControlDefProcMessage</CODE>
 to indicate the action your control definition function must perform. </P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=259946">
 </A>
enum {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;drawCntl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;testCntl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;calcCRgns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;initCntl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 3,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dispCntl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 4,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;posCntl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 5,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;thumbCntl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 6,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dragCntl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 7,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;autoTrack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 8,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;calcCntlRgn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 10,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;calcThumbRgn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 11,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgDrawGhost&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 13,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgCalcBestRect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 14,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgHandleTracking&nbsp;&nbsp;&nbsp;= 15,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgFocus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 16,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgKeyDown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 17,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgIdle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 18,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgGetFeatures&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 19,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgSetData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 20,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgGetData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 21,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgActivate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 22,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgSetUpBackground&nbsp;&nbsp;= 23,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgSubValueChanged&nbsp;&nbsp;= 25,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgCalcValueFromPos&nbsp;= 26,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgTestNewMsgSupport= 27,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgSubControlAdded&nbsp;&nbsp;= 28,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlMsgSubControlRemoved= 29<BR>
};<BR>
typedef SInt16 ControlDefProcMessage;</CODE>
</DIV>
<DIV>
<BR><BR><H4 CLASS="UH.UserHd">
<A NAME="pgfId=157168">
 </A>
Constant descriptions</H6>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259950">
 </A>
<CODE>drawCntl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91154">
 </A>
Draw the entire control or part of a control.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259960">
 </A>
<CODE>testCntl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91156">
 </A>
Test where the mouse has been pressed.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259970">
 </A>
<CODE>calcCRgns</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91158">
 </A>
Calculate the region for the control or the indicator in 24-bit systems. This message is obsolete in Mac OS 7.6 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259980">
 </A>
<CODE>initCntl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91160">
 </A>
Perform additional control initialization.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=259990">
 </A>
<CODE>dispCntl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91162">
 </A>
Perform additional control disposal actions.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260000">
 </A>
<CODE>posCntl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91164">
 </A>
Move and update the indicator setting.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260010">
 </A>
<CODE>thumbCntl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91166">
 </A>
Calculate the parameters for dragging the indicator.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260020">
 </A>
<CODE>dragCntl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91168">
 </A>
Perform customized dragging (of the control or its indicator).</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260030">
 </A>
<CODE>autoTrack</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91173">
 </A>
Execute the specified action function.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260040">
 </A>
<CODE>calcCntlRgn</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91175">
 </A>
Calculate the control region in 32-bit systems.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260050">
 </A>
<CODE>calcThumbRgn</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91177">
 </A>
Calculate the indicator region in 32-bit systems.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260060">
 </A>
<CODE>kControlMsgDrawGhost</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91035">
 </A>
 Draw a ghost image of the indicator. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260071">
 </A>
<CODE>kControlMsgCalcBestRect</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92761">
 </A>
 Calculate the optimal control rectangle. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260082">
 </A>
<CODE>kControlMsgHandleTracking</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92977">
 </A>
 Perform custom tracking. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260093">
 </A>
<CODE>kControlMsgFocus</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92931">
 </A>
Handle keyboard focus. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260103">
 </A>
<CODE>kControlMsgKeyDown</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92933">
 </A>
Handle keyboard events. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260113">
 </A>
<CODE>kControlMsgIdle</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92935">
 </A>
Perform idle processing. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260123">
 </A>
<CODE>kControlMsgGetFeatures</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92937">
 </A>
 Specify which Appearance-compliant messages are supported. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260134">
 </A>
<CODE>kControlMsgSetData</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92939">
 </A>
 Set control-specific data. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260145">
 </A>
<CODE>kControlMsgGetData</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92941">
 </A>
 Get control-specific data. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260156">
 </A>
<CODE>kControlMsgActivate</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92943">
 </A>
 Handle activate and deactivate events. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260167">
 </A>
<CODE>kControlMsgSetUpBackground</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=92945">
 </A>
 Set the control's background color or pattern (only available if the control supports embedding). Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260178">
 </A>
<CODE>kControlMsgSubValueChanged</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=213153">
 </A>
 Be informed that the value of a subcontrol embedded in the control has changed; this message is useful for radio groups. Available with Appearance 1.0.1 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260189">
 </A>
<CODE>kControlMsgCalcValueFromPos</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91098">
 </A>
 Support live feedback while dragging the indicator and calculate the control value based on the new indicator region. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260200">
 </A>
<CODE>kControlMsgTestNewMsgSupport</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=91100">
 </A>
 Specify whether Appearance-compliant messages are supported. Available with Appearance Manager 1.0 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260211">
 </A>
<CODE>kControlMsgSubControlAdded</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=103541">
 </A>
						  Be informed that a subcontrol has been embedded in the control. Available with Appearance 1.0.1 and later.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260224">
 </A>
<CODE>kControlMsgSubControlRemoved</CODE>
 </DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123737">
 </A>
 Be informed that a subcontrol is about to be removed from the control. Available with Appearance 1.0.1 and later.</DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=123771">
 </A>
<CODE></CODE>
<A NAME="24638">
 </A>
Drawing the Control or Its Part</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=92170">
 </A>
When the Control Manager passes the value <CODE>drawCntl</CODE>
 in the <CODE>message</CODE>
 parameter, your control definition function should respond by drawing the indicator or the entire control.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=93247">
 </A>
The Control Manager passes one of the following drawing constants in the low word of the <CODE>param</CODE>
 parameter to specify whether the user is drawing an indicator or the whole control. The high-order word of the <CODE>param</CODE>
 parameter may contain undefined data; therefore, evaluate only the low-order word of this parameter. </P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260237">
 </A>
enum {&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kDrawControlEntireControl&nbsp;&nbsp;&nbsp;= 0,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kDrawControlIndicatorOnly&nbsp;&nbsp;&nbsp;= 129<BR>
};</CODE>
</DIV>
<DIV>
<BR><BR><H4 CLASS="UH.UserHd">
<A NAME="pgfId=90870">
 </A>
Constant descriptions</H6>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260239">
 </A>
<CODE>kDrawControlEntireControl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=90872">
 </A>
 Draw the entire control.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260250">
 </A>
<CODE>kDrawControlIndicatorOnly</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=90874">
 </A>
 Draw the indicator only.</DD>
</DL COMPACT>
<P CLASS="T1.Text1">
<A NAME="pgfId=90875">
 </A>
With the exception of part code 128, which is reserved for future use and should not be used, any other value indicates a part code for the control. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72001">
 </A>
If the specified control is visible, your control definition function should draw the control (or the part specified in the <CODE>param</CODE>
 parameter) within the control's rectangle. If the control is invisible (that is, if its <CODE>contrlVis</CODE>
 field is set to 0), your control definition function does nothing. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72002">
 </A>
When drawing the control or its part, take into account the current values of its <CODE>contrlHilite</CODE>
 and <CODE>contrlValue</CODE>
 fields in the control structure.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72003">
 </A>
If the part code for your control's indicator is passed in <CODE>param</CODE>
, assume that the indicator hasn't moved; the Control Manager, for example, may be calling your control definition function so that you may simply highlight the indicator. However, when your application calls <CODE>SetControlValue</CODE>
, <CODE>SetControlMinimum</CODE>
, and <CODE>SetControlMaximum</CODE>
, they in turn may call your control definition function with the <CODE>drawCntl</CODE>
 message to redraw the indicator. Since these functions have no way of determining what part code you chose for your indicator, they all pass 129 in <CODE>param</CODE>
, meaning that you should move your indicator. Your control definition function must detect this part code as a special case and remove the indicator from its former location before drawing it. If your control has more than one indicator, you should interpret 129 to mean all indicators.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72013">
 </A>
When sent the message <CODE>drawCntl</CODE>
, your control definition function should return 0 as its function result.</P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=72018">
 </A>
Testing Where the Mouse-Down Event Occurs</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=93250">
 </A>
When the Control Manager passes the value for the <CODE>testCntl</CODE>
 constant in the <CODE>message</CODE>
 parameter, your control definition function should respond by determining whether a specified point is in a visible control. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=93256">
 </A>
The Control Manager passes a point (in local coordinates) in the <CODE>param</CODE>
 parameter. The point's vertical coordinate is contained in the high-order word of the long integer, and horizontal coordinate is contained in the low-order word.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72026">
 </A>
Your control definition function should return the part code of the part that contains the specified point; it should return 0 if the point is outside the control or if the control is inactive. </P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=72028">
 </A>
Calculating the Control and Indicator Regions on 24-Bit Systems</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=72030">
 </A>
When the Control Manager passes the value for the <CODE>calcCRgns</CODE>
 constant in the <CODE>message</CODE>
 parameter, your control definition function should calculate the region passed in the <CODE>param</CODE>
 parameter for the specified control or its indicator. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=93274">
 </A>
The Control Manager passes a QuickDraw region handle in the <CODE>param</CODE>
 parameter. If the high-order bit of <CODE>param</CODE>
 is set, the region requested is that of the control's indicator; otherwise, the region requested is that of the entire control. Your control definition function should clear the high bit of the region handle before calculating the region.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72033">
 </A>
When passed this message, your control definition function should always return 0, and it should express the region in the local coordinate system of the control's window.</P>
</DIV>
<DIV>
<BR><BLOCKQUOTE><H3 CLASS="ImportantHead">
<A NAME="pgfId=260261">
 </A>
IMPORTANT</H3>
<P CLASS="I.Important">
<A NAME="pgfId=123785">
 </A>
The <CODE>calcCRgns</CODE>
 message will never be sent to any system running on 32-bit mode and is therefore obsolete in Mac&nbsp;OS 7.6 and later. The <CODE>calcCntlRgn</CODE>
 and <CODE>calcThumbRgn</CODE>
 messages will be sent instead.</P></BLOCKQUOTE>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=206142">
 </A>
Calculating the Control and Indicator Regions on 32-Bit Systems</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=206143">
 </A>
When the Control Manager passes the values for the <CODE>calcCntlRgn</CODE>
 or <CODE>calcThumbRgn</CODE>
 constants in the <CODE>message</CODE>
 parameter, your control definition function should calculate the region for the specified control or its indicator using the QuickDraw region handle passed in the <CODE>param</CODE>
 parameter . </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=206144">
 </A>
If the Control Manager passes the value for the <CODE>calcThumbRgn</CODE>
 constant in the <CODE>message</CODE>
 parameter, calculate the region occupied by the indicator. If the Control Manager passes the value for the <CODE>calcCntlRgn</CODE>
 constant in the <CODE>message</CODE>
 parameter, calculate the region for the entire control.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=206145">
 </A>
When passed this message, your control definition function should always return 0, and it should express the region in the local coordinate system of the control's window.</P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=72041">
 </A>
Performing Additional Control Initialization</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=72043">
 </A>
After initializing fields of a control structure as appropriate when creating a new control, the Control Manager passes <CODE>initCntl</CODE>
 in the <CODE>message</CODE>
 parameter to give your control definition function the opportunity to perform any type-specific initialization you may require. For example, the standard control definition function for scroll bars allocates space for a region to hold the scroll box and stores the region handle in the <CODE>contrlData</CODE>
 field of the new control structure.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72048">
 </A>
When passed the value for the <CODE>initCntl</CODE>
 constant in the <CODE>message</CODE>
 parameter, your control definition function should ignore the <CODE>param</CODE>
 parameter and return 0 as a function result.</P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=72050">
 </A>
Performing Additional Control Disposal Actions</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=72055">
 </A>
The function <A HREF="ControlMgrRef.3.html#11869" CLASS="XRef"><CODE>DisposeControl</A></CODE>
 passes <CODE>dispCntl</CODE>
 in the <CODE>message</CODE>
 parameter to give your control definition function the opportunity to carry out any additional actions when disposing of a control. For example, the standard definition function for scroll bars releases the memory occupied by the scroll box region, whose handle is kept in the <CODE>contrlData</CODE>
 field of the control structure.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72056">
 </A>
When passed the value for the <CODE>dispCntl</CODE>
 constant in the <CODE>message</CODE>
 parameter, your control definition function should ignore the <CODE>param</CODE>
 parameter and return 0 as a function result. </P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=72058">
 </A>
Dragging the Control or Its Indicator</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=72060">
 </A>
When a mouse-up event occurs in the indicator of a control, the <A HREF="ControlMgrRef.7.html#21975" CLASS="XRef"><CODE>HandleControlClick</A></CODE>
 or <A HREF="ControlMgrRef.7.html#34113" CLASS="XRef"><CODE>TrackControl</A></CODE>
 functions call your control definition function and pass <CODE>posCntl</CODE>
 in the <CODE>message</CODE>
 parameter. In this case, the Control Manager passes a point (in coordinates local to the control's window) in the <CODE>param</CODE>
 parameter that specifies the vertical and horizontal offset, in pixels, by which your control definition function should move the indicator from its current position. Typically, this is the offset between the points where the cursor was when the user pressed and released the mouse button while dragging the indicator. The point's vertical offset is contained in the high-order word of the <CODE>param</CODE>
 parameter, and its horizontal offset is contained in the low-order word.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72066">
 </A>
Your definition function should calculate the control's new setting based on the  given offset and then, to reflect the new setting, redraw the control and update the <CODE>contrlValue</CODE>
 field in the control structure. Your control definition function should ignore the <CODE>param</CODE>
 parameter and return 0 as a function result.</P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=72078">
 </A>
Calculating Parameters for Dragging the Indicator</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=72080">
 </A>
When the Control Manager passes the value for <CODE>thumbCntl</CODE>
 in the <CODE>message</CODE>
 parameter, your control definition function should respond by calculating values analogous to the <CODE>limitRect</CODE>
, <CODE>slopRect</CODE>
, and <CODE>axis</CODE>
 parameters of <CODE>DragControl</CODE>
 that constrain how the indicator is dragged. On entry, the fields <CODE>param-&gt;limitRect.top</CODE>
 and <CODE>param-&gt;limitRect.left</CODE>
 contain the point where the mouse-down event first occurred. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=98274">
 </A>
The Control Manager passes a pointer to a structure of type <CODE>IndicatorDragConstraint </CODE>
in the <CODE>param</CODE>
 parameter:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260268">
 </A>
struct IndicatorDragConstraint {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;limitRect;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slopRect;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DragConstraint&nbsp;&nbsp;axis;<BR>
};<BR>
typedef struct IndicatorDragConstraint IndicatorDragConstraint;<BR>
typedef IndicatorDragConstraint *IndicatorDragConstraintPtr;<BR>
typedef IndicatorDragConstraintPtr *IndicatorDragConstraintHandle;</CODE>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260272">
 </A>
<CODE>limitRect</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=159532">
 </A>
A pointer to a rectangle--whose coordinates should normally coincide with or be contained in the window's content region--delimiting the area in which the user can drag the control's outline.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260282">
 </A>
<CODE>slopRect</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=98278">
 </A>
A pointer to a rectangle that allows some extra space for the user to move the mouse while still constraining the control within the rectangle specified in the <CODE>limitRect</CODE>
 parameter.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260291">
 </A>
<CODE>axis</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=98279">
 </A>
The axis along which the user may drag the control's outline.</DD>
</DL COMPACT>
<P CLASS="T1.Text1">
<A NAME="pgfId=114473">
 </A>
Your definition function should store the appropriate values into the fields of the structure pointed to by the <CODE>param </CODE>
parameter; they're analogous to the similarly named parameters of the Window Manager function <CODE>DragGrayRgn</CODE>
 .<CODE> </CODE>
</P>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260300">
 </A>
Your control definition function should return 0 as function result.</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=114471">
 </A>
</DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=98263">
 </A>
Performing Custom Dragging</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=90911">
 </A>
When the Control Manager passes the value for the <CODE>dragCntl</CODE>
 constant in the <CODE>message</CODE>
 parameter, the <CODE>param</CODE>
 parameter typically contains a custom dragging constant with one of the following values to specify whether the user is dragging an indicator or the whole control:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260309">
 </A>
enum {&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kDragControlEntireControl&nbsp;&nbsp;&nbsp;= 0,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kDragControlIndicator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1<BR>
};</CODE>
</DIV>
<DIV>
<BR><BR><H4 CLASS="UH.UserHd">
<A NAME="pgfId=90901">
 </A>
Constant descriptions</H6>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260311">
 </A>
<CODE>kDragControlEntireControl</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=90903">
 </A>
 Dragging the entire control.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260322">
 </A>
<CODE>kDragControlIndicator</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=90905">
 </A>
 Dragging the indicator.</DD>
</DL COMPACT>
</DIV>
</DIV>
<DIV>
<blockquote><H3 CLASS="NoteHead">
<A NAME="pgfId=260333">
 </A>
Note</H3>
<P CLASS="Note">
<A NAME="pgfId=125453">
 </A>
When the Appearance Manager is present, the message <CODE>kControlMsgHandleTracking</CODE>
 should be sent instead of <CODE>dragCntl</CODE>
 to handle any custom tracking; see <A HREF="ControlMgrRef.a.html#24261" CLASS="XRef">Performing Custom Tracking</A>
.</P></blockquote>
<P CLASS="T1.Text1">
<A NAME="pgfId=72097">
 </A>
If you want to use the Control Manager's default method of dragging, which is to call <CODE>DragControl</CODE>
 to drag the control or the Window Manager function <CODE>DragGrayRgn</CODE>
 to drag its indicator, return 0 as the function result for your control definition function.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=72104">
 </A>
If your control definition function returns a nonzero value, your control definition function (not the Control Manager) must drag the specified control (or its indicator) to follow the cursor until the user releases the mouse button. If the user drags the entire control, your definition function should use the function <CODE>MoveControl</CODE>
 to reposition the control to its new location after the user releases the mouse button. If the user drags the indicator, your definition function must calculate the control's new setting (based on the pixel offset between the points where the cursor was when the user pressed and released the mouse button while dragging the indicator) and then, to reflect the new setting, redraw the control and update the <CODE>contrlValue</CODE>
 field in the control structure. Note that, in this case, the functions <A HREF="ControlMgrRef.7.html#21975" CLASS="XRef"><CODE>HandleControlClick</A></CODE>
 and <A HREF="ControlMgrRef.7.html#34113" CLASS="XRef"><CODE>TrackControl</A></CODE>
 return 0 whether or not the user changes the indicator's position. Thus, you must determine whether the user has changed the control's setting by another method, for instance, by comparing the control's value before and after the call to <CODE>HandleControlClick</CODE>
.</P>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=72116">
 </A>
Executing an Action Function</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=197864">
 </A>
The only way to specify actions in response to all mouse-down events in a control or its indicator is to define your own control definition function that specifies an action function.
 When you create the control, your control definition function must first respond to the <CODE>initCntl</CODE>
 message by storing <CODE>(ControlDefUPP)-1L</CODE>
 in the <CODE>contrlAction</CODE>
 field of the control structure. (The Control Manager sends the <CODE>initCntl</CODE>
 message to your control definition function after initializing the fields of a new control structure.) Then, when your application passes <CODE>(ControlActionUPP)-1L</CODE>
 in the <CODE>actionProc</CODE>
 parameter of <A HREF="ControlMgrRef.7.html#21975" CLASS="XRef"><CODE>HandleControlClick</A></CODE>
 or <A HREF="ControlMgrRef.7.html#34113" CLASS="XRef"><CODE>TrackControl</A></CODE>
, <CODE>HandleControlClick</CODE>
 calls your control definition function with the <CODE>autoTrack</CODE>
 message. The Control Manager passes the part code of the part where the mouse-down event occurs in the <CODE>param</CODE>
 parameter. Your control definition function should then use this information to respond as an action function would.</P>
</DIV>
</DIV>
<DIV>
<blockquote><H3 CLASS="NoteHead">
<A NAME="pgfId=260335">
 </A>
Note</H3>
<P CLASS="Note">
<A NAME="pgfId=72122">
 </A>
For the <CODE>autoTrack</CODE>
 message, the high-order word of the <CODE>param</CODE>
 parameter may contain undefined data; therefore, evaluate only the low-order word of this parameter.</P></blockquote>
<P CLASS="T1.Text1">
<A NAME="pgfId=125633">
 </A>
If the mouse-down event occurs in an indicator of a control that supports live feedback, your action function should take two parameters (a handle to the control and the part code of the control where the mouse-down event first occurred). This action function is the same one you would use to define actions to be performed in control part codes in response to a mouse-down event; see <A HREF="ControlMgrRef.b.html#27959" CLASS="XRef">MyActionProc</A>
.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=197850">
 </A>
If the mouse-down event occurs in an indicator of a control that does not support live feedback, your action function should take no parameters, because the user may move the cursor outside the indicator while dragging it; see <A HREF="ControlMgrRef.b.html#29806" CLASS="XRef">MyIndicatorActionProc</A>
.</P>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=126517">
 </A>
Specifying Whether Appearance-Compliant Messages Are Supported</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=126518">
 </A>
If your control definition function supports Appearance-compliant messages, it should return <CODE>kControlSupportsNewMessages</CODE>
 as a function result when the Control Manager passes <CODE>kControlMsgTestNewMsgSupport</CODE>
 in the <CODE>message</CODE>
 parameter.</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260343">
 </A>
enum{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlSupportsNewMessages&nbsp;= ' ok '<BR>
};</CODE>
</DIV>
<DIV>
<BR><BR><H4 CLASS="UH.UserHd">
<A NAME="pgfId=174023">
 </A>
Constant description</H6>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260345">
 </A>
<CODE>kControlSupportsNewMessages</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=174025">
 </A>
<CODE>	</CODE>
 The control definition function supports new messages introduced with Mac OS 8 and the Appearance Manager. </DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=174018">
 </A>
<A NAME="13842">
 </A>
Specifying Which Appearance-Compliant Messages Are Supported</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=124235">
 </A>
If your control definition function supports Appearance-compliant messages, it should return a bit field of the features it supports in response to the <CODE>kControlMsgGetFeatures</CODE>
 message. Your control definition function should ignore the <CODE>param</CODE>
 parameter. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=123868">
 </A>
The bit field returned by your control definition function should be composed of one or more of the following bits:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260360">
 </A>
enum{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlSupportsGhosting&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 0,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlSupportsEmbedding&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlSupportsFocus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlWantsIdle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 3,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlWantsActivate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 4,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlHandlesTracking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 5,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlSupportsDataAccess&nbsp;&nbsp;= 1 &lt;&lt; 6,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlHasSpecialBackground= 1 &lt;&lt; 7,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlGetsFocusOnClick&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 8,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlSupportsCalcBestRect= 1 &lt;&lt; 9,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlSupportsLiveFeedback= 1 &lt;&lt; 10,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlHasRadioBehavior&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 11<BR>
};</CODE>
</DIV>
<DIV>
<BR><BR><H4 CLASS="UH.UserHd">
<A NAME="pgfId=123870">
 </A>
Constant descriptions</H6>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260364">
 </A>
<CODE>kControlSupportsGhosting</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123872">
 </A>
<CODE>	</CODE>
 If this bit (bit 0) is set, the control definition function supports the <CODE>kControlMsgDrawGhost</CODE>
 message. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260377">
 </A>
<CODE>kControlSupportsEmbedding</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123874">
 </A>
 If this bit (bit 1) is set, the control definition function supports the <CODE>kControlMsgSubControlAdded </CODE>
and <CODE>kControlMsgSubControlRemoved </CODE>
messages.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260388">
 </A>
<CODE>kControlSupportsFocus</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123876">
 </A>
 If this bit (bit 2) is set, the control definition function supports the <CODE>kControlMsgKeyDown</CODE>
 message. If this bit and the <CODE>kControlGetsFocusOnClick</CODE>
 bit are set, the control definition function supports the <CODE>kControlMsgFocus</CODE>
 message.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260401">
 </A>
<CODE>kControlWantsIdle</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123878">
 </A>
 If this bit (bit 3) is set, the control definition function supports the <CODE>kControlMsgIdle</CODE>
 message.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260414">
 </A>
<CODE>kControlWantsActivate</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123880">
 </A>
 If this bit (bit 4) is set, the control definition function supports the <CODE>kControlMsgActivate</CODE>
 message.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260427">
 </A>
<CODE>kControlHandlesTracking</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123882">
 </A>
 If this bit (bit 5) is set, the control definition function supports the <CODE>kControlMsgHandleTracking</CODE>
 message. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260438">
 </A>
<CODE>kControlSupportsDataAccess</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123884">
 </A>
 If this bit (bit 6) is set, the control definition function supports the <CODE>kControlMsgGetData</CODE>
 and <CODE>kControlMsgSetData</CODE>
 messages.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260451">
 </A>
<CODE>kControlHasSpecialBackground</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123886">
 </A>
 If this bit (bit 7) is set, the control definition function supports the <CODE>kControlMsgSetUpBackground</CODE>
 message. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260462">
 </A>
<CODE>kControlGetsFocusOnClick</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123888">
 </A>
<CODE>	</CODE>
 If this bit (bit 8) and the <CODE>kControlSupportsFocus</CODE>
 bit are set, the control definition function supports the <CODE>kControlMsgFocus</CODE>
 message.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260475">
 </A>
<CODE>kControlSupportsCalcBestRect</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123890">
 </A>
 If this bit (bit 9) is set, the control definition function supports the <CODE>kControlMsgCalcBestRect</CODE>
 message. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260486">
 </A>
<CODE>kControlSupportsLiveFeedback</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123892">
 </A>
 If this bit (bit 10) is set, the control definition function supports the <CODE>kControlMsgCalcValueFromPos </CODE>
message. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260497">
 </A>
<CODE>kControlHasRadioBehavior</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=123894">
 </A>
				 If this bit (bit 11) is set, the control definition function supports radio button behavior and can be embedded in a radio group control. This constant is available with Appearance 1.0.1 and later. </DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=93358">
 </A>
<CODE></CODE>
Drawing a Ghost Image of the Indicator</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=124001">
 </A>
If your control definition function supports indicator ghosting, it should return <CODE>kControlSupportsGhosting</CODE>
 as one of the feature bits in response to a <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set and the control indicator is being tracked, the Control Manager calls your control definition function and passes <CODE>kControlMsgDrawGhost</CODE>
 in the <CODE>message</CODE>
 parameter. A handle to the region where the ghost should be drawn will be passed in the <CODE>param</CODE>
 parameter. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=115443">
 </A>
Your control definition function should respond by redrawing the control with the ghosted indicator at the specified location and should return 0 as its function result.</P>
</DIV>
</DIV>
<DIV>
<blockquote><H3 CLASS="NoteHead">
<A NAME="pgfId=260510">
 </A>
Note</H3>
<P CLASS="Note">
<A NAME="pgfId=123988">
 </A>
The ghost indicator should always be drawn before the actual indicator so that it appears underneath the actual indicator. </P></blockquote>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=92471">
 </A>
Calculating the Optimal Control Rectangle</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=126473">
 </A>
If your control definition function supports calculating the optimal dimensions of the control rectangle, it should return <CODE>kControlSupportsCalcBestRect</CODE>
 as one of the feature bits in response to the <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set and <A HREF="ControlMgrRef.9.html#20341" CLASS="XRef"><CODE>GetBestControlRect</A></CODE>
 is called, the Control Manager will call your control definition function and pass <CODE>kControlMsgCalcBestRect</CODE>
 in the <CODE>message</CODE>
 parameter. The Control Manager passes a pointer to a control size calculation structure in the <CODE>param</CODE>
 parameter.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=115399">
 </A>
Your control definition function should respond by calculating the width and height of the optimal control rectangle and adjusting the rectangle by setting the <CODE>height</CODE>
 and <CODE>width</CODE>
 fields of the control size calculation structure to the appropriate values. If your control definition function displays text, it should pass in the offset from the bottom of control to the base of the text in the baseLine field of the structure. Your control definition function should return the offset value stored in the structure's <CODE>baseLine</CODE>
 field.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=98567">
 </A>
The control size calculation structure is a structure of type <CODE>ControlCalcSizeRec</CODE>
:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260514">
 </A>
struct ControlCalcSizeRec {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SInt16 &nbsp;height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SInt16 &nbsp;width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SInt16 &nbsp;baseLine;<BR>
};<BR>
typedef struct ControlCalcSizeRec ControlCalcSizeRec;<BR>
typedef ControlCalcSizeRec *ControlCalcSizePtr;</CODE>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260518">
 </A>
<CODE>height</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=98576">
 </A>
The optimal height (in pixels) of the control's bounding rectangle. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260528">
 </A>
<CODE>width</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=124079">
 </A>
The optimal width (in pixels) of the control's bounding rectangle. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260537">
 </A>
<CODE>baseLine</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=124047">
 </A>
The offset from the bottom of the control to the base of the text. This value is generally negative. </DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=92472">
 </A>
<A NAME="24261">
 </A>
Performing Custom Tracking </H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=125435">
 </A>
If your control definition function supports custom tracking, it should return <CODE>kControlHandlesTracking</CODE>
 as one of the feature bits in response to a <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set and a mouse-down event occurs in your control, <A HREF="ControlMgrRef.7.html#34113" CLASS="XRef"><CODE>TrackControl</A></CODE>
 or <A HREF="ControlMgrRef.7.html#21975" CLASS="XRef"><CODE>HandleControlClick</A></CODE>
 calls your control definition function and passes <CODE>kControlMsgHandlesTracking</CODE>
 in the <CODE>message</CODE>
 parameter. The Control Manager passes a pointer to a control tracking structure in the <CODE>param</CODE>
 parameter. Your control definition function should respond appropriately and return the part code that was hit, or <CODE>kControlNoPart</CODE>
 if the mouse-down event occurred outside the control; see <A HREF="ControlMgrRef.1d.html#13866" CLASS="XRef">Control Part Code Constants</A>
.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=114542">
 </A>
The control tracking structure is a structure of type <CODE>ControlTrackingRec</CODE>
:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260548">
 </A>
struct ControlTrackingRec {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Point &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SInt16 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modifiers;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ControlActionUPP &nbsp;&nbsp;&nbsp;action;<BR>
};<BR>
typedef struct ControlTrackingRec ControlTrackingRec;<BR>
typedef ControlTrackingRec *ControlTrackingPtr;</CODE>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260552">
 </A>
<CODE>startPt</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=98404">
 </A>
The location of the cursor at the time the mouse button was first pressed, in local coordinates. Your application retrieves this point from the <CODE>where</CODE>
 field of the event structure.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260562">
 </A>
<CODE>modifiers</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=125052">
 </A>
The constant in the <CODE>modifiers</CODE>
 field of the event structure specifying the state of the modifier keys and the mouse button at the time the event was posted. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260571">
 </A>
<CODE>action</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=98415">
 </A>
A pointer to an action function defining what action your application takes while the user holds down the mouse button. The value of the <CODE>actionProc</CODE>
 parameter can be a valid <CODE>procPtr</CODE>
, <CODE>nil</CODE>
, or -1. A value of -1 indicates that the control should either perform auto tracking, or if it is incapable of doing so, do nothing (like <CODE>nil</CODE>
).</DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=105554">
 </A>
<A NAME="32933">
 </A>
Handling Keyboard Focus</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=125606">
 </A>
If your control definition function can change its keyboard focus, it should set <CODE>kControlSupportsFocus</CODE>
 and <CODE>kControlGetsFocusOnClick</CODE>
 as feature bits in response to a <CODE>kControlMsgGetFeatures</CODE>
 message. If these bits are set and the <A HREF="ControlMgrRef.8.html#16134" CLASS="XRef"><CODE>AdvanceKeyboardFocus</A></CODE>
, <A HREF="ControlMgrRef.8.html#10462" CLASS="XRef"><CODE>ReverseKeyboardFocus</A></CODE>
, <A HREF="ControlMgrRef.8.html#27306" CLASS="XRef"><CODE>ClearKeyboardFocus</A></CODE>
, or <A HREF="ControlMgrRef.8.html#35678" CLASS="XRef"><CODE>SetKeyboardFocus</A></CODE>
 function is called, the Control Manager calls your control definition function and passes <CODE>kControlMsgFocus</CODE>
 in the <CODE>message</CODE>
 parameter.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=209350">
 </A>
The Control Manager passes one of the control focus part code constants described below or a valid part code in the <CODE>param </CODE>
parameter. Your control definition function should respond by adjusting the focus accordingly.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=125861">
 </A>
Your control definition function should return the control focus part code or actual control part that was focused on. Return <CODE>kControlFocusNoPart</CODE>
 if your control does not accept focus or has just relinquished it. Return a nonzero part code to indicate that your control received keyboard focus. Your control definition function is responsible for maintaining which part is focused.</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260582">
 </A>
enum {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlFocusNoPart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlFocusNextPart&nbsp;&nbsp;&nbsp;= -1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;kControlFocusPrevPart&nbsp;&nbsp;&nbsp;= -2<BR>
};<BR>
typedef SInt16 ControlFocusPart;</CODE>
</DIV>
<DIV>
<BR><BR><H4 CLASS="UH.UserHd">
<A NAME="pgfId=194486">
 </A>
Constant descriptions</H6>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260586">
 </A>
<CODE>kControlFocusNoPart</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=194501">
 </A>
 Your control definition function should relinquish its focus and return <CODE>kControlFocusNoPart</CODE>
. It might respond by deactivating its text edit handle and erasing its focus ring. If the control is at the end of its subparts, it should return <CODE>kControlFocusNoPart</CODE>
. This tells the focusing mechanism to jump to the next control that supports focus.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260597">
 </A>
<CODE>kControlFocusNextPart</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=194505">
 </A>
 Your control definition function should change keyboard focus to its next part, the entire control, or remove keyboard focus from the control, depending upon the circumstances. For multiple part controls that already had keyboard focus, the next part of the control would receive keyboard focus when <CODE>kControlFocusNextPart</CODE>
 was passed in the <CODE>param</CODE>
 parameter. For example, a clock control with keyboard focus would change its focus to the left-most element of the control (the month field). For single-part controls that did not have keyboard focus and are now receiving it, the entire control would receive keyboard focus when <CODE>kControlFocusNextPart</CODE>
 was passed in the <CODE>param</CODE>
 parameter. For single-part controls that already had keyboard focus and are now losing it, the entire control would lose keyboard focus. If you are passed <CODE>kControlFocusNextPart</CODE>
 and have run out of parts, return <CODE>kControlFocusNoPart</CODE>
 to indicate that the user tabbed past the control.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260620">
 </A>
<CODE>kControlFocusPrevPart</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=194513">
 </A>
 Your control definition function should change keyboard focus to its previous part, the entire control, or remove keyboard focus from the control, depending upon the circumstances. For multiple part controls that already had keyboard focus, the previous part of the control would receive keyboard focus when <CODE>kControlFocusPrevPart</CODE>
 was passed in the <CODE>param</CODE>
 parameter. For example, a clock control with keyboard focus would change its focus to the right-most element of the control (the year field). For single-part controls that did not have keyboard focus and are now receiving it, the entire control would receive keyboard focus when <CODE>kControlFocusNextPart</CODE>
 was passed in the <CODE>param</CODE>
 parameter. For single-part controls that already had keyboard focus and are now losing it, the entire control would lose keyboard focus. If you are passed <CODE>kControlFocusPrevPart</CODE>
 and have run out of parts, return <CODE>kControlFocusNoPart</CODE>
 to indicate that the user tabbed past the control.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260643">
 </A>
<CODE>&lt;part code&gt;</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=194509">
 </A>
Your control definition function should focus on the specified part code. Your function can interpret this in any way it wishes.</DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=98520">
 </A>
Handling Keyboard Events</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=115258">
 </A>
If your control definition function can handle keyboard events, it should return <CODE>kControlSupportsFocus</CODE>
--every control that supports keyboard focus must also be able to handle keyboard events--as one of the feature bits in response to a <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set, the Control Manager will pass <CODE>kControlMsgKeyDown</CODE>
 in the <CODE>message</CODE>
 parameter. The Control Manager passes a pointer to a control key down structure in the <CODE>param </CODE>
parameter. Your control definition function should respond by processing the keyboard event as appropriate and return 0 as the function result.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=115259">
 </A>
The control key down structure is a structure of type <CODE>ControlKeyDownRec</CODE>
:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260654">
 </A>
struct ControlKeyDownRec {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SInt16&nbsp;&nbsp;modifiers;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SInt16&nbsp;&nbsp;keyCode;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SInt16&nbsp;&nbsp;charCode;<BR>
};<BR>
typedef struct ControlKeyDownRec ControlKeyDownRec;<BR>
typedef ControlKeyDownRec *ControlKeyDownPtr;</CODE>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260658">
 </A>
<CODE>modifiers</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=98437">
 </A>
The constant in the <CODE>modifiers</CODE>
 field of the event structure specifying the state of the modifier keys and the mouse button at the time the event was posted. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260668">
 </A>
<CODE>keyCode</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=98444">
 </A>
The virtual key code derived from the event structure. This value represents the key pressed or released by the user. It is always the same for a specific physical key on a particular keyboard regardless of which modifier keys were also pressed.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260677">
 </A>
<CODE>charCode</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=98445">
 </A>
A particular character derived from the event structure. This value depends on the virtual key code, the state of the modifier keys, and the current <CODE>'KCHR'</CODE>
 resource. </DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=92365">
 </A>
<A NAME="11861">
 </A>
Performing Idle Processing</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=115298">
 </A>
If your control definition function can perform idle processing, it should return <CODE>kControlWantsIdle</CODE>
 as one of the feature bits in response to a <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set and <A HREF="ControlMgrRef.7.html#28111" CLASS="XRef"><CODE>IdleControls</A></CODE>
 is called for the window your control is in, the Control Manager will pass <CODE>kControlMsgIdle</CODE>
 in the <CODE>message</CODE>
 parameter. Your control definition function should ignore the <CODE>param</CODE>
 parameter and respond appropriately. For example, indeterminate progress indicators and asynchronous arrows use idle time to perform their animation. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=126401">
 </A>
Your control definition function should return 0 as the function result.</P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=103670">
 </A>
Getting and Setting Control-Specific Data</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=126147">
 </A>
If your control definition function supports getting and setting control-specific data, it should return <CODE>kControlSupportsDataAccess</CODE>
 as one of its features bits in response to the <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set, the Control Manager will call your control definition function and pass <CODE>kControlMsgSetData</CODE>
 in the <CODE>message</CODE>
 parameter when <A HREF="ControlMgrRef.9.html#18086" CLASS="XRef"><CODE>SetControlData</A></CODE>
 is called, and will pass <CODE>kControlMsgGetData</CODE>
 in the <CODE>message</CODE>
 parameter when <A HREF="ControlMgrRef.9.html#22231" CLASS="XRef"><CODE>GetControlData</A></CODE>
 and <A HREF="ControlMgrRef.9.html#21370" CLASS="XRef"><CODE>GetControlDataSize</A></CODE>
 are called. The Control Manager passes a pointer to a control data access structure in the <CODE>param</CODE>
 parameter. Your definition function should respond by filling out the structure and returning an operating system status message as the function result.</P>

<A NAME="pgfId=260688">
 </A>
The control data access structure is a structure of type <CODE CLASS="Cv.Code">ControlDataAccessRec: <P>

<A NAME="pgfId=260692">
 </A>
struct ControlDataAccessRec{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ResType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ResType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataPtr;<BR>
};<BR>
typedef struct ControlDataAccessRec ControlDataAccessRec;<BR>
typedef ControlDataAccessRec *ControlDataAccessPtr;</CODE>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260696">
 </A>
<CODE>tag</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=114845">
 </A>
A constant representing a piece of data that is passed in (in response to a <CODE>kControlMsgSetData</CODE>
 message) or returned (in response to a <CODE>kControlMsgGetData</CODE>
 message); see <A HREF="ControlMgrRef.12.html#19583" CLASS="XRef">Control Data Tag Constants</A>
 for a description of these constants. The control definition function should return <CODE>errDataNotSupported</CODE>
 if the value in the <CODE>tag</CODE>
 parameter is unknown or invalid.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260706">
 </A>
<CODE>part</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=114853">
 </A>
The part of the control that this data should be applied to. If the information is not tied to a specific part of the control or the control has no parts, pass 0. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260715">
 </A>
<CODE>size</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=114854">
 </A>
On entry, the size of the buffer pointed to by the <CODE>dataPtr </CODE>
field. In response to a <CODE>kControlMsgGetData</CODE>
 message, this field should be adjusted to reflect the actual size of the data that the control is maintaining. If the size of the buffer being passed in is smaller than the actual size of the data, the control definition function should return <CODE>errDataSizeMismatch</CODE>
.</DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260724">
 </A>
<CODE>dataPtr</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=114864">
 </A>
A pointer to a buffer to read or write the information requested. In response to a <CODE>kControlMsgGetData</CODE>
 message, this field could be <CODE>nil</CODE>
, indicating that you wish to return the size of the data in the <CODE>size</CODE>
 field.</DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=92505">
 </A>
Handling Activate and Deactivate Events</H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=126371">
 </A>
If your control definition function wants to be informed whenever it is being activated or deactivated, it should return <CODE>kControlWantsActivate</CODE>
 as one of the feature bits in response to the <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set and your control definition function is being activated or deactivated, the Control Manager calls it and passes <CODE>kControlMsgActivate</CODE>
 in the <CODE>message</CODE>
 parameter. The Control Manager passes a 0 or 1 in the <CODE>param</CODE>
 parameter. A value of 0 indicates that the control is being deactivated; 1 indicates that it is being activated. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=115467">
 </A>
Your control definition function should respond by performing any special processing before the user pane becomes activated or deactivated, such as deactivating its <CODE>TEHandle</CODE>
 or <CODE>ListHandle</CODE>
 if it is about to be deactivated. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=114341">
 </A>
Your control definition function should return 0 as the function result.</P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=93955">
 </A>
<A NAME="37970">
 </A>
Setting a Control's Background Color or Pattern </H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=115479">
 </A>
If your control definition function supports embedding and draws its own background, it should return <CODE>kControlHasSpecialBackground</CODE>
 as one of the feature bits in response to the <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set and an embedding hierarchy of controls is being drawn in your control, the Control Manager passes <CODE>kControlMsgSetUpBackground</CODE>
 in the <CODE>message</CODE>
 parameter of your control definition function. The Control Manager passes a pointer to a filled-in control background structure in the <CODE>param</CODE>
 parameter. Your control definition function should respond by setting its background color or pattern to whatever is appropriate given the bit depth and device type passed in. Your control definition function should return 0 as the function result. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=98625">
 </A>
The control background structure is a structure of type <CODE>ControlBackgroundRec</CODE>
:</P>
<CODE CLASS="Cv.Code">
<A NAME="pgfId=260735">
 </A>
struct ControlBackgroundRec {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SInt16 &nbsp;depth;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Boolean&nbsp;colorDevice;<BR>
};<BR>
typedef struct ControlBackgroundRec ControlBackgroundRec;<BR>
typedef ControlBackgroundRec *ControlBackgroundPtr;</CODE>
<DL COMPACT>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260739">
 </A>
<CODE>depth</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=100366">
 </A>
A signed 16-bit integer indicating the bit depth (in pixels) of the current graphics port. </DD>
<DT CLASS="DT.DefinitionTerm">
<A NAME="pgfId=260749">
 </A>
<CODE>colorDevice</CODE>
</DT>
<DD CLASS="DD.DefinitionDef">
<A NAME="pgfId=100367">
 </A>
A Boolean value. If <CODE>true</CODE>
,<CODE> </CODE>
you are drawing on a color device. If <CODE>false</CODE>
, you are drawing on a monochrome device.</DD>
</DL COMPACT>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=93192">
 </A>
Supporting Live Feedback </H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=126365">
 </A>
If your control definition function supports live feedback while tracking the indicator, it should return <CODE>kControlSupportsLiveFeedback</CODE>
 as one of the feature bits in response to the <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set, the Control Manager will call your control definition function when it tracks the indicator and pass <CODE>kControlMsgCalcValueFromPos</CODE>
 in the <CODE>message</CODE>
 parameter. The Control Manager passes a handle to the indicator region being dragged in the <CODE>param</CODE>
 parameter. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=115602">
 </A>
Your control definition function should respond by calculating its value and drawing the control based on the new indicator region passed in. Your control definition function should not recalculate its indicator position. After the user is done dragging the indicator, your control definition function will be called with a <CODE>posCntl</CODE>
 message at which time you can recalculate the position of the indicator. Not recalculating the indicator position each time your control definition function is called creates a smooth dragging experience for the user.</P>
<P CLASS="T1.Text1">
<A NAME="pgfId=115634">
 </A>
Your control definition function should return 0 as the function result.</P>
</DIV>
<DIV>
<BR><H4 CLASS="H4.Heading4">
<A NAME="pgfId=126258">
 </A>
Being Informed When Subcontrols Are Added or Removed </H6>
<P CLASS="T1.Text1">
<A NAME="pgfId=126259">
 </A>
If your control definition function wishes to be informed when subcontrols are added or removed, it should return <CODE>kControlSupportsEmbedding</CODE>
 as one of the feature bits in response to the <CODE>kControlMsgGetFeatures</CODE>
 message. If this bit is set, the Control Manager passes <CODE>ControlMsgSubControlAdded</CODE>
 in the <CODE>message</CODE>
 parameter immediately after a subcontrol is added, or it passes <CODE>kControlMsgSubControlRemoved</CODE>
 just before a subcontrol is removed from your embedder control. A handle to the control being added or removed from the embedding hierarchy is passed in the <CODE>param</CODE>
 parameter. Your control definition function should respond appropriately and return 0 as the function result. </P>
<P CLASS="T1.Text1">
<A NAME="pgfId=126307">
 </A>
Typically, a control definition function only supports this message if it wants to do extra processing in response to changes in its embedded controls. Radio groups use these messages to perform necessary processing for handling embedded controls. For example, if a currently selected radio button is deleted, the group can adjust itself accordingly.</P>
</DIV>
</DIV>
<HR>\xA9 1998 Apple Computer, Inc. &#150 (Last Updated 19 Nov 98)<P><A HREF="ControlMgrRef.2.html" border="0"><img src="images/up.gif" border="0"></A> <A HREF="ControlMgrRef.9.html"><img src="images/previous.gif" border="0"></A> <A HREF="ControlMgrRef.b.html"><img src="images/next.gif" border="0"></A> 

<!-- insert Show/Hide frames -->
<a href="javascript:testFrame()">
<script>
<!--
 document.write(frameLink);
//-->
</script><!-- end Show/Hide frames --></a>

<!-- start of footer -->
<!--#include virtual="/includes/framesetfooter" -->
<!-- end of footer -->

</body>
</HTML>
