<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Live Scroll - /Windows.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxUserExperience-date.html">User Experience</a> &gt; <A HREF="javascript:location.replace('index.html');">Live Scroll</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxUserExperience-date.html" target="_blank">Carbon > User Experience</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Live Scroll</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Windows.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AppleEvents.c</option>
<option value="listing2.html">/BareBones.c</option>
<option value="listing3.html">/BareBones.h</option>
<option value="listing4.html">/Events.c</option>
<option value="listing5.html">/Initialize.c</option>
<option value="listing6.html">/Menus.c</option>
<option value="listing7.html">/Prototypes.h</option>
<option value="listing8.html">/ScrollBars.c</option>
<option value="listing9.html">/ScrollBars.h</option>
<option value="listing10.html">/Utilities.c</option>
<option value="listing11.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Live_Scroll.zip">Download Sample</a></strong> (&#147;Live_Scroll.zip&#148;, 39.5K)<BR>
<strong><a href="Live_Scroll.dmg">Download Sample</a></strong> (&#147;Live_Scroll.dmg&#148;, 100.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    Windows.c  Contains:  Handle application's windows  Written by: Chris White    Copyright:  Copyright &copy; 1996-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/6/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#pragma segment Core#include &lt;Sound.h&gt;// System Includes#ifndef __TYPES__  #include &lt;Types.h&gt;#endif#ifndef __WINDOWS__  #include &lt;Windows.h&gt;#endif#ifndef __DIALOGS__  #include &lt;Dialogs.h&gt;#endif#ifndef __QUICKDRAW__  #include &lt;Quickdraw.h&gt;#endif#ifndef __PICTUTILS__  #include &lt;PictUtils.h&gt;#endif#ifndef __RESOURCES__  #include &lt;Resources.h&gt;#endif#ifndef __FONTS__  #include &lt;Fonts.h&gt;#endif#ifndef __TOOLUTILS__  #include &lt;ToolUtils.h&gt;#endif#ifndef __ERRORS__  #include &lt;Errors.h&gt;#endif// Application Includes#ifndef __BAREBONES__  #include &quot;BareBones.h&quot;#endif#ifndef __PROTOTYPES__  #include &quot;Prototypes.h&quot;#endif// Static prototypesstatic OSErr    CreateDocumentWindow ( WindowRef* windowRef );static GWorldPtr  CreateOffscreen ( CTabHandle theCTabHndl, SInt16 theXsize, SInt16 theYsize,                    SInt16 theBitDepth, GWorldFlags theFlags );static OSErr    DrawPictToOffscreen ( PicHandle thePictHndl, GWorldPtr theOffscreen );static OSErr    DrawOffscreenToWindow ( GWorldPtr theOffscreen, WindowPtr theWindow );static Rect      GetWindowVisibleRect ( WindowRef theWindow, SInt16 theSizeX, SInt16 theSizeY );static void      SaveSetMMUMode ( Boolean bIsSaveMode );static void      DrawClippedScrollBarLines ( WindowRef theWindow );static void      DrawClippedGrowIcon ( WindowRef theWindow );static void      HandleContentClick ( WindowRef theWindow, EventRecord* event );static OSErr    CreateWindowInfo ( WindowRef windowRef, Size infoSize );static pascal OSErr  SafeGetPictInfo ( PicHandle thePictHandle, PictInfo* thePictInfo,                    SInt16 verb, SInt16 colorsRequested,                    SInt16 colorPickMethod, SInt16 version );static void      SizeScrollBars ( WindowRef theWindow );static Point    GetMaximumWindowSize ( WindowRef theWindow );// Default RGB Colorsstatic const RGBColor   kRGBBlack = {0x0000, 0x0000, 0x0000};static const RGBColor  kRGBWhite = {0xFFFF, 0xFFFF, 0xFFFF};//// This is called to create the application's window.//void CreateWindow ( void ){  OSErr    theErr;  WindowRef  theWindow;    theErr = CreateDocumentWindow ( &amp;theWindow );  if ( theErr )    AlertUser ( kGenericErrorStr, theErr, &quot;\p&quot; );    return;}//// This will close the application's window, dispose of any storage we've hung// off the window, and then dispose of the window itself.//WindowRef DestroyWindow ( WindowRef windowRef ){  if ( windowRef )  {    tWindowInfoPtr  theInfo;        theInfo = (tWindowInfoPtr) GetWRefCon ( windowRef );    if ( theInfo )    {      if ( theInfo-&gt;hScrollBar )        DisposeControl ( theInfo-&gt;hScrollBar );      if ( theInfo-&gt;vScrollBar )        DisposeControl ( theInfo-&gt;vScrollBar );              if ( theInfo-&gt;offscreen )        DisposeGWorld ( theInfo-&gt;offscreen );                    DisposePtr ( (Ptr) theInfo );    }        DisposeWindow ( windowRef );      }    return nil;}void DoActivate ( EventRecord* theEvent ){  Boolean      bActiveFlag = theEvent-&gt;modifiers &amp; resumeFlag;  WindowRef    theWindow = (WindowRef) theEvent-&gt;message;  GrafPtr      savePort;  tWindowInfoPtr  theInfo;      gInBackground = (theEvent-&gt;modifiers &amp; resumeFlag) == 0;    GetPort ( &amp;savePort );  SetPortWindowPort ( theWindow );    theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );    if ( bActiveFlag )  {    ShowControl ( theInfo-&gt;hScrollBar );    ShowControl ( theInfo-&gt;vScrollBar );  }  else  {    HideControl ( theInfo-&gt;hScrollBar );    HideControl ( theInfo-&gt;vScrollBar );    DrawClippedScrollBarLines ( theWindow );  }    DrawClippedGrowIcon ( theWindow );    SetPort ( savePort );    return;}void DoUpdate ( WindowRef theWindow ){  GrafPtr      savePort;  CGrafPtr    thePort;      thePort = GetWindowPort ( theWindow );    GetPort ( &amp;savePort );  SetPortWindowPort ( theWindow );  BeginUpdate ( theWindow );          // visRgn temporarily = updateRgn  EraseRect ( &amp;thePort-&gt;portRect );    UpdateWindowContent ( theWindow );    if ( gInBackground )    DrawClippedScrollBarLines ( theWindow );  else    UpdateControls ( theWindow, theWindow-&gt;visRgn );  DrawClippedGrowIcon ( theWindow );    EndUpdate ( theWindow );          // restore normal visRgn of grafport  SetPort ( savePort );    return;}void UpdateWindowContent ( WindowRef theWindow ){    tWindowInfoPtr  theInfo;        theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );  DrawOffscreenToWindow ( theInfo-&gt;offscreen, theWindow );    return;}void DoContentClick ( WindowRef theWindow, EventRecord* theEvent ){  OSErr    theErr = noErr;  WindowRef  frontWindow;    // If a movable modal is active, ignore click in an inactive   // window, otherwise select it or handle the content click.    frontWindow = FrontWindow ( );  if ( theWindow != frontWindow )  {    if ( IsMovableModal ( frontWindow ) )      SysBeep ( 30 );    else      SelectWindow ( theWindow );  }  else  {    SInt16      thePart;    GrafPtr      savePort;    ControlRef    theControl;    Point      localPt;      localPt = theEvent-&gt;where;    GlobalToLocal ( &amp;localPt );    thePart = FindControl ( localPt, theWindow, &amp;theControl );        GetPort ( &amp;savePort );    SetPortWindowPort ( theWindow );        if ( thePart )    {      switch ( thePart )      {        case kControlUpButtonPart:        case kControlDownButtonPart:        case kControlPageUpPart:        case kControlPageDownPart:          TrackControl ( theControl, localPt, gScrollControlActionUPP );        break;                case kControlIndicatorPart:          if ( BeginThumbTracking ( theControl ) == noErr )          {            TrackControl ( theControl, localPt,                    (ControlActionUPP) gScrollThumbActionUPP );            EndThumbTracking ( );          }        break;      }    }    else      HandleContentClick ( theWindow, theEvent );          SetPort ( savePort );  }      return;  } // DoContentClickvoid DoGrowWindow ( WindowRef theWindow, EventRecord* theEvent ){  WindowPtr      savePort;  SInt32        returnCoord;  Rect        resizeBounds;  SInt16        theWidth,            theHeight;  Point        theMaxSize;    GetPort ( &amp;savePort );  theMaxSize = GetMaximumWindowSize ( theWindow );  SetRect ( &amp;resizeBounds, 96, 96, theMaxSize.h, theMaxSize.v );  returnCoord = GrowWindow ( theWindow, theEvent-&gt;where, &amp;resizeBounds );  theHeight   = HiWord ( returnCoord );  theWidth = LoWord ( returnCoord );    SizeWindow ( theWindow, theWidth, theHeight, true );  SizeScrollBars ( theWindow );  SetPort ( theWindow );  InvalRect ( &amp;theWindow-&gt;portRect );    SetPort ( savePort );      return;}void DoDragWindow ( WindowRef theWindow, EventRecord* theEvent ){  WindowRef  frontWindow;      // If a movable modal is active, ignore click in an inactive   // title bar, otherwise let the Window Manager handle it.    frontWindow = FrontWindow ( );  if ( theWindow != frontWindow &amp;&amp; IsMovableModal ( frontWindow ) )    SysBeep ( 30 );  else                  {    RgnHandle  theRgn;    Rect    dragRect;        theRgn = GetGrayRgn ( );    dragRect = (*theRgn)-&gt;rgnBBox;    DragWindow ( theWindow, theEvent-&gt;where, &amp;dragRect );  }    return;}OSErr DoAboutBox ( void ){  OSErr      theErr = noErr;  SInt16      theItem = 0;  GrafPtr      savePort = nil;  DialogRef    theDialog;  ModalFilterUPP  theFilter = nil;      theDialog = GetNewDialog ( kAboutDialog, nil, (WindowPtr) -1 );    GetPort ( &amp;savePort );  SetPort ( theDialog );  ShowWindow ( theDialog );    // Get the standard filter proc  theErr = GetStdFilterProc ( &amp;theFilter );  if ( theErr )    goto CleanupAndBail;    // Tell the dialog manager to use the default button  SetDialogDefaultItem ( theDialog, kStdOkItemIndex );          // Modal dialog loop    do  {    // Use &quot;theFilter&quot; in ModalDialog call       ModalDialog ( theFilter, &amp;theItem );         } while ( theItem != kStdOkItemIndex );    CleanupAndBail:    DisposeDialog ( theDialog );  SetPort ( savePort );  return theErr;}//// Creates a document window containing a picture.//static OSErr CreateDocumentWindow ( WindowRef* windowRef ){  OSErr      theErr = noErr;  WindowRef    theWindow;  Point      theImageSize;  PicHandle    thePict = nil;  PictInfo    thePictInfo;  tWindowInfoPtr  theInfo;        theWindow = GetNewCWindow ( kDisplayWindow, nil, (WindowRef) -1 );  if ( theWindow == nil )    return (ResError ( )) ? ResError ( ) : resNotFound;    theErr = CreateWindowInfo ( theWindow, sizeof ( tWindowInfo ) );  if ( theErr )  goto CleanupAndBail;    theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );    SetPortWindowPort ( theWindow );    thePict = GetPicture ( kPictureID );  if ( thePict == nil )  goto CleanupAndBail;    theErr = SafeGetPictInfo ( thePict, &amp;thePictInfo, returnColorTable, 256, systemMethod, 0 );  if ( theErr )  goto CleanupAndBail;    theImageSize.h = thePictInfo.sourceRect.right - thePictInfo.sourceRect.left;  theImageSize.v = thePictInfo.sourceRect.bottom - thePictInfo.sourceRect.top;    theInfo-&gt;offscreen = CreateOffscreen ( (thePictInfo.depth &lt;= 8) ? thePictInfo.theColorTable : nil,                      theImageSize.h, theImageSize.v, thePictInfo.depth,                      kNoFlags );  if ( theInfo-&gt;offscreen == nil )  goto CleanupAndBail;    theInfo-&gt;hScrollBar = GetNewControl ( kScrollBar, theWindow );  theInfo-&gt;vScrollBar = GetNewControl ( kScrollBar, theWindow );  if ( theInfo-&gt;hScrollBar == nil || theInfo-&gt;vScrollBar == nil)    goto CleanupAndBail;      // Setup the correct control values  SetControlMinimum ( theInfo-&gt;hScrollBar, 0 );  SetControlMinimum ( theInfo-&gt;vScrollBar, 0 );  SetControlValue ( theInfo-&gt;hScrollBar, 0 );  SetControlValue ( theInfo-&gt;vScrollBar, 0 );    SizeScrollBars ( theWindow );    theErr = DrawPictToOffscreen ( thePict, theInfo-&gt;offscreen );  if ( theErr )  goto CleanupAndBail;    SelectWindow ( theWindow );  ShowWindow ( theWindow );    *windowRef = theWindow;    if ( thePict )    ReleaseResource ( (Handle) thePict );      return noErr;  CleanupAndBail:    // Don't forget to free any storage we've used so far  if ( thePict )    ReleaseResource ( (Handle) thePict );    DestroyWindow ( theWindow );    return theErr;}static GWorldPtr CreateOffscreen ( CTabHandle theCTabHndl, SInt16 theXsize, SInt16 theYsize,                  SInt16 theBitDepth, GWorldFlags theFlags ){  GWorldPtr  theGWorld = nil;  QDErr    theErr;  Rect    theRect;      SetRect ( &amp;theRect, 0, 0, theXsize, theYsize );  theErr = NewGWorld ( &amp;theGWorld, theBitDepth, &amp;theRect, theCTabHndl, nil, theFlags );    #if WARNINGS  if ( theErr )    DebugStrNum ( &quot;\p CreateOffscreen: &quot;, theErr );  #endif    return theGWorld;}static OSErr DrawPictToOffscreen ( PicHandle thePictHndl, GWorldPtr theOffscreen ){  PixMapHandle  theGWorldPMHndl;  GDHandle    saveGDevice;  CGrafPtr    saveGWorld;  OSErr      theErr = noErr;      GetGWorld ( &amp;saveGWorld, &amp;saveGDevice );  SetGWorld ( theOffscreen, nil );    // We'll initialize out port settings here.  // If you don't set the foreground and background colors to black  // and white, colorisation can occur during the call to CopyBits.  RGBForeColor ( &amp;kRGBBlack );                RGBBackColor ( &amp;kRGBWhite );  // Reset the transfer mode  PenMode ( srcCopy );                        theGWorldPMHndl = GetGWorldPixMap ( theOffscreen );  LockPixels ( theGWorldPMHndl );    EraseRect ( &amp;theOffscreen-&gt;portRect );  // render the image into the offscreen buffer  HLock ( (Handle) thePictHndl );  DrawPicture ( thePictHndl, &amp;theOffscreen-&gt;portRect );  HUnlock ( (Handle) thePictHndl );    UnlockPixels ( theGWorldPMHndl );  SetGWorld ( saveGWorld, saveGDevice );    return  theErr;}static OSErr DrawOffscreenToWindow ( GWorldPtr theOffscreen, WindowPtr theWindow ){  OSErr      theErr = noErr;  CGrafPtr    savePort = nil;  GDHandle    saveGDevice;  PixMapHandle  thePixMapHndl = nil;  RGBColor    saveForeColor,          saveBackColor;  Rect      sourceRect,          destRect;      GetGWorld ( &amp;savePort, &amp;saveGDevice );  SetGWorld ( theOffscreen, nil );  GetForeColor ( &amp;saveForeColor );  GetBackColor ( &amp;saveBackColor );    RGBForeColor ( &amp;kRGBBlack );  RGBBackColor ( &amp;kRGBWhite );  thePixMapHndl = GetGWorldPixMap ( theOffscreen );  if ( PixMap32Bit ( thePixMapHndl ) )          // if 32bit mode needed == true    SaveSetMMUMode ( true );  if ( !LockPixels ( thePixMapHndl ) )    goto CleanupAndBail;      sourceRect = theOffscreen-&gt;portRect;  destRect = theWindow-&gt;portRect;  destRect.right -= kScrollBarWidth;            // exclude scrollbar area  destRect.bottom -= kScrollBarWidth;  if ( !EqualRect ( &amp;sourceRect, &amp;destRect ) )    sourceRect = GetWindowVisibleRect ( theWindow, destRect.right, destRect.bottom );  SetGWorld ( savePort, saveGDevice );  savePort = nil;    CopyBits ( (BitMap*) *thePixMapHndl, (BitMap*) &amp;theWindow-&gt;portBits,          &amp;sourceRect, &amp;destRect, srcCopy, nil);    CleanupAndBail:    if ( savePort )    SetGWorld ( savePort, saveGDevice );    RGBForeColor ( &amp;saveForeColor );  RGBBackColor ( &amp;saveBackColor );  UnlockPixels ( thePixMapHndl );  SaveSetMMUMode ( false );    return theErr;}static void DrawClippedScrollBarLines ( WindowRef theWindow ){  CGrafPtr  thePort;  Rect    theRect;      thePort = GetWindowPort ( theWindow );  theRect = thePort-&gt;portRect;    MoveTo ( theRect.left, theRect.bottom - kScrollBarWidthAdjust );  LineTo ( theRect.right - kScrollBarWidthAdjust, theRect.bottom - kScrollBarWidthAdjust );  MoveTo ( theRect.right - kScrollBarWidthAdjust, theRect.top );  LineTo ( theRect.right - kScrollBarWidthAdjust, theRect.bottom - kScrollBarWidthAdjust );    return;}static void DrawClippedGrowIcon ( WindowRef theWindow ){  CGrafPtr  thePort;  RgnHandle  saveClip = nil;  Rect    newClip;      thePort = GetWindowPort ( theWindow );  saveClip = NewRgn ( );  GetClip ( saveClip );    newClip = thePort-&gt;portRect;  newClip.top = newClip.bottom - kScrollBarWidth;  newClip.left = newClip.right - kScrollBarWidth;  ClipRect ( &amp;newClip );  DrawGrowIcon ( theWindow );    SetClip ( saveClip );  DisposeRgn ( saveClip );    return;}static Rect GetWindowVisibleRect ( WindowRef theWindow, SInt16 theSizeX, SInt16 theSizeY ){  Rect      displayRect;  SInt16      theValueX,          theValueY;  tWindowInfoPtr  theInfo;    theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );  theValueX = GetControlValue ( theInfo-&gt;hScrollBar );  theValueY = GetControlValue ( theInfo-&gt;vScrollBar );  SetRect ( &amp;displayRect, theValueX, theValueY, theValueX + theSizeX, theValueY + theSizeY );    return displayRect;}static void  SaveSetMMUMode ( Boolean bIsSaveMode ){  static signed char    theAddrMode = true32b;  static Boolean      bSwapModeNeeded = false;    if ( bIsSaveMode )  {    if ( GetMMUMode ( ) == false32b )      // get current addr mode    {      bSwapModeNeeded = true;          // in 24 bit mode swap needed      SwapMMUMode ( &amp;theAddrMode );      // switch to 32 bit mode    }  }  else if ( bSwapModeNeeded )    SwapMMUMode ( &amp;theAddrMode );      return;}static void HandleContentClick ( WindowRef theWindow, EventRecord* event ){  #pragma unused(theWindow)  Point    localPt;    localPt = event-&gt;where;  GlobalToLocal ( &amp;localPt );    // Handle any content clicks here    return;}//// Creates the storage for the data to hang off a window or dialog//static OSErr CreateWindowInfo ( WindowRef windowRef, Size infoSize ){  OSErr  theErr;  Ptr    theInfo = nil;      theInfo = NewPtrClear ( infoSize );  theErr = MemError ( );  if ( theErr )    return theErr;    SetWRefCon ( windowRef, (long) theInfo );    return noErr;}//// The GetPictInfo routine has a bug which will allow all hell to// break loose if there isn't enough temporary memory available.//static pascal OSErr SafeGetPictInfo ( PicHandle thePictHandle, PictInfo* thePictInfo, SInt16 verb, SInt16 colorsRequested, SInt16 colorPickMethod, SInt16 version ){  const SInt32 kMinLowMem  = 10240;    // 10K isn't too much to ask for!    if ( TempFreeMem ( )  &lt; kMinLowMem )    return memFullErr;    return GetPictInfo ( thePictHandle, thePictInfo, verb, colorsRequested, colorPickMethod, version );}static void SizeScrollBars ( WindowRef theWindow ){  SInt16      maxXsize,          maxYsize;  tWindowInfoPtr  theInfo;      theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );    MoveControl ( theInfo-&gt;vScrollBar, theWindow-&gt;portRect.right - kScrollBarWidthAdjust,                    theWindow-&gt;portRect.top - 1 );  MoveControl ( theInfo-&gt;hScrollBar, theWindow-&gt;portRect.left - 1,                     theWindow-&gt;portRect.bottom - kScrollBarWidthAdjust );  SizeControl ( theInfo-&gt;vScrollBar, kScrollBarWidth,                    theWindow-&gt;portRect.bottom - theWindow-&gt;portRect.top - 13 );  SizeControl ( theInfo-&gt;hScrollBar, theWindow-&gt;portRect.right - theWindow-&gt;portRect.left - 13,                    kScrollBarWidth );                      maxXsize = theInfo-&gt;offscreen-&gt;portRect.right -         ((theWindow-&gt;portRect.right - kScrollBarWidthAdjust) - theWindow-&gt;portRect.left);  maxYsize = theInfo-&gt;offscreen-&gt;portRect.bottom -         ((theWindow-&gt;portRect.bottom - kScrollBarWidthAdjust) - theWindow-&gt;portRect.top);  SetControlMaximum ( theInfo-&gt;vScrollBar, maxYsize );  SetControlMaximum ( theInfo-&gt;hScrollBar, maxXsize );    return;}//// Calculates the maximum window size based on the image size and the// current size of the main screen. The image size is used, but resticted// by the current screen size.//static Point GetMaximumWindowSize ( WindowRef theWindow ){  GDHandle      theMainGDevHndl;  Point        theWindowSize,            theImageSize;  tWindowInfoPtr    theInfo;      theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );    // Calulate the image size  theImageSize.h = theInfo-&gt;offscreen-&gt;portRect.right - theInfo-&gt;offscreen-&gt;portRect.left;  theImageSize.v = theInfo-&gt;offscreen-&gt;portRect.bottom - theInfo-&gt;offscreen-&gt;portRect.top;  theImageSize.h += kScrollBarWidth;  theImageSize.v += kScrollBarWidth;    // Calulate the screen size  theMainGDevHndl = GetMainDevice ( );  theWindowSize.h = (*theMainGDevHndl)-&gt;gdRect.right - (*theMainGDevHndl)-&gt;gdRect.left;  theWindowSize.v = (*theMainGDevHndl)-&gt;gdRect.bottom - (*theMainGDevHndl)-&gt;gdRect.top;  theWindowSize.v -= GetMBarHeight ( );    // Make sure the image size is within the constraints of the screen  theWindowSize.h = theWindowSize.h &lt; theImageSize.h ? theWindowSize.h : theImageSize.h;  theWindowSize.v = theWindowSize.v &lt; theImageSize.v ? theWindowSize.v : theImageSize.v;    return theWindowSize;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Live_Scroll/listing11.html%3Fid%3DDTS10000591-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Live_Scroll/listing11.html%3Fid%3DDTS10000591-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Live_Scroll/listing11.html%3Fid%3DDTS10000591-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>