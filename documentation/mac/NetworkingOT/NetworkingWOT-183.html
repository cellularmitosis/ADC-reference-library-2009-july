<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>OTRcv</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING183></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-182.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-184.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-81.html"><B>Part 2 - Open Transport Reference</B></A><BR><DD><A HREF="NetworkingWOT-127.html"><B>Chapter 22 - Endpoints Reference</B></A> / <A HREF="NetworkingWOT-146.html"><B>Functions</B></A><BR><DL><DD><A HREF="NetworkingWOT-181.html"><B>Functions for Connection-Oriented Transactionless Endpoints</B></A> / </DL></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING183-0></A>
<H3><A NAME=MARKER-9-214></A>OTRcv</H3>
 Reads data sent using a connection-oriented transactionless endpoint.<P>
<A NAME=HEADING183-2></A>
<H5>C INTERFACE</H5>
<PRE>
<A NAME=MARKER-11-215></A>OTResult OTRcv(EndpointRef ref, 
                     void* buf, 
                     size_t nbytes, 
                                         OTFlags* flags);
</PRE>
<A NAME=HEADING183-4></A>
<H5>C++ INTERFACE</H5>
<PRE>
<A NAME=MARKER-12-216></A>OTResult TEndpoint::Rcv(void* buf, 
                     size_t nbytes, 
                     OTFlags* flags);
</PRE>
<A NAME=HEADING183-6></A>
<H5>PARAMETERS</H5>
<DL>
<DT><CODE>ref</CODE>
<DD> The endpoint reference of the endpoint receiving data.
<DT><CODE>buf</CODE>
<DD> A pointer to a buffer where the incoming data is to be copied. You must allocate this buffer before you call the function. 
<DT><CODE>nbytes</CODE>
<DD> A 32-bit value specifying the size of the buffer in bytes. 
<DT><CODE>flags</CODE>
<DD> A 32-bit bitmapped value specifying, on return, whether the data being sent is expedited (<CODE>T_EXPEDITED</CODE>) and whether more data remains to be received (<CODE>T_MORE</CODE>). 
<DT><I>function result</I>
<DD> A positive integer specifying the number of bytes received or a negative integer specifying an error code. See <A HREF=NetworkingWOT-479.html#MARKER-9-72>Appendix B</A>, and Discussion.
</DL>
<A NAME=HEADING183-12></A>
<H5>DISCUSSION</H5>
 You call the <CODE>OTRcv</CODE> function to read data sent by the peer to which you are connected. If the <CODE>OTRcv</CODE> function succeeds, it returns a positive integer (<CODE>OTResult</CODE>) specifying the number of bytes received. The function places the data read into the buffer referenced by the <CODE>buf</CODE> parameter. If the function fails, it returns a negative integer corresponding to a result code that indicates the reason for the failure. You can call this function to receive either normal or expedited data. If the data is expedited, the <CODE>T_EXPEDITED</CODE> flag is set in the <CODE>flags</CODE> parameter.<P>
 If the endpoint does not support the concept of a TSDU, the <CODE>T_MORE</CODE> flag is not meaningful and should be ignored. To determine whether the endpoint supports TSDUs, examine the <CODE>tsdu</CODE> field of the <CODE>TEndpointInfo</CODE> structure. If the endpoint supports TSDUs and the <CODE>T_MORE</CODE> bit is set in the <CODE>flags</CODE> parameter when the function returns, this means that the buffer you allocated is too small to contain the entire TSDU and that you must call the <CODE>OTRcv</CODE> function again. If you have read x bytes with the first call, the next call to the <CODE>OTRcv</CODE> function begins to read at the (x + 1) byte. Each call to this function that returns with the <CODE>T_MORE</CODE> flag set means that you must call the function again to get more of the TSDU. When you have read the entire TSDU, the <CODE>OTRcv</CODE> function returns with the <CODE>T_MORE</CODE> flag not set. <P>
 If the <CODE>OTRcv</CODE> function returns and the <CODE>T_EXPEDITED</CODE> bit is set in the <CODE>flags</CODE> parameter, this means that you have read expedited data. If the number of bytes in the ETSDU exceeds the number of bytes you specified in the <CODE>reqCount</CODE> parameter, both the <CODE>T_EXPEDITED</CODE> and the <CODE>T_MORE</CODE> bits are set. You must call the <CODE>OTRcv</CODE> function until the <CODE>T_MORE</CODE> flag is not set to retrieve the rest of the ETSDU.<P>
 If you are calling the <CODE>OTRcv</CODE> function repeatedly to read normal data and a call to the function returns <CODE>T_EXPEDITED</CODE> in the <CODE>flags</CODE> parameter, the next call to the <CODE>OTRcv</CODE> function that returns without the <CODE>T_EXPEDITED</CODE> flag set returns normal data at the place it was interrupted. It is your responsibility to remember where that was and to continue processing normal data. <P>
 If the endpoint is in synchronous blocking mode, the endpoint waits for data if none is currently available.If the endpoint is in asynchronous mode or is not blocking, the function returns with the <CODE>kOTNoDataErr</CODE> result if no data is available. For more information on notifier functions and event codes, see <A HREF=NetworkingWOT-126.html#MARKER-9-142><CODE>MyNofierCallback</CODE></A> function and <A HREF=NetworkingWOT-100.html#MARKER-9-22>"Event Codes"</A>. If you have installed a notifier, the endpoint provider calls your notifier and passes <CODE>T_DATA</CODE> or <CODE>T_EXDATA</CODE> for the <CODE>code</CODE> parameter when there is data available. If you have not installed a notifier, you may poll for these events using the <A HREF=NetworkingWOT-156.html#MARKER-9-143><CODE>OTLook</CODE></A> function. Once you receive a <CODE>T_DATA</CODE> or <CODE>T_EXDATA</CODE> event, you should continue in a loop, calling the <CODE>OTRcv</CODE> function until it returns with the <CODE>kOTNoDataErr</CODE> result.<P>
<A NAME=HEADING183-18></A>
<H5>SPECIAL CONSIDERATIONS</H5>
 You should be prepared for a <CODE>T_DATA</CODE> event and then a <CODE>kOTNoDataErr</CODE> error when you call the <CODE>OTRcv</CODE> function. This seems unusual, but it can occur if you were in the process of calling <CODE>OTRcv</CODE> in the foreground when a <CODE>T_DATA</CODE> event comes in.<P>
 Whenever the <CODE>OTRcv</CODE> function returns a <CODE>kOTLookErr</CODE> error, it is very important that you call the <CODE>OTLook</CODE> function. If you are in a flow-control situation on the send side, and a <CODE>T_GODATA</CODE> or <CODE>T_GOEXDATA</CODE> event occurs that you do not clear in your notifier (by calling <CODE>OTLook</CODE> or by actually sending some data), then you will hang waiting. Until the <CODE>T_GODATA</CODE> or <CODE>T_GOEXDATA</CODE> events are cleared, Open Transport cannot send you another <CODE>T_DATA</CODE> event (or any other event other than a <CODE>T_DISCONNECT</CODE> event).<P>
 The <CODE>XTI_RCVLOWAT</CODE> option allows endpoints that support it to negotiate the minimum number of bytes that must have accumulated in the endpoint's internal receive buffer before the endpoint provider generates a <CODE>T_DATA</CODE> event. See <A HREF=NetworkingWOT-37.html#MARKER-9-21>"Option Management"</A> for information on setting this option.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-182.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-184.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
