<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Imageer - /source/fileIO.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Imageer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Imageer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/fileIO.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/source/doevent.c</option>
<option value="listing2.html">/source/eventloop.c</option>
<option value="listing3.html">/source/fileCache.c</option>
<option value="listing4.html">/source/fileIO.c</option>
<option value="listing5.html">/source/gxGraphics.c</option>
<option value="listing6.html">/source/Imageer.app.h</option>
<option value="listing7.html">/source/Imageer.protos.h</option>
<option value="listing8.html">/source/Imageer.r</option>
<option value="listing9.html">/source/imageFilter.c</option>
<option value="listing10.html">/source/menu.c</option>
<option value="listing11.html">/source/offscrnGraphics.c</option>
<option value="listing12.html">/source/PreCompiledHeaders.c</option>
<option value="listing13.html">/source/start.c</option>
<option value="listing14.html">/source/windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Imageer.zip">Download Sample</a></strong> (&#147;Imageer.zip&#148;, 161.4K)<BR>
<strong><a href="Imageer.dmg">Download Sample</a></strong> (&#147;Imageer.dmg&#148;, 243.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************//*                          *//*  File:    fileIO.c              *//*                          *//*  Program:  Imageer                *//*                          *//*  By:      Jason Hodges-Harris          *//*                          *//*  Created:  26/10/95  00:00:00 AM        *//*                          *//*  Version:  1.0.0d3                *//*                          *//*  Copyright:  &copy; 1995-96 Apple Computer, Inc.,    */ /*          all rights reserved.      */    /*                          *//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __COMPONENTS__#include &lt;Components.h&gt;#endif#ifndef __CONTROLS__#include &lt;Controls.h&gt;#endif#ifndef __CURSORCTL__#include &lt;CursorCtl.h&gt;#endif#ifndef __DIALOGS__#include &lt;Dialogs.h&gt;#endif#ifndef __FILES__#include &lt;Files.h&gt;#endif#ifndef __GXGRAPHICS__#include &lt;GXGraphics.h&gt;#endif#ifndef __GXMATH__#include &lt;GXMath.h&gt;#endif#ifndef __IMAGECOMPRESSION__#include &lt;ImageCompression.h&gt;#endif#ifndef __MEMORY__#include &lt;Memory.h&gt;#endif#ifndef __PICTUTILS__#include &lt;PictUtils.h&gt;#endif#ifndef __QUICKTIMECOMPONENTS__#include &lt;QuickTimeComponents.h&gt;#endif#ifndef __STANDARDFILE__#include &lt;StandardFile.h&gt;#endif#ifndef __STRING__#include &lt;string.h&gt;#endif#ifndef __STRINGS__#include &lt;Strings.h&gt;#endif#ifndef __TOOLUTILS__#include &lt;ToolUtils.h&gt;#endif#ifndef __TYPES__#include &lt;Types.h&gt;#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include &quot;Imageer.app.h&quot;#endif#ifndef __IMAGEERPROTOSHEADER__#include &quot;Imageer.protos.h&quot;#endif/****  Global variables  ****/extern OSType   gLoadFileType;static OSType  gSaveFileType;/****  Default RGB Colors  ****/static const RGBColor   kRGBBlack = {0x0000, 0x0000, 0x0000};static const RGBColor  kRGBWhite = {0xFFFF, 0xFFFF, 0xFFFF};/****  Load supported image file type  ****/// Main function which is called when 'Open' is selected in the file menu.// Displays the custom get file dialog, which supports a pop up menu// to filter out unwanted/unwanted file types. Creates and initialises the// image window document structure dependent of the file type loaded.#pragma segment fileSysOSErr  LoadSupportedImage(void){  ImageDocHndl    theDocHndl = nil;  PicHandle      thePictHndl = nil;  DlgHookYDUPP    theDialogHookUPP;  FileFilterYDUPP    theDialogFileFilterUPP;  PictInfo      thePictInfo;  StandardFileReply  theSFReply;  TiffInfo      theTiffStruct;  SFTypeList      fileTypes;  Point        dlogPosition = {-1,-1};  OSErr        error = noErr;    // Create Universal Proc Ptrs for custom Dialog functions  theDialogHookUPP = NewDlgHookYDProc(CustomGetFileHook);  theDialogFileFilterUPP = NewFileFilterYDProc(CustomFileDlogFilter);  CustomGetFile (theDialogFileFilterUPP,-1,           fileTypes,&amp;theSFReply,rCustomOpenDialog,           dlogPosition,theDialogHookUPP,nil,nil,nil,nil);  DisposeRoutineDescriptor((UniversalProcPtr)theDialogHookUPP);  DisposeRoutineDescriptor((UniversalProcPtr)theDialogFileFilterUPP);  if (theSFReply.sfGood == true)  {    theDocHndl = (ImageDocHndl)NewHandle(sizeof(ImageDoc));  // create new image document    if (!theDocHndl)    {      DisplayAlert (rGenWarning,rErrMessages,iFailAllocMem);      return kFailAllocDocHndl;    }    if (theSFReply.sfType == 'qdgx')      (**theDocHndl).isUsingQDGX = true;    else      (**theDocHndl).isUsingQDGX = false;          (**theDocHndl).theImageFileReply = theSFReply;  // copy SFReply to window Doc structure    switch (theSFReply.sfType)    {      case ('TIFF'):                // TIFF file type        // Set up document structure to defaults for image type        (**theDocHndl).theFileType = TiffType;        (**theDocHndl).theImageChanged = false;        (**theDocHndl).theColorsPalette = nil;        (**theDocHndl).theImageWorld = nil;        (**theDocHndl).theVScrollBar = nil;        (**theDocHndl).theHScrollBar = nil;        (**theDocHndl).theUndoState = kCannotUndo;        (**theDocHndl).hasUndoTemp = false;        (**theDocHndl).hasRedoTemp = false;        theTiffStruct.tiffCTabHndl = nil;    // set to nil as Color table not always created        GetTIFFHdrInfo(theDocHndl,&amp;theTiffStruct);        error = GetTIFFIFDirectory(theDocHndl,&amp;theTiffStruct);        if (error == kTIFFNotSupported)        {          if (theTiffStruct.tiffCTabHndl)            DisposeHandle((Handle)theTiffStruct.tiffCTabHndl);          CleanLoadAbort(theDocHndl);          DisplayAlert (rGenWarning, rFileIOMessages, iTiffNotSupported);          return error;        }        // cannot at present support TIFF files that aren't 8 or 32 bit        switch (theTiffStruct.bitDepth)        {          case 8:            (**theDocHndl).theImageWorld =               CreateOffscreen(theTiffStruct.tiffCTabHndl,                      theTiffStruct.xImageSize,                      theTiffStruct.yImageSize,                      theTiffStruct.bitDepth,kNoFlags);            if ((**theDocHndl).theImageWorld == nil)            {              DisposeHandle((Handle)theDocHndl);              return kFailMakeGWorld;            }          break;          case 32:            (**theDocHndl).theImageWorld =               CreateOffscreen(nil,                      theTiffStruct.xImageSize,                      theTiffStruct.yImageSize,                      theTiffStruct.bitDepth,kNoFlags);            if ((**theDocHndl).theImageWorld == nil)            {              DisposeHandle((Handle)theDocHndl);              return kFailMakeGWorld;            }          break;          default:            DisplayAlert (rGenWarning,rErrMessages,iNoSupportBitDepth);            return kBitDepthErr;          break;        }        // Fill in image coord sizes and bit depth to document structure        (**theDocHndl).theImageXSize = theTiffStruct.xImageSize;        (**theDocHndl).theImageYSize = theTiffStruct.yImageSize;        (**theDocHndl).theImageDepth = theTiffStruct.bitDepth;        // Perform TIFF file parse directly into GWorld referenced from document structure        error = LoadTiffToGWorld (theDocHndl,&amp;theTiffStruct,theTiffStruct.bitDepth);        if (error)        {          DisplayAlert (rGenAlert,0,0);          return error;        }        SetUndoItemText(kCannotUndo);        error = CreateImageWindow (theDocHndl);        if (error == kDefaultAppError)        {          DisplayAlert (rGenAlert,0,0);          return error;        }        // Dispose of Tiff struct color table handle         if (theTiffStruct.tiffCTabHndl)          DisposeHandle((Handle)theTiffStruct.tiffCTabHndl);        error = AddDocNameToMenu(theDocHndl);        if (error)          DisplayAlert (rGenAlert,0,0);        else          return noErr;      break;      case ('PICT'):                // PICT type        // Set up document structure to defaults for image type        (**theDocHndl).theFileType = PictType;        (**theDocHndl).theImageChanged = false;        (**theDocHndl).theColorsPalette = nil;        (**theDocHndl).theImageWorld = nil;        (**theDocHndl).theVScrollBar = nil;        (**theDocHndl).theHScrollBar = nil;        (**theDocHndl).theUndoState = kCannotUndo;        (**theDocHndl).hasUndoTemp = false;        (**theDocHndl).hasRedoTemp = false;        // Load PICT file into PicHandle structure before placing in GWorld        thePictHndl = LoadPictImageFile(theDocHndl);        if (!thePictHndl)        {          DisposeHandle((Handle)theDocHndl);          return kDefaultAppError;        }        // test if minimal temp memory free available. If none available GetPictInfo() fails.        if (TempFreeMem() &lt; kMinLowMem)        {          DisplayAlert(rGenWarning,rErrMessages,iLowTempMem);          DisposeHandle((Handle)theDocHndl);          return kLowMemWarning;        }        error = GetPictInfo (thePictHndl, &amp;thePictInfo, returnColorTable,256,systemMethod,0);        // Fill in image coord sizes and bit depth to document structure        (**theDocHndl).theImageXSize = thePictInfo.sourceRect.right - thePictInfo.sourceRect.left;        (**theDocHndl).theImageYSize = thePictInfo.sourceRect.bottom - thePictInfo.sourceRect.top;        (**theDocHndl).theImageDepth = thePictInfo.depth;        // Create window document's GWorld structure and draw loaded Pict image into it.        if (!error &amp;&amp; thePictInfo.depth &lt;= 8)          (**theDocHndl).theImageWorld =             CreateOffscreen(thePictInfo.theColorTable,                    (**theDocHndl).theImageXSize,                    (**theDocHndl).theImageYSize,                    (**theDocHndl).theImageDepth,kNoFlags);        else          (**theDocHndl).theImageWorld =             CreateOffscreen(nil,                    (**theDocHndl).theImageXSize,                    (**theDocHndl).theImageYSize,                    (**theDocHndl).theImageDepth,kNoFlags);                if ((**theDocHndl).theImageWorld == nil)        {          DisposeHandle((Handle)theDocHndl);    // dispose image document          DisposeHandle((Handle)thePictHndl);    // dispose picHandle          return kFailMakeGWorld;        }        error = DrawPictToGWorld (theDocHndl,thePictHndl);        SetUndoItemText(kCannotUndo);        error = CreateImageWindow (theDocHndl);        if (error == kDefaultAppError)        {          DisplayAlert (rGenAlert,0,0);          return error;        }        error = AddDocNameToMenu(theDocHndl);        if (error)          DisplayAlert (rGenAlert,0,0);        else          return noErr;      break;      case ('qdgx'):        // QuickDraw GX file load function is not yet supported in this release.         // It will be included in a future release.        SetUndoItemText(kCannotUndo);        DisplayAlert (rGenAlert,rErrMessages,iNotImplemented);        return kNotSupported;      break;    }  }  return kFileLoadAbortErr;}/****  CustomGetFile  dialog file hook func  ****/// This function handles user interaction of the custom dialog items added to the// CustomGetFile dialog and ignores all other items which are returned and processed// by the standard internal function.#pragma segment fileSyspascal short  CustomGetFileHook(short item,DialogPtr theDlogPtr,void* theData){  Handle        theHandle;  Rect        theRect;  short        theType,            ignored;    switch (item)    {    case sfHookFirstCall:      GetDItem(theDlogPtr,kLoadFilePopUpItem,&amp;theType,&amp;theHandle,&amp;theRect);      switch (gLoadFileType)      {        case 'TIFF':          theType = iTiffType;        break;        case 'PICT':          theType = iPictType;        break;        case 'qdgx':          theType = iGXType;        break;        default:          theType = iAllFiles;        break;      }      SetCtlValue((ControlHandle)theHandle,theType);      return sfHookNullEvent;    break;    case kLoadFilePopUpItem:      GetDItem(theDlogPtr,item,&amp;ignored,&amp;theHandle,&amp;theRect);      theType = GetCtlValue((ControlHandle)theHandle);      switch (theType)      {        case iTiffType:          gLoadFileType = 'TIFF';          item = sfHookRebuildList;        break;        case iPictType:          gLoadFileType = 'PICT';          item = sfHookRebuildList;        break;        case iGXType:          gLoadFileType = 'qdgx';          item = sfHookRebuildList;        break;        case iAllFiles:          gLoadFileType = '????';          item = sfHookRebuildList;        break;      }      return item;    break;  }  return item;}  /****  basic CustomGetFile filter function  ****/// File filter function is used by CustomGetFile() to restrict the// display of files and folders to supported image file types and visible folders.#pragma segment fileSyspascal Boolean  CustomFileDlogFilter(CInfoPBPtr theParamBlok, Ptr theDataPtr){  Boolean    notDisplayed = true;    switch (theParamBlok-&gt;hFileInfo.ioFlFndrInfo.fdType)  {    case 'TIFF':      if (gLoadFileType == 'TIFF' || gLoadFileType == '????')        notDisplayed = false;    break;    case 'PICT':      if (gLoadFileType == 'PICT' || gLoadFileType == '????')        notDisplayed = false;    break;    case 'qdgx':      if (gLoadFileType == 'qdgx' || gLoadFileType == '????')        notDisplayed = false;    break;    default:      if ((theParamBlok-&gt;dirInfo.ioFlAttrib &amp; kFolderBit) &amp;&amp;         !(theParamBlok-&gt;hFileInfo.ioFlFndrInfo.fdFlags &amp; kFileVisibleBit))          notDisplayed = false;    break;  }  return  notDisplayed;}/****  retrieve TIFF image header information  ****/// Retrieve TIFF file header information and parse. Used to calculate file information// when reading in TIFF directory data.#pragma segment fileSysvoid  GetTIFFHdrInfo(ImageDocHndl theDocHndl, TiffInfo *theTiffHeader){  long        fileLen;  StandardFileReply   theFileSpec = (**theDocHndl).theImageFileReply;  // use local as FSpOpenDF returns param in spec  char        headerStore[8];    FSpOpenDF(&amp;theFileSpec.sfFile,fsRdPerm,&amp;theFileSpec.sfFile.vRefNum); // open file  // Get size of file storage of TIFF header and read in TIFF header info  fileLen = sizeof(headerStore);            FSRead(theFileSpec.sfFile.vRefNum,&amp;fileLen,headerStore);     FSClose(theFileSpec.sfFile.vRefNum);  // copy header information to data structure  BlockMoveData(headerStore,&amp;theTiffHeader-&gt;byteOrder,2);  BlockMoveData(&amp;headerStore[2],&amp;theTiffHeader-&gt;version,2);  if (theTiffHeader-&gt;byteOrder == IntlFormat)    theTiffHeader-&gt;version = SwapByteOrder(theTiffHeader-&gt;version,2);  BlockMoveData(&amp;headerStore[4],&amp;theTiffHeader-&gt;offsetToIFD,4);  if (theTiffHeader-&gt;byteOrder == IntlFormat)    theTiffHeader-&gt;offsetToIFD = SwapByteOrder(theTiffHeader-&gt;offsetToIFD,4);  return;}/****  Retrieve TIFF format image file directory info  ****/// Function to parse the TIFF image file and load the image// data directly into a previously created GWorld PixMap.// If the TIFF file is an indexed image the color table information// is used to manually create a Color Table#pragma segment fileSysOSErr  GetTIFFIFDirectory(ImageDocHndl theDocHndl, TiffInfo *theTiffHeader){  long        fileLen,            tempDecode,      // temporary decoder storage            myOldFilePos,            cTabSize;  StandardFileReply  theFileSpec = (**theDocHndl).theImageFileReply; // use local as FSpOpen returns param in spec  char        iFDcounter[2],    // number of IFD entries            iFDStore[12],    // IFD field entry            iFDOffset[4];    // offset to next IFD  short        entriesLeft,    // IFD's to process            numberColors,            colorValue,            countStep,            count;  OSErr        error = noErr,            myFileErr;  Boolean        isIntFormat = false;    if (theTiffHeader-&gt;byteOrder == IntlFormat)    isIntFormat = true;  FSpOpenDF(&amp;theFileSpec.sfFile,fsRdPerm,&amp;theFileSpec.sfFile.vRefNum);  SetFPos(theFileSpec.sfFile.vRefNum,fsFromStart,theTiffHeader-&gt;offsetToIFD);  fileLen = sizeof(iFDcounter);  FSRead(theFileSpec.sfFile.vRefNum,&amp;fileLen,iFDcounter);  BlockMoveData(iFDcounter,&amp;entriesLeft,2);  if (isIntFormat)    entriesLeft = SwapByteOrder(entriesLeft,2);  fileLen = sizeof(iFDStore);  do{    do{      myFileErr = FSRead(theFileSpec.sfFile.vRefNum,&amp;fileLen,iFDStore);  // get pattern header info      if (myFileErr)        DebugStr(&quot;\pError in reading IFDirectory&quot;);      BlockMoveData(iFDStore,&amp;tempDecode,2);      tempDecode=tempDecode&gt;&gt;16;      if (isIntFormat)        tempDecode = SwapByteOrder(tempDecode,2);      switch (tempDecode)      {        case 0xFE:      // get image subfile type          BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,4);          if (tempDecode!=0)            DebugStr(&quot;\pIFD new subfile type not supported&quot;);         break;        case 0x100:      // image width          BlockMoveData(&amp;iFDStore[2],&amp;tempDecode,2);          tempDecode=tempDecode&gt;&gt;16;          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          if (tempDecode==3)          {            BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);            tempDecode=tempDecode&gt;&gt;16;            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,2);          }          else             {            BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,4);            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,4);          }          theTiffHeader-&gt;xImageSize = tempDecode;        break;        case 0x101:      // image length          BlockMoveData(&amp;iFDStore[2],&amp;tempDecode,2);          tempDecode=tempDecode&gt;&gt;16;          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          if (tempDecode==3)          {            BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);            tempDecode=tempDecode&gt;&gt;16;            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,2);          }          else             {            BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,4);            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,4);          }          theTiffHeader-&gt;yImageSize = tempDecode;        break;        case 0x102:      // bits per sample          BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);          tempDecode=tempDecode&gt;&gt;16;          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          theTiffHeader-&gt;bitDepth = tempDecode;        break;        case 0x103:      // image compression NOT SUPPORTED YET!!          BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);          tempDecode=tempDecode&gt;&gt;16;          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          theTiffHeader-&gt;compressionType = tempDecode;          if (tempDecode != 1)            return kTIFFNotSupported;        break;        case 0x106:      // Photometricinterpretation          BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);          tempDecode=tempDecode&gt;&gt;16;          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          theTiffHeader-&gt;PhotoInterpret = tempDecode;          if (tempDecode &gt; 3)            return kTIFFNotSupported;        break;        case 0x111:      // strip offsets for one strip. Is offset to data          BlockMoveData(&amp;iFDStore[2],&amp;tempDecode,2);          tempDecode=tempDecode&gt;&gt;16;          if (tempDecode==3)          {            BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);            tempDecode=tempDecode&gt;&gt;16;            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,2);          }          else             {            BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,4);            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,4);          }          theTiffHeader-&gt;imageOffset = tempDecode;  // offset to image strip        break;        case 0x115:      // samples per pixel 1 for palette, 3 for direct          BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);          tempDecode=tempDecode&gt;&gt;16;          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          theTiffHeader-&gt;bitDepth = tempDecode*8;          if (theTiffHeader-&gt;bitDepth == 24)            theTiffHeader-&gt;bitDepth = 32;  // amend to 32 bpp to correctly create GWorld           if (theTiffHeader-&gt;PhotoInterpret &lt; 2)          {            if (theTiffHeader-&gt;bitDepth == 8)  // 8 Bit Greyscale image            {              numberColors = 256;      // number of entries in palette              countStep = 1;            }            if (theTiffHeader-&gt;bitDepth == 4)  // 4 Bit Greyscale image            {              numberColors = 16;              countStep = 16;            }            // Manually create the Color Table from TIFF file information            cTabSize = sizeof(ColorTable)+(sizeof(ColorSpec)*(numberColors-1));            theTiffHeader-&gt;tiffCTabHndl = (CTabHandle) NewHandle(cTabSize);            if (theTiffHeader-&gt;tiffCTabHndl == nil || MemError())            {              return kDefaultAppError;            }            (**theTiffHeader-&gt;tiffCTabHndl).ctFlags = 0;            (**theTiffHeader-&gt;tiffCTabHndl).ctSize = numberColors-1;            switch (theTiffHeader-&gt;PhotoInterpret)            {              case 0:                for (count=0;count&lt;numberColors;count+=countStep)                {                  colorValue = (255 - count) &lt;&lt; 8;                  (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].value = count;                  (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.red = colorValue;    // red component                  (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.green = colorValue;    // green component                  (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.blue = colorValue;    // blue component                }              break;                            case 1:                for (count=0;count&lt;numberColors;count+=countStep)                {                                    colorValue = count &lt;&lt; 8;                  (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].value = count;                  (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.red = colorValue;  // red component                  (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.green = colorValue;  // green component                  (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.blue = colorValue;  // blue component                }              break;            }            CTabChanged(theTiffHeader-&gt;tiffCTabHndl);          }        break;        case 0x116:      // number of rows per image strip          BlockMoveData(&amp;iFDStore[2],&amp;tempDecode,2);          tempDecode = tempDecode&gt;&gt;16;          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          if (tempDecode == 3)          {            BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);            tempDecode=tempDecode&gt;&gt;16;            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,2);          }          else          {            BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,4);            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,4);          }          theTiffHeader-&gt;rowStrip = tempDecode;        break;        case 0x11C:          BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          theTiffHeader-&gt;PlanarConfig = tempDecode&gt;&gt;16;        break;        case 0x140:      // image clut for palette images          if (theTiffHeader-&gt;bitDepth == 8)  // 8 Bit palette image            numberColors = 256;    // number of entries in palette          if (theTiffHeader-&gt;bitDepth == 4)  // 4 Bit palette image            numberColors = 16;          cTabSize = sizeof(ColorTable)+(sizeof(ColorSpec)*(numberColors-1));          theTiffHeader-&gt;tiffCTabHndl = (CTabHandle) NewHandle(cTabSize);          if (theTiffHeader-&gt;tiffCTabHndl==nil)          {            return kDefaultAppError;          }          (**theTiffHeader-&gt;tiffCTabHndl).ctFlags = 0;          (**theTiffHeader-&gt;tiffCTabHndl).ctSize = numberColors-1;          BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,4);          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,4);          GetFPos(theFileSpec.sfFile.vRefNum,&amp;myOldFilePos);  // get old file position          SetFPos(theFileSpec.sfFile.vRefNum,fsFromStart,tempDecode); // set new file pos          fileLen = sizeof(short);          for (count=0;count&lt;numberColors;count++)          {            (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].value = count;            FSRead(theFileSpec.sfFile.vRefNum,&amp;fileLen,&amp;tempDecode);            tempDecode = tempDecode&gt;&gt;16;            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,2);            (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.red = tempDecode;    // red component          }          for (count=0;count&lt;numberColors;count++)          {            FSRead(theFileSpec.sfFile.vRefNum,&amp;fileLen,&amp;tempDecode);            tempDecode = tempDecode&gt;&gt;16;            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,2);            (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.green = tempDecode;    // green component          }          for (count=0;count&lt;numberColors;count++)          {            FSRead(theFileSpec.sfFile.vRefNum,&amp;fileLen,&amp;tempDecode);            tempDecode = tempDecode&gt;&gt;16;            if (isIntFormat)              tempDecode = SwapByteOrder(tempDecode,2);            (**theTiffHeader-&gt;tiffCTabHndl).ctTable[count].rgb.blue = tempDecode;    // blue component          }          CTabChanged(theTiffHeader-&gt;tiffCTabHndl);          SetFPos(theFileSpec.sfFile.vRefNum,fsFromStart,myOldFilePos);        break;        case 0x153:  // Sample Format tag          BlockMoveData(&amp;iFDStore[8],&amp;tempDecode,2);          tempDecode=tempDecode&gt;&gt;16;          if (isIntFormat)            tempDecode = SwapByteOrder(tempDecode,2);          if (tempDecode != 1)            return kTIFFNotSupported;        break;        case 0x142:  // handle unsupported tags which could cause incorrect image display        case 0x143:        case 0x152:          return kTIFFNotSupported;        break;      }        entriesLeft--;    } while (entriesLeft!=0);        // read all tags    // multi IFD stuff Needs to be expanded to support     fileLen = sizeof(iFDOffset);    FSRead(theFileSpec.sfFile.vRefNum,&amp;fileLen,iFDOffset);// get pattern header info    BlockMoveData(iFDOffset,&amp;theTiffHeader-&gt;offsetToIFD,4);    if (isIntFormat)      tempDecode = SwapByteOrder(tempDecode,4);    SetFPos(theFileSpec.sfFile.vRefNum,fsFromStart,theTiffHeader-&gt;offsetToIFD);    theTiffHeader-&gt;offsetToIFD = 0;      // force to zero as don't support multiple images in file  } while (theTiffHeader-&gt;offsetToIFD!=0);  // read next IFD if present  FSClose(theFileSpec.sfFile.vRefNum);     // close open file  return  error;}/****    Draw the TIFF image data directly into the offscreen pixmap  ****/#pragma segment fileSysOSErr LoadTiffToGWorld (ImageDocHndl theImageDocHndl, TiffInfoPtr theTiffInfo, short bitDepth){  PixMapHandle    thePixMapHndl = nil;  CursHandle      watchCrsr;  Ptr          imageLinePtr = nil,            theLinePosPtr;  float        theBarStepValue,            theBarValue;  long        theFileLen,            imageLeft = theTiffInfo-&gt;rowStrip,            imageLineStart,            spinCounter = 0;  StandardFileReply  theFileSpec = (**theImageDocHndl).theImageFileReply; // use local as FSpOpen returns param in spec  OSErr        error = noErr;  short        theGWrowBytes,            xCount,            imageWidth;    thePixMapHndl = GetGWorldPixMap((*theImageDocHndl)-&gt;theImageWorld);  if (PixMap32Bit(thePixMapHndl))    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    theBarStepValue = (float)kProgressSteps/(*theImageDocHndl)-&gt;theImageYSize;     theBarValue = theBarStepValue;  //  intialise progress bar value    error = FSpOpenDF(&amp;theFileSpec.sfFile,fsRdPerm,&amp;theFileSpec.sfFile.vRefNum);    error |= SetFPos(theFileSpec.sfFile.vRefNum,fsFromStart,theTiffInfo-&gt;imageOffset);    if (!error)     {      imageLinePtr = GetPixBaseAddr(thePixMapHndl);  // base addr of GWorld      imageLineStart = (long)imageLinePtr;      theGWrowBytes = (**thePixMapHndl).rowBytes &amp; 0x3FFF;      // Display the progress bar dialog to provide feedback on load operation.      DisplayProgressBarDlog(kDisplayProgressWindow, 0 , rProgressMessages, iLoading);      // Read in imaga data from file into Pixmap      switch (bitDepth)      {        case 8:          theFileLen = (**thePixMapHndl).bounds.right - (**thePixMapHndl).bounds.left;          watchCrsr = GetCursor(watchCursor);          SetCursor(*watchCrsr);          do{            FSRead(theFileSpec.sfFile.vRefNum,&amp;theFileLen,imageLinePtr);  // get count            imageLinePtr+=theGWrowBytes;            imageLeft--;            theBarValue += theBarStepValue;            DisplayProgressBarDlog(kUpdateProgressWindow, (short)theBarValue, 0, 0);            RotateCursor(spinCounter+=8);          } while (imageLeft);          SetCursor(&amp;qd.arrow);        break;        case 16:          DebugStr(&quot;\p16 bit color depth not supported&quot;);        break;        case 32:          theFileLen = 3;          imageWidth = (**thePixMapHndl).bounds.right - (**thePixMapHndl).bounds.left;          watchCrsr = GetCursor(watchCursor);          SetCursor(*watchCrsr);          do{            theLinePosPtr = imageLinePtr;            theLinePosPtr++;            for (xCount = 0;xCount&lt;imageWidth;xCount++)            {              FSRead(theFileSpec.sfFile.vRefNum,&amp;theFileLen,theLinePosPtr);              theLinePosPtr+=4;            }            imageLinePtr+=theGWrowBytes;            imageLeft--;            theBarValue += theBarStepValue;            DisplayProgressBarDlog(kUpdateProgressWindow, (short)theBarValue, 0, 0);            RotateCursor(spinCounter+=8);          } while (imageLeft);          SetCursor(&amp;qd.arrow);        break;      }      UnlockPixels(thePixMapHndl);      DisplayProgressBarDlog(kDisposeProgressWindow,0,0,0);    }    else      DebugStr(&quot;\pError opening and setting file offset in LoadTiffToGWorld&quot;);  }  SaveSetMMUMode(false);  return error;}/****  Swap the byte order between little and big endian formats  ****/#pragma segment fileSyslong  SwapByteOrder(long  theData,short  theDataLength){  long  tempStore,      tempStore2,      tempStore3,      tempStore4;    switch(theDataLength)  {    case (2):      tempStore = theData &lt;&lt; 8;      tempStore = tempStore &amp; 0x0000FF00;      tempStore2 = theData &gt;&gt; 8;      tempStore2 = tempStore2 &amp; 0x000000FF;      theData = tempStore + tempStore2;    break;    case (4):      tempStore = theData &lt;&lt; 24;      tempStore = tempStore &amp; 0xFF000000;      tempStore2 = theData &lt;&lt; 8;      tempStore2 = tempStore2 &amp; 0x00FF0000;      tempStore3 = theData &gt;&gt; 8;      tempStore3 = tempStore3 &amp; 0x0000FF00;      tempStore4 = theData &gt;&gt; 24;      tempStore4 = tempStore4 &amp; 0x000000FF;      theData = tempStore + tempStore2 + tempStore3 + tempStore4;    break;  }  return theData;}/****  Load PICT file into PicHandle  ****/// Basic PICT file load function that takes a PICT file// and returns the loaded image in a PicHandle structure.// If an error occurs nil is returned to indicate load problem.#pragma segment fileSysPicHandle  LoadPictImageFile(ImageDocHndl  theDocHndl){  PicHandle      thePictHndl;  long        thePictFileSize;  StandardFileReply   theFileSpec = (**theDocHndl).theImageFileReply;  short        theFileRef;  OSErr        error = noErr;    error = FSpOpenDF(&amp;theFileSpec.sfFile, fsRdPerm, &amp;theFileRef);  if (!error)  {    error = GetEOF(theFileRef, &amp;thePictFileSize);    if(error)    {      FSClose(theFileSpec.sfFile.vRefNum);      return nil;     }    if(SetFPos(theFileRef,fsFromStart,512))    {      FSClose(theFileRef);      return nil;     }    thePictFileSize -= 512;  // Remove unwanted 512 byte header     thePictHndl = (PicHandle)NewHandle(thePictFileSize);    if(thePictHndl == nil)    {      FSClose(theFileRef);      return nil;    }    HLock((Handle)thePictHndl);    error = FSRead(theFileRef,&amp;thePictFileSize,(Ptr)*thePictHndl);    HUnlock((Handle)thePictHndl);    FSClose(theFileRef);    if(error)      return nil;     return thePictHndl;  }  return nil;}/****  Draw PicHandle into GWorld PixMap  ****/// Draw a PICT contained in a PicHandle into a GWorld // attached to the passed document structure parameter#pragma segment fileSysOSErr  DrawPictToGWorld (ImageDocHndl  theDocHndl,PicHandle  thePictHndl){  PixMapHandle  theGWorldPMHndl;  GDHandle    oldGDHndl;  CGrafPtr    oldGWorld;  OSErr      error = noErr;    GetGWorld(&amp;oldGWorld, &amp;oldGDHndl);  SetGWorld((**theDocHndl).theImageWorld, nil);  // Reset foreground and background colors to black and white  // so no colorisation effects occur.  RGBForeColor(&amp;kRGBBlack);                RGBBackColor(&amp;kRGBWhite);  theGWorldPMHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  LockPixels(theGWorldPMHndl);  EraseRect(&amp;(**theDocHndl).theImageWorld-&gt;portRect);  // Reset the transfer mode  PenMode(srcCopy);                    // render the image into the offscreen buffer  DrawPicture(thePictHndl, &amp;(**theDocHndl).theImageWorld-&gt;portRect);  UnlockPixels(theGWorldPMHndl);  SetGWorld(oldGWorld, oldGDHndl);  // dispose of unwanted picHandle structure  DisposeHandle((Handle)thePictHndl);  return  error;}/****  Save supported file types  ****/// Main function to perform the saving of supported image file types.#pragma segment fileSysOSErr  SaveSupportedImageFile(ImageDocHndl  theDocHndl){  StandardFileReply  theSFReply;  DlgHookYDUPP    theDialogHookUPP;  Point        dlogPosition = {-1,-1};  OSErr        error = noErr;    gSaveFileType = (*theDocHndl)-&gt;theFileType;  theDialogHookUPP = NewDlgHookYDProc(CustomPutFileHook);  CustomPutFile((ConstStr255Param)kNull_Str, (**theDocHndl).theImageFileReply.sfFile.name,          &amp;theSFReply, rCustomSaveDialog,dlogPosition, theDialogHookUPP,          nil, nil, nil, nil);  DisposeRoutineDescriptor((UniversalProcPtr)theDialogHookUPP);  if (theSFReply.sfGood)  {    /****  Dispose Temp file if present  ****/    if ((*theDocHndl)-&gt;hasUndoTemp || (*theDocHndl)-&gt;hasRedoTemp)      RemoveTempFile(theDocHndl, true, true);    switch (gSaveFileType)    {      case TiffType:      break;      case PictType:        if ( !(*theDocHndl)-&gt;isUsingQDGX )        {          error = SavePictImage(theDocHndl, &amp;theSFReply);          switch (error)          {            case kFailPictCompSave:              DisplayAlert(rGenAlert,rFileIOMessages,iSaveCompPICTErr);            break;            case kFailPictUnCompSave:              DisplayAlert(rGenAlert,rFileIOMessages,iSaveUnCompPICTErr);            break;            case kFailedLockPixels:              DisplayAlert(rGenAlert,rQDMessages,iFailLockPixmap);            break;          }        }      break;      case GXType:        if ( (*theDocHndl)-&gt;isUsingQDGX )        {          error = SaveQdGxShape(theDocHndl, &amp;theSFReply);          if (error)            DisplayAlert(rGenAlert,rFileIOMessages,iSaveQDGXErr);        }      break;    }  }  return error;}/****  CustomPutFile  dialog file hook function  ****/#pragma segment fileSyspascal short  CustomPutFileHook(short item,DialogPtr theDlogPtr,void* theData){  Handle        theHandle;  Rect        theRect;  short        theType,            ignored;    if (GetWRefCon((WindowPtr)theDlogPtr) != sfMainDialogRefCon)    return item;  switch (item)    {    case sfHookFirstCall:      GetDItem(theDlogPtr,kSaveFilePopUpItem,&amp;theType,&amp;theHandle,&amp;theRect);      switch (gSaveFileType)      {        case TiffType:          theType = iSaveTiffType;        break;        case PictType:          theType = iSavePictType;        break;        case GXType:          theType = iSaveGXType;        break;      }      SetCtlValue((ControlHandle)theHandle,theType);      return sfHookNullEvent;    break;    case kSaveFilePopUpItem:      GetDItem(theDlogPtr,item,&amp;ignored,&amp;theHandle,&amp;theRect);      theType = GetCtlValue((ControlHandle)theHandle);      switch (theType)      {        case iSaveTiffType:          gSaveFileType = TiffType;        break;        case iSavePictType:          gSaveFileType = PictType;        break;        case iSaveGXType:          gSaveFileType = GXType;        break;      }      return sfHookNullEvent;    break;  }  return item;}  /****  Save image as PICT file    ****/#pragma segment fileSysOSErr SavePictImage(ImageDocHndl theDocHndl, StandardFileReply* thePictFile){  Handle          compDataHndl;  Ptr            compDataPtr;  ImageDescriptionHandle  compImageDescHndl = nil;  PicHandle        theSavePict = nil;  GDHandle        theGDevHndl;  PixMapHandle      theSavePictPixMapHndl = nil;  GWorldPtr        oldPort;  long          thePictLen,              emptyDataSize = 4,              emptyData = 0x00000000,              maxCompSize = 0;  CodecQ          compQuality;  Rect          thePortRect;  OpenCPicParams      thePictParams;  OSErr          error = noErr,              fileErr = noErr;  short          fileRefNum,              compressionSetting,              count;      GetGWorld(&amp;oldPort,&amp;theGDevHndl);  thePortRect = (**theDocHndl).theImageWorld-&gt;portRect;  theSavePictPixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(theSavePictPixMapHndl))    SaveSetMMUMode(true);  if (LockPixels(theSavePictPixMapHndl))  {    /****  setup Color PICT paramaters  ****/    thePictParams.srcRect = thePortRect;    thePictParams.hRes = ff(72);    thePictParams.vRes = ff(72);    thePictParams.version = -2;    thePictParams.reserved1 = 0;    thePictParams.reserved2 = 0;    // Display PICT compression setting dialog box    compressionSetting = ProcessPictCompDlog();    if (compressionSetting == kNoCompression)    {            // Create uncompressed PicHandle ready to save to disk.      SetGWorld((**theDocHndl).theImageWorld,nil);      theSavePict = OpenCPicture(&amp;thePictParams);      ClipRect (&amp;thePortRect);      CopyBits((BitMap*)(*theSavePictPixMapHndl),           (BitMap*)(*theSavePictPixMapHndl),           &amp;thePortRect,           &amp;thePortRect,srcCopy,nil);      ClosePicture();      SetGWorld(oldPort,theGDevHndl);      UnlockPixels(theSavePictPixMapHndl);    }    else      {      // Image compression selected. Compress image using chosen setting      // and create PicHandle containing the compressed image ready to save to disk      switch (compressionSetting)      {        case kHighQuality:          compQuality = codecHighQuality;        break;        case kMediumQuality:          compQuality = codecNormalQuality;        break;        case kLowQuality:          compQuality = codecLowQuality;        break;      }      error = GetMaxCompressionSize(theSavePictPixMapHndl,                    &amp;thePortRect,0,compQuality,                    'jpeg',anyCodec,&amp;maxCompSize);      if (error != noErr || maxCompSize == 0)      {        UnlockPixels(theSavePictPixMapHndl);        SaveSetMMUMode(false);        return kDefaultAppError;      }      compImageDescHndl = (ImageDescriptionHandle) NewHandle(4);      compDataHndl = NewHandle(maxCompSize);      if (compImageDescHndl != nil &amp;&amp; compDataHndl != nil)      {        HLock(compDataHndl);        compDataPtr = StripAddress(*compDataHndl);        error = CompressImage (theSavePictPixMapHndl,&amp;thePortRect,                     compQuality,'jpeg',compImageDescHndl,compDataPtr);        if (error != noErr)        {          RemoveOldSaveData(compImageDescHndl,compDataHndl,theSavePictPixMapHndl);          SaveSetMMUMode(false);          return kFailPictCompSave;        }        SetGWorld((**theDocHndl).theImageWorld,nil);        theSavePict = OpenCPicture(&amp;thePictParams);        ClipRect (&amp;thePortRect);        error = DecompressImage(compDataPtr, compImageDescHndl,                    theSavePictPixMapHndl,&amp;thePortRect,                    &amp;thePortRect, srcCopy, nil);        ClosePicture();        SetGWorld(oldPort,theGDevHndl);        RemoveOldSaveData(compImageDescHndl,compDataHndl,theSavePictPixMapHndl);        if (error)        {          if (theSavePict)            DisposeHandle((Handle)theSavePict);          SaveSetMMUMode(false);          return kFailPictCompSave;        }      }      else      {        RemoveOldSaveData(compImageDescHndl,compDataHndl,theSavePictPixMapHndl);        SaveSetMMUMode(false);        return kFailPictCompSave;      }    }  }  else    return kFailedLockPixels;    // Save image conatined in PicHandle structure to disk  fileErr = FSpCreate(&amp;thePictFile-&gt;sfFile,'ttxt','PICT',smSystemScript);  if (!fileErr)    fileErr = FSpOpenDF(&amp;thePictFile-&gt;sfFile,fsRdWrPerm,&amp;fileRefNum);  if (!fileErr)  {    for (count = 0;count&lt;128;count++)      FSWrite(fileRefNum,&amp;emptyDataSize,&amp;emptyData);    thePictLen = GetHandleSize((Handle)theSavePict);    HLock((Handle)theSavePict);    fileErr = FSWrite(fileRefNum,&amp;thePictLen,*theSavePict);    fileErr |= FSClose(fileRefNum);    HUnlock((Handle)theSavePict);    if (fileErr)    {      switch (compressionSetting)      {        case kNoCompression:          error = kFailPictUnCompSave;        break;        default:          error = kFailPictCompSave;        break;      }    }  }  SaveSetMMUMode(false);  if (theSavePict)    DisposeHandle((Handle)theSavePict);  return error;}/****  handle processing of the PICT file settings dialog  ****/#pragma segment fileSysshort  ProcessPictCompDlog(void){  Handle        theItemHandle;  DialogPtr      theDialog = nil;  ModalFilterUPP    theFilter = nil;  GrafPtr        oldPort;  Rect        theRect;  short        theCompSetting = kNoCompression;  short        theItem,            theNextItem,            theItemType,            count;    GetPort(&amp;oldPort);  theDialog = GetNewDialog(rPictCompDialog,nil,((WindowPtr)-1L));  SetPort(theDialog);  if (!GetStdFilterProc(&amp;theFilter))    SetDialogDefaultItem(theDialog,1);  GetDialogItem(theDialog,theCompSetting,&amp;theItemType,&amp;theItemHandle,&amp;theRect);  SetControlValue((ControlHandle)theItemHandle,1);  do{    ModalDialog(nil,&amp;theItem);    GetDialogItem(theDialog,theItem,&amp;theItemType,&amp;theItemHandle,&amp;theRect);    if (theItemType == kRadioButton)    {      for (count = kNoCompression; count&lt;=kLowQuality; count++)      {        GetDialogItem(theDialog,count,&amp;theItemType,&amp;theItemHandle,&amp;theRect);        if (count == theItem)        {          SetControlValue((ControlHandle)theItemHandle,1);          theCompSetting = count;        }        else          SetControlValue((ControlHandle)theItemHandle,0);      }    }  } while (theItem != kOkButton);  DisposeDialog(theDialog);  SetPort(oldPort);  return  theCompSetting;}/****  Clean up after save file  ****/#pragma segment fileSysvoid  RemoveOldSaveData(ImageDescriptionHandle theImageDescH, Handle theDataH, PixMapHandle thePixMapHndl){  UnlockPixels(thePixMapHndl);  if (theImageDescH)    DisposeHandle((Handle)theImageDescH);  if (theDataH)  {    HUnlock(theDataH);    DisposeHandle(theDataH);  }}/****  convert QuickDraw GX shape to handle for saving to disk ****/#pragma segment fileSysvoid  SaveGXShapeToFile(gxShape theShape, gxFlattenFlag theFlags, short fileRefNum){  UserGXSpool   dataBlock;    dataBlock.spool.spoolProcedure = NewgxSpoolProc(FileSpoolProc);  dataBlock.reference = fileRefNum;  dataBlock.spool.buffer = nil;  dataBlock.spool.bufferSize = 0;  GXFlattenShape(theShape, theFlags, &amp;dataBlock.spool);  DisposeRoutineDescriptor(dataBlock.spool.spoolProcedure);}/****  Save flatten QD GX shape to disk  ****/#pragma segment fileSysOSErr  SaveQdGxShape(ImageDocHndl theDocHndl, StandardFileReply* thePictFile){  OSErr    fileErr = noErr;  short    theRefNum;    if ((*theDocHndl)-&gt;theGXImageShape == nil)    return kFailQDGXSave;  fileErr = FSpCreate(&amp;thePictFile-&gt;sfFile,(OSType)AppCreator,'qdgx',smSystemScript);  if (!fileErr)    fileErr = FSpOpenDF(&amp;thePictFile-&gt;sfFile,fsRdWrPerm,&amp;theRefNum);  if (fileErr)    DebugStr(&quot;\pFile error creating QDGX file for save operation&quot;);  SaveGXShapeToFile((*theDocHndl)-&gt;theGXImageShape, 0,theRefNum);  fileErr |= FSClose(theRefNum);  if (fileErr)    fileErr = kFailQDGXSave;  return fileErr;}/**** QuickDraw GX shape to file Spooling function  ****/#pragma segment fileSysstatic long FileSpoolProc(gxSpoolCommand command, UserGXSpool *block){   OSErr     error = noErr;      switch (command)   {      case gxOpenReadSpool:      break;      case gxOpenWriteSpool:      break;      case gxReadSpool:      break;      case gxWriteSpool:      {         long count = block-&gt;spool.count;         error = FSWrite(block-&gt;reference, &amp;count, block-&gt;spool.buffer);         if (error)           DebugStr(&quot;\pFSWrite failed&quot;);      }      break;      case gxCloseSpool:      break;      default:         DebugStr(&quot;\punexpected spool command&quot;);      break;   }   return noErr;}/****  Revert image to last saved image ****/#pragma segment fileSysOSErr  RevertToSavedFile(ImageDocHndl theDocHndl, WindowPtr theWindow){  PicHandle      thePictHndl = nil;  PictInfo      thePictInfo;  GrafPtr        oldPort;  TiffInfo      theTiffStruct;  OSErr        error = noErr;    (**theDocHndl).theImageChanged = false;  if ((**theDocHndl).hasUndoTemp)  {    RemoveTempFile(theDocHndl, true, false);    (**theDocHndl).hasUndoTemp = false;  }  if ((**theDocHndl).hasRedoTemp)  {    RemoveTempFile(theDocHndl, false, true);    (**theDocHndl).hasRedoTemp = false;  }  (**theDocHndl).theUndoState = kCannotUndo;  if ((**theDocHndl).theImageWorld)    DisposeGWorld((**theDocHndl).theImageWorld);  if ((**theDocHndl).theColorsPalette)    DisposePalette((**theDocHndl).theColorsPalette);  if ((**theDocHndl).isUsingQDGX)  {    GXDisposeShape((**theDocHndl).theGXImageShape);    GXDisposeInk((**theDocHndl).theInkShape);    GXDisposeViewPort((**theDocHndl).theGxChildView);    GXDisposeViewPort((**theDocHndl).theGXview);  }  switch ((*theDocHndl)-&gt;theFileType)  {    case TiffType:      theTiffStruct.tiffCTabHndl = nil;    // set to nil as Color table not always created      GetTIFFHdrInfo(theDocHndl,&amp;theTiffStruct);      GetTIFFIFDirectory(theDocHndl,&amp;theTiffStruct);      switch (theTiffStruct.bitDepth)      {        case 8:          (**theDocHndl).theImageWorld =             CreateOffscreen(theTiffStruct.tiffCTabHndl,                    theTiffStruct.xImageSize,                    theTiffStruct.yImageSize,                    theTiffStruct.bitDepth,kNoFlags);          if ((**theDocHndl).theImageWorld == nil)          {            DisposeHandle((Handle)theDocHndl);            return kFailMakeGWorld;          }        break;        case 32:          (**theDocHndl).theImageWorld =             CreateOffscreen(nil,                    theTiffStruct.xImageSize,                    theTiffStruct.yImageSize,                    theTiffStruct.bitDepth,kNoFlags);          if ((**theDocHndl).theImageWorld == nil)          {              DisposeHandle((Handle)theDocHndl);            return kFailMakeGWorld;          }        break;        default:          DisplayAlert (rGenWarning,rErrMessages,iNoSupportBitDepth);          return kBitDepthErr;        break;      }      error = LoadTiffToGWorld (theDocHndl,&amp;theTiffStruct,theTiffStruct.bitDepth);      if (error)      {        DisplayAlert (rGenAlert,0,0);        return error;      }      SetUndoItemText((*theDocHndl)-&gt;theUndoState);    break;    case PictType:      thePictHndl = LoadPictImageFile(theDocHndl);      if (!thePictHndl)      {        DisposeHandle((Handle)theDocHndl);        return kDefaultAppError;      }      // test if minimal temp memory free available. If none available GetPictInfo() fails.      if (TempFreeMem() &lt; kMinLowMem)      {        DisplayAlert(rGenWarning,rErrMessages,iLowTempMem);        DisposeHandle((Handle)theDocHndl);        return kLowMemWarning;      }      error = GetPictInfo (thePictHndl, &amp;thePictInfo, returnColorTable,256,systemMethod,0);      if (!error &amp;&amp; thePictInfo.depth &lt;= 8)        (**theDocHndl).theImageWorld =           CreateOffscreen(thePictInfo.theColorTable,                  (**theDocHndl).theImageXSize,                  (**theDocHndl).theImageYSize,                  (**theDocHndl).theImageDepth,kNoFlags);      else        (**theDocHndl).theImageWorld =           CreateOffscreen(nil,                  (**theDocHndl).theImageXSize,                  (**theDocHndl).theImageYSize,                  (**theDocHndl).theImageDepth,kNoFlags);            if ((**theDocHndl).theImageWorld == nil)      {        DisposeHandle((Handle)theDocHndl);    // dispose image document        DisposeHandle((Handle)thePictHndl);    // dispose picHandle        return kFailMakeGWorld;      }      error = DrawPictToGWorld (theDocHndl,thePictHndl);      SetUndoItemText((*theDocHndl)-&gt;theUndoState);    break;    case GXType:      DisplayAlert(rGenWarning,rErrMessages,iNotImplemented);      return noErr;    break;  }  GetPort(&amp;oldPort);  SetPort(theWindow);  InvalRect(&amp;theWindow-&gt;portRect);  SetPort(oldPort);  return error;}/****  Clean up after abort TIFF load  ****/#pragma segment fileSysvoid CleanLoadAbort(ImageDocHndl theDocHndl){  if ((**theDocHndl).theColorsPalette)    DisposePalette((**theDocHndl).theColorsPalette);  DisposeHandle((Handle)theDocHndl);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Imageer/listing4.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Imageer/listing4.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Imageer/listing4.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>