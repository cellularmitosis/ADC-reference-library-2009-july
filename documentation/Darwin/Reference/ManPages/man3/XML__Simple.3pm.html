<html><head><title>Mac OS X
 Manual Page For XML::Simple(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/XML::Simple" title="Mac OS X
 Manual Page for XML::Simple(3pm)"><a name="//apple_ref/doc/man/3/XML::Simple" title="Mac OS X
 Manual Page for XML::Simple(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/XML::Simple"; name=XML::Simple(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
XML::Simple(3)                       User Contributed Perl Documentation                      XML::Simple(3)



<b>NAME</b>
       XML::Simple - Easy API to maintain XML (esp config files)

<b>SYNOPSIS</b>
           use XML::Simple;

           my $ref = XMLin([&lt;xml file or string&gt;] [, &lt;options&gt;]);

           my $xml = XMLout($hashref [, &lt;options&gt;]);

       Or the object oriented way:

           require XML::Simple;

           my $xs = new XML::Simple(options);

           my $ref = $xs-&gt;XMLin([&lt;xml file or string&gt;] [, &lt;options&gt;]);

           my $xml = $xs-&gt;XMLout($hashref [, &lt;options&gt;]);

       (or see "SAX SUPPORT" for 'the SAX way').

       To catch common errors:

           use XML::Simple qw(:strict);

       (see "STRICT MODE" for more details).

<b>QUICK</b> <b>START</b>
       Say you have a script called <b>foo</b> and a file of configuration options called <b>foo.xml</b> containing this:

         &lt;config logdir="/var/log/foo/" debugfile="/tmp/foo.debug"&gt;
           &lt;server name="sahara" osname="solaris" osversion="2.6"&gt;
             &lt;address&gt;10.0.0.101&lt;/address&gt;
             &lt;address&gt;10.0.1.101&lt;/address&gt;
           &lt;/server&gt;
           &lt;server name="gobi" osname="irix" osversion="6.5"&gt;
             &lt;address&gt;10.0.0.102&lt;/address&gt;
           &lt;/server&gt;
           &lt;server name="kalahari" osname="linux" osversion="2.0.34"&gt;
             &lt;address&gt;10.0.0.103&lt;/address&gt;
             &lt;address&gt;10.0.1.103&lt;/address&gt;
           &lt;/server&gt;
         &lt;/config&gt;

       The following lines of code in <b>foo</b>:

         use XML::Simple;

         my $config = XMLin();

       will 'slurp' the configuration options into the hashref $config (because no arguments are passed to
       "XMLin()" the name and location of the XML file will be inferred from name and location of the
       script).  You can dump out the contents of the hashref using Data::Dumper:

         use Data::Dumper;

         print Dumper($config);

       which will produce something like this (formatting has been adjusted for brevity):

         {
             'logdir'        =&gt; '/var/log/foo/',
             'debugfile'     =&gt; '/tmp/foo.debug',
             'server'        =&gt; {
                 'sahara'        =&gt; {
                     'osversion'     =&gt; '2.6',
                     'osname'        =&gt; 'solaris',
                     'address'       =&gt; [ '10.0.0.101', '10.0.1.101' ]
                 },
                 'gobi'          =&gt; {
                     'osversion'     =&gt; '6.5',
                     'osname'        =&gt; 'irix',
                     'address'       =&gt; '10.0.0.102'
                 },
                 'kalahari'      =&gt; {
                     'osversion'     =&gt; '2.0.34',
                     'osname'        =&gt; 'linux',
                     'address'       =&gt; [ '10.0.0.103', '10.0.1.103' ]
                 }
             }
         }

       Your script could then access the name of the log directory like this:

         print $config-&gt;{logdir};

       similarly, the second address on the server 'kalahari' could be referenced as:

         print $config-&gt;{server}-&gt;{kalahari}-&gt;{address}-&gt;[1];

       What could be simpler?  (Rhetorical).

       For simple requirements, that's really all there is to it.  If you want to store your XML in a
       different directory or file, or pass it in as a string or even pass it in via some derivative of an
       IO::Handle, you'll need to check out "OPTIONS".  If you want to turn off or tweak the array folding
       feature (that neat little transformation that produced $config-&gt;{server}) you'll find options for
       that as well.

       If you want to generate XML (for example to write a modified version of $config back out as XML),
       check out "XMLout()".

       If your needs are not so simple, this may not be the module for you.  In that case, you might want to
       read "WHERE TO FROM HERE?".

<b>DESCRIPTION</b>
       The XML::Simple module provides a simple API layer on top of an underlying XML parsing module (either
       XML::Parser or one of the SAX2 parser modules).  Two functions are exported: "XMLin()" and
       "XMLout()".  Note: you can explicity request the lower case versions of the function names:
       "xml_in()" and "xml_out()".

       The simplest approach is to call these two functions directly, but an optional object oriented
       interface (see "OPTIONAL OO INTERFACE" below) allows them to be called as methods of an <b>XML::Simple</b>
       object.  The object interface can also be used at either end of a SAX pipeline.

       <u>XMLin()</u>

       Parses XML formatted data and returns a reference to a data structure which contains the same
       information in a more readily accessible form.  (Skip down to "EXAMPLES" below, for more sample
       code).

       "XMLin()" accepts an optional XML specifier followed by zero or more 'name =&gt; value' option pairs.
       The XML specifier can be one of the following:

       A filename
           If the filename contains no directory components "XMLin()" will look for the file in each
           directory in the SearchPath (see "OPTIONS" below) or in the current directory if the SearchPath
           option is not defined.  eg:

             $ref = XMLin('/etc/params.xml');

           Note, the filename '-' can be used to parse from STDIN.

       undef
           If there is no XML specifier, "XMLin()" will check the script directory and each of the
           SearchPath directories for a file with the same name as the script but with the extension '.xml'.
           Note: if you wish to specify options, you must specify the value 'undef'.  eg:

             $ref = XMLin(undef, ForceArray =&gt; 1);

       A string of XML
           A string containing XML (recognised by the presence of '&lt;' and '&gt;' characters) will be parsed
           directly.  eg:

             $ref = XMLin('&lt;opt username="bob" password="flurp" /&gt;');

       An IO::Handle object
           An IO::Handle object will be read to EOF and its contents parsed. eg:

             $fh = new IO::File('/etc/params.xml');
             $ref = XMLin($fh);

       <u>XMLout()</u>

       Takes a data structure (generally a hashref) and returns an XML encoding of that structure.  If the
       resulting XML is parsed using "XMLin()", it should return a data structure equivalent to the original
       (see caveats below).

       The "XMLout()" function can also be used to output the XML as SAX events see the "Handler" option and
       "SAX SUPPORT" for more details).

       When translating hashes to XML, hash keys which have a leading '-' will be silently skipped.  This is
       the approved method for marking elements of a data structure which should be ignored by "XMLout".
       (Note: If these items were not skipped the key names would be emitted as element or attribute names
       with a leading '-' which would not be valid XML).

       <b>Caveats</b>

       Some care is required in creating data structures which will be passed to "XMLout()".  Hash keys from
       the data structure will be encoded as either XML element names or attribute names.  Therefore, you
       should use hash key names which conform to the relatively strict XML naming rules:

       Names in XML must begin with a letter.  The remaining characters may be letters, digits, hyphens (-),
       underscores (_) or full stops (.).  It is also allowable to include one colon (:) in an element name
       but this should only be used when working with namespaces (<b>XML::Simple</b> can only usefully work with
       namespaces when teamed with a SAX Parser).

       You can use other punctuation characters in hash values (just not in hash keys) however <b>XML::Simple</b>
       does not support dumping binary data.

       If you break these rules, the current implementation of "XMLout()" will simply emit non-compliant XML
       which will be rejected if you try to read it back in.  (A later version of <b>XML::Simple</b> might take a
       more proactive approach).

       Note also that although you can nest hashes and arrays to arbitrary levels, circular data structures
       are not supported and will cause "XMLout()" to die.

       If you wish to 'round-trip' arbitrary data structures from Perl to XML and back to Perl, then you
       should probably disable array folding (using the KeyAttr option) both with "XMLout()" and with
       "XMLin()".  If you still don't get the expected results, you may prefer to use XML::Dumper which is
       designed for exactly that purpose.

       Refer to "WHERE TO FROM HERE?" if "XMLout()" is too simple for your needs.

<b>OPTIONS</b>
       <b>XML::Simple</b> supports a number of options (in fact as each release of <b>XML::Simple</b> adds more options,
       the module's claim to the name 'Simple' becomes increasingly tenuous).  If you find yourself
       repeatedly having to specify the same options, you might like to investigate "OPTIONAL OO INTERFACE"
       below.

       If you can't be bothered reading the documentation, refer to "STRICT MODE" to automatically catch
       common mistakes.

       Because there are so many options, it's hard for new users to know which ones are important, so here
       are the two you really need to know about:

          check out "ForceArray" because you'll almost certainly want to turn it on

          make sure you know what the "KeyAttr" option does and what its default value is because it may
           surprise you otherwise (note in particular that 'KeyAttr' affects both "XMLin" and "XMLout")

       The option name headings below have a trailing 'comment' - a hash followed by two pieces of metadata:

          Options are marked with '<u>in</u>' if they are recognised by "XMLin()" and '<u>out</u>' if they are recognised
           by "XMLout()".

          Each option is also flagged to indicate whether it is:

            'important'   - don't use the module until you understand this one
            'handy'       - you can skip this on the first time through
            'advanced'    - you can skip this on the second time through
            'SAX only'    - don't worry about this unless you're using SAX (or
                            alternatively if you need this, you also need SAX)
            'seldom used' - you'll probably never use this unless you were the
                            person that requested the feature

       The options are listed alphabetically:

       Note: option names are no longer case sensitive so you can use the mixed case versions shown here;
       all lower case as required by versions 2.03 and earlier; or you can add underscores between the words
       (eg: key_attr).

       <b>AttrIndent</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>out</u> <u>-</u> <u>handy</u>

       When you are using "XMLout()", enable this option to have attributes printed one-per-line with
       sensible indentation rather than all on one line.

       <b>Cache</b> <b>=&gt;</b> <b>[</b> <b>cache</b> <b>schemes</b> <b>]</b> <u>#</u> <u>in</u> <u>-</u> <u>advanced</u>

       Because loading the <b>XML::Parser</b> module and parsing an XML file can consume a significant number of
       CPU cycles, it is often desirable to cache the output of "XMLin()" for later reuse.

       When parsing from a named file, <b>XML::Simple</b> supports a number of caching schemes.  The 'Cache' option
       may be used to specify one or more schemes (using an anonymous array).  Each scheme will be tried in
       turn in the hope of finding a cached pre-parsed representation of the XML file.  If no cached copy is
       found, the file will be parsed and the first cache scheme in the list will be used to save a copy of
       the results.  The following cache schemes have been implemented:

       storable
           Utilises <b>Storable.pm</b> to read/write a cache file with the same name as the XML file but with the
           extension .stor

       memshare
           When a file is first parsed, a copy of the resulting data structure is retained in memory in the
           <b>XML::Simple</b> module's namespace.  Subsequent calls to parse the same file will return a reference
           to this structure.  This cached version will persist only for the life of the Perl interpreter
           (which in the case of mod_perl for example, may be some significant time).

           Because each caller receives a reference to the same data structure, a change made by one caller
           will be visible to all.  For this reason, the reference returned should be treated as read-only.

       memcopy
           This scheme works identically to 'memshare' (above) except that each caller receives a reference
           to a new data structure which is a copy of the cached version.  Copying the data structure will
           add a little processing overhead, therefore this scheme should only be used where the caller
           intends to modify the data structure (or wishes to protect itself from others who might).  This
           scheme uses <b>Storable.pm</b> to perform the copy.

       Warning! The memory-based caching schemes compare the timestamp on the file to the time when it was
       last parsed.  If the file is stored on an NFS filesystem (or other network share) and the clock on
       the file server is not exactly synchronised with the clock where your script is run, updates to the
       source XML file may appear to be ignored.

       <b>ContentKey</b> <b>=&gt;</b> <b>'keyname'</b> <u>#</u> <u>in+out</u> <u>-</u> <u>seldom</u> <u>used</u>

       When text content is parsed to a hash value, this option let's you specify a name for the hash key to
       override the default 'content'.  So for example:

         XMLin('&lt;opt one="1"&gt;Text&lt;/opt&gt;', ContentKey =&gt; 'text')

       will parse to:

         { 'one' =&gt; 1, 'text' =&gt; 'Text' }

       instead of:

         { 'one' =&gt; 1, 'content' =&gt; 'Text' }

       "XMLout()" will also honour the value of this option when converting a hashref to XML.

       You can also prefix your selected key name with a '-' character to have "XMLin()" try a little harder
       to eliminate unnecessary 'content' keys after array folding.  For example:

         XMLin(
           '&lt;opt&gt;&lt;item name="one"&gt;First&lt;/item&gt;&lt;item name="two"&gt;Second&lt;/item&gt;&lt;/opt&gt;',
           KeyAttr =&gt; {item =&gt; 'name'},
           ForceArray =&gt; [ 'item' ],
           ContentKey =&gt; '-content'
         )

       will parse to:

         {
           'item' =&gt; {
             'one' =&gt;  'First'
             'two' =&gt;  'Second'
           }
         }

       rather than this (without the '-'):

         {
           'item' =&gt; {
             'one' =&gt; { 'content' =&gt; 'First' }
             'two' =&gt; { 'content' =&gt; 'Second' }
           }
         }

       <b>DataHandler</b> <b>=&gt;</b> <b>code_ref</b> <u>#</u> <u>in</u> <u>-</u> <u>SAX</u> <u>only</u>

       When you use an <b>XML::Simple</b> object as a SAX handler, it will return a 'simple tree' data structure in
       the same format as "XMLin()" would return.  If this option is set (to a subroutine reference), then
       when the tree is built the subroutine will be called and passed two arguments: a reference to the
       <b>XML::Simple</b> object and a reference to the data tree.  The return value from the subroutine will be
       returned to the SAX driver.  (See "SAX SUPPORT" for more details).

       <b>ForceArray</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>in</u> <u>-</u> <u>important</u>

       This option should be set to '1' to force nested elements to be represented as arrays even when there
       is only one.  Eg, with ForceArray enabled, this XML:

           &lt;opt&gt;
             &lt;name&gt;value&lt;/name&gt;
           &lt;/opt&gt;

       would parse to this:

           {
             'name' =&gt; [
                         'value'
                       ]
           }

       instead of this (the default):

           {
             'name' =&gt; 'value'
           }

       This option is especially useful if the data structure is likely to be written back out as XML and
       the default behaviour of rolling single nested elements up into attributes is not desirable.

       If you are using the array folding feature, you should almost certainly enable this option.  If you
       do not, single nested elements will not be parsed to arrays and therefore will not be candidates for
       folding to a hash.  (Given that the default value of 'KeyAttr' enables array folding, the default
       value of this option should probably also have been enabled too - sorry).

       <b>ForceArray</b> <b>=&gt;</b> <b>[</b> <b>names</b> <b>]</b> <u>#</u> <u>in</u> <u>-</u> <u>important</u>

       This alternative (and preferred) form of the 'ForceArray' option allows you to specify a list of
       element names which should always be forced into an array representation, rather than the 'all or
       nothing' approach above.

       It is also possible (since version 2.05) to include compiled regular expressions in the list - any
       element names which match the pattern will be forced to arrays.  If the list contains only a single
       regex, then it is not necessary to enclose it in an arrayref.  Eg:

         ForceArray =&gt; qr/_list$/

       <b>ForceContent</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>in</u> <u>-</u> <u>seldom</u> <u>used</u>

       When "XMLin()" parses elements which have text content as well as attributes, the text content must
       be represented as a hash value rather than a simple scalar.  This option allows you to force text
       content to always parse to a hash value even when there are no attributes.  So for example:

         XMLin('&lt;opt&gt;&lt;x&gt;text1&lt;/x&gt;&lt;y a="2"&gt;text2&lt;/y&gt;&lt;/opt&gt;', ForceContent =&gt; 1)

       will parse to:

         {
           'x' =&gt; {           'content' =&gt; 'text1' },
           'y' =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }
         }

       instead of:

         {
           'x' =&gt; 'text1',
           'y' =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }
         }

       <b>GroupTags</b> <b>=&gt;</b> <b>{</b> <b>grouping</b> <b>tag</b> <b>=&gt;</b> <b>grouped</b> <b>tag</b> <b>}</b> <u>#</u> <u>in+out</u> <u>-</u> <u>handy</u>

       You can use this option to eliminate extra levels of indirection in your Perl data structure.  For
       example this XML:

         &lt;opt&gt;
          &lt;searchpath&gt;
            &lt;dir&gt;/usr/bin&lt;/dir&gt;
            &lt;dir&gt;/usr/local/bin&lt;/dir&gt;
            &lt;dir&gt;/usr/X11/bin&lt;/dir&gt;
          &lt;/searchpath&gt;
        &lt;/opt&gt;

       Would normally be read into a structure like this:

         {
           searchpath =&gt; {
                           dir =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
                         }
         }

       But when read in with the appropriate value for 'GroupTags':

         my $opt = XMLin($xml, GroupTags =&gt; { searchpath =&gt; 'dir' });

       It will return this simpler structure:

         {
           searchpath =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
         }

       The grouping element ("&lt;searchpath&gt;" in the example) must not contain any attributes or elements
       other than the grouped element.

       You can specify multiple 'grouping element' to 'grouped element' mappings in the same hashref.  If
       this option is combined with "KeyAttr", the array folding will occur first and then the grouped
       element names will be eliminated.

       "XMLout" will also use the grouptag mappings to re-introduce the tags around the grouped elements.
       Beware though that this will occur in all places that the 'grouping tag' name occurs - you probably
       don't want to use the same name for elements as well as attributes.

       <b>Handler</b> <b>=&gt;</b> <b>object_ref</b> <u>#</u> <u>out</u> <u>-</u> <u>SAX</u> <u>only</u>

       Use the 'Handler' option to have "XMLout()" generate SAX events rather than returning a string of
       XML.  For more details see "SAX SUPPORT" below.

       Note: the current implementation of this option generates a string of XML and uses a SAX parser to
       translate it into SAX events.  The normal encoding rules apply here - your data must be UTF8 encoded
       unless you specify an alternative encoding via the 'XMLDecl' option; and by the time the data reaches
       the handler object, it will be in UTF8 form regardless of the encoding you supply.  A future
       implementation of this option may generate the events directly.

       <b>KeepRoot</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>in+out</u> <u>-</u> <u>handy</u>

       In its attempt to return a data structure free of superfluous detail and unnecessary levels of
       indirection, "XMLin()" normally discards the root element name.  Setting the 'KeepRoot' option to '1'
       will cause the root element name to be retained.  So after executing this code:

         $config = XMLin('&lt;config tempdir="/tmp" /&gt;', KeepRoot =&gt; 1)

       You'll be able to reference the tempdir as "$config-&gt;{config}-&gt;{tempdir}" instead of the default
       "$config-&gt;{tempdir}".

       Similarly, setting the 'KeepRoot' option to '1' will tell "XMLout()" that the data structure already
       contains a root element name and it is not necessary to add another.

       <b>KeyAttr</b> <b>=&gt;</b> <b>[</b> <b>list</b> <b>]</b> <u>#</u> <u>in+out</u> <u>-</u> <u>important</u>

       This option controls the 'array folding' feature which translates nested elements from an array to a
       hash.  It also controls the 'unfolding' of hashes to arrays.

       For example, this XML:

           &lt;opt&gt;
             &lt;user login="grep" fullname="Gary R Epstein" /&gt;
             &lt;user login="stty" fullname="Simon T Tyson" /&gt;
           &lt;/opt&gt;

       would, by default, parse to this:

           {
             'user' =&gt; [
                         {
                           'login' =&gt; 'grep',
                           'fullname' =&gt; 'Gary R Epstein'
                         },
                         {
                           'login' =&gt; 'stty',
                           'fullname' =&gt; 'Simon T Tyson'
                         }
                       ]
           }

       If the option 'KeyAttr =&gt; "login"' were used to specify that the 'login' attribute is a key, the same
       XML would parse to:

           {
             'user' =&gt; {
                         'stty' =&gt; {
                                     'fullname' =&gt; 'Simon T Tyson'
                                   },
                         'grep' =&gt; {
                                     'fullname' =&gt; 'Gary R Epstein'
                                   }
                       }
           }

       The key attribute names should be supplied in an arrayref if there is more than one.  "XMLin()" will
       attempt to match attribute names in the order supplied.  "XMLout()" will use the first attribute name
       supplied when 'unfolding' a hash into an array.

       Note 1: The default value for 'KeyAttr' is ['name', 'key', 'id'].  If you do not want folding on
       input or unfolding on output you must setting this option to an empty list to disable the feature.

       Note 2: If you wish to use this option, you should also enable the "ForceArray" option.  Without
       'ForceArray', a single nested element will be rolled up into a scalar rather than an array and
       therefore will not be folded (since only arrays get folded).

       <b>KeyAttr</b> <b>=&gt;</b> <b>{</b> <b>list</b> <b>}</b> <u>#</u> <u>in+out</u> <u>-</u> <u>important</u>

       This alternative (and preferred) method of specifiying the key attributes allows more fine grained
       control over which elements are folded and on which attributes.  For example the option 'KeyAttr =&gt; {
       package =&gt; 'id' } will cause any package elements to be folded on the 'id' attribute.  No other
       elements which have an 'id' attribute will be folded at all.

       Note: "XMLin()" will generate a warning (or a fatal error in "STRICT MODE") if this syntax is used
       and an element which does not have the specified key attribute is encountered (eg: a 'package'
       element without an 'id' attribute, to use the example above).  Warnings will only be generated if <b>-w</b>
       is in force.

       Two further variations are made possible by prefixing a '+' or a '-' character to the attribute name:

       The option 'KeyAttr =&gt; { user =&gt; "+login" }' will cause this XML:

           &lt;opt&gt;
             &lt;user login="grep" fullname="Gary R Epstein" /&gt;
             &lt;user login="stty" fullname="Simon T Tyson" /&gt;
           &lt;/opt&gt;

       to parse to this data structure:

           {
             'user' =&gt; {
                         'stty' =&gt; {
                                     'fullname' =&gt; 'Simon T Tyson',
                                     'login'    =&gt; 'stty'
                                   },
                         'grep' =&gt; {
                                     'fullname' =&gt; 'Gary R Epstein',
                                     'login'    =&gt; 'grep'
                                   }
                       }
           }

       The '+' indicates that the value of the key attribute should be copied rather than moved to the
       folded hash key.

       A '-' prefix would produce this result:

           {
             'user' =&gt; {
                         'stty' =&gt; {
                                     'fullname' =&gt; 'Simon T Tyson',
                                     '-login'    =&gt; 'stty'
                                   },
                         'grep' =&gt; {
                                     'fullname' =&gt; 'Gary R Epstein',
                                     '-login'    =&gt; 'grep'
                                   }
                       }
           }

       As described earlier, "XMLout" will ignore hash keys starting with a '-'.

       <b>NoAttr</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>in+out</u> <u>-</u> <u>handy</u>

       When used with "XMLout()", the generated XML will contain no attributes.  All hash key/values will be
       represented as nested elements instead.

       When used with "XMLin()", any attributes in the XML will be ignored.

       <b>NoEscape</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>out</u> <u>-</u> <u>seldom</u> <u>used</u>

       By default, "XMLout()" will translate the characters '&lt;', '&gt;', '&amp;' and '"' to '&amp;lt;', '&amp;gt;', '&amp;amp;'
       and '&amp;quot' respectively.  Use this option to suppress escaping (presumably because you've already
       escaped the data in some more sophisticated manner).

       <b>NoIndent</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>out</u> <u>-</u> <u>seldom</u> <u>used</u>

       Set this option to 1 to disable "XMLout()"'s default 'pretty printing' mode.  With this option
       enabled, the XML output will all be on one line (unless there are newlines in the data) - this may be
       easier for downstream processing.

       <b>NoSort</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>out</u> <u>-</u> <u>seldom</u> <u>used</u>

       Newer versions of XML::Simple sort elements and attributes alphabetically (*), by default.  Enable
       this option to suppress the sorting - possibly for backwards compatibility.

       * Actually, sorting is alphabetical but 'key' attribute or element names (as in 'KeyAttr') sort
       first.  Also, when a hash of hashes is 'unfolded', the elements are sorted alphabetically by the
       value of the key field.

       <b>NormaliseSpace</b> <b>=&gt;</b> <b>0</b> <b>|</b> <b>1</b> <b>|</b> <b>2</b> <u>#</u> <u>in</u> <u>-</u> <u>handy</u>

       This option controls how whitespace in text content is handled.  Recognised values for the option
       are:

          0 = (default) whitespace is passed through unaltered (except of course for the normalisation of
           whitespace in attribute values which is mandated by the XML recommendation)

          1 = whitespace is normalised in any value used as a hash key (normalising means removing leading
           and trailing whitespace and collapsing sequences of whitespace characters to a single space)

          2 = whitespace is normalised in all text content

       Note: you can spell this option with a 'z' if that is more natural for you.

       <b>NSExpand</b> <b>=&gt;</b> <b>1</b> <u>#</u> <u>in+out</u> <u>handy</u> <u>-</u> <u>SAX</u> <u>only</u>

       This option controls namespace expansion - the translation of element and attribute names of the form
       'prefix:name' to '{uri}name'.  For example the element name 'xsl:template' might be expanded to:
       '{<a href="http://www.w3.org/1999/XSL/Transform}template">http://www.w3.org/1999/XSL/Transform}template</a>'.

       By default, "XMLin()" will return element names and attribute names exactly as they appear in the
       XML.  Setting this option to 1 will cause all element and attribute names to be expanded to include
       their namespace prefix.

       <u>Note:</u> <u>You</u> <u>must</u> <u>be</u> <u>using</u> <u>a</u> <u>SAX</u> <u>parser</u> <u>for</u> <u>this</u> <u>option</u> <u>to</u> <u>work</u> <u>(ie:</u> <u>it</u> <u>does</u> <u>not</u> <u>work</u> <u>with</u> <u>XML::Parser)</u>.

       This option also controls whether "XMLout()" performs the reverse translation from '{uri}name' back
       to 'prefix:name'.  The default is no translation.  If your data contains expanded names, you should
       set this option to 1 otherwise "XMLout" will emit XML which is not well formed.

       <u>Note:</u> <u>You</u> <u>must</u> <u>have</u> <u>the</u> <u>XML::NamespaceSupport</u> <u>module</u> <u>installed</u> <u>if</u> <u>you</u> <u>want</u> <u>"XMLout()"</u> <u>to</u> <u>translate</u>
       <u>URIs</u> <u>back</u> <u>to</u> <u>prefixes</u>.

       <b>NumericEscape</b> <b>=&gt;</b> <b>0</b> <b>|</b> <b>1</b> <b>|</b> <b>2</b> <u>#</u> <u>out</u> <u>-</u> <u>handy</u>

       Use this option to have 'high' (non-ASCII) characters in your Perl data structure converted to
       numeric entities (eg: &amp;#8364;) in the XML output.  Three levels are possible:

       0 - default: no numeric escaping (OK if you're writing out UTF8)

       1 - only characters above 0xFF are escaped (ie: characters in the 0x80-FF range are not escaped),
       possibly useful with ISO8859-1 output

       2 - all characters above 0x7F are escaped (good for plain ASCII output)

       <b>OutputFile</b> <b>=&gt;</b> <b>&lt;file</b> <b>specifier&gt;</b> <u>#</u> <u>out</u> <u>-</u> <u>handy</u>

       The default behaviour of "XMLout()" is to return the XML as a string.  If you wish to write the XML
       to a file, simply supply the filename using the 'OutputFile' option.

       This option also accepts an IO handle object - especially useful in Perl 5.8.0 and later for output
       using an encoding other than UTF-8, eg:

         open my $fh, '&gt;:encoding(iso-8859-1)', $path or die "open($path): $!";
         XMLout($ref, OutputFile =&gt; $fh);

       <b>ParserOpts</b> <b>=&gt;</b> <b>[</b> <b>XML::Parser</b> <b>Options</b> <b>]</b> <u>#</u> <u>in</u> <u>-</u> <u>don't</u> <u>use</u> <u>this</u>

       <u>Note:</u> <u>This</u> <u>option</u> <u>is</u> <u>now</u> <u>officially</u> <u>deprecated.</u>  <u>If</u> <u>you</u> <u>find</u> <u>it</u> <u>useful,</u> <u>email</u> <u>the</u> <u>author</u> <u>with</u> <u>an</u>
       <u>example</u> <u>of</u> <u>what</u> <u>you</u> <u>use</u> <u>it</u> <u>for.</u>  <u>Do</u> <u>not</u> <u>use</u> <u>this</u> <u>option</u> <u>to</u> <u>set</u> <u>the</u> <u>ProtocolEncoding,</u> <u>that's</u> <u>just</u>
       <u>plain</u> <u>wrong</u> <u>-</u> <u>fix</u> <u>the</u> <u>XML</u>.

       This option allows you to pass parameters to the constructor of the underlying XML::Parser object
       (which of course assumes you're not using SAX).

       <b>RootName</b> <b>=&gt;</b> <b>'string'</b> <u>#</u> <u>out</u> <u>-</u> <u>handy</u>

       By default, when "XMLout()" generates XML, the root element will be named 'opt'.  This option allows
       you to specify an alternative name.

       Specifying either undef or the empty string for the RootName option will produce XML with no root
       elements.  In most cases the resulting XML fragment will not be 'well formed' and therefore could not
       be read back in by "XMLin()".  Nevertheless, the option has been found to be useful in certain
       circumstances.

       <b>SearchPath</b> <b>=&gt;</b> <b>[</b> <b>list</b> <b>]</b> <u>#</u> <u>in</u> <u>-</u> <u>handy</u>

       If you pass "XMLin()" a filename, but the filename include no directory component, you can use this
       option to specify which directories should be searched to locate the file.  You might use this option
       to search first in the user's home directory, then in a global directory such as /etc.

       If a filename is provided to "XMLin()" but SearchPath is not defined, the file is assumed to be in
       the current directory.

       If the first parameter to "XMLin()" is undefined, the default SearchPath will contain only the
       directory in which the script itself is located.  Otherwise the default SearchPath will be empty.

       <b>SuppressEmpty</b> <b>=&gt;</b> <b>1</b> <b>|</b> <b>''</b> <b>|</b> <b>undef</b> <u>#</u> <u>in+out</u> <u>-</u> <u>handy</u>

       This option controls what "XMLin()" should do with empty elements (no attributes and no content).
       The default behaviour is to represent them as empty hashes.  Setting this option to a true value (eg:
       1) will cause empty elements to be skipped altogether.  Setting the option to 'undef' or the empty
       string will cause empty elements to be represented as the undefined value or the empty string
       respectively.  The latter two alternatives are a little easier to test for in your code than a hash
       with no keys.

       The option also controls what "XMLout()" does with undefined values.  Setting the option to undef
       causes undefined values to be output as empty elements (rather than empty attributes), it also
       suppresses the generation of warnings about undefined values.  Setting the option to a true value
       (eg: 1) causes undefined values to be skipped altogether on output.

       <b>ValueAttr</b> <b>=&gt;</b> <b>[</b> <b>names</b> <b>]</b> <u>#</u> <u>in</u> <u>-</u> <u>handy</u>

       Use this option to deal elements which always have a single attribute and no content.  Eg:

         &lt;opt&gt;
           &lt;colour value="red" /&gt;
           &lt;size   value="XXL" /&gt;
         &lt;/opt&gt;

       Setting "ValueAttr =&gt; [ 'value' ]" will cause the above XML to parse to:

         {
           colour =&gt; 'red',
           size   =&gt; 'XXL'
         }

       instead of this (the default):

         {
           colour =&gt; { value =&gt; 'red' },
           size   =&gt; { value =&gt; 'XXL' }
         }

       Note: This form of the ValueAttr option is not compatible with "XMLout()" - since the attribute name
       is discarded at parse time, the original XML cannot be reconstructed.

       <b>ValueAttr</b> <b>=&gt;</b> <b>{</b> <b>element</b> <b>=&gt;</b> <b>attribute,</b> <b>...</b> <b>}</b> <u>#</u> <u>in+out</u> <u>-</u> <u>handy</u>

       This (preferred) form of the ValueAttr option requires you to specify both the element and the
       attribute names.  This is not only safer, it also allows the original XML to be reconstructed by
       "XMLout()".

       Note: You probably don't want to use this option and the NoAttr option at the same time.

       <b>Variables</b> <b>=&gt;</b> <b>{</b> <b>name</b> <b>=&gt;</b> <b>value</b> <b>}</b> <u>#</u> <u>in</u> <u>-</u> <u>handy</u>

       This option allows variables in the XML to be expanded when the file is read.  (there is no facility
       for putting the variable names back if you regenerate XML using "XMLout").

       A 'variable' is any text of the form "${name}" which occurs in an attribute value or in the text
       content of an element.  If 'name' matches a key in the supplied hashref, "${name}" will be replaced
       with the corresponding value from the hashref.  If no matching key is found, the variable will not be
       replaced.

       <b>VarAttr</b> <b>=&gt;</b> <b>'attr_name'</b> <u>#</u> <u>in</u> <u>-</u> <u>handy</u>

       In addition to the variables defined using "Variables", this option allows variables to be defined in
       the XML.  A variable definition consists of an element with an attribute called 'attr_name' (the
       value of the "VarAttr" option).  The value of the attribute will be used as the variable name and the
       text content of the element will be used as the value.  A variable defined in this way will override
       a variable defined using the "Variables" option.  For example:

         XMLin( '&lt;opt&gt;
                   &lt;dir name="prefix"&gt;/usr/local/apache&lt;/dir&gt;
                   &lt;dir name="exec_prefix"&gt;${prefix}&lt;/dir&gt;
                   &lt;dir name="bindir"&gt;${exec_prefix}/bin&lt;/dir&gt;
                 &lt;/opt&gt;',
                VarAttr =&gt; 'name', ContentKey =&gt; '-content'
               );

       produces the following data structure:

         {
           dir =&gt; {
                    prefix      =&gt; '/usr/local/apache',
                    exec_prefix =&gt; '/usr/local/apache',
                    bindir      =&gt; '/usr/local/apache/bin',
                  }
         }

       <b>XMLDecl</b> <b>=&gt;</b> <b>1</b>  <b>or</b>  <b>XMLDecl</b> <b>=&gt;</b> <b>'string'</b>  <u>#</u> <u>out</u> <u>-</u> <u>handy</u>

       If you want the output from "XMLout()" to start with the optional XML declaration, simply set the
       option to '1'.  The default XML declaration is:

               &lt;?xml version='1.0' standalone='yes'?&gt;

       If you want some other string (for example to declare an encoding value), set the value of this
       option to the complete string you require.

<b>OPTIONAL</b> <b>OO</b> <b>INTERFACE</b>
       The procedural interface is both simple and convenient however there are a couple of reasons why you
       might prefer to use the object oriented (OO) interface:

          to define a set of default values which should be used on all subsequent calls to "XMLin()" or
           "XMLout()"

          to override methods in <b>XML::Simple</b> to provide customised behaviour

       The default values for the options described above are unlikely to suit everyone.  The OO interface
       allows you to effectively override <b>XML::Simple</b>'s defaults with your preferred values.  It works like
       this:

       First create an XML::Simple parser object with your preferred defaults:

         my $xs = new XML::Simple(ForceArray =&gt; 1, KeepRoot =&gt; 1);

       then call "XMLin()" or "XMLout()" as a method of that object:

         my $ref = $xs-&gt;XMLin($xml);
         my $xml = $xs-&gt;XMLout($ref);

       You can also specify options when you make the method calls and these values will be merged with the
       values specified when the object was created.  Values specified in a method call take precedence.

       Overriding methods is a more advanced topic but might be useful if for example you wished to provide
       an alternative routine for escaping character data (the escape_value method) or for building the
       initial parse tree (the build_tree method).

       Note: when called as methods, the "XMLin()" and "XMLout()" routines may be called as "xml_in()" or
       "xml_out()".  The method names are aliased so the only difference is the aesthetics.

<b>STRICT</b> <b>MODE</b>
       If you import the <b>XML::Simple</b> routines like this:

         use XML::Simple qw(:strict);

       the following common mistakes will be detected and treated as fatal errors

          Failing to explicitly set the "KeyAttr" option - if you can't be bothered reading about this
           option, turn it off with: KeyAttr =&gt; [ ]

          Failing to explicitly set the "ForceArray" option - if you can't be bothered reading about this
           option, set it to the safest mode with: ForceArray =&gt; 1

          Setting ForceArray to an array, but failing to list all the elements from the KeyAttr hash.

          Data error - KeyAttr is set to say { part =&gt; 'partnum' } but the XML contains one or more &lt;part&gt;
           elements without a 'partnum' attribute (or nested element).  Note: if strict mode is not set but
           -w is, this condition triggers a warning.

          Data error - as above, but value of key attribute (eg: partnum) is not a scalar string (due to
           nested elements etc).  This will also trigger a warning if strict mode is not enabled.

<b>SAX</b> <b>SUPPORT</b>
       From version 1.08_01, <b>XML::Simple</b> includes support for SAX (the Simple API for XML) - specifically
       SAX2.

       In a typical SAX application, an XML parser (or SAX 'driver') module generates SAX events (start of
       element, character data, end of element, etc) as it parses an XML document and a 'handler' module
       processes the events to extract the required data.  This simple model allows for some interesting and
       powerful possibilities:

          Applications written to the SAX API can extract data from huge XML documents without the memory
           overheads of a DOM or tree API.

          The SAX API allows for plug and play interchange of parser modules without having to change your
           code to fit a new module's API.  A number of SAX parsers are available with capabilities ranging
           from extreme portability to blazing performance.

          A SAX 'filter' module can implement both a handler interface for receiving data and a generator
           interface for passing modified data on to a downstream handler.  Filters can be chained together
           in 'pipelines'.

          One filter module might split a data stream to direct data to two or more downstream handlers.

          Generating SAX events is not the exclusive preserve of XML parsing modules.  For example, a
           module might extract data from a relational database using DBI and pass it on to a SAX pipeline
           for filtering and formatting.

       <b>XML::Simple</b> can operate at either end of a SAX pipeline.  For example, you can take a data structure
       in the form of a hashref and pass it into a SAX pipeline using the 'Handler' option on "XMLout()":

         use XML::Simple;
         use Some::SAX::Filter;
         use XML::SAX::Writer;

         my $ref = {
                      ....   # your data here
                   };

         my $writer = XML::SAX::Writer-&gt;new();
         my $filter = Some::SAX::Filter-&gt;new(Handler =&gt; $writer);
         my $simple = XML::Simple-&gt;new(Handler =&gt; $filter);
         $simple-&gt;XMLout($ref);

       You can also put <b>XML::Simple</b> at the opposite end of the pipeline to take advantage of the simple
       'tree' data structure once the relevant data has been isolated through filtering:

         use XML::SAX;
         use Some::SAX::Filter;
         use XML::Simple;

         my $simple = XML::Simple-&gt;new(ForceArray =&gt; 1, KeyAttr =&gt; ['partnum']);
         my $filter = Some::SAX::Filter-&gt;new(Handler =&gt; $simple);
         my $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $filter);

         my $ref = $parser-&gt;parse_uri('some_huge_file.xml');

         print $ref-&gt;{part}-&gt;{'555-1234'};

       You can build a filter by using an XML::Simple object as a handler and setting its DataHandler option
       to point to a routine which takes the resulting tree, modifies it and sends it off as SAX events to a
       downstream handler:

         my $writer = XML::SAX::Writer-&gt;new();
         my $filter = XML::Simple-&gt;new(
                        DataHandler =&gt; sub {
                                         my $simple = shift;
                                         my $data = shift;

                                         # Modify $data here

                                         $simple-&gt;XMLout($data, Handler =&gt; $writer);
                                       }
                      );
         my $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $filter);

         $parser-&gt;parse_uri($filename);

       <u>Note:</u> <u>In</u> <u>this</u> <u>last</u> <u>example,</u> <u>the</u> <u>'Handler'</u> <u>option</u> <u>was</u> <u>specified</u> <u>in</u> <u>the</u> <u>call</u> <u>to</u> <u>"XMLout()"</u> <u>but</u> <u>it</u> <u>could</u>
       <u>also</u> <u>have</u> <u>been</u> <u>specified</u> <u>in</u> <u>the</u> <u>constructor</u>.

<b>ENVIRONMENT</b>
       If you don't care which parser module <b>XML::Simple</b> uses then skip this section entirely (it looks more
       complicated than it really is).

       <b>XML::Simple</b> will default to using a <b>SAX</b> parser if one is available or <b>XML::Parser</b> if SAX is not
       available.

       You can dictate which parser module is used by setting either the environment variable
       'XML_SIMPLE_PREFERRED_PARSER' or the package variable $XML::Simple::PREFERRED_PARSER to contain the
       module name.  The following rules are used:

          The package variable takes precedence over the environment variable if both are defined.  To
           force <b>XML::Simple</b> to ignore the environment settings and use its default rules, you can set the
           package variable to an empty string.

          If the 'preferred parser' is set to the string 'XML::Parser', then XML::Parser will be used (or
           "XMLin()" will die if XML::Parser is not installed).

          If the 'preferred parser' is set to some other value, then it is assumed to be the name of a SAX
           parser module and is passed to XML::SAX::ParserFactory.  If XML::SAX is not installed, or the
           requested parser module is not installed, then "XMLin()" will die.

          If the 'preferred parser' is not defined at all (the normal default state), an attempt will be
           made to load XML::SAX.  If XML::SAX is installed, then a parser module will be selected according
           to XML::SAX::ParserFactory's normal rules (which typically means the last SAX parser installed).

          if the 'preferred parser' is not defined and <b>XML::SAX</b> is not installed, then <b>XML::Parser</b> will be
           used.  "XMLin()" will die if XML::Parser is not installed.

       Note: The <b>XML::SAX</b> distribution includes an XML parser written entirely in Perl.  It is very portable
       but it is not very fast.  You should consider installing XML::LibXML or XML::SAX::Expat if they are
       available for your platform.

<b>ERROR</b> <b>HANDLING</b>
       The XML standard is very clear on the issue of non-compliant documents.  An error in parsing any
       single element (for example a missing end tag) must cause the whole document to be rejected.
       <b>XML::Simple</b> will die with an appropriate message if it encounters a parsing error.

       If dying is not appropriate for your application, you should arrange to call "XMLin()" in an eval
       block and look for errors in $@.  eg:

           my $config = eval { XMLin() };
           PopUpMessage($@) if($@);

       Note, there is a common misconception that use of <b>eval</b> will significantly slow down a script.  While
       that may be true when the code being eval'd is in a string, it is not true of code like the sample
       above.

<b>EXAMPLES</b>
       When "XMLin()" reads the following very simple piece of XML:

           &lt;opt username="testuser" password="frodo"&gt;&lt;/opt&gt;

       it returns the following data structure:

           {
             'username' =&gt; 'testuser',
             'password' =&gt; 'frodo'
           }

       The identical result could have been produced with this alternative XML:

           &lt;opt username="testuser" password="frodo" /&gt;

       Or this (although see 'ForceArray' option for variations):

           &lt;opt&gt;
             &lt;username&gt;testuser&lt;/username&gt;
             &lt;password&gt;frodo&lt;/password&gt;
           &lt;/opt&gt;

       Repeated nested elements are represented as anonymous arrays:

           &lt;opt&gt;
             &lt;person firstname="Joe" lastname="Smith"&gt;
               &lt;email&gt;joe@smith.com&lt;/email&gt;
               &lt;email&gt;jsmith@yahoo.com&lt;/email&gt;
             &lt;/person&gt;
             &lt;person firstname="Bob" lastname="Smith"&gt;
               &lt;email&gt;bob@smith.com&lt;/email&gt;
             &lt;/person&gt;
           &lt;/opt&gt;

           {
             'person' =&gt; [
                           {
                             'email' =&gt; [
                                          'joe@smith.com',
                                          'jsmith@yahoo.com'
                                        ],
                             'firstname' =&gt; 'Joe',
                             'lastname' =&gt; 'Smith'
                           },
                           {
                             'email' =&gt; 'bob@smith.com',
                             'firstname' =&gt; 'Bob',
                             'lastname' =&gt; 'Smith'
                           }
                         ]
           }

       Nested elements with a recognised key attribute are transformed (folded) from an array into a hash
       keyed on the value of that attribute (see the "KeyAttr" option):

           &lt;opt&gt;
             &lt;person key="jsmith" firstname="Joe" lastname="Smith" /&gt;
             &lt;person key="tsmith" firstname="Tom" lastname="Smith" /&gt;
             &lt;person key="jbloggs" firstname="Joe" lastname="Bloggs" /&gt;
           &lt;/opt&gt;

           {
             'person' =&gt; {
                           'jbloggs' =&gt; {
                                          'firstname' =&gt; 'Joe',
                                          'lastname' =&gt; 'Bloggs'
                                        },
                           'tsmith' =&gt; {
                                         'firstname' =&gt; 'Tom',
                                         'lastname' =&gt; 'Smith'
                                       },
                           'jsmith' =&gt; {
                                         'firstname' =&gt; 'Joe',
                                         'lastname' =&gt; 'Smith'
                                       }
                         }
           }

       The &lt;anon&gt; tag can be used to form anonymous arrays:

           &lt;opt&gt;
             &lt;head&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;anon&gt;Col 3&lt;/anon&gt;&lt;/head&gt;
             &lt;data&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;anon&gt;R1C3&lt;/anon&gt;&lt;/data&gt;
             &lt;data&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;anon&gt;R2C3&lt;/anon&gt;&lt;/data&gt;
             &lt;data&gt;&lt;anon&gt;R3C1&lt;/anon&gt;&lt;anon&gt;R3C2&lt;/anon&gt;&lt;anon&gt;R3C3&lt;/anon&gt;&lt;/data&gt;
           &lt;/opt&gt;

           {
             'head' =&gt; [
                         [ 'Col 1', 'Col 2', 'Col 3' ]
                       ],
             'data' =&gt; [
                         [ 'R1C1', 'R1C2', 'R1C3' ],
                         [ 'R2C1', 'R2C2', 'R2C3' ],
                         [ 'R3C1', 'R3C2', 'R3C3' ]
                       ]
           }

       Anonymous arrays can be nested to arbirtrary levels and as a special case, if the surrounding tags
       for an XML document contain only an anonymous array the arrayref will be returned directly rather
       than the usual hashref:

           &lt;opt&gt;
             &lt;anon&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;/anon&gt;
             &lt;anon&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;/anon&gt;
             &lt;anon&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;/anon&gt;
           &lt;/opt&gt;

           [
             [ 'Col 1', 'Col 2' ],
             [ 'R1C1', 'R1C2' ],
             [ 'R2C1', 'R2C2' ]
           ]

       Elements which only contain text content will simply be represented as a scalar.  Where an element
       has both attributes and text content, the element will be represented as a hashref with the text
       content in the 'content' key (see the "ContentKey" option):

         &lt;opt&gt;
           &lt;one&gt;first&lt;/one&gt;
           &lt;two attr="value"&gt;second&lt;/two&gt;
         &lt;/opt&gt;

         {
           'one' =&gt; 'first',
           'two' =&gt; { 'attr' =&gt; 'value', 'content' =&gt; 'second' }
         }

       Mixed content (elements which contain both text content and nested elements) will be not be
       represented in a useful way - element order and significant whitespace will be lost.  If you need to
       work with mixed content, then XML::Simple is not the right tool for your job - check out the next
       section.

<b>WHERE</b> <b>TO</b> <b>FROM</b> <b>HERE?</b>
       <b>XML::Simple</b> is able to present a simple API because it makes some assumptions on your behalf.  These
       include:

          You're not interested in text content consisting only of whitespace

          You don't mind that when things get slurped into a hash the order is lost

          You don't want fine-grained control of the formatting of generated XML

          You would never use a hash key that was not a legal XML element name

          You don't need help converting between different encodings

       In a serious XML project, you'll probably outgrow these assumptions fairly quickly.  This section of
       the document used to offer some advice on chosing a more powerful option.  That advice has now grown
       into the 'Perl-XML FAQ' document which you can find at: &lt;<a href="http://perl-xml.sourceforge.net/faq/">http://perl-xml.sourceforge.net/faq/</a>

       The advice in the FAQ boils down to a quick explanation of tree versus event based parsers and then
       recommends:

       For event based parsing, use SAX (do not set out to write any new code for XML::Parser's handler API
       - it is obselete).

       For tree-based parsing, you could choose between the 'Perlish' approach of XML::Twig and more
       standards based DOM implementations - preferably one with XPath support.

<b>SEE</b> <b>ALSO</b>
       <b>XML::Simple</b> requires either XML::Parser or XML::SAX.

       To generate documents with namespaces, XML::NamespaceSupport is required.

       The optional caching functions require Storable.

       Answers to Frequently Asked Questions about XML::Simple are bundled with this distribution as:
       XML::Simple::FAQ

<b>COPYRIGHT</b>
       Copyright 1999-2004 Grant McLean &lt;grantm@cpan.org&gt;

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.



perl v5.8.8                                      2005-01-28                                   XML::Simple(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/XML__Simple.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/XML__Simple.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/XML__Simple.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
