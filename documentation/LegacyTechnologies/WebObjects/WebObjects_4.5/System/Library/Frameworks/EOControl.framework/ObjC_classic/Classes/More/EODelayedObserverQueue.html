<HTML>		<HEAD>		<TITLE>					</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../webobjects.html" target="_top">WebObjects 4.5 Documentation</a> <b>&gt;</b>EOControl Reference</font><br><br><!--end of path --><a href="../../EOControlTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> <h1><FONT COLOR="#000066"><a name="//apple_ref/occ/cl/EODelayedObserverQueue">EODelayedObserverQueue</a></FONT></h1><br><br><a name = "BABDFBBD"><h2>Enqueuing a Delayed Observer</h2></a><p>The  <a frame= "conv" href="../../Classes/EODelayedObserverQueue.html#//apple_ref/occ/instm/EODelayedObserverQueue/enqueueObserver:">enqueueObserver:</a> method records anEODelayedObserver for later change notification. However, enqueuingis usually performed automatically by an EODelayedObserver in its  <a frame= "conv" href="../../Classes/EODelayedObserver.html#//apple_ref/occ/instm/EODelayedObserver/objectWillChange:">objectWillChange:</a> method.Hence, it's typically enough that an object being observed invoke  <a frame= "conv" href="../../Protocols/EOEnterpriseObject.html#//apple_ref/occ/intfm/EOEnterpriseObject/willChange">willChange</a> as needed. For example,in Java Client and Application Kit applications, an EODisplayGroup(EOInterface) does this (among many other things) on receiving an  <a frame= "conv" href="../../Classes/EOEditingContext.html#BIDCFHHF">EOObjectsChangedInEditingContextNotification</a><b> </b>fromits EOEditingContext.</p><p>Although you can create individual EODelayedObserverQueues using <b>alloc</b> and  <a frame= "conv" href="../../Classes/EODelayedObserverQueue.html#//apple_ref/occ/instm/EODelayedObserverQueue/init">init</a>, you typically use the singleinstance provided by the class method  <a frame= "conv" href="../../Classes/EODelayedObserverQueue.html#//apple_ref/occ/clm/EODelayedObserverQueue/defaultObserverQueue">defaultObserverQueue</a>.Using separate queues bypasses the prioritization mechanism, whichmay cause problems between the objects using the separate queues.If you do use separate queues, your EODelayedObserver subclassesshould record a designated EODelayedObserverQueue that they alwaysuse, and implement  <a frame= "conv" href="../../Classes/EODelayedObserver.html#//apple_ref/occ/instm/EODelayedObserver/observerQueue">observerQueue</a> to return that object.</p><p>If you need to remove an enqueued observer, you can do sousing the  <a frame= "conv" href="../../Classes/EODelayedObserverQueue.html#//apple_ref/occ/instm/EODelayedObserverQueue/dequeueObserver:">dequeueObserver:</a> method. EODelayedObserveralso defines the  <a frame= "conv" href="../../Classes/EODelayedObserver.html#//apple_ref/occ/instm/EODelayedObserver/discardPendingNotification">discardPendingNotification</a> method,which removes the receiver from its designated queue. This is usefulin an object's implementation of <b>dealloc</b>,for example, to prevent a change notification from being sent toit.</p><br><a name = "BABDHJBI"><h2>Change Notification</h2></a><p>The actual process of change notification is initiated bythe  <a frame= "conv" href="../../Classes/EODelayedObserverQueue.html#//apple_ref/occ/instm/EODelayedObserverQueue/enqueueObserver:">enqueueObserver:</a> messages that line observersup to receive notifications. Regardless of how many times <b>enqueueObserver:</b> isinvoked for a particular observer, that observer is only put inthe queue once. The first observer enqueued during the run loopalso triggers the EODelayedObserverQueue to set up a delayed invocationof  <a frame= "conv" href="../../Classes/EODelayedObserverQueue.html#//apple_ref/occ/instm/EODelayedObserverQueue/notifyObserversUpToPriority:">notifyObserversUpToPriority:</a>,which causes it to receive that message at the end of the run loop. EODelayedObserversets up this delayed invocation in NSDefaultRunLoopMode, but youcan change the mode or add additional modes in which delayed invocationoccurs using  <a frame= "conv" href="../../Classes/EODelayedObserverQueue.html#//apple_ref/occ/instm/EODelayedObserverQueue/setRunLoopModes:">setRunLoopModes:</a>.</p><p> <a frame= "conv" href="../../Classes/EODelayedObserverQueue.html#//apple_ref/occ/instm/EODelayedObserverQueue/notifyObserversUpToPriority:">notifyObserversUpToPriority:</a> cyclesthrough the queue of EODelayedObservers in priority order, from  <a frame= "conv" href="../../Classes/EODelayedObserver.html#CEGDEGFB">EOObserverPriorityFirst</a> to the prioritygiven, sending each observer a  <a frame= "conv" href="../../Classes/EODelayedObserver.html#//apple_ref/occ/instm/EODelayedObserver/subjectChanged">subjectChanged</a> message. Each time,it returns to the earliest priority (rather than continuing throughthe queue) in case the message resulted in another EODelayedObserverwith a earlier priority being enqueued. This guarantees an optimaldelivery of change notifications.</p><br><a name = "BABCJAEA"><h2>Observer Proxies</h2></a><p>It may not always be possible for a custom observer classto inherit from EODelayedObserver. To aid such objects in participatingin delayed change notifications, the Framework defines a subclassof EODelayedObserver, EOObserverProxy, which implements its  <a frame= "conv" href="../../Classes/EODelayedObserver.html#//apple_ref/occ/instm/EODelayedObserver/subjectChanged">subjectChanged</a> method to invoke an actionmethod of your custom object. You create an EOObserverProxy, usingthe  <a frame= "conv" href="../../Classes/EOObserverProxy.html#//apple_ref/occ/instm/EOObserverProxy/initWithTarget:action:priority:">initWithTarget:action:priority:</a> method,which records the "real" observer, the action method to invoke,and the priority at which the EOObserverProxy should be enqueued.Then, instead of registering the custom object as an observer ofobjects, you register the proxy (using EOObserverCenter's  <a frame= "conv" href="../../Classes/EOObserverCenter.html#//apple_ref/occ/clm/EOObserverCenter/addObserver:forObject:">addObserver:forObject:</a><b>)</b>.When the proxy receives an  <a frame= "conv" href="../../Classes/EODelayedObserver.html#//apple_ref/occ/instm/EODelayedObserver/objectWillChange:">objectWillChange:</a> message,it enqueues itself for delayed change notification, receives the <b>subjectChanged</b> messagefrom the EODelayedObserverQueue, and then sends the action messageto the "real" observer.</p><br><a href="../../EOControlTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> </BODY></HTML>