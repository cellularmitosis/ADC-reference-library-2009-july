<html><head><title>Mac OS X
 Manual Page For MIME::Parser(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/MIME::Parser" title="Mac OS X
 Manual Page for MIME::Parser(3pm)"><a name="//apple_ref/doc/man/3/MIME::Parser" title="Mac OS X
 Manual Page for MIME::Parser(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/MIME::Parser"; name=MIME::Parser(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
MIME::Parser(3)                      User Contributed Perl Documentation                     MIME::Parser(3)



<b>NAME</b>
       MIME::Parser - experimental class for parsing MIME streams

<b>SYNOPSIS</b>
       Before reading further, you should see MIME::Tools to make sure that you understand where this module
       fits into the grand scheme of things.  Go on, do it now.  I'll wait.

       Ready?  Ok...

       <b>Basic</b> <b>usage</b> <b>examples</b>

           ### Create a new parser object:
           my $parser = new MIME::Parser;

           ### Tell it where to put things:
           $parser-&gt;output_under("/tmp");

           ### Parse an input filehandle:
           $entity = $parser-&gt;parse(\*STDIN);

           ### Congratulations: you now have a (possibly multipart) MIME entity!
           $entity-&gt;dump_skeleton;          # for debugging

       <b>Examples</b> <b>of</b> <b>input</b>

           ### Parse from filehandles:
           $entity = $parser-&gt;parse(\*STDIN);
           $entity = $parser-&gt;parse(IO::File-&gt;new("some command|");

           ### Parse from any object that supports getline() and read():
           $entity = $parser-&gt;parse($myHandle);

           ### Parse an in-core MIME message:
           $entity = $parser-&gt;parse_data($message);

           ### Parse an MIME message in a file:
           $entity = $parser-&gt;parse_open("/some/file.msg");

           ### Parse an MIME message out of a pipeline:
           $entity = $parser-&gt;parse_open("gunzip - &lt; file.msg.gz |");

           ### Parse already-split input (as "deliver" would give it to you):
           $entity = $parser-&gt;parse_two("msg.head", "msg.body");

       <b>Examples</b> <b>of</b> <b>output</b> <b>control</b>

           ### Keep parsed message bodies in core (default outputs to disk):
           $parser-&gt;output_to_core(1);

           ### Output each message body to a one-per-message directory:
           $parser-&gt;output_under("/tmp");

           ### Output each message body to the same directory:
           $parser-&gt;output_dir("/tmp");

           ### Change how nameless message-component files are named:
           $parser-&gt;output_prefix("msg");

       <b>Examples</b> <b>of</b> <b>error</b> <b>recovery</b>

           ### Normal mechanism:
           eval { $entity = $parser-&gt;parse(\*STDIN) };
           if ($@) {
               $results  = $parser-&gt;results;
               $decapitated = $parser-&gt;last_head;  ### get last top-level head
           }

           ### Ultra-tolerant mechanism:
           $parser-&gt;ignore_errors(1);
           $entity = eval { $parser-&gt;parse(\*STDIN) };
           $error = ($@ || $parser-&gt;last_error);

           ### Cleanup all files created by the parse:
           eval { $entity = $parser-&gt;parse(\*STDIN) };
           ...
           $parser-&gt;filer-&gt;purge;

       <b>Examples</b> <b>of</b> <b>parser</b> <b>options</b>

           ### Automatically attempt to RFC-1522-decode the MIME headers?
           $parser-&gt;decode_headers(1);             ### default is false

           ### Parse contained "message/rfc822" objects as nested MIME streams?
           $parser-&gt;extract_nested_messages(0);    ### default is true

           ### Look for uuencode in "text" messages, and extract it?
           $parser-&gt;extract_uuencode(1);           ### default is false

           ### Should we forgive normally-fatal errors?
           $parser-&gt;ignore_errors(0);              ### default is true

       <b>Miscellaneous</b> <b>examples</b>

           ### Convert a Mail::Internet object to a MIME::Entity:
           @lines = (@{$mail-&gt;header}, "\n", @{$mail-&gt;body});
           $entity = $parser-&gt;parse_data(\@lines);

<b>DESCRIPTION</b>
       You can inherit from this class to create your own subclasses that parse MIME streams into
       MIME::Entity objects.

<b>PUBLIC</b> <b>INTERFACE</b>
       <b>Construction</b>


       new ARGS...
           <u>Class</u> <u>method.</u>  Create a new parser object.  Once you do this, you can then set up various
           parameters before doing the actual parsing.  For example:

               my $parser = new MIME::Parser;
               $parser-&gt;output_dir("/tmp");
               $parser-&gt;output_prefix("msg1");
               my $entity = $parser-&gt;parse(\*STDIN);

           Any arguments are passed into "init()".  Don't override this in your subclasses; override <u>init()</u>
           instead.

       init ARGS...
           <u>Instance</u> <u>method.</u>  Initiallize a new MIME::Parser object.  This is automatically sent to a new
           object; you may want to override it.  If you override this, be sure to invoke the inherited
           method.

       init_parse
           <u>Instance</u> <u>method.</u>  Invoked automatically whenever one of the top-level <u>parse()</u> methods is called,
           to reset the parser to a "ready" state.

       <b>Altering</b> <b>how</b> <b>messages</b> <b>are</b> <b>parsed</b>


       decode_headers [YESNO]
           <u>Instance</u> <u>method.</u>  Controls whether the parser will attempt to decode all the MIME headers (as per
           RFC-1522) the moment it sees them.  <b>This</b> <b>is</b> <b>not</b> <b>advisable</b> <b>for</b> <b>two</b> <b>very</b> <b>important</b> <b>reasons:</b>

              <b>It</b> <b>screws</b> <b>up</b> <b>the</b> <b>extraction</b> <b>of</b> <b>information</b> <b>from</b> <b>MIME</b> <b>fields.</b>  If you fully decode the headers
               into bytes, you can inadvertently transform a parseable MIME header like this:

                   Content-type: text/plain; filename="=?ISO-8859-1?Q?Hi=22Ho?="

               into unparseable gobbledygook; in this case:

                   Content-type: text/plain; filename="Hi"Ho"

              <b>It</b> <b>is</b> <b>information-lossy.</b>  An encoded string which contains both Latin-1 and Cyrillic
               characters will be turned into a binary mishmosh which simply can't be rendered.

           <b>History.</b>  This method was once the only out-of-the-box way to deal with attachments whose
           filenames had non-ASCII characters.  However, since MIME-tools 5.4xx this is no longer necessary.

           <b>Parameters.</b>  If YESNO is true, decoding is done.  However, you will get a warning unless you use
           one of the special "true" values:

              "I_NEED_TO_FIX_THIS"
                     Just shut up and do it.  Not recommended.
                     Provided only for those who need to keep old scripts functioning.

              "I_KNOW_WHAT_I_AM_DOING"
                     Just shut up and do it.  Not recommended.
                     Provided for those who REALLY know what they are doing.

           If YESNO is false (the default), no attempt at decoding will be done.  With no argument, just
           returns the current setting.  <b>Remember:</b> you can always decode the headers <u>after</u> the parsing has
           completed (see <u>MIME::Head::decode()</u>), or decode the words on demand (see MIME::Words).

       extract_nested_messages OPTION
           <u>Instance</u> <u>method.</u>  Some MIME messages will contain a part of type "message/rfc822"
           ,"message/partial" or "message/external-body": literally, the text of an embedded
           mail/news/whatever message.  This option controls whether (and how) we parse that embedded
           message.

           If the OPTION is false, we treat such a message just as if it were a "text/plain" document,
           without attempting to decode its contents.

           If the OPTION is true (the default), the body of the "message/rfc822" or "message/partial" part
           is parsed by this parser, creating an entity object.  What happens then is determined by the
           actual OPTION:

           NEST or 1
               The default setting.  The contained message becomes the sole "part" of the "message/rfc822"
               entity (as if the containing message were a special kind of "multipart" message).  You can
               recover the sub-entity by invoking the <u>parts()</u> method on the "message/rfc822" entity.

           REPLACE
               The contained message replaces the "message/rfc822" entity, as though the "message/rfc822"
               "container" never existed.

               <b>Warning:</b> notice that, with this option, all the header information in the "message/rfc822"
               header is lost.  This might seriously bother you if you're dealing with a top-level message,
               and you've just lost the sender's address and the subject line.  ":-/".

           <u>Thanks</u> <u>to</u> <u>Andreas</u> <u>Koenig</u> <u>for</u> <u>suggesting</u> <u>this</u> <u>method.</u>

       extract_uuencode [YESNO]
           <u>Instance</u> <u>method.</u>  If set true, then whenever we are confronted with a message whose effective
           content-type is "text/plain" and whose encoding is 7bit/8bit/binary, we scan the encoded body to
           see if it contains uuencoded data (generally given away by a "begin XXX" line).

           If it does, we explode the uuencoded message into a multipart, where the text before the first
           "begin XXX" becomes the first part, and all "begin...end" sections following become the
           subsequent parts.  The filename (if given) is accessible through the normal means.

       ignore_errors [YESNO]
           <u>Instance</u> <u>method.</u>  Controls whether the parser will attempt to ignore normally-fatal errors,
           treating them as warnings and continuing with the parse.

           If YESNO is true (the default), many syntax errors are tolerated.  If YESNO is false, fatal
           errors throw exceptions.  With no argument, just returns the current setting.

       decode_bodies [YESNO]
           <u>Instance</u> <u>method.</u>  Controls whether the parser should decode entity bodies or not.  If this is set
           to a false value (default is true), all entity bodies will be kept as-is in the original content-<font color="#ffffff" class="whiteout">transfer&nbsp;contenttransfer</font>
           transfer encoding.

           To prevent double encoding on the output side MIME::Body-&gt;is_encoded is set, which tells
           MIME::Body not to encode the data again, if encoded data was requested. This is in particular
           useful, when it's important that the content <b>must</b> <b>not</b> be modified, e.g. if you want to calculate
           OpenPGP signatures from it.

           <b>WARNING</b>: the semantics change significantly if you parse MIME messages with this option set,
           because MIME::Entity resp. MIME::Body *always* see encoded data now, while the default behaviour
           is working with *decoded* data (and encoding it only if you request it).  You need to decode the
           data yourself, if you want to have it decoded.

           So use this option only if you exactly know, what you're doing, and that you're sure, that you
           really need it.

       <b>Parsing</b> <b>an</b> <b>input</b> <b>source</b>


       parse_data DATA
           <u>Instance</u> <u>method.</u>  Parse a MIME message that's already in core.  You may supply the DATA in any of
           a number of ways...

              <b>A</b> <b>scalar</b> which holds the message.

              <b>A</b> <b>ref</b> <b>to</b> <b>a</b> <b>scalar</b> which holds the message.  This is an efficiency hack.

              <b>A</b> <b>ref</b> <b>to</b> <b>an</b> <b>array</b> <b>of</b> <b>scalars.</b>  They are treated as a stream which (conceptually) consists of
               simply concatenating the scalars.

           Returns the parsed MIME::Entity on success.

       parse INSTREAM
           <u>Instance</u> <u>method.</u>  Takes a MIME-stream and splits it into its component entities.

           The INSTREAM can be given as a readable FileHandle, an IO::File, a globref filehandle (like
           "\*STDIN"), or as <u>any</u> blessed object conforming to the IO:: interface (which minimally implements
           <u>getline()</u> and <u>read()</u>).

           Returns the parsed MIME::Entity on success.  Throws exception on failure.  If the message
           contained too many parts (as set by <u>max</u><b>_</b><u>parts</u>), returns undef.

       parse_open EXPR
           <u>Instance</u> <u>method.</u>  Convenience front-end onto "parse()".  Simply give this method any expression
           that may be sent as the second argument to <u>open()</u> to open a filehandle for reading.

           Returns the parsed MIME::Entity on success.  Throws exception on failure.

       parse_two HEADFILE, BODYFILE
           <u>Instance</u> <u>method.</u>  Convenience front-end onto "parse_open()", intended for programs running under
           mail-handlers like <b>deliver</b>, which splits the incoming mail message into a header file and a body
           file.  Simply give this method the paths to the respective files.

           <b>Warning:</b> it is assumed that, once the files are cat'ed together, there will be a blank line
           separating the head part and the body part.

           <b>Warning:</b> new implementation slurps files into line array for portability, instead of using 'cat'.
           May be an issue if your messages are large.

           Returns the parsed MIME::Entity on success.  Throws exception on failure.

       <b>Specifying</b> <b>output</b> <b>destination</b>

       <b>Warning:</b> in 5.212 and before, this was done by methods of MIME::Parser.  However, since many users
       have requested fine-tuned control over how this is done, the logic has been split off from the parser
       into its own class, MIME::Parser::Filer Every MIME::Parser maintains an instance of a
       MIME::Parser::Filer subclass to manage disk output (see MIME::Parser::Filer for details.)

       The benefit to this is that the MIME::Parser code won't be confounded with a lot of garbage related
       to disk output.  The drawback is that the way you override the default behavior will change.

       For now, all the normal public-interface methods are still provided, but many are only stubs which
       create or delegate to the underlying MIME::Parser::Filer object.

       filer [FILER]
           <u>Instance</u> <u>method.</u>  Get/set the FILER object used to manage the output of files to disk.  This will
           be some subclass of MIME::Parser::Filer.

       output_dir DIRECTORY
           <u>Instance</u> <u>method.</u>  Causes messages to be filed directly into the given DIRECTORY.  It does this by
           setting the underlying <u>filer()</u> to a new instance of MIME::Parser::FileInto, and passing the
           arguments into that class' <u>new()</u> method.

           <b>Note:</b> Since this method replaces the underlying filer, you must invoke it <u>before</u> doing changing
           any attributes of the filer, like the output prefix; otherwise those changes will be lost.

       output_under BASEDIR, OPTS...
           <u>Instance</u> <u>method.</u>  Causes messages to be filed directly into subdirectories of the given BASEDIR,
           one subdirectory per message.  It does this by setting the underlying <u>filer()</u> to a new instance
           of MIME::Parser::FileUnder, and passing the arguments into that class' <u>new()</u> method.

           <b>Note:</b> Since this method replaces the underlying filer, you must invoke it <u>before</u> doing changing
           any attributes of the filer, like the output prefix; otherwise those changes will be lost.

       output_path HEAD
           <u>Instance</u> <u>method,</u> <u>DEPRECATED.</u>  Given a MIME head for a file to be extracted, come up with a good
           output pathname for the extracted file.  Identical to the preferred form:

                $parser-&gt;filer-&gt;output_path(...args...);

           We just delegate this to the underlying <u>filer()</u> object.

       output_prefix [PREFIX]
           <u>Instance</u> <u>method,</u> <u>DEPRECATED.</u>  Get/set the short string that all filenames for extracted body-<font color="#ffffff" class="whiteout">parts&nbsp;bodyparts</font>
           parts will begin with (assuming that there is no better "recommended filename").  Identical to
           the preferred form:

                $parser-&gt;filer-&gt;output_prefix(...args...);

           We just delegate this to the underlying <u>filer()</u> object.

       evil_filename NAME
           <u>Instance</u> <u>method,</u> <u>DEPRECATED.</u>  Identical to the preferred form:

                $parser-&gt;filer-&gt;evil_filename(...args...);

           We just delegate this to the underlying <u>filer()</u> object.

       max_parts NUM
           <u>Instance</u> <u>method.</u>  Limits the number of MIME parts we will parse.

           Normally, instances of this class parse a message to the bitter end.  Messages with many MIME
           parts can cause excessive memory consumption.  If you invoke this method, parsing will abort with
           a <u>die()</u> if a message contains more than NUM parts.

           If NUM is set to -1 (the default), then no maximum limit is enforced.

           With no argument, returns the current setting as an integer

       output_to_core YESNO
           <u>Instance</u> <u>method.</u>  Normally, instances of this class output all their decoded body data to disk
           files (via MIME::Body::File).  However, you can change this behaviour by invoking this method
           before parsing:

           If YESNO is false (the default), then all body data goes to disk files.

           If YESNO is true, then all body data goes to in-core data structures This is a little risky (what
           if someone emails you an MPEG or a tar file, hmmm?) but people seem to want this bit of noose-<font color="#ffffff" class="whiteout">shaped&nbsp;nooseshaped</font>
           shaped rope, so I'm providing it.  Note that setting this attribute true <u>does</u> <u>not</u> mean that
           parser-internal temporary files are avoided!  Use <u>tmp</u><b>_</b><u>to</u><b>_</b><u>core()</u> for that.

           With no argument, returns the current setting as a boolean.

       tmp_recycling [YESNO]
           <u>Instance</u> <u>method.</u>  Normally, tmpfiles are created when needed during parsing, and destroyed
           automatically when they go out of scope.  But for efficiency, you might prefer for your parser to
           attempt to rewind and reuse the same file until the parser itself is destroyed.

           If YESNO is true (the default), we allow recycling; tmpfiles persist until the parser itself is
           destroyed.  If YESNO is false, we do not allow recycling; tmpfiles persist only as long as they
           are needed during the parse.  With no argument, just returns the current setting.

       tmp_to_core [YESNO]
           <u>Instance</u> <u>method.</u>  Should <u>new</u><b>_</b><u>tmpfile()</u> create real temp files, or use fake in-core ones?
           Normally we allow the creation of temporary disk files, since this allows us to handle huge
           attachments even when core is limited.

           If YESNO is true, we implement <u>new</u><b>_</b><u>tmpfile()</u> via in-core handles.  If YESNO is false (the
           default), we use real tmpfiles.  With no argument, just returns the current setting.

       use_inner_files [YESNO]
           <u>Instance</u> <u>method.</u>  If you are parsing from a handle which supports <u>seek()</u> and <u>tell()</u>, then we can
           avoid tmpfiles completely by using IO::InnerFile, if so desired: basically, we simulate a
           temporary file via pointers to virtual start- and end-positions in the input stream.

           If YESNO is false (the default), then we will not use IO::InnerFile.  If YESNO is true, we use
           IO::InnerFile if we can.  With no argument, just returns the current setting.

           <b>Note:</b> inner files are slower than <u>real</u> tmpfiles, but possibly faster than <u>in-core</u> tmpfiles... so
           your choice for this option will probably depend on your choice for <u>tmp</u><b>_</b><u>to</u><b>_</b><u>core()</u> and the kind of
           input streams you are parsing.

       <b>Specifying</b> <b>classes</b> <b>to</b> <b>be</b> <b>instantiated</b>


       interface ROLE,[VALUE]
           <u>Instance</u> <u>method.</u>  During parsing, the parser normally creates instances of certain classes, like
           MIME::Entity.  However, you may want to create a parser subclass that uses your own experimental
           head, entity, etc. classes (for example, your "head" class may provide some additional MIME-<font color="#ffffff" class="whiteout">field-oriented&nbsp;MIMEfield-oriented</font>
           field-oriented methods).

           If so, then this is the method that your subclass should invoke during init.  Use it like this:

               package MyParser;
               @ISA = qw(MIME::Parser);
               ...
               sub init {
                   my $self = shift;
                   $self-&gt;SUPER::init(@_);        ### do my parent's init
                   $self-&gt;interface(ENTITY_CLASS =&gt; 'MIME::MyEntity');
                   $self-&gt;interface(HEAD_CLASS   =&gt; 'MIME::MyHead');
                   $self;                         ### return
               }

           With no VALUE, returns the VALUE currently associated with that ROLE.

       new_body_for HEAD
           <u>Instance</u> <u>method.</u>  Based on the HEAD of a part we are parsing, return a new body object (any
           desirable subclass of MIME::Body) for receiving that part's data.

           If you set the "output_to_core" option to false before parsing (the default), then we call
           "output_path()" and create a new MIME::Body::File on that filename.

           If you set the "output_to_core" option to true before parsing, then you get a MIME::Body::InCore
           instead.

           If you want the parser to do something else entirely, you can override this method in a subclass.

       new_tmpfile [RECYCLE]
           <u>Instance</u> <u>method.</u>  Return an IO handle to be used to hold temporary data during a parse.  The
           default uses the standard IO::File-&gt;<u>new</u><b>_</b><u>tmpfile()</u> method unless <u>tmp</u><b>_</b><u>to</u><b>_</b><u>core()</u> dictates otherwise,
           but you can override this.  You shouldn't need to.

           If you do override this, make certain that the object you return is set for <u>binmode()</u>, and is
           able to handle the following methods:

               read(BUF, NBYTES)
               getline()
               getlines()
               print(@ARGS)
               flush()
               seek(0, 0)

           Fatal exception if the stream could not be established.

           If RECYCLE is given, it is an object returned by a previous invocation of this method; to recycle
           it, this method must effectively rewind and truncate it, and return the same object.  If you
           don't want to support recycling, just ignore it and always return a new object.

       <b>Parse</b> <b>results</b> <b>and</b> <b>error</b> <b>recovery</b>


       last_error
           <u>Instance</u> <u>method.</u>  Return the error (if any) that we ignored in the last parse.

       last_head
           <u>Instance</u> <u>method.</u>  Return the top-level MIME header of the last stream we attempted to parse.
           This is useful for replying to people who sent us bad MIME messages.

               ### Parse an input stream:
               eval { $entity = $parser-&gt;parse(\*STDIN) };
               if (!$entity) {    ### parse failed!
                   my $decapitated = $parser-&gt;last_head;
                   ...
               }

       results
           <u>Instance</u> <u>method.</u>  Return an object containing lots of info from the last entity parsed.  This
           will be an instance of class MIME::Parser::Results.

<b>OPTIMIZING</b> <b>YOUR</b> <b>PARSER</b>
       <b>Maximizing</b> <b>speed</b>

       Optimum input mechanisms:

           parse()                    YES (if you give it a globref or a
                                           subclass of IO::File)
           parse_open()               YES
           parse_data()               NO  (see below)
           parse_two()                NO  (see below)

       Optimum settings:

           decode_headers()           *** (no real difference; 0 is slightly faster)
           extract_nested_messages()  0   (may be slightly faster, but in
                                           general you want it set to 1)
           output_to_core()           0   (will be MUCH faster)
           tmp_recycling()            1?  (probably, but should be investigated)
           tmp_to_core()              0   (will be MUCH faster)
           use_inner_files()          0   (if tmp_to_core() is 0;
                                           use 1 otherwise)

       <b>File</b> <b>I/O</b> <b>is</b> <b>much</b> <b>faster</b> <b>than</b> <b>in-core</b> <b>I/O.</b>  Although it <u>seems</u> like slurping a message into core and
       processing it in-core should be faster... it isn't.  Reason: Perl's filehandle-based I/O translates
       directly into native operating-system calls, whereas the in-core I/O is implemented in Perl.

       <b>Inner</b> <b>files</b> <b>are</b> <b>slower</b> <b>than</b> <b>real</b> <b>tmpfiles,</b> <b>but</b> <b>faster</b> <b>than</b> <b>in-core</b> <b>ones.</b>  If speed is your concern,
       that's why you should set use_inner_files(true) if you set tmp_to_core(true): so that we can bypass
       the slow in-core tmpfiles if the input stream permits.

       <b>Native</b> <b>I/O</b> <b>is</b> <b>much</b> <b>faster</b> <b>than</b> <b>object-oriented</b> <b>I/O.</b>  It's much faster to use &lt;$foo&gt; than
       $foo-&gt;getline.  For backwards compatibilty, this module must continue to use object-oriented I/O in
       most places, but if you use <u>parse()</u> with a "real" filehandle (string, globref, or subclass of
       IO::File) then MIME::Parser is able to perform some crucial optimizations.

       <b>The</b> <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>e</u></b><b>_</b><u></u><b><u>t</u></b><u></u><b><u>o</u></b><u></u><b><u>)</u></b> <b>call</b> <b>is</b> <b>very</b> <b>inefficient.</b>  Currently this is just a front-end onto <u>parse</u><b>_</b><u>data()</u>.  If
       your OS supports it, you're <u>far</u> better off doing something like:

           $parser-&gt;parse_open("/bin/cat msg.head msg.body |");

       <b>Minimizing</b> <b>memory</b>

       Optimum input mechanisms:

           parse()                    YES
           parse_open()               YES
           parse_data()               NO  (in-core I/O will burn core)
           parse_two()                NO  (in-core I/O will burn core)

       Optimum settings:

           decode_headers()           *** (no real difference)
           extract_nested_messages()  *** (no real difference)
           output_to_core()           0   (will use MUCH less memory)
           tmp_recycling()            0?  (promotes faster GC if
                                           tmp_to_core is 1)
           tmp_to_core()              0   (will use MUCH less memory)
           use_inner_files()          *** (no real difference, but set it to 1
                                           if you *must* have tmp_to_core set to 1,
                                           so that you avoid in-core tmpfiles)

       <b>Maximizing</b> <b>tolerance</b> <b>of</b> <b>bad</b> <b>MIME</b>

       Optimum input mechanisms:

           parse()                    *** (doesn't matter)
           parse_open()               *** (doesn't matter)
           parse_data()               *** (doesn't matter)
           parse_two()                *** (doesn't matter)

       Optimum settings:

           decode_headers()           0   (sidesteps problem of bad hdr encodings)
           extract_nested_messages()  0   (sidesteps problems of bad nested messages,
                                           but often you want it set to 1 anyway).
           output_to_core()           *** (doesn't matter)
           tmp_recycling()            *** (doesn't matter)
           tmp_to_core()              *** (doesn't matter)
           use_inner_files()          *** (doesn't matter)

       <b>Avoiding</b> <b>disk-based</b> <b>temporary</b> <b>files</b>

       Optimum input mechanisms:

           parse()                    YES (if you give it a seekable handle)
           parse_open()               YES (becomes a seekable handle)
           parse_data()               NO  (unless you set <!-- a -->tmp_to_core(1)<!-- /a -->)
           parse_two()                NO  (unless you set <!-- a -->tmp_to_core(1)<!-- /a -->)

       Optimum settings:

           decode_headers()           *** (doesn't matter)
           extract_nested_messages()  *** (doesn't matter)
           output_to_core()           *** (doesn't matter)
           tmp_recycling              1   (restricts created files to 1 per parser)
           tmp_to_core()              1
           use_inner_files()          1

       <b>If</b> <b>we</b> <b>can</b> <b>use</b> <b>them,</b> <b>inner</b> <b>files</b> <b>avoid</b> <b>most</b> <b>tmpfiles.</b>  If you parse from a seekable-and-tellable
       filehandle, then the internal <u>process</u><b>_</b><u>to</u><b>_</b><u>bound()</u> doesn't need to extract each part into a temporary
       buffer; it can use IO::InnerFile (<b>warning:</b> this will slow down the parsing of messages with large
       attachments).

       <b>You</b> <b>can</b> <b>veto</b> <b>tmpfiles</b> <b>entirely.</b>  If you might not be parsing from a seekable-and-tellable filehandle,
       you can set <u>tmp</u><b>_</b><u>to</u><b>_</b><u>core()</u> true: this will always use in-core I/O for the buffering (<b>warning:</b> this
       will slow down the parsing of messages with large attachments).

       <b>Final</b> <b>resort.</b>  You can always override <u>new</u><b>_</b><u>tmpfile()</u> in a subclass.

<b>WARNINGS</b>
       Multipart messages are always read line-by-line
           Multipart document parts are read line-by-line, so that the encapsulation boundaries may easily
           be detected.  However, bad MIME composition agents (for example, naive CGI scripts) might return
           multipart documents where the parts are, say, unencoded bitmap files... and, consequently, where
           such "lines" might be veeeeeeeeery long indeed.

           A better solution for this case would be to set up some form of state machine for input
           processing.  This will be left for future versions.

       Multipart parts read into temp files before decoding
           In my original implementation, the MIME::Decoder classes had to be aware of encapsulation
           boundaries in multipart MIME documents.  While this decode-while-parsing approach obviated the
           need for temporary files, it resulted in inflexible and complex decoder implementations.

           The revised implementation uses a temporary file (a la "tmpfile()") during parsing to hold the
           <u>encoded</u> portion of the current MIME document or part.  This file is deleted automatically after
           the current part is decoded and the data is written to the "body stream" object; you'll never see
           it, and should never need to worry about it.

           Some folks have asked for the ability to bypass this temp-file mechanism, I suppose because they
           assume it would slow down their application.  I considered accomodating this wish, but the temp-<font color="#ffffff" class="whiteout">file&nbsp;tempfile</font>
           file approach solves a lot of thorny problems in parsing, and it also protects against hidden
           bugs in user applications (what if you've directed the encoded part into a scalar, and someone
           unexpectedly sends you a 6 MB tar file?).  Finally, I'm just not conviced that the temp-file use
           adds significant overhead.

       Fuzzing of CRLF and newline on input
           RFC-1521 dictates that MIME streams have lines terminated by CRLF ("\r\n").  However, it is
           extremely likely that folks will want to parse MIME streams where each line ends in the local
           newline character "\n" instead.

           An attempt has been made to allow the parser to handle both CRLF and newline-terminated input.

       Fuzzing of CRLF and newline on output
           The "7bit" and "8bit" decoders will decode both a "\n" and a "\r\n" end-of-line sequence into a
           "\n".

           The "binary" decoder (default if no encoding specified) still outputs stuff verbatim... so a MIME
           message with CRLFs and no explicit encoding will be output as a text file that, on many systems,
           will have an annoying ^M at the end of each line... <u>but</u> <u>this</u> <u>is</u> <u>as</u> <u>it</u> <u>should</u> <u>be</u>.

       Inability to handle multipart boundaries that contain newlines
           First, let's get something straight: <u>this</u> <u>is</u> <u>an</u> <u>evil,</u> <u>EVIL</u> <u>practice,</u> and is incompatible with
           RFC-1521... hence, it's not valid MIME.

           If your mailer creates multipart boundary strings that contain newlines <u>when</u> <u>they</u> <u>appear</u> <u>in</u> <u>the</u>
           <u>message</u> <u>body,</u> give it two weeks notice and find another one.  If your mail robot receives MIME
           mail like this, regard it as syntactically incorrect MIME, which it is.

           Why do I say that?  Well, in RFC-1521, the syntax of a boundary is given quite clearly:

                 boundary := 0*69&lt;bchars&gt; bcharsnospace

                 bchars := bcharsnospace / " "

                 bcharsnospace :=    DIGIT / ALPHA / "'" / "(" / ")" / "+" /"_"
                              / "," / "-" / "." / "/" / ":" / "=" / "?"

           All of which means that a valid boundary string <u>cannot</u> have newlines in it, and any newlines in
           such a string in the message header are expected to be solely the result of <u>folding</u> the string
           (i.e., inserting to-be-removed newlines for readability and line-shortening <u>only</u>).

           Yet, there is at least one brain-damaged user agent out there that composes mail like this:

                 MIME-Version: 1.0
                 Content-type: multipart/mixed; boundary="----ABC-<font color="#ffffff" class="whiteout">123----"&nbsp;boundary="----ABC123----"</font>
                  123----"
                 Subject: Hi... I'm a dork!

                 This is a multipart MIME message (yeah, right...)

                 ----ABC-<font color="#ffffff" class="whiteout">123---&nbsp;----ABC123---</font>
123----<font color="#ffffff" class="whiteout">Hi&nbsp;123---Hi</font>

                 Hi there!

           We have <u>got</u> to discourage practices like this (and the recent file upload idiocy where binary
           files that are part of a multipart MIME message aren't base64-encoded) if we want MIME to stay
           relatively simple, and MIME parsers to be relatively robust.

           <u>Thanks</u> <u>to</u> <u>Andreas</u> <u>Koenig</u> <u>for</u> <u>bringing</u> <u>a</u> <u>baaaaaaaaad</u> <u>user</u> <u>agent</u> <u>to</u> <u>my</u> <u>attention.</u>

<b>AUTHOR</b>
       Eryq (<u>eryq@zeegee.com</u>), ZeeGee Software Inc (<a href="http://www.zeegee.com)"><u>http://www.zeegee.com</u>)</u></a><u>  David F. Skoll
       (dfs@roaringpenguin.com) <a href="http://www.roaringpenguin.com">http://www.roaringpenguin.com</u></a><u>

       All rights reserved.  This program is free software; you can redistribute it and/or modify it under
       the same terms as Perl itself.

<b>VERSION</b>
       $Revision: 1.20 $ $Date: 2006/03/17 21:03:23 $



perl v5.8.8                                      2006-03-17                                  MIME::Parser(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
