<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>CopyBits (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING166></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-165.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-167.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-58.html"><B>Chapter 3 - QuickDraw Drawing</B></A> / <A HREF="QuickDraw-61.html"><B>QuickDraw Drawing Reference</B></A><BR><DL><DD><A HREF="QuickDraw-67.html"><B>Routines</B></A> / <A HREF="QuickDraw-165.html"><B>Copying Images</B></A></DL></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING166-0></A>
<H3><A NAME=MARKER-9-752></A>CopyBits</H3>
 <A NAME=MARKER-11-754></A><A NAME=MARKER-11-754></A><A NAME=MARKER-2-107></A>You can use the <CODE>CopyBits</CODE> procedure to copy a portion of a bitmap or a pixel map from one graphics port (or offscreen graphics world) into another graphics port.<P>
<PRE>
PROCEDURE CopyBits (srcBits,dstBits: BitMap; 
                    srcRect,dstRect:\xF0Rect; mode:\xF0Integer; 
                    maskRgn:\xF0RgnHandle);
</PRE>
<DL>
<DT><CODE>srcBits</CODE>
<DD> The source <CODE>BitMap</CODE> record.
<DT><CODE>dstBits</CODE>
<DD> The destination <CODE>BitMap</CODE> record.
<DT><CODE>srcRect</CODE>
<DD> The source rectangle.
<DT><CODE>dstRect</CODE>
<DD> The destination rectangle.
<DT><CODE>mode</CODE>
<DD> One of the eight source modes in which the copy is to be performed.
<DT><CODE>maskRgn</CODE>
<DD> A region to use as a clipping mask.
</DL>
<A NAME=HEADING166-9></A>
<H5>DESCRIPTION</H5>
 The <CODE>CopyBits</CODE> procedure transfers any portion of a bitmap between two basic graphics ports, or any portion of a pixel map between two color graphics ports. You can use <CODE>CopyBits</CODE> to move offscreen graphic images into an onscreen window, to blend colors for the image in a pixel map, and to shrink and expand images.<P>
 Specify a source bitmap in the <CODE>srcBits</CODE> parameter and a destination bitmap in the <CODE>dstBits</CODE> parameter. When copying images between color graphics ports, you must coerce each <CODE>CGrafPort</CODE> record to a <CODE>GrafPort</CODE> record, dereference the <CODE>portBits</CODE> fields of each, and then pass these "bitmaps" in the <CODE>srcBits</CODE> and <CODE>dstBits</CODE> parameters. If your application copies a pixel image from a color graphics port called <CODE>MyColorPort</CODE>, for example, you could specify <CODE>GrafPtr(MyColorPort)^.portBits</CODE> in the <CODE>srcBits</CODE> parameter. In a <CODE>CGrafPort</CODE> record, the high 2 bits of the <CODE>portVersion</CODE> field are set. This field, which shares the same position in a <CODE>CGrafPort</CODE> record as the <CODE>portBits.rowBytes</CODE> field in a <CODE>GrafPort</CODE> record, indicates to <CODE>CopyBits</CODE> that you have passed it a handle to a pixel map rather than a bitmap.<P>
 Using the <CODE>srcRect</CODE> and <CODE>dstRect</CODE> parameters, you can specify identically or differently sized source and destination rectangles; for differently sized rectangles, <CODE>CopyBits</CODE> scales the source image to fit the destination. As shown in <A HREF=#MARKER-9-756>Figure 3-27</A>, for example, if the bit image is a circle in a square source rectangle, and the destination rectangle is not square, the bit image appears as an oval in the destination. When you specify rectangles in the <CODE>srcRect</CODE> and <CODE>dstRect</CODE> parameters, use the local coordinate systems of, respectively, the source and destination graphics ports.<P>
<B>Figure 3-27  <A NAME=MARKER-9-756></A>Using <CODE>CopyBits</CODE> to stretch an image<CODE></CODE></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-L-11.jpg"><BR>
 In the <CODE>mode</CODE> parameter, specify one of the following source modes for transferring the bits from a source bitmap to a destination bitmap:<P>
<PRE>
CONST             {source modes for basic graphics ports}
   srcCopy   = 0; {where source pixel is black, force }
                  { destination pixel black; where source pixel }
                  { is white, force destination pixel white}
   srcOr     = 1; {where source pixel is black, force }
                  { destination pixel black; where source pixel }
                  { is white, leave destination pixel unaltered}
   srcXor    = 2; {where source pixel is black, invert }
                  { destination pixel; where source pixel is }
                  { white, leave destination pixel unaltered}
   srcBic    = 3; {where source pixel is black, force }
                  { destination pixel white; where source pixel }
                  { is white, leave destination pixel unaltered}
   notSrcCopy 
             = 4; {where source pixel is black, force }
                  { destination pixel white; where source pixel }
                  { is white, force destination pixel black}
   notSrcOr  = 5; {where source pixel is black, leave }
                  { destination pixel unaltered; where source }
                  { pixel is white, force destination pixel black}
   notSrcXor = 6; {where source pixel is black, leave }
                  { destination pixel unaltered; where source }
                  { pixel is white, invert destination pixel}
   notSrcBic = 7; {where source pixel is black, leave }
                  { destination pixel unaltered; where source }
                  { pixel is white, force destination pixel white}
</PRE>
 On computers running System 7, you can add dithering to any source mode by adding the following constant or the value it represents to the source mode:<P>
<PRE>
CONST ditherCopy  = 64; {add to source mode for dithering}
</PRE>
 Dithering is a technique that mixes existing colors to create the effect of additional colors. It also improves images that you shrink or that you copy from a direct pixel device to an indexed device. The <CODE>CopyBits</CODE> procedure always dithers images when shrinking them between pixel maps on direct devices. <P>
 To use highlighting, you can add this constant or its value to the source mode:<P>
<PRE>
CONST hilite= 50; {add to source or pattern mode for highlighting}
</PRE>
 With highlighting, QuickDraw replaces the background color with the highlight color when your application copies images between graphics ports. This has the visual effect of using a highlighting pen to select the object. (The global variable <CODE>HiliteRGB</CODE> is read from parameter RAM when the machine starts. Basic graphics ports use the color stored in the <CODE>HiliteRGB</CODE> global variable as the highlight color. Color graphics ports default to the <CODE>HiliteRGB</CODE> global variable, but can be overridden by the <CODE>HiliteColor</CODE> procedure, described in the chapter "Color QuickDraw.")<P>
 When transferring pixels from a source pixel map to a destination pixel map, Color QuickDraw interprets the source mode constants differently than basic QuickDraw does. These constants have the following effects under Color QuickDraw:<P>
<PRE>
CONST             {source modes for color graphics ports}
   srcCopy    = 0;{determine how close the color of the source }
                  { pixel is to black, and assign this relative }
                  { amount of foreground color to the }
                  { destination pixel; determine how close the }
                  { color of the source pixel is to white, and }
                  { assign this relative amount of background }
                  { color to the destination pixel}
   srcOr      = 1;{determine how close the color of the source }
                  { pixel is to black, and assign this relative }
                  { amount of foreground color to the }
                  { destination pixel}
   srcXor     = 2;{where source pixel is black, invert the }
                  { destination pixel--for a colored destination }
                  { pixel, use the complement of its color }
                  { if the pixel is direct, invert its index if }
                  { the pixel is indexed}
   srcBic     = 3;{determine how close the color of the source }
                  { pixel is to black, and assign this relative }
                  { amount of background color to the }
                  { destination pixel}
   notSrcCopy = 4;{determine how close the color of the source }
                  { pixel is to black, and assign this relative }
                  { amount of background color to the }
                  { destination pixel; determine how close the }
                  { color of the source pixel is to white, and }
                  { assign this relative amount of foreground }
                  { color to the destination pixel}
   notSrcOr  = 5; {determine how close the color of the source }
                  { pixel is to white, and assign this relative }
                  { amount of foreground color to the }
                  { destination pixel}
   notSrcXor = 6; {where source pixel is white, invert the }
                  { destination pixel--for a colored destination }
                  { pixel, use the complement of its color }
                  { if the pixel is direct, invert its index if }
                  { the pixel is indexed}
   notSrcBic = 7; {determine how close the color of the source }
                  { pixel is to white, and assign this relative }
                  { amount of background color to the }
                  { destination pixel}
</PRE>
 When you use <CODE>CopyBits</CODE> on a computer running Color QuickDraw, you can also specify one of the following transfer modes in the <CODE>mode</CODE> parameter:<P>
<PRE>
CONST {arithmetic transfer modes available in Color QuickDraw}
   blend       = 32; {replace destination pixel with a blend }
                     { of the source and destination pixel }
                     { colors; if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcCopy mode}
   addPin      = 33; {replace destination pixel with the sum of }
                     { the source and destination pixel colors-- }
                     { up to a maximum allowable value; if }
                     { the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcBic mode}
   addOver     = 34; {replace destination pixel with the sum of }
                     { the source and destination pixel colors-- }
                     { but if the value of the red, green, or }
                     { blue component exceeds 65,536, then } 
                     { subtract 65,536 from that value; if the }
                     { destination is a bitmap or 1-bit }
                     { pixel map, revert to srcXor mode}
   subPin      = 35; {replace destination pixel with the }
                     { difference of the source and destination }
                     { pixel colors--but not less than a minimum }
                     { allowable value; if the destination }
                     { is a bitmap or 1-bit pixel map, revert to }
                     { srcOr mode}
   transparent = 36; {replace the destination pixel with the }
                     { source pixel if the source pixel isn't }
                     { equal to the background color}





   addMax      = 37; {compare the source and destination pixels, }
                     { and replace the destination pixel with }
                     { the color containing the greater }
                     { saturation of each of the RGB components; }
                     { if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcBic mode}
   subOver     = 38; {replace destination pixel with the }
                     { difference of the source and destination }
                     { pixel colors--but if the value of the }
                     { red, green, or blue component is }
                     { less than 0, add the negative result to }
                     { 65,536; if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcXor mode}
   adMin       = 39; {compare the source and destination pixels, }
                     { and replace the destination pixel with }
                     { the color containing the lesser }
                     { saturation of each of the RGB components; }
                     { if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcOr mode}
</PRE>
 You can pass a region handle in the <CODE>MaskRgn</CODE> parameter to specify a mask region; the resulting image is always clipped to this mask region and to the boundary rectangle of the destination bitmap. If the destination bitmap is the current graphics port's bitmap, it's also clipped to the intersection of the graphics port's clipping region and visible region. If you don't want to clip to a masking region, just pass <CODE>NIL</CODE> for the <CODE>maskRgn</CODE> parameter.<P>
<A NAME=HEADING166-28></A>
<H5><A NAME=MARKER-9-757></A>SPECIAL CONSIDERATIONS</H5>
 When you use the <CODE>CopyBits</CODE> procedure to transfer an image between pixel maps, the source and destination images may be of different pixel depths, of different sizes, and they may have different color tables. However, <CODE>CopyBits</CODE> assumes that the destination pixel map uses the same color table as the color table for the current <CODE>GDevice</CODE> record. (This is because the Color Manager requires an inverse table for translating the color table from the source pixel map to the destination pixel map.) <P>
 The <CODE>CopyBits</CODE> procedure applies the foreground and background colors of the current graphics port to the image in the destination pixel map (or bitmap), even if the source image is a bitmap. This causes the foreground color to replace all black pixels in the destination and the background color to replace all white pixels. To avoid unwanted coloring of the image, use the <CODE>RGBForeColor</CODE> procedure to set the foreground to black and use the <CODE>RGBBackColor</CODE> procedure to set the background to white before calling <CODE>CopyBits</CODE>.<P>
 The source bitmap or pixel map must not occupy more memory than half the available stack space. The stack space required by <CODE>CopyBits</CODE> is roughly five times the value of the <CODE>rowBytes</CODE> field of the source pixel map: one <CODE>rowBytes</CODE> value for the pixel map (or bitmap), an additional <CODE>rowBytes</CODE> value for dithering, another <CODE>rowBytes</CODE> value when stretching or shrinking the source pixel map into the destination, another <CODE>rowBytes</CODE> value for any color map changing, and a fifth additional <CODE>rowBytes</CODE> value for any color aliasing. If there is insufficient memory to complete a <CODE>CopyBits</CODE> operation in Color QuickDraw, the <CODE>QDError</CODE> function (described in the chapter "Color QuickDraw" in this book) returns the result code -143.<P>
 If you use <CODE>CopyBits</CODE> to copy between two graphics ports that overlap, you must first use the <CODE>LocalToGlobal</CODE> procedure to convert to global coordinates, and then specify the global variable <CODE>screenBits</CODE> for both the <CODE>srcBits</CODE> and <CODE>dstBits</CODE> parameters.<P>
 The <CODE>CopyBits</CODE> procedure may move or purge memory blocks in the application heap. Your application should not call this procedure at interrupt time.<P>
 If you are reading directly from a NuBus<Superscript>\x89<EM></EM> video card with a base address of Fs00000 and there is not a card in the slot (s-1) below it, <CODE>CopyBits</CODE> reads addresses less than the base address of the pixel map. This causes a bus error. To work around the problem, remap the <CODE>baseAddr</CODE> field of the pixel map in your video card to at least 20 bytes above the NuBus boundary; an address link of Fs000020 precludes the problem.<P>
<A NAME=HEADING166-35></A>
<H5>SEE ALSO</H5>
 <A HREF=QuickDraw-60.html#MARKER-9-135>Listing 3-11 on page 3-29</A> illustrates how to use <CODE>CopyBits</CODE> to scale an image when copying it from one window into another. Source modes are described in <A HREF=QuickDraw-59.html#MARKER-9-37>"Boolean Transfer Modes With 1-Bit Pixels" beginning on page 3-7</A>.  <A HREF="ColorPlate2.html">Plate 2</A> at the front of this book illustrates how to use <CODE>CopyBits</CODE> to colorize an image in a color graphics port; <A HREF=QuickDraw-199.html#MARKER-9-136>Listing 4-5 on page 4-26</A> in the chapter "Color QuickDraw" shows the sample code that produced this plate. <A HREF=QuickDraw-304.html#MARKER-9-27>Listing 6-1 on page 6-5</A> in the chapter "Offscreen Graphics Worlds" illustrates how to use <CODE>CopyBits</CODE> to copy an image from an offscreen graphics world to an onscreen color graphics port. <P>
 Dithering, pixel maps, color graphics ports, the <CODE>RGBForeColor</CODE> and <CODE>RGBBackColor</CODE> procedures, and color tables are explained in the chapter "Color QuickDraw." The <CODE>LocalToGlobal</CODE> procedure is described in the chapter "Basic QuickDraw." The <CODE>GDevice</CODE> record is described in the chapter "Graphics Devices." Inverse tables and the Color Manager are described in the chapter "Color Manager" in <I><A HREF="../ACI/ACI-2.html">Advanced Color Imaging on the Mac OS</A></I>.<P>
 "Copying Pixels Between Color Graphics Ports" in the chapter "Color QuickDraw" describes in greater detail how to use <CODE>CopyBits</CODE> to transfer colored images.<P>
 The <CODE>CopyDeepMask</CODE> procedure (described on <A HREF=QuickDraw-168.html#MARKER-9-764>page 3-116</A>) combines the functions of the <CODE>CopyBits</CODE> and <CODE>CopyMask</CODE> procedures. (The <CODE>CopyMask</CODE> procedure is described next.)<A NAME=MARKER-2-758></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-165.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-167.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
