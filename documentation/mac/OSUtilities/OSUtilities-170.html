<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About the Trap Manager (IM: U)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING170></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="OSUtilities-169.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-171.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="OSUtilities-2.html"><B>Operating System Utilities</B></A> / <BR><DD><A HREF="OSUtilities-169.html"><B>Chapter 8 - Trap Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING170-0></A>
<H1><A NAME=MARKER-9-4></A>About the Trap Manager</H1>
 The Trap Manager is a collection of routines that lets you add extra capabilities to system software routines. <P>
 <A NAME=MARKER-0-5></A>In order to execute system software routines, system software takes advantage of the unimplemented instruction feature of the MC680x0 family of microprocessors, which are the central processing units (CPUs) used in the Macintosh family of computers.<P>
 <A NAME=MARKER-0-6></A><A NAME=MARKER-0-7></A>The MC680x0, like other microprocessors, executes a stream of instructions. Information encoded in an instruction indicates the operation to be performed by the microprocessor. The MC680x0 family of microprocessors recognizes a defined set of instructions. When the microprocessor encounters an instruction that it doesn't recognize, an exception is generated. An exception refers to bus errors, interrupts, and unimplemented instructions. When an exception occurs, the microprocessor suspends normal execution and transfers control to an appropriate exception handler. <P>
 In the MC680x0 family of microprocessors, all instructions starting with the hexadecimal digit $A are unimplemented instructions. These unimplemented instructions are also called <B>A-line instructions</B>. System software uses these unimplemented A-line instructions to execute system software routines. When you call a system software routine, the call to the system software routine is translated into an A-line instruction. The MC680x0 microprocessor doesn't recognize this A-line instruction, and transfers control to an exception handler.<P>
 <A NAME=MARKER-0-8></A><A NAME=MARKER-0-9></A>System software provides an exception handler, called a <B>trap dispatcher</B>, to handle exceptions generated by A-line instructions. Whenever a MC680x0 microprocessor encounters an A-line instruction, an exception is generated, and the microprocessor transfers control to the trap dispatcher. An exception generated by an A-line instruction is called a <B>trap</B>.<P>
 <A NAME=MARKER-0-10></A>When the trap dispatcher receives the A-line instruction, it looks into a table, called a<B> trap dispatch table</B>, to find the address of the called system software routine. After the trap dispatcher retrieves the address, it transfers control to the specified system software routine. <A HREF=#MARKER-9-11>Figure 8-1</A> illustrates the processing of instructions that include the A-line instructions that the microprocessor does not recognize.<P>
<B>Figure 8-1  <A NAME=MARKER-9-11></A>How the CPU processes A-line instructions</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-17.jpg"><P>
 You can use the Trap Manager routines to read from and write to the two trap dispatch tables maintained by system software. <A NAME=MARKER-0-12></A><P>
<A NAME=HEADING170-10></A>
<H2>Trap Dispatch Tables</H2>
 <A NAME=MARKER-2-13></A><A NAME=MARKER-2-14></A><A NAME=MARKER-2-15></A>System software uses trap dispatch tables to locate the address of system software routines. System software maintains two trap dispatch tables: an Operating System trap dispatch table and a Toolbox trap dispatch table. <A HREF=#MARKER-9-16>Figure 8-2</A> illustrates the two trap dispatch tables.<P>
<B>Figure 8-2  <A NAME=MARKER-9-16></A>Trap dispatch tables</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-13.jpg"><P>
 At system startup time, system software builds the trap dispatch tables and places them in RAM. The <B>Operating System trap dispatch table</B> contains 256 entries, and the <B>Toolbox trap dispatch table</B> contains 1024 entries. Each entry in the Operating System trap dispatch table contains a 32-bit address of an Operating System routine, and each entry in the Toolbox trap dispatch table contains a 32-bit address of a Toolbox routine. The system software routines can be located in either ROM or RAM.<A NAME=MARKER-2-17></A><A NAME=MARKER-2-5></A><A NAME=MARKER-2-19></A><P>
<A NAME=HEADING170-15></A>
<H2>Process for Accessing System Software Routines</H2>
 <A NAME=MARKER-0-20></A>As previously described, when your application calls a system software routine, an A-line instruction is sent to the microprocessor. The microprocessor does not recognize this instruction, and an exception is generated. This exception is then handled by the trap dispatcher. When the trap dispatcher receives the A-line instruction, it looks into one of the two trap dispatch tables to find the address of the called system software routine. When the trap dispatcher retrieves the address, it transfers control to the specified system software routine. For example, <A HREF=#MARKER-9-21>Figure 8-3</A> illustrates a call to the Toolbox procedure, <CODE>FillRect</CODE>. When the application calls the <CODE>FillRect</CODE> procedure, an exception is generated. The trap dispatcher looks into the Toolbox trap dispatch table to find the address of the <CODE>FillRect</CODE> procedure. When the address is found, the trap dispatcher transfers control to the <CODE>FillRect</CODE> procedure.<P>
<B>Figure 8-3  Accessing the <EM>FillRect</EM> procedure<A NAME=MARKER-9-21></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-14.jpg"><P>
<DL>
<DT><B>Note</B>
<DD>Not all A-line instructions are defined. When the trap dispatcher receives an undefined A-line instruction, the trap dispatcher returns the address of the Toolbox procedure <CODE>Unimplemented</CODE>. When called, the <CODE>Unimplemented<A NAME=MARKER-2-22></A></CODE> procedure triggers a system error.<EM></EM><A NAME=MARKER-0-23></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-20></A>
<H2>Patches and System Software Routines </H2>
 <A NAME=MARKER-2-24></A><A NAME=MARKER-0-25></A><A NAME=MARKER-2-99></A><A NAME=MARKER-2-27></A>You can modify the trap dispatch table so that the address that gets returned to the trap dispatcher points to a different routine instead of the intended system software routine; this is useful if you want to augment or override an existing system software routine. The routine that augment an existing system software routine is called a <B>patch</B>. The method of augmenting or overriding a system software routine is called <I>patching a trap</I>. <P>
 For example, you can augment the <CODE>FillRect</CODE> procedure with your own procedure <CODE>MyPatchFillRect</CODE>. <A HREF=#MARKER-9-28>Figure 8-4</A> illustrates another call to the Toolbox procedure <CODE>FillRect</CODE>. When the application calls the <CODE>FillRect</CODE> procedure the application-defined patch <CODE>MyPatchFillRect</CODE> is executed first. After the application-defined patch <CODE>MyPatchFillRect</CODE> completes its primary action, it transfers control (through a JMP instruction) to the original <CODE>FillRect</CODE> procedure.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Although this chapter describes patching in some detail, you should avoid any unnecessary patching of the system software. One very good reason to avoid patching is that is causes a performance reduction. The performance reduction is especially substantial when your patch is executed on a PowerPC processor-based Macintosh computer, where it is necessary to switch execution environments when entering and exiting your patch code. For more information about patching PowerPC system software, see <I><A HREF="../PPCSoftware/PPCSoftware-2.html">Inside Macintosh: PowerPC System Software</A></I>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Figure 8-4  <A NAME=MARKER-9-28></A>Augmenting the <EM>FillRect</EM> procedure with a single patch</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-11.jpg"><P>
<DL>
<DT><B>Note</B>
<DD>To prevent dangling patch addresses, you must ensure that your patch routine is in a locked memory block while its address is in the trap dispatch table.<EM></EM><A NAME=MARKER-2-104></A>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-27></A>
<H3>Daisy Chain of Patches</H3>
 <A NAME=MARKER-0-30></A><A NAME=MARKER-2-31></A>It is possible to patch a system software routine with more than just one patch; this is <A NAME=MARKER-0-32></A>called a <B>daisy chain</B> of patches. Typically, you extract from the trap dispatch table the address of the routine you wish to patch, save this address, and then install your own patch routine. When your patch has completed its tasks, it should jump to the address you previously extracted from the trap dispatch table. In this way, the patches take the general form of a daisy chain. Each patch will execute in turn and jump to the next patch until the last link in the chain, which returns control to the trap dispatcher. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Although this chapter describes patching in some depth, you should rarely, if ever, find a need to use patches in an application. The primary purposes of patches, as their name suggests, are to fix problems and augment routines in ROM code.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 A patch can be implemented as either a head patch, tail patch, or come-from patch. These are described in the next sections.<A NAME=MARKER-0-33></A><A NAME=MARKER-2-34></A><P>
<A NAME=HEADING170-31></A>
<H3>Head Patch (Normal Patch)</H3>
 <A NAME=MARKER-2-35></A>A <B>head patch</B>, also referred to as a <B>normal patch</B>, is a routine that gets executed before the original system software routine. A head patch performs its primary action and then uses a jump instruction (<CODE>JMP</CODE>) to jump to the system software routine. Thus the head patch does not regain control after the execution of the system software routine. After the execution of the system software routine, control is transferred back to the trap dispatcher.<P>
<A NAME=HEADING170-33></A>
<H3>Tail Patch</H3>
 <A NAME=MARKER-2-21></A>A <B>tail patch</B> is a routine that gets executed before the original system software routine and regains control after the execution of the system software routine. A tail patch uses a  jump-subroutine instruction (<CODE>JSR</CODE>) to transfer control to the system software routine. After the system software routine returns control to the tail patch, the tail patch returns control to the trap dispatcher.<P>
<DL>
<DT><B>WARNING</B>
<DD>You should never install tail patches in system software versions earlier than System 7. Tail patches may conflict with come-from patches, installed by Apple.<EM></EM><A NAME=MARKER-9-86></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-36></A>
<H3>Come-From Patch (Used Only by Apple)</H3>
 <A NAME=MARKER-9-64></A>A <B>come-from patch, </B>also called a <B>system patch</B>, is a type of patch used only by Apple. Come-from patches are used to replace erroneous code or to add capabilities not in ROM.<P>
 When a come-from patch is invoked, it examines the stack to determine where it was called from. If the come-from patch was invoked from a particular place in ROM (a spot where the code needs to be augmented or deleted), the come-from patch executes the modifying code. Otherwise, if the come-from patch was called from a part of the system that does not need to be augmented, it transfers control to the next routine in the daisy chain. This routine could be another patch or the system software routine.<P>
 Beginning with System 7, the addresses of come-from patches are permanently placed in the trap dispatch table at system startup time. The addresses of come-from patches are hidden and cannot be manipulated by any of the Trap Manger routines. <P>
 For example, if a system software routine has a come-from patch and if you use the Trap Manger function <CODE>NGetTrapAddress</CODE> to retrieve the address of the system software routine, you will not get the address in the trap dispatch table (which is the address of the come-from patch). <CODE>NGetTrapAddress</CODE> instead returns the address of the routine that is executed immediately after the come-from patch. This address could be the address of another patch or the system software routine.<P>
 If a system software routine has a come-from patch and if you use the Trap Manager procedure <CODE>NSetTrapAddress</CODE> to install a patch to the system software routine, the address of the patch is not written into the trap dispatch table. Instead, the <CODE>NSetTrapAddress</CODE> procedure installs the address of the patch into the last come-from patch. The patch is executed after the completion of the come-from patch.<P>
<DL>
<DT><B>WARNING</B>
<DD>In system software before System 7, if a come-from patch is invoked by a tail-patch, the come-from patch does not work correctly. The come-from patch never sees the ROM address on the stack--only the return address of the tail-patch. <EM></EM><A NAME=MARKER-2-39></A><A NAME=MARKER-2-40></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-43></A>
<H3>Patch for One Application</H3>
 <A NAME=MARKER-0-41></A>If you install a patch into your application heap, the patch applies only to your application. When your application is switched out, your application's heap (and patch) is swapped out. For example, if you patch <CODE>FillRect</CODE> with the patch <CODE>MyPatchFillRect</CODE>, the <CODE>MyPatchFillRect</CODE> patch is executed only when the <CODE>FillRect</CODE> procedure is called from your application.<P>
<DL>
<DT><B>Note</B>
<DD>When running in System 7 or under MultiFinder in System 6, each application has its own copy of the trap dispatch tables. This ensures that an application's patches apply only when it is running and that they're discarded when the application quits.<EM></EM><A NAME=MARKER-0-42></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-46></A>
<H3>Patch for All Applications</H3>
 <A NAME=MARKER-0-43></A><A NAME=MARKER-0-44></A>If you install a patch from a system extension during system startup, your patch is placed in the system heap and applies to all applications. For example, if you patch the <CODE>FillRect</CODE> procedure with the patch <CODE>MyPatchFillRect</CODE> from a system extension, the <CODE>MyPatchFillRect</CODE> patch is executed every time the <CODE>FillRect</CODE> procedure is called, no matter which application calls it.<A NAME=MARKER-0-45></A><P>
<A NAME=HEADING170-48></A>
<H2>A-Line Instructions</H2>
 <A NAME=MARKER-2-46></A>When your application calls a Toolbox or an Operating System routine, an A-line instruction is sent to the microprocessor. Each A-line instruction contains information about the called system software routine. <A HREF=#MARKER-9-47>Figure 8-5</A> shows the layout of an A-line instruction.<P>
<B>Figure 8-5  <A NAME=MARKER-9-47></A>A-line instruction format</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-01.jpg"><P>
 <A NAME=MARKER-2-59></A>The high-order 4 bits of an A-line instruction have the hexadecimal value $A, hence the name A-line instruction. Bit 11 of the A-line instruction indicates the type of system software routine to be invoked: a value of 0 in bit 11 indicates an Operating System routine, a value of 1 in bit 11 indicates a Toolbox routine<A NAME=MARKER-9-38></A>. The trap number in an A-line instruction is used as an index into the appropriate dispatch table. The meaning of the flags vary accordingly to the type of A-line instruction.<P>
 <A NAME=MARKER-0-50></A>When your application calls a system software routine (thereby generating an exception), the microprocessor pushes an <B>exception stack frame<A NAME=MARKER-2-52></A></B> onto the stack. <A HREF=#MARKER-9-52>Figure 8-6</A> shows a typical exception stack frame. After pushing the exception stack frame on the stack, the microprocessor transfers control to the trap dispatcher.<P>
<B>Figure 8-6  <BR>
<A NAME=MARKER-9-52></A>Exception stack frame (on Macintosh computers with a MC68020 microprocessor or greater)</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-02.jpg"><P>
 The trap dispatcher discards the status register and vector offset. Depending on whether the A-line instruction is used to invoke an Operating System routine or a Toolbox routine, the trap dispatcher deals with the stack and registers in two very different ways, as described in the next section, "A-line Instructions for Operating System Routines," and in the section <A HREF=#MARKER-9-69>"A-Line Instructions for Toolbox Routines" beginning on page 8-14</A>.<A NAME=MARKER-0-53></A><P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-0-54></A>The exception handler is located at address $28 on computers with an MC68000 microprocessor and at address $28 offset from the address in the microprocessor's Vector Base Register (VBR)<A NAME=MARKER-2-55></A> on computers with other MC680x0 microprocessors. Consult the relevant microprocessor handbook for the precise details of exception handling on the MC680x0 microprocessor of interest to you.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-58></A>
<H2>A-Line Instructions for Operating System Routines</H2>
 <A NAME=MARKER-2-56></A><A NAME=MARKER-2-57></A>An <B>Operating System trap</B> is an exception that is caused by an A-line instruction that executes an Operating System routine. <P>
 When dispatching an Operating System trap, the trap dispatcher extracts the trap number from the A-line instruction and uses it as an index into the Operating System trap dispatch table. The entry in the Operating System trap dispatch table contains the address of the desired Operating System routine. <A HREF=#MARKER-9-58>Figure 8-7</A> illustrates an A-line instruction for an Operating System routine. <P>
<B>Figure 8-7  <A NAME=MARKER-9-58></A>An A-line instruction for an Operating System routine</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-03.jpg"><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-06.jpg"><P>
 <A NAME=MARKER-2-59></A>Bit 11 tells the trap dispatcher that this A-line instruction invokes an Operating System routine. Two flag bits, bit 10 and bit 9, are reserved for use by the Operating System routine itself and are discussed in detail in <A HREF=#MARKER-9-67>"Flag Bits" on page 8-14</A>. Bit 8 indicates whether the value in register A0 is returned from the Operating System routine. If bit 8 is 0, the value in register A0 is returned from the Operating System routine. If bit 8 is 1, the value in register A0 is not returned by the Operating System routine. As previously described, the trap number is in bits 7-0 and is used to determine which of the 256 possible Operating System routines is executed.<P>
 For example, a call to the Operating System function <CODE>GetPtrSize</CODE> is translated to the A-line instruction $A021. This A-line instruction causes the microprocessor to transfer control to the trap dispatcher<B><A NAME=MARKER-2-82></A></B>, which deals with any instruction of the form $A<I>xxx</I>. The trap dispatcher first saves registers D0, D1, D2, A1, and, if bit 8 is 0, A0. The trap dispatcher places the A-line instruction itself into the low-order word of register D1 so that the Operating System routine can inspect the flag bits. Next, the trap dispatcher examines the other bits in the A-line instruction. The value (0) of bit 11 indicates that <CODE>GetPtrSize</CODE> is an Operating System routine, and that the value in bits 7-0 is the index into the Operating System trap dispatch table. The trap dispatcher uses the index (which is 33 in this example) to find the address of the <CODE>GetPtrSize</CODE> function in the Operating System trap dispatch table. When the address is found, the trap dispatcher transfers control to the <CODE>GetPtrSize</CODE> function.<P>
 <A HREF=#MARKER-9-61>Figure 8-8</A> illustrates the stack after the trap dispatcher has transferred control to an Operating System routine.<P>
<B>Figure 8-8  <A NAME=MARKER-9-61></A>The stack on entry to an Operating System routine</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-07.jpg"><P>
 The Operating System routine may alter any of the registers D0-D2 and A0-A2, but it must preserve registers D3-D7 and A3-A6. The Operating System routine may return information in register D0 (and A0 if bit 8 is set). To return to the trap dispatcher, the Operating System routine executes the RTS (return from subroutine) instruction.<P>
 When the trap dispatcher resumes control, first it restores the value of registers D1, D2, A1, A2, and, if bit 8 is 0, A0. The values in registers D0 and, if bit 8 is 1, in A0 are not restored.<P>
<A NAME=HEADING170-71></A>
<H3>Calling Conventions for Register-Based Routines</H3>
 <A NAME=MARKER-2-62></A>Register-based routines receive their parameters from microprocessor registers, and they pass their results in microprocessor registers. Virtually all Operating System routines are register-based routines.<P>
 An Operating System routine returns information only in registers D0 and, if bit 8 is 1, A0. The stack and all other registers are unchanged.<P>
 Many Operating System routines return a result code in the low-memory word of register D0 to report whether the requested operation was performed successfully. A result code of 0 indicates that the routine completed successfully; any other value typically indicates an error. Just before the trap dispatcher finishes execution, it tests the low-order word of register D0 with a TST.W instruction to set the condition codes of the microprocessor.<P>
<DL>
<DT><B>Note</B>
<DD>Calling conventions for PowerPC microprocessor-based Macintosh computers are different from the calling conventions described for in this section. For information about calling conventions for PowerPC processor-based Macintosh computers, see <I><A HREF="../PPCSoftware/PPCSoftware-2.html">Inside Macintosh: PowerPC System Software</A></I>.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-76></A>
<H3><A NAME=MARKER-2-63></A>Parameter-Passing Conventions for Operating System Routines</H3>
 By convention, register-based routines normally use register A0 for passing addresses (such as pointers to data objects) and register D0 for other data values (such as integers). <P>
 For routines that take more than two parameters, the parameters are normally collected in a parameter block in memory and a pointer to the parameter block is passed in register A0. See the description of an individual routine in the appropriate <I>Inside Macintosh</I> book for exact details.<A NAME=MARKER-2-64></A><P>
<A NAME=HEADING170-79></A>
<H3><A NAME=MARKER-2-65></A>Function Results</H3>
 Most Operating System functions return their function result (or result code) in register D0. Parameters are returned through register A0, usually as a pointer to a parameter block.<P>
 Whether the trap dispatcher preserves register A0 depends on the setting of bit 8 in the A-line instruction. If bit 8 is 0, the trap dispatcher saves and restores register A0; if it's 1, the routine passes back register A0 unchanged. Thus, bit 8 of the A-line instruction should be set to 1 only for those routines that use register A0 to return information. The trap macros automatically set this bit correctly for each routine.<P>
 To see in which register the function passes the function result, see the description of the individual function in the appropriate <I>Inside Macintosh</I> book.<A NAME=MARKER-2-66></A><P>
<A NAME=HEADING170-83></A>
<H3><A NAME=MARKER-9-67></A>Flag Bits</H3>
 Many Operating System routines use the flag bits in an A-line instruction to encode additional information used by the routine. For example, the A-line instructions that invoke Memory Manager routines define the two flag bits like this:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Bit<TH>Explanation<TR>
<TD>9<TD>If 1, initialize all bytes in the allocated memory to 0.<BR>If 0, do not initialize all bytes in the allocated memory to 0.<TR>
<TD>8<TD>If 1, allocate memory from the system heap.<BR>If 0, allocate memory from the application heap.</TABLE>
<P>
 These two bits are defined in assembly language as:<P>
<PRE>
CLEAR    EQU      $200     ;initialize block to zero
SYS      EQU      $400     ;use the system heap
</PRE>
 When used with a Memory Manager A-line instruction, these modifiers cause flag bits 9 and 10, respectively, to be set. They could be used in an assembly-language instruction sequence like<P>
<PRE>
         MOVEQ    #124,D0        ;need 124 bytes
         _NewPtr     SYS,CLEAR   ;allocate requested memory in
                                 ; system heap and initialize to
                                 ; zeroes
</PRE>
 The <CODE>SYS</CODE> modifier specifies allocation from the system heap, regardless of the value of the global variable <CODE>TheZone</CODE>, and the <CODE>CLEAR</CODE> modifier specifies that the Memory Manager should initialize the block contents to zero. For further details, consult <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A></I>.<A NAME=MARKER-2-10></A><P>
<A NAME=HEADING170-90></A>
<H2><A NAME=MARKER-9-69></A>A-Line Instructions for Toolbox Routines</H2>
 <A NAME=MARKER-2-70></A><A NAME=MARKER-2-71></A>A <B>Toolbox trap</B> is an exception that is caused by an A-line instruction that executes a Toolbox routine. <P>
 When dispatching a Toolbox trap, the trap dispatcher extracts the trap number from the A-line instruction and uses it as an index into the Toolbox trap dispatch table. The index points to the entry in the Toolbox trap dispatch table that contains the address of the desired Toolbox routine. <A HREF=#MARKER-9-72>Figure 8-9</A> illustrates an A-line instruction that is used to access a Toolbox routine. <P>
<B>Figure 8-9  <A NAME=MARKER-9-72></A>An A-line instruction for a Toolbox routine</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-03.jpg"><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-03.jpg"><P>
 Bit 11 tells the trap dispatcher that this A-line instruction is used to access a Toolbox routine. Bit 10 is the auto-pop bit. Bits 9-0 contain the trap number which, as previously described, determine which of the 1024 possible Toolbox routines is executed. The auto-pop bit is described in detail in <A HREF=#MARKER-9-85>"The Auto-Pop Bit" on page 8-20</A>.<P>
 For example, a call to the Toolbox function <CODE>WaitNextEvent</CODE> is translated to the A-line instruction $A860. This A-line instruction causes the microprocessor to transfer control to the trap dispatcher<B><A NAME=MARKER-2-73></A></B>, which deals with any instruction of the form $A<I>xxx</I>. The trap dispatcher examines the other bits in the A-line instruction. The value (0) of bit 11 indicates that <CODE>WaitNextEvent</CODE> is a Toolbox routine and that the value in bits 9-0 is the index into the Toolbox trap dispatch table. The trap dispatcher uses the index (which is $60 in this example) to find the address of the <CODE>WaitNextEvent</CODE> function in the Toolbox trap dispatch table. When the address is found, the trap dispatcher transfers control to the <CODE>WaitNextEvent</CODE> function.<P>
 <A HREF=#MARKER-9-74>Figure 8-10</A> illustrates the stack after the trap dispatcher has transferred control to a Toolbox routine.<P>
<B>Figure 8-10  <A NAME=MARKER-9-74></A>Stack when entering a Toolbox routine</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-04.jpg"><P>
 The value of the Program Counter that is left on the stack before entry to the Toolbox routine points to the instruction that is executed after the completion of the Toolbox routine.<P>
 After the trap dispatcher completes execution, the internal status of the stack is restored, and normal execution resumes from the point at which processing was suspended.<P>
 A Toolbox routine changes the Stack Pointer in register A7 and pops the return address and any input parameters. A routine might also alter registers D0-D2, A0, and A1.<P>
<DL>
<DT><B>WARNING</B>
<DD>Some Toolbox routines (for example the <CODE>LongMul</CODE> procedure described in the chapter "Mathematical and Logical Utilities" in this book) preserve more than the required set of registers. However, you should assume all of registers D0-D2, A0, and A1 are altered by Toolbox routines.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-105></A>
<H3><A NAME=MARKER-2-75></A><A NAME=MARKER-9-76></A>Calling Conventions for Stack-Based Routines</H3>
 Stack-based routines receive their parameters on the stack and return their results on the stack. Virtually all Toolbox routines are stack-based routines.<P>
 Most Toolbox routines follow Pascal calling conventions; that is, Toolbox routine parameters are evaluated from left to right and are pushed onto the stack in the order in which they are evaluated. Function results are returned by value or by address on the stack. Space for the function result is allocated by the caller before the parameters are pushed on the stack. The caller is responsible for removing the result from the stack after the call.<P>
<DL>
<DT><B>Note</B>
<DD>Calling conventions for PowerPC microprocessor-based Macintosh computers are different from the calling conventions described in this section. For information about calling conventions for PowerPC processor-based Macintosh computers, see <I><A HREF="../PPCSoftware/PPCSoftware-2.html">Inside Macintosh: PowerPC System Software</A></I>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-77>Figure 8-11</A> illustrates Pascal calling conventions. In this example, a routine calls the application-defined function <CODE>MyPascalFn</CODE>. When the application calls the function <CODE>MyPascalFn</CODE>, the application must first make room on the stack for the function result, then push the parameters on the stack in left-to-right order.<P>
<B>Figure 8-11  <A NAME=MARKER-9-77></A>Pascal calling convention</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-15.jpg"><P>
 <A HREF=#MARKER-9-78>Figure 8-12</A> illustrates C calling conventions. In this example, a routine calls the application-defined function <CODE>MyCFn</CODE>. When the application calls the function <CODE>MyCFn</CODE>, the application pushes the parameters on the stack in right-to-left order. The function result is returned in register D0, and not on the stack.<P>
<B>Figure 8-12  <A NAME=MARKER-9-78></A><A NAME=MARKER-2-79></A>C calling convention</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Trap_L-16.jpg"><P>
<A NAME=HEADING170-115></A>
<H3>Parameter-Passing Conventions for Toolbox Routines</H3>
 <A NAME=MARKER-2-80></A>All variable parameters (parameters of type <CODE>VAR</CODE>) are passed as pointers to the actual storage location. In the case of byte-sized types, parameters of type <CODE>VAR</CODE> may have odd values.<P>
 Nonvariable parameters are passed in different ways, depending on the type of the parameter. Values of type <CODE>Boolean</CODE>, elements of an enumerated type with fewer than 128 elements, and subranges within the range -128 to 127 are passed as signed byte values. Values of type <CODE>Integer</CODE> and, <CODE>Char</CODE> and all other enumerations and subranges are passed as signed word values. Pointers and values of type <CODE>LongInt</CODE> are passed as signed 32-bit values. <A HREF=#MARKER-9-1>Table 8-1</A> summarizes the parameter-passing conventions.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-1></A><B>Table 8-1 Toolbox parameter-passing conventions</B></CAPTION>
<TH>Parameter type<TH>Data object pushed on stack<TR>
<TD><CODE>Boolean</CODE><TD>Byte: range 0 to 1<TR>
<TD><CODE>Char</CODE><TD>16 bits: range 0 to 255<TR>
<TD><CODE>Integer</CODE><TD>16 bits: range -32768 to 32767<TR>
<TD><CODE>LongInt</CODE><TD>32 bits<TR>
<TD>Pointer<TD>32 bits<TR>
<TD>Enumeration: range 0 to 127<TD>Byte: range 0 to 127<TR>
<TD>Enumeration: range 0 to 32767<TD>16 bits: range 0 to 32767<TR>
<TD>Subrange: range -128 to 127<TD>16 bits: range -128 to 127<TR>
<TD>Subrange: range -32768 to 32767<TD>Word: range -32768 to 32767<TR>
<TD><CODE>Real</CODE><TD>Address of <CODE>Extended</CODE> copy<TR>
<TD><CODE>Double</CODE><TD>Address of <CODE>Extended</CODE> copy <TR>
<TD><CODE>Comp</CODE><TD>Address of <CODE>Extended</CODE> copy <TR>
<TD><CODE>Extended</CODE><TD>Address of argument<TR>
<TD><CODE>ARRAY</CODE>, <CODE>RECORD</CODE>, string \xBE 4 bytes<TD>Value (word or long word)<TR>
<TD><CODE>ARRAY</CODE>, <CODE>RECORD</CODE>, string &gt; 4 bytes<TD>Address of value<TR>
<TD><CODE>SET</CODE><TD><CODE>SET</CODE> value rounded to whole number of words</TABLE>
<P>
 A parameter of type <CODE>SET</CODE> is passed by rounding its size up to the next whole word, if necessary, then pushing its value so that the lowest-order word is pushed last. In the case of a byte-size <CODE>SET</CODE>, the called procedure accesses only the low-order half of the word that is pushed.<P>
<DL>
<DT><B>Note</B>
<DD>A byte pushed on the stack occupies the high-order byte of the word allocated for it, according to conventions for the MC680x0 microprocessors.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
<DT><B>WARNING</B>
<DD>A value of type <CODE>Char</CODE> is passed as a word value. The value occupies the low-order half of the word.<EM></EM><A NAME=MARKER-2-81></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-121></A>
<H3>Function Results</H3>
 <A NAME=MARKER-2-82></A>Function results are returned by value or by address on the stack. Space for the function result is allocated by the caller before the parameters are pushed. The caller is responsible for removing the result from the stack after the call.<P>
 For types <CODE>Boolean</CODE>, <CODE>Char</CODE>, and <CODE>Integer</CODE> and for enumerated and subrange types, the caller allocates a word on the stack to make space for the function result. Values of type <CODE>Boolean</CODE>, enumerated types with fewer than 128 elements, and subranges within the range -128 to 127 are returned as signed byte values. The value is placed in the high-order byte of the word.<P>
 Values of type <CODE>Integer</CODE> and <CODE>Char</CODE> and all enumerated and subrange types not covered above are returned as signed word values.<P>
 Pointers and values of type <CODE>LongInt</CODE> are returned as signed 32-bit values. Values of type <CODE>Real</CODE> are returned as 32-bit real values. For types whose values are greater than 4 bytes in size, the caller pushes a pointer to a temporary location into which the function places the result; these types include <CODE>Double</CODE> (8 bytes), <CODE>Comp</CODE> (8 bytes), and <CODE>Extended</CODE> (10 or 12 bytes); types <CODE>SET</CODE>, <CODE>ARRAY</CODE>, <CODE>RECORD</CODE>; and strings greater than 4 bytes in size.<P>
 For a 1-byte <CODE>SET</CODE>, for types <CODE>SET</CODE>, <CODE>ARRAY</CODE>, and <CODE>RECORD</CODE>, and for strings whose size is one word, the caller allocates a word on the stack. For types <CODE>SET</CODE>, <CODE>ARRAY</CODE>, and <CODE>RECORD</CODE> and strings whose size is two words, the caller allocates a long word on the stack.<P>
 The conventions for returning results of functions are summarized in <A HREF=#MARKER-9-2>Table 8-2</A>.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-2></A><B>Table 8-2 Conventions for returning results from Toolbox functions</B> </CAPTION>
<TH>Function result type<TH>Data object left on stack or returned through pointer on stack<TR>
<TD><CODE>Boolean</CODE><TD>Byte: range 0 to 1<TR>
<TD><CODE>Char</CODE><TD>16 bits: range 0 to 255<TR>
<TD><CODE>Integer</CODE><TD>16 bits: range -32768 to 32767<TR>
<TD><CODE>LongInt</CODE><TD>32 bits<TR>
<TD>Pointer<TD>32 bits<TR>
<TD>Enumeration: range 0 to 127<TD>Byte: range 0 to 127<TR>
<TD>Enumeration: range 0 to 32767<TD>16 bits: range 0 to 32767<TR>
<TD colspan=2>&nbsp;<TR>
<TD>Subrange: range -128 to 127<TD>Byte: range -128 to 127<TR>
<TD>Subrange: range -32768 to 32767<TD>16 bits: range -32768 to 32767<TR>
<TD><CODE>Real</CODE><TD><CODE>Real</CODE><TR>
<TD><CODE>Double</CODE><TD><CODE>Double</CODE> at address given by pointer<TR>
<TD><CODE>Comp</CODE><TD><CODE>Comp</CODE> at address given by pointer<TR>
<TD><CODE>Extended</CODE><TD><CODE>Extended</CODE> at address given by pointer<TR>
<TD><CODE>ARRAY</CODE>, <CODE>RECORD</CODE>, string \xBE 4 bytes<TD>Value (word or long word)<TR>
<TD><CODE>ARRAY</CODE>, <CODE>RECORD</CODE>, string &gt; 4 bytes<TD>Value at address given by pointer<TR>
<TD><CODE>SET</CODE>: one byte<TD>Byte value<TR>
<TD><CODE>SET</CODE>: one word<TD>16-bits value<TR>
<TD><CODE>SET</CODE>: two words<TD>32-bits value<TR>
<TD><CODE>SET</CODE> &gt; two words<TD>Value at address given by pointer</TABLE>
<P>
<DL>
<DT><B>Note</B>
<DD>A 1 byte-size return value occupies the high-order byte of the word allocated for it.<EM></EM><A NAME=MARKER-8-83></A><A NAME=MARKER-2-84></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING170-129></A>
<H3><A NAME=MARKER-9-85></A>The Auto-Pop Bit</H3>
 <A NAME=MARKER-2-86></A>The <B>auto-pop bit</B> is bit 10 in an A-line instruction for a Toolbox routine. Some language systems prefer to generate jump-subroutine calls (<CODE>JSR</CODE>) to intermediate routines, called glue routines, which then call Toolbox routines instead of executing the Toolbox routine directly. This glue method would normally interfere with Toolbox traps because the return address of the glue subroutine is placed on the stack between the Toolbox routine's parameters and the address of the place where the glue routine was called from (where control returns once the Toolbox routine has completed execution). <P>
 The auto-pop bit forces the trap dispatcher to remove the top 4 bytes from the stack before dispatching to the Toolbox routine. After the Toolbox routine completes execution, control is transferred back to the place where the glue routine was called from, not back to the glue routine.<P>
 Most development environments, including MPW, do not use this feature.<A NAME=MARKER-2-87></A><A NAME=MARKER-2-88></A><A NAME=MARKER-2-13></A><P>
<A NAME=HEADING170-133></A>
<H2>About Trap Macros</H2>
 <A NAME=MARKER-2-90></A>A <B>trap macro</B> is an assembly-language macro that assembles into an A-line instruction, used for calling a Toolbox or Operating System routine from assembly language. The names of all trap macros begin with the underscore character (_), followed by the name of the corresponding routine. As a rule, the macro name is the same as the name used to call the routine from Pascal. For example, to call the Window Manager function <CODE>NewWindow</CODE>, you should use an instruction with the macro name <CODE>_NewWindow</CODE>. There are some exceptions, however, in which the spelling of the macro differs from the name of the Pascal routine itself; these are noted in the documentation for the individual routines.<P>
 Trap macros for Toolbox routines take no arguments; any parameters must be pushed on the stack before invoking the routine. See <A HREF=#MARKER-9-76>"Calling Conventions for Stack-Based Routines" on page 8-16</A> for more information. Trap macros for Operating System routines may have as many as three optional arguments. The first argument, if present, is used to load a register with a parameter value for the routine you're calling. The remaining arguments control the settings of the various flag bits in the A-line instruction. <A NAME=MARKER-2-91></A><P>
<A NAME=HEADING170-136></A>
<H2>About Routine Selectors</H2>
 <A NAME=MARKER-2-92></A>A routine selector is a value that is pushed on the stack to select a particular routine from a group of routines to be executed. Many trap macros take routine selectors. For example, the trap macro <CODE>_HFSDispatch</CODE> has the possibility of calling 42 different system software routines. Hence, the trap macro has 42 different routine selectors. The routine selector that is passed on the stack (for <CODE>_HFSDispacth</CODE> to access) selects which of the 42 software routines <CODE>_HFSDispatch</CODE> executes.<P>
 Most system software routines that are accessed through a trap macro and a routine selector also have a corresponding macro that expands to call the original trap macro and automatically puts the correct routine selector on the stack. For example, the trap macro <CODE>_GetCatInfo</CODE> expands to call <CODE>_HFSDispatch</CODE> and places the selector $0009 on the stack after the parameters.<A NAME=MARKER-2-93></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="OSUtilities-169.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-171.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="OSUtilities-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
