<html>

<body bgcolor="#FFFFFF">

<CENTER><H1>Class next.util.DecimalNumber</H1></CENTER>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>

<!-- extends:next.util.NSNumber -->

<DL>

<DT><B>Extends:</B></DT><DD>next.util.NSNumber</DD>

</DL>

<P>

DecimalNumber, an immutable subclass of NSNumber (which itself is a private class), provides an object-oriented wrapper for doing base-10 arithmetic. An instance can represent any number that can be expressed as <I>mantissa</I>*10^<I>exponent</I> where <I>mantissa</I> is a decimal integer up to 38 digits long, and <I>exponent</I> is an integer between -128 and 127.
<P>
In the course of doing arithmetic, a method may produce calculation errors, such as division by zero. It may also meet circumstances where it has a choice of ways to round a number off. The way the method acts on such occasions is called its "behavior." 
<!--Behavior is set by methods in the NSDecimalNumberBehaviors protocol. Every NSDecimalNumber argument called behavior requires an object that conforms to this protocol. For more on behaviors, see the specifications for the NSDecimalNumberBehaviors protocol and the NSDecimalNumberHandler class. Also see the defaultBehavior method description, below.
-->
The arithmetic methods in this class do not round numbers off. They assume that your need for precision does not exceed 38 significant digits. And they raise exceptions when they try to divide by zero, or when they produce a number that is too big or small to be represented.

<!-- C Interface to Decimal Numbers
The arithmetic and rounding methods of NSDecimalNumber are also accessible through group of ordinary C functions, defined in NSDecimal.h. You might consider the C interface if you don't need to treat NSDecimalNumbers as objects-that is, if you don't need to store them in an object-oriented collection like an NSArray or NSDictionary.
You might also consider the C interface if you need maximum efficiency. The C interface is faster and uses less memory than the NSDecimalNumberClass.
If you need mutability, you can combine the two interfaces. Use functions from the C interface and convert their results to NSDecimalNumbers.
The C functions-NSDecimalCompact(), NSDecimalCompare(), NSDecimalRound(), NSDecimalNormalize(), NSDecimalAdd(), NSDecimalSubtract(), NSDecimalMultiply(), NSDecimalDivide(), NSDecimalPower(), NSDecimalMultiplyByPowerOf10(), NSDecimalString()-are all documented in the "Functions" chapter of the Foundation Framework Reference.
-->
<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- constructors -->

<a name="constructors"><CENTER><H2>CONSTRUCTORS</H2></CENTER></a>

<!-- consKey:DecimalNumber() cons:DecimalNumber descr:<TT> static  <B>DecimalNumber</B>()</TT> -->

<H3><a name="DecimalNumber()">DecimalNumber</a></H3>

   <TT> static  <B>DecimalNumber</B>()</TT>

<P>

Creates and returns a new DecimalNumber object.

<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- consKey:DecimalNumber(public) cons:DecimalNumber descr:<TT>public  <B>DecimalNumber</B>(long <I>aLong</I>, int <I>anInt</I>)</TT>:<TT>public  <B>DecimalNumber</B>(java.lang.String <I>aString</I>)</TT>:<TT>public  <B>DecimalNumber</B>()</TT> -->

<H3><a name="DecimalNumber(public)">DecimalNumber</a></H3>

<TT>public  <B>DecimalNumber</B>()</TT><br>

<TT>public  <B>DecimalNumber</B>(java.lang.String <I>aString</I>)</TT><br>

<TT>public  <B>DecimalNumber</B>(long <I>mantissa</I>, int <I>exponent</I>)</TT>

<P>

Creates and returns a new DecimalNumber object. If <I>aString</I> is supplied, the new object is initialized using <B>initWithString</B>. If <I>mantissa</I> and <I>exponent</I> are supplied, the new object is initialized using <B>initWithMantissaAndExponent</B>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- methods -->

<a name="methods"><CENTER><H2>METHODS</H2></CENTER></a>

<!-- methKey:byAdding(public) meth:byAdding descr:<TT>public static next.util.DecimalNumber <B>byAdding</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT> -->

<H3><a name="byAdding(public)">byAdding</a></H3>

<TT>public static next.util.DecimalNumber <B>byAdding</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT>

<P>

Adds <I>aDecimalNumber</I> to the receiver, and returns the sum, a newly created DecimalNumber.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:byDividingBy(public) meth:byDividingBy descr:<TT>public static next.util.DecimalNumber <B>byDividingBy</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT> -->

<H3><a name="byDividingBy(public)">byDividingBy</a></H3>

<TT>public static next.util.DecimalNumber <B>byDividingBy</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT>

<P>

Divides the receiver by <I>aDecimalNumber</I>, and returns the quotient, a newly created DecimalNumber.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:byMultiplyingBy(public) meth:byMultiplyingBy descr:<TT>public static next.util.DecimalNumber <B>byMultiplyingBy</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT> -->

<H3><a name="byMultiplyingBy(public)">byMultiplyingBy</a></H3>

<TT>public static next.util.DecimalNumber <B>byMultiplyingBy</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT>

<P>

Multiplies the receiver by <I>aDecimalNumber</I>, and returns the product, a newly created DecimalNumber.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:byMultiplyingByPowerOf10(public) meth:byMultiplyingByPowerOf10 descr:<TT>public static next.util.DecimalNumber <B>byMultiplyingByPowerOf10</B>(int <I>anInt</I>)</TT> -->

<H3><a name="byMultiplyingByPowerOf10(public)">byMultiplyingByPowerOf10</a></H3>

<TT>public static next.util.DecimalNumber <B>byMultiplyingByPowerOf10</B>(int <I>power</I>)</TT>

<P>

Multiplies the receiver by 10 raised to the power <I>power</I>, and returns the product, a newly created DecimalNumber.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:byRaisingToPower(public) meth:byRaisingToPower descr:<TT>public static next.util.DecimalNumber <B>byRaisingToPower</B>(int <I>anInt</I>)</TT> -->

<H3><a name="byRaisingToPower(public)">byRaisingToPower</a></H3>

<TT>public static next.util.DecimalNumber <B>byRaisingToPower</B>(int <I>power</I>)</TT>

<P>

Raises the receiver to <I>power</I>, and returns the result, a newly created DecimalNumber.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:bySubtracting(public) meth:bySubtracting descr:<TT>public static next.util.DecimalNumber <B>bySubtracting</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT> -->

<H3><a name="bySubtracting(public)">bySubtracting</a></H3>

<TT>public static next.util.DecimalNumber <B>bySubtracting</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT>

<P>

Subtracts <I>aDecimalNumber</I> from the receiver, and returns the difference, a newly created DecimalNumber.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:compare(public) meth:compare descr:<TT>public int <B>compare</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT> -->

<H3><a name="compare(public)">compare</a></H3>

<TT>public int <B>compare</B>(next.util.DecimalNumber <I>aDecimalNumber</I>)</TT>

<P>

Compares the receiver with
<I>aDecimalNumber</I> and returns 1 if  <I>aDecimalNumber</I> is less than the receiver, 0 if they are equal, or -1 if <I>aDecimalNumber</I> is greater than the receiver.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:doubleValue(public) meth:doubleValue descr:<TT>public double <B>doubleValue</B>()</TT> -->

<H3><a name="doubleValue(public)">doubleValue</a></H3>

<TT>public double <B>doubleValue</B>()</TT>

<P>

Returns the receiver's value as a double, converting it as necessary.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:floatValue(public) meth:floatValue descr:<TT>public float <B>floatValue</B>()</TT> -->

<H3><a name="floatValue(public)">floatValue</a></H3>

<TT>public float <B>floatValue</B>()</TT>

<P>

Returns the receiver's value as a float, converting it as necessary.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:initWithMantissaAndExponent(protected) meth:initWithMantissaAndExponent descr:<TT>protected void <B>initWithMantissaAndExponent</B>(long <I>aLong</I>, int <I>anInt</I>)</TT> -->

<H3><a name="initWithMantissaAndExponent(protected)">initWithMantissaAndExponent</a></H3>

<TT>protected void <B>initWithMantissaAndExponent</B>(long <I>mantissa</I>, int <I>exponent</I>)</TT>

<P>

Initializes the receiver to the number specified by the arguments. The arguments express a number in a type of scientific notation that requires the mantissa to be an integer. So, for example, if the number to be represented is 1.23, it's expressed as 123x10-2. Thus, <I>mantissa</I> is 123 and <I>exponent</I> is -2.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:initWithString(protected) meth:initWithString descr:<TT>protected void <B>initWithString</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="initWithString(protected)">initWithString</a></H3>

<TT>protected void <B>initWithString</B>(java.lang.String <I>aString</I>)</TT>

<P>

Returns a DecimalNumber equivalent to <I>aString</I>. Besides digits, <I>aString</I> can include an initial "+" or "-," a single "E" or "e", to indicate the exponent of a number in scientific notation, and a single decimal separator to divide the fractional from the integral part of the number. Whether the decimal separator is a period (as in the United States) or a comma (as in France) depends on the default locale.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:intValue(public) meth:intValue descr:<TT>public int <B>intValue</B>()</TT> -->

<H3><a name="intValue(public)">intValue</a></H3>

<TT>public int <B>intValue</B>()</TT>

<P>

Returns the receiver's value as an integer, converting it as necessary.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:isNaN(public) meth:isNaN descr:<TT>public boolean <B>isNaN</B>()</TT> -->

<H3><a name="isNaN(public)">isNaN</a></H3>

<TT>public boolean <B>isNaN</B>()</TT>

<P>

Returns <B>true</B> if the receiver has the value NaN (not a number), <B>false</B> otherwise.

<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:longValue(public) meth:longValue descr:<TT>public long <B>longValue</B>()</TT> -->

<H3><a name="longValue(public)">longValue</a></H3>

<TT>public long <B>longValue</B>()</TT>

<P>

Returns the receiver's value as a long integer, converting it as necessary.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:newWithOperation(protected) meth:newWithOperation descr:<TT>protected static next.util.DecimalNumber <B>newWithOperation</B>(int <I>anInt</I>, next.util.DecimalNumber <I>aDecimalNumber</I>)</TT> -->

<H3><a name="newWithOperation(protected)">newWithOperation</a></H3>

<TT>protected static next.util.DecimalNumber <B>newWithOperation</B>(int <I>operation</I>, next.util.DecimalNumber <I>aDecimalNumber</I>)</TT>

<P>

Returns a newly-created DecimalNumber that is computed from the reciever and <I>aDecimalNumber</I>. The operator used in the computation depends on <I>operation</I>; the following are valid values for <I>operation</I>:
<DL>
<DT>1</DT><DD>The result is obtained by adding <I>aDecimalNumber</I> to the receiver.</DD>
<DT>2</DT><DD>The result is obtained by subtracting <I>aDecimalNumber</I> from the receiver.</DD>
<DT>3</DT><DD>The result is obtained by multiplying the receiver by <I>aDecimalNumber</I>.</DD>
<DT>4</DT><DD>The result is obtained by dividing the receiver by  <I>aDecimalNumber</I>.</DD>
<DT>5</DT><DD>The result is obtained by converting <I>aDecimalNumber</I> to an unsigned integer, and then raising the receiver to that power.</DD>
<DT>6</DT><DD>The result is obtained by converting <I>aDecimalNumber</I> to a short, and then raising the receiver to the resulting power of 10.</DD>
</DL>
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:valueOf(public) meth:valueOf descr:<TT>public static next.util.DecimalNumber <B>valueOf</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="valueOf(public)">valueOf</a></H3>

<TT>public static next.util.DecimalNumber <B>valueOf</B>(java.lang.String <I>aString</I>)</TT>

<P>

Creates and returns a DecimalNumber equivalent to <I>aString</I>. Besides digits, <I>aString</I> can include an initial "+" or "-," a single "E" or "e", to indicate the exponent of a number in scientific notation, and a single decimal separator to divide the fractional from the integral part of the number. Whether the decimal separator is a period (as in the United States) or a comma (as in France) depends on the default locale.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html>