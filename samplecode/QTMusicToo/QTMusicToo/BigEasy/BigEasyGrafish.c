/*	File:		BigEasyGrafish.c	Contains:	xxx put contents here xxx	Written by:	xxx put writers here xxx	Copyright:	© 1991, 1994 by Apple Computer, Inc., all rights reserved.    This file is used in these builds: Warhol	Change History (most recent first):		 <6+> universal headers		 <6>	  9-8-94	dvb				 <4>	 1/20/92	dvb		Add more routines.		 <3>	 5/23/91	PH		changes for THINK 5		 <2>	 4/25/91	JB		Changing to new THINK_C interface files	To Do:*//* file: BigEasyGrafish.c * * Started 4 August 1989, more or less. * * A set of routines for doing certain * QuickDraw like operations on the Macintosh. * *//*--------------------------------	Inclusions--------------------------------*/#include <QuickDraw.h>#include <Resources.h>#include <Memory.h>#include <Palettes.h>#include <Gestalt.h>#define BigEasyGrafish#include "BigEasyGrafish.h"/*--------------------------------	Data--------------------------------*/unsigned char dGrayPat[] = {0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA};unsigned char dBlackPat[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};/*--------------------------------	Local Variables & Routines--------------------------------*/static Boolean GestaltColor(void);static Boolean gBEGHasColor;static Boolean gDoneColorGestalt = false;/*--------------------------------	Routines--------------------------------*/void RGBFore(unsigned short r,unsigned short g,unsigned short b)	{	GestaltColor();	if(gBEGHasColor || 1)		{		RGBColor c;		c.red = r;		c.green = g;		c.blue = b;		RGBForeColor(&c);		}	else		{		unsigned long x;		x = r + g + b;		if ( x > (3 * 32768))			ForeColor(whiteColor);		else			ForeColor(blackColor);		}	}void RGBBack(unsigned short r,unsigned short g,unsigned short b)	{	GestaltColor();	if(gBEGHasColor || 1)		{		RGBColor c;		c.red = r;		c.green = g;		c.blue = b;		RGBBackColor(&c);		}	else		{		unsigned long x;		x = r + g + b;		if ( x > (3 * 32768))			BackColor(whiteColor);		else			BackColor(blackColor);		}	}void GoWhite()	{	PenPat((Pattern *)dBlackPat);	ForeColor(whiteColor);	}void GoGray()	{	PenPat((Pattern *)dBlackPat);	RGBFore(32768,32768,32768);	}void GoBlack()	{	PenPat((Pattern *)dBlackPat);	ForeColor(blackColor);	}void GoBW()	{	PenNormal();	ForeColor(blackColor);	BackColor(whiteColor);	}void RGBOp(unsigned short r,unsigned short g,unsigned short b)	{	RGBColor c;	c.red = r;	c.green = g;	c.blue = b;	OpColor(&c);	}void RGBHilite(unsigned short r,unsigned short g,unsigned short b)	{	RGBColor c;	c.red = r;	c.green = g;	c.blue = b;	HiliteColor(&c);	}void PmHilite(short h)	{	PaletteHandle ph;	RGBColor c;	ph = GetPalette(FrontWindow());	GetEntryColor(ph,h,&c);	HiliteColor(&c);	}void RampColorTable(CTabHandle ctH,short start,short length,		unsigned short r1,unsigned short g1,unsigned short b1,		unsigned short r2,unsigned short g2,unsigned short b2)/*  * Make an rgb ramp in the color table handle passed.  */	{	long dr,dg,db;	short i;	ColorSpec *c;	dr = r2-r1;	dg = g2-g1;	db = b2-b1;	c = &(**ctH).ctTable[start];	for(i = 0; i< length; i++)		{		c->value = start+i;		c->rgb.red = r1+ dr*i/length;		c->rgb.green = g1+ dg*i/length;		c->rgb.blue = b1+ db*i/length;		c++;		}	}	void FrameRectOutside(Rect *r)	{	Rect r2;	PenState ps;	r2 = *r;	GetPenState(&ps);	InsetRect(&r2,-ps.pnSize.h,-ps.pnSize.v);	FrameRect(&r2);	}void DrawIcl8Resource(short id,Rect *r)/* * Draw the icl8, disregarding masks and such */	{	PixMap pm;	Handle h;	h = GetResource('icl8',id);	if(!h)		{		PaintRect(r);		return;		}	HLock(h);	pm.baseAddr = *h;	pm.rowBytes = 32 | 0x8000;	pm.bounds.top = pm.bounds.left = 0;	pm.bounds.bottom = pm.bounds.right = 32;	pm.pmVersion = 0;	pm.packType = 0;	pm.packSize = 0;	pm.hRes = pm.vRes = 0x00480000;	pm.pixelType = 0;	pm.pixelSize = 8;	pm.cmpCount = 1;	pm.cmpSize = 8;	pm.planeBytes = 0;	pm.pmTable = GetCTable(8);	pm.pmReserved = 0;	CopyBits((void *)&pm,&qd.thePort->portBits,&pm.bounds,r,0,0);	DisposeCTable(pm.pmTable);	HUnlock(h);	ReleaseResource(h);	}Boolean EasyHasColor(void)/* * In a nutshell: returns True of the * 0,0-point of the current port is * anything besides a b/w situation. */	{	GDHandle gdH;	Rect r;	Boolean b;	if(GestaltColor)		{		r = qd.thePort->portRect;		LocalToGlobal((Point *)&r.top);		LocalToGlobal((Point *)&r.bottom);		gdH = GetMaxDevice(&r);		if(gdH)			b = (**(**gdH).gdPMap).pixelSize > 1;		else			b = false;		/* not on any device... whatever */		}	else		b = false;	return b;	}Boolean GestaltColor(void)	{	long result;	if(!gDoneColorGestalt)		gBEGHasColor = (Gestalt('qdrw',&result)) ?				false : (result & (1<<gestaltHasDeepGWorlds)) != 0;	return gBEGHasColor;	}void DrawPixMap(PixMap *pm,Rect *src,Rect *dst,short mode)	{	Rect srcR,dstR;	if(src)		srcR = *src;	else		srcR = pm->bounds;	if(dst)		dstR = *dst;	else		dstR = srcR;	CopyBits((BitMap *)pm,&qd.thePort->portBits,&srcR,&dstR,mode,nil);	}void DrawPixMapOffset(PixMap *pm,short x,short y,short mode)	{	Rect r;	r = pm->bounds;	OffsetRect(&r,x,y);	DrawPixMap(pm,nil,&r,mode);	}