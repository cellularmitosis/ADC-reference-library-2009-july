<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>QuickTime VR: QuickTime VR  Programming</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="QuickTime VR  Programming"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000944-CH208" title="QuickTime VR  Programming"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../index.html#//apple_ref/doc/uid/TP30000440-TP30000433" target="_top">QuickTime</a> &gt; <a href="../../VirtualReality-date.html#//apple_ref/doc/uid/TP30000440-TP30000433-TP30000589" target="_top">Virtual Reality</a> &gt; <a href="../0Preface/QTVR-preface.html#//apple_ref/doc/uid/TP40000944-CH204-DontLinkElementID_2">QuickTime VR</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../3Chap/3-QTVR-Programming.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../6Chap/6-Creating-QTVR-Movies.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_66" title="QuickTime VR  Programming"></a><h1><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBGGDIA" title="QuickTime VR  Programming"></a>QuickTime VR  Programming</h1><p>This chapter discusses how you can add support to your application for playing QuickTime VR movies. The chapter is aimed at programmers and tool developers who want to incorporate QTVR movies in their applications, both on the Web and as standalone programs. Because QuickTime VR allows users to interactively explore and examine photorealistic, three-dimensional virtual worlds, it provides users with a content-rich, immersive experience. This offers QuickTime VR programmers and tool developers an opportunity to enhance their products by incorporating QTVR movies. </p><p>As discussed in <span class="content_text"><a href="../3Chap/3-QTVR-Programming.html#//apple_ref/doc/uid/TP40000944-CH207-BCIGFDGC">“Chapter 3, Creating QuickTime VR Panoramas and Object Movies,”</a></span> the images displayed in QuickTime VR movies can be captured either photographically or rendered on a computer using a 3D graphics package. That chapter explains some of the equipment and tools you use to capture images that you want to display in QuickTime VR movies. </p><p>This chapter is divided into the following major sections:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBFFBAH">“Displaying QuickTime VR Movies”</a></span> describes how you can add support to your application for playing QuickTime VR movies. </p></li><li class="li"><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBDDHAJ">“Defining the QTVR Movie Controller”</a></span> discusses the QuickTime VR movie controller, which is a movie controller component that manages the interface for presenting QuickTime VR movies to users and allows them to navigate and explore in those movies. </p></li><li class="li"><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAC">“Using the QuickTime VR Movie Controller”</a></span> illustrates basic ways of interacting with the QuickTime VR movie controller. In particular, it provides source code examples that show how you can hide the control bar, hide and show buttons in the control bar, and disable the automatic cursor tracking and shape changing provided by the QuickTime VR movie controller. </p></li><li class="li"><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBIEIAB">“QuickTime VR Authoring Components”</a></span> discusses the QTVR Flattener, the Multinode Splitter, and the QTVR Object Movie Compressor. </p></li><li class="li"><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBGIFIG">“QuickTime VR Manager”</a></span> discusses the QuickTime VR Manager, which is the part of QuickTime that your application can use to interact with QuickTime VR. </p></li><li class="li"><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBHEGHD">“Using the QuickTime VR Manager”</a></span> discusses some of the basic ways of using the QuickTime VR Manager. Source code examples are provided that show how you can determine whether the QuickTime VR Manager is available in the current operating environment, how you initialize the QuickTime VR Manager or display a QuickTime VR movie in a window, and how you can create QuickTime VR movie instances. </p></li></ul><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBFFBAH" title="Displaying QuickTime VR Movies"></a><h2>Displaying QuickTime VR Movies</h2><p>QuickTime VR movies, as discussed in <span class="content_text"><a href="../2Chap/2-QTVR-Authoring.html#//apple_ref/doc/uid/TP40000944-CH206-BAJGAGFA">“Chapter 2, QuickTime VR Panoramas and Object Movies,”</a></span> are simply a special kind of QuickTime movie, which means that you can add support to your application for playing QuickTime VR movies easily and with a minimum of effort. </p><p>If the QuickTime VR Manager (and hence the QuickTime VR movie controller) is available, you simply open a movie using standard QuickTime functions, call <code>NewMovieController</code> to associate the movie with the QuickTime VR movie controller, and make the appropriate call to <code>MCIsPlayerEvent</code> in your main event loop. You follow exactly these same steps to open and manage any QuickTime movie. </p><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBHIIII">Listing 4-1</a></span>shows a typical way to open a QuickTime VR movie.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_67" title="Listing 4-1Opening a QuickTime VR movie"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBHIIII" title="Listing 4-1Opening a QuickTime VR movie"></a><strong>Listing 4-1&nbsp;&nbsp;</strong>Opening a QuickTime VR movie</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_273"></a><div class="codesample"><table><tr><td scope="row"><pre>Movie MyGetMovie (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr                   myErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    SFTypeList              myTypes = {MovieFileType, 0, 0, 0};<span></span></pre></td></tr><tr><td scope="row"><pre>    StandardFileReply       myReply;<span></span></pre></td></tr><tr><td scope="row"><pre>    Movie           myMovie = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    short           myResFile;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    StandardGetFilePreview(nil, 1, myTypes, &amp;myReply);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myReply.sfGood) {<span></span></pre></td></tr><tr><td scope="row"><pre>        myErr = OpenMovieFile(&amp;myReply.sfFile, &amp;myResFile,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 fsRdPerm);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (myErr == noErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>            short   myResID = 0; //We want the first movie.<span></span></pre></td></tr><tr><td scope="row"><pre>            Str255  myName;<span></span></pre></td></tr><tr><td scope="row"><pre>            Boolean wasChanged;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            myErr = NewMovieFromFile(&amp;myMovie, myResFile,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    &amp;myResID, myName,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    newMovieActive,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    &amp;wasChanged);<span></span></pre></td></tr><tr><td scope="row"><pre>            CloseMovieFile(myResFile);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return(myMovie);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBHIIII">Listing 4-1</a></span> does not use the QuickTime VR Manager at all. Instead, it relies entirely on QuickTime’s Movie Toolbox and other Macintosh system software managers. Refer to the <em>QuickTime API Reference</em> for a complete description of the Movie Toolbox and all QuickTime functions supported by the QuickTime API. </p><p>Once you’ve opened a file containing a QuickTime VR movie, you need to call <code>NewMovieController</code> to obtain the standard user interface for playing QuickTime VR movies. It’s particularly important that you call <code>NewMovieController</code> (rather than call the Component Manager directly) for QuickTime VR movies, because QuickTime VR movies contain special information that lets QuickTime know which movie controller to load.</p><p>In your main event loop, you should pass all events to the <code>MCIsPlayerEvent</code> function, which passes user events (such as mouse movements and button clicks) to the QuickTime VR movie controller. QuickTime VR automatically changes the cursor’s shape when it is inside the movie’s boundary. As a result, your application should relinquish control of the cursor for as long as it remains in the movie’s boundary and then reset the cursor’s shape as necessary when it is moved outside the movie.</p><p>To allow the QuickTime VR movie controller to update the shape of the cursor in a timely manner, your application should pass all events, even idle events, to the <code>MCIsPlayerEvent</code> function. Alternatively, you can call the <code>MCIdle</code> function frequently.</p><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_274"></a>If you want to disable the automatic cursor tracking and shape changing provided by the QuickTime VR movie controller, you can execute the following line of code, where <code>myMC</code> is an identifier for a movie controller returned by <code>NewMovieController</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>MCDoAction(myMC, mcActionSetCursorSettingEnabled, (void*) false);<span></span></pre></td></tr></table></div><p>The <code>mcActionSetCursorSettingEnabled</code> movie controller action was introduced in QuickTime version 2.1. This chapter provides a description of how the QuickTime VR movie controller handles this and other movie controller actions.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBDDHAJ" title="Defining the QTVR Movie Controller"></a><h2>Defining the QTVR Movie Controller</h2><p>The <strong>QuickTime VR movie controller</strong> is a movie controller component that manages the interface for presenting QuickTime VR movies to users and allowing them to navigate and explore in those movies. You can use standard QuickTime movie controller functions to configure and manipulate the QuickTime VR movie controller.</p><p>If you want to customize the interface presented by the QuickTime VR movie controller (for example, to hide the control bar), you should read this section. You might also need to read this section to learn how the QuickTime VR movie controller handles movie controller actions. Your application can issue actions to access certain movie controller capabilities; your application can also install an action filter function to intercept and possibly also override movie controller actions.</p><p>This section begins by describing the appearance and behavior of the QuickTime VR movie controller. Then it describes the movie controller actions and the ways in which your application might need to issue or respond to them. The next major section <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAC">“Using the QuickTime VR Movie Controller,”</a></span> briefly illustrates how to issue a movie controller action and perform other operations on the QuickTime VR movie controller.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_68" title="Note"></a><p><strong>Note:</strong>&nbsp;For complete information on movie controllers, see the chapter “Movie Controller Components” in the book Inside Macintosh: QuickTime Components. You need to be familiar with the information in that chapter in order to use this chapter.</p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF101" title="User Controls For Easy Navigation"></a><h3>User Controls For Easy Navigation</h3><p>When QuickTime plug-in displays a QuickTime VR movie, it provides users with a set of controls shown in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBDHGFI">Figure 4-1</a></span> to manipulate VR objects and panoramas. </p><p>A VR <a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_275"></a>panorama lets the user stand in a virtual reality space, such as the view of the Eiffel Tower illustrated in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAB">Figure 4-2</a></span>, and explore immersively the dimensions of a full 360 degree panorama––panning across, as well as zooming in and out of the panorama. </p><br/><div><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_69" title="Figure 4-1The standard QTVR controller"></a><p><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBDHGFI" title="Figure 4-1The standard QTVR controller"></a><strong>Figure 4-1&nbsp;&nbsp;</strong>The standard QTVR controller</p><img src = "../art/cubic_vr_plugin02.gif" alt = "The standard QTVR controller" width="399" height="278"></div><br/><p>In QuickTime, authors can create VR panoramas in which users also have the ability to tilt up and down a full 180 degrees, so that you can see the ceiling of the cathedral as well as the floor in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAB">Figure 4-2</a></span>. The actual horizontal and vertical range is determined by the panorama itself. To look left, right, up and down, you drag with the mouse across the panorama.</p><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAB">Figure 4-2</a></span> shows an illustration of a QuickTime VR panoramic movie in Mac OS X, with various controls to manipulate the panorama. </p><br/><div><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_70" title="Figure 4-2A QuickTime VR panoramic movie in Mac OS X"></a><p><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAB" title="Figure 4-2A QuickTime VR panoramic movie in Mac OS X"></a><strong>Figure 4-2&nbsp;&nbsp;</strong>A QuickTime VR panoramic movie in Mac OS X</p><img src = "../art/iqt_im02.gif" alt = "A QuickTime VR panoramic movie in Mac OS X" width="399" height="354"></div><br/><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_276"></a>The user can navigate in a movie by dragging inside the picture, as shown in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAB">Figure 4-2</a></span>. The user can also use the control bar to perform several other operations. The control bar contains the following controls:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_277"></a>A <strong>go-back button</strong>. This control allows the user to return to the previous node. Clicking this button restores the previous static pan angle, tilt angle, and field of view. This button is enabled only for multinode movies.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_278"></a>A <strong>zoom-out button</strong>. This control allows the user to zoom out. Pressing the button causes the field of view of the displayed node to increase, thereby making the object or panorama appear to move away from the viewer.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_279"></a>A <strong>zoom-in button</strong>. This control allows the user to zoom in. Pressing the button while causes the field of view of the displayed node to decrease, thereby making the object or panorama appear to move toward the viewer.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_280"></a>A <strong>hot spot display button</strong>. This allows the user to highlight the visible hot spots. A single click toggles hot spots on; another click toggles hot spots off. This is a change in behavior from previous hot spot buttons, which displayed hot spots only while the mouse button was held down.</p></li></ul><p>The Shift key can be used to zoom in and the Control key can be used to zoom out. </p><p>In addition to these buttons, there is also a label display area (not shown in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAB">Figure 4-2</a></span>) in which helpful information can be displayed. For instance, when the cursor is over one of the buttons, the button’s name appears in the label display area. Similarly, when the cursor is over a hot spot, the hot spot’s name (if it has one) appears in the label display area.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF102" title="Loading the Movie Controller Component"></a><h3>Loading the Movie Controller Component</h3><p>As defined, the QuickTime VR movie controller is a movie controller component that manages the interface for presenting QuickTime VR movies to users and allowing them to navigate and explore in those movies. This component is stored in the QuickTime VR extension and is loaded automatically whenever an application calls <code>NewMovieController</code> with a QuickTime VR movie. </p><p>A special piece of user data in a QuickTime VR movie file indicates the movie controller to use.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF103" title="Movie Controller Actions"></a><h3>Movie Controller Actions</h3><p>A <strong>movie controller action</strong> is a constant that you can pass to a movie controller to request that the movie controller perform some action (such as modify certain movie characteristics or respond to user events). For example, you can pass the <code>mcActionSetCursorSettingEnabled</code> action to enable or disable the automatic cursor tracking and shape changing provided by the QuickTime VR movie controller.</p><p>There are two ways in which you might be concerned with these actions: your application can invoke these actions directly by calling the <code>MCDoAction</code> function; or your application can install an <strong>action filter function</strong>, which can receive any of these actions; your action filter can then either intercept the action or send it back to the movie controller for processing.</p><p>A movie controller action is usually accompanied by some parameter data. For instance, the <code>mcActionSetCursorSettingEnabled</code> action must be accompanied by a Boolean value that indicates whether to enable or disable cursor tracking and shape changing. When calling <code>MCDoAction</code>, you get or set data through the <code>params</code> parameter. Similarly, an action filter function exchanges data with a movie controller through its <code>params</code> parameter. The type and meaning of this additional parameter data are described in the individual descriptions of each movie controller action. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_71" title="Note"></a><p><strong>Note:</strong>&nbsp;For complete information on handling movie controller actions, see the chapter “Movie Controller Components” in the book Inside Macintosh: QuickTime Components.</p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBJJAAC" title="Using the QuickTime VR Movie Controller"></a><h2>Using the QuickTime VR Movie Controller</h2><p>This section illustrates basic ways of interacting with the QuickTime VR movie controller. In particular, it provides source code examples that show how you can</p><ul class="ul"><li class="li"><p>hide the control bar</p></li><li class="li"><p>hide and show buttons in the control bar</p></li><li class="li"><p>disable the automatic cursor tracking and shape changing provided by the QuickTime VR movie controller</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_72" title="Note"></a><p><strong>Note:</strong>&nbsp;The code examples shown in this section provide only very rudimentary error handling. </p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF104" title="Hiding and Showing the Control Bar"></a><h3>Hiding and Showing the Control Bar</h3><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_281"></a>You can use standard QuickTime movie component routines to hide and show the control bar associated with a QuickTime VR movie. To hide the control bar, you can call the <code>MCSetVisible</code> function, as illustrated in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBDHBEJ">Listing 4-2</a></span>.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_73" title="Listing 4-2Hiding the control bar"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBDHBEJ" title="Listing 4-2Hiding the control bar"></a><strong>Listing 4-2&nbsp;&nbsp;</strong>Hiding the control bar</p><div class="codesample"><table><tr><td scope="row"><pre>componentResult     myResult;<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean             isVisible;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>isVisible = false;<span></span></pre></td></tr><tr><td scope="row"><pre>myResult = MCSetVisible(myMC, isVisible);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF105" title="Showing and Hiding Control Bar Buttons"></a><h3>Showing and Hiding Control Bar Buttons</h3><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_282"></a><p>You can use standard QuickTime movie controller routines to hide and show specific buttons in the control bar associated with a QuickTime VR movie. The QuickTime VR movie controller automatically shows and hides some buttons, and it automatically disables some buttons that might not be appropriate for a specific movie or node. You can, however, override these automatic behaviors using the QuickTime VR Manager. </p><p>For instance, the QuickTime VR movie controller displays the speaker button (used for adjusting a movie’s volume) whenever a movie contains a sound track. It’s possible, however, that only a single node in a large multinode movie has a sound track. In that case, you might want to hide the speaker button in all nodes that do not have a sound track. Conversely, the QuickTime VR movie controller hides the speaker button if a movie does not contain a sound track. You might, however, play a sound loaded from a sound resource or from another QuickTime file. In that case, you might want to show the speaker button and have it control the sound you’re playing. In both these cases, you need to override the default behavior of the QuickTime VR movie controller.</p><p>Note first that every VR movie has two sets of movie controller flags: a set of control flags and a set of explicit flags. If a bit in the set of control flags is set (that is, equal to 1), then the associated action or property is enabled. For instance, bit 17 (<code>mcFlagQTVRSuppressZoomBtns</code>) means to suppress the zoom buttons. So, if that bit is set in a VR movie’s control flags, the zoom buttons are not displayed. If that bit is clear, the zoom buttons are displayed.</p><p>However, the QuickTime VR movie controller sometimes suppresses buttons even when those buttons have not been explicitly suppressed in the control flags. As already mentioned, if a particular VR movie does not contain a sound track, then the movie controller automatically suppresses the speaker button. If a movie does contain a sound track, then the speaker button is displayed only if the suppress speaker bit is off.</p><p>For instance, if your application is playing a sound that it loaded from a sound resource, you might want the user to be able to adjust the sound’s volume using the volume control. To do that, you need a way to force the speaker button to appear. For this reason, the explicit flags were introduced.</p><p>The explicit flags indicate which bits in the control flags are to be used explicitly (that is, taken at face value). If a certain bit is set in a movie’s explicit flags, then the corresponding bit in the control flags is interpreted as the desired setting for the feature (and the movie controller does not attempt to do anything clever). In other words, if bit 17 is set in a movie’s explicit flags and bit 17 is clear in that movie’s control flags, then the zoom buttons are always displayed. Similarly, if bit 2 is set in a movie’s explicit flags and bit 2 is clear in that movie’s control flags, then the speaker button is displayed, whether or not the movie contains a sound track.</p><p>To get or set a bit in a movie’s explicit flags, you must set the flag <code>mcFlagQTVRExplicitFlagSet</code> in your call to <code>mcActionGetFlags</code> or <code>mcActionSetFlags</code>. To get or set a bit in a movie’s control flags, you must clear the flag <code>mcFlagQTVRExplicitFlagSet</code> in your call to <code>mcActionGetFlags</code> or <code>mcActionSetFlags</code>. Note that when you use the defined constants to set values in the explicit flags, the constant names might be confusing. For instance, setting the bit <code>mcFlagSuppressSpeakerButton</code> in a movie’s explicit flags doesn’t cause the speaker to be suppressed; it just means: “use the actual value of the <code>mcFlagSuppressSpeakerButton</code> bit in the control flags.”</p><p>Now you can see how to hide or show a button in the control bar: set the appropriate explicit flag to 1 and set the corresponding control flag to the desired value. <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBCACED">Listing 4-3</a></span> shows how to force a specific button in the control bar  to be displayed.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_74" title="Listing 4-3Showing a control bar button"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBCACED" title="Listing 4-3Showing a control bar button"></a><strong>Listing 4-3&nbsp;&nbsp;</strong>Showing a control bar button</p><div class="codesample"><table><tr><td scope="row"><pre>void ShowControllerButton (MovieController theMC, long theButton)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    long    myControllerFlags;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the current explicit flags<span></span></pre></td></tr><tr><td scope="row"><pre>    // and set the explicit flag for the specified button.<span></span></pre></td></tr><tr><td scope="row"><pre>    myControllerFlags = mcFlagQTVRExplicitFlagSet;<span></span></pre></td></tr><tr><td scope="row"><pre>    MCDoAction(theMC, mcActionGetFlags, &amp;myControllerFlags);<span></span></pre></td></tr><tr><td scope="row"><pre>    MCDoAction(theMC, mcActionSetFlags,<span></span></pre></td></tr><tr><td scope="row"><pre>            (void *)((myControllerFlags | theButton) |<span></span></pre></td></tr><tr><td scope="row"><pre>                        mcFlagQTVRExplicitFlagSet));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the current control flags<span></span></pre></td></tr><tr><td scope="row"><pre>    // and clear the suppress flag for the specified button.<span></span></pre></td></tr><tr><td scope="row"><pre>    myControllerFlags = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    MCDoAction(theMC, mcActionGetFlags, &amp;myControllerFlags);<span></span></pre></td></tr><tr><td scope="row"><pre>    MCDoAction(theMC, mcActionSetFlags,<span></span></pre></td></tr><tr><td scope="row"><pre>                (void *)(myControllerFlags &amp; ~theButton));<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBDBDCA">Listing 4-4</a></span> shows how to force a specific button in the control bar to be hidden. Because the suppress flag overrides the setting of the explicit flag, this routine sets only the suppress flag and doesn’t bother with the explicit flag.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_75" title="Listing 4-4Hiding a control bar button"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBDBDCA" title="Listing 4-4Hiding a control bar button"></a><strong>Listing 4-4&nbsp;&nbsp;</strong>Hiding a control bar button</p><div class="codesample"><table><tr><td scope="row"><pre>void HideControllerButton (MovieController theMC, long theButton)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    long    myControllerFlags;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the current control flags<span></span></pre></td></tr><tr><td scope="row"><pre>    // and set the suppress flag for the specified button.<span></span></pre></td></tr><tr><td scope="row"><pre>    myControllerFlags = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    MCDoAction(theMC, mcActionGetFlags, &amp;myControllerFlags);<span></span></pre></td></tr><tr><td scope="row"><pre>    MCDoAction(theMC, mcActionSetFlags,<span></span></pre></td></tr><tr><td scope="row"><pre>            (void *)((myControllerFlags | theButton));<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF106" title="Sending Actions to the QuickTime VR  Movie Controller"></a><h3>Sending Actions to the QuickTime VR  Movie Controller</h3><p>You can use the <code>MCDoAction</code> function to send a movie controller action to a movie controller. For example, you can execute this line of code to disable the automatic cursor tracking and shape changing provided by the QuickTime VR movie controller:</p><div class="codesample"><table><tr><td scope="row"><pre>MCDoAction(myMC, mcActionSetCursorSettingEnabled, (void*) false);<span></span></pre></td></tr></table></div><p>In this example, the <code>myMC</code> parameter is an identifier for the QuickTime VR movie controller, returned by a previous call to <code>NewMovieController. </code></p><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBIEIAB" title="QuickTime VR Authoring Components "></a><h2>QuickTime VR Authoring Components </h2><p>There are three QTVR authoring components, which were introduced in QuickTime 5: </p><ul class="ul"><li class="li"><p>QTVR Flattener, which is a movie export component that converts an existing QuickTime VR single node movie into a new movie optimized for the Web </p></li><li class="li"><p>Multinode Splitter, also a movie export component </p></li><li class="li"><p>QTVR Object Movie Compressor </p></li></ul><p>All three components are contained in the file QuickTime VR and are installed if the user chooses Select All in the Custom Install option. </p><p>As movie exporters, these authoring components can be demonstrated using QuickTime Pro, or a custom application by opening a QuickTime VR movie and then choosing Export from the File menu. You can then choose the particular exporter by selecting it from the Export: pop-up menu in the Export File dialog.</p><p>The pop-up menu includes these choices:</p><ul class="ul"><li class="li"><p>Movie to Fast-Start QuickTime VR movie (the Flattener). Appears for all single node panorama and object movies. </p></li><li class="li"><p>Movie to Separate Single-Node Movies (The Multinode Splitter). Appears only for 2.0 format multinode movies. </p></li><li class="li"><p>Movie to QuickTime VR Object Movie (Object Movie Compressor). Appears only for 2.0 format object movies. </p></li></ul><p>Once an export method is selected, you can click the Options button to bring up a dialog where you can choose options specific to the given exporter.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF107" title="The QTVR Flattener"></a><h3>The QTVR Flattener</h3><p>The QTVR Flattener is a movie export component that converts an existing QuickTime VR single node movie into a new movie that is optimized for the Web. The flattener re-orders media samples; and for panoramas the flattener creates a small preview of the panorama. When viewed on the Web, this preview appears after 5% to 10% of the movie data has been downloaded, allowing users to see a lower-resolution version of the panorama before the full resolution version is available. </p><p>To use the QTVR Flattener from your application, you first create a <a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_283"></a>QuickTime VR movie, then open the QTVR Flattener component and call the <code>MovieExportToFile</code> routine, as shown in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBIEECJ">Listing 4-5</a></span>.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_76" title="Listing 4-5Using the QTVR flattener "></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBIEECJ" title="Listing 4-5Using the QTVR flattener "></a><strong>Listing 4-5&nbsp;&nbsp;</strong>Using the QTVR flattener </p><div class="codesample"><table><tr><td scope="row"><pre>ComponentDescription desc;<span></span></pre></td></tr><tr><td scope="row"><pre>Component flattener;<span></span></pre></td></tr><tr><td scope="row"><pre>ComponentInstance qtvrExport = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>desc.componentType = MovieExportType;<span></span></pre></td></tr><tr><td scope="row"><pre>desc.componentSubType = MovieFileType;<span></span></pre></td></tr><tr><td scope="row"><pre>desc.componentManufacturer = QTVRFlattenerType;<span></span></pre></td></tr><tr><td scope="row"><pre>flattener = FindNextComponent(nil, &amp;desc);<span></span></pre></td></tr><tr><td scope="row"><pre>if (flattener) qtvrExport = OpenComponent (flattener);<span></span></pre></td></tr><tr><td scope="row"><pre>if (qtvrExport)<span></span></pre></td></tr><tr><td scope="row"><pre>    MovieExportToFile (qtvrExport, &amp;myFileSpec, myQTVRMovie, nil, 0, 0);<span></span></pre></td></tr></table></div><p>The code snippet shown in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBIEECJ">Listing 4-5</a></span> creates a flattened movie file specified by the <code>myFileSpec</code> parameter. If your QuickTime VR movie is a panorama, the flattened movie file includes a quarter size, blurred JPEG, compressed preview of the panorama image.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_77" title="Note"></a><p><strong>Note:</strong>&nbsp;The constants <code>MovieExportType</code> and <code>MovieFileType</code> used in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBIEECJ">Listing 4-5</a></span> are defined in the header files <code>QuickTimeComponents.h</code> and <code>Movies.h</code>, respectively, and are defined as <code>'spit'</code> and <code>'MooV'</code>. </p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF108" title="Presenting Users with the QTVR Flattener Dialog Box"></a><h4>Presenting Users with the QTVR Flattener Dialog Box</h4><p>You can present users with the QTVR Flattener’s own dialog box. This allows users to choose options such as how to compress the preview image or to select a separate preview image file. </p><p>To show the dialog box, use the following line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>err = MovieExportDoUserDialog (qtvrExport, myQTVRMovie, nil, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                0, &amp;cancel);<span></span></pre></td></tr></table></div><p>If the user cancels the dialog box, then the Boolean cancel is set to <code>true</code>.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF109" title="Communicating Directly with the Component"></a><h4>Communicating Directly with the Component</h4><p>If you don’t want to present the user with the flattener’s dialog box, you can communicate directly with the component by using the <code>MovieExportSetSettingsFromAtomContainer</code> routine as described next.</p><p>If you want to specify a preview image other than the default, you need to create a special atom container and then call <code>MovieExportSetSettingsFromAtomContainer</code> before calling <code>MovieExportToFile</code>. You can specify how to compress the image, what resolution to use, and you can even specify your own preview image file to be used. The atom container you pass in can have various atoms that specify certain export options. These atoms must all be children of a flattener settings parent atom. </p><p>The preview resolution atom is a 16-bit, big-endian value that allows you to specify the resolution of the preview image. This value, which defaults to <code>kQTVRQuarterRes</code>, indicates how much to reduce the preview image. Note that <code><a href="../../Reference/QTRef_VirtualReality/Reference/reference.html#//apple_ref/doc/c_ref/kQTVRQuarterRes" target="_top">kQTVRQuarterRes</a></code> is defined as 4, implying that you can replace this with 5, for example, yielding a 1/6 resolution fast-start preview. </p><p>The blur preview atom is a Boolean value that indicates whether to blur the image before compressing. Blurring usually results in a much more highly compressed image. The default value is <code>true</code>.</p><p>The create preview atom is a Boolean value that indicates whether a preview image should be created. The default value is <code>true</code>.</p><p>The import preview atom is a Boolean value that is used to indicate that the preview image should be imported from an external file rather than generated from the image in the panorama file itself. This allows you to have any image you want as the preview for the panorama. You can specify which file to use by also including the import specification atom, which is an <code>FSSpec</code> data structure that identifies the image file. If you do not include this atom, then the flattener presents the user with a dialog box asking the user to select a file. The default for import preview is <code>false.</code> If an import file is used, the image is used at its natural size and the resolution setting is ignored.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF110" title="Sample Atom Container for the QTVR Flattener"></a><h4>Sample Atom Container for the QTVR Flattener</h4><p>The sample code in<span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJAGAJ">Listing 4-6</a></span> creates an <a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_284"></a>atom container and adds atoms to indicate an import preview file for the flattener to use.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_78" title="Listing 4-6Specifying a preview file for the flattener to use "></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBJAGAJ" title="Listing 4-6Specifying a preview file for the flattener to use "></a><strong>Listing 4-6&nbsp;&nbsp;</strong>Specifying a preview file for the flattener to use </p><div class="codesample"><table><tr><td scope="row"><pre>Boolean yes = true;<span></span></pre></td></tr><tr><td scope="row"><pre>QTAtomContainer exportData;<span></span></pre></td></tr><tr><td scope="row"><pre>QTAtom parent;<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTNewAtomContainer(&amp;exportData);<span></span></pre></td></tr><tr><td scope="row"><pre>// create a parent for the other settings atoms<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTInsertChild (exportData, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>                    QTVRFlattenerParentAtomType, 1, 0, 0, nil, &amp;parent);<span></span></pre></td></tr><tr><td scope="row"><pre>// Add child atom to indicate we want to import the preview from a file<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTInsertChild (exportData, parent, QTVRImportPreviewAtomType, 1, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                    sizeof (yes), &amp;yes, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>// Add child atom to tell which file to import<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTInsertChild (exportData, parent, QTVRImportSpecAtomType, 1, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                    sizeof (previewSpec), &amp;previewSpec, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>// Tell the export component<span></span></pre></td></tr><tr><td scope="row"><pre>MovieExportSetSettingsFromAtomContainer (qtvrExport, exportData);<span></span></pre></td></tr></table></div><p>Overriding the compression settings is a bit more complicated. You need to open a standard image compression dialog component and make calls to obtain an atom container that you can then pass to the QTVR Flattener component.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_79" title="Listing 4-7Overriding the compression settings "></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF126" title="Listing 4-7Overriding the compression settings "></a><strong>Listing 4-7&nbsp;&nbsp;</strong>Overriding the compression settings </p><div class="codesample"><table><tr><td scope="row"><pre>ComponentInstance sc;<span></span></pre></td></tr><tr><td scope="row"><pre>QTAtomContainer compressorData;<span></span></pre></td></tr><tr><td scope="row"><pre>SCSpatialSettings ss;<span></span></pre></td></tr><tr><td scope="row"><pre>sc = OpenDefaultComponent(StandardCompressionType,StandardCompressionSubType);<span></span></pre></td></tr><tr><td scope="row"><pre>ss.codecType = kCinepakCodecType;<span></span></pre></td></tr><tr><td scope="row"><pre>ss.codec = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>ss.depth = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>ss.spatialQuality = codecHighQuality<span></span></pre></td></tr><tr><td scope="row"><pre>err = SCSetInfo(sc, scSpatialSettingsType, &amp;ss);<span></span></pre></td></tr><tr><td scope="row"><pre>err = SCGetSettingsAsAtomContainer(sc, &amp;compressorData);<span></span></pre></td></tr><tr><td scope="row"><pre>MovieExportSetSettingsFromAtomContainer (qtvrExport, compressorData);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF111" title="The QTVR Multinode Splitter"></a><h3>The QTVR Multinode Splitter</h3><p>The QTVR Splitter, a movie export component, takes a QTVR version 2.x multinode movie and exports a set of single-node movies with relative URL links to each other. </p><p>The QTVR Splitter works by changing all of the link hot spots to URL hotspots, leaving any previously defined URL or undefined (blob) hot spots unchanged. If the QTVR Flattener component is present, the Splitter gives you the option of using it to add fast-start data to the movies, including previews for panorama nodes. Additionally, the Splitter will generate a text file with HTML embed tags for each movie created.</p><p>When you display the movies’ output by the Splitter using the QuickTime plug-in, clicking the relative URL links opens the other nodes in the browser window. When loaded in a frame, the Plugin loads the new movies in the same frame. </p><p>When the user clicks a link which displays a multinode movie split this way, the first thing to download is the hot spot track, which is live immediately. Then any preview data is downloaded, and finally the tiles download in and are placed over the background grid or preview. The user can jump to another node at any time, and only the nodes they visit are downloaded, unlike a multinode movie, which does not allow navigation until the entire file has downloaded, and therefore downloads all of the nodes, whether the user visits them or not. </p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF112" title="Advantages of a Multinode Movie"></a><h4>Advantages of a Multinode Movie</h4><p>The one significant advantage of a multinode movie is that when the user jumps to a new node the movie opens to the destination view defined in the authoring process. This can be overcome by specifying view angles in the embed tag (with a new page for each movie which links to it), and the Splitter can do this for you.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF113" title="Using the QTVR Splitter"></a><h4>Using the QTVR Splitter</h4><p>As discussed, the QTVR Splitter is a movie export component. When the QuickTime VR Authoring extension is placed in your QuickTime Extensions Folder, any application that uses movie exporters will have access to it. The instructions outlined here use the QuickTime Player Pro application to demonstrate its usage. You begin by creating a multinode movie, using a QuickTime VR tool.</p><p>To split the movie:</p><ol class="ol"><li class="li"><p>Open any QTVR version 2.0+ multinode movie in the QuickTime Player Pro application. Version 1.0 multinode movies can be converted to version 2.1 using the QTVR Converter component, which is part of the QuickTime VR Authoring Studio, or ConVRter from Sumware, a third-party developer.</p></li><li class="li"><p>Choose Export... from the File menu. Choose Separate Single-node movies from the popup menu at the bottom of the Export dialog. The file name you specify here will be edited by the Splitter to assure Internet compatibility. Spaces will be converted to underscores, other dangerous characters will be removed, and the resulting name will be truncated to allow the node number to be appended. Take this into account in order to wind up with useful file names at the end of the process.</p></li><li class="li"><p>Clicking the options... button opens the splitters settings dialog. </p><ol class="ol"><li class="ol ol"><p>Generate HTML Embed tags: The splitter will write out a text file including an embed tag for each movie which can be copied and pasted into your HTML pages. Useful data included are the sizes of the movies as well as all of the hot spots and their URLs. Although the URLs are included in the movies, this list can be helpful if you want to override a URL or provide one for an undefined hot spot.</p></li><li class="ol ol"><p>Overwrite Files with matching names: Since the Splitter creates names that are different from the name you specify in the dialog, there is no “replace” confirmation. Leaving this box checked allows the Splitter to overwrite files which have the same names as those it is creating. Since these names are pretty unusual, the chances are that the only files it will overwrite are those created by it from the same source movie. Unchecking this box will cause the Splitter to abort its operation if it runs into a file with a matching name.</p></li><li class="ol ol"><p>Use QTVR Flattener: The Splitter will use the QTVR Flattener to add fast-start data to the files exported, along with an optional preview track for any panorama nodes. Clicking the options... button will open the Flattener’s settings dialog. If this is unchecked, it will be flattened with the generic QuickTime flattener rather than QuickTime VR. </p></li></ol></li><li class="li"><p>Click OK and let the Splitter do its work.</p></li><li class="li"><p>Test the movies by dragging the first node into a browser window.</p></li></ol><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF114" title="Displaying Movies in Web Pages"></a><h4>Displaying Movies in Web Pages</h4><p>Now you put all of the movies in the same directory together. Do not change any of the names. Even changing capitalization will break the references. If you need different names, go back and repeat the process with a different starting name.</p><p>There are a few ways to go about displaying the movie in your Web pages. The simplest (and least attractive) approach is to put a link to the first node in one of your pages:</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;A href src="my_scene_127.mov">click to view the QTVR scene"&lt;/a><span></span></pre></td></tr></table></div><p>This causes the Plugin to open the movie in an empty browser window. Clicking any URL links loads the new movies in the same place. </p><p>You can improve the user experience significantly by embedding the movies in your pages:</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;Embed src="my_scene_127.mov"...<span></span></pre></td></tr></table></div><p>You copy and paste the embed tags provided in the HTML file written by the Splitter. In this case, the Plugin displays the movie in place like a graphic. However, when you click a URL link the new movie will be loaded in a blank window like the above case.</p><p>To remedy this, either override the URLs in the movies with links to pages with the other nodes embedded in them (a bit of work), or display the movies in a frame. </p><p>To load the movies in a frame, just use the first one as a frame source (instead of an HTML source with it embedded):</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;frameset>...<span></span></pre></td></tr></table></div><p>Now the movies will all load in that frame, providing a smooth experience for the user.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF115" title="QuickTime VR Object Movie Compressor"></a><h3>QuickTime VR Object Movie Compressor</h3><p>The QuickTime VR Object Movie Compressor, a movie export component, takes a multirow object movie and compresses frames in multi-dimensions with the goal of making the file smaller. It includes the user settings dialog box shown in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBDGFEG">Figure 4-3</a></span>. </p><br/><div><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_80" title="Figure 4-3The new QTVR Object Compression user Settings dialog box"></a><p><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBDGFEG" title="Figure 4-3The new QTVR Object Compression user Settings dialog box"></a><strong>Figure 4-3&nbsp;&nbsp;</strong>The new QTVR Object Compression user Settings dialog box</p><img src = "../art/qtvr-obj-dialog.jpg" alt = "The new QTVR Object Compression user Settings dialog box" ></div><br/><p>The user settings for the QuickTime VR Object Movie Compressor include:</p><ul class="spaceabove"><li class="li"><p>The Standard Compression Setting, which is set by clicking on the Compression Setting button.</p></li><li class="li"><p>The target file size of the compressed VR object movie, which is specified as:</p><div class="codesample"><table><tr><td scope="row"><pre>kQTVRObjExporterSettingsTargetSize = FOUR_CHAR_CODE('tsiz')<span></span></pre></td></tr></table></div></li><li class="li"><p>The Block Size Setting, which can also be set from a QT atom container, controls the dimensions of the compression: </p><div class="codesample"><table><tr><td scope="row"><pre>    long: blockSize<span></span></pre></td></tr><tr><td scope="row"><pre>    type: ‘bsiz’<span></span></pre></td></tr><tr><td scope="row"><pre>    Valid Value: 1, 2, 3, 4 which correspond to the block size of<span></span></pre></td></tr><tr><td scope="row"><pre>                 1x1, 3x3, 5x5, 7x7<span></span></pre></td></tr></table></div></li></ul><p>Note that this only works for codecs that can do interframe compression: in particular, it will not work for Photo-JPEG. </p><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBGIFIG" title="QuickTime VR Manager"></a><h2>QuickTime VR Manager</h2><p>This section discusses the QuickTime VR Manager, the part of QuickTime that your application can use to interact with QuickTime VR. </p><p>You can use the QuickTime VR Manager—in conjunction with QuickTime—to open and display QuickTime VR objects and panoramas, change the viewing angle or zoom level, handle mouse events for QuickTime VR movies, and perform other operations on these movies.</p><p>To use the information in this section, you need to know how to open and display QuickTime movies, because QuickTime VR objects and panoramas are stored as QuickTime movie tracks. If you need direct access to the movie data stored in an atom container, you also need to be familiar with the atom routines introduced in QuickTime version 2.1. </p><p>See the <em>QuickTime API Reference</em> for information about the atom routines. The Reference is available at </p><p><span class="content_text"><a href="../../../../documentation/QuickTime/QuickTime.html" target="_top">http://developer.apple.com/documentation/QuickTime/QuickTime.html</a></span></p><p>See also <span class="content_text"><a href="../7Chap/7-QTVR-atoms-file-format.html#//apple_ref/doc/uid/TP40000944-CH211-BAJJCAGC">“Chapter 7, QTVR Atom Containers,”</a></span> in this book for a description of the atom containers in a QuickTime VR movie file.</p><p>The QuickTime VR Manager is the part of QuickTime that you can use to control QuickTime VR movies from your application. For example, you can use the QuickTime VR Manager to</p><ul class="ul"><li class="li"><p>display movies of panoramas and objects</p></li><li class="li"><p>perform basic orientation, positioning, and animation control</p></li><li class="li"><p>intercept and override QuickTime VR’s mouse-tracking and default hot spot behaviors</p></li><li class="li"><p>composite flat or perspective overlays (such as QuickDraw 3D objects or QuickTime movies)</p></li><li class="li"><p>specify transition effects</p></li><li class="li"><p>control QuickTime VR’s memory usage</p></li><li class="li"><p>intercept calls to some QuickTime VR Manager functions and modify their behavior</p></li></ul><p><span class="content_text"><a href="../6Chap/6-Creating-QTVR-Movies.html#//apple_ref/doc/uid/TP40000944-CH209-BCIBDDFI">“Chapter 5, QuickTime VR Movie Structure,”</a></span> describes the QuickTime VR file format (the format of the movie files that contain QuickTime VR movies). You need this information only if you need to parse existing QuickTime VR movies or you want to create QuickTime VR movies programmatically. For instance, you need this information if you are developing QuickTime VR movie-authoring software. In general, however, you don’t need to know about the format of atoms or atom containers simply to use the functions provided by the QuickTime VR Manager.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF116" title="Overview of the QuickTime VR Manager"></a><h3>Overview of the QuickTime VR Manager</h3><p>The QuickTime VR Manager is the part of QuickTime that provides an API for controlling QuickTime VR objects and panoramas. You can use the QuickTime VR Manager to</p><ul class="spaceabove"><li class="li"><p>perform basic orientation, positioning, and animation control</p></li><li class="li"><p>intercept and override QuickTime VR’s mouse tracking</p></li><li class="li"><p>modify the display quality</p></li><li class="li"><p>intercept and override QuickTime VR’s default hot spot behavior</p></li><li class="li"><p>composite flat or perspective overlays (such as QuickDraw 3D objects or QuickTime movies)</p></li><li class="li"><p>specify transition effects</p></li><li class="li"><p>get the viewing limits of a node and get and set a node’s viewing constraints</p></li><li class="li"><p>control QuickTime VR’s memory usage</p></li><li class="li"><p>intercept calls to some QuickTime VR Manager functions and modify their behavior</p></li></ul><p>This section describes the main concepts that you need to be familiar with in order to use the QuickTime VR Manager. See <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBHEGHD">“Using the QuickTime VR Manager”</a></span> for code examples showing how to use the QuickTime VR Manager.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_81" title="Important:"></a><p><strong>Important:</strong>&nbsp;You don’t need to use the QuickTime VR Manager simply to open and display a QuickTime VR movie. The QuickTime VR movie controller automatically provides the basic mouse-and-keyboard-driven interface and handles all necessary memory allocation. You need to use the QuickTime VR Manager only if you want to exercise programmatic control over object or panoramic nodes. </p><p></p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF117" title="QuickTime VR Movie Instances"></a><h3>QuickTime VR Movie Instances</h3><p>Almost all the QuickTime VR Manager’s functions operate on a QuickTime VR movie instance (defined by the <code>QTVRInstance</code> data type). A QuickTime VR movie instance is an identifier for a particular QuickTime VR movie. You obtain a QuickTime VR movie instance by calling the <code>QTVRGetQTVRInstance</code> function. (See <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBDBDFE">“Creating QuickTime VR Movie Instances”</a></span> for an example.)</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_82" title="Important:"></a><p><strong>Important:</strong>&nbsp;There is no need to dispose of a movie instance that you’ve obtained by calling <code>QTVRGetQTVRInstance.</code></p><p></p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF118" title="Buffers"></a><h3>Buffers</h3><p>For panoramic nodes, QuickTime VR maintains several buffers that it uses to hold the panoramic image before and after the warping that is applied to correct the cylindrical distortion of the original panoramic image. All or part of the uncorrected panoramic image is stored in QuickTime VR’s back buffer. The corrected image for a particular view (that is, for a particular pan angle, tilt angle, and field of view) is stored in another buffer, the prescreen buffer (or front buffer). During screen updates, the contents of the prescreen buffer are copied into the graphics world associated with the panoramic node. Sometimes, this process is optimized to bypass the pre-screen buffer, going directly from back buffer to the screen. </p><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBEFJGI">Figure 4-4</a></span> illustrates the internal buffers maintained by QuickTime VR.</p><br/><div><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_83" title="Figure 4-4QuickTime VR&acirc;&#128;&#153;s internal buffers"></a><p><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBEFJGI" title="Figure 4-4QuickTime VR&acirc;&#128;&#153;s internal buffers"></a><strong>Figure 4-4&nbsp;&nbsp;</strong>QuickTime VR’s internal buffers</p><img src = "../art/qtvr_ls_12.gif" alt = "QuickTime VR’s internal buffers" width="495" height="188"></div><br/><p>The QuickTime VR Manager allows applications limited access to the contents of the back and prescreen buffers. You can draw directly into the back buffer by installing a back buffer imaging procedure, which is called at preestablished times (for instance, whenever an update event occurs for the window containing the movie). You can also draw directly into the prescreen buffer by installing a prescreen buffer imaging completion procedure, which is called each time QuickTime VR is finished drawing an image into the prescreen buffer. You can use a prescreen buffer imaging completion procedure to add graphical elements to an image before it is copied to the screen.</p><p>Note that this type of access is not encouraged, and is not available for cubic panoramas. </p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF119" title="Memory Management"></a><h3>Memory Management</h3><p>QuickTime VR can require large amounts of memory to store its internal representation of the uncorrected image associated with a panoramic node, which is stored in the back buffer. To provide flexibility when operating with limited amounts of memory, a movie’s author can include several different resolutions of an image, in different video tracks in the movie file. By default, QuickTime VR selects the highest resolution image available. When memory is limited, however, QuickTime VR selects the image with the highest resolution that fits into the memory it can allocate for its back buffer.</p><p>The QuickTime VR Manager provides functions that you can use to determine what resolutions are available and to get and set the current resolution of a panoramic node. You can also use QuickTime VR Manager functions to override the default behavior for loading data into the back buffer. By default, if enough memory is available, QuickTime VR allocates a back buffer that is large enough to hold the entire uncorrected panoramic image.<a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_285"></a></p><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBHEGHD" title="Using the QuickTime VR Manager"></a><h2>Using the QuickTime VR Manager</h2><p>This section illustrates some of the basic ways of using the QuickTime VR Manager. In particular, it provides source code examples that show how you can</p><ul class="ul"><li class="li"><p>determine whether the QuickTime VR Manager is available in the current operating environment</p></li><li class="li"><p>initialize the QuickTime VR Manager</p></li><li class="li"><p>display a QuickTime VR movie in a window</p></li><li class="li"><p>create QuickTime VR movie instances</p></li><li class="li"><p>manipulate a node’s pan and tilt angles</p></li><li class="li"><p>zoom in and out</p></li><li class="li"><p>install an intercept procedure</p></li><li class="li"><p>define node-entering and node-leaving procedures</p></li><li class="li"><p>manage QuickTime VR’s panoramic image buffers</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_84" title="Note"></a><p><strong>Note:</strong>&nbsp;The code examples shown in this section provide only rudimentary error handling.</p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF120" title="Determining If The QuickTime VR  Manager Is Available"></a><h3>Determining If The QuickTime VR  Manager Is Available</h3><p>Before calling any QuickTime VR Manager routines, you need to verify that the QuickTime VR Manager is available in the current operating environment and that it has the capabilities you need. For the Mac OS, you can verify that the QuickTime VR Manager is available by calling the <code>Gestalt</code> function with the <code>gestaltQTVRMgrAttr</code> selector. <code>Gestalt</code> returns, in its second parameter, a long word whose value encodes the attributes of the QuickTime VR Manager. <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBEICIA">Listing 4-8</a></span> illustrates how to determine whether the QuickTime VR Manager is available.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_85" title="Listing 4-8Checking for the availability of the QuickTime VR Manager"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBEICIA" title="Listing 4-8Checking for the availability of the QuickTime VR Manager"></a><strong>Listing 4-8&nbsp;&nbsp;</strong>Checking for the availability of the QuickTime VR Manager</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_286"></a><div class="codesample"><table><tr><td scope="row"><pre>Boolean MyHasQTVRManager (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr           myErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    long            myAttrs;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean         myHasQTVRMgr = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    myErr = Gestalt(gestaltQTVRMgrAttr, &amp;myAttrs);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myErr == noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        if (myAttrs &amp; (1 &lt;&lt; gestaltQTVRMgrPresent))<span></span></pre></td></tr><tr><td scope="row"><pre>            myHasQTVRMgr = true;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return myHasQTVRMgr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>You can also use the <code>Gestalt</code> function to get information about other attributes of the QuickTime VR Manager. The <code>Gestalt</code> function is available with all operating systems. On those systems that require a call to <code>InitializeQTML</code>, <code>Gestalt</code> is available after calling <code>InitializeQTML</code>. On those systems, calling <code>InitializeQTVR</code> is still required after calling <code>Gestalt</code>, and the value returned from <code>InitializeQTVR</code> must be checked even when the call to <code>Gestalt</code> is successful, so the call to <code>Gestalt</code> is not necessary, but it can be useful in determining the version and features of the QuickTime VR software that is installed. </p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF121" title="Initializing the QuickTime VR Manager"></a><h3>Initializing the QuickTime VR Manager</h3><p>In a Windows environment, before your application can call any QuickTime VR Manager routines, you have to call <code>InitializeQTVR</code> so that QuickTime VR can set up its internal data structures. If you make any other calls to the QuickTime VR Manager before calling <code>InitializeQTVR</code>, those calls return either a numerical value of zero or an error code of –30555 (<code>qtvrUninitialized</code>), which indicates that QuickTime VR has not been initialized. Similarly, functions with Boolean return types return <code>false</code> and functions with OSType return types return <code>'????'</code>.</p><p>When your application or process has finished using QuickTime VR, it should call <code>TerminateQTVR</code>. </p><p>You can call <code>InitializeQTVR</code> and <code>TerminateQTVR</code> more than once; they are reference-counted and nestable. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_86" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>InitializeQTVR</code> and <code>TerminateQTVR</code> routines are required for QuickTime VR to run in a Windows environment. They neither compile nor link in the Mac OS environment. </p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBDBDFE" title="Creating QuickTime VR Movie Instances"></a><h3>Creating QuickTime VR Movie Instances</h3><p>As discussed earlier, most QuickTime VR Manager functions operate on a QuickTime VR movie instance (defined by the <code>QTVRInstance</code> data type), which identifies a particular QuickTime VR movie. You can get a QuickTime VR movie instance by calling the <code>QTVRGetQTVRInstance</code> function, as illustrated in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBCEEBF">Listing 4-9</a></span>.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_87" title="Listing 4-9Getting a QuickTime VR movie instance"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBCEEBF" title="Listing 4-9Getting a QuickTime VR movie instance"></a><strong>Listing 4-9&nbsp;&nbsp;</strong>Getting a QuickTime VR movie instance</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_287"></a><div class="codesample"><table><tr><td scope="row"><pre>QTVRInstance MyGetQTVRInstanceFromMC (MovieController theController)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Track               myTrack = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRInstance        myInstance = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    Movie               myMovie;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Get the movie from the movie controller.<span></span></pre></td></tr><tr><td scope="row"><pre>    myMovie = MCGetMovie(theController);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (myMovie) {<span></span></pre></td></tr><tr><td scope="row"><pre>        //Get the first QTVR track in the movie.<span></span></pre></td></tr><tr><td scope="row"><pre>        myTrack = QTVRGetQTVRTrack(myMovie, 1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Get a QTVR instance for that QTVR track.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (myTrack) {<span></span></pre></td></tr><tr><td scope="row"><pre>            QTVRGetQTVRInstance(myInstance, myTrack, theController);<span></span></pre></td></tr><tr><td scope="row"><pre>            //Set our units to be degrees.<span></span></pre></td></tr><tr><td scope="row"><pre>            if (myInstance)<span></span></pre></td></tr><tr><td scope="row"><pre>                QTVRSetAngularUnits(myInstance, kQTVRDegrees);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return(myInstance);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>To get a QuickTime VR movie instance, you first need to obtain a QTVR track, a special type of QuickTime track that maintains a list of the nodes in the scene. A single QuickTime movie file can contain more than one QuickTime VR scene and hence more than one QTVR track, so you need to specify which QTVR track you want by calling the <code>QTVRGetQTVRTrack</code> function with the index of the desired track. <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBCEEBF">Listing 4-9</a></span> simply gets the first QTVR track in the specified movie.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_88" title="Note"></a><p><strong>Note:</strong>&nbsp;Movies made with QuickTime VR 1.0 do not contain a QTVR track. When you call <code>QTVRGetQTVRTrack</code> with such a movie, the function returns the appropriate QuickTime track. </p></div><p>After getting the desired QTVR track, the <code>MyGetQTVRInstanceFromMC</code> function defined in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBCEEBF">Listing 4-9</a></span> calls the <code>QTVRGetQTVRInstance</code> function to obtain a QuickTime VR movie instance. Finally, <code>MyGetQTVRInstanceFromMC</code> calls <code>QTVRSetAngularUnits</code> to ensure that all angles passed to QuickTime VR functions are interpreted as degrees.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_89" title="Note"></a><p><strong>Note:</strong>&nbsp;A QuickTime VR movie instance is essentially a pointer to a data structure maintained privately by QuickTime VR. You obtain a movie instance by calling <code>QTVRGetQTVRInstance</code>, but you do not need to dispose of that instance. A QuickTime VR movie instance remains valid until you dispose of the QuickTime movie controller (by calling <code>DisposeMovieController</code>).<a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_288"></a></p></div><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF122" title="Manipulating Viewing Angles and Zooming"></a><h3>Manipulating Viewing Angles and Zooming</h3><p>Perhaps the simplest use of the QuickTime VR Manager is to manipulate the current viewing characteristics of an object or panoramic node. You can use the <code>QTVRGetPanAngle</code> and <code>QTVRSetPanAngle</code> functions to manipulate the pan angle, and you can use the <code>QTVRGetTiltAngle</code> and <code>QTVRSetTiltAngle</code> functions to manipulate the tilt angle.</p><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBCFDAJ">Listing 4-10</a></span> illustrates how to pan or tilt a specific number of degrees in a specific direction.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_90" title="Listing 4-10Changing the viewing angle"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBCFDAJ" title="Listing 4-10Changing the viewing angle"></a><strong>Listing 4-10&nbsp;&nbsp;</strong>Changing the viewing angle</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_289"></a><div class="codesample"><table><tr><td scope="row"><pre>#define kDirLeft    0L<span></span></pre></td></tr><tr><td scope="row"><pre>#define kDirRight   1L<span></span></pre></td></tr><tr><td scope="row"><pre>#define kDirUp      2L<span></span></pre></td></tr><tr><td scope="row"><pre>#define kDirDown    3L<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Boolean MyGoDirByDegrees (QTVRInstance theInstance, long theDir, float theAmt)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float       theAngle;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean     theMoved = false;   //Did calling this routine result in a movement?<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (theDir) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirUp:<span></span></pre></td></tr><tr><td scope="row"><pre>            theAngle = QTVRGetTiltAngle(theInstance);<span></span></pre></td></tr><tr><td scope="row"><pre>            QTVRSetTiltAngle(theInstance, theAngle + theAmt);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirDown:<span></span></pre></td></tr><tr><td scope="row"><pre>            theAngle = QTVRGetTiltAngle(theInstance);<span></span></pre></td></tr><tr><td scope="row"><pre>            QTVRSetTiltAngle(theInstance, theAngle – theAmt);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirLeft:<span></span></pre></td></tr><tr><td scope="row"><pre>            theAngle = QTVRGetPanAngle(theInstance);<span></span></pre></td></tr><tr><td scope="row"><pre>            QTVRSetPanAngle(theInstance, theAngle + theAmt);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirRight:<span></span></pre></td></tr><tr><td scope="row"><pre>            theAngle = QTVRGetPanAngle(theInstance);<span></span></pre></td></tr><tr><td scope="row"><pre>            QTVRSetPanAngle(theInstance, theAngle – theAmt);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Now update the image on the screen.<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRUpdate(theInstance, kQTVRStatic);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Determine whether a movement actually occurred.<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (theDir) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirUp:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirDown:<span></span></pre></td></tr><tr><td scope="row"><pre>            theMoved = (theAngle != QTVRGetTiltAngle(theInstance));<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirLeft:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirRight:<span></span></pre></td></tr><tr><td scope="row"><pre>            theMoved = (theAngle != QTVRGetPanAngle(theInstance));<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return(theMoved);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><code>MyGoDirByDegrees</code> is relatively simple. It first determines the direction in which to move, gets the current pan or tilt angle, and then sets a new pan or tilt angle by adding or subtracting the desired displacement to that angle. Notice that <code>MyGoDirByDegrees</code> calls the <code>QTVRUpdate</code> function to update the image on the screen. This update is necessary whenever you change a viewing characteristic programmatically.</p><p>Once the new viewing angle has been set and the new image has been displayed, the <code>MyGoDirByDegrees</code> function determines whether the new pan or tilt angle differs from the pan or tilt angle on entry and passes back a Boolean value to indicate whether the call to <code>MyGoDirByDegrees</code> changed the pan or tilt angle. (The new angle may not be different because, for example, the value was already at some limit or constraint. This information might be useful for determining whether to enable or disable some visual effect in the scene.)</p><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_290"></a>Zooming in or out is just as simple as panning or tilting. For both objects and panoramas, you zoom in or out by changing the field of view of the node. <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBIDDED">Listing 4-11</a></span> defines a function that zooms in or out by a predetermined amount.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_91" title="Listing 4-11Changing the field of view"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBIDDED" title="Listing 4-11Changing the field of view"></a><strong>Listing 4-11&nbsp;&nbsp;</strong>Changing the field of view</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_291"></a><div class="codesample"><table><tr><td scope="row"><pre>#define kDirIn      4L<span></span></pre></td></tr><tr><td scope="row"><pre>#define kDirOut     5L<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyZoomInOrOut (QTVRInstance theInstance, long theDir)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float   theFloat;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theFloat = QTVRGetFieldOfView(theInstance);<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (theDir) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirIn:<span></span></pre></td></tr><tr><td scope="row"><pre>            theFloat = theFloat / 2.0;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kDirOut:<span></span></pre></td></tr><tr><td scope="row"><pre>            theFloat = theFloat * 2.0;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRSetFieldOfView(theInstance, theFloat);<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRUpdate(theInstance, kQTVRStatic);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>MyZoomInOrOut</code> function defined in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBIDDED">Listing 4-11</a></span> simply doubles or halves the current field of view, depending on whether you’re zooming out or in.<a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_292"></a></p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF123" title="Intercepting QuickTime VR Manager Routines"></a><h3>Intercepting QuickTime VR Manager Routines</h3><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_293"></a><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_294"></a>The QuickTime VR Manager provides support for intercepting some of its routines. To intercept a routine, you need to define and install an intercept procedure, a function that is executed in addition to (or instead of) the QuickTime VR Manager function it’s intercepting.<a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_295"></a></p><p>Typically, you use an intercept procedure to augment the behavior of a QuickTime VR Manager function. For instance, you might intercept the <code>QTVRSetPanAngle</code> function to play a specific sound when the user moves to a particular pan angle. In this case, you would have the QuickTime VR Manager execute the <code>QTVRSetPanAngle</code> function, and then you would play the appropriate sound.</p><p>Alternatively, you might want to override the intercepted function altogether. For instance, you might intercept the <code>QTVRTriggerHotSpot</code> function so that when the user clicks a custom hot spot, you can respond accordingly. In this case, there is no need to have the QuickTime VR Manager execute the <code>QTVRTriggerHotSpot</code> function. </p><p>You declare an intercept procedure like this:</p><div class="codesample"><table><tr><td scope="row"><pre>pascal void MyInterceptProc (<span></span></pre></td></tr><tr><td scope="row"><pre>QTVRInstance qtvr,<span></span></pre></td></tr><tr><td scope="row"><pre>QTVRInterceptPtr qtvrMsg,<span></span></pre></td></tr><tr><td scope="row"><pre>SInt32 refCon,<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean *cancel);<span></span></pre></td></tr></table></div><p>The <code>qtvr</code> parameter is the instance with which you’re concerned. The <code>qtvrMsg</code> parameter is a pointer to an intercept structure, which contains information about the routine being intercepted and its parameters. The <code>refCon</code> parameter is a long integer available for use by your application. Finally, your intercept procedure should set the <code>cancel</code> parameter to indicate whether the QuickTime VR Manager should execute the intercepted function when your intercept procedure has finished (<code>false</code>) or should not execute the function (<code>true</code>).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_92" title="Note"></a><p><strong>Note:</strong>&nbsp;If you don’t set the <code>cancel</code> parameter before exiting your intercept procedure, its value is by default set to <code>false</code> (indicating that the intercepted function should be executed).</p></div><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_296"></a>The intercept structure is defined by the <code>QTVRInterceptRecord</code> data type:</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct QTVRInterceptRecord {<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                              reserved1;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                              selector;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                              reserved2;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                              reserved3;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                              paramCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    void                                *parameter[6];<span></span></pre></td></tr><tr><td scope="row"><pre>} QTVRInterceptRecord, *QTVRInterceptPtr;<span></span></pre></td></tr></table></div><p>Many of the fields of an intercept structure are reserved. The interesting fields are <code>selector</code>, <code>paramCount</code>, and <code>parameter</code>. The <code>selector</code> field is an intercept selector, a constant that indicates which routine has triggered your intercept procedure. You can, if you wish, install a single intercept procedure for all intercepted functions. In that case, you can inspect the <code>selector</code> field of the intercept structure passed to your intercept routine to determine how to respond. </p><p>The QuickTime VR Manager defines these intercept selectors:<a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_297"></a></p><div class="codesample"><table><tr><td scope="row"><pre>typedef enum QTVRProcSelector {<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRSetPanAngleSelector                        = 0x2000,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRSetTiltAngleSelector                       = 0x2001,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRSetFieldOfViewSelector                     = 0x2002,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRSetViewCenterSelector                      = 0x2003,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRMouseEnterSelector                         = 0x2004,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRMouseWithinSelector                        = 0x2005,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRMouseLeaveSelector                         = 0x2006,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRMouseDownSelector                          = 0x2007,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRMouseStillDownSelector                     = 0x2008,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRMouseUpSelector                            = 0x2009,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRTriggerHotSpotSelector                     = 0x200A,<span></span></pre></td></tr><tr><td scope="row"><pre>    kQTVRGetHotSpotTypeSelector                     = 0x200B<span></span></pre></td></tr><tr><td scope="row"><pre>} QTVRProcSelector;<span></span></pre></td></tr></table></div><p>The <code>parameter</code> field of the intercept structure is an array that holds, in order, the parameters that were passed to the intercepted function, minus the QTVR instance parameter. For example, if you intercept the <code>QTVRSetPanAngle</code> function, the <code>parameter</code> array contains a single member, a pointer to a floating-point value that is the new pan angle. You can determine how many members the <code>parameter</code> array contains by inspecting the <code>paramCount</code> field of the intercept structure.</p><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJCBBJ">Listing 4-12</a></span> defines a simple intercept procedure that is called whenever the QuickTime VR Manager function <code>QTVRSetPanAngle</code> is called. The intercept procedure calls an application-defined function, <code>MyPlayPanSound</code>, to play a sound for the new pan angle.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_93" title="Listing 4-12Intercepting the QTVRSetPanAngle function (version 1)"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBJCBBJ" title="Listing 4-12Intercepting the QTVRSetPanAngle function (version 1)"></a><strong>Listing 4-12&nbsp;&nbsp;</strong>Intercepting the <code>QTVRSetPanAngle</code> function (version 1)</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_298"></a><div class="codesample"><table><tr><td scope="row"><pre>#define MyPi (3.1415926535898)<span></span></pre></td></tr><tr><td scope="row"><pre>#define RadiansToDegrees(x) ((x) * 180.0 / MyPi)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal void MyInterceptProc (QTVRInstance theInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>                QTVRInterceptPtr theMsg, SInt32 refcon, Boolean *cancel)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean     cancelInterceptedProc = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    float       theAngle, *theAnglePtr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (theMsg->selector) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kQTVRSetPanAngleSelector:<span></span></pre></td></tr><tr><td scope="row"><pre>            theAnglePtr = theMsg->parameter[0];<span></span></pre></td></tr><tr><td scope="row"><pre>            theAngle = *theAnglePtr;<span></span></pre></td></tr><tr><td scope="row"><pre>            theAngle = RadiansToDegrees(theAngle);<span></span></pre></td></tr><tr><td scope="row"><pre>            MyPlayPanSound(theAngle);       //Play a sound for the angle.<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    *cancel = cancelInterceptedProc;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_94" title="Important:"></a><p><strong>Important:</strong>&nbsp;Angular values in the <code>parameter</code> field of an intercept structure are always returned in radians, regardless of the current angular unit. In addition, a floating-point value is always passed as a pointer to a floating-point value.</p><p></p></div><p>The intercept procedure defined in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBJCBBJ">Listing 4-12</a></span> returns the value <code>false</code> in the <code>cancel</code> parameter. This indicates that the QuickTime VR Manager should call the intercepted function after the intercept procedure exits. If the <code>cancel</code> parameter is set to <code>true</code>, the QuickTime VR Manager does not call the intercepted function. This is useful if you want to replace the intercepted function altogether or if you want to call the intercepted function from within your intercept procedure. For example, if you want to play a sound after the new pan angle is displayed, you can define an intercept procedure like the one specified in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBGCGDH">Listing 4-13</a></span>.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_95" title="Listing 4-13Intercepting the QTVRSetPanAngle function (version 2)"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBGCGDH" title="Listing 4-13Intercepting the QTVRSetPanAngle function (version 2)"></a><strong>Listing 4-13&nbsp;&nbsp;</strong>Intercepting the <code>QTVRSetPanAngle</code> function (version 2)</p><div class="codesample"><table><tr><td scope="row"><pre>pascal void MyInterceptProc (QTVRInstance theInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRInterceptPtr theMsg, SInt32 refcon, Boolean *cancel)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean cancelInterceptedProc = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (theMsg->selector) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kQTVRGetHotSpotTypeSelector:<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        OSType hsType;<span></span></pre></td></tr><tr><td scope="row"><pre>        QTVRCallInterceptedProc (theInstance, theMsg);<span></span></pre></td></tr><tr><td scope="row"><pre>        hsType = * ((UInt32 *) theMsg->parameter[1]);<span></span></pre></td></tr><tr><td scope="row"><pre>        // Turn all url hotspots into undefined hotspots<span></span></pre></td></tr><tr><td scope="row"><pre>        if (hsType == kQTVRHotSpotURLType)<span></span></pre></td></tr><tr><td scope="row"><pre>            * ((UInt32 *) theMsg->parameter[1]) =<span></span></pre></td></tr><tr><td scope="row"><pre>                                    kQTVRHotSpotUndefinedType;<span></span></pre></td></tr><tr><td scope="row"><pre>        cancelInterceptedProc = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    default:<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>*cancel = cancelInterceptedProc;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The intercept procedure defined in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBGCGDH">Listing 4-13</a></span> looks at the hot spot type returned by the call to <code>QTVRCallInterceptedProc </code>and changes it to undefined if it is a URL hot spot. </p><p>Notice that the new intercept procedure returns the value <code>true</code> in the <code>cancel</code> parameter, indicating that the QuickTime VR Manager should not call the intercepted function after the intercept procedure returns. If the intercept procedure returns <code>false</code>, then the intercepted function will be called twice (once because you call <code>QTVRCallInterceptedProc</code> and a second time because you return <code>false</code> in the <code>cancel</code> parameter).</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_96" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should use the <code>QTVRCallInterceptedProc</code> function only in an intercept procedure. Moreover, you should use <code>QTVRCallInterceptedProc</code> instead of the function you’re intercepting. If you called <code>QTVRSetPanAngle</code> directly in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBGCGDH">Listing 4-13</a></span>, your intercept procedure would be called repeatedly until your stack overflowed.</p><p></p></div><p>You install an intercept procedure by calling the <code>QTVRInstallInterceptProc</code> function, as shown in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBGAGCD">Listing 4-14</a></span>.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_97" title="Listing 4-14Installing an intercept procedure"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBGAGCD" title="Listing 4-14Installing an intercept procedure"></a><strong>Listing 4-14&nbsp;&nbsp;</strong>Installing an intercept procedure</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_299"></a><div class="codesample"><table><tr><td scope="row"><pre>QTVRInterceptUPP MyInstallInterceptProcedure (QTVRInstance theInstance)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRInterceptUPP    theInterceptProc;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theInterceptProc = NewQTVRInterceptProc(MyInterceptProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRInstallInterceptProc(theInstance, kQTVRSetPanAngleSelector,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                theInterceptProc, 0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    return  theInterceptProc<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>. . .<span></span></pre></td></tr><tr><td scope="row"><pre>myProc = MyInstallInterceptProcedure(qtvr);<span></span></pre></td></tr></table></div><p><code>QTVRInstallInterceptProc</code> takes an intercept selector to determine which QuickTime VR Manager function to intercept. If you wish, you can define a single intercept procedure and use the intercept selector passed to it in the <code>selector</code> field of <code>theMsg</code> to decide how to respond.<a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_300"></a><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_301"></a></p><p>When you no longer need the intercept procedure you should call <code>QTVRInstallInterceptProc</code> again with the same selector and a <code>nil</code> procedure pointer and then call <code>DisposeRoutineDescriptor</code> on <code>myProc</code>. </p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF124" title="Entering and Leaving Nodes"></a><h3>Entering and Leaving Nodes</h3><p>The QuickTime VR Manager provides a way for you to be notified whenever the user is about to enter a new node or leave the current node. You can then react to these notifications in whatever manner you choose. </p><p>For example, when the user is about to enter a new node, you might determine the name of that new node and display the name or other information about the node. Similarly, when the user is about to leave the current node, you might initiate a custom node-to-node transition effect. Alternatively, you can cancel the move to the other node; this might be useful in a game when the user hasn’t yet searched the current node completely or accomplished some other predefined task in that node.</p><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_302"></a>To be informed that the user is about to enter a new node, you define and install a node-entering procedure. <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBFGIAF">Listing 4-15</a></span> illustrates a simple node-entering procedure that determines the name of the new node and then utters that name.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_98" title="Listing 4-15Informing the user of a new node&acirc;&#128;&#153;s name"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBFGIAF" title="Listing 4-15Informing the user of a new node&acirc;&#128;&#153;s name"></a><strong>Listing 4-15&nbsp;&nbsp;</strong>Informing the user of a new node’s name</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_303"></a><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr MyEnteringNodeProc (QTVRInstance theInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    UInt32 theNodeID, SInt32 refCon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Str255          theString;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr           theErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = MyGetNodeName(theInstance, theNodeID, &amp;theString);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        SpeakString(theString);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return(theErr);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_99" title="Note"></a><p><strong>Note:</strong>&nbsp;See the QuickTime API Reference for the definition of the function <code>MyGetNodeName</code> defined in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBFGIAF">Listing 4-15</a></span>.</p></div><p>You install a node-entering procedure by calling the <code>QTVRSetEnteringNodeProc</code> function, like this:</p><div class="codesample"><table><tr><td scope="row"><pre>theErr = QTVRSetEnteringNodeProc(theInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NewQTVREnteringNodeProc(MyEnteringNodeProc), 0, 0);<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_304"></a>To be informed that the user is about to leave the current node, you define and install a node-leaving procedure. <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBGJAAE">Listing 4-16</a></span> illustrates a simple node-leaving procedure that prevents the user from leaving the current node unless all hot spots in the node have been triggered.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_100" title="Listing 4-16Leaving a node"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBGJAAE" title="Listing 4-16Leaving a node"></a><strong>Listing 4-16&nbsp;&nbsp;</strong>Leaving a node</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_305"></a><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr MyLeavingNodeProc (QTVRInstance theInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>                                UInt32 fromNodeID, UInt32 toNodeID,<span></span></pre></td></tr><tr><td scope="row"><pre>                                Boolean *cancel, MyDataPtr theDataPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean theUserCanLeave = false;    //By default, user can’t leave.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (theDataPtr->allHotSpotsTouched)<span></span></pre></td></tr><tr><td scope="row"><pre>        theUserCanLeave = true;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    *cancel = !theUserCanLeave;<span></span></pre></td></tr><tr><td scope="row"><pre>    return(noErr);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Before returning, your node-leaving procedure should set the Boolean value pointed to by the <code>cancel</code> parameter to <code>false</code> to accept the move from <code>fromNodeID</code> to <code>toNodeID</code>. Set that value to <code>true</code> to cancel the move and remain at the node specified by the <code>fromNodeID</code> parameter. The procedure defined in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBGJAAE">Listing 4-16</a></span> simply reads some private data to determine whether to allow the user to leave the current node.</p><p>You install a node-leaving procedure by calling the <code>QTVRSetLeavingNodeProc</code> function, like this:</p><div class="codesample"><table><tr><td scope="row"><pre>theErr = QTVRSetLeavingNodeProc(theInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>        NewQTVRLeavingNodeProc(MyLeavingNodeProc), (SInt32)&amp;theData, 0);<span></span></pre></td></tr></table></div><p>In a multinode movie, your node-entering procedure is not called for the first node. This is because the user is considered to be in the first node as soon as the VR movie is opened, before you have a chance to install your node-entering procedure. If you need to have your node-entering procedure called for the first node, you can execute it explicitly, either before or after you’ve installed it as a node-entering procedure.<a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_306"></a></p><a name="//apple_ref/doc/uid/TP40000944-CH208-TPXREF125" title="Drawing in the Prescreen Buffer"></a><h3>Drawing in the Prescreen Buffer</h3><p>The QuickTime VR Manager allows you to define a prescreen buffer imaging completion procedure that is called whenever QuickTime VR finishes drawing a panorama image in the prescreen buffer. Typically, your completion procedure adds graphical elements to the image before the buffer is copied to the screen. For instance, a flight simulator could overlay a heads-up display containing information about the aircraft (its altitude, velocity, and so forth).</p><p>You install a prescreen buffer imaging completion procedure by passing its address to the <code>QTVRSetPrescreenImagingCompleteProc</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>theErr = QTVRSetPrescreenImagingCompleteProc(theInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>        NewQTVRImagingCompleteProc(MyImagingCompleteProc),<span></span></pre></td></tr><tr><td scope="row"><pre>        (SInt32)&amp;theData, 0);<span></span></pre></td></tr></table></div><p><span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBHCDAI">Listing 4-17</a></span> defines a simple completion routine that overlays a picture onto the screen image.</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_101" title="Listing 4-17Overlaying images in the prescreen buffer"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40000944-CH208-CJBHCDAI" title="Listing 4-17Overlaying images in the prescreen buffer"></a><strong>Listing 4-17&nbsp;&nbsp;</strong>Overlaying images in the prescreen buffer</p><a name="//apple_ref/doc/uid/TP40000944-CH208-DontLinkElementID_307"></a><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr MyImagingCompleteProc (QTVRInstance, MyDataPtr theDataPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theDataPtr->hasLogoPict) {<span></span></pre></td></tr><tr><td scope="row"><pre>        GWorldPtr   theOffscreenGWorld;<span></span></pre></td></tr><tr><td scope="row"><pre>        GDHandle    theGD;<span></span></pre></td></tr><tr><td scope="row"><pre>        Rect        gwRect;<span></span></pre></td></tr><tr><td scope="row"><pre>        Rect        picRect;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // The current graphics world is set to the prescreen buffer.<span></span></pre></td></tr><tr><td scope="row"><pre>        GetGWorld (&amp;theOffscreenGWorld, &amp;theGD);<span></span></pre></td></tr><tr><td scope="row"><pre>        gwRect = (*(theOffscreenGWorld->portPixMap))->bounds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        picRect = (*(theDataPtr->logoPict))->picFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>        OffsetRect (&amp;picRect, -picRect.left, -picRect.top);<span></span></pre></td></tr><tr><td scope="row"><pre>        OffsetRect (&amp;picRect, gwRect.right - (picRect.right + 8),<span></span></pre></td></tr><tr><td scope="row"><pre>                gwRect.bottom - (picRect.bottom + 8));<span></span></pre></td></tr><tr><td scope="row"><pre>        // Draw logo in lower right corner<span></span></pre></td></tr><tr><td scope="row"><pre>        DrawPicture (theDataPtr->logoPict, &amp;picRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>On entry to the prescreen buffer imaging completion routine, the current graphics world is set to QuickTime VR’s prescreen buffer. The <code>MyImagingCompleteProc</code> function defined in <span class="content_text"><a href="4-QTVR-Manager.html#//apple_ref/doc/uid/TP40000944-CH208-CJBHCDAI">Listing 4-17</a></span> retrieves the dimensions of that buffer and then draws a picture in the lower-right corner of that buffer. </p><p>The <em>QuickTime API Reference</em> describes the constants, data structures, and routines provided by the QuickTime VR Manager.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../3Chap/3-QTVR-Programming.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../6Chap/6-Creating-QTVR-Movies.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-06-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/InsideQT_QTVR/4Chap/4-QTVR-Manager.html%3Fid%3DTP40000944-2.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/InsideQT_QTVR/4Chap/4-QTVR-Manager.html%3Fid%3DTP40000944-2.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/InsideQT_QTVR/4Chap/4-QTVR-Manager.html%3Fid%3DTP40000944-2.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>