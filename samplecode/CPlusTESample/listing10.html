<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CPlusTESample - /FlowCtlMacs.d</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">CPlusTESample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CPlusTESample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/FlowCtlMacs.d</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AppLib.h</option>
<option value="listing2.html">/AppLib.r</option>
<option value="listing3.html">/Application.cp</option>
<option value="listing4.html">/Application.h</option>
<option value="listing5.html">/C.pipe.code.c</option>
<option value="listing6.html">/Document.cp</option>
<option value="listing7.html">/Document.h</option>
<option value="listing8.html">/Exceptions.cp</option>
<option value="listing9.html">/Exceptions.h</option>
<option value="listing10.html">/FlowCtlMacs.d</option>
<option value="listing11.html">/List.cp</option>
<option value="listing12.html">/List.h</option>
<option value="listing13.html">/ProgStrucMacs.d</option>
<option value="listing14.html">/TECommon.h</option>
<option value="listing15.html">/TEDocument.cp</option>
<option value="listing16.html">/TEDocument.h</option>
<option value="listing17.html">/TESample.cp</option>
<option value="listing18.html">/TESample.h</option>
<option value="listing19.html">/TESample.r</option>
<option value="listing20.html">/TESampleGlue.a</option>
<option value="listing21.html">/UMAFailure.a</option>
<option value="listing22.html">/UMAFailure.h</option>
<option value="listing23.html">/UMAFailure.inc1.p</option>
<option value="listing24.html">/UMAFailure.p</option></select>
				</p>
				</form>
				<p><strong><a href="CPlusTESample.zip">Download Sample</a></strong> (&#147;CPlusTESample.zip&#148;, 130.6K)<BR>
<strong><a href="CPlusTESample.dmg">Download Sample</a></strong> (&#147;CPlusTESample.dmg&#148;, 196.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">  &yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml; FOR#      .&amp;Lbl    For#.&amp;Sz   &amp;Opnds,&amp;Dreg==D0,&amp;Opt=Y,&amp;Clr=Y     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack6    GBLA    &amp;Incr#[25]    ; 1==&gt;TO; 0 ==&gt;DOWNTO; -1 ==&gt; DBcc8    GBLC    &amp;LblStk#[25]    ; For# label for Cycle# and Leave#0    GBLC    &amp;Lbl1Stk#[25]    ; label suffix for Leave#0    GBLC    &amp;Lbl2Stk#[25]    ; label suffix for Cycle#2    GBLC    &amp;Sz#[25]      ; size of control reg (B, W, L)1    GBLC    &amp;Op1#[25]      ; &lt;op1&gt;, loop control counter'    GBLC    &amp;Op3#[25]      ; &lt;op3&gt;, loop limit+    GBLC    &amp;Op4#[25]      ; &lt;op4&gt;, loop increment2    GBLC    &amp;Until#[25]    ; &lt;expr&gt;, loop end  condition9    GBLC    &amp;Dreg#[25]    ; work register if &lt;op1&gt; is not a reg)    GBLA    &amp;Debug#      ; debug printing switch1    LCLA    &amp;Cp,&amp;Sw,&amp;First,&amp;Last,&amp;HaveOp2,&amp;DBcc,&amp;t,&amp;b     LCLC    &amp;Id,&amp;Expr,&amp;Op2,&amp;Siz,&amp;Ext    IF &amp;StkPtr# = 25 THEN&amp;    AERROR 'Too many nested statements'      GOTO .Exit   ENDIF.  &amp;StkPtr#: SETA &amp;StkPtr#+1    ; Update stack ptrB   IF &amp;Lbl = '' THEN        ; Remember label for Until#, Cycle#, Leave#     &amp;LblStk#[&amp;StkPtr#]: SETC ''    ELSE     &amp;LblStk#[&amp;StkPtr#]: SETC &amp;Lbl &amp;Lbl   ENDIFC  &amp;Lbl1Stk#[&amp;StkPtr#]: SETC &amp;SysNdx  ; We always need a &quot;leave&quot; label.  &amp;Lbl2Stk#[&amp;StkPtr#]: SETC ''    ; No Cycle# yet&lt;  &amp;KindStk#[&amp;StkPtr#]: SETA 4    ; Kind = 4 for For# statements4  &amp;Cp: SETA 1          ; Start scanning at start of &amp;Opnds.  &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)    ; Scan 1st token=  &amp;Id: SETC &amp;UC(&amp;SysTokStr)    ; We will scan until end of &lt;op1&gt;V   WHILE (&amp;Id &shy; 'TO') AND (&amp;Id &shy; 'DOWNTO') AND (&amp;SysToken &shy; 12) AND (&amp;SysToken &shy; 30) DO=    &amp;Last: SETA &amp;Cp        ; Always assume next token is delimiter1    &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)    ; Scan next token     &amp;Id: SETC &amp;UC(&amp;SysTokStr)   ENDW&lt;   IF &amp;SysToken = 30 THEN      ; Did we crash into end of line ?!    AERROR 'Invalid loop variable')     GOTO .Err          ; Common error recovery   ENDIFB   IF &amp;SysToken = 12 THEN      ; Did we crach into &quot;=&quot; following &lt;op1&gt;;    &amp;Last: SETA &amp;Last-1      ; Yes, it is not part of the &lt;op1&gt;   ENDIF=  &amp;Op1#[&amp;StkPtr#]: SETC &amp;Trim(&amp;Opnds[1:&amp;Last]) ; Extract &lt;op1&gt;+  &amp;Siz: SETC 'W'          ; The default size is W7   IF &amp;SysToken = 12 THEN       ; Did a &quot;=&quot; delimit &lt;op1&gt; ??    &amp;HaveOp2: SETA 1        ; Yes, set switch to now will have &lt;op2&gt;?     IF &amp;Opnds[&amp;Cp:1] = '.' THEN    ; Explicit .sz following &quot;=&quot; ?H      &amp;Siz: SETC &amp;UC(&amp;Opnds[&amp;Cp+1:1]); Yes, we will use whatever is there7      &amp;Sz#[&amp;StkPtr#]: SETC &amp;Siz    ; Save for use by EndF#)      &amp;Cp: SETA &amp;Cp+2        ; Bump Cp over it      ELSEF      &amp;Sz#[&amp;StkPtr#]: SETC 'W'    ; If no explicit size, EndF# will use W     ENDIF6    &amp;First: SETA &amp;Cp        ; Prepare to scan off the &lt;op2&gt;B    &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)    ; It's scan is like that for &lt;op1&gt;     &amp;Id: SETC &amp;UC(&amp;SysTokStr)  C     WHILE (&amp;Id &shy; 'TO') AND (&amp;Id &shy; 'DOWNTO') AND (&amp;SysToken &shy; 30) DO?      &amp;Last: SETA &amp;Cp        ; Always assume next token is delimiter2      &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)  ; Scan next token       &amp;Id: SETC &amp;UC(&amp;SysTokStr)     ENDW&gt;     IF &amp;SysToken = 30 THEN      ; Did we crash into end of line ?#      AERROR 'TO or DOWNTO expected'+       GOTO .Err          ; Common error recovery     ENDIF  A    &amp;Op2: SETC &amp;Trim(&amp;Opnds[&amp;First:&amp;Last-&amp;First+1]); Extract &lt;op2&gt;   ENDIF#   IF &amp;Id = 'TO' THEN        ; Have TO ?&gt;    &amp;Incr#[&amp;StkPtr#]: SETA 1    ; Indicate incrementing for EndF#-   ELSEIF &amp;Id = 'DOWNTO' THEN    ; Have DOWNTO ?&gt;    &amp;Incr#[&amp;StkPtr#]: SETA 0    ; Indicate decrementing for EndF#    ELSE!    AERROR 'TO or DOWNTO expected'     GOTO .Err   ENDIF9  &amp;First: SETA &amp;Cp        ; Scanned like &lt;op1&gt; and &lt;op2&gt; above   &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)   &amp;Id: SETC &amp;UC(&amp;SysTokStr)  Q   WHILE (&amp;Id &shy; 'UNTIL') AND (&amp;Id &shy; 'BY') AND (&amp;Id &shy; 'DO') AND (&amp;SysToken &shy; 30) DO     &amp;Last: SETA &amp;Cp     &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)     &amp;Id: SETC &amp;UC(&amp;SysTokStr)   ENDW    IF &amp;SysToken = 30 THEN$    AERROR 'BY, UNTIL or DO expected'     GOTO .Err   ENDIFJ  &amp;Op3#[&amp;StkPtr#]: SETC &amp;Trim(&amp;Opnds[&amp;First:&amp;Last-&amp;First+1]); Extract &lt;op3&gt;2  &amp;Op4#[&amp;StkPtr#]: SETC '#1'    ; Default &lt;op4&gt; to #1&gt;  &amp;Until#[&amp;StkPtr#]: SETC ''    ; Assume there is no UNTIL clause0   WHILE &amp;Sw &shy; 4 DO        ; Loop until DO is scanned+     IF &amp;Id = 'BY' THEN      ; Have BY clause ?&lt;       IF (&amp;Sw MOD 2) = 1 THEN    ; Yes, it can occur only once*        AERROR 'Only one BY clause allowed'          GOTO .Err
      ENDIF;      &amp;First: SETA &amp;Cp      ; Scan over the &lt;op4&gt; the usual way       &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)       &amp;Id: SETC &amp;UC(&amp;SysTokStr)D       WHILE (&amp;Id &shy; 'DO') AND (&amp;Id &shy; 'UNTIL') AND (&amp;SysToken &shy; 30) DO         &amp;Last: SETA &amp;Cp      &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)      &amp;Id: SETC &amp;UC(&amp;SysTokStr)        ENDW        IF &amp;SysToken &shy; 30 THENP        &amp;Op4#[&amp;StkPtr#]: SETC &amp;Trim(&amp;Opnds[&amp;First:&amp;Last-&amp;First+1]); Extract &lt;op4&gt;
      ENDIF;      &amp;Sw: SETA &amp;Sw+1        ; Indicate that BY has been scanned4     ELSEIF &amp;Id = 'UNTIL' THEN    ; Have UNTIL clause ?&lt;       IF (&amp;Sw DIV 2) = 1 THEN    ; Yes, it can occur only once-        AERROR 'Only one UNTIL clause allowed'          GOTO .Err
      ENDIF&lt;      &amp;First: SETA &amp;Cp      ; Scan over the &lt;expr&gt; the usual way       &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)       &amp;Id: SETC &amp;UC(&amp;SysTokStr)A       WHILE (&amp;Id &shy; 'DO') AND (&amp;Id &shy; 'BY') AND (&amp;SysToken &shy; 30) DO         &amp;Last: SETA &amp;Cp      &amp;Cp: SETA &amp;Lex(&amp;Opnds, &amp;Cp)      &amp;Id: SETC &amp;UC(&amp;SysTokStr)        ENDW        IF &amp;SysToken &shy; 30 THENS        &amp;Until#[&amp;StkPtr#]: SETC &amp;Trim(&amp;Opnds[&amp;First:&amp;Last-&amp;First+1]); Extract &lt;expr&gt;
      ENDIF&gt;      &amp;Sw: SETA &amp;Sw+2        ; Indicate that UNTIL has been scanned3     ELSEIF &amp;Id = 'DO' THEN      ; Have delimiting DO ?;      &amp;Sw: SETA 4 ; LEAVE !!    ; Yes, set switch to stop loopF       IF &amp;Opnds[&amp;Cp:1] = '.' THEN  ; Have explicit &lt;extent&gt; on the DO ?6     &amp;Ext: SETC &amp;UC(&amp;Trim(&amp;Opnds[&amp;Cp+1:1])); Yes, use it
      ENDIF?      &amp;Ext: SETC &amp;Default(&amp;Ext, 'W')  ; Make sure of the &lt;extent&gt;      ELSE&amp;      AERROR 'BY, UNTIL or DO expected'        GOTO .Err     ENDIF   ENDW9   IF &amp;SubStr(&amp;Type(&amp;Op1#[&amp;StkPtr#]), 1, 5) &shy; 'REG D' THENC    &amp;Dreg#[&amp;StkPtr#]: SETC &amp;Dreg  ; Indicate we are using a work reg      ELSEE    &amp;Dreg#[&amp;StkPtr#]: SETC ''    ; If work reg not needed, set to &lt;null&gt;   ENDIF/   GOTO .Opt            ; Hop over error recovery code  .Err  ANOP0  &amp;Op1#[&amp;StkPtr#]:   SETC 'D0'    ; Set &lt;op1&gt; to D0&amp;  &amp;HaveOp2:          SETA 1    ; Have &quot;=&quot;0  &amp;Op3#[&amp;StkPtr#]:   SETC '#0'    ; Set &lt;op3&gt; to #0                         0  &amp;Op4#[&amp;StkPtr#]:   SETC '#1'    ; Set &lt;op4&gt; to #1'  &amp;Until#[&amp;StkPtr#]: SETC ''    ; No UNTIL*  &amp;Incr#[&amp;StkPtr#]:  SETA 1    ; Incrementing1  &amp;Dreg#[&amp;StkPtr#]:  SETC ''    ; No work reg needed0  &amp;Ext:              SETC 'W'    ; An &lt;extent&gt; of W? .Opt  IF &amp;UC(&amp;Opt[1:1]) = 'Y' THEN          ; Optimization allowed ?4     IF &amp;Dreg#[&amp;StkPtr#] = '' THEN        ; &lt;op1&gt; is a Dn@       IF &amp;Siz &shy; 'L' THEN                     ; Word, byte sized reg@      IF &amp;Op3#[&amp;StkPtr#,1:1] = '#' THEN     ; &lt;op3&gt; is #n (Down[To])*       &amp;t: SETA &amp;Eval(&amp;Op3#[&amp;StkPtr#,2:255])'        IF &amp;t = 0 THEN            ; Down[To] #09       IF &amp;Op4#[&amp;StkPtr#,1:1] = '#' THEN    ; &lt;op4&gt; is #m (By)*        &amp;b: SETA &amp;Eval(&amp;Op4#[&amp;StkPtr#,2:255])          IF &amp;b = 1 THEN          ; By #1$           IF NOT &amp;Incr#[&amp;StkPtr#] THEN(         &amp;DBcc: SETA 1          ; DownTo #0 By #1          ENDIF%         ELSEIF &amp;b = -1 THEN        ; By #-1            IF &amp;Incr#[&amp;StkPtr#] THEN$         &amp;DBcc: SETA 1          ; To #0 By -1          ENDIF
        ENDIF       ENDIFH        ELSEIF (&amp;t=1)AND(&amp;Until#[&amp;StkPtr#]='')THEN; Down[To] #1 (no UNTIL)9       IF &amp;Op4#[&amp;StkPtr#,1:1] = '#' THEN    ; &lt;op4&gt; is #m (By)*        &amp;b: SETA &amp;Eval(&amp;Op4#[&amp;StkPtr#,2:255])          IF &amp;b = 1 THEN          ; By #1$           IF NOT &amp;Incr#[&amp;StkPtr#] THEN(         &amp;DBcc: SETA 1          ; DownTo #1 By #1          ENDIF%         ELSEIF &amp;b = -1 THEN        ; By #-1            IF &amp;Incr#[&amp;StkPtr#] THEN$         &amp;DBcc: SETA 1          ; To #1 By -1          ENDIF
        ENDIF       ENDIF
       ENDIF      ENDIF
      ENDIF     ENDIF   ENDIF    IF &amp;DBcc THEN     &amp;Incr#[&amp;StkPtr#]: SETA -1&lt;     IF &amp;HaveOp2 THEN        ; If explicit initial setting, do itJ       IF (&amp;Siz = 'B') AND (&amp;UC(&amp;Clr[1:1]) = 'Y') THEN; Clear the reg 1st ?H         IF &amp;Op2[1:1] = '#' THEN    ; Yes, but only if &lt;op2&gt; is not a const4       &amp;Siz: SETC 'W'      ; If const, init reg as a word       ELSE#          CLR.W     &amp;Op1#[&amp;StkPtr#]      ENDIF
      ENDIF(          MOVE.&amp;Siz &amp;Op2,&amp;Op1#[&amp;StkPtr#]     ENDIF1     IF &amp;t = 0 THEN        ; ... [Down]To #0 By #1 ...           BLT.&amp;Ext  %E%&amp;SysNdx)     ELSE            ; ... [Down]To #1 By #1 ...J      &amp;Lbl2Stk#[&amp;StkPtr#]: SETC &amp;SysNdx; Use the Cycle# label as branch dst           BRA.&amp;Ext  %C%&amp;SysNdx     ENDIF%Loop%&amp;SysNdx    ELSE&lt;     IF &amp;HaveOp2 THEN        ; If explicit initial setting, do it#       IF &amp;Dreg#[&amp;StkPtr#] &shy; '' THEN)          MOVE.&amp;Siz &amp;Op2,&amp;Dreg#[&amp;StkPtr#]
       ELSE(          MOVE.&amp;Siz &amp;Op2,&amp;Op1#[&amp;StkPtr#]
      ENDIF     ENDIF           BRA.&amp;Ext  %L%&amp;SysNdx%Loop%&amp;SysNdx   ENDIF    IF &amp;Debug# THEN%    Write 'FOR#', ' ', &amp;Op1#[&amp;StkPtr#]      IF &amp;HaveOp2 THEN*      Write '=.', &amp;Sz#[&amp;StkPtr#], ' ', &amp;Op2     ENDIF      IF &amp;Incr#[&amp;StkPtr#] THEN       Write ' TO '      ELSE       Write ' DOWNTO '     ENDIF1    Write  &amp;Op3#[&amp;StkPtr#], ' BY ', &amp;Op4#[&amp;StkPtr#]&quot;     IF &amp;Until#[&amp;StkPtr#] &shy; '' THEN-      Write ' UNTIL &quot;', &amp;Until#[&amp;StkPtr#], '&quot;'     ENDIF     WriteLn  ' DO.', &amp;Ext   ENDIF .Exit   PRINT   Pop&yuml; ENDW#           EndW#     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack:    GBLC    &amp;LblStk#[25]    ; While# label for Cycle# and Leave#&lt;    GBLC    &amp;Lbl1Stk#[25]    ; label suffix for Leave# and While#                                    /    GBLC    &amp;Lbl2Stk#[25]    ; extent attribute on DO    IF &amp;StkPtr# = 0 THEN'    AERROR 'ENDW# does not end a WHILE#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 3 THEN'    AERROR 'ENDW# does not end a WHILE#'      GOTO .Exit   ENDIF4          BRA.&amp;Lbl2Stk#[&amp;StkPtr#] &amp;LblStk#[&amp;StkPtr#] %E%&amp;Lbl1Stk#[&amp;StkPtr#]   &amp;StkPtr#: SETA &amp;StkPtr#-1 .Exit  PRINT  Pop&yuml; GOTO#           GoTo#.&amp;Ext &amp;Where     PRINT  Push,NoMDir,NoMCall     GBLA    &amp;Cp#        ; scan pointer&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)     LCLC    &amp;Opnds,&amp;S    LCLA    &amp;i,&amp;l&lt;  &amp;Opnds: SETC &amp;Where        ; Copy operands where we can edit it/  &amp;Cp#:   SETA &amp;Lex(&amp;Opnds, 1)    ; Scan 1st token7   IF &amp;SysToken = 0 THEN      ; Do we have an idtentifier ?A    &amp;S: SETC &amp;UC(&amp;SysTokStr)    ; Yes, see if it is an &quot;IF&quot; or &quot;IF#&quot;0     IF (&amp;S = 'IF') OR (&amp;S = 'IF#') THEN; Is it ?L      &amp;Opnds: SETC &amp;Opnds[&amp;Cp#:255]  ; Yes ==&gt; If[#] &lt;expr&gt; THEN.&lt;ext&gt; &lt;label&gt;1      &amp;l: SETA &amp;Len(&amp;Opnds)    ; Extract the &lt;label&gt;P      &amp;i: SETA -&amp;ScanEQ(' ', &amp;Opnds, -&amp;l); First scan to 1st blank before &lt;label&gt;        IF &amp;i = &amp;l THEN#        AERROR 'GOTO# label missing'       GOTO .Exit
      ENDIFW      Expr#.&amp;Ext &amp;Opnds,True=&amp;Opnds[&amp;l-&amp;i+1:&amp;i],False=%L%&amp;SysNdx,JumpCond=1,Keyword=THENI       IF NOT &amp;FalseUsed# GOTO .Exit  ; If we need False label, generate it
%L%&amp;SysNdx*       GOTO .Exit          ; Wasn't that simple?     ENDIF   ENDIF           BRA.&amp;Ext  &amp;Opnds .Exit  Print  Pop&yuml; SEXPR#           SExpr#  &amp;Expr,&amp;Keyword     GBLA    &amp;Cp#        ; scan pointer&amp;    GBLA    &amp;Cmp#      ; condition code index7    GBLC    &amp;Left#      ; left &lt;ea&gt; if &lt;s-expr&gt; = &lt;ea&gt;&lt;cc&gt;&lt;ea&gt;9    GBLC    &amp;Right#      ; right &lt;ea&gt; if &lt;s-expr&gt; = &lt;ea&gt;&lt;cc&gt;&lt;ea&gt;&amp;    GBLC    &amp;CC#        ; condition code table/    GBLC    &amp;Op#        ; AND or OR delimiter or &lt;null&gt;2    GBLC    &amp;Size#      ; size attribute from &lt;cc&gt;[.&lt;sz&gt;]:    GBLC    &amp;Extent#      ; extent attribute on delimiter keyword)    GBLA    &amp;Debug#      ; debug printing switch     LCLC    &amp;Token     LCLA    &amp;p,&amp;i,&amp;First,&amp;Last7  &amp;Cmp#:   SETA 0        ; Assume we only have a simple &lt;cc&gt;8  &amp;Size#:  SETC 'W'        ; The default size attribute is .W8  &amp;Op#:    SETC ''        ; If only &lt;cc&gt;, &amp;Op# will be &lt;null&gt;:  &amp;Right#: SETC ''        ; And there would be no right operand/   IF &amp;Len(&amp;SysTokStr) = 2 THEN    ; Possible &lt;cc&gt;D    &amp;Cmp#: SETA &amp;Pos(&amp;Concat(&amp;UC(&amp;SysTokStr), '.'), &amp;CC#); Look it up4     IF &amp;Cmp# THEN        ; Have &lt;s-expr&gt; ::= &lt;cc&gt;[.&lt;sz&gt;]2      &amp;Left#: SETC ''        ; There is no left operandB       IF &amp;Expr[&amp;Cp#:1] &shy; '.' THEN  ; Have explicit size attribute ?G        &amp;Cp#: SETA &amp;Lex(&amp;Expr, &amp;Cp#)  ; No, scan the delimiter for caller,       ELSE            ; If explicit size attribute=        &amp;Size#: SETC &amp;UC(&amp;Expr[&amp;Cp#+1:1]); Return it to callerC        &amp;Cp#:   SETA &amp;Lex(&amp;Expr, &amp;Cp#+2) ; Scan delimiter for caller
      ENDIFJ       IF &amp;SysToken &shy; 0 GOTO .Exit  ; Exit if delimiter is not an identifierG      &amp;Token: SETC &amp;UC(&amp;SysTokStr)  ; If identifier, see if it is keyword*       IF &amp;Token = &amp;Keyword THEN    ; Is it ?D         IF &amp;Expr[&amp;Cp#:1] = '.' THEN  ; Yes, return &lt;extent&gt; to caller3          &amp;Extent#: SETC &amp;UC(&amp;Trim(&amp;Expr[&amp;Cp#+1:1]))+          &amp;Cp#:     SETA &amp;Lex(&amp;Expr, &amp;Cp#+2)        ENDIF                                              5       ELSEIF (&amp;Token = 'AND') OR (&amp;Token = 'OR') THENB        &amp;Op#: SETC &amp;Token      ; Tell caller we have AND, OR delimiter#        &amp;Cp#: SETA &amp;Lex(&amp;Expr, &amp;Cp#)
      ENDIF7       GOTO .Exit          ; Skip over &lt;ea&gt; &lt;cc&gt; &lt;ea&gt; parsing     ENDIF   ENDIFA  &amp;Left#: SETC &amp;SysTokStr      ; The caller already scanned 1st token8  &amp;First: SETA &amp;Cp#        ; &quot;First&quot; is not-quite right here!4   WHILE &amp;Cmp# = 0 DO        ; Loop until &lt;cc&gt; is scanned;    &amp;Last: SETA &amp;Cp#        ; Assume next token will be the &lt;cc&gt;5    &amp;Cp#: SETA &amp;Lex(&amp;Expr, &amp;Cp#)  ; Scan the next tokenD     IF &amp;SysToken = 0 THEN      ; If possible &lt;cc&gt; (an identifier token)M       IF &amp;Len(&amp;SysTokStr) = 2 THEN  ; And the id length is 2 ==&gt; possible &lt;cc&gt;&lt;        &amp;Cmp#: SETA &amp;Pos(&amp;Concat(&amp;UC(&amp;SysTokStr), '.'), &amp;CC#)4      IF &amp;Cmp# &shy; 0 THEN      ; Do we really have a &lt;cc&gt; ?I        IF &amp;Expr[&amp;Cp#:1] = '.' THEN; Yes, scan size attribute if it's there$      &amp;Size#: SETC &amp;UC(&amp;Expr[&amp;Cp#+1:1])       &amp;Cp#:   SETA &amp;Cp#+2
       ENDIF      ENDIF
      ENDIFF     ELSEIF &amp;SysToken = 30 THEN    ; If we hit end of expr, we have error       AERROR 'Invalid expression'
      EXITM     ENDIF   ENDWB  &amp;Left#: SETC &amp;Trim(&amp;Concat(&amp;Left#, &amp;Expr[&amp;First:&amp;Last-&amp;First+1]));  &amp;First: SETA &amp;Cp#        ; Remember the start of the left &lt;ea&gt;/   WHILE 1 DO          ; Loop until we find delimiter@    &amp;Last: SETA &amp;Cp#        ; Assume next token will be the delimiter)    &amp;Cp#: SETA &amp;Lex(&amp;Expr, &amp;Cp#)  ; Scan it8     IF &amp;SysToken = 0 THEN      ; Have an identifier token ?&lt;       IF &amp;p = 0 THEN        ; Yes, look at it only if not nested;        &amp;Token: SETC &amp;UC(&amp;SysTokStr)  ; If it isn't nested...F         IF &amp;Token = &amp;Keyword THEN  ; Do we have the specified keyword ?F           IF &amp;Expr[&amp;Cp#:1] = '.' THEN; Yes, return &lt;extent&gt; if present.            &amp;Extent#: SETC &amp;UC(&amp;Expr[&amp;Cp#+1:1])           ENDIF7           GOTO .SetLeft      ; Hop to return the left &lt;ea&gt;        ENDIFA         IF (&amp;Token = 'AND') OR (&amp;Token = 'OR') THEN; If AND or OR5          &amp;Op#: SETC &amp;Token    ; Return it to the caller%          &amp;Cp#: SETA &amp;Lex(&amp;Expr, &amp;Cp#)7           GOTO .SetLeft      ; Hop to return the left &lt;ea&gt;        ENDIF
      ENDIF,     ELSEIF &amp;SysToken = 23 THEN    ; Have &quot;)&quot; ?4      &amp;p: SETA &amp;p-1        ; Yes, decrement nesting countG       IF &amp;p &lt; 0 GOTO .SetLeft    ; If unmatched paren, just set left &lt;ea&gt;-     ELSEIF &amp;SysToken = 22 THEN     ; Have &quot;)&quot; ?8      &amp;p:      SETA &amp;p+1      ; Yes, increment nesting count3     ELSEIF &amp;SysToken = 30 THEN    ; If end of line....       GOTO .SetLeft        ; ...just set left &lt;ea&gt;     ENDIF   ENDW.SetLeft ANOP2  &amp;Right#: SETC &amp;Trim(&amp;Expr[&amp;First:&amp;Last-&amp;First+1])
.Exit ANOP       IF &amp;Debug# THEN      IF &amp;Cmp# &shy; 0 THENK      WriteLn '   ', &amp;Left#, ' ', &amp;CC#[&amp;Cmp#:2], '.', &amp;Size#, '(=', &amp;Cmp#, \K              ') ', &amp;Right#, ' Token=&quot;', &amp;SysTokStr, '&quot;(', &amp;SysToken, ')', \$           ' Extent=&quot;', &amp;Extent#, '&quot;'      ENDIF
     ENDIF.      IF (&amp;Left# &shy; '') AND (&amp;Right# = '') THEN     AERROR 'Invalid Expression'     &amp;Cmp#: SETA 0
      ENDIF&yuml; CYCLE#           Cycle#.&amp;Ext &amp;Who     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack                          &lt;    GBLC    &amp;LblStk#[25]    ; Repeat#, While#, or For# label stackD    GBLC    &amp;Lbl2Stk#[25]    ; lbl suffix stack for Cycle# in REPEAT#,FOR#     GBLA    &amp;Cp#        ; scan pointer&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)     LCLA    &amp;Kind,&amp;StkPtr     LCLC    &amp;Lbl,&amp;Cond,&amp;S    IF &amp;StkPtr# = 0 THENC    AERROR 'CYCLE# must be nested inside a REPEAT#, WHILE#, or FOR#'      GOTO .Exit   ENDIF0   IF &amp;Who &shy; '' THEN        ; If any thing to scan...-    &amp;Cp#: SETA &amp;Lex(&amp;Who, 1)    ; Scan 1st token;     IF &amp;SysToken &shy; 0 THEN      ; We must have an idtentifier ?*      AERROR 'CYCLE# label or IF# expected'        GOTO .Exit     ENDIF&lt;    &amp;S: SETC &amp;UC(&amp;SysTokStr)    ; See if we have explicit label=     IF (&amp;S &shy;'IF') AND (&amp;S &shy; 'IF#') THEN; If explicit label...(      &amp;Lbl: SETC &amp;SysTokStr    ; Pick it up@      &amp;Cp#: SETA &amp;Lex(&amp;Who, &amp;Cp#)  ; Scan for conditional (if any)I       IF &amp;Systoken &shy; 30 THEN    ; If not end of line, we have a conditionalC        &amp;S: SETC &amp;UC(&amp;SysTokStr)  ; We now must have an &quot;IF&quot; or &quot;IF#&quot;5         IF (&amp;S &shy; 'IF') AND (&amp;S &shy; 'IF#') THEN; Is it ?(       AERROR 'Invalid CYCLE# conditional'         GOTO .Exit        ENDIFD        &amp;Cond: SETC &amp;Trim(&amp;Who[&amp;Cp#:255]); Extract conditional &lt;expr&gt;
      ENDIF4     ELSE            ; If conditional but no explicit labelG      &amp;Cond: SETC &amp;Trim(&amp;Who[&amp;Cp#:255]); Just extract conditional &lt;expr&gt;     ENDIF   ENDIF?  &amp;StkPtr: SETA &amp;StkPtr#      ; Prepare to scan the statement stack:   IF &amp;Lbl &shy; '' THEN        ; Have explicit label to look for ?1     WHILE &amp;LblStk#[&amp;StkPtr]&shy;&amp;Lbl DO  ; Look for it       &amp;StkPtr: SETA &amp;StkPtr-1        IF &amp;StkPtr = 0 THENH          AERROR &amp;Concat(&amp;Lbl, ' is not a REPEAT#, WHILE#, or FOR# label')        GOTO .Exit
      ENDIF     ENDW#   ELSE              ; If no explicit labelK     WHILE &amp;KindStk#[&amp;StkPtr] = 5 DO  ; Look for deepest loop after Switch#'s       &amp;StkPtr: SETA &amp;StkPtr-1        IF &amp;StkPtr = 0 THENH          AERROR &amp;Concat(&amp;Lbl, ' is not a REPEAT#, WHILE#, or FOR# label')        GOTO .Exit
      ENDIF     ENDW   ENDIFH  &amp;Kind: SETA &amp;KindStk#[&amp;StkPtr]  ; See which stmt we are doing Cycle# for4   IF (&amp;Kind = 2) OR (&amp;Kind = 4) THEN ; REPEAT#, FOR##     IF &amp;Lbl2Stk#[&amp;StkPtr] = '' THEN%      &amp;Lbl2Stk#[&amp;StkPtr]: SETC &amp;SysNdx     ENDIF      IF &amp;Cond = '' THEN)          BRA.&amp;Ext  %C%&amp;Lbl2Stk#[&amp;StkPtr]      ELSEL      Expr#.&amp;Ext &amp;Cond,True=%C%&amp;Lbl2Stk#[&amp;StkPtr],False=%L%&amp;SysNdx,JumpCond=1I       IF NOT &amp;FalseUsed# GOTO .Exit  ; If we need False label, generate it
%L%&amp;SysNdx     ENDIF&quot;   ELSEIF &amp;Kind = 3 THEN      ; WHILE#      IF &amp;Cond = '' THEN%          BRA.&amp;Ext  &amp;LblStk#[&amp;StkPtr]      ELSEH      Expr#.&amp;Ext &amp;Cond,True=&amp;LblStk#[&amp;StkPtr],False=%L%&amp;SysNdx,JumpCond=1I       IF NOT &amp;FalseUsed# GOTO .Exit  ; If we need False label, generate it
%L%&amp;SysNdx     ENDIF    ELSEC    AERROR 'CYCLE# must be nested inside a REPEAT#, WHILE#, or FOR#'   ENDIF .Exit  PRINT  Pop&yuml; WHILE#       &amp;Lbl    While#  &amp;Expr     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack:    GBLC    &amp;LblStk#[25]    ; While# label for Cycle# and Leave#&lt;    GBLC    &amp;Lbl1Stk#[25]    ; label suffix for Leave# and While#                        /    GBLC    &amp;Lbl2Stk#[25]    ; extent attribute on DO6    GBLC    &amp;Extent#      ; extent attribute on DO from Expr#&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)
    LCLA    &amp;i    IF &amp;StkPtr# = 25 THEN&amp;    AERROR 'Too many nested statements'      GOTO .Exit   ENDIF.  &amp;StkPtr#: SETA &amp;StkPtr#+1    ; Update stack ptrB   IF &amp;Lbl = '' THEN        ; Remember label for Until#, Cycle#, Leave#3    &amp;LblStk#[&amp;StkPtr#]: SETC &amp;Concat('%L%', &amp;SysNdx)    ELSE     &amp;LblStk#[&amp;StkPtr#]: SETC &amp;Lbl   ENDIFC  &amp;Lbl1Stk#[&amp;StkPtr#]: SETC &amp;SysNdx  ; We always need a &quot;leave&quot; label&gt;  &amp;KindStk#[&amp;StkPtr#]: SETA 3    ; Kind = 3 for While# statements &amp;LblStk#[&amp;StkPtr#]   &amp;i: SETA &amp;Lex(&amp;Expr, 1)    IF &amp;SysToken = 0 THEN$     IF &amp;UC(&amp;SysTokStr) = 'TRUE' THEN       &amp;i: SETA &amp;Lex(&amp;expr, &amp;i)        IF &amp;SysToken = 0 THEN&amp;         IF &amp;UC(&amp;SysTokStr) = 'DO' THEN         IF &amp;Expr[&amp;i:1] = '.' THEN3         &amp;Lbl2Stk#[&amp;StkPtr#]: SETC &amp;UC(&amp;Expr[&amp;i+1:1])
        ELSE$         &amp;Lbl2Stk#[&amp;StkPtr#]: SETC 'W'
       ENDIF         GOTO .Exit      ENDIF
      ENDIF     ENDIF   ENDIFC  Expr# &amp;Expr,True=%E%&amp;SysNdx,False=%F%&amp;SysNdx,JumpCond=0,Keyword=DO&gt;  &amp;Lbl2Stk#[&amp;StkPtr#]: SETC &amp;Extent#  ; Remember &lt;ext&gt; for EndW#?   IF &amp;FalseUsed# THEN         ; If we need False label, generate it
%F%&amp;SysNdx   ENDIF .Exit  PRINT  Pop&yuml; IF#          If#    &amp;Expr     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack8    GBLC    &amp;LblStk#[25]    ; label suffix to next If# section;    GBLC    &amp;Lbl1Stk#[25]    ; label suffix to EndIf# for ElseIf#&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)    IF &amp;StkPtr# = 25 THEN&amp;    AERROR 'Too many nested statements'      GOTO .Exit   ENDIF7  &amp;StkPtr#:            SETA &amp;StkPtr#+1; Update stack ptrL  &amp;LblStk#[&amp;StkPtr#]:  SETC &amp;SysNdx   ; Label suffix to Else#, ElseIf#, EndIf#0  &amp;Lbl1Stk#[&amp;StkPtr#]: SETC ''     ; No ElseIf# yet&lt;  &amp;KindStk#[&amp;StkPtr#]: SETA 1     ; Kind = 1 for If# statementsE  Expr# &amp;Expr,True=%L%&amp;SysNdx,False=%F%&amp;SysNdx,JumpCond=0,Keyword=THEN?   IF &amp;FalseUsed# THEN         ; If we need False label, generate it
%F%&amp;SysNdx   ENDIF .Exit  Print  Pop&yuml; UNTIL#           Until#.&amp;Ext &amp;Expr     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack;    GBLC    &amp;LblStk#[25]    ; Repeat# label for Cycle# and Leave#0    GBLC    &amp;Lbl1Stk#[25]    ; label suffix for Leave#0    GBLC    &amp;Lbl2Stk#[25]    ; label suffix for Cycle#&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)    IF &amp;StkPtr# = 0 THEN)    AERROR 'UNTIL# does not end a REPEAT#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 2 THEN)    AERROR 'UNTIL# does not end a REPEAT#'      GOTO .Exit   ENDIF    IF &amp;UC(&amp;Expr) = 'FALSE' THENI     IF &amp;Lbl2Stk#[&amp;StkPtr#] &shy; '' THEN    ; Equate cycle label to top of loop2%C%&amp;Lbl2Stk#[&amp;StkPtr#] EQU      &amp;LblStk#[&amp;StkPtr#]     ENDIF&amp;          BRA.&amp;Ext  &amp;LblStk#[&amp;StkPtr#]     GOTO .L1   ENDIF&quot;   IF &amp;Lbl2Stk#[&amp;StkPtr#] &shy; '' THEN %C%&amp;Lbl2Stk#[&amp;StkPtr#]   ENDIFE  Expr#.&amp;Ext &amp;Expr,True=&amp;LblStk#[&amp;StkPtr#],False=%F%&amp;SysNdx,JumpCond=0?   IF &amp;FalseUsed# THEN         ; If we need False label, generate it
%F%&amp;SysNdx      ENDIF% .L1  IF &amp;Lbl1Stk#[&amp;StkPtr#] &shy; '' THEN %E%&amp;Lbl1Stk#[&amp;StkPtr#]     ENDIF   &amp;StkPtr#: SETA &amp;StkPtr#-1 .Exit  PRINT  Pop&yuml; ENDIF#           EndIf#     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack8    GBLC    &amp;LblStk#[25]    ; label suffix to next If# section;    GBLC    &amp;Lbl1Stk#[25]    ; label suffix to EndIf# for ElseIf#    IF &amp;StkPtr# = 0 THEN&amp;    AERROR 'ENDIF# does not end an IF#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 1 THEN&amp;    AERROR 'ENDIF# does not end an IF#'      GOTO .Exit   ENDIF %L%&amp;LblStk#[&amp;StkPtr#]&quot;   IF &amp;Lbl1Stk#[&amp;StkPtr#] &shy; '' THEN %E%&amp;Lbl1Stk#[&amp;StkPtr#]   ENDIF   &amp;StkPtr#: SETA &amp;StkPtr#-1 .Exit  PRINT  Pop&yuml; SWITCH#      ;&amp;Lbl    Switch#.&amp;Sz &amp;Selector,&amp;Dreg==D0,&amp;JmpTbl==N,&amp;ChkRng==N     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack0    GBLC    &amp;LblStk#[25]    ; Switch# label for Leave#5    GBLC    &amp;Lbl1Stk#[25]    ; most recent Case# &lt;ae&gt; value0    GBLC    &amp;Lbl2Stk#[25]    ; next Case# label suffix&gt;    GBLA    &amp;CaseStkPtr#    ; case stack pointer for nested switches?    GBLA    &amp;FrstCase#[25]    ; index of 1st Case# label in &amp;CaseStk#'    GBLA    &amp;Low#[25]      ; lowest case value(    GBLA    &amp;High#[25]    ; highest case value&lt;    GBLA    &amp;JmpTbl#[25]    ; 0==&gt;SUB's; 1==&gt;JumpTbl; 2==&gt;ChkRng=Y:    GBLC    &amp;EndSwLbl#[25]    ; end case label suffix for Leave#5    GBLC    &amp;Dreg#[25]    ; D-register used by this Switch#4    GBLC    &amp;Default#[25]    ; default label from Default#     LCLC    &amp;t1,&amp;t2    IF &amp;StkPtr# = 25 THEN&amp;    AERROR 'Too many nested statements'      GOTO .Exit   ENDIF.  &amp;StkPtr#: SETA &amp;StkPtr#+1    ; Update stack ptr@  &amp;KindStk#[&amp;StkPtr#]: SETA 5    ; Kind = 5 for Switch# statements  &gt;  &amp;Default#[&amp;StkPtr#]: SETC ''    ; There is no default label yetB  &amp;EndSwLbl#[&amp;StkPtr#]: SETC &amp;SysNdx  ; Set end of case label suffix2   IF &amp;Lbl = '' THEN        ; Remember label for Leave#     &amp;LblStk#[&amp;StkPtr#]: SETC ''    ELSE     &amp;LblStk#[&amp;StkPtr#]: SETC &amp;Lbl &amp;Lbl   ENDIF5  &amp;t1: SETC &amp;Type(&amp;Selector)    ; Check out the selector9   IF (&amp;t1[1:5] &shy; 'REG D') OR (&amp;t1[5:2] &shy; &amp;UC(&amp;Dreg)) THEN      IF &amp;UC(&amp;Sz) = 'B' THEN           MOVEQ     #0,&amp;Dreg     ENDIF#          MOVE.&amp;Sz  &amp;Selector,&amp;Dreg   ENDIF@  &amp;Dreg#[&amp;StkPtr#]: SETC &amp;Dreg    ; Remember the D-reg we are using@  &amp;t1: SETC &amp;UC(&amp;JmpTbl[1:1])    ; See if we are to us a jump table?   IF &amp;Pos(&amp;t1, 'YWSBL') THEN    ; JumpTbl = Y[es] | S | B | W | L6     IF &amp;t1 = 'Y' THEN        ; If we had JmpTbl = Y[es]...4      &amp;t1: SETC 'W'        ; ...pretend it was JmpTbl = W     ENDIFJ    &amp;t2: SETC &amp;UC(&amp;ChkRng[1:1])    ; Should a range check be done on selector)     IF &amp;t2 = 'Y' THEN        ; ChkRng = Y[es]D      &amp;JmpTbl#[&amp;StkPtr#]: SETA 2  ; Tell EndS# to gen range check code      ELSE            ; ChkRng = N[o]        IF &amp;t2 &shy; 'N' THENA     AERROR 'Invalid ChkRng specification -- ChkRng=N assumed'      
      ENDIFH      &amp;JmpTbl#[&amp;StkPtr#]: SETA 1  ; Tell EndS# we're only doing jump table     ENDIF@    &amp;Low#[&amp;StkPtr#]:  SETA $7FFFFFFF  ; Init lowest case tag valueA    &amp;High#[&amp;StkPtr#]: SETA $80000000  ; Init highest case tag value                                   2    PRINT Push,NoWarn        ; Gen branch to EndS# code           BRA.&amp;t1   %L%&amp;SysNdx    PRINT PopE     IF &amp;CaseStkPtr# = 250 THEN    ; Prepare to set &amp;FrstCase#[&amp;StkPtr#];      AERROR 'Too many &quot;JmpTbl&quot; cases -- max of 250 allowed'      ELSEE      &amp;FrstCase#[&amp;StkPtr#]: SETA &amp;CaseStkPtr#+1; 1st Case# label index     ENDIF    ELSE              ; JumpTbl = N[o]I    &amp;JmpTbl#[&amp;StkPtr#]:  SETA 0    ; Tell EndS# we're not using a jump table@    &amp;Lbl1Stk#[&amp;StkPtr#]: SETC ''  ; There is no previous  case yet@    &amp;Lbl2Stk#[&amp;StkPtr#]: SETC ''  ; And no next Case# label either      IF &amp;t1 &shy; 'N' THEN&gt;      AERROR 'Invalid JmpTbl specification -- JmpTbl=N assumed'     ENDIF   ENDIF .Exit  PRINT  Pop&yuml; ELSEIF#           ElseIf#.&amp;Ext &amp;Expr     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack8    GBLC    &amp;LblStk#[25]    ; label suffix to next If# section;    GBLC    &amp;Lbl1Stk#[25]    ; label suffix to EndIf# for ElseIf#&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)    IF &amp;StkPtr# = 0 THEN&amp;    AERROR 'ELSE# not nested in an IF#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 1 THEN&amp;    AERROR 'ELSE# not nested in an IF#'      GOTO .Exit   ENDIF&quot;   IF &amp;Lbl1Stk#[&amp;StkPtr#] = '' THEN$    &amp;Lbl1Stk#[&amp;StkPtr#]: SETC &amp;SysNdx           BRA.&amp;Ext  %E%&amp;SysNdx    ELSE*          BRA.&amp;Ext  %E%&amp;Lbl1Stk#[&amp;StkPtr#]   ENDIF %L%&amp;LblStk#[&amp;StkPtr#]F   Expr# &amp;Expr,True=%L%&amp;SysNdx,False=%F%&amp;SysNdx,JumpCond=0,Keyword=THEN!  &amp;LblStk#[&amp;StkPtr#]: SETC &amp;SysNdx?   IF &amp;FalseUsed# THEN         ; If we need False label, generate it
%F%&amp;SysNdx   ENDIF .Exit  PRINT  Pop&yuml; REPEAT#      &amp;Lbl    Repeat#     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack;    GBLC    &amp;LblStk#[25]    ; Repeat# label for Cycle# and Leave#0    GBLC    &amp;Lbl1Stk#[25]    ; label suffix for Leave#0    GBLC    &amp;Lbl2Stk#[25]    ; label suffix for Cycle#    IF &amp;StkPtr# = 25 THEN&amp;    AERROR 'Too many nested statements'      GOTO .Exit   ENDIF.  &amp;StkPtr#: SETA &amp;StkPtr#+1    ; Update stack ptrB   IF &amp;Lbl = '' THEN        ; Remember label for Until#, Cycle#, Leave#3    &amp;LblStk#[&amp;StkPtr#]: SETC &amp;Concat('%L%', &amp;SysNdx)    ELSE     &amp;LblStk#[&amp;StkPtr#]: SETC &amp;Lbl   ENDIF.  &amp;Lbl1Stk#[&amp;StkPtr#]: SETC ''    ; No Leave# yet.  &amp;Lbl2Stk#[&amp;StkPtr#]: SETC ''    ; No Cycle# yet?  &amp;KindStk#[&amp;StkPtr#]: SETA 2    ; Kind = 2 for Repeat# statements &amp;LblStk#[&amp;StkPtr#] .Exit  PRINT  Pop&yuml; CASE#          Case#.&amp;Ext     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack5    GBLC    &amp;Lbl1Stk#[25]    ; most recent Case# &lt;ae&gt; value0    GBLC    &amp;Lbl2Stk#[25]    ; next Case# label suffix&gt;    GBLA    &amp;CaseStkPtr#    ; case stack pointer for nested switches'    GBLA    &amp;Low#[25]      ; lowest case value(    GBLA    &amp;High#[25]    ; highest case value&lt;    GBLA    &amp;JmpTbl#[25]    ; 0==&gt;SUB's; 1==&gt;JumpTbl; 2==&gt;ChkRng=Y5    GBLC    &amp;Dreg#[25]    ; D-register used by this Switch#+    GBLC    &amp;CaseStk#[250]    ; Case# label stack$    LCLC    &amp;Case,&amp;Low,&amp;High,&amp;Dreg,&amp;Prev!    LCLA    &amp;Case1,&amp;Case2,&amp;t,&amp;N,&amp;i,&amp;j    IF &amp;StkPtr# = 0 THEN                        *    AERROR 'CASE# not nested in an SWITCH#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 5 THEN*    AERROR 'CASE# not nested in an SWITCH#'      GOTO .Exit   ENDIF&lt;  &amp;N: SETA &amp;Nbr(&amp;SysLst)      ; Get number of Case# tag (ranges):   IF &amp;JmpTbl#[&amp;StkPtr#] THEN    ; Doing a jump table Case# ?
%C%&amp;SysNdx@     WHILE &amp;i &lt; &amp;N DO        ; Yes, loop through all Case# parameters+      &amp;i: SETA &amp;i+1        ; Count the parameter*      &amp;Case: SETC &amp;SysLst[&amp;i]    ; Pick it upA      &amp;j: SETA &amp;Pos('..', &amp;Case)  ; See if we have a case tag range        IF &amp;j THEN          ; Is it ?=        &amp;Case1: SETA &amp;Eval(&amp;Case[1:&amp;j-1])                ; YesE     &amp;Case2: SETA &amp;Eval(&amp;Case[&amp;j+2:&amp;Len(&amp;Case)-&amp;j-1]) ; Get both &lt;ae&gt;'s,       ELSE            ; If not a case tag range...&gt;        &amp;Case1: SETA &amp;Eval(&amp;Case)  ; ...both &lt;ae&gt;'s are the same      &amp;Case2: SETA &amp;Case1?     &amp;j:     SETA 256      ; Fake out to set &lt;ae&gt; in &amp;CaseStk# below
      ENDIFG       IF &amp;CaseStkPtr# = 250 THEN  ; Make sure we can save the label info9     AERROR 'Too many &quot;JmpTbl&quot; cases -- max of 250 allowed'       GOTO .Exit
      ENDIF9       IF &amp;Case1 &gt; &amp;Case2 THEN    ; Make sure &lt;ae1&gt; &lt;= &lt;ae2&gt;5        AERROR &amp;Concat('Invalid CASE# range: ', &amp;Case)*     &amp;t: SETA &amp;Case1      ; If &lt;ae1&gt; &gt; &lt;ae2&gt;...&gt;     &amp;Case1: SETA &amp;Case2    ; Invert the range for the hell of it!      &amp;Case2: SETA &amp;t
      ENDIFE      &amp;t: SETA &amp;Case2-&amp;Case1+1    ; Get nbr of case tags in range (NNNN)H      &amp;CaseStkPtr#: SETA &amp;CaseStkPtr#+1; Stack the case info in &amp;CaseStk#P      &amp;CaseStk#[&amp;CaseStkPtr#]: SETC &amp;Concat(&amp;SysNdx, &amp;I2S(&amp;t, -4), &amp;Case[1:&amp;j-1])H      &amp;Low#[&amp;StkPtr#]: SETA &amp;Min(&amp;Low#[&amp;StkPtr#], &amp;Case1)   ; Get min tagH      &amp;High#[&amp;StkPtr#]: SETA &amp;Max(&amp;High#[&amp;StkPtr#], &amp;Case2) ; Get max tag     ENDW+   ELSE              ; Not doing a jump table Case#=    &amp;Dreg: SETC &amp;Dreg#[&amp;StkPtr#]  ; Prepare to gen subtractionsB    &amp;Prev: SETC &amp;Lbl1Stk#[&amp;StkPtr#]  ; &amp;Prev will hold previous &lt;ae&gt;@     IF &amp;Prev &shy; '' THEN      ; Gen destination label if not 1st time %C%&amp;Lbl2Stk#[&amp;StkPtr#]     ENDIFC    &amp;Lbl2Stk#[&amp;StkPtr#]: SETC &amp;SysNdx; Set destination to next Case#=     WHILE &amp;i &lt; &amp;N DO        ; Gen subtractions for each parameter+      &amp;i: SETA &amp;i+1        ; Count the parameter*      &amp;Case: SETC &amp;SysLst[&amp;i]    ; Pick it upA      &amp;j: SETA &amp;Pos('..', &amp;Case)  ; See if we have a case tag range=       IF &amp;j THEN          ; Case tag range: Case# &lt;ae1&gt;..&lt;ae2&gt;,...F        &amp;Low:  SETC &amp;Case[1:&amp;j-1]  ; Yes, extract both &lt;ae&gt;'s as strings+     &amp;High: SETC &amp;Case[&amp;j+2:&amp;Len(&amp;Case)-&amp;j-1]D     &amp;Case1: SETA &amp;Eval(&amp;Low)  ; Get values of &lt;ea&gt;'s to check ordering      &amp;Case2: SETA &amp;Eval(&amp;High)7      IF &amp;Case1 &gt; &amp;Case2 THEN    ; Make sure &lt;ae1&gt; &lt;= &lt;ae2&gt;3       AERROR &amp;Concat('Invalid CASE# range: ', &amp;Case)-       &amp;Case: SETC &amp;Low      ; If &lt;ae1&gt; &gt; &lt;ae2&gt;...&gt;       &amp;Low:  SETC &amp;High    ; Invert the range for the hell of it!9       &amp;High: SETC &amp;Case    ; Note, here we using the strings      ENDIF.      IF &amp;i &lt; &amp;N THEN      ; Case# &lt;ae1&gt;..&lt;ae2&gt;,...$          SUB.W     #&amp;Low&amp;Prev,&amp;Dreg           BLT.S     @&amp;i%          SUB.W     #&amp;High-&amp;Low,&amp;Dreg           BLE.S     %T%&amp;SysNdx @&amp;i%      ELSE          ; Case# ...,&lt;ae1&gt;..&lt;ae2&gt;$          SUB.W     #&amp;Low&amp;Prev,&amp;Dreg           BLT.&amp;Ext  %C%&amp;SysNdx         %          SUB.W     #&amp;High-&amp;Low,&amp;Dreg           BGT.&amp;Ext  %C%&amp;SysNdx      ENDIF&amp;        &amp;Prev: SETC &amp;Concat('-', &amp;High)7       ELSE            ; Not a case tage range: Case# &lt;ae&gt;,...&amp;      IF &amp;i &lt; &amp;N THEN      ; Case# &lt;ae&gt;,...%          SUB.W     #&amp;Case&amp;Prev,&amp;Dreg           BEQ.S     %T%&amp;SysNdx       ELSE          ; Case# ...,&lt;ae&gt;%          SUB.W     #&amp;Case&amp;Prev,&amp;Dreg           BNE.&amp;Ext  %C%&amp;SysNdx      ENDIF&amp;        &amp;Prev: SETC &amp;Concat('-', &amp;Case)
      ENDIF     ENDW;     IF &amp;N &shy; 1 THEN        ; Gen &quot;true&quot; label if nore than 1 tag
%T%&amp;SysNdx     ENDIF?    &amp;Lbl1Stk#[&amp;StkPtr#]: SETC &amp;Prev  ; Update for next Case# call   ENDIF .Exit  PRINT  Pop&yuml; ENDF#           EndF#     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack6    GBLA    &amp;Incr#[25]    ; 1==&gt;TO; 0 ==&gt;DOWNTO; -1 ==&gt; DBcc8    GBLC    &amp;LblStk#[25]    ; For# label for Cycle# and Leave#0    GBLC    &amp;Lbl1Stk#[25]    ; label suffix for Leave#0    GBLC    &amp;Lbl2Stk#[25]    ; label suffix for Cycle#2    GBLC    &amp;Sz#[25]      ; size of control reg (B, W, L)1    GBLC    &amp;Op1#[25]      ; &lt;op1&gt;, loop control counter'    GBLC    &amp;Op3#[25]      ; &lt;op3&gt;, loop limit+    GBLC    &amp;Op4#[25]      ; &lt;op4&gt;, loop increment2    GBLC    &amp;Until#[25]    ; &lt;expr&gt;, loop end  condition9    GBLC    &amp;Dreg#[25]    ; work register if &lt;op1&gt; is not a reg&amp;    GBLC    &amp;CC#        ; Condition code table&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)+    LCLC    &amp;Op1,&amp;Op3,&amp;OP4,&amp;Lbl,&amp;Sz,&amp;DBcc,&amp;Dreg    LCLA    &amp;Incr    IF &amp;StkPtr# = 0 THEN%    AERROR 'ENDF# does not end a FOR#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 4 THEN%    AERROR 'ENDW# does not end a FOR#'      GOTO .Exit   ENDIF$  &amp;Op1: SETC &amp;Op1#[&amp;StkPtr#]    ; &lt;op1&gt;$  &amp;Op3: SETC &amp;Op3#[&amp;StkPtr#]    ; &lt;op3&gt;$  &amp;Op4: SETC &amp;Op4#[&amp;StkPtr#]    ; &lt;op4&gt;:  &amp;Lbl: SETC &amp;Lbl1Stk#[&amp;StkPtr#]  ; Top of loop label suffix3  &amp;Sz:  SETC &amp;Sz#[&amp;StkPtr#]    ; Size of loop register.  &amp;Incr:SETA &amp;Incr#[&amp;StkPtr#]    ; Loop direction.   IF &amp;Incr &lt; 0 THEN        ; Are we to do a DBcc ?4    &amp;DBcc: SETC 'F'        ; Yes, assume it will be a DBF   ENDIF5  &amp;Dreg: SETC &amp;Dreg#[&amp;StkPtr#]    ; Set work reg, if any&quot;   IF &amp;Lbl2Stk#[&amp;StkPtr#] &shy; '' THEN %C%&amp;Lbl2Stk#[&amp;StkPtr#]   ENDIF9   IF &amp;Until#[&amp;StkPtr#] &shy; '' THEN  ; Have an UNTIL clause ?.    &amp;FalseUsed#: SETA 0      ; Make sure of switch?     IF &amp;DBcc = '' THEN      ; Yes, are we generation a DBcc loop ?[      Expr#.S &amp;Until#[&amp;StkPtr#],True=%E%&amp;Lbl,False=%F%&amp;SysNdx,JumpCond=0; No, treat like If#      ELSE            ; If DBcc loopM      &amp;DBcc: SETC &amp;Until#[&amp;StkPtr#]  ; See if &lt;expr&gt; is a simple condition codeE      &amp;CC#: SETC 'EQ.NE.LE.LT.GE.GT.MI.PL.HI.LS.LO.CC.CS.NZ.HS.VC.VS.'Q       IF &amp;Pos(&amp;Concat(&amp;UC(&amp;DBcc), '.'), &amp;CC#) = 0 THEN; Not simple condition codeR     Expr#.S &amp;DBcc,True=%E%&amp;Lbl,False=%F%&amp;SysNdx,JumpCond=0; Still treat like an If#1     &amp;DBcc: SETC 'F'      ; And loop will become a DBF
      ENDIF     ENDIF?     IF &amp;FalseUsed# THEN      ; If we need False label, generate it
%F%&amp;SysNdx     ENDIF   ENDIF&gt;  PRINT Push,NoWarn        ; Suppress any Assembler branch warnings!   IF &amp;Incr = 1 THEN        ; TO loopsG     IF &amp;Dreg &shy; '' THEN      ; Case 1 - TO loop, not DBcc, needing work reg           MOVE.&amp;Sz  &amp;Op1,&amp;Dreg                ADD.&amp;Sz   &amp;Op4,&amp;Dreg %L%&amp;Lbl   MOVE.&amp;Sz  &amp;Dreg,&amp;Op1           CMP.&amp;Sz   &amp;Op3,&amp;Dreg           BLE       %Loop%&amp;Lbl %E%&amp;Lbl&lt;     ELSE            ; Case 2 - TO loop, not DBcc, &lt;op1&gt; is a D-reg           ADD.&amp;Sz   &amp;Op4,&amp;Op1 %L%&amp;Lbl   CMP.&amp;Sz   &amp;Op3,&amp;Op1           BLE       %Loop%&amp;Lbl %E%&amp;Lbl     ENDIF(   ELSEIF &amp;Incr = 0 THEN      ; DOWNTO loopsK     IF &amp;Dreg &shy; '' THEN      ; Case 3 - DOWNTO loop, not DBcc, needing work reg           MOVE.&amp;Sz  &amp;Op1,&amp;Dreg           SUB.&amp;Sz   &amp;Op4,&amp;Dreg %L%&amp;Lbl   MOVE.&amp;Sz  &amp;Dreg,&amp;Op1           CMP.&amp;Sz   &amp;Op3,&amp;Dreg           BGE       %Loop%&amp;Lbl %E%&amp;Lbl@     ELSE            ; Case 4 - DOWNTO loop, not DBcc, &lt;op1&gt; is a D-reg           SUB.&amp;Sz   &amp;Op4,&amp;Op1 %L%&amp;Lbl   CMP.&amp;Sz   &amp;Op3,&amp;Op1           BGE       %Loop%&amp;Lbl %E%&amp;Lbl     ENDIF!   ELSE              ; Case 5 - DBcc loop'          DB&amp;DBcc       &amp;Op1,%Loop%&amp;Lbl %E%&amp;Lbl   ENDIF
  PRINT Pop   &amp;StkPtr#: SETA &amp;StkPtr#-1 .Exit  PRINT  Pop&yuml; LEAVE#           Leave#.&amp;Ext &amp;Who     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack?    GBLC    &amp;LblStk#[25]    ; Repeat#,While#,For#,Switch# label stack&gt;    GBLC    &amp;Lbl1Stk#[25]    ; lbl suffix for Cycle# in REPEAT#,FOR#@    GBLC    &amp;EndSwLbl#[25]    ; end case label suffix stack for Leave#     GBLA    &amp;Cp#        ; scan pointer&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)     LCLA    &amp;Kind,&amp;StkPtr     LCLC    &amp;Lbl,&amp;Cond,&amp;S    IF &amp;StkPtr# = 0 THENC    AERROR 'LEAVE# must be nested inside a REPEAT#, WHILE#, or FOR#'      GOTO .Exit   ENDIF0   IF &amp;Who &shy; '' THEN        ; If any thing to scan...-    &amp;Cp#: SETA &amp;Lex(&amp;Who, 1)    ; Scan 1st token;     IF &amp;SysToken &shy; 0 THEN      ; We must have an idtentifier ?*      AERROR 'LEAVE# label or IF# expected'        GOTO .Exit     ENDIF&lt;    &amp;S: SETC &amp;UC(&amp;SysTokStr)    ; See if we have explicit label=     IF (&amp;S &shy;'IF') AND (&amp;S &shy; 'IF#') THEN; If explicit label...(      &amp;Lbl: SETC &amp;SysTokStr    ; Pick it up@      &amp;Cp#: SETA &amp;Lex(&amp;Who, &amp;Cp#)  ; Scan for conditional (if any)I       IF &amp;Systoken &shy; 30 THEN    ; If not end of line, we have a conditionalC        &amp;S: SETC &amp;UC(&amp;SysTokStr)  ; We now must have an &quot;IF&quot; or &quot;IF#&quot;5         IF (&amp;S &shy; 'IF') AND (&amp;S &shy; 'IF#') THEN; Is it ?(       AERROR 'Invalid LEAVE# conditional'         GOTO .Exit        ENDIFD        &amp;Cond: SETC &amp;Trim(&amp;Who[&amp;Cp#:255]); Extract conditional &lt;expr&gt;
      ENDIF4     ELSE            ; If conditional but no explicit labelG      &amp;Cond: SETC &amp;Trim(&amp;Who[&amp;Cp#:255]); Just extract conditional &lt;expr&gt;     ENDIF   ENDIF?  &amp;StkPtr: SETA &amp;StkPtr#      ; Prepare to scan the statement stack:   IF &amp;Lbl &shy; '' THEN        ; Have explicit label to look for ?1     WHILE &amp;LblStk#[&amp;StkPtr]&shy;&amp;Lbl DO  ; Look for it       &amp;StkPtr: SETA &amp;StkPtr-1        IF &amp;StkPtr = 0 THENQ          AERROR &amp;Concat(&amp;Lbl, ' is not a REPEAT#, WHILE#, FOR#, or SWITCH# label')        GOTO .Exit
      ENDIF     ENDW   ENDIFH  &amp;Kind: SETA &amp;KindStk#[&amp;StkPtr]  ; See which stmt we are doing Leave# for    IF &amp;Kind = 2 THEN        ; REPEAT##     IF &amp;Lbl1Stk#[&amp;StkPtr] = '' THEN%      &amp;Lbl1Stk#[&amp;StkPtr]: SETC &amp;SysNdx     ENDIF      IF &amp;Cond = '' THEN)          BRA.&amp;Ext  %E%&amp;Lbl1Stk#[&amp;StkPtr]      ELSE           L      Expr#.&amp;Ext &amp;Cond,True=%E%&amp;Lbl1Stk#[&amp;StkPtr],False=%L%&amp;SysNdx,JumpCond=1I       IF NOT &amp;FalseUsed# GOTO .Exit  ; If we need False label, generate it
%L%&amp;SysNdx     ENDIF3   ELSEIF (&amp;Kind=3) OR (&amp;Kind=4) THEN ; WHILE#, FOR#      IF &amp;Cond = '' THEN)          BRA.&amp;Ext  %E%&amp;Lbl1Stk#[&amp;StkPtr]      ELSEL      Expr#.&amp;Ext &amp;Cond,True=%E%&amp;Lbl1Stk#[&amp;StkPtr],False=%L%&amp;SysNdx,JumpCond=1I       IF NOT &amp;FalseUsed# GOTO .Exit  ; If we need False label, generate it
%L%&amp;SysNdx     ENDIF#   ELSEIF &amp;Kind = 5 THEN      ; SWITCH#      IF &amp;Cond = '' THEN*          BRA.&amp;Ext  %E%&amp;EndSwLbl#[&amp;StkPtr]      ELSEM      Expr#.&amp;Ext &amp;Cond,True=%E%&amp;EndSwLbl#[&amp;StkPtr],False=%L%&amp;SysNdx,JumpCond=1I       IF NOT &amp;FalseUsed# GOTO .Exit  ; If we need False label, generate it
%L%&amp;SysNdx     ENDIF    ELSEL    AERROR 'LEAVE# must be nested inside a REPEAT#, WHILE#, FOR#, or SWITCH#'   ENDIF .Exit  PRINT  Pop&yuml; DEFAULT#      
    Default#     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack4    GBLC    &amp;Default#[25]    ; default label from Default#    IF &amp;StkPtr# = 0 THEN-    AERROR 'DEFAULT# not nested in an SWITCH#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 5 THEN-    AERROR 'DEFAULT# not nested in an SWITCH#'      GOTO .Exit   ENDIF&quot;   IF &amp;Default#[&amp;StkPtr#] &shy; '' THEN7    AERROR 'DEFAULT# already specified for this SWITCH#'      GOTO .Exit   ENDIF
%D%&amp;SysNdx2  &amp;Default#[&amp;StkPtr#]: SETC &amp;Concat('%D%', &amp;SysNdx) .Exit  PRINT  Pop&yuml; EXPR#      =    Expr#.&amp;Ext &amp;Expr,&amp;True==,&amp;False==,&amp;JumpCond:A==1,&amp;Keyword==     PRINT  Push,NoMDir,NoMCall     GBLA    &amp;Cp#        ; scan pointer&amp;    GBLA    &amp;Cmp#      ; condition code index&lt;    GBLA    &amp;FalseUsed#    ; &lt;ea&gt; AND(OR) &lt;ea&gt; with &amp;JumpCond=1(0)&amp;    GBLC    &amp;CC#        ; condition code table0    GBLC    &amp;NotCC#      ; negated condition code table0    GBLC    &amp;RevCC#      ; reverse condition code table:    GBLC    &amp;NotRevCC#    ; negated inverse condition code table7    GBLC    &amp;Left#      ; left &lt;ea&gt; if &lt;s-expr&gt; = &lt;ea&gt;&lt;cc&gt;&lt;ea&gt;9    GBLC    &amp;Right#      ; right &lt;ea&gt; if &lt;s-expr&gt; = &lt;ea&gt;&lt;cc&gt;&lt;ea&gt;/    GBLC    &amp;Op#        ; AND or OR delimiter or &lt;null&gt;2    GBLC    &amp;Size#      ; size attribute from &lt;cc&gt;[.&lt;sz&gt;]:    GBLC    &amp;Extent#      ; extent attribute on delimiter keyword)    GBLA    &amp;Debug#      ; debug printing switch&amp;    GBLA    &amp;FirstIf      ; First time switch    LCLA    &amp;lCmp     LCLC    &amp;lSize,&amp;lLeft,&amp;lRight    IF &amp;Debug# THEN
    WriteLn     WriteLn  &amp;Expr   ENDIF    IF NOT &amp;FirstIf THENI    &amp;CC#:       SETC 'EQ.NE.LE.LT.GE.GT.MI.PL.HI.LS.LO.CC.CS.NZ.HS.VC.VS.'I    &amp;NotCC#:    SETC 'NE.EQ.GT.GE.LT.LE.PL.MI.LS.HI.CC.LO.CC.EQ.CS.VS.VC.'I    &amp;RevCC#:    SETC 'EQ.NE.GE.GT.LE.LT.PL.MI.LO.**.HI.CS.CC.NZ.CS.VS.VC.'I    &amp;NotRevCC#: SETC 'NE.EQ.LT.LE.GT.GE.MI.PL.CC.LS.LS.CC.CS.EQ.CC.VC.VS.'     &amp;FirstIf: SETA 0   ENDIF7  &amp;Cp#:        SETA &amp;Lex(&amp;Expr, 1)    ; Scan the 1st tokenD  &amp;Extent#:    SETC &amp;Default(&amp;UC(&amp;Ext), 'W'); Preset &lt;extent&gt; to &amp;Ext2  SExpr# &amp;Expr,&amp;Keyword        ; Parse the 1st &lt;s-expr&gt;8  &amp;lCmp:       SETA &amp;Cmp#        ; Save info for 1st &lt;s-expr&gt;?  &amp;lSize:      SETC &amp;Size#        ; All these are needed to gen code=  &amp;lLeft:      SETC &amp;Left#        ; We copy them to locals in case                               =  &amp;lRight:     SETC &amp;Right#      ; there is a right-hand &lt;s-expr&gt;;  &amp;FalseUsed#: SETA 0          ; Assume we done have false labels'   IF &amp;Debug# THEN          ; If debugging...6     IF &amp;Op# &shy; '' THEN        ; ...and we have AND or OR...2      Writeln '   ', &amp;Op#        ; ...show we have them     ENDIF   ENDIF*   IF &amp;Op# = 'AND' THEN        ; Have and AND ?:    SExpr# &amp;Expr,&amp;Keyword        ; Yes parse the right &lt;s-expr&gt;=     IF &amp;JumpCond THEN          ; Branch to &amp;True if expr is true ?&gt;      &amp;FalseUsed#: SETA 1        ; Yes, indicate &amp;False label used F      Test#.&amp;lSize &amp;lCmp,&amp;lLeft,&amp;lRight,&amp;False,&amp;Extent#,0 ; B&lt;F&gt;  FalseE      Test#.&amp;Size# &amp;Cmp#,&amp;Left#,&amp;Right#,&amp;True,&amp;Extent#,1  ; B&lt;T&gt;  True      ELSEE      Test#.&amp;lSize &amp;lCmp,&amp;lLeft,&amp;lRight,&amp;True,&amp;Extent#,0  ; B&lt;F&gt;  TrueE      Test#.&amp;Size# &amp;Cmp#,&amp;Left#,&amp;Right#,&amp;True,&amp;Extent#,0  ; B&lt;F&gt;  True     ENDIF+   ELSEIF &amp;Op# = 'OR' THEN        ; Have an OR ?:    SExpr# &amp;Expr,&amp;Keyword        ; Yes parse the right &lt;s-expr&gt;      IF &amp;JumpCond THENE      Test#.&amp;lSize &amp;lCmp,&amp;lLeft,&amp;lRight,&amp;True,&amp;Extent#,1  ; B&lt;T&gt;  TrueE      Test#.&amp;Size# &amp;Cmp#,&amp;Left#,&amp;Right#,&amp;True,&amp;Extent#,1  ; B&lt;T&gt;  True      ELSE9      &amp;FalseUsed#: SETA 1        ; Indicate &amp;False label used F      Test#.&amp;lSize &amp;lCmp,&amp;lLeft,&amp;lRight,&amp;False,&amp;Extent#,1 ; B&lt;T&gt;  FalseE      Test#.&amp;Size# &amp;Cmp#,&amp;Left#,&amp;Right#,&amp;True,&amp;Extent#,0  ; B&lt;F&gt;  True     ENDIF    ELSE=    Test#.&amp;lSize &amp;lCmp,&amp;lLeft,&amp;lRight,&amp;True,&amp;Extent#,&amp;JumpCond   ENDIF .Exit   PRINT   Pop&yuml; ELSE#          Else#.&amp;Ext     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack8    GBLC    &amp;LblStk#[25]    ; label suffix to next If# section    IF &amp;StkPtr# = 0 THEN&amp;    AERROR 'ELSE# not nested in an IF#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 1 THEN&amp;    AERROR 'ELSE# not nested in an IF#'      GOTO .Exit   ENDIF           BRA.&amp;Ext  %L%&amp;SysNdx %L%&amp;LblStk#[&amp;StkPtr#]!  &amp;LblStk#[&amp;StkPtr#]: SETC &amp;SysNdx .Exit   Print  Pop&yuml; TEST#      2    Test#.&amp;Sz &amp;Cmp#:A,&amp;a,&amp;b,&amp;Dst,&amp;Extent,&amp;JumpCond:A     PRINT  Push,NoMDir,NoMCall&amp;    GBLC    &amp;CC#        ; condition code table0    GBLC    &amp;NotCC#      ; negated condition code table0    GBLC    &amp;RevCC#      ; reverse condition code table:    GBLC    &amp;NotRevCC#    ; negated inverse condition code table,    LCLC    &amp;tRevCC      ; tmp to fool with &amp;RevCC#&gt;   IF &amp;Cmp# = 0 GOTO .Exit      ; If there are syntax errors, exit/   IF &amp;a = '' THEN        ; &lt;s-expr&gt; ::= &lt;cc&gt;[.&lt;sz&gt;]-     IF &amp;JumpCond THEN        ; Just do the branch,          B&amp;CC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst          ELSE,          B&amp;NotCC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst     ENDIFD   ELSEIF &amp;a[1:1] = '#' THEN    ; &lt;s-expr&gt; ::= #&lt;imm&gt; &lt;cc&gt;[.&lt;sz&gt;] &lt;eaB&gt;           CMPI.&amp;Sz  &amp;a,&amp;b      IF &amp;JumpCond THEN     &amp;tRevCC: SETC &amp;RevCC#[&amp;Cmp#:2]      IF &amp;tRevCC &shy; '**' THEN$          B&amp;tRevCC..&amp;Extent     &amp;Dst      ELSE           BHI.&amp;Extent &amp;Dst           BEQ.&amp;Extent &amp;Dst     ENDIF      ELSE/          B&amp;NotRevCC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst     ENDIFD   ELSEIF &amp;b[1:1] = '#' THEN    ; &lt;s-expr&gt; ::= &lt;eaA&gt; &lt;cc&gt;[.&lt;sz&gt;] #&lt;imm&gt;           CMPI.&amp;Sz  &amp;b,&amp;a      IF &amp;JumpCond THEN)          B&amp;CC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst      ELSE,          B&amp;NotCC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst     ENDIF                 P   ELSEIF &amp;SubStr(&amp;Type(&amp;a),1,3)='REG' THEN; &lt;s-expr&gt; ::= &lt;reg&gt; &lt;cc&gt;[.&lt;sz&gt;] &lt;eaB&gt;           CMP.&amp;Sz   &amp;b,&amp;a      IF &amp;JumpCond THEN)          B&amp;CC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst      ELSE,          B&amp;NotCC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst     ENDIFP   ELSEIF &amp;SubStr(&amp;Type(&amp;b),1,3)='REG' THEN; &lt;s-expr&gt; ::= &lt;eaA&gt; &lt;cc&gt;[.&lt;sz&gt;] &lt;reg&gt;           CMP.&amp;Sz   &amp;a,&amp;b      IF &amp;JumpCond THEN     &amp;tRevCC: SETC &amp;RevCC#[&amp;Cmp#:2]      IF &amp;tRevCC &shy; '**' THEN$          B&amp;tRevCC..&amp;Extent     &amp;Dst      ELSE           BHI.&amp;Extent &amp;Dst           BEQ.&amp;Extent &amp;Dst     ENDIF      ELSE/          B&amp;NotRevCC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst     ENDIF3   ELSE              ; &lt;s-expr&gt; ::= &lt;eaA&gt; &lt;cc&gt;[.&lt;sz&gt;] &lt;eaB&gt;       CMP.&amp;Sz   &amp;b,&amp;a      IF &amp;JumpCond THEN)          B&amp;CC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst      ELSE,          B&amp;NotCC#[&amp;Cmp#:2].&amp;Extent     &amp;Dst     ENDIF   ENDIF .Exit  PRINT  Pop&yuml; ENDS#           EndS#     PRINT  Push,NoMDir,NoMCall3    GBLA    &amp;StkPtr#      ; statment nesting stack pointer5    GBLA    &amp;KindStk#[25]    ; statement nesting kind stack0    GBLC    &amp;Lbl2Stk#[25]    ; next Case# label suffix&gt;    GBLA    &amp;CaseStkPtr#    ; case stack pointer for nested switches?    GBLA    &amp;FrstCase#[25]    ; index of 1st Case# label in &amp;CaseStk#'    GBLA    &amp;Low#[25]      ; lowest case value(    GBLA    &amp;High#[25]    ; highest case value&lt;    GBLA    &amp;JmpTbl#[25]    ; 0==&gt;SUB's; 1==&gt;JumpTbl; 2==&gt;ChkRng=Y:    GBLC    &amp;EndSwLbl#[25]    ; end case label suffix for Leave#5    GBLC    &amp;Dreg#[25]    ; D-register used by this Switch#4    GBLC    &amp;Default#[25]    ; default label from Default#+    GBLC    &amp;CaseStk#[250]    ; Case# label stack/    LCLC    &amp;Dreg,&amp;Lbl,&amp;Default,&amp;CaseLbl,&amp;CaseValue,    LCLA    &amp;Low,&amp;High,&amp;LastCase,&amp;Case,&amp;N,&amp;Case1    IF &amp;StkPtr# = 0 THEN*    AERROR 'ENDS# not nested in an SWITCH#'      GOTO .Exit   ENDIF!   IF &amp;KindStk#[&amp;StkPtr#] &shy; 5 THEN*    AERROR 'ENDS# not nested in an SWITCH#'      GOTO .Exit   ENDIFG  &amp;Lbl:     SETC &amp;EndSwLbl#[&amp;StkPtr#]; Pick up main Switch# label suffixD  &amp;Default: SETC &amp;Default#[&amp;StkPtr#]  ; Pick up the default case label9   IF &amp;JmpTbl#[&amp;StkPtr#] THEN    ; Generating a jump table ?G    &amp;Case: SETA &amp;FrstCase#[&amp;StkPtr#]  ; Yes, get index to the first labelF     IF &amp;CaseStkPtr# &lt; &amp;Case THEN  ; Make sure we had at least one Case#       AERROR 'No CASE#''s'      ELSEB      &amp;Dreg: SETC &amp;Dreg#[&amp;StkPtr#]  ; Get the D-reg we will be usingD      &amp;Low: SETA &amp;Low#[&amp;StkPtr#]  ; Get the low value of all case tags:      &amp;High: SETA &amp;High#[&amp;StkPtr#]  ; Get the high value too %L%&amp;Lbl7       IF &amp;Default = '' THEN    ; Did we have a Default# ?L        &amp;Default: SETC &amp;Concat('%E%',&amp;Lbl); No, define it as the Leave# label
      ENDIF=       IF &amp;JmpTbl#[&amp;StkPtr#] = 2 THEN  ; Perform range check...8        PRINT Push,NoWarn      ; Ignore branch warnings here           CMPI.W    #&amp;Low,&amp;Dreg           BLT       &amp;Default           CMPI.W    #&amp;High,&amp;Dreg           BGT       &amp;Default     PRINT Pop
      ENDIF           ADD.W     &amp;Dreg,&amp;Dreg4          MOVE.W    %T%&amp;Lbl-(2*&amp;Low)(&amp;Dreg..W),&amp;Dreg%          JMP       %T%&amp;Lbl(&amp;Dreg..W)
%T%&amp;Lbl   1          DCB.W     &amp;High-&amp;Low+1,&amp;Default-%T%&amp;Lbl7       WHILE &amp;Case &lt;= &amp;CaseStkPtr# DO  ; Gen the table!!!                                                             F        &amp;CaseLbl:   SETC &amp;CaseStk#[&amp;Case]     ; Extract Case# label infoG     &amp;Case1:     SETA &amp;S2I(&amp;CaseLbl[5:4]) ; &amp;Case1   = NNNN = nbr of tags;     &amp;CaseValue: SETC &amp;CaseLbl[9:255]     ; &amp;CaseValue = &lt;ae1&gt;D     &amp;CaseLbl:   SETC &amp;CaseLbl[1:4]     ; &amp;CaseLbl = Case# label suffix&lt;      IF &amp;Case1 = 1 THEN           ; If one tag, gen a DC else DCB/          ORG       %T%&amp;Lbl+2*(&amp;CaseValue-&amp;Low)8          DC.W      %C%&amp;CaseLbl-%T%&amp;Lbl     ; &amp;CaseValue7      ELSEIF &amp;SubStr(&amp;Trim(&amp;CaseValue), 1, 1) = '''' THEN/          ORG       %T%&amp;Lbl+2*(&amp;CaseValue-&amp;Low)a          DCB.W     &amp;Case1,%C%&amp;CaseLbl-%T%&amp;Lbl  ; &amp;CaseValue...'&amp;Chr(&amp;Eval(&amp;CaseValue)+&amp;Case1-1)'       ELSE/          ORG       %T%&amp;Lbl+2*(&amp;CaseValue-&amp;Low)_          DCB.W     &amp;Case1,%C%&amp;CaseLbl-%T%&amp;Lbl  ; &amp;CaseValue...&amp;Chr(&amp;Eval(&amp;CaseValue)+&amp;Case1-1)      ENDIF      &amp;Case: SETA &amp;Case+1        ENDWA      &amp;CaseStkPtr#: SETA &amp;FrstCase#[&amp;StkPtr#]-1 ; Next Case# label          ORG     ENDIF*   ELSE              ; Not generating a jump tableM     IF &amp;Lbl2Stk#[&amp;StkPtr#] = '' THEN  ; Make sure there was at least one Case#       AERROR 'No CASE#''s'E     ELSEIF &amp;Default = '' THEN    ; Define final Case# destination label %C%&amp;Lbl2Stk#[&amp;StkPtr#]4     ELSE            ; Equat final Case# dst lbl to default#%C%&amp;Lbl2Stk#[&amp;StkPtr#] EQU &amp;Default     ENDIF   ENDIF %E%&amp;Lbl   &amp;StkPtr#: SETA &amp;StkPtr#-1 .Exit  PRINT  Pop&yuml;                                                                                                                                                                                                                       </pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CPlusTESample/listing10.html%3Fid%3DDTS10000730-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CPlusTESample/listing10.html%3Fid%3DDTS10000730-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CPlusTESample/listing10.html%3Fid%3DDTS10000730-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>