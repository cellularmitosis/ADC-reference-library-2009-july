<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>64-Bit Transition Guide: Cross-Architecture Plug-in Support</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Cross-Architecture Plug-in Support"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001064-CH225" title="Cross-Architecture Plug-in Support"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Porting-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000553" target="_top">Porting</a> &gt; <a href="../intro/intro.html#//apple_ref/doc/uid/TP40001064-CH205-TPXREF101">64-Bit Transition Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HighLevelAPIs/HighLevelAPIs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../pseudo_vm/pseudo_vm.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001064-CH225-SW7" title="Cross-Architecture Plug-in Support"></a><h1>Cross-Architecture Plug-in Support</h1><p>In some cases, you may find it useful to support plug-ins written for an architecture other than the one your application is running on at the time. You may need this simply for debugging purposes, but this approach may also be useful if you want your application to support existing plug-ins on newer architectures. For example, audio software manufacturers may find it easier to drive adoption of 64-bit versions of their application if they also support existing 32-bit audio unit plug-ins.</p><p>Designing a host application to load a given plug-in is a highly specialized task. This chapter provides an overview of common approaches to doing this. This chapter assumes that you have already written a dummy plug-in loader that loads the plug-in into memory (even if it doesn’t actually do anything with the plug-in yet).</p><p>In addition, this chapter describes several common interprocess communication APIs, explains how to pass large amounts of data between the host application and the plug-in helper host, and tells how to launch that host for a particular architecture.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_1">Choosing a Helper Host Architecture Model</a>
				
			<br/>
			
        
			
			
				<a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW1">Using Interprocess Communication</a>
				
			<br/>
			
        
			
			
				<a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW6">Launching the Helper Host</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_1" title="Choosing a Helper Host Architecture Model"></a><h2>Choosing a Helper Host Architecture Model</h2><p>Before you can build a helper host, you must first choose an architecture model that accomplishes your needs. There are many possible design models for helper hosts, each with varying levels of functionality and difficulty. This section describes three such models and explains the problems you may encounter with each model.</p><p>Of these models, remote hosting is generally recommended because it is the easiest and most reliable. Limited function-call marshaling works when the scope of the API is limited. Full programmatic function-call marshaling, although described here, should usually be avoided because the exceptions and edge cases can make it impractical.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_2" title="Programmatic Function-Call Marshaling"></a><h3>Programmatic Function-Call Marshaling</h3><p>The first thing most developers consider doing when they design a helper host is trying to make every function call from the plug-in result in the same function being called in the host. With programmatic function-call marshaling, your application extracts the symbols from the plug-in, then generates custom library code to marshall arguments across address space boundaries (or even from one machine to another).</p><p>In general, the sheer number of exceptions and edge cases involved makes programmatic function-call marshaling highly impractical, and thus it should generally be avoided. However, this design may be reasonable if the plug-ins call only C APIs.</p><p>Such a design, although powerful, is tricky to get right, particularly when used across byte-order boundaries, because this design requires intimate understanding of every data structure involved to know whether or not a field should be byte swapped. For example, swapping various BSD-level networking data structures would be disastrous.</p><p>Fortunately, these data types are by far the exception rather than the rule, and can generally be ignored. However, the prevalent use of structure hiding (for example, using <code>void *</code> pointers and opaque types) essentially makes programmatic function-call marshaling nearly impossible, because there is no way to programmatically determine the underlying structure of a piece of data passed in this manner (and in many cases, the value may be meaningless in the context of a different process).</p><p>Opaque data structures are particularly an issue if a plug-in executes some code in the local process (such as interacting with a single-architecture plug-in GUI library that makes calls that are not supported in the main host architecture) and passes the resulting data (such as a window reference) to closely related functions in the remote process.</p><p>If the plug-in must call arbitrary C++ or Objective-C class or instance methods on classes outside the plug-in itself, it becomes even more difficult to remotely execute function calls because of the need to maintain synchronization of class instances between the helper host and the main host. Since you cannot recompile the plug-in, replacing variables with accessor methods is impossible. This means that each function that potentially manipulates state must copy all of the state from the main host’s notion of the class instance. Further, there is still some possibility that the host could update public class members without your knowledge, leading to potentially significant changes in your host application.</p><p>Finally, this method will not work transparently if the plug-in calls any functions that involve Mach ports, because port rights are not shared between the two processes unless they are explicitly passed from one process to the other or are inherited from the parent. Similarly, you should not try to marshal system calls in this way, because byte swapping at the lower levels of the operating system can be particularly complex.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-SW10" title="Limited Function-Call Marshaling"></a><h3>Limited Function-Call Marshaling</h3><p>Limited function-call marshaling is a far more realistic approach than fully programmatic marshaling. First, identify a set of (generally C) routines that call back into the host application. Then, replace those in the helper host with libraries that call across address space boundaries.</p><p>Because the scope of the supported API is limited, it is much more practical for you to support them through function-call marshaling, because you can hand-code routines for each function or class that that you intend to call across an address-space boundary instead of relying on programmatically generated functions and classes.</p><p>As with programmatic function-call marshaling, you must be particularly careful when working with pointers. If pointer arguments are of a known type and size, it is relatively easy to work with them. However, you may encounter problems if you do not know the size of the referenced object and if you need to byte swap or otherwise manipulate the pointer contents during the boundary crossing.</p><p>C++ and Objective-C classes are a bit harder. You can’t simply pass pointers to classes, because they won’t be valid on the other side of the communications channel. However, if the number of classes is limited, you can emulate class pointers by using stub classes in the helper host that contain an extra member variable that stores the address of the real class instance on the host side.</p><p>Similarly, you must emulate any callback pointers passed as arguments, because the callback pointer is meaningless in the context of the main host application. You can emulate these pointers either through message passing in the reverse direction or through RPC from the primary host into the helper host.</p><p>When you use limited function-call marshaling, your helper host can be very compact and completely transparent. However, your stub libraries must contain every function that you intend to override. For large plug-in APIs, this approach can be daunting, particularly if you are not in control of the API itself.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_3" title="Remote Hosting"></a><h3>Remote Hosting</h3><p>Remote hosting is strongly recommended for most helper host implementations because it is relatively easy to implement reliably. With remote hosting, instead of relying on knowledge of the plug-in architecture, you rely on your knowledge of the plug-in host itself. Because you are in control of the code in question, you will be aware of any changes to the API. Also, because the interface between a host and its built-in engine rarely involves callback pointers, you can use a simpler communication mechanism.</p><p>With remote hosting, you create a stripped-down version of your application that displays no user interface itself (except possibly a mirror of the menu bars with appropriate message passing to the main application). This miniature application should include a full set of data processing functionality. In this model, the host application passes a chunk of data to the helper host, then relies on the helper host to process the data just as the host application’s built-in plug-in engine would.</p><p>You may choose to add a command-line flag (using <code>argc</code> and <code>argv</code>) to your application and, upon seeing that flag, call a separate initialization routine in which only the back-end functionality is configured. If you do, your helper host can simply be another running instance of your main application binary.</p><p>The biggest change you must make to support remote hosting is to maintain the state of your plug-in support engine through function calls instead of variable assignment (if you don’t already do so). After you make that change throughout your host, the problem becomes a relatively simple set of changes to these functions:</p><ul class="spaceabove"><li class="li"><p>State changes to the plug-in layer of the host application must be reflected in the helper host.</p></li><li class="li"><p>In the helper host, whenever a plug-in calls a callback that changes the state information stored in the helper host, your application must notify the main host so that the two remain in sync.</p></li><li class="li"><p>Additional code must be added to handle passing of any data on which the plug-in will operate.</p></li></ul><p>This state synchronization can be achieved through a relatively straightforward use of interprocess communication (discussed in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW1">“Using Interprocess Communication”</a></span>). For transport of large data, you should generally transfer the data using memory mapping. This technique is described in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW4">“Memory Mapping for Bulk Data Transport.”</a></span></p><a name="//apple_ref/doc/uid/TP40001064-CH225-SW1" title="Using Interprocess Communication"></a><h2>Using Interprocess Communication</h2><p>For interprocess communication, you can design a helper host using three broad models:</p><ul class="ul"><li class="li"><p><strong>Remote procedure call (RPC) model</strong>—You can use remote procedure calls to handle synchronization of your main host and helper host for you. There are many different RPC APIs available, each with different features and limitations, but at a high level they all behave similarly.</p><p>A helper host designed using the RPC model contains a stub library. The functions in this library are created by RPC support tools based on an interface description. When your helper host (or a plug-in) calls these functions, the stub library sends a message to the main application, which causes the corresponding function in the main application to be called. When that function has completed, the result (if any) is returned in the same manner.</p><p>An RPC-based helper host can be easier to write than one based on a pure client/server model, but it may suffer from limitations in the RPC API itself. For example, Mach RPC has no notion of complex data structures. As a result, you still need to write a fair amount of code to marshal arguments across address space boundaries. Mach RPC is discouraged, and is not officially supported.</p><p>You will learn about several RPC APIs in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW11">“Remote Procedure Call APIs.”</a></span></p></li><li class="li"><p><strong>Client/server message passing model</strong>—Open a socket-based or pipe-based connection to the main host application and use it to pass messages back and forth.</p><p>A client/server helper host design consts of three main parts:</p><ul class="nested"><li class="nested li"><p>Create a stub versions of the functions you want your helper host to call in the main host. When a plug-in or some other part of the helper host calls one of these stub functions, the function adds a message to a queue and waits on a condition variable. The plug-in thread then sleeps until a response is received and is posted to the buffer by the communication thread.</p></li><li class="nested li"><p>Create a communication thread in the helper host to transmit message entries from the buffer and store the responses in some other part of the same message entry.</p></li><li class="nested li"><p>Create a listener thread in the primary host to manage this communication on the other end.</p></li></ul><p>You will learn about several client/server messaging APIs in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW3">“Client/Server Messaging APIs.”</a></span></p></li><li class="li"><p><strong>Memory mapping</strong>—Create a region of memory that is simultaneously accessible to two (or more) processes and use it to share data between them.</p><p>If you want to use memory mapping for passing messages back and forth, you would have to write a lot of additional code. For this reason, for most messaging needs, you should use a different IPC mechanism. However, when you need to move large quantities of information in bulk, client/server and RPC communication can get bogged down.</p><p>For this reason, memory mapping is a common technique for passing large amounts of information in an out-of-band fashion (that is, in lieu of sending it through the primary IPC channel). For example, it would make sense for an audio plug-in helper host to communicate changes to parameters using a traditional IPC API and use memory mapping for a locking-free buffer between the main host and the helper host.</p><p>You can find out more about memory mapping in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW4">“Memory Mapping for Bulk Data Transport.”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40001064-CH225-SW11" title="Remote Procedure Call APIs"></a><h3>Remote Procedure Call APIs</h3><p>There are three remote procedure calls that are commonly used in Mac OS X: distributed objects, Mach RPC, and Sun RPC. Of these, only distributed objects is a public API recommended for general use.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_4" title="Distributed Objects"></a><h4>Distributed Objects</h4><p>If you are calling Objective-C APIs, distributed objects is the recommended RPC API because it does a lot of the work for you.</p><p>If you are calling C or C++ APIs, you must wrap them in Objective-C classes before you can use this API. Before you consider doing so, you should read <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW10">“Limited Function-Call Marshaling.”</a></span></p><p>For more information on distributed objects, see <em><a href="../../../../Cocoa/Conceptual/DistrObjects/index.html#//apple_ref/doc/uid/10000102i" target="_top">Distributed Objects Programming Topics</a></em>.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_5" title="Mach RPC"></a><h4>Mach RPC</h4><p>Mach RPC is not considered a public interface, and its direct use is not generally recommended. However, if you decide to use it, you can find information about it at the following URLs:</p><ul class="simple"><li><p><span class="content_text"><a href="http://www.cs.cmu.edu/afs/cs/project/mach/public/www/doc/osf.html" target="_blank">http://www.cs.cmu.edu/afs/cs/project/mach/public/www/doc/osf.html</a></span>—OSF's Mach Documentation (from CMU)</p></li><li><p><span class="content_text"><a href="http://www.cs.cmu.edu/afs/cs/project/mach/public/www/doc/tutorials.html" target="_blank">http://www.cs.cmu.edu/afs/cs/project/mach/public/www/doc/tutorials.html</a></span>—Mach Tutorials and Examples (from CMU)</p></li></ul><a name="//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_6" title="Sun RPC"></a><h4>Sun RPC</h4><p>Sun RPC is beyond the scope of this document. You can find more information in the following places:</p><ul class="simple"><li><p><code><a href="../../../Reference/ManPages/man3/rpc.3.html#//apple_ref/doc/man/3/rpc" target="_top">rpc(3)</a></code> man page</p></li><li><p><code><a href="../../../Reference/ManPages/man1/rpcgen.1.html#//apple_ref/doc/man/1/rpcgen" target="_top">rpcgen(1)</a></code> man page</p></li><li><p><code><a href="../../../Reference/ManPages/man3/xdr.3.html#//apple_ref/doc/man/3/xdr" target="_top">xdr(3)</a></code> man page</p></li><li><p><code><a href="../../../Reference/ManPages/man8/rpcinfo.8.html#//apple_ref/doc/man/8/rpcinfo" target="_top">rpcinfo(8)</a></code> man page</p></li><li><p><code><a href="../../../Reference/ManPages/man8/portmap.8.html#//apple_ref/doc/man/8/portmap" target="_top">portmap(8)</a></code> man page</p></li></ul><p>Sun RPC is generally not recommended for new designs.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-SW3" title="Client/Server Messaging APIs"></a><h3>Client/Server Messaging APIs</h3><p>Mac OS X supports several client/server messaging APIs, including Apple events, BSD sockets, and pipes (standard input and output, for example). These APIs are described in the sections that follow.</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW2">“Apple Events”</a></span></p></li><li class="li"><p><span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW8">“Socket Programming”</a></span></p></li><li class="li"><p><span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW9">“Standard Input and Output”</a></span></p></li><li class="li"><p><span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW5">“Message Queues”</a></span></p></li></ul><p>These APIs can be used by themselves in some cases. Many APIs lend themselves to sending messages back and forth easily and do not depend on receiving a response from the other end. However, when you need to get a response from a function or method call, you may want to implement a higher level construct on top of these messaging APIs to make it easier to handle these asynchronous responses. One such method is described in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW5">“Message Queues.”</a></span></p><a name="//apple_ref/doc/uid/TP40001064-CH225-SW2" title="Apple Events"></a><h4>Apple Events</h4><p>A common API for interprocess communication in Mac OS X is Apple events. The Apple Events API is a fairly straightforward API for low-bandwidth IPC, and you are probably already using it in your application. If so, you can add additional message types for communication between your application and the plug-in host.</p><p>For more information, see <em><a href="../../../../AppleScript/Conceptual/AppleEvents/index.html#//apple_ref/doc/uid/TP40001449" target="_top">Apple Events Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-SW8" title="Socket Programming"></a><h4>Socket Programming</h4><p>The most common API for simple interprocess communication is an old standby, sockets. There are a number of different Mac OS X technologies for working with sockets, including:</p><ul class="simple"><li><p><code>CFNetwork</code> API (described in <em><a href="../../../../Networking/Conceptual/CFNetwork/index.html#//apple_ref/doc/uid/TP30001132" target="_top">CFNetwork Programming Guide</a></em>)</p></li><li><p><code>NSSocketPort</code> API (described in <em><a href="../../../../Cocoa/Reference/Foundation/Classes/NSSocketPort_Class/index.html#//apple_ref/doc/uid/TP40003738" target="_top">NSSocketPort Class Reference</a></em>)</p></li><li><p>BSD socket API (described in <code><a href="../../../Reference/ManPages/man2/socket.2.html#//apple_ref/doc/man/2/socket" target="_top">socket(2)</a></code>)</p></li></ul><p>Each of these APIs implements the same underlying message, a bidirectional stream of bytes between both ends. Stream-based messaging presents a problem if your helper host needs to concurrently support multiple plug-ins, however, because you will need to multiplex data from multiple sources. You can solve this problem by using message queues, as described in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW5">“Message Queues.”</a></span></p><p>As an added bonus, communication via sockets is not limited to a single machine. If you are writing software that can benefit from distributed computing, such remote communication can be a significant benefit.</p><p>If you are writing an audio helper host, most of the work is done for you beginning in Mac OS X v10.4. The AUNetSend and AUNetReceive audio units can make helper hosting relatively painless to implement, whether on a local machine or remotely. However, with these plug-ins, <em>all</em> information passes through the TCP/IP stack even if the destination is on the local machine.</p><p>Keep in mind two caveats if you use TCP/IP for passing the actual data back and forth instead of just passing control information. First, the latency of remote communications is <em>not</em> insignificant. If this matters in your application (for example, an audio application), you <em>must</em> compensate for this latency or quality will suffer greatly. Second, the amount of information being sent is substantial, and thus, for performance reasons, socket programming may not be ideal for hosting a large number of individual plug-ins on a helper host. If you expect a large number of non-native plug-ins, you should generally use memory mapping to pass data from the main host to the helper host, as described in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW4">“Memory Mapping for Bulk Data Transport.”</a></span></p><p>With those caveats in mind, sockets also open up the possibility of alternative software usage models. For example, you might design an audio application so that the front end can run on a small, low-power, fanless computer in a studio control room, with all of the heavy lifting performed by a separate computer in another room. You could implement the user interface by temporarily hosting a local copy of plug-ins when a user wants to show their user interface, then sending control change messages across the wire to the actual host (where the plug-ins are all running with no UI displayed). Then, use TCP/IP for sending <em>only</em> the raw audio from the audio interface. For audio play-through while recording, you should mix the incoming audio into the output on the front-end computer as the very last step in processing.</p><p>The details of creating and using sockets are beyond the scope of this document. For additional information, consult the documents listed above. You may also find useful information in the UNIX Socket FAQ, which can be found at <span class="content_text"><a href="http://www.developerweb.net/forum/" target="_blank">http://www.developerweb.net/forum/</a></span>. This FAQ includes code examples that illustrate how to use TCP/IP and UNIX domain sockets at the BSD API level.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-SW9" title="Standard Input and Output"></a><h4>Standard Input and Output</h4><p>Another common API for interprocess communication is standard input and output. This API provides a pair of unidirectional streams. Much like socket programming, the stream-based nature of standard input and output requires you to keep additional state information if you need to associate responses to messages with the original message. A good way to solve that problem is through the use of message queues, as described in <span class="content_text"><a href="Cross-ArchitecturePluginSupport.html#//apple_ref/doc/uid/TP40001064-CH225-SW5">“Message Queues.”</a></span></p><p>One thing that makes standard input and output convenient is that they are largely set up for you. Every process in a UNIX-based system has standard input and output automatically. You can take advantage of these to communicate between a parent process (your main application) and its children (your helper host).</p><p>To communicate with child processes in Cocoa, you should use the <code>NSTask</code> API, described in <span class="content_text"><a href="../../../../Cocoa/Reference/Foundation/Classes/NSTask_Class/Reference/Reference.html#//apple_ref/doc/uid/20000317" target="_top">NSTask Class Reference</a></span>. For more information on this method, read <span class="content_text"><a href="../../../../Cocoa/Conceptual/OperatingSystem/Tasks/createtask.html#//apple_ref/doc/uid/20000803" target="_top">Creating and Launching an NSTask</a></span> and <span class="content_text"><a href="../../../../Cocoa/Conceptual/OperatingSystem/Tasks/endingtask.html#//apple_ref/doc/uid/20000804" target="_top">Ending an NSTask</a></span>.</p><p>Alternatively, in BSD tools, you can accomplish the same thing at a file descriptor level using a few low-level APIs as shown in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdlib.h><span></span></pre></td></tr><tr><td scope="row"><pre>comm_channel *startchild(char *path)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        comm_channel *channel = malloc(sizeof(*channel));<span></span></pre></td></tr><tr><td scope="row"><pre>        pid_t childpid;<span></span></pre></td></tr><tr><td scope="row"><pre>        int in_descriptors[2];<span></span></pre></td></tr><tr><td scope="row"><pre>        int out_descriptors[2];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Create a pair of file descriptors to use for communication. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (pipe(in_descriptors) == -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>                fprintf(stderr, "pipe creation failed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                goto error_exit;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if (pipe(out_descriptors) == -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>                fprintf(stderr, "pipe creation failed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                goto error_exit;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Create a new child process. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((childpid = fork()) == -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>                fprintf(stderr, "fork failed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                goto error_exit;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if (childpid) {<span></span></pre></td></tr><tr><td scope="row"><pre>                /* Parent process */<span></span></pre></td></tr><tr><td scope="row"><pre>                channel->in_fd = in_descriptors[0];<span></span></pre></td></tr><tr><td scope="row"><pre>                close(in_descriptors[1]);<span></span></pre></td></tr><tr><td scope="row"><pre>                channel->out_fd = out_descriptors[1];<span></span></pre></td></tr><tr><td scope="row"><pre>                close(out_descriptors[0]);<span></span></pre></td></tr><tr><td scope="row"><pre>                return channel;<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>                /* Child process */<span></span></pre></td></tr><tr><td scope="row"><pre>                if (dup2(in_descriptors[1], STDOUT_FILENO) == -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>                        fprintf(stderr, "Call to dup2 failed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                        goto error_exit;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                close(in_descriptors[0]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                if (dup2(out_descriptors[0], STDIN_FILENO) == -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>                        fprintf(stderr, "Call to dup2 failed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                        goto error_exit;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                close(out_descriptors[1]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                execl(path, path, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                /* If we get here, something went wrong. */<span></span></pre></td></tr><tr><td scope="row"><pre>                fprintf(stderr, "Exec failed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                goto error_exit;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        return channel;<span></span></pre></td></tr><tr><td scope="row"><pre>    error_exit:<span></span></pre></td></tr><tr><td scope="row"><pre>        free(channel);<span></span></pre></td></tr><tr><td scope="row"><pre>        perror("msg_send");<span></span></pre></td></tr><tr><td scope="row"><pre>        return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<div class="notebox"><a name="//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_26" title="Note"></a><p><strong>Note:</strong>&nbsp;If you use a function like this one, you should always specify an absolute path to your helper application.</p></div><a name="//apple_ref/doc/uid/TP40001064-CH225-SW5" title="Message Queues"></a><h4>Message Queues</h4><p>Message queues provide a way for one process to communicate with another process in a flexible fashion over a stream-based transport without requiring that the two processes behave in a lockstep fashion at all times. You can build message queues on top of either bidirectional communication channels, such as sockets, or on top of pairs of unidirectional communication channels, such as pipes or standard input and output.</p><p>A message queue at its simplest consists of a linked list of message structures. Each message structure contains an outgoing message and a location in which the response will be stored. Depending on how you write your code, it may contain a callback, to be executed upon completion, or a single handler that calls the right function based on the original message type.</p><p>On each end, you should have a thread to handle messages from the socket. You can use your run loop thread as a handler thread if you are writing a traditional application, or you can use a separate message thread if you prefer to use lower-level socket APIs.</p><p>The code for managing a message queue is relatively straightforward, locking issues notwithstanding. A complete code example is provided in the companion files associated with this document. The companion files archive can be downloaded from the sidebar when viewing this document as HTML at the ADC Reference Library (<code>developer.apple.com</code>).</p><a name="//apple_ref/doc/uid/TP40001064-CH225-SW4" title="Memory Mapping for Bulk Data Transport"></a><h3>Memory Mapping for Bulk Data Transport</h3><p>For moving large quantities of data between two applications, unless you are communicating over a network, you should generally avoid most traditional message-passing algorithms because of the inherent CPU overhead and latency involved. Instead, you should consider a shared memory design using  <code><a href="../../../Reference/ManPages/man2/mmap.2.html#//apple_ref/doc/man/2/mmap" target="_top">mmap(2)</a></code>.</p><p>The following example shows how to create a shared memory region between a process and its child:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;sys/types.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/mman.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/dirent.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;fcntl.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;stdlib.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Create the map file and fill it with bytes. */<span></span></pre></td></tr><tr><td scope="row"><pre>char *create_shm_file(char *progname, int length)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int fd, i;<span></span></pre></td></tr><tr><td scope="row"><pre>    char *filename=malloc(MAXNAMLEN+1);<span></span></pre></td></tr><tr><td scope="row"><pre>    char *ret;<span></span></pre></td></tr><tr><td scope="row"><pre>    char byte = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    sprintf(filename, "/tmp/%s-XXXXXXXX", progname);<span></span></pre></td></tr><tr><td scope="row"><pre>    ret = mktemp(filename);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fd = open(filename, O_RDWR|O_CREAT, 0600);<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i=0; i&lt;length; i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>        write(fd, &amp;byte, 1);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return ret;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Map the file into memory in a read-write fashion */<span></span></pre></td></tr><tr><td scope="row"><pre>void *map_shm_file(char *filename, int length)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int fd = open(filename, O_RDWR, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    void *map;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (fd == -1) return NULL; /* Could not open file */<span></span></pre></td></tr><tr><td scope="row"><pre>    map = mmap(NULL, length, PROT_READ|PROT_WRITE,<span></span></pre></td></tr><tr><td scope="row"><pre>        MAP_FILE|MAP_SHARED, fd, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    return map;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Using this sample code, the two applications can rendezvous using a file as a shared memory buffer between them. As long as both applications use the same file, any changes made by one application will be seen by the other and vice versa. Your application can then assign pieces of this buffer to be used for various tasks just as though you were using anonymous memory returned by a call to <code><a href="../../../Reference/ManPages/man3/malloc.3.html#//apple_ref/doc/man/3/malloc" target="_top">malloc(3)</a></code>.</p><p>If you intend to work with page-sized regions, you should also take note of the functions described in the <code><a href="../../../Reference/ManPages/man3/mpool.3.html#//apple_ref/doc/man/3/mpool" target="_top">mpool(3)</a></code> manual page. However, for most purposes, you should write your own pool allocator if you need to regularly allocate and deallocate shared memory.</p><p>For more information on the functions used in the example above, see the man pages for <code><a href="../../../Reference/ManPages/man2/mmap.2.html#//apple_ref/doc/man/2/mmap" target="_top">mmap(2)</a></code>, <code><a href="../../../Reference/ManPages/man2/open.2.html#//apple_ref/doc/man/2/open" target="_top">open(2)</a></code>, and <code><a href="../../../Reference/ManPages/man3/mktemp.3.html#//apple_ref/doc/man/3/mktemp" target="_top">mktemp(3)</a></code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001064-CH225-DontLinkElementID_27" title="Note"></a><p><strong>Note:</strong>&nbsp;Memory-mapped files do not grow automatically. Thus, you cannot map beyond the file’s EOF marker. If you need to extend the length of a mapping file, you must do so using normal file I/O routines prior to remapping the file.</p>You will probably find it easier to use a separate map file each time that you require another large chunk of shared space, however. Usually, you should only need to map another large piece of shared memory when loading a new plug-in or creating a new plug-in instance. Thus, the mapping file name and descriptor can be stored as an additional piece of metadata associated with a given plug-in instance.</p></div><p>A good way of working with shared memory is for you to use a lock-free ring buffer design. In such a design, each communication endpoint reads from two variables but writes only to one. In this way, both sides know where in the buffer the other endpoint is working.</p><p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct ringbuffer {<span></span></pre></td></tr><tr><td scope="row"><pre>    void *buffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    int buflen;<span></span></pre></td></tr><tr><td scope="row"><pre>    int readpos;<span></span></pre></td></tr><tr><td scope="row"><pre>    int writepos;<span></span></pre></td></tr><tr><td scope="row"><pre>} *ringbuffer;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define BYTES_TO_READ(ringbuffer) (ringbuffer->writepos - \<span></span></pre></td></tr><tr><td scope="row"><pre>    ringbuffer->readpos + \<span></span></pre></td></tr><tr><td scope="row"><pre>    ((ringbuffer->readpos > ringbuffer->writepos) * \<span></span></pre></td></tr><tr><td scope="row"><pre>        (ringbuffer->buflen)))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Use >= here because if readpos and writepos are equal,<span></span></pre></td></tr><tr><td scope="row"><pre>    the buffer must be assumed to be empty.  Otherwise,<span></span></pre></td></tr><tr><td scope="row"><pre>    the buffer would start out full. For this reason,<span></span></pre></td></tr><tr><td scope="row"><pre>    the writepos must not be allowed to overtake the read<span></span></pre></td></tr><tr><td scope="row"><pre>    position, so subtract one from the final value.<span></span></pre></td></tr><tr><td scope="row"><pre>*/<span></span></pre></td></tr><tr><td scope="row"><pre>#define BYTES_TO_WRITE(ringbuffer) (ringbuffer->readpos - \<span></span></pre></td></tr><tr><td scope="row"><pre>    ringbuffer->writepos + \<span></span></pre></td></tr><tr><td scope="row"><pre>    ((ringbuffer->writepos >= ringbuffer->readpos) * \<span></span></pre></td></tr><tr><td scope="row"><pre>        ringbuffer->buflen) - 1)<span></span></pre></td></tr></table></div><p>The code reading from this buffer knows that it can always read from <code>readpos</code>  forwards up to <code>writepos</code> (or if <code>writepos</code> is less than <code>readpos</code>, it can read to the end of the buffer, then read from the start of the buffer up to <code>writepos</code>). After reading, the read code updates <code>readpos</code> to reflect the location of the last byte read.</p><p>In a similar fashion, the code writing to this buffer knows that it can safely write from the <code>writepos</code> position until it reaches <code>readpos</code>, wrapping around the end of the buffer if necessary. After writing, the write code updates <code>writepos</code> to reflect the location of the last byte written.</p><p>Because only one process will ever modify either <code>readpos</code> or <code>writepos</code>, no synchronization between the two processes is required. Note, however, that the reading code <em>must</em> protect <code>readpos</code> against other threads within that process, and the writing code must do the same for <code>writepos</code>.</p><a name="//apple_ref/doc/uid/TP40001064-CH225-SW6" title="Launching the Helper Host"></a><h2>Launching the Helper Host</h2><p>After you’ve build a helper host, the next step is to determine the architecture of the plug-in. For PEF/CFM plug-ins, it is safe for you to assume that the plug-in contains 32-bit PowerPC executable code. For Mach-O plug-ins, the method you should use varies according to the version of Mac OS X being used.</p><p>For backward compatibility with versions of Mac OS X prior to 10.5, your application should use the detection code presented in the <em><a href="../../../../../samplecode/CheckExecutableArchitecture/index.html#//apple_ref/doc/uid/DTS10003756" target="_top">CheckExecutableArchitecture</a></em> sample code. This sample code is straightforward and presents a fairly easy way to determine which architecture to use for loading existing plug-ins.</p><p>In Mac OS X v10.5 and later, you should use the <code>CFBundle</code> API. This API is safer as a long-term solution, because it will support any binary format that is supported by that particular version of Mac OS X, thus freeing you from the need to alter the code as new binary formats are introduced. The relevant functions are:</p><div class="codesample"><table><tr><td scope="row"><pre>CFArrayRef CFBundleCopyExecutableArchitecturesForURL(CFURLRef url);<span></span></pre></td></tr><tr><td scope="row"><pre>CFArrayRef CFBundleCopyExecutableArchitectures(CFBundleRef bundle);<span></span></pre></td></tr></table></div>	<p>The next step is to execute the helper host, choosing the appropriate architecture in the process. In Mac OS X v10.5 and later, the recommended way to launch an executable using a particular architecture is through an extension to <code><!--a-->posix_spawn<!--/a--></code>. This API is described in the manual page for <code><a href="../../../Reference/ManPages/man2/posix_spawn.2.html#//apple_ref/doc/man/2/posix_spawn" target="_top">posix_spawn(2)</a></code>,  <code><a href="../../../Reference/ManPages/man3/posix_spawnattr_init.3.html#//apple_ref/doc/man/3/posix_spawnattr_init" target="_top">posix_spawnattr_init(3)</a></code>, and the related manual pages linked from those pages. The extension for choosing an architecture to launch is described in the manual page for <code><a href="../../../Reference/ManPages/man3/posix_spawnattr_setbinpref_np.3.html#//apple_ref/doc/man/3/posix_spawnattr_setbinpref_np" target="_top">posix_spawnattr_setbinpref_np(3)</a></code>.</p><p>To support helper hosts on Mac OS X v10.4, you can use separate copies of your helper host for each processor architecture instead of a universal binary, then launch whichever version is appropriate.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HighLevelAPIs/HighLevelAPIs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../pseudo_vm/pseudo_vm.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-04-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/64bitPorting/Cross-ArchitecturePluginSupport/Cross-ArchitecturePluginSupport.html%3Fid%3DTP40001064-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/64bitPorting/Cross-ArchitecturePluginSupport/Cross-ArchitecturePluginSupport.html%3Fid%3DTP40001064-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/64bitPorting/Cross-ArchitecturePluginSupport/Cross-ArchitecturePluginSupport.html%3Fid%3DTP40001064-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>