<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ATADemo - /ATA Demo.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">ATADemo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ATADemo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/ATA Demo.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ATA Demo.c</option>
<option value="listing2.html">/ATA Demo.h</option>
<option value="listing3.html">/ATAExecIO.c</option></select>
				</p>
				</form>
				<p><strong><a href="ATADemo.zip">Download Sample</a></strong> (&#147;ATADemo.zip&#148;, 48.0K)<BR>
<strong><a href="ATADemo.dmg">Download Sample</a></strong> (&#147;ATADemo.dmg&#148;, 110.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    ATA Demo.c    Description:ATADemo is a CodeWarrior C sample that will call the ATA           Manager and scan the ATA bus and list the various device           configuration data.                 This sample has been updated to properly work with the .AppleCD          driver installed.        The sample also has been updated to attempt to read sector 0 of        each ATA or ATAPI device and display the contents.           Copyright:   &copy; Copyright 1996-2001 Apple Computer, Inc. All rights reserved.    Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      Change History (most recent first):    04/04/01  Converted to CW Pro 6          Added file ATAExecIO.c to demonstrate sending ATA and ATAPI commands          Read and display sector 0 of each device &lt;JAS&gt;              06/23/99  Reformatted and Recompiled on CW Pro 2.1(KG)        03/15/99  Updated to CW 4 and it's headers.          Added code to set the standard .AppleCD driver          into a quiescent state and thus allow us to          query the ATA bus without disturbing the .AppleCD driver.(VM)                06/25/98  Buffer was still the incorrect size in           DisplayATADriveIdentity routine.          Buffer needs to be 256 words (for 512 bytes long).           Drive identify just assumes you have allocated a          512 byte buffer and writes it accordingly.  In          this case it overwrites the end of the array.          Modified to CW Pro 3 and its headers(VM)    10/05/97  Buffer was incorrect size in           DisplayATADriveIdentity routine.          Modified to CW Pro 1 and its headers          Added Metrowerks SIOUX specific stuff          Created Fat application          Realized that the words come back swapped;           adjusted for this in the DumpFormatedBuffer routine.(BLoB)  *///------------------------------------------------------------------------------------#pragma mark Includes//------------------------------------------------------------------------------------#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;LowMem.h&gt;#include &lt;Patches.h&gt;#include &lt;Traps.h&gt;#include &lt;Devices.h&gt;#include &lt;ATA.h&gt;#ifdef __MWERKS__  #include &lt;SIOUX.h&gt;#endif#include &quot;ATA Demo.h&quot;//------------------------------------------------------------------------------------#pragma mark Globals//------------------------------------------------------------------------------------UInt8  gATAMgrPBVers;  // used to hold current version of PB from ataMgrInquiryFormatTable kIdentFormat[] = {  {   0,   0, kHex,    &quot;Configuration word&quot;            },  {   1,   1,  kDecimal,  &quot;Cylinders&quot;                  },  {   3,   3,  kDecimal,  &quot;Heads&quot;                    },  {   4,   4,  kDecimal,  &quot;Bytes/Track&quot;                },  {   5,   5,  kDecimal,  &quot;Bytes/Sector (0 = 512 bytes)&quot;        },  {   5,   5,  kDecimal,  &quot;Sectors/Track&quot;                },  /* 35 */  {   7,   9,  kHex,    &quot;Vendor Unique (word 7..9)&quot;          },  {  10,  19,  kRightJust,  &quot;Serial Number&quot;                },  {  20,  20,  kHex,    &quot;Buffer Type&quot;                },  {  21,  21,  kDecimal,  &quot;Buffer size in 512 byte increments&quot;    },  {  22,  22,  kDecimal,  &quot;Number of ECC bytes available&quot;        },  {  23,  26,  kLeftJust,  &quot;Firmware Revision&quot;              },  {  27,  46,  kLeftJust,  &quot;Model Number&quot;                },  {  47,  53,  kHex,    &quot;Capability Flags (word 47..53)&quot;      },  {  54,  54,  kDecimal,  &quot;Cylinders (current mode)&quot;          },  {  55,  55,  kDecimal,  &quot;Heads (current mode)&quot;            },  {  56,  56,  kDecimal,  &quot;Sectors/Track (current mode)&quot;        },  {  57,  58,  kDecimal,  &quot;Current Capacity in Sectors&quot;        },  {  59,  59,  kHex,    &quot;Multiple Sector Capability Flag&quot;      },  {  60,  61,  kDecimal,  &quot;Current User-addressable Sectors&quot;      },  {  62,  62,  kHex,    &quot;Single Word DMA Transfer Mode Flags&quot;    },  {  63,  63,  kHex,    &quot;Multiword DMT Transfer Mode Flags&quot;      },  {   0,  0,  kEndOfTable,&quot;&quot;                      }};//------------------------------------------------------------------------------------#pragma mark -//------------------------------------------------------------------------------------// ---------------------------------------------------------------------------void   main   (void)// ---------------------------------------------------------------------------{  OSErr      status;  SInt16      drvrRefNum  = 0;  #ifdef __MWERKS__  SIOUXSettings.asktosaveonclose = false;  SIOUXSettings.columns = 88;#endif  printf(&quot;Macintosh ATA Manager Sample\n\n&quot;);// Check for ATA Hardware // you should do this before calling the ATAManager, since some early ROMS// could indicate an ATA manager without the proper HW, thus casing a crash.  if (ATAHardwarePresent() == false) {    printf(&quot;ATA Hardware is not present on this system\n&quot;);    exit(EXIT_FAILURE);  }// Check for ATA Manager  if (ATAManagerPresent() == false) {    printf(&quot;ATA Manager is not present on this system\n&quot;);    exit(EXIT_FAILURE);  }    // Display ATA Manager Info  status = DisplayATAManagerInquiryInfo();  if (status != noErr) {    printf(&quot;Cannot access ATA Manager: %d\n&quot;, (int) status);    exit(EXIT_FAILURE);  }// Disable the CD driver   status = OpenDriver(&quot;\p.AppleCD&quot;, &amp;drvrRefNum);    if (status == noErr) {    printf(&quot;Found .AppleCD driver, preparing to disable it\n&quot;);    status = DisableCDDriver(drvrRefNum);   }  // Display ATA Device Info  status = ScanATABusses();  if (status != noErr) {    printf(&quot;Cannot access ATA Manager: %d\n&quot;, (int) status);    exit(EXIT_FAILURE);  }  // Renable the CD driver  if(drvrRefNum != 0)  {    printf(&quot;Re-enabling the .AppleCD driver \n&quot;);    status = EnableCDDriver(drvrRefNum);  }    }// ---------------------------------------------------------------------------OSErr     DisplayATAManagerInquiryInfo (void)// ---------------------------------------------------------------------------////  Display information about the ATA Manager//{  ataMgrInquiry  pb;  OSErr      status;  CLEAR(pb);    pb.ataPBFunctionCode =  kATAMgrManagerInquiry;  pb.ataPBVers =      kATAPBVers1;  status = ataManager((ataPB*) &amp;pb );  IF_ERROR(status, &quot;ATA Manager Inquiry failed\n&quot;)  printf(&quot;ATA Manager inquiry:\n&quot;);  PrintNumVersion(&quot;\tATA Manager Version:&quot;, pb.ataMgrVersion);  printf(&quot;\tBusses:\t\t%d\n\tDevices:\t%d\n&quot;,        pb.ataBusCnt, pb.ataDevCnt);  printf(&quot;\tPIO Modes:\t%x\n\tDMA Modes:\t%d\n\tMulti DMA Modes:%x\n&quot;,         pb.ataPioModes, pb.ataSingleDMAModes, pb.ataMultiDMAModes);  printf(&quot;-----------------------------------------\n\n&quot;);      gATAMgrPBVers = pb.ataMgrPBVers;  // remember current PB version    return (status);}// ---------------------------------------------------------------------------OSErr     ScanATABusses (void)// ---------------------------------------------------------------------------////  Display information about the ATA Busses//{  ataDrvrRegister    pb;  OSErr        status;// Get first device ID (yes you have to do this once)  CLEAR(pb);  pb.ataPBFunctionCode   =  kATAMgrFindDriverRefnum;  pb.ataPBVers      =  kATAPBVers1;  pb.ataPBDeviceID     =   (UInt32)0x0000ffff;  status           =   ataManager((ataPB*) &amp;pb );// loop through devices  for  (pb.ataPBDeviceID = (UInt32) pb.ataDeviceNextID;     pb.ataPBDeviceID != 0xff;     pb.ataPBDeviceID = (UInt32) pb.ataDeviceNextID)    {             status = ataManager((ataPB*) &amp;pb );      IF_ERROR(status, &quot;ATA Find Driver failed\n&quot;)            printf(&quot;\nDevice %d %#s\n&quot;, pb.ataPBDeviceID, DrvrRefToName(pb.ataDrvrRefNum) );      DisplayATADriveIdentity(pb.ataPBDeviceID);                printf(&quot;-----------------------------------------\n&quot;);      };      printf(&quot;\n&quot;);    return (status);}// ---------------------------------------------------------------------------OSErr     DisplayATADriveIdentity (UInt32 deviceID)// ---------------------------------------------------------------------------////  Display information about the ATA Identify Info//{  ataIdentify      pb;  ataDevConfiguration  pb1;  UInt8    devType;  UInt16    buffer[256];  OSErr    status;  UInt8    dataBuffer[4096];    // Get Driver Configuration  CLEAR(pb1);  pb1.ataPBFunctionCode   =  kATAMgrGetDrvConfiguration;  pb1.ataPBVers      =  kATAPBVers2;  pb1.ataPBDeviceID     =  deviceID;    status = ataManager((ataPB*) &amp;pb1 );  IF_ERROR(status, &quot;ATA GetDrvConfiguration failed\n&quot;)// Setup Identify block;  CLEAR(pb);  pb.ataPBFunctionCode   =  kATAMgrDriveIdentify;  pb.ataPBVers      =  kATAPBVers1;  pb.ataPBDeviceID    =  deviceID;   pb.ataPBFlags       =   mATAFlagIORead + mATAFlagByteSwap ;      if(pb1.ataDeviceType == kDevATAPI) pb.ataPBFlags += mATAFlagProtocol1;     pb.ataPBTimeOut      =  100;  pb.ataPBBuffer      =  (void*) buffer;    status = ataManager((ataPB*) &amp;pb );  IF_ERROR(status, &quot;ATA DriveIdentify failed\n&quot;)  printf(&quot;Configuration: (&quot;);  switch(pb1.ataDeviceType){    case kDevUnknown:              printf(&quot;Unknown protocol&quot;);            devType = 0;            break;        case kDevATA:            printf(&quot;ATA&quot;);            devType = kDevATA;             break;                   case kDevATAPI:              printf(&quot;ATAPI&quot;);             devType = kDevATAPI;             break;                case kDevPCMCIA:              printf(&quot;PCMCIA&quot;);             devType = kDevATA;             break;  }    switch(pb1.ataSocketType){    case kSocketUnknown:              printf(&quot;, Unknown Socket&quot;);             break;        case kSocketInternal:            printf(&quot;, Internal&quot;);             break;                   case kSocketMediaBay:              printf(&quot;, Media Bay&quot;);             break;                case kkSocketPCMCIA:              printf(&quot;, PCMCIA, Vcc=%d, Vpp1=%d, Vpp2=%d&quot;,                     pb1.atapcVcc, pb1.atapcVpp1,pb1.atapcVpp2);             break;  }  printf(&quot;)\n&quot;);  DumpFormatedBuffer(buffer, kIdentFormat);    // read and display sector 0  if( (devType == kDevATA) )  {    status = ATARead( pb1.ataPBDeviceID, dataBuffer );        if( status == noErr )    {      printf( &quot;\n*********************************** Sector 0 ***********************************\n\n&quot; );      DumpRawBuffer( dataBuffer, 512 );    }    else      printf( &quot;\nATA read failed: %d\n&quot;, status );  }  else if( devType == kDevATAPI )  {    status = ATAPIRead( pb1.ataPBDeviceID, dataBuffer );        if( status == noErr )      {      printf( &quot;\n*********************************** Sector 0 ***********************************\n\n&quot; );      DumpRawBuffer( dataBuffer, 2048 );    }    else      printf( &quot;\nATAPI read failed: %d\n&quot;, status );  }      return status;}// ---------------------------------------------------------------------------OSErr     DisableCDDriver (SInt16 refNum)// ---------------------------------------------------------------------------//// Disable the CD driver//{  OSErr status;  printf(&quot;- Disable the CD Driver \n&quot;);    // wake up drive  status = WakeUpCDDrive (refNum);  if (status != noErr)  {    return status;  }  // move driver to quiescent mode  status = SetQuiescence (refNum, quiescenceON);  if (status != noErr)  {    return status;  }  return noErr;}// ---------------------------------------------------------------------------OSErr     EnableCDDriver (SInt16 refNum)// ---------------------------------------------------------------------------////  Re-enable the CD driver//{  OSErr status;   printf(&quot;- Enable the CD Driver \n&quot;);  // move driver to quiescent mode  status = SetQuiescence (refNum, quiescenceOFF);  if (status != noErr)  {    return status;  }  return noErr;}// ---------------------------------------------------------------------------OSErr     WakeUpCDDrive (SInt16 refNum)// ---------------------------------------------------------------------------////  Re-enable the CD driver//{  CntrlParam  pb;  OSErr    status;  printf(&quot;-- Wake up the CD Driver \n&quot;);  CLEAR(pb);   pb.ioCRefNum = refNum;  pb.csCode = csSetPowerMode;  *(UInt8 *) &amp;pb.csParam[0] = pmActive;    // send command to the CD/DVD driver  status = PBControlImmed ((ParmBlkPtr) &amp;pb);   return status;}// ---------------------------------------------------------------------------OSErr     SetQuiescence (SInt16 refNum, UInt16 mode)// ---------------------------------------------------------------------------////  Re-enable the CD driver//{  CntrlParam  pb;  OSErr    status;  printf(&quot;-- Set the CD Driver Quiescence mode to %s\n&quot;,      (mode ==quiescenceOFF)? &quot;Off&quot;:&quot;On&quot;);  CLEAR(pb);   pb.ioCRefNum = refNum;  pb.csCode = csQuiescence;  pb.csParam[0] = mode;    // send command to the CD/DVD driver  status = PBControlImmed ((ParmBlkPtr) &amp;pb);   return status;}// ---------------------------------------------------------------------------Boolean   ATAManagerPresent  (void)// ---------------------------------------------------------------------------//// returns true if this machine has the ata manager//{    return (TrapAvailable(kATATrap));}// ---------------------------------------------------------------------------Boolean   ATAHardwarePresent    (void)// ---------------------------------------------------------------------------//// returns true if this machine has ata hardware//{  UInt16  configFlags;  // Hardware configuration flags  configFlags = LMGetHWCfgFlags();    return (configFlags &amp; 0x0080);}//------------------------------------------------------------------------------------#pragma mark -#define NumToolboxTraps() (                \    (NGetTrapAddress(_InitGraf, ToolTrap)      \        == NGetTrapAddress(0xAA6E, ToolTrap))  \      ? 0x200 : 0x400                \  )#define GetTrapType(theTrap) (              \    (((theTrap) &amp; 0x800) != 0) ? ToolTrap : OSTrap  \  )// ---------------------------------------------------------------------------Boolean   TrapAvailable    (short theTrap)// ---------------------------------------------------------------------------// (see Inside Mac VI 3-8){    TrapType        trapType;        trapType = GetTrapType(theTrap);    if (trapType == ToolTrap) {      theTrap &amp;= 0x07FF;      if (theTrap &gt;= NumToolboxTraps())        theTrap = _Unimplemented;    }    return (      NGetTrapAddress(theTrap, trapType)      != NGetTrapAddress(_Unimplemented, ToolTrap)    );}// ---------------------------------------------------------------------------void     PrintNumVersion    (char *label, NumVersion version )// ---------------------------------------------------------------------------////  Decode version number info//{  char      *stage;  switch (version.stage) {  case developStage:  stage = &quot;d&quot;;    break;  case alphaStage:  stage = &quot;a&quot;;    break;  case betaStage:    stage = &quot;b&quot;;    break;  case finalStage:  stage = &quot;&quot;;      break;  default:      stage = &quot;?&quot;;    break;    }  printf(&quot;%s %d.%d.%d&quot;,    label,    version.majorRev,    (version.minorAndBugRev&gt;&gt;4), (version.minorAndBugRev &amp; 0xf),    stage);  if(version.stage != finalStage) printf(&quot;.%d&quot;,version.nonRelRev);    printf(&quot; (hex %08lx)\n&quot;,  (* ((unsigned long *) &amp;version)));}// ---------------------------------------------------------------------------void    DumpFormatedBuffer  (void* p,  const FormatTablePtr format) // ---------------------------------------------------------------------------//// Dump formatted buffer//{    unsigned short      *idInfo = p;       register char      *charField;  register short      fieldLength;  register short      i;  register long      value;  register FormatTablePtr  formatPtr;  #define FORMAT  (*formatPtr)  for (formatPtr = format; FORMAT.format != kEndOfTable; formatPtr++) {      printf(&quot;%35s&quot;, FORMAT.label);      switch (FORMAT.format) {      // Decimal values come as two words with the words swapped.      case kDecimal:        value = 0;        for (i = FORMAT.lastWord; i &gt;= FORMAT.firstWord; i--) {          value &lt;&lt;= 16;          value += idInfo[i];        }        printf(&quot; %lu&quot;, value);  // was %lu        break;              case kHex:        for (i = FORMAT.lastWord; i &gt;= FORMAT.firstWord; i--) {          value = idInfo[i];          printf(&quot; 0x%04X&quot;, value);        }        break;              case kLeftJust:        charField = (char *) &amp;idInfo[FORMAT.firstWord];        fieldLength = (FORMAT.lastWord - FORMAT.firstWord + 1)              * sizeof (unsigned short);        /*         * First scan for an unspecified field.         */        for (i = 0; i &lt;= fieldLength; i++) {          if (charField[i] != '\0')            goto gotLeftJustField;        }        printf(&quot; &lt;not specified&gt;&quot;);        break;        gotLeftJustField:        for (i = fieldLength; i &gt; 0; --i) {          if (charField[i - 1] != ' ')            break;        }        printf(&quot; \&quot;%.*s\&quot;&quot;, (int) i, charField);        break;              case kRightJust:        charField = (char *) &amp;idInfo[FORMAT.firstWord];        fieldLength = (FORMAT.lastWord - FORMAT.firstWord + 1)              * sizeof (unsigned short);        /*         * First scan for an unspecified field.         */        for (i = 0; i &lt;= fieldLength; i++) {          if (charField[i] != '\0')            goto gotRightJustField;        }        printf(&quot; &lt;not specified&gt;&quot;);        break;        gotRightJustField:        for (i = 0; i &lt; fieldLength; i++) {          if (charField[i] != ' ')            break;        }        printf(&quot; \&quot;%.*s\&quot;&quot;, (int) (fieldLength - i), &amp;charField[i]);        break;              }      printf(&quot;\n&quot;);    }//    DumpRawBuffer( p,512);}    // ---------------------------------------------------------------------------void    DumpRawBuffer    ( UInt8 *bufferPtr, int length )// ---------------------------------------------------------------------------//// Dump buffer//{    register int      i;    int            lineStart;    int            lineLength;    short          c;#define kLineSize  16    for (lineStart = 0; lineStart &lt; length; lineStart += lineLength) {      lineLength = kLineSize;      if (lineStart + lineLength &gt; length)        lineLength = length - lineStart;      printf(&quot;%03x %3d:&quot;, lineStart, lineStart);      for (i = 0; i &lt; lineLength; i++)        printf(&quot; %02x&quot;, bufferPtr[lineStart + i] &amp; 0xFF);      for (; i &lt; kLineSize; i++)        printf(&quot;   &quot;);      printf(&quot;  &quot;);      for (i = 0; i &lt; lineLength; i++) {        c = bufferPtr[lineStart + i] &amp; 0xFF;        if (c &gt; ' ' &amp;&amp; c &lt; '~')          printf(&quot;%c&quot;, c);        else {          printf(&quot;.&quot;);        }      }      printf(&quot;\n&quot;);    }}    // ---------------------------------------------------------------------------char*    DrvrRefToName(short refNum)// ---------------------------------------------------------------------------////  lookup driver name in table//{    AuxDCEHandle*    UTable  = (AuxDCEHandle*) LMGetUTableBase();    DCtlPtr        dctl;    Ptr          p;          if(!refNum) return ((char*) &quot;\p&lt;none&gt;&quot;);    dctl = (DCtlPtr) *UTable[~refNum];    p    =  dctl-&gt;dCtlDriver;    if( dctl-&gt;dCtlFlags  &amp; 0x0040) p = (void*) *p;    return  ( p?(char*) (p+18):(char*)&quot;\p-Purged-&quot;);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ATADemo/listing1.html%3Fid%3DDTS10000418-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ATADemo/listing1.html%3Fid%3DDTS10000418-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ATADemo/listing1.html%3Fid%3DDTS10000418-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>