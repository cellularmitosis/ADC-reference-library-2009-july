<HTML><HEAD>   <title>Technical Q&amp;A QA1061: RunApplicationEventLoop and Thread Manager</title><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><meta name="keywords" content="RunApplicationEventLoop, Thread Manager, cooperative threads,YieldToAnyThread"><meta name="Description" content="Technical Q&amp;A QA1061: Describes how to yield to cooperative(Thread Manager) threads from a RunApplicationEventLoop-basedapplication."><meta name="categories" content="Processes"><meta name="week-posted" content="Oct 8, 2001 - Oct 12, 2001"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10001613" title="RunApplicationEventLoop and Thread Manager"></a><P><!-- top_of_header_marker_comment --> <!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalqas/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxProcessManagement-date.html" target="_blank">Carbon > Process Management</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --> <!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A QA1061</div>
<div id="pageheadsub">RunApplicationEventLoop and Thread Manager</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --></P><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600>   <TR>      <td align="left">         <P><!-- begin_content -->                  <hr width=500 align=center>                  </P>                  <P id=p2>Q: I want to change my Carbon application to use         <CODE>RunApplicationEventLoop</CODE>. My application uses         cooperative (Thead Manager) threads and there's no obvious         place to call <CODE>YieldToAnyThread</CODE>         (r. 2729795). Should I use a Carbon timer to yield to         my cooperative threads?</P>                  <P id=p4>A: No. Using a timer is not the best solution         because it limits the amount of processing that your         cooperative threads can do. The right thing to do depends on         whether your threads are compute-bound or I/O-bound. I'll         explain each case in turn.</P>                  <P id=p4>For compute-bound cooperative threads the simplest         thing to do is to write your own equivalent of         <CODE>RunApplicationEventLoop</CODE> that includes a call to         <CODE>YieldToAnyThread</CODE>. The core code for         <CODE>RunApplicationEventLoop</CODE> is shown in Listing         3-10 of <A href="../../documentation/Carbon/pdf/HandlingCarbEvents.pdf">Inside         Carbon: Handling Carbon Events</A>. I've included a version         of this code in Listing 1. The         <CODE>EventLoopEventHandler</CODE> routine is the actual         event loop code. The remainder of Listing 1 implements a         trick to ensure that the standard handlers are installed         while <CODE>EventLoopEventHandler</CODE> executes; see the         comments in the code for an explanation of what it does and         why.</P>                  <P><BR>         <BR>         </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>extern SInt32 gNumberOfRunningThreads;    // This variable must be maintained by your thread scheduling    // code to accurately reflect the number of threads that are    // ready and need time for computation.static EventHandlerUPP gQuitEventHandlerUPP;   // -&gt; QuitEventHandlerstatic pascal OSStatus QuitEventHandler(EventHandlerCallRef inHandlerCallRef,                                        EventRef inEvent, void *inUserData)    // This event handler is used to override the kEventClassApplication/    // kEventAppQuit event while inside our event loop (EventLoopEventHandler).    // It simply calls through to the next handler and, if that handler returns    // noErr (indicating that the application is doing to quit), it sets    // a Boolean to tell our event loop to quit as well.{    OSStatus err;    MoreAssertQ(inUserData != nil);    MoreAssertQ( GetEventClass( inEvent ) == kEventClassApplication );    MoreAssertQ( GetEventKind ( inEvent ) == kEventAppQuit );    err = CallNextEventHandler(inHandlerCallRef, inEvent);    if (err == noErr) {        *((Boolean *) inUserData) = true;    }    return err;}static EventHandlerUPP gEventLoopEventHandlerUPP;   // -&gt; EventLoopEventHandlerstatic pascal OSStatus EventLoopEventHandler(EventHandlerCallRef inHandlerCallRef,                                             EventRef inEvent, void *inUserData)    // This code contains the standard Carbon event dispatch loop,    // as per &quot;Inside Macintosh: Handling Carbon Events&quot;, Listing 3-10,    // except:    //    // o this loop supports yielding to cooperative threads based on the    //   application maintaining the gNumberOfRunningThreads global    //   variable, and    //    // o it also works around a problem with the Inside Macintosh code    //   which unexpectedly quits when run on traditional Mac OS 9.    //    // See RunApplicationEventLoopWithCooperativeThreadSupport for    // an explanation of why this is inside a Carbon event handler.    //    // The code in Inside Mac has a problem in that it quits the    // event loop when ReceiveNextEvent returns an error.  This is    // wrong because ReceiveNextEvent can return eventLoopQuitErr    // when you call WakeUpProcess on traditional Mac OS.  So, rather    // than relying on an error from ReceiveNextEvent, this routine tracks    // whether the application is really quitting by installing a    // customer handler for the kEventClassApplication/kEventAppQuit    // Carbon event.  All the custom handler does is call through    // to the previous handler and, if it returns noErr (which indicates    // the application is quitting, it sets quitNow so that our event    // loop quits.    //    // Note that this approach continues to support QuitApplicationEventLoop,    // which is a simple wrapper that just posts a kEventClassApplication/    // kEventAppQuit event to the event loop.{    OSStatus        err;    OSStatus        junk;    EventHandlerRef installedHandler;    EventTargetRef  theTarget;    EventRef        theEvent;    EventTimeout    timeToWaitForEvent;    Boolean         quitNow;    static const EventTypeSpec eventSpec = {kEventClassApplication, kEventAppQuit};    quitNow = false;    MoreAssertQ(gQuitEventHandlerUPP != nil);    // Install our override on the kEventClassApplication, kEventAppQuit event.    err = InstallEventHandler(GetApplicationEventTarget(), gQuitEventHandlerUPP,                              1, &amp;eventSpec, &amp;quitNow, &amp;installedHandler);    if (err == noErr) {        // Run our event loop until quitNow is set.        theTarget = GetEventDispatcherTarget();        do {            if (gNumberOfRunningThreads == 0) {                timeToWaitForEvent = kEventDurationForever;            } else {                timeToWaitForEvent = kEventDurationNoWait;            }            err = ReceiveNextEvent(0, NULL, timeToWaitForEvent,                                   true, &amp;theEvent);            if (err == noErr) {                (void) SendEventToEventTarget(theEvent, theTarget);                ReleaseEvent(theEvent);            }            if (gNumberOfRunningThreads &gt; 0) {                (void) YieldToAnyThread();            }        } while ( ! quitNow );        // Clean up.        junk = RemoveEventHandler(installedHandler);        MoreAssertQ(junk == noErr);    }    // So we can tell when our event loop quit.    SysBeep(10);    return err;}static void RunApplicationEventLoopWithCooperativeThreadSupport(void)    // A reimplementation of RunApplicationEventLoop that supports    // yielding time to cooperative threads.  It relies on the    // rest of your application to maintain a global variable,    // gNumberOfRunningThreads, that reflects the number of threads    // that are ready to run.{    static const EventTypeSpec eventSpec = {'KWIN', 'KWIN' };    OSStatus        err;    OSStatus        junk;    EventTargetRef  appTarget;    EventHandlerRef installedHandler;    EventRef        dummyEvent;    dummyEvent = nil;    // Create a UPP for EventLoopEventHandler and QuitEventHandler    // (if we haven't already done so).    err = noErr;    if (gEventLoopEventHandlerUPP == nil) {        gEventLoopEventHandlerUPP = NewEventHandlerUPP(EventLoopEventHandler);    }    if (gQuitEventHandlerUPP == nil) {        gQuitEventHandlerUPP = NewEventHandlerUPP(QuitEventHandler);    }    if (gEventLoopEventHandlerUPP == nil || gQuitEventHandlerUPP == nil) {        err = memFullErr;    }    // Install EventLoopEventHandler, create a dummy event and post it,    // and then call RunApplicationEventLoop.  The rationale for this    // is as follows:  We want to unravel RunApplicationEventLoop so    // that we can can yield to cooperative threads.  In fact, the    // core code for RunApplicationEventLoop is pretty easy (you    // can see it above in EventLoopEventHandler).  However, if you    // just execute this code you miss out on all the standard event    // handlers.  These are relatively easy to reproduce (handling    // the quit event and so on), but doing so is a pain because    // a) it requires a bunch boilerplate code, and b) if Apple    // extends the list of standard event handlers, your application    // wouldn't benefit.  So, we execute our event loop from within    // a Carbon event handler that we cause to be executed by    // explicitly posting an event to our event loop.  Thus, the    // standard event handlers are installed while our event loop runs.    if (err == noErr) {        err = InstallEventHandler(GetApplicationEventTarget(), gEventLoopEventHandlerUPP,                                  1, &amp;eventSpec, nil, &amp;installedHandler);        if (err == noErr) {            err = MacCreateEvent(nil, 'KWIN', 'KWIN', GetCurrentEventTime(),                                  kEventAttributeNone, &amp;dummyEvent);            if (err == noErr) {                err = PostEventToQueue(GetMainEventQueue(), dummyEvent,                                  kEventPriorityHigh);            }            if (err == noErr) {                RunApplicationEventLoop();            }            junk = RemoveEventHandler(installedHandler);            MoreAssertQ(junk == noErr);        }    }    // Clean up.    if (dummyEvent != nil) {        ReleaseEvent(dummyEvent);    }</pre>               </TD>            </TR>            <TR>               <td align="left">                  <P><B>Listing 1</B>.                  <CODE>RunApplicationEventLoopWithCooperativeThreadSupport</CODE></P>               </TD>            </TR>         </TABLE>         </CENTER>                  <P><BR>         <BR>         The <CODE>timeToWaitForEvent</CODE> variable is a key part         of <CODE>EventLoopEventHandler</CODE>. If there are no         active cooperative threads, <CODE>timeToWaitForEvent</CODE>         is set to <CODE>kEventDurationForever</CODE> which means         that <CODE>ReceiveNextEvent</CODE> will block your process         until some event arrives (or a timer fires). On the other         hand, if there are active cooperative threads then         <CODE>timeToWaitForEvent</CODE> is set to         <CODE>kEventDurationNoWait</CODE> and         <CODE>ReceiveNextEvent</CODE> will return immediately with         no event, and your cooperative threads will get an         appropriately large fraction of the CPU.</P>                  <P id=p4>Note: Of course, if your cooperative threads are         compute-bound you probably want to switch to one of the         preemptive threading APIs to take advantage of the second         processor on dual processor computers. However, for the sake         of this discussion I'll assume that you're looking for the         simplest solution.</P>                  <P id=p4>The approach described above falls down for         I/O-bound threads for two reasons.</P>                  <UL id=p4>            <LI>Determining <CODE>gNumberOfRunningThreads</CODE>            becomes difficult as threads start and stop waiting for            I/O.</LI>                        <LI>Cooperative threads always have a high scheduling            latency, which makes them incompatible with fast I/O            (without using excessive memory or CPU). For a further            discussion of this point, see the documentation that            comes with the <A href="../../samplecode/Sample_Code/Networking/OTMP.htm">OTMP</A>            DTS sample.</LI>         </UL>                  <P id=p4>The solution to this conundrum is to turn your         I/O-bound cooperative threads into preemptive threads (MP         tasks for Mac OS 9 and Mac OS X, or pthreads for Mac OS X         only). A significant amount of the I/O subsystem can be         called from preemptive threads, even on Mac OS 9. DTS         Technote 2006 <a href="../../technotes/tn/tn2006.html">MP-Safe         Routines</A> lists the preemptive-safe routines that are         available on both Mac OS 9 and Mac OS X.</P>                  <P id=p4>If a particular I/O subsystem is not callable from         preemptive threads on Mac OS 9, it may be possible to         construct glue for calling it. A good example of this is the         "OTMP" DTS sample (see the URL above).</P>                  <P>                  <hr width=500 align=center>                  </P>                  <!-- begin_date --><H4><CENTER>[Oct 10 2001]</CENTER></H4><!-- end_date -->      </TD>   </TR></TABLE></CENTER><P><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/qa2001/qa1061.html%3Fid%3DDTS10001613-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/qa2001/qa1061.html%3Fid%3DDTS10001613-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/qa2001/qa1061.html%3Fid%3DDTS10001613-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --><hr width=500 align=center><hr width=500 align=center></P></BODY></HTML>