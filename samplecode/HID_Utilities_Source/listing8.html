<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>HID Utilities Source - /HID_Queue_Utilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/HardwareDrivers/index.html">Hardware & Drivers</a> &gt; <a href="../../samplecode/HardwareDrivers/idxHumanInterfaceDeviceForceFeedback-date.html">Human Interface Device & Force Feedback</a> &gt; <A HREF="javascript:location.replace('index.html');">HID Utilities Source</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">HID Utilities Source</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/HID_Queue_Utilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/HID_CFM.c</option>
<option value="listing2.html">/HID_Config_Utilities.c</option>
<option value="listing3.html">/HID_Config_Utilities.h</option>
<option value="listing4.html">/HID_Error_Handler.c</option>
<option value="listing5.html">/HID_Error_Handler.h</option>
<option value="listing6.html">/HID_Name_Lookup.c</option>
<option value="listing7.html">/HID_Name_Lookup.h</option>
<option value="listing8.html">/HID_Queue_Utilities.c</option>
<option value="listing9.html">/HID_Queue_Utilities.h</option>
<option value="listing10.html">/HID_Transaction_Utilities.c</option>
<option value="listing11.html">/HID_Transaction_Utilities.h</option>
<option value="listing12.html">/HID_Utilities.c</option>
<option value="listing13.html">/HID_Utilities.h</option>
<option value="listing14.html">/HID_Utilities_CFM.h</option>
<option value="listing15.html">/HID_Utilities_External.h</option>
<option value="listing16.html">/HID_Utilities_Internal.h</option>
<option value="listing17.html">/HIDLib.h</option>
<option value="listing18.html">/IOHIDPowerUsage.h</option>
<option value="listing19.html">/PID.h</option></select>
				</p>
				</form>
				<p><strong><a href="HID_Utilities_Source.zip">Download Sample</a></strong> (&#147;HID_Utilities_Source.zip&#148;, 280.4K)<BR>
<strong><a href="HID_Utilities_Source.dmg">Download Sample</a></strong> (&#147;HID_Utilities_Source.dmg&#148;, 335.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    HID_Queue_Utilities.c

  Contains:  Implementation of the HID queue functions for the HID utilites.
    
  DRI: George Warner

  Copyright:  Copyright &copy; 2002 Apple Computer, Inc., All Rights Reserved

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//#include &lt;IOKit/hid/IOHIDDevice.h&gt;

#include &quot;HID_Utilities_Internal.h&quot;
#include &quot;HID_Utilities_External.h&quot;

// ==================================
// compiler directives
// ==================================
#define USE_ASYNC_EVENTS TRUE
#define REPORT_ERRORS FALSE
// ==================================
#if REPORT_ERRORS
#define HIDREPORTERRORNUM(s,n) HIDReportErrorNum(s,n)
#define HIDREPORTERROR(s)    HIDReportError(s)
#else
#define HIDREPORTERRORNUM(s,n)  do {} while (false)
#define HIDREPORTERROR(s)    do {} while (false)
#endif
// ==================================
// private functions
// ==================================

// creates a queue for a device

static IOReturn hid_CreateQueue (pRecDevice pDevice)
{
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)

  if (HIDIsValidDevice(pDevice))
  {
    if (NULL == pDevice-&gt;queue) // do we already have a queue
    {
      if (NULL != pDevice-&gt;interface)
      {
        pDevice-&gt;queue = (void *) (*(IOHIDDeviceInterface**) pDevice-&gt;interface)-&gt;allocQueue (pDevice-&gt;interface); // alloc queue
        if (pDevice-&gt;queue)
        {
          result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;create (pDevice-&gt;queue, 0, kDeviceQueueSize); // create actual queue
          if (kIOReturnSuccess != result)
            HIDREPORTERRORNUM (&quot;hid_CreateQueue - Failed to create queue via create&quot;, result);
        }
        else
        {
          HIDREPORTERROR (&quot;hid_CreateQueue - Failed to alloc IOHIDQueueInterface ** via allocQueue&quot;);
          result = kIOReturnError; // synthesis error
        }
      }
      else
        HIDREPORTERRORNUM (&quot;hid_CreateQueue - Device inteface does not exist for queue creation&quot;, result);
    }
  }
  else
    HIDREPORTERRORNUM (&quot;hid_CreateQueue - Invalid Device&quot;, result);
    return result;
}

// ---------------------------------
// returns true if queue is empty false otherwise
// error if no device, empty if no queue

static unsigned char hid_IsDeviceQueueEmpty (pRecDevice pDevice)
{
  if (HIDIsValidDevice(pDevice))  // need valid device
  {
    if (pDevice-&gt;queue) // and queue
    {
      pRecElement pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
      while (pElement)
      {
        if ((*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
          return false;
        pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
      } 
    }
    else
      HIDREPORTERROR (&quot;hid_IsDeviceQueueEmpty - no queue.&quot;);
  }
  else
    HIDREPORTERROR (&quot;hid_IsDeviceQueueEmpty - Invalid device.&quot;);
  return true;   
}

// ---------------------------------
// disposes and releases queue, sets queue to NULL,.
// Note: will have no effect if device or queue do not exist

static IOReturn hid_DisposeReleaseQueue (pRecDevice pDevice)
{
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)

  if (HIDIsValidDevice(pDevice))  // need valid device
  {
    if (pDevice-&gt;queue) // and queue
    {
      // stop queue
      result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
      if (kIOReturnSuccess != result)
        HIDREPORTERRORNUM (&quot;hid_DisposeReleaseQueue - Failed to stop queue.&quot;, result);
      // dispose of queue
      result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;dispose (pDevice-&gt;queue);
      if (kIOReturnSuccess != result)
        HIDREPORTERRORNUM (&quot;hid_DisposeReleaseQueue - Failed to dipose queue.&quot;, result);
      // release the queue
      result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;Release (pDevice-&gt;queue);
      if (kIOReturnSuccess != result)
        HIDREPORTERRORNUM (&quot;hid_DisposeReleaseQueue - Failed to release queue.&quot;, result);

      pDevice-&gt;queue = NULL;
    }
    else
      HIDREPORTERROR (&quot;hid_DisposeReleaseQueue - no queue.&quot;);
  }
  else
    HIDREPORTERROR (&quot;hid_DisposeReleaseQueue - Invalid device.&quot;);
    return result;
}

// ==================================
// public functions

// ---------------------------------
// queues specific element, performing any device queue set up required
// queue is started and ready to return events on exit from this function

unsigned long  HIDQueueElement (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)

  if (HIDIsValidElement(pDevice,pElement))
  {
    if (NULL == pDevice-&gt;interface) // must have interface
    {
      HIDREPORTERROR (&quot;HIDQueueElement - Device does not have interface.&quot;);
      return kIOReturnError;
    }
    if (NULL == pDevice-&gt;queue) // if no queue create queue
      result = hid_CreateQueue (pDevice);
    if ((kIOReturnSuccess != result) || (NULL == pDevice-&gt;queue))
    {
      HIDREPORTERRORNUM (&quot;HIDQueueElement - problem creating queue.&quot;, result);
      if (kIOReturnSuccess != result)
        return result;
      else
        return kIOReturnError;
    }

    // stop queue
    result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
      HIDREPORTERROR (&quot;HIDQueueElement - Failed to stop queue.&quot;);

    // queue element
    if (!(*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
    {
      result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;addElement (pDevice-&gt;queue, pElement-&gt;cookie, 0);
      if (kIOReturnSuccess != result)
        HIDREPORTERROR (&quot;HIDQueueElement - Failed to add Element to queue.&quot;);
    }

    // restart queue
    result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
      HIDREPORTERROR (&quot;HIDQueueElement - Failed to start queue.&quot;);
  }
  else
  {
    HIDREPORTERROR (&quot;HIDQueueElement - Invalid Device and/or element.&quot;);
        return kIOReturnBadArgument;
  }

   return result;
}

// ---------------------------------
// adds all elements to queue, performing any device queue set up required
// queue is started and ready to return events on exit from this function

unsigned long  HIDQueueDevice (pRecDevice pDevice)
{
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)
    pRecElement pElement;

  if (HIDIsValidDevice(pDevice))
  {
    // error checking
    if (NULL == pDevice)
    {
      HIDREPORTERROR (&quot;HIDQueueDevice - Device does not exist.&quot;);
      return kIOReturnBadArgument;
    }
    if (NULL == pDevice-&gt;interface) // must have interface
    {
      HIDREPORTERROR (&quot;HIDQueueDevice - Device does not have interface.&quot;);
      return kIOReturnError;
    }
    if (NULL == pDevice-&gt;queue) // if no queue create queue
      result = hid_CreateQueue (pDevice);
    if ((kIOReturnSuccess != result) || (NULL == pDevice-&gt;queue))
    {
      HIDREPORTERRORNUM (&quot;HIDQueueDevice - problem creating queue.&quot;, result);
      if (kIOReturnSuccess != result)
        return result;
      else
        return kIOReturnError;
    }

    // stop queue
    result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
      HIDREPORTERRORNUM (&quot;HIDQueueDevice - Failed to stop queue.&quot;, result);

    // queue element
  //* pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
    pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeInput | kHIDElementTypeFeature);

    while (pElement)
    {
      if (!(*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
      {
        result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;addElement (pDevice-&gt;queue, pElement-&gt;cookie, 0);
        if (kIOReturnSuccess != result)
          HIDREPORTERRORNUM (&quot;HIDQueueDevice - Failed to add element to queue.&quot;, result);
      }
      //* pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
      pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeInput | kHIDElementTypeFeature);
    }

    // start queue
    result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
      HIDREPORTERRORNUM (&quot;HIDQueueDevice - Failed to start queue.&quot;, result);
    
  }
  else
    HIDREPORTERROR (&quot;HIDQueueDevice - Invalid device.&quot;);

    return result;
}

// ---------------------------------
// removes element for queue, if last element in queue will release queue and closes device interface

unsigned long  HIDDequeueElement (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)

  if (HIDIsValidElement(pDevice,pElement))
  {
    if (!pDevice || !pElement)
      result = kIOReturnBadArgument;
    else
    {
      if ((pDevice-&gt;interface) &amp;&amp; (pDevice-&gt;queue))
      {
        // stop queue
        result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
        if (kIOReturnSuccess != result)
          HIDREPORTERRORNUM (&quot;HIDDequeueElement - Failed to stop queue.&quot;, result);

        if ((*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie)) // if has element then remove
        {
          result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;removeElement (pDevice-&gt;queue, pElement-&gt;cookie);
          if (kIOReturnSuccess != result)
            HIDREPORTERRORNUM (&quot;HIDDequeueElement - Failed to add element to queue&quot;, result);
        }

        if (hid_IsDeviceQueueEmpty (pDevice)) // release device queue and close interface if queue empty
        {
          result = hid_DisposeReleaseQueue (pDevice);
          if (kIOReturnSuccess != result)
            HIDREPORTERRORNUM (&quot;HIDDequeueElement - Failed to dispose and release queue.&quot;, result);
        }
        else // not empty so restart queue
        {
          result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
          if (kIOReturnSuccess != result)
            HIDREPORTERRORNUM (&quot;HIDDequeueElement - Failed to start queue.&quot;, result);
        }
      }
      else
      {
        HIDREPORTERROR (&quot;HIDDequeueElement - No device inteface or queue.&quot;);
        return kIOReturnError;
      }
    }
  }
  else
    HIDREPORTERROR (&quot;HIDDequeueElement - Invalid device.&quot;);

    return result;
}

// ---------------------------------
// completely removes all elements from queue and releases queue and closes device interface
// does not release device interfaces, application must call HIDReleaseDeviceList on exit

unsigned long  HIDDequeueDevice (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;

    if (HIDIsValidDevice(pDevice))
  {
    if ((pDevice-&gt;interface) &amp;&amp; (pDevice-&gt;queue))
    {
      // iterate through elements and if queued, remove
      pRecElement pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
      while (pElement)
      {
        if ((*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
        {
          result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;removeElement (pDevice-&gt;queue, pElement-&gt;cookie);
          if (kIOReturnSuccess != result)
            HIDREPORTERRORNUM (&quot;HIDDequeueDevice - Failed to remove element from queue.&quot;, result);
        }
        pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
      }
    }
    // ensure queue is disposed and released
    // interface will be closed and released on call to HIDReleaseDeviceList
    result = hid_DisposeReleaseQueue (pDevice);
    if (kIOReturnSuccess != result)
      HIDREPORTERRORNUM (&quot;removeElement - Failed to dispose and release queue.&quot;, result);
#if USE_ASYNC_EVENTS
    else if (NULL != pDevice-&gt;queueRunLoopSource)
    {
      if (CFRunLoopContainsSource(CFRunLoopGetCurrent(), pDevice-&gt;queueRunLoopSource, kCFRunLoopDefaultMode))
        CFRunLoopRemoveSource(CFRunLoopGetCurrent(), pDevice-&gt;queueRunLoopSource, kCFRunLoopDefaultMode);
      CFRelease(pDevice-&gt;queueRunLoopSource);
      pDevice-&gt;queueRunLoopSource = NULL;
    }
#endif USE_ASYNC_EVENTS
  }
  else
  {
    HIDREPORTERROR (&quot;HIDDequeueDevice - Invalid device.&quot;);
    result = kIOReturnBadArgument;
  }
    return result;
}

// ---------------------------------
// releases all device queues for quit or rebuild (must be called)
// does not release device interfaces, application must call HIDReleaseDeviceList on exit

unsigned long HIDReleaseAllDeviceQueues (void)
{
    IOReturn result = kIOReturnBadArgument;
    pRecDevice pDevice = HIDGetFirstDevice ();

    while (pDevice)
    {
        result = HIDDequeueDevice (pDevice);
        if (kIOReturnSuccess != result)
            HIDREPORTERRORNUM (&quot;HIDReleaseAllDeviceQueues - Could not dequeue device.&quot;, result);
        pDevice = HIDGetNextDevice (pDevice);
    }
    return result;
}

// ---------------------------------
// Closes and releases interface to device, should be done prior to exting application
// Note: will have no affect if device or interface do not exist
// application will &quot;own&quot; the device if interface is not closed
// (device may have to be plug and re-plugged in different location to get it working again without a restart)

unsigned long HIDCloseReleaseInterface (pRecDevice pDevice)
{
  IOReturn result = kIOReturnSuccess;
  
  if (HIDIsValidDevice(pDevice) &amp;&amp; (NULL != pDevice-&gt;interface))
  {
    // close the interface
    result = (*(IOHIDDeviceInterface**) pDevice-&gt;interface)-&gt;close (pDevice-&gt;interface);
    if (kIOReturnNotOpen == result)
    {
      //  do nothing as device was not opened, thus can't be closed
    }
    else if (kIOReturnSuccess != result)
      HIDREPORTERRORNUM (&quot;HIDCloseReleaseInterface - Failed to close IOHIDDeviceInterface.&quot;, result);
    //release the interface
    result = (*(IOHIDDeviceInterface**) pDevice-&gt;interface)-&gt;Release (pDevice-&gt;interface);
    if (kIOReturnSuccess != result)
      HIDREPORTERRORNUM (&quot;HIDCloseReleaseInterface - Failed to release interface.&quot;, result);
    pDevice-&gt;interface = NULL;
  }  
  return result;
}      

// ---------------------------------
// Get the next event in the queue for a device
// elements or entire device should be queued prior to calling this with HIDQueueElement or HIDQueueDevice
// returns true if an event is avialable for the element and fills out *pHIDEvent structure, returns false otherwise
// Note: kIOReturnUnderrun returned from getNextEvent indicates an empty queue not an error condition
// Note: application should pass in a pointer to a IOHIDEventStruct cast to a void (for CFM compatibility)

unsigned char HIDGetEvent (pRecDevice pDevice, void * pHIDEvent)
{
    IOReturn result = kIOReturnBadArgument;
    AbsoluteTime zeroTime = {0,0};

    if (HIDIsValidDevice(pDevice))
  {
    if (pDevice-&gt;queue)
    {
      result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;getNextEvent (pDevice-&gt;queue, (IOHIDEventStruct *)pHIDEvent, zeroTime, 0);
      if (kIOReturnUnderrun == result)
        return false;  // no events in queue not an error per say
      else if (kIOReturnSuccess != result) // actual error versus just an empty queue
        HIDREPORTERRORNUM (&quot;HIDGetEvent - Could not get HID event via getNextEvent.&quot;, result);
      else
        return true;
    }
    else
      HIDREPORTERROR (&quot;HIDGetEvent - queue does not exist.&quot;);
  }
  else
    HIDREPORTERROR (&quot;HIDGetEvent - invalid device.&quot;);

    return false; // did not get event
}

// ---------------------------------
// returns current value for element, polling element
// will return 0 on error conditions which should be accounted for by application

long HIDGetElementValue (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnBadArgument;
    IOHIDEventStruct hidEvent;

  hidEvent.value = 0;
    hidEvent.longValueSize = 0;
  hidEvent.longValue = nil;

  if (HIDIsValidElement(pDevice, pElement))
  {
    if (NULL != pDevice-&gt;interface)
    {
      // ++ NOTE: If the element type is feature then use queryElementValue instead of getElementValue
      if (kIOHIDElementTypeFeature == pElement-&gt;type)
      {
        result = (*(IOHIDDeviceInterface**) pDevice-&gt;interface)-&gt;queryElementValue (pDevice-&gt;interface, pElement-&gt;cookie, &amp;hidEvent,0,NULL,NULL,NULL);
        if (kIOReturnUnsupported == result)  // unless it's unsuported.
          goto try_getElementValue;
        else if (kIOReturnSuccess != result)
          HIDREPORTERRORNUM (&quot;HIDGetElementValue - Could not get HID element value via queryElementValue.&quot;, result);
      }
      else if (pElement-&gt;type &lt;= kIOHIDElementTypeInput_ScanCodes)
      {
try_getElementValue:
        result = (*(IOHIDDeviceInterface**) pDevice-&gt;interface)-&gt;getElementValue (pDevice-&gt;interface, pElement-&gt;cookie, &amp;hidEvent);
        if (kIOReturnSuccess != result)
          HIDREPORTERRORNUM (&quot;HIDGetElementValue - Could not get HID element value via getElementValue.&quot;, result);
      }
      // on 10.0.x this returns the incorrect result for negative ranges, so fix it!!!
   // this is not required on Mac OS X 10.1+
      if ((pElement-&gt;min &lt; 0) &amp;&amp; (hidEvent.value &gt; pElement-&gt;max)) // assume range problem
        hidEvent.value = hidEvent.value + pElement-&gt;min - pElement-&gt;max - 1;
    }
    else
      HIDREPORTERROR (&quot;HIDGetElementValue - no interface for device.&quot;);
  }
  else
    HIDREPORTERROR (&quot;HIDGetElementValue - invalid device and/or element.&quot;);

    // record min and max for auto scale and auto ...
    if (hidEvent.value &lt; pElement-&gt;calMin)
        pElement-&gt;calMin = hidEvent.value; 
    if (hidEvent.value &gt; pElement-&gt;calMax)
        pElement-&gt;calMax = hidEvent.value; 

    // auto user scale
    return hidEvent.value;
}

// ---------------------------------
// Set an elements value
// NOTE: This should only be used when a single element of a report needs to be sent.
// If multiple elements are to be send then transactions should be used.

long HIDSetElementValue (pRecDevice pDevice, pRecElement pElement,void* pIOHIDEvent)
{
  IOHIDEventStruct* pMyIOHIDEvent = (IOHIDEventStruct*) pIOHIDEvent;
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)

  if (HIDIsValidElement(pDevice, pElement))
  {
    if (NULL != pDevice-&gt;interface)
    {
      result = (*(IOHIDDeviceInterface**) pDevice-&gt;interface)-&gt;setElementValue (pDevice-&gt;interface, pElement-&gt;cookie, pMyIOHIDEvent, -1, nil, nil, nil);
      if (kIOReturnSuccess != result)
        HIDREPORTERRORNUM (&quot;HIDSetElementValue - Could not set HID element value via setElementValue.&quot;, result);
    }
    else
      HIDREPORTERROR (&quot;HIDSetElementValue - no interface for device.&quot;);
  }
  else
    HIDREPORTERROR (&quot;HIDSetElementValue - invalid device and/or element.&quot;);
  
    return result;
}

// ---------------------------------
// Set a callback to be called when a queue goes from empty to non-empty
long HIDSetQueueCallback (pRecDevice pDevice, IOHIDCallbackFunction callback)
{
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)

  if (HIDIsValidDevice(pDevice))
  {
#if USE_ASYNC_EVENTS
    // if we don't have a queue runloop source\xC9
    if (NULL == pDevice-&gt;queueRunLoopSource)
    {
      // then create one
      result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;createAsyncEventSource((void *) pDevice-&gt;queue,
        (CFRunLoopSourceRef*) &amp;pDevice-&gt;queueRunLoopSource);
      if (kIOReturnSuccess != result)
        HIDREPORTERRORNUM (&quot;HIDSetQueueCallback - Failed to createAsyncEventSource error: &quot;, result);
    }
    // if we have one now\xC9
    if (NULL != pDevice-&gt;queueRunLoopSource)
    {
      // and it's not already attached to our runloop\xC9
      if (!CFRunLoopContainsSource(CFRunLoopGetCurrent(), pDevice-&gt;queueRunLoopSource, kCFRunLoopDefaultMode))
        // then attach it now.
        CFRunLoopAddSource(CFRunLoopGetCurrent(), pDevice-&gt;queueRunLoopSource, kCFRunLoopDefaultMode);
    }

    // now install our callback
    result = (*(IOHIDQueueInterface**) pDevice-&gt;queue)-&gt;setEventCallout(pDevice-&gt;queue, callback, pDevice, pDevice);
    if (kIOReturnSuccess != result)
      HIDREPORTERRORNUM (&quot;HIDSetQueueCallback - Could not set HID queue callback via setEventCallout.&quot;, result);
#endif USE_ASYNC_EVENTS
  }
  else
    HIDREPORTERROR (&quot;HIDSetQueueCallback - invalid device and/or element.&quot;);
    return result;
}

#if 1
// ---------------------------------
// Get a report from a device
long HIDGetReport (pRecDevice pDevice,const IOHIDReportType reportType, const UInt32 reportID, void* reportBuffer, UInt32* reportBufferSize)
{
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)

    if (HIDIsValidDevice(pDevice))
    {
    if (NULL != pDevice-&gt;interface)
    {
      result = (*(IOHIDDeviceInterface**) pDevice-&gt;interface)-&gt;getReport (pDevice-&gt;interface, reportType, reportID, reportBuffer, reportBufferSize, -1, nil, nil, nil);
      if (kIOReturnSuccess != result)
        HIDREPORTERRORNUM (&quot;HIDGetReport - Could not getReport, error: &quot;, result);
    }
    else
      HIDREPORTERROR (&quot;HIDGetReport - no interface for device.&quot;);
    }
    else
        HIDREPORTERROR (&quot;HIDGetReport - invalid device.&quot;);

    return result;
}

// ---------------------------------
// Send a report to a device
long HIDSetReport (pRecDevice pDevice,const IOHIDReportType reportType, const UInt32 reportID, void* reportBuffer, const UInt32 reportBufferSize)
{
    IOReturn result = kIOReturnError;  // assume failure (pessimist!)

    if (HIDIsValidDevice(pDevice))
    {
    if (NULL != pDevice-&gt;interface)
    {
      result = (*(IOHIDDeviceInterface**) pDevice-&gt;interface)-&gt;setReport (pDevice-&gt;interface, reportType, reportID, reportBuffer, reportBufferSize, -1, nil, nil, nil);
      if (kIOReturnSuccess != result)
        HIDREPORTERRORNUM (&quot;HIDGetReport - Could not setReport; error: &quot;, result);
    }
    else
      HIDREPORTERROR (&quot;HIDGetReport - no interface for device.&quot;);
    }
    else
        HIDREPORTERROR (&quot;HIDGetReport - invalid device.&quot;);

    return result;
}
#endif</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/HID_Utilities_Source/listing8.html%3Fid%3DDTS10000445-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/HID_Utilities_Source/listing8.html%3Fid%3DDTS10000445-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/HID_Utilities_Source/listing8.html%3Fid%3DDTS10000445-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>