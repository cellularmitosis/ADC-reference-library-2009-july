<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Concordia - /DrawTkl.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">Concordia</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Concordia</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/DrawTkl.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ChooseTkl.c</option>
<option value="listing2.html">/ChooseTkl.h</option>
<option value="listing3.html">/Concordia.c</option>
<option value="listing4.html">/Concordia.h</option>
<option value="listing5.html">/Concordia.r</option>
<option value="listing6.html">/DrawTkl.c</option>
<option value="listing7.html">/DrawTkl.h</option>
<option value="listing8.html">/PopUpTkl.c</option>
<option value="listing9.html">/PopUpTkl.h</option>
<option value="listing10.html">/SizeTkl.c</option>
<option value="listing11.html">/SizeTkl.h</option></select>
				</p>
				</form>
				<p><strong><a href="Concordia.zip">Download Sample</a></strong> (&#147;Concordia.zip&#148;, 35.8K)<BR>
<strong><a href="Concordia.dmg">Download Sample</a></strong> (&#147;Concordia.dmg&#148;, 94.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    DrawTkl.c  Contains:  the code to process the mDrawMsg message from the Menu        Manager.  This source file contains the routines to do ALL drawing, including        the scroll icons.  Written by:     Copyright:  Copyright &copy; 1991-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/10/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        *//******************************************************************************\* Header Files\******************************************************************************/#include &lt;Memory.h&gt;#include &lt;Menus.h&gt;#include &lt;Resources.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Icons.h&gt;#include &lt;Types.h&gt;#include &quot;Concordia.h&quot;#include &quot;DrawTkl.h&quot;#include &quot;SizeTkl.h&quot;/******************************************************************************\* Constants &amp; Macros\******************************************************************************/#define scrlSICNID -12288 //Resource ID of scroll arrows SICN/******************************************************************************\* Type Declarations\******************************************************************************//* Small icon data */typedef Byte SICNData [32];/******************************************************************************\* Function Prototypes\******************************************************************************/void DimRect (Rect *);void DrawSICN (SICNData **, short, short, short);void DrawICON (Handle, Rect *);#pragma segment Main/******************************************************************************\* DoDrawMsg - Draw a menu** DoDrawMsg draws the menu specified by TheMenu.  The rectangle in global coord-* inates that the menu occupies is specified in MenuRect.  If the system global* TopMenuItem is not equal to the top coordinate of MenuRect, a top scroll bar* is drawn.  If the menu extends below the bottom of MenuRect, a bottom scroll* bar is drawn.  The Menu Manager (I guess) sets TopMenuItem properly for pull-* down menus, while the popup menu tackler (DoPopupMsg) sets TopMenuItem* properly for popup menus.  DoDrawMsg sets the system global AtMenuBottom to* the bottom of the entire menu, regardless of whether it fits on the screen or* not.** Coding Notes* #A# - The sole purpose of this loop is to find the total height of the menu in *       pixels ignoring the size of the screen.  Seems like kind of a waste,*       doesn't it?* #B# - The clip rectangle, MenuClip is only set if the menu has scroll icons.*       This is determined here.* #C# - This loop draws each of the menu items.* #D# - Side-effect: system global AtMenuBottom set to coordinate of bottom of*       Menu regardless of whether the menu fits or not.* #E# - We don't need the menuEnabled bit any more so get rid of it by shifting*       it out.  Then we have to set the high bit so that all items beyond the*       31st will be enabled.  With arithmetic right shifting, this high bit*       will be preserved.\******************************************************************************/voidDoDrawMsg (TheMenu, MenuRect)  MenuHandle TheMenu;   //=&gt; Menu to draw &gt;&gt;  Rect       *MenuRect; //-&gt; Menu's rectangle in global coords &gt;&gt;  {  Str255      *ItemString; //-&gt; Menu item's string  ItemInfoPtr ItemInfo;    //-&gt; Item info  Rect        ItemRect;    //Item's rectangle  Rect        TotMenuRect; //Menu's rectangle w/o clipping to screen  RgnHandle   SaveClip;    //=&gt; Saved clip region  Rect        MenuClip;    //Clip region of menu if menu scrolls  long        EnableFlags; //Menu's enable flags  SaveClip = (RgnHandle) null;  if ((**TheMenu).enableFlags &amp; 1)    {    EnableFlags = (unsigned long) (**TheMenu).enableFlags &gt;&gt; 1; //#E#    EnableFlags |= 0x80000000;    }  else    EnableFlags = 0;  SetRect (&amp;TotMenuRect, MenuRect-&gt;left, sgTopMenuItem, MenuRect-&gt;right,      sgTopMenuItem);  HLock ((Handle) TheMenu);  ItemString = (Str255 *) (**TheMenu).menuData;  ItemString = (Str255 *) ((Byte *) ItemString + strSize (*ItemString));  while ((*ItemString) [0] != (char) 0) //#A#    {    ItemInfo = (ItemInfoPtr) ((Byte *) *ItemString + strSize (*ItemString));    TotMenuRect.bottom += CalcItemHeight (*ItemString, ItemInfo);    ItemString = (Str255 *) (ItemInfo + 1);    }  HUnlock ((Handle) TheMenu);  MenuClip = *MenuRect;  if (TotMenuRect.top != MenuRect-&gt;top || TotMenuRect.bottom != MenuRect-&gt;      bottom) //#B#    {    if (TotMenuRect.top != MenuRect-&gt;top)      {      DrawScroll (MenuRect, topScroll);      MenuClip.top += scrlIconHeight;      }    if (TotMenuRect.bottom != MenuRect-&gt;bottom)      {      DrawScroll (MenuRect, botScroll);      MenuClip.bottom -= scrlIconHeight;      }    SaveClip = NewRgn ();    GetClip (SaveClip);    ClipRect (&amp;MenuClip);    }  HLock ((Handle) TheMenu);  ItemString = (Str255 *) (**TheMenu).menuData;  ItemString = (Str255 *) ((Byte *) ItemString + strSize (*ItemString));  ItemRect = TotMenuRect;  ItemRect.bottom = ItemRect.top;  while ((*ItemString) [0] != (char) 0) //#C#    {    ItemInfo = (ItemInfoPtr) ((Byte *) *ItemString + strSize (*ItemString));    ItemRect.bottom += CalcItemHeight (*ItemString, ItemInfo);    if (ItemRect.bottom &gt; MenuClip.top &amp;&amp; ItemRect.top &lt; MenuClip.bottom)      DrawItem (*ItemString, ItemInfo, &amp;ItemRect, (short) (EnableFlags &amp;          1));    ItemString = (Str255 *) (ItemInfo + 1);    ItemRect.top = ItemRect.bottom;    EnableFlags &gt;&gt;= 1;    }  HUnlock ((Handle) TheMenu);  if (SaveClip != (RgnHandle) null)    {    SetClip (SaveClip);    DisposeRgn (SaveClip);    }  sgAtMenuBottom = TotMenuRect.bottom; //#D#  *((short *) ((*sgMBSaveLoc) + 16)) = 1;  }#pragma segment Main/******************************************************************************\* DrawItem - Draw a menu item** DrawItem draws a menu item whose text is specified by ItemString and whose* item information is specified by ItemData.  The rectangle that the item* occupies on the screen is specified by ItemRect.  If the item is enabled,* Enabled must be true, otherwise it must be false.  DrawItem also draws mark* characters (like check marks); big, scaled, and disabled icons, dims items if* they're not enabled, and draws gray lines if the item string begins with a* hyphen.  Any command key characters that aren't printable are ignored.  If the* specified item icon can't be found, it is not drawn (of course), but space is* left for it.** Coding Notes:* #A# - This calculation figures out the proper vertical coordinate to begin*       drawing the item string so that it's centered vertically in ItemRect.* #B# - Draw the mark character unless this is a hierarchical menu item.* #C# - Draw the command-key equivalent* #E# - Draw the item icon* #F# - With these command-key equivalents, icons are half their size.* #G# - If couldn't load icon, ignore drawing and continue* #H# - With this command-key equivalent, icon is dimmed.* #I# - These values will be used to set the location of the item string.\******************************************************************************/voidDrawItem (Str255 ItemString,ItemInfoPtr ItemData,Rect* ItemRect,short Enabled){  short        HorzPos;   //Horizontal position to draw item  short        VertPos;   //Vertical position to draw item  short        MarkWidth; //Width of item mark  Handle       ItemIcon;  //=&gt; Item's icon  Rect         IconRect;  //Rectangle of icon  short        IconSize;  //Size of icon in pixels  FontInfo     CurrFont;  //Current font's characteristics  PenState     CurrPen;   //Current characteristics of graphics pen  short        CurrFile;  //Refnum of current resource file  SICNData     **SICNRes; //=&gt; SICN resource  TextStateRec TextState; //Current characteristics of text drawing  GetPenState (&amp;CurrPen);  if (ItemString [1] == '-')    {    PenSize (1, 1);    PenMode (patOr);    PenPat (&amp;qd.gray);    MoveTo (ItemRect-&gt;left, ItemRect-&gt;top + ItemRect-&gt;bottom &gt;&gt; 1);    Line (ItemRect-&gt;right - ItemRect-&gt;left, 0);    }  else    {    PenMode (patOr);    GetTextState (&amp;TextState);    TextFace (normal);    TextMode (srcOr);    GetFontInfo (&amp;CurrFont);    MarkWidth = CurrFont.widMax;    if (ItemData-&gt;markChar != '\0' || ItemData-&gt;kbdEquiv != '\0')      {      VertPos = ((short) ((ItemRect-&gt;bottom - ItemRect-&gt;top) - (CurrFont.          ascent + CurrFont.descent + CurrFont.leading) &gt;&gt; 1) +          CurrFont.ascent + ItemRect-&gt;top); //#A#      if (ItemData-&gt;markChar != (char) 0 &amp;&amp; ItemData-&gt;kbdEquiv !=          hMenuCmd) //#B#        {        HorzPos = ItemRect-&gt;left + itemHorzMarg;        MoveTo (HorzPos, VertPos);        DrawChar (ItemData-&gt;markChar);        }      if (ItemData-&gt;kbdEquiv &gt; '!') //#C#        {        HorzPos = ItemRect-&gt;right - itemHorzMarg -            CurrFont.widMax - CharWidth (cmmdCharCode);        MoveTo (HorzPos, VertPos);        DrawChar (cmmdCharCode);        DrawChar (ItemData-&gt;kbdEquiv);        }      else if (ItemData-&gt;kbdEquiv == hMenuCmd)        {        HorzPos = ItemRect-&gt;right - sicnSize;        VertPos = (short) ((ItemRect-&gt;bottom - ItemRect-&gt;top - (short)            sicnSize) &gt;&gt; 1) + ItemRect-&gt;top;        CurrFile = CurResFile ();        UseResFile (0);        if ((SICNRes = (SICNData **) Get1Resource ('SICN', scrlSICNID))            != (SICNData **) null)          DrawSICN (SICNRes, heirArrow, HorzPos, VertPos);        UseResFile (CurrFile);        }      }    if (ItemData-&gt;iconNum != (Byte) 0) //#E#      {      IconSize = iconSize;      if (ItemData-&gt;kbdEquiv == (char) 0x1D || ItemData-&gt;kbdEquiv ==          (char) 0x1F) //#F#        IconSize &gt;&gt;= 1;      if ((ItemIcon = GetIcon (ItemData-&gt;iconNum + 256)) != (Handle) null) //#G#        {        IconRect.top = (ItemRect-&gt;bottom - ItemRect-&gt;top -            IconSize &gt;&gt; 1) + ItemRect-&gt;top;        IconRect.left = ItemRect-&gt;left + itemHorzMarg + MarkWidth +            markItemGap;        IconRect.bottom = IconRect.top + IconSize;        IconRect.right = IconRect.left + IconSize;        DrawICON (ItemIcon, &amp;IconRect);        if (ItemData-&gt;kbdEquiv == (char) 0x1F) //#H#          DimRect (&amp;IconRect);        }      IconSize += iconItemGap; //#I#      }    else      IconSize = 0; //#I#    TextFace (ItemData-&gt;charStyle);    GetFontInfo (&amp;CurrFont);    VertPos = (short) ((ItemRect-&gt;bottom - ItemRect-&gt;top) - (CurrFont.        ascent + CurrFont.descent + CurrFont.leading) &gt;&gt; 1) + CurrFont.        ascent + ItemRect-&gt;top;    HorzPos = ItemRect-&gt;left + itemHorzMarg + MarkWidth + markItemGap +        IconSize;    MoveTo (HorzPos, VertPos);    DrawString (ItemString);    SetTextState (&amp;TextState);    if (! Enabled)      DimRect (ItemRect);    }  SetPenState (&amp;CurrPen);  }#pragma segment Main/******************************************************************************\* DimRect - Dim a rectangle** DimRect dims the rectangle specified by ItemRect by bit-clearing it with a* medium gray pattern.  Normally, we could do this just by drawing over the item* with the standard gray pattern, but there's a problem: what if the menu has* scrolled an odd number of pixels and we have to draw part of a dimmed menu* item?  We'll end up with the gray pattern that's out of phase with the part of* the menu item that was already drawn.  To solve this, DimRect creates its own* pattern &quot;on the fly&quot; in GrayPat.  Two gray patterns can be created, each one* being out of out of phase with the other by one pixel.  The particular pattern* is chosen by checking to see whether the system global, TopMenuItem, is odd or* even.  The current pen state is unchanged.\******************************************************************************/static voidDimRect (TheRect)  Rect *TheRect; //-&gt; Rectangle to dim &gt;&gt;  {  PenState CurrPen;     //Current characteristics of graphics pen  short    PatElem;     //Pattern element  short    GrayPat [4]; //Gray pattern (not 8 bytes 'cause it's easier here  short    PatInd;      //Index into pattern array  GetPenState (&amp;CurrPen);  PenMode (patBic);  if ((sgTopMenuItem &amp; 0x0001) == 0)    PatElem = (short) 0xAA55;  else    PatElem = (short) 0x55AA;  for (PatInd = 0; PatInd &lt; 4; PatInd++)    GrayPat [PatInd] = PatElem;  PenPat ((Pattern*) GrayPat);  PaintRect (TheRect);  SetPenState (&amp;CurrPen);  }#pragma segment Main/******************************************************************************\* DrawScroll - Draw a scroll arrow** DrawScroll draws a top scroll arrow if Which is topScroll, and it draws a* bottom scroll arrow if which is botScroll.  The menu's rectangle must be* specified in MenuRect.\******************************************************************************/voidDrawScroll (Rect* MenuRect,short Which){  SICNData **SICNRes; //=&gt; SICN resource  short    HorzPos;   //Horizontal position of icon  short    VertPos;   //Vertical position of icon  Rect     ScrlRect;  //Rectangle of scroll icon area  PenState CurrPen;   //Current pen state  short    CurrFile;  //Current resource file's refnum  HorzPos = (short) ((MenuRect-&gt;right - MenuRect-&gt;left - sicnSize) &gt;&gt; 1) +      MenuRect-&gt;left;  ScrlRect = *MenuRect;  GetPenState (&amp;CurrPen);  PenPat (&amp;qd.black);  PenMode (patCopy);  PenSize (1, 1);  if (Which == topScroll)    {    ScrlRect.bottom = ScrlRect.top + scrlIconHeight;    EraseRect (&amp;ScrlRect);    MoveTo (MenuRect-&gt;left, MenuRect-&gt;top + scrlIconHeight - 1);    Line (MenuRect-&gt;right - MenuRect-&gt;left, 0);    VertPos = MenuRect-&gt;top + 1;    }  else    {    ScrlRect.top = ScrlRect.bottom - scrlIconHeight;    EraseRect (&amp;ScrlRect);    MoveTo (MenuRect-&gt;left, MenuRect-&gt;bottom - scrlIconHeight);    Line (MenuRect-&gt;right - MenuRect-&gt;left, 0);    VertPos = MenuRect-&gt;bottom - 1 - sicnSize;    }  PenMode (patOr);  CurrFile = CurResFile ();  UseResFile (0);  if ((SICNRes = (SICNData **) Get1Resource ('SICN', scrlSICNID)) !=      (SICNData **) null)    DrawSICN (SICNRes, Which, HorzPos, VertPos);  UseResFile (CurrFile);  SetPenState (&amp;CurrPen);  }#pragma segment Main/******************************************************************************\* DrawSICN - Draw a small icon** DrawSICN draws the small icon specified by TheIcon into the current port.* Each SICNData can hold any number of SICNs, so Index specifies which SICN to* draw, 0 specifying the first.  HorzPos and VertPos specify the horizontal and* vertical position to draw the top-left corner of the icon in local* coordinates.  If TheIcon doesn't specify a SICN or if Index is out of range,* garbage will be drawn.  The transfer mode will be the equivalent of the* current pen mode of the current port.  For example, if the current pen mode is* patXor, the SICN will be drawn in srcXor mode.\******************************************************************************/static voidDrawSICN (SICNData** TheIcon,short Index,short HorzPos,short VertPos){  BitMap  IconBits;  //Bitmap for icon  GrafPtr CurrPort;  //-&gt; Current GrafPort  Rect    SICNRect;  //Rectangle to draw icon into  short   TransMode; //Transfer mode to use  HLock ((Handle) TheIcon);  SetRect (&amp;IconBits.bounds, 0, 0, sicnSize, sicnSize);  IconBits.rowBytes = 2;  IconBits.baseAddr = (Ptr) (*TheIcon + Index);  SetRect (&amp;SICNRect, HorzPos, VertPos, HorzPos + sicnSize, VertPos +      sicnSize);  GetPort (&amp;CurrPort);  if (CurrPort-&gt;pnMode == patCopy || CurrPort-&gt;pnMode == notPatCopy)    TransMode = srcCopy;  else if (CurrPort-&gt;pnMode == patOr || CurrPort-&gt;pnMode == notPatOr)    TransMode = srcOr;  else if (CurrPort-&gt;pnMode == patXor || CurrPort-&gt;pnMode == notPatXor)    TransMode = srcXor;  else if (CurrPort-&gt;pnMode == patBic || CurrPort-&gt;pnMode == notPatBic)    TransMode = srcBic;  CopyBits (&amp;IconBits, &amp;CurrPort-&gt;portBits, &amp;IconBits.bounds, &amp;SICNRect,      TransMode, (RgnHandle) null);  HUnlock ((Handle) TheIcon);  }#pragma segment Main/******************************************************************************\* DrawICON - Draw an icon** DrawICON draws the icon specified by TheIcon into the current port.  IconRect* specifies the size and location to draw the icon in local coordinates.  If* TheIcon doesn't specify an ICON, garbage will be drawn.  The transfer mode* will be the equivalent of the current pen mode of the current port.  For* example, if the current pen mode is patXor, the ICON will be drawn in srcXor* mode.\******************************************************************************/static voidDrawICON (TheIcon, IconRect)  Handle TheIcon; //=&gt; Icon data &gt;&gt;  Rect   *IconRect; //-&gt; Rectangle to draw icon into &gt;&gt;  {  BitMap  IconBits;  //Bitmap for icon  GrafPtr CurrPort;  //-&gt; Current GrafPort  short   TransMode; //Transfer mode to use  HLock (TheIcon);  SetRect (&amp;IconBits.bounds, 0, 0, iconSize, iconSize);  IconBits.rowBytes = 4;  IconBits.baseAddr = *TheIcon;  GetPort (&amp;CurrPort);  if (CurrPort-&gt;pnMode == patCopy || CurrPort-&gt;pnMode == notPatCopy)    TransMode = srcCopy;  else if (CurrPort-&gt;pnMode == patOr || CurrPort-&gt;pnMode == notPatOr)    TransMode = srcOr;  else if (CurrPort-&gt;pnMode == patXor || CurrPort-&gt;pnMode == notPatXor)    TransMode = srcXor;  else if (CurrPort-&gt;pnMode == patBic || CurrPort-&gt;pnMode == notPatBic)    TransMode = srcBic;  CopyBits (&amp;IconBits, &amp;CurrPort-&gt;portBits, &amp;IconBits.bounds, IconRect,      TransMode, (RgnHandle) null);  HUnlock (TheIcon);  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Concordia/listing6.html%3Fid%3DDTS10000181-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Concordia/listing6.html%3Fid%3DDTS10000181-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Concordia/listing6.html%3Fid%3DDTS10000181-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>