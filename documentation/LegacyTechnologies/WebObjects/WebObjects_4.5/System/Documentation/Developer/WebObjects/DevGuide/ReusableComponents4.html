<html><head><title>Creating Reusable Components</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>WebObjects Developer's Guide</font><br><br><!--end of path --> <hr> <a href="ReuseTOC.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="ReusableComponents3.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="873"><h2> Synchronizing Attributes in Parent and Child &#32;Components</h2></a><a name="902">Because WebObjects treats attribute bindings between parent and child components as potentially two-way communication paths, it synchronizes the values of the bound variables at strategic times during the component action request-response loop. This synchronization mechanism has some implications for how you design components. Also, you can disable synchronization for the component action request-response loop as described in <a href="ReusableComponents5.html#4163">"Disabling Component Synchronization"</a>.<p></a><a name="904">For the sake of illustration, consider a page that displays a value in two different text fields-one provided by the parent component and one by the child (see <a href="ReusableComponents4.html#919">Figure &#32;35</a>).<p></a><a name="903"><p><img src="ReusableComponents4.gif"><p></a><a name="919"><p>Figure 35.	  Synchronized Components<p></a><a name="905">Setting the value of either text field and submitting the change causes the new value to appear in both text fields.<p></a><a name="909">The parent's declarations file reveals the binding between the two components:<p></a><pre><a name="911">CHILDCOMPONENT: ChildComponent {<br>		childValue=parentValue;<br>};</a></pre><a name="1011">When a value is entered in a field and the change submitted, WebObjects will, if needed, synchronize the value in the parent (<strong>parentValue</strong>) and child (<strong>childValue</strong>) at each of the three stages of the component action request-response loop:<p></a><ul><a name="1017"><li>Before and after the components receive the <strong>takeValuesFromRequest:inContext:</strong> message.</a><a name="1018"><li>Before and after the components receive the<strong> invokeActionForRequest:inContext:</strong> message.</a><a name="1019"><li>Before and after the components receive the <strong>appendToResponse:inContext:</strong> message.</a></ul><a name="3461">To synchronize values, WebObjects uses key-value coding, a standard interface for accessing an object's properties either through methods designed for that purpose or directly through its instance variables. <br>Key-value coding always first attempts to set properties through accessor methods, reverting to accessing the instance variables directly only if the required accessor method is missing. <p></a><a name="3462">Given that synchronization occurs several times during each cycle of the request-response loop and that key-value coding is used to accomplish this synchronization, how does this affect the design of reusable component? It has these implications:<p></a><ul><a name="1022"><p><li>You rarely need to implement accessor methods for your component's instance variables. </a><a name="3711"><p>For instance, it's sufficient in the example shown in <a href="ReusableComponents4.html#919">Figure &#32;35</a> to &#32;simply declare a <strong>childValue</strong> instance variable in the child component and a <strong>parentValue</strong> instance variable in the parent. You &#32;need to implement accessor methods (such as <strong>setChildValue:</strong> and <strong>childValue</strong>) only if the component must do some calculation (say, determine how long the application has been running) before returning the value.<p></a><a name="1023"><p><li>If you do provide accessor methods, they should have no unwanted side effects and should be implemented as efficiently as possible since they will be invoked several times in a request-response loop cycle.</a><a name="1024"><p><li>If you bind a component's attribute to a method rather than to an instance variable, you must provide both accessor methods: one to set the value and one to return it. This is only the case if no instance variable exists, and does not apply to actions.</a><a name="3717"><p>Let's say the parent component in the example shown in <a href="ReusableComponents4.html#919">Figure &#32;35</a> doesn't have a discrete <strong>parentValue</strong> instance variable but &#32;instead stores the value in some other way (for example, as an &#32;entry in a dictionary object). In that case, the parent component must provide both a <strong>parentValue</strong> method (to retrieve the value) and a <strong>setParentValue:</strong> method (to set it). During synchronization, WebObjects expects both methods to be present and will raise an exception if one is missing.<p></a></ul><P> <a href="ReuseTOC.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="ReusableComponents5.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>