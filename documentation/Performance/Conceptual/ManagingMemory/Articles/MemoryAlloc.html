<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Memory Usage Performance Guidelines: Optimizing Your Memory Allocations</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Optimizing Your Memory Allocations"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001881" title="Optimizing Your Memory Allocations"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../DeveloperTools/index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../../DeveloperTools/Performance-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000901" target="_top">Performance</a> &gt; <a href="../index.html" target="_top">Memory Usage Performance Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="AboutMemory.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="FindingPatterns.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20001881-CJBCFDGA" title="Optimizing Your Memory Allocations"></a><hr /><H1>Optimizing Your Memory Allocations</H1><p>Memory is an important resource for your application so it’s important to take the time to examine your application’s memory allocation patterns and make changes as necessary. </p><p>You can gather a history of your allocations using the Sampler program or using the <code>malloc_history</code> command-line tool. For more information on analyzing your memory usage, see <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-CJBJFIDD">“Examining Memory Allocation Patterns.”</a></span> </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="MemoryAlloc.html#//apple_ref/doc/uid/20001881-99063">Memory Allocation in Mac OS X</a>
				
			<br/>
			
        
			
			
				<a href="MemoryAlloc.html#//apple_ref/doc/uid/20001881-122425">Tips for Allocating Memory</a>
				
			<br/>
			
        
			
			
				<a href="MemoryAlloc.html#//apple_ref/doc/uid/20001881-107791">Copying Memory</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001881-99063" title="Memory Allocation in Mac OS X"></a><h2>Memory Allocation in Mac OS X</h2><p><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_133"></a>Mac OS X implements a highly-tuned, threadsafe allocation library, providing standard implementations of the <code>malloc</code>,<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_134"></a><code>calloc</code>, <a name="//apple_ref/doc/uid/20001881-DontLinkElementID_135"></a><code>realloc</code>, and <a name="//apple_ref/doc/uid/20001881-DontLinkElementID_136"></a><code>free</code> routines, among others. If you are allocating memory using older routines such as <code>NewPtr</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_137"></a> or <code>NewHandle</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_138"></a>, you should change your code to use <code>malloc</code> instead. The end result is the same since most legacy routines are now wrappers for <code>malloc</code> anyway.</p><p>If you are using a custom <code>malloc</code> implementation, you should consider moving to the system-supplied <code>malloc</code> routines. The Mac OS X <code>malloc</code> implementation is highly optimized and fully supports the Apple-provided memory analysis tools. Moving to Apple’s implementation not only gains you the ability to analyze your memory, it lets you remove your custom code from your executable, thus reducing your application footprint.</p><p>The following sections provide some details on how the Mac OS X allocation library handles large and small allocations. This information can help you identify the costs associated with each type of allocation. Note that although the following sections talk about the behaviors of the <code>malloc</code> routine, those behaviors also apply to routines such as <code>calloc</code> and <code>realloc</code>. </p><a name="//apple_ref/doc/uid/20001881-99117" title="Allocating Small Memory Blocks"></a><h3>Allocating Small Memory Blocks</h3><p>For allocations of less than a few virtual memory pages, <code>malloc</code> suballocates the requested amount from a list (or “pool”) of free blocks of increasing size. Any small blocks you deallocate using the <code>free</code> routine are added back to the pool and reused on a “best fit” basis. The memory pool is itself is comprised of several virtual memory pages and allocated using the <code>vm_allocate</code> routine. </p><p>The granularity<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_139"></a> of any block returned by <code>malloc</code> is 16 bytes. Any blocks you allocate will be at least 16 bytes in size or comprised of a block that is a multiple of 16. Thus, if you request 4 bytes, <code>malloc</code> returns a block of 16 bytes. If you request 24 bytes, <code>malloc</code> returns a block of 32 bytes. </p><div class="notebox"><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_8" title="Note"></a><p><strong>Note:</strong>&nbsp;By their nature, allocations smaller than a single virtual memory page in size cannot be page aligned. </p></div><a name="//apple_ref/doc/uid/20001881-99765" title="Allocating Large Memory Blocks"></a><h3>Allocating Large Memory Blocks</h3><p>For allocations greater than a few virtual memory pages, <code>malloc</code> uses the <code>vm_allocate</code> routine to obtain a block of the requested size.The <code>vm_allocate</code> routine assigns an address range to the new block in the virtual memory space of the current process but does not allocate any physical memory. Instead, the <code>malloc</code> routine pages in the memory for the allocated block as it is used.</p><p>The granularity<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_140"></a> of large memory blocks is 4096 bytes, the size of a virtual memory page. If you are allocating a large memory buffer, you should consider making it a multiple of this size. </p><div class="notebox"><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_9" title="Note"></a><p><strong>Note:</strong>&nbsp;Large memory allocations are guaranteed to be page-aligned. </p></div><p>For large allocations, you may find that it makes sense to allocate virtual memory using <code>vm_allocate</code> directly. The example in <span class="content_text"><a href="MemoryAlloc.html#//apple_ref/doc/uid/20001881-97272-CJBGFHDA">Listing 1</a></span> shows how to use the <code>vm_allocate</code> function.</p><a name="//apple_ref/doc/uid/20001881-97272-CJBGFHDA" title="Listing 1Allocating memory with vm_allocate"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001881-97272" title="Listing 1Allocating memory with vm_allocate"></a><strong>Listing 1&nbsp;&nbsp;</strong>Allocating memory with vm_allocate</p><div class="codesample"><table><tr><td scope="row"><pre>void* AllocateVirtualMemory(size_t size)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    char*          data;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   err;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // In debug builds, check that we have<span></span></pre></td></tr><tr><td scope="row"><pre>    // correct VM page alignment<span></span></pre></td></tr><tr><td scope="row"><pre>    check(size != 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    check((size % 4096) == 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Allocate directly from VM<span></span></pre></td></tr><tr><td scope="row"><pre>    err = vm_allocate(  (vm_map_t) mach_task_self(),<span></span></pre></td></tr><tr><td scope="row"><pre>                        (vm_address_t*) &amp;data,<span></span></pre></td></tr><tr><td scope="row"><pre>                        size,<span></span></pre></td></tr><tr><td scope="row"><pre>                        VM_FLAGS_ANYWHERE);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Check errors<span></span></pre></td></tr><tr><td scope="row"><pre>    check(err == KERN_SUCCESS);<span></span></pre></td></tr><tr><td scope="row"><pre>    if(err != KERN_SUCCESS)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        data = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return data;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/20001881-122762" title="Allocating Memory in Batches "></a><h3>Allocating Memory in Batches </h3><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_141"></a><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_142"></a><p>If your code allocates multiple, identically-sized memory blocks, you can use the <code>malloc_zone_batch_malloc</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_143"></a> function to allocate those blocks all at once. This function offers better performance than the equivalent series of calls to <code>malloc</code> to allocate the same memory. Performance is best when the individual block size is relatively small—less than 4K in size. The function does its best to allocate all of the requested memory but may return less than was requested. When using this function, check the return values carefully to see how many blocks were actually allocated.</p><p>Batch allocation of memory blocks is supported in Mac OS X version 10.3 and later. For information, see the <code>/usr/include/malloc/malloc.h</code> header file. </p><a name="//apple_ref/doc/uid/20001881-99932" title="About Memory Zones"></a><a name="//apple_ref/doc/uid/20001881-99932-CJBEAJHF" title="About Memory Zones"></a><h3>About Memory Zones</h3><p>A <strong>zone</strong><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_144"></a><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_145"></a> is a variable-size range of virtual memory from which <code>malloc</code> allocates blocks. All allocations made using the <code>malloc</code> function occur within the standard malloc zone, which is created when <code>malloc</code> is first called by your application. You can create additional malloc zones and allocate memory in a specific zone.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_10" title="Note"></a><p><strong>Note:</strong>&nbsp;The term zone is synonomous with the terms heap<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_146"></a>, pool<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_147"></a>, and arena in terms of memory allocation using the <code>malloc</code> routines. </p></div><p>Zones have the advantage of allowing blocks with similar access patterns or lifetimes to be placed together, theoretically minimizing wasted space or paging activity. You can allocate many objects in a zone and then destroy the zone to free them all. For most developers, however, zones fail to deliver a performance advantage, and you should avoid them unless you need to either track a set of memory blocks separately from other allocations or free many memory blocks quickly, or you have measured a specific case where zones will help.</p><p>For information on how to use multiple zones in an application, see <span class="content_text"><a href="MemoryAlloc.html#//apple_ref/doc/uid/20001881-100720">“Using Multiple Malloc Zones”</a></span><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_148"></a></p><a name="//apple_ref/doc/uid/20001881-122425" title="Tips for Allocating Memory"></a><h2>Tips for Allocating Memory</h2><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_149"></a><p>When it comes time to allocate memory for your program, there are other considerations you should make. The following sections provide guidelines on when and how to allocate memory. </p><a name="//apple_ref/doc/uid/20001881-100651" title="Deferring Memory Allocations"></a><a name="//apple_ref/doc/uid/20001881-100651-BAJJEJFA" title="Deferring Memory Allocations"></a><h3>Deferring Memory Allocations</h3><p><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_150"></a>Every memory allocation has a performance cost. That cost<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_151"></a> is measured by the time it takes to allocate the memory and the space occupied by the memory. If you do not need a particular block of memory right away, you should consider deferring its allocation until the first time you actually need it. Once allocated, you can then use it and delete it or cache it for later use.</p><p>Applications often allocate memory during initialization and then use that memory later—or sometimes not at all during a given session. Not only does this cause the application to pay an up-front cost for allocating the memory but it does so needlessly. You can easily improve on this costly approach by deferring the allocation to the first time the memory is needed. </p><p>For most operations, you can easily arrange your code to use a block of memory right after you allocate it. But if your application uses global variables, you need another way to ensure the memory is there when you need it, but not before. To accomplish this with a minimum of code modification, do the following: </p><ul class="spaceabove"><li class="li"><p>Turn any global variables into static variables so that they are inaccessible to other code modules.</p></li><li class="li"><p>Create a public accessor function to access the static variable and allocate and initialize the buffer for it upon the first invocation.</p></li></ul><p><span class="content_text"><a href="MemoryAlloc.html#//apple_ref/doc/uid/20001881-98185-BAJDJBEH">Listing 2</a></span> gives an example of this technique. Code modules that want to access the global buffer call the function to access the pointer.<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_152"></a><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_153"></a></p><a name="//apple_ref/doc/uid/20001881-98185-BAJDJBEH" title="Listing 2Lazy allocation of memory through an accessor"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001881-98185" title="Listing 2Lazy allocation of memory through an accessor"></a><strong>Listing 2&nbsp;&nbsp;</strong>Lazy allocation of memory through an accessor</p><div class="codesample"><table><tr><td scope="row"><pre>MyGlobalInfo* GetGlobalBuffer()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    static MyGlobalInfo* sGlobalBuffer = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( sGlobalBuffer == NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            sGlobalBuffer = malloc( sizeof( MyGlobalInfo ) );<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        return sGlobalBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_11" title="Note"></a><p><strong>Note:</strong>&nbsp;This code is not safe in the presence of multiple threads<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_154"></a>. More than one thread could call this function simultaneously, causing the memory to be allocated more than once. To make it threadsafe, add a semaphore lock around the <code>if</code> statement and any required initialization code.</p></div><a name="//apple_ref/doc/uid/20001881-98355" title="Initializing Memory"></a><h3>Initializing Memory</h3><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_155"></a><p>Memory allocated using <code>malloc</code> is not guaranteed to be initialized with zeroes. Instead of using <code>memset</code> to initialize the memory, a better choice is to use the <code>calloc</code> routine to allocate the memory in the first place. </p><p>When you call <code>memset</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_156"></a> right after <code>malloc</code>, the virtual memory system must map the corresponding pages into memory in order to zero-initialize them. This operation can be very expensive and wasteful, especially if you do not use the pages right away. </p><p>The <code>calloc</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_157"></a> routine reserves the required virtual address space for the memory but waits until the memory is actually used before initializing it. This approach alleviates the need to map the pages into memory right away. It also lets the system initialize pages as they’re used, as opposed to all at once. </p><a name="//apple_ref/doc/uid/20001881-100720" title="Using Multiple Malloc Zones"></a><a name="//apple_ref/doc/uid/20001881-100720-BCIDIEII" title="Using Multiple Malloc Zones"></a><h3>Using Multiple Malloc Zones</h3><p>All <a name="//apple_ref/doc/uid/20001881-DontLinkElementID_158"></a>memory blocks are contained within a <a name="//apple_ref/doc/uid/20001881-DontLinkElementID_159"></a>malloc zone<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_160"></a><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_161"></a> (also referred to as a malloc heap). All allocations made by <code>malloc</code> function occur within the default malloc zone of the current process, which is created when <code>malloc</code> is first called. Although it is generally not recommended, you can create additional zones if measurements show there to be potential performance gains. For example, if the effect of releasing a large number of temporary (and isolated) objects is slowing down your application, you could allocate them in a zone instead and simply deallocate the zone.  </p><p>Basic support for zones is defined in <code>/usr/include/malloc/malloc.h</code>. Use the <code>malloc_create_zone</code> function to create a custom malloc zone or the <code>malloc_default_zone</code> function to get the default zone for your application. To allocate memory in a particular zone, use the <code>malloc_zone_malloc</code> , <code>malloc_zone_calloc</code> , <code>malloc_zone_valloc</code> , or <code>malloc_zone_realloc</code> functions. To release the memory in a custom zone, call <code>malloc_destroy_zone</code>. </p><div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_12" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;You should never deallocate the default zone for your application.  </p><p></p><div class="clear"></div></div><p>If you are a Cocoa developer, you can also use the <code>NSCreateZone</code> function to create a custom malloc zone and the  <code>NSDefaultMallocZone</code> function to get the default zone for your application. To create new objects in a custom zone, use the <code>allocWithZone:</code> class method, which is available to all subclasses of NSObject. If your class does not descend from NSObject, use the <code>NSAllocateObject</code> function to allocate the memory for your new instances. For more information, see the function descriptions in  <em><a href="../../../../Cocoa/Reference/Foundation/ObjC_classic/index.html#//apple_ref/doc/uid/20001091" target="_top">Foundation Framework Reference</a></em>.</p><p>If you are creating objects (or allocating memory blocks) in a custom malloc zone, you can simply free the entire zone when you are done with it, instead of releasing the zone-allocated objects or memory blocks individually. When doing so, be sure your application data structures do not hold references to the memory in the custom zone. Attempting to access memory in a deallocated zone will cause a memory fault and crash your application.  </p><a name="//apple_ref/doc/uid/20001881-107331" title="Cache Temporary Buffers"></a><h3>Cache Temporary Buffers</h3><p>If you have a highly-used function that allocates a large temporary buffer for some calculations, you might want to consider alternative ways to allocate that buffer. Instead of creating a new block of memory each time it’s called, your function could instead cache a buffer initially and reuse that buffer during subsequent invocations. If your function needs a variable buffer space, you can always grow the buffer as needed. For multi-threaded applications, you can attach the buffer pointer to your thread’s context. For single-threaded applications, you can just store the pointer in a global variable. </p><p>Caching buffers eliminates much of the overhead for functions that regularly allocate and free large blocks of memory. However, this technique is only appropriate for functions that are called frequently. Also, you should be careful not to cache too many large buffers. Caching buffers does add to the memory footprint of your application. You should be sure to gather metrics for your program with and without the caches to see which yields better performance. </p><a name="//apple_ref/doc/uid/20001881-102725" title="Release Your Memory"></a><h3>Release Your Memory</h3><p>Finally, keep in mind the importance of releasing (via the <code>free</code> system routine) all memory that you have allocated with <code>malloc</code>, <code>calloc</code>, or <code>realloc</code>.<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_162"></a> Neglecting to release<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_163"></a><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_164"></a>memory causes memory leaks, which have a direct impact on performance. To help track down memory leaks, use the MallocDebug application or the <code>leaks</code> command-line tool. Both of these tools are described in <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-CJBJFIDD">“Examining Memory Allocation Patterns.”</a></span> </p><a name="//apple_ref/doc/uid/20001881-107628" title="Using Handles in Carbon"></a><h3>Using Handles in Carbon</h3><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_165"></a><p>If you have existing code from Mac OS 9 that you are porting<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_166"></a> to Mac OS X, you can achieve some performance gains by simplifying your handle-related code. The benefit offered by handles in Mac OS 9 is no longer relevant in applications built for Mac OS X. In particular, there is no need to compact the memory blocks referenced by handles. As a result, your handles never move and there is no need to lock them when you want to access their contents. </p><p>If you have code that makes calls to <code>HLock</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_167"></a>, <code>HUnlock</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_168"></a>. <code>HSetState</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_169"></a>, or <code>HGetState</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_170"></a>, you can either conditionally compile that code out for Mac OS X or you can remove the code entirely. The only exception to this rule is cases where your code calls the <code>SetHandleSize</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_171"></a> function, which can potentially move a handle if more space is required. If your code needs to access a handle that might be resized at some point, you should lock the handle first. <a name="//apple_ref/doc/uid/20001881-DontLinkElementID_172"></a></p><a name="//apple_ref/doc/uid/20001881-107791" title="Copying Memory"></a><h2>Copying Memory</h2><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_173"></a><p>There are two main approaches to copying memory in Mac OS X: direct and delayed. For most situations, the direct approach offers the best overall performance. However, there are times when using a delayed-copy operation has is benefits. The goal of the following sections is to introduce you to the different approaches for copying memory and the situations when you might use those approaches. </p><a name="//apple_ref/doc/uid/20001881-101380" title="Copying Memory Directly"></a><h3>Copying Memory Directly</h3><p>The direct copying of memory involves using a routine such as <code>memcpy</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_174"></a> or <code>memmove</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_175"></a> to copy bytes from one block to another. Both the source and destination blocks must be resident in memory at the time of the copy. However, these routines are especially suited for the following situations:</p><ul class="spaceabove"><li class="li"><p>the size of the block you want to copy is small (under 16 kilobytes).</p></li><li class="li"><p>you intend to use either the source or destination right away.</p></li><li class="li"><p>the source or destination block is not page aligned.</p></li><li class="li"><p>the source and destination blocks overlap.</p></li></ul><p>If you do not plan to use the source or destination data for some time, performing a direct copy can decrease performance significantly for large memory blocks. Copying the memory directly increases the size of your application’s working set. Whenever you increase your application’s working set, you increase the chances of paging to disk. If you have two direct copies of a large memory block in your working set, you might end up paging them both to disk. When you later access either the source or destination, you would then need to load that data back from disk, which is much more expensive than using <code>vm_copy</code> to perform a delayed copy operation.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;If the source and destination blocks overlap, you should prefer the use of <code>memmove</code> over <code>memcpy</code>. Both implementations handle overlapping blocks correctly in Mac OS X, but the implementation of <code>memcpy</code> is not guaranteed to do so.</p></div><a name="//apple_ref/doc/uid/20001881-106546" title="Delaying Memory Copy Operations"></a><h3>Delaying Memory Copy Operations</h3><p>If you intend to copy many pages worth of memory, but don’t intend to use either the source or destination pages immediately, then you may want to use the <code>vm_copy</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_176"></a> routine. Unlike <code>memmove</code> or <code>memcpy</code>, <code>vm_copy</code> does not touch any real memory. It modifies the virtual memory map to indicate that the destination address range is a copy-on-write version of the source address range. </p><p>The <code>vm_copy</code> routine is more efficient than <code>memcpy</code> in very specific situations. Specifically, it is more efficient in cases where your code does not access either the source or destination memory for a fairly large period of time after the copy operation. The reason that <code>vm_copy</code> is effective for delayed usage is the way the kernel handles the copy-on-write case. In order to perform the copy operation, the kernel must remove all references to the source pages from the virtual memory system. The next time a process accesses data on that source page, a soft fault occurs, and the kernel maps the page back into the process space as a copy-on-write page. The process of handling a single soft fault is almost as expensive as copying the data directly.</p><a name="//apple_ref/doc/uid/20001881-106593" title="Copying Small Amounts of Data"></a><h3>Copying Small Amounts of Data</h3><p>If you need to copy a small blocks of non-overlapping data, you should prefer <code>memcpy</code> over any other routines. For small blocks of memory, the GCC compiler can optimize out this routine and replace it with inline instructions to copy the data by value. The compiler may not optimize out other routines such as <code>memmove</code> or <code>BlockMoveData</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_177"></a>. </p><a name="//apple_ref/doc/uid/20001881-106612" title="Copying Data to Video RAM"></a><h3>Copying Data to Video RAM</h3><p>When copying data into VRAM<a name="//apple_ref/doc/uid/20001881-DontLinkElementID_178"></a>, use the <code>BlockMoveDataUncached</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_179"></a>function instead of functions such as <code>bcopy</code>. The <code>bcopy</code><a name="//apple_ref/doc/uid/20001881-DontLinkElementID_180"></a> routine uses cache-manipulation instructions that may cause exception errors. The kernel must fix these errors in order to continue, which slows down performance tremendously. <a name="//apple_ref/doc/uid/20001881-DontLinkElementID_181"></a></p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="AboutMemory.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="FindingPatterns.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-06-28<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/MemoryAlloc.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/MemoryAlloc.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/MemoryAlloc.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
