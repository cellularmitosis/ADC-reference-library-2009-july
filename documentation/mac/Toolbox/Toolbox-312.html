<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Scrolling Through a Document(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING312></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-311.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-313.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-297.html"><B>Chapter 5 - Control Manager</B></A> / <A HREF="Toolbox-308.html"><B>Using the Control Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING312-0></A>
<H2><A NAME=MARKER-9-245></A>Scrolling Through a Document</H2>
 <A NAME=MARKER-2-246></A><A NAME=MARKER-2-247></A>Earlier sections of this chapter explain how to create scroll bars, determine when a mouse-down event occurs in a scroll bar, track user actions in a scroll bar, and determine and change scroll bar settings. This section discusses how your application actually scrolls through documents in response to users' mouse activity in the scroll bars. For example, your application scrolls toward the bottom of the document under the following conditions:<P>
<UL>
<LI>When the user drags the scroll box to the bottom of the vertical scroll bar, your application should display the end of the user's document.
<LI>When the user clicks the gray area below the scroll box, your application should move the document up to display the next window of information toward the bottom of the document, and it should use <CODE>SetControlValue</CODE> to move the scroll box.
<LI>When the user clicks the down scroll arrow, your application should move the document up by one line (or by some similar measure) and bring more of the bottom of the document into view, and it should use <CODE>SetControlValue</CODE> to move the <BR>scroll box. <P>
</UL>
 As a first step, your application must determine the distance by which to scroll. When the user drags a scroll box to a new location on the scroll bar, you scroll a corresponding distance to a new location in the document.<P>
 When the user clicks a scroll arrow, your application determines an appropriate amount to scroll. In general, a word processor scrolls vertically by one line of text and horizon- tally by the average character width, and a database or spreadsheet scrolls by one field. Graphics applications should scroll to display an entire object when possible. (Typically, applications convert these distances to pixels when using Control Manager, QuickDraw, and TextEdit routines.)<P>
 When the user clicks a gray area of a scroll bar, your application should scroll by a distance of just less than the height or width of the window. To determine this height and width, you can use the <CODE>contrlOwner</CODE> field of the scroll bar's control record. This field contains a pointer to the window record. When you scroll by a distance of one window, it is best to retain part of the previous window. This retained portion helps the user place the material in context. For example, if the user scrolls down by a distance of one window in a text document, the line at the top of the window should be the one that previously appeared at the bottom of the window.<P>
 The scrolling direction is determined by whether the scrolling distance is expressed as a positive or negative number. When the user scrolls down or to the right, the scrolling distance is a negative number; when the user scrolls up or to the left, the scrolling distance is a positive number. For example, when the user scrolls from the beginning of a document to a line located 200 pixels down, the scrolling distance is -200 pixels on the vertical scroll bar. When the user scrolls from there back to the start of the document, the scrolling distance is 200 pixels.<P>
 Determining the scrolling distance is only the first step. In brief, your application should take the following steps to scroll through a document in response to the user's manipulation of a scroll bar.<P>
<OL>
<LI>Use the <CODE>FindControl</CODE>, <CODE>GetControlValue</CODE>, and <CODE>TrackControl</CODE> functions to help calculate the scrolling distance. <A NAME=MARKER-2-172></A>
<LI>If you are scrolling for any reason other than the user dragging the scroll box, use the <CODE>SetControlValue</CODE> procedure to move the scroll box a corresponding amount.<A NAME=MARKER-2-179></A>
<LI>Use a routine--such as the QuickDraw procedure <CODE>ScrollRect</CODE> or the TextEdit procedure <CODE>TEPinScroll</CODE>--to move the bits displayed in the window by the calculated scrolling distance. Then either use a call that generates an update event <BR>or else directly call your application's <CODE>DoUpdate</CODE> routine, which should perform <BR>the rest of these steps.
<LI>Use the <CODE>UpdateControls</CODE> procedure to update the scroll bars and then call the Window Manager procedure <CODE>DrawGrowIcon</CODE> to redraw the size box.
<LI>Use the QuickDraw procedure <CODE>SetOrigin</CODE> to change the window origin by an amount equal to the scroll bar settings so that the upper-left corner of the document lies at (0,0) in the window's local coordinate system. (You perform this step so that your application's document-drawing routines can draw in the correct area of the window.)<A NAME=MARKER-2-191></A><A NAME=MARKER-2-183></A>
<LI>Call your application's routines for redrawing the document inside the window.
<LI>Use the <CODE>SetOrigin</CODE> procedure to reset the window origin to (0,0) so that future Window Manager and Control Manager routines draw in the correct area of the window.
<LI>Return to your event loop.<P>
</OL>
 These steps are explained in greater detail in the rest of this section.<P>
<DL>
<DT><B>Note</B>
<DD>It is not necessary to use <CODE>SetOrigin</CODE> as described in the rest of this chapter. This procedure merely helps you to offset the window origin <BR>by the scroll bars' current settings when you update the window, so <BR>that you can locate objects in a document using a coordinate system where the upper-left corner of the document is always at (0,0). As an alternative to this approach, your application can leave the upper-left corner of the window (called the <B>window origin</B>) located at (0,0) and instead offset the items in your document by an amount equal to the scroll bars' settings. The QuickDraw procedures <CODE>OffsetRect</CODE>, <CODE>OffsetRgn</CODE>, <CODE>SubPt</CODE>, and <CODE>AddPt</CODE>, which are described in <I>Inside Macintosh: Imaging,</I> are useful if you pursue this alternate approach.<A NAME=MARKER-2-184></A><A NAME=MARKER-2-96></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When the user saves a document, your application should store the data in your own application-defined data structures. (For example, the sample code in this chapter <BR>stores a handle to a TextEdit edit record in a <I>document record.</I> The edit record contains information about the text, such as it length and its own local coordinate system, and <BR>a handle to the text itself.) You typically store information about the objects your application displays onscreen by using coordinates local to the document, where the upper-left corner of the document is located at (0,0).<P>
 The left side of <A HREF=#MARKER-9-255>Figure 5-16</A> on the next page illustrates a case in which the user has just opened an existing document, and the SurfWriter sample application displays the top of the document. In this example, the document consists of 35 lines of monostyled text, and the line height throughout is 10 pixels. Therefore, the document is 350 pixels long. When the user first opens the document, the window origin is identical to the upper-left point of the document's space: both are at (0,0).<P>
 In this example, the window displays 15 lines of text, which amount to 150 pixels. Hence, the maximum setting for the scroll bar is 200 because the vertical scroll bar's maximum setting is the length of the document minus the height of its window.<A NAME=MARKER-2-75></A><P>
 Imagine that the user drags the scroll box halfway down the vertical scroll bar. Because the user wishes to scroll down, the SurfWriter application must move the text of the document up so that more of the bottom of the document shows. Moving a document <I>up</I> in response to a user request to scroll <I>down</I> requires a scrolling distance with a <I>negative</I> value. (Likewise, moving a document <I>down</I> in response to a user request to scroll <I>up</I> requires a scrolling distance with a <I>positive</I> value.)<P>
 Using <CODE>FindControl</CODE>, <CODE>TrackControl</CODE>, and <CODE>GetControlValue</CODE>, the SurfWriter application determines that it must move the document up by 100 pixels--that is, <BR>by a scrolling distance of -100 pixels. (Using <CODE>FindControl</CODE>, <CODE>TrackControl</CODE>, and <CODE>GetControlValue</CODE> to determine the scrolling distance is explained in detail in <A HREF=#MARKER-9-269>"Scrolling in Response to Events in the Scroll Box" beginning on page 5-48</A>.)<P>
<B>Figure 5-16  <A NAME=MARKER-9-255></A>Moving a document relative to its window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-08.jpg"><P>
 <A NAME=MARKER-9-162></A>The SurfWriter application then uses the QuickDraw procedure <CODE>ScrollRect</CODE> to shift <BR>the bits displayed in the window by a distance of -100 pixels. The <CODE>ScrollRect</CODE> procedure moves the document upward by 100 pixels (that is, by 10 lines); 5 lines from the bottom of the previous window display now appear at the top of the window, <BR>and the SurfWriter application adds the rest of the window to an update region for <BR>later updating.<P>
 The <CODE>ScrollRect</CODE> procedure doesn't change the coordinate system of the window; instead it moves the bits in the window to new coordinates that are still in the window's local coordinate system. For purposes of updating the window, you can think of this <BR>as changing the coordinates of the entire document, as illustrated in the right side of <A HREF=#MARKER-9-255>Figure 5-16</A>.<P>
 The <CODE>ScrollRect</CODE> procedure takes four parameters: a rectangle to scroll, a horizontal distance to scroll, a vertical distance to scroll, and a region handle. Typically, when specifying the rectangle to scroll, your application passes a value representing the content region minus the scroll bar regions, as shown in <A HREF=#MARKER-9-257>Listing 5-17</A>.<P>
<B>Listing 5-17  <A NAME=MARKER-9-257></A>Using <CODE>ScrollRect</CODE> to scroll the bits displayed in the window</B><P>
<PRE>
PROCEDURE DoGraphicsScroll (window: WindowPtr;
                            hDistance, vDistance: Integer);
VAR
   myScrollRect: Rect;
   updateRegion: RgnHandle;
BEGIN
   {initially, use the window's portRect as the rectangle to scroll}
   myScrollRect := window^.portRect;
   {subtract vertical and horizontal scroll bars from rectangle}
   myScrollRect.right := myScrollRect.right - 15;
   myScrollRect.bottom := myScrollRect.bottom - 15;
   updateRegion := NewRgn;    {always initialize the update region}
   ScrollRect(myScrollRect, hDistance, vDistance, updateRegion);
   InvalRgn(updateRegion);
   DisposeRgn(updateRegion);
END; {of DoGraphicsScroll}
</PRE>
<DL>
<DT><B>IMPORTANT</B>
<DD>You must first pass a horizontal distance as a parameter to <CODE>ScrollRect</CODE> and then pass a vertical distance. Notice that when you specify a point in the QuickDraw coordinate system, the opposite is true: you name the vertical coordinate first and the horizontal coordinate second. <EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Although each scroll bar is 16 pixels along its shorter dimension, the <CODE>DoGraphicsScroll</CODE> procedure shown in <A HREF=#MARKER-9-257>Listing 5-17</A> subtracts only 15 pixels <BR>because the edge of the scroll bar overlaps the edge of the window frame, leaving <BR>only 15 pixels of the scroll bar in the content region of the window.<P>
 The bits that <CODE>ScrollRect</CODE> shifts outside of the rectangle specified by <CODE>myScrollRect</CODE> are not drawn on the screen, and they are not saved--it is your application's responsibility to keep track of this data.<P>
 The <CODE>ScrollRect</CODE> procedure shifts the bits a distance of <CODE>hDistance</CODE> pixels horizontally and <CODE>vDistance</CODE> pixels vertically; when <CODE>DoGraphicsScroll</CODE> passes positive values in these parameters, <CODE>ScrollRect</CODE> shifts the bits in the <CODE>myScrollRect</CODE> parameter to the right and down, respectively. This is appropriate when the user intends to scroll left or up, because when the SurfWriter application finishes updating the window, the user sees more of the left and top of the document, respectively. (Remember: to scroll up or left, move the document down or right, both of which are in the positive direction.)<P>
 When <CODE>DoGraphicsScroll</CODE> passes negative values in these parameters, <CODE>ScrollRect</CODE> shifts the bits in the <CODE>myScrollRect</CODE> parameter to the left or up. This is appropriate when the user intends to scroll right or down, because when the SurfWriter application finishes updating the window, the user sees more of the right and the bottom of the document. (Remember: to scroll down or right, move the document up or left, both of which are in the negative direction.)<P>
 In <A HREF=#MARKER-9-255>Figure 5-16</A>, the SurfWriter application determines a vertical scrolling distance of -100, which it passes in the <CODE>vDistance</CODE> parameter as shown here:<P>
<PRE>
ScrollRect(myScrollRect, 0, -100, updateRegion);
</PRE>
 If, however, the user were to move the scroll box back to the beginning of the document at this point, the SurfWriter application would determine that it has a distance of <BR>100 pixels to scroll up, and it would therefore pass a positive value of 100 in the <CODE>vDistance</CODE> parameter.<P>
 After using <CODE>ScrollRect</CODE> to move the bits that already exist in the window, the SurfWriter application should draw the bits in the update region of the window by using its standard window-updating code.<P>
 <A NAME=MARKER-2-258></A>As previously explained, <CODE>ScrollRect</CODE> in effect changes the coordinates of the document relative to the local coordinates of the window. In terms of the window's local coordinate system, the upper-left corner of the document is now at (-100, 0), as shown on the right side of <A HREF=#MARKER-9-255>Figure 5-16</A>. To facilitate updating the window, the SurfWriter application uses the QuickDraw procedure <CODE>SetOrigin</CODE> to change the local coordinate system of the window so that the SurfWriter application can treat the upper-left corner of the document as again lying at (0,0).<A NAME=MARKER-2-158></A><P>
 The <CODE>SetOrigin</CODE> procedure takes two parameters: the first is a new horizontal coordinate for the window origin, and the second is a new vertical coordinate for the window origin. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Like <CODE>ScrollRect</CODE>, <CODE>SetOrigin</CODE> requires you to pass a horizontal coordinate and then a vertical coordinate. Notice that when you <BR>specify a point in the QuickDraw coordinate system, the opposite <BR>is true: you name the vertical coordinate first and the horizontal coordinate second. <EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Any time you are ready to update a window (such as after scrolling it), you can use <CODE>GetControlValue</CODE> to determine the current setting of the horizontal scroll bar and <BR>pass this value as the new horizontal coordinate for the window origin. Then use <CODE>GetControlValue</CODE> to determine the current setting of the vertical scroll bar and pass this value as the new vertical coordinate for the window origin. Using <CODE>SetOrigin</CODE> in this fashion shifts the window's local coordinate system so that the upper-left corner of the document is always at (0,0) when you redraw the document within its window.<P>
 For example, after the user manipulates the vertical scroll bar to move (either up or down) to a location 100 pixels from the top of the document, the SurfWriter application makes the following call:<P>
<PRE>
SetOrigin(0, 100);
</PRE>
 Although the scrolling distance was -100, which is relative, the current setting for the scroll bar is now at 100. (Because you specify a point in the QuickDraw coordinate system by its vertical coordinate first and then its horizontal coordinate, the order of parameters to <CODE>SetOrigin</CODE> may be initially confusing.) <P>
 <A NAME=MARKER-2-122></A>The left side of <A HREF=#MARKER-9-261>Figure 5-17</A> shows how the SurfWriter application uses the <CODE>SetOrigin</CODE> procedure to move the window origin to the point (100,0) so that the upper-left corner of the document is now at (0,0) in the window's local coordinate system. This restores the document's original coordinate space and makes it easier for the application to draw in the update region of the window.<P>
<B>Figure 5-17  <A NAME=MARKER-9-261></A>Updating the contents of a scrolled window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-09.jpg"><P>
 After restoring the document's original coordinates, the SurfWriter application updates the window, as shown on right side of <A HREF=#MARKER-9-261>Figure 5-17</A>. The application draws lines 16 through 24, which it stores in its document record as beginning at (160,0) and ending <BR>at (250,0).<P>
 To review what has happened up to this point: the user has dragged the scroll box one-half of the distance down the vertical scroll bar; the SurfWriter application determines that this distance amounts to a scroll distance of -100 pixels; the SurfWriter application passes this distance to <CODE>ScrollRect</CODE>, which shifts the bits in the window <BR>100 pixels upward and creates an update region for the rest of the window; the SurfWriter application passes the vertical scroll bar's current setting (100 pixels) in a parameter to <CODE>SetOrigin</CODE> so that the document's local coordinates are used when the update region of the window is redrawn; and, finally, the SurfWriter application draws the text in the update region of the window.<P>
 However, the window origin cannot be left at (100,0); instead, the SurfWriter application must use <CODE>SetOrigin</CODE> to reset it to (0,0) after performing its own drawing, because the Window and Control Managers always assume the window's upper-left point is at (0,0) when they draw in a window. <A HREF=#MARKER-9-262>Figure 5-18</A> shows how the application uses <CODE>SetOrigin</CODE> to set the window origin back to (0,0) at the conclusion of its window-updating routine. After the update, the application begins processing events in its event loop again.<P>
<B>Figure 5-18  <A NAME=MARKER-9-262></A>Restoring the window origin to (0,0)</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-10.jpg"><P>
 The left side of <A HREF=#MARKER-9-263>Figure 5-19</A> illustrates what happens when the user scrolls all the way <BR>to the end of the document--a distance of another 10 lines, or 100 pixels. After the SurfWriter application calls <CODE>ScrollRect</CODE>, the bottom 5 lines from the previous window display appear at the top of the new window and the bottom of the window becomes <BR>a new update region. Because the user has scrolled a total distance of 200 pixels, the application uses <CODE>SetOrigin</CODE> to change the window origin to (200,0), as shown on the right side of <A HREF=#MARKER-9-263>Figure 5-19</A>.<P>
 The left side of <A HREF=#MARKER-9-264>Figure 5-20</A> shows the SurfWriter application drawing in the update region of the window; the right side of the figure shows the SurfWriter application restoring the window origin to (0,0).<P>
<B>Figure 5-19  <A NAME=MARKER-9-263></A>Scrolling to the end of a document</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-11.jpg"><P>
<B>Figure 5-20  <A NAME=MARKER-9-264></A>Updating a window's contents and returning the window origin to (0,0)</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-12.jpg"><P>
 <A NAME=MARKER-2-69></A><A NAME=MARKER-2-70></A>How your application determines a scrolling distance and how it then moves the bits in the window by this distance are explained in greater detail in the next two sections, <A HREF=#MARKER-9-269>"Scrolling in Response to Events in the Scroll Box"</A> and <A HREF=#MARKER-9-279>"Scrolling in Response to Events in Scroll Arrows and Gray Areas."</A> <A HREF=#MARKER-9-294>"Drawing a Scrolled Document Inside a Window,"</A> which follows these two sections, describes what your application should do in its window-updating code to draw in a window that has been scrolled. You can find more detailed information about the <CODE>SetOrigin</CODE> and <CODE>ScrollRect</CODE> procedures in <I>Inside Macintosh: Imaging.</I><P>
 <A NAME=MARKER-2-198></A>So far, this discussion has assumed that you are scrolling in response to the user's manipulation of a scroll bar. Most of the time, the user decides when and where to scroll. However, in addition to user manipulation of scroll bars, there are four cases in which your application must scroll through the document. Your application design must take these cases into account.<P>
<UL>
<LI>When your application performs an operation whose side effect is to make a new selection or move the insertion point, you should scroll to show the new selection. For example, when the user invokes a search operation, your application locates the desired text. If this text appears in a part of the document that isn't currently visible, you should scroll to show the selection. Such scrolling might also be necessary after the user invokes a paste operation. If the insertion point appears after the end of whatever was pasted, scroll until the selection and the new insertion point are visible.
<LI>When the user enters information from the keyboard at the edge of a window, you should scroll to incorporate and display the new information. The user's focus will be on the new information, so it doesn't make sense to maintain the document's position and record the new information out of the user's view. In general, a word processor scrolls one line of text, and a database or spreadsheet scrolls one field. Graphics applications should scroll to display an entire object when possible. Otherwise, determine how quickly your application can redraw the window contents during scrolling and adjust the scrolling to minimize blinking and redrawing. Try to ensure that the scrolling is sufficiently fast so as not to annoy users but not so fast as to confuse them.
<LI>When the user moves the cursor past the edge of the window while holding down the mouse button to make an extended selection, you should scroll the window in the direction of cursor movement. The rate of scrolling can be the same as if the user were holding down the mouse button on the corresponding scroll arrow. In some cases it makes sense to vary the scrolling speed so that it is faster as the user moves the cursor farther away from the edge of the window.
<LI>Sometimes the user selects something, scrolls to a new location, and then tries to perform an operation on the selection. In this case, you should scroll so that the selection is showing before your application performs the operation. Showing the selection makes it clear to the user what is being changed.<P>
</UL>
 When designing the document-scrolling routines for your application, also try to keep the following user interface guidelines in mind:<P>
<UL>
<LI>Whenever your application scrolls automatically, avoid unnecessary scrolling. Users want to control the position of documents, so your application should move a document only as much as necessary. Thus, if part of a selection is already showing in a window, don't scroll at all. One exception to this rule is when the hidden part of the selection is more important than the visible part; then scroll to show the important part. For example, suppose a user selects a large block of text and only the bottom is currently visible. If the user then types a character, your application must scroll to the location of the newly typed characters so that they are visible. 
<LI>If your application can scroll in one orientation to reveal the selection, don't scroll in both orientations. That is, if you can scroll vertically to show the selection, don't also scroll horizontally.
<LI>When you can show context on either side of a selection, it's useful to do so. It's <BR>also better to position a selection somewhere near the middle of a window than against a corner. When the selection is too large to fit in the window, it's helpful to display unselected information at either the beginning or the end of the selection <BR>to provide context.<A NAME=MARKER-2-268></A><P>
</UL>
<A NAME=HEADING312-72></A>
<H3><A NAME=MARKER-9-269></A>Scrolling in Response to Events in the Scroll Box</H3>
 <A NAME=MARKER-2-270></A><A HREF=Toolbox-310.html#MARKER-9-196>"Responding to Mouse Events in a Control" beginning on page 5-27</A> describes in <BR>general how to use <CODE>FindControl</CODE> and <CODE>TrackControl</CODE> in your event-handling code. <A HREF=#MARKER-9-271>Listing 5-18</A> shows how to use these routines to respond in particular to mouse events <BR>in a scroll bar.<P>
<B>Listing 5-18  <A NAME=MARKER-9-271></A>Responding to mouse events in a scroll bar</B><P>
<PRE>
PROCEDURE DoContentClick (window: WindowPtr; event: EventRecord);
VAR
   mouse:               Point;
   control:             ControlHandle;
   part:                Integer;
   myData:              MyDocRecHnd;
   oldSetting:          Integer;
   scrollDistance:      Integer;
   windowType:          Integer;
BEGIN
   windowType := MyGetWindowType(window);
   CASE windowType OF
      kMyDocWindow:
         BEGIN
            myData := MyDocRecHnd(GetWRefCon(window));
            HLock(Handle(myData));
            mouse := event.where;
            GlobalToLocal(mouse);   {convert to local coordinates}
            part := FindControl(mouse, window, control);
            CASE part OF
               {handle all other parts first; handle scroll bar parts last}
            inThumb:    {mouse-down in scroll box}
               BEGIN    {get scroll bar setting}
                  oldSetting := GetControlValue(control);
                  {let user drag scroll box around}
                  part := TrackControl(control, mouse, NIL);
                  {until user releases mouse button}
                  IF part = inThumb THEN
                  BEGIN                {get new distance to scroll}
                     scrollDistance := oldSetting - GetControlValue(control);
                     IF scrollDistance &lt;&gt; 0 THEN
                        IF control = myData^^.vScrollBar THEN
                           TEPinScroll(0, scrollDistance * 
                                       myData^^.editRec^^.lineHeight,
                                       myData^^.editRec);
                        ELSE
                           TEPinScroll(scrollDistance, 0, myData^^.editRec);
                  END; {of handling mouse-up in scroll box}
               END; {of handling mouse-down in scroll box}
            inUpButton, inDownButton, inPageUp, in PageDown:
            {mouse-down in scroll arrows or gray areas}
               IF control = myData^^.vScrollBar THEN  
                        {handle vertical scroll}
                  part := TrackControl(control, mouse, @MyVerticalActionProc)
               ELSE     {handle horizontal scroll}
                  part := TrackControl(control, mouse, @MyHorzntlActionProc);
            OTHERWISE   ;
            END; {of CASE part}
            HUnLock(Handle(myData));
         END; {of kMyDocWindowType}
         {handle other window types here}
   END; {of CASE windowType}
END;
</PRE>
 When the user presses the mouse button while the cursor is in a visible, active scroll box, <CODE>FindControl</CODE> returns as its result the part code for a scroll box. That part code and the constant you can use to represent it are listed here:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant<TH>Part code<TH>Control part<TR>
<TD>inThumb<TD>129<TD>Scroll box</TABLE>
<P>
 As shown in <A HREF=#MARKER-9-271>Listing 5-18</A>, when <CODE>FindControl</CODE> returns the value for <CODE>inThumb</CODE>, your application should immediately call <CODE>GetControlValue</CODE> to determine the current setting of the scroll bar. If the user drags the scroll box, you subtract from this setting the new current setting that becomes available when the user releases the mouse button, and you use this result for your scrolling distance. <A NAME=MARKER-2-361></A><P>
 After using <CODE>GetControlValue</CODE> to determine the current setting of the scroll bar, use <CODE>TrackControl</CODE> to follow the movements of the cursor inside the scroll box and to drag a dotted outline of the scroll box in response to the user's movements.<P>
 When the user releases the mouse button, <CODE>TrackControl</CODE> returns <CODE>inThumb</CODE> if the cursor is still in the scroll box or 0 if the cursor is outside the scroll box. When <CODE>TrackControl</CODE> returns 0, your application does nothing. Otherwise, your application again uses <CODE>GetControlValue</CODE> to calculate the distance to scroll.<P>
 Calculate the distance to scroll by calling <CODE>GetControlValue</CODE> and subtracting the new current setting of the scroll bar from its previous setting, which you determine by calling <CODE>GetControlValue</CODE> before the user releases the mouse button. If this distance is not 0, you should move the bits in the window by this distance and update the contents of the rest of the window.<A NAME=MARKER-2-221></A><P>
 Before scrolling, you must determine if the scroll bar is a vertical scroll bar or a horizontal scroll bar. As previously explained in this chapter, you should store handles to your scroll bars in a document record, one of which you create for every document. By <BR>comparing the field containing the vertical scroll bar handle, you can determine whether the control handle returned by <CODE>FindControl</CODE> is the handle to the vertical scroll bar. If so, the user has moved the scroll box of the vertical scroll box. If not, the user has moved the scroll box of the horizontal scroll bar.<P>
 After determining which scroll bar contains the scroll box that the user has dragged, you move the document contents of the window by the appropriate scrolling distance. That is, for a positive scrolling distance in the vertical scroll bar, move the bits in the window down by that distance. When you update the window, this displays more lines from the top of the document--which is appropriate when the user moves the scroll box <I>up.</I> For a positive scrolling distance in the horizontal scroll bar, move the bits in the window to the right by that distance. When you update the window, this displays more lines from the left side of the document--which is appropriate when the user moves the scroll box <I>to the left.</I> (Remember: to scroll up or left, move the document down or right, both of which are in the positive direction.)<P>
 For a negative scrolling distance in the vertical scroll bar (such as that shown in <BR><A HREF=#MARKER-9-255>Figure 5-16 on page 5-42</A>), move the bits in the window up by that distance. When you update the window, this displays more lines from the bottom of the document--which <BR>is appropriate when the user moves the scroll box <I>down.</I> For a negative scrolling distance in the horizontal scroll bar, move the bits in the window to the left by that distance. When you update the window, this displays more lines from the right side of the document--which is appropriate when the user moves the scroll box <I>to the right.</I> (Remember: to scroll down or right, move the document up or left, both of which are in the negative direction.)<P>
 <A NAME=MARKER-2-212></A>The previous examples in this chapter have shown an application that uses a TextEdit edit record to store monostyled text created by the user. For simple text-handling <BR>needs, TextEdit provides many routines that simplify your work; for example, the <CODE>TEPinScroll</CODE> procedure scrolls through the text in the view rectangle of an edit record by the number of pixels specified by your application; <CODE>TEPinScroll</CODE> stops scrolling when the last line scrolls into the view rectangle.<P>
 The <CODE>TEPinScroll</CODE> procedure takes three parameters: the number of pixels to move the text horizontally, the number of pixels to move the text vertically, and a handle to an edit record. Positive values in the first two parameters move the text right and down, respectively, and negative values move the text left and up.<P>
 The <CODE>DoContentClick</CODE> procedure, illustrated in <A HREF=#MARKER-9-271>Listing 5-18 on page 5-48</A>, passes the scrolling distance in the second parameter of <CODE>TEPinScroll</CODE> for a vertical scroll bar, and it passes the scrolling distance in the first parameter for a horizontal scroll bar.<P>
 <A HREF=Toolbox-311.html#MARKER-9-238>Listing 5-16 on page 5-38</A> shows an application-defined routine, <CODE>MyAdjustHV</CODE>, called by the SurfWriter sample application whenever it creates, opens, or resizes a window. This routine defines the current and maximum settings for a vertical scroll bar in terms of lines of text.<P>
 The <CODE>DoContentClick</CODE> procedure on <A HREF=#MARKER-9-271>page 5-48</A> uses <CODE>GetControlValue</CODE> to determine the control's current setting--which for the vertical scroll bar <CODE>DoContentClick</CODE> calculates as some number of lines. When determining the vertical scroll bar's scrolling distance, <CODE>DoContentClick</CODE> again calculates a value representing some number of lines. <P>
 However, <CODE>TEPinScroll</CODE> expects pixels, not lines, to be passed in its parameters. Therefore, <CODE>DoContentClick</CODE> multiplies the scrolling distance (which it calculates as some number of lines of text) by the line height (which is maintained in the edit record for monostyled text as some number of pixels). In this way, <CODE>DoContentClick</CODE> passes a scrolling distance--in terms of pixels--to <CODE>TEPinScroll</CODE>, as shown in this code fragment.<P>
<PRE>
IF control = myData^^.vScrollBar THEN
   TEPinScroll(0, scrollDistance * myData^^.editRec^^.lineHeight,
               myData^^.editRec);
</PRE>
 <A HREF=#MARKER-9-255>Figure 5-16 on page 5-42</A> illustrates a scrolling distance of -10 lines. If the line height <BR>is 10 pixels, the SurfWriter application passes -100 as the second parameter to <CODE>TEPinScroll</CODE>.<P>
 The <CODE>TEPinScroll</CODE> procedure adds the scrolled-away area to the update region and generates an update event so that the text in the edit record's view rectangle can be updated. In its code that handles update events for windows, the SurfWriter sample application then uses the <CODE>TEUpdate</CODE> procedure--as described in <A HREF=#MARKER-9-294>"Drawing a Scrolled Document Inside a Window" beginning on page 5-56</A>-- for its windows that include TextEdit edit records.<P>
 To learn more about <CODE>TEPinScroll</CODE>, the TextEdit edit record, and other facilities offered by TextEdit, see <I>Inside Macintosh: Text.</I><A NAME=MARKER-2-214></A><P>
 <A NAME=MARKER-2-216></A>The QuickDraw procedure <CODE>ScrollRect</CODE> is a more general-purpose routine for moving bits in a window when scrolling. If you use <CODE>ScrollRect</CODE> to scroll the bits displayed <BR>in the window, you should define a routine like <CODE>DoGraphicsScroll</CODE>, shown in <BR><A HREF=#MARKER-9-257>Listing 5-17 on page 5-43</A>, and use it instead of <CODE>TEPinScroll</CODE>, which is used in <BR><A HREF=#MARKER-9-271>Listing 5-18 on page 5-48</A>.<P>
 The <CODE>ScrollRect</CODE> procedure returns in the <CODE>updateRegion</CODE> parameter the area that needs to be updated. The <CODE>DoGraphicsScroll</CODE> procedure shown in <A HREF=#MARKER-9-257>Listing 5-17 on page 5-43</A> then uses the QuickDraw procedure <CODE>InvalRgn</CODE> to add this area to the update region, forcing an update event. In your code for handling update events, you draw in the area of the window from which <CODE>ScrollRect</CODE> has moved the bits, as described in <A HREF=#MARKER-9-294>"Drawing a Scrolled Document Inside a Window" beginning on page 5-56</A>.<A NAME=MARKER-2-277></A><P>
 When a mouse-down event occurs in the scroll arrows or gray areas of the vertical <BR>scroll bar, the <CODE>DoContentClick</CODE> routine in <A HREF=#MARKER-9-271>Listing 5-18 on page 5-48</A> calls <CODE>TrackControl</CODE> and passes it a pointer to an application-defined action procedure <BR>called <CODE>MyVerticalActionProc</CODE>. For the horizontal scroll bar, <CODE>DoContentClick</CODE> <BR>calls <CODE>TrackControl</CODE> and passes it a pointer to an action procedure called <CODE>MyHorzntlActionProc</CODE>. These action procedures are described in the next section.<A NAME=MARKER-2-278></A><P>
<A NAME=HEADING312-97></A>
<H3><A NAME=MARKER-9-279></A>Scrolling in Response to Events in Scroll Arrows and Gray Areas</H3>
 <A NAME=MARKER-2-280></A>With each click in a scroll arrow, your application should scroll by a distance of one <BR>unit (that is, by a single line, character, cell, or whatever your application deems appropriate) in the chosen direction. When the user holds the mouse button down <BR>while the cursor is in a scroll arrow, your application should scroll continuously by single units until the user releases the mouse button or until your application has scrolled as far as possible in the document. <P>
 With each click in a gray area, your application should scroll in the appropriate direction by a distance of just less than the height or width of one window to show part of the previous window (thus placing the newly displayed material in context). When the user holds the mouse button down while the cursor is in a gray area, your application should scroll continuously in units of this distance until the user releases the mouse button or until your application has scrolled as far as possible in the document.<P>
 When your application finishes scrolling, it should use <CODE>SetControlValue</CODE> to move the scroll box accordingly.<P>
 As previously described in this chapter, you use <CODE>FindControl</CODE> to determine when a mouse-down event has occurred in a control in one of your windows, and you use <CODE>TrackControl</CODE> to follow the movements of the cursor inside the control, to give the user visual feedback, and then to inform your application when the user releases the mouse button.<P>
 When a mouse-down event occurs in the scroll arrows or the gray areas of an active scroll bar, <CODE>FindControl</CODE> returns as its result the appropriate part code. The part codes for the scroll arrows and gray areas, and the constants you can use to represent them, are listed here:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant<TH>Part code<TH>Control part<TR>
<TD>inUpButton<TD>20<TD>Up scroll arrow for a vertical scroll bar, left scroll arrow for a horizontal scroll bar<TR>
<TD>inDownButton<TD>21<TD>Down scroll arrow for a vertical scroll bar, right scroll arrow for a horizontal scroll bar<TR>
<TD>inPageUp<TD>22<TD>Gray area above scroll box for a vertical scroll bar, gray area to left of scroll box for a horizontal scroll bar<TR>
<TD>inPageDown<TD>23<TD>Gray area below scroll box for a vertical scroll bar, gray area to right of scroll box for a horizontal scroll bar</TABLE>
<P>
 When <CODE>FindControl</CODE> returns one of these part codes, your application should immediately call <CODE>TrackControl</CODE>. As long as the user holds down the mouse button while the cursor is in a scroll arrow, <CODE>TrackControl</CODE> highlights the scroll arrow, <BR>as shown in <A HREF=Toolbox-305.html#MARKER-9-99>Figure 5-8 on page 5-10</A>. When the user releases the mouse button, <CODE>TrackControl</CODE> removes the highlighting.<P>
 For all of the other standard controls, as well as for the scroll box in a scroll bar, your application doesn't respond until <CODE>TrackControl</CODE> reports a mouse-up event in the same control part where the mouse-down event initially occurred. However, for scroll arrows and gray areas, your application must respond by scrolling the document <I>before</I> <CODE>TrackControl</CODE> reports that the user has released the mouse button. When you call <CODE>TrackControl</CODE> for scroll arrows and gray areas, you must define an action procedure that scrolls appropriately until <CODE>TrackControl</CODE> reports that the user has released the mouse button.<A NAME=MARKER-2-410></A><P>
 <A NAME=MARKER-2-411></A>When the user releases the mouse button or moves the cursor away from the scroll arrow or gray area, <CODE>TrackControl</CODE> returns as its result one of the previously listed values that represent the control part. As shown in <A HREF=#MARKER-9-271>Listing 5-18 on page 5-48</A>, the <CODE>DoContentClick</CODE> procedure tests for the part codes <CODE>inUpButton</CODE>, <CODE>inDownButton</CODE>, <CODE>inPageUp</CODE>, and <CODE>inPageDown</CODE> to determine when a mouse-down event occurs in a <BR>scroll arrow or a gray area.<P>
 When the user presses or holds down the mouse button while the cursor is in either <BR>the scroll arrow or the gray area of the vertical scroll bar, <CODE>DoContentClick</CODE> calls <CODE>TrackControl</CODE> and passes it a pointer to an application-defined action procedure <BR>called <CODE>MyVerticalActionProc</CODE>. For the horizontal scroll bar, <CODE>DoContentClick</CODE> <BR>calls <CODE>TrackControl</CODE> and passes it a pointer to an action procedure called <CODE>MyVerticalActionProc</CODE>. In turn, <CODE>TrackControl</CODE> calls these action procedures to scroll continuously until the user releases the mouse button.<A NAME=MARKER-2-225></A><P>
<DL>
<DT><B>Note</B>
<DD>As an alternative to passing a pointer to your action procedure <BR>in a parameter to <CODE>TrackControl</CODE>, you can use the <CODE>SetControlAction</CODE> procedure to store a pointer to the action procedure in the <CODE>contrlAction</CODE> field in the control record. When <BR>you pass <CODE>Pointer(-1)</CODE> instead of a procedure pointer to <CODE>TrackControl</CODE>, <CODE>TrackControl</CODE> uses the action procedure <BR>pointed to in the control record.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-284>Listing 5-19</A> shows two sample action procedures: <CODE>MyVerticalActionProc</CODE>--which responds to mouse events in the scroll arrows and gray areas of a vertical scroll bar--<BR>and <CODE>MyHorzntlActionProc</CODE>--which responds to those same events in a horizontal scroll bar. When <CODE>TrackControl</CODE> calls these action procedures, it passes a control handle and an integer representing the part of the control in which the mouse event occurred. Both <CODE>MyVerticalActionProc</CODE> and <CODE>MyHorzntlActionProc</CODE> use the constants <CODE>inUpButton</CODE>, <CODE>inDownButton</CODE>, <CODE>inPageUp</CODE>, and <CODE>inPageDown</CODE> to test for the control part passed by <CODE>TrackControl</CODE>.<P>
<B>Listing 5-19  <A NAME=MARKER-9-284></A>Action procedures for scrolling through a text document</B><P>
<PRE>
PROCEDURE MyVerticalActionProc (control: ControlHandle; part: Integer);
VAR
   scrollDistance:   Integer;
   window:           WindowPtr;
   myData:           MyDocRecHnd;
BEGIN
   IF part &lt;&gt; 0 THEN
   BEGIN
      window := control^^.contrlOwner; {get the control's window}
      myData := MyDocRecHnd(GetWRefCon(window));
      HLock(Handle(myData));
      CASE part OF
         inUpButton, inDownButton:  {get one line to scroll}
            scrollDistance := 1;
         inPageUp, inPageDown:   {get the window's height}
         BEGIN
            scrollDistance := (myData^^.editRec^^.viewRect.bottom -
                              myData^^.editRec^^.viewRect.top) 
                              DIV myData^^.editRec^^.lineHeight;
               {subtract 1 line so user sees part of previous window}
            scrollDistance := scrollDistance - 1;
         END;
      END;  {of part CASE}
      IF (part = inDownButton) OR (part = inPageDown) THEN
         scrollDistance := -scrollDistance;
      MyMoveScrollBox(control, scrollDistance);
      IF scrollDistance &lt;&gt; 0 THEN   {scroll by line or by window}
         TEPinScroll(0, scrollDistance * myData^^.editRec^^.lineHeight,
                     myData^^.editRec);
      HUnLock(Handle(myData));
   END;
END; {of MyVerticalActionProc}

PROCEDURE MyHorzntlActionProc (control: ControlHandle; part: Integer);
VAR
   scrollDistance:   Integer;
   window:           WindowPtr;
   myData:           MyDocRecHnd;
BEGIN
   IF part &lt;&gt; 0 THEN
   BEGIN
      window := control^^.contrlOwner; {get the control's window}
      myData := MyDocRecHnd(GetWRefCon(window));
      HLock(Handle(myData));
      CASE part OF
         inUpButton, inDownButton:  {get a few pixels}
            scrollDistance := kButtonScroll;
         inPageUp, inPageDown:   {get a window's width}
            scrollDistance := myData^^.editRec^^.viewRect.right -
                               myData^^.editRec^^.viewRect.left;
      END;  {of part CASE}
      IF (part = inDownButton) OR (part = inPageDown) THEN
         scrollDistance := -scrollDistance;
      MyMoveScrollBox(control, scrollDistance);
      IF scrollDistance &lt;&gt; 0 THEN
         TEPinScroll(scrollDistance, 0, myData^^.editRec);
      HUnLock(Handle(myData));
   END;
END; {of MyHorzntlActionProc}
</PRE>
 Each action procedure begins by determining an appropriate scrolling distance. For <BR>the scroll arrows in a vertical scroll bar, <CODE>MyVerticalActionProc</CODE> defines the <BR>scrolling distance as one line. For the gray areas in a vertical scroll bar, <CODE>MyVerticalActionProc</CODE> determines the scrolling distance in lines by dividing the window height by the line height; the window height is determined by subtracting <BR>the bottom coordinate of the view rectangle (defined in the edit record) from its top coordinate. Then <CODE>MyVerticalActionProc</CODE> subtracts 1 from this distance so that <BR>when the user presses the mouse button while the cursor is in a gray area, <CODE>MyVerticalActionProc</CODE> scrolls one line less than the total number of lines in <BR>the window.<P>
 The <CODE>MyVerticalActionProc</CODE> procedure later multiplies these line distances by the <BR>line height to derive pixel distances to pass in parameters to <CODE>TEPinScroll</CODE>. Also, <CODE>MyVerticalActionProc</CODE> turns these distances into negative values when the mouse-down event occurs in the lower scroll arrow or in the gray area below the <BR>scroll box.<P>
 For the scrolling distance of the scroll arrows in horizontal scroll bars, <CODE>MyHorzntlActionProc</CODE> uses a predetermined pixel distance--roughly the <BR>document's average character width. For the scrolling distance of the gray areas <CODE>MyHorzntlActionProc</CODE> uses the window width (which is derived by <BR>subtracting the left coordinate of the view rectangle from its right coordinate). The <CODE>MyHorzntlActionProc</CODE> routine turns these distances into negative values when <BR>the mouse-down event occurs in the right scroll arrow or in the gray area to the <BR>right of the scroll box.<P>
 After calling <CODE>MyMoveScrollBox</CODE>, an application-defined routine that moves the scroll box, both action procedures use <CODE>TEPinScroll</CODE> to move the text displayed in the window by the scrolling distance. (In this example, the SurfWriter application is <BR>scrolling a simple monostyled text document stored as a TextEdit edit record. For <BR>a discussion of using the more general-purpose QuickDraw scrolling routine <CODE>ScrollRect</CODE>, see the previous section, <A HREF=#MARKER-9-269>"Scrolling in Response to Events in the Scroll Box" beginning on page 5-48</A>.)<P>
 The <CODE>TEPinScroll</CODE> procedure automatically creates an update region and invokes an update event. In its window-updating code, the SurfWriter application uses the <CODE>TEUpdate</CODE> procedure to draw the text in the update region, as shown in <A HREF=Toolbox-340.html#MARKER-9-456>Listing 5-23 on page 5-59</A>.<P>
 The action procedures continue moving the text by the specified distances over and over until the user releases the mouse button and <CODE>TrackControl</CODE> completes. If there is no more area to scroll through, <CODE>TEPinScroll</CODE> automatically stops scrolling, as your application should if you implement your own scrolling routine.<P>
 <A NAME=MARKER-2-159></A><A NAME=MARKER-2-286></A><A NAME=MARKER-2-287></A><A HREF=#MARKER-9-288>Listing 5-20</A> shows how the application-defined procedure <CODE>MyMoveScrollBox</CODE> uses <CODE>GetControlValue</CODE>, <CODE>GetControlMaximum</CODE>, and <CODE>SetControlValue</CODE> to move the scroll box an appropriate distance while the action procedures scroll through the document. The <CODE>MyMoveScrollBox</CODE> procedure uses <CODE>GetControlMaximum</CODE> to determine the maximum scrolling distance, <CODE>GetControlValue</CODE> to determine the current setting for the scroll box, and <CODE>SetControlValue</CODE> to assign the new setting and move the scroll box. Use of the <CODE>SetControlMaximum</CODE> and <CODE>SetControlValue</CODE> routines is described in <A HREF=Toolbox-311.html#MARKER-9-227>"Determining and Changing Control Settings" beginning on page 5-34</A>; <CODE>GetControlMaximum</CODE> is described in detail on <A HREF=Toolbox-349.html#MARKER-9-502>page 5-104</A>.<P>
<B>Listing 5-20  <A NAME=MARKER-9-288></A>Moving the scroll box from the action procedures</B><P>
<PRE>
PROCEDURE MyMoveScrollBox (control: ControlHandle;
                           scrollDistance: Integer);
VAR
   oldSetting, setting, max:  Integer;
BEGIN
   oldSetting := GetControlValue(control);   {get last setting}
   max := GetControlMaximum(control);        {get maximum setting}
{subtract action procs' scroll amount from last setting to get new setting}
   setting := oldSetting - scrollDistance;
   IF setting &lt; 0 THEN 
      setting := 0
   ELSE IF setting &gt; max THEN 
      setting := max;
   SetControlValue(control, setting); {assign new current setting}
END; {of MyMoveScrollBox}
</PRE>
 The previous two sections have described how to move the bits displayed in the window; the next section describes how to draw into the update region.<A NAME=MARKER-9-596></A><A NAME=MARKER-2-290></A><A NAME=MARKER-2-291></A><A NAME=MARKER-2-292></A><A NAME=MARKER-2-293></A><P>
<A NAME=HEADING312-121></A>
<H3><A NAME=MARKER-9-294></A>Drawing a Scrolled Document Inside a Window</H3>
 <A NAME=MARKER-2-208></A>The previous two sections have described how to use the QuickDraw procedure <CODE>ScrollRect</CODE> and the TextEdit procedure <CODE>TEPinScroll</CODE> in response to the user manipulating any of the five parts of a scroll bar. After using these or your own routines for moving the bits in your window, your application must draw into the update region. Typically, you use your own window-updating code for this purpose.<P>
 Both <CODE>InvalRect</CODE> and <CODE>TEPinScroll</CODE>, which are used in the examples shown earlier in this chapter, create update regions that cause update events. As described in the chapters "Window Manager" and "Event Manager" in this book, your application should draw in the update regions of your windows when it receives update events. If you create your own scrolling routine to use instead of <CODE>ScrollRect</CODE> or <CODE>TEPinScroll</CODE>, you should guarantee that it generates an update event or that it explicitly calls your own window-updating routine.<P>
 <A HREF=#MARKER-9-296>Listing 5-21</A> shows an application-defined routine, <CODE>DoUpdate</CODE>, that the SurfWriter application calls whenever it receives an update event. In this procedure, the application tests for two different types of windows: windows containing graphics objects and windows containing text created with TextEdit routines. <P>
<B>Listing 5-21  <A NAME=MARKER-9-296></A>An application-defined update routine</B><P>
<PRE>
PROCEDURE DoUpdate (window: WindowPtr);
VAR
   windowType: Integer;
BEGIN
   windowType := MyGetWindowType(window);
   CASE windowType OF
   kMyGraphicsWindow:   {window containing graphics objects}
      BEGIN
         BeginUpdate(window);
         MyDrawGraphicsWindow(window);
         EndUpdate(window);
      END;  {of updating graphics windows}
   kMyDocWindow:        {window containing TextEdit text}
      BEGIN
         BeginUpdate(window);
         MyDrawWindow(window);
         EndUpdate(window);
      END;  {of updating TextEdit document windows}
   {handle other window types----modeless dialogs, etc.----here}
   END;  {of windowType CASE}
END;  {of DoUpdate}
</PRE>
 In this example, when the window requiring updating is of type <CODE>kMyGraphicsWindow</CODE>, <CODE>DoUpdate</CODE> uses another application-defined routine called <CODE>MyDrawGraphicsWindow</CODE>. When the window requiring updating is of type <CODE>kMyDocWindow</CODE>, <CODE>DoUpdate</CODE> uses another application-defined routine--namely, <CODE>MyDrawWindow</CODE>. <A HREF=#MARKER-9-297>Listing 5-22</A> shows <BR>the <CODE>MyDrawGraphicsWindow</CODE> routine and <A HREF=Toolbox-340.html#MARKER-9-456>Listing 5-23 on page 5-59</A> shows the <CODE>MyDrawWindow</CODE> routine.<P>
 Before drawing into the scrolled-away portion of the window, both of these routines <BR>use the QuickDraw, Window Manager, and Control Manager routines necessary for updating windows. (<A HREF=Toolbox-309.html#MARKER-9-188>"Updating a Control" beginning on page 5-25</A> describes the <CODE>UpdateControls</CODE> procedure; see the chapter "Window Manager" in this book for a detailed description of how to use the rest of these routines to update a window.) <P>
<B>Listing 5-22  <A NAME=MARKER-9-297></A>Redrawing a window containing graphics objects</B><P>
<PRE>
PROCEDURE MyDrawGraphicsWindow (window: WindowPtr);
VAR
   myData:  MyDocRecHnd;
   i:       Integer;
BEGIN
   SetPort(window);
   myData := MyDocRecHnd(GetWRefCon(window));
   HLock(Handle(myData));
   WITH window^ DO
      BEGIN
         EraseRect(portRect);
         UpdateControls(window, visRgn);
         DrawGrowIcon(window);
         SetOrigin(GetControlValue(myData^^.hScrollBar),
                   GetControlValue(myData^^.vScrollBar));
         i := 1;
         WHILE i &lt;= myData^^.numObjects DO
            DrawMyObjects(portRect, myData^^.numObjects[i]);
            i := i + 1;
         END; {of WHILE}
         SetOrigin(0, 0);
      END;
   HUnLock(Handle(myData));
END;  {of MyDrawGraphicsWindow}
</PRE>
 The <CODE>MyDrawGraphicsWindow</CODE> routine uses the QuickDraw procedure <CODE>SetOrigin</CODE> to change the window origin by an amount equal to the scroll bar settings, so that the upper-left corner of the document lies at (0,0) in the window's local coordinate system. The SurfWriter sample application performs this step so that its own drawing routines can draw into the correct area of the window.<P>
 Notice that <CODE>MyDrawGraphicsWindow</CODE> calls <CODE>SetOrigin</CODE> only after calling the necessary Window Manager and Control Manager routines, because the Window Manager and Control Manager always expect the window origin to be at (0,0).<P>
 By using <CODE>SetOrigin</CODE> to change the window origin, <CODE>MyDrawGraphicsWindow</CODE> can treat the objects in its document as being located in a coordinate system where the upper-left corner of the document is always at (0,0). Then <CODE>MyDrawGraphicsWindow</CODE> calls another of its own routines, <CODE>DrawMyObjects</CODE>, to draw the objects it has stored in its document record for the window.<P>
 After performing all its own drawing in the window, <CODE>MyDrawGraphicsWindow</CODE> again uses <CODE>SetOrigin</CODE>--this time to reset the window origin to (0,0) so that future Window Manager and Control Manager routines will draw into the correct area of the window.<P>
 <A HREF=#MARKER-9-255>Figure 5-16</A> through <A HREF=#MARKER-9-264>Figure 5-20</A> earlier in this chapter help to illustrate how to use <CODE>SetOrigin</CODE> to offset the window's coordinate system so that you can treat the objects <BR>in your document as fixed in the document's own coordinate space. However, it is not necessary for your application to use <CODE>SetOrigin</CODE>. Your application can leave the window's coordinate system fixed and instead offset the items in your document by the amount equal to the scroll bar settings. The QuickDraw procedures <CODE>OffsetRect</CODE>, <CODE>OffsetRgn</CODE>, <CODE>SubPt</CODE>, and <CODE>AddPt</CODE>, which are described in <I>Inside Macintosh: Imaging,</I> <BR>are useful if you pursue this approach.<A NAME=MARKER-2-203></A><P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>SetOrigin</CODE> procedure does not move the window's clipping region. If you use clipping regions in your windows, use the QuickDraw procedure <CODE>GetClip</CODE> to store your clipping region immediately after your first call to <CODE>SetOrigin</CODE>. Before calling your own window-drawing routine, use the QuickDraw procedure <CODE>ClipRect</CODE> to define a new clipping region--to avoid drawing over your scroll bars, for example. After calling your own window-drawing routine, use the QuickDraw procedure <CODE>ClipRect</CODE> to restore the original clipping region. You <BR>can then call <CODE>SetOrigin</CODE> again to restore the window origin to (0,0) with your original clipping region intact. See <I>Inside Macintosh: <BR>Imaging</I> for detailed descriptions of clipping regions and of these <BR>QuickDraw routines.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The previous examples in this chapter have shown an application that uses a TextEdit edit record to store the information created by the user. For simple text-handling <BR>needs, TextEdit provides many routines that simplify your work; for example, the <CODE>TEPinScroll</CODE> procedure (used in <A HREF=#MARKER-9-271>Listing 5-18 on page 5-48</A> and <A HREF=#MARKER-9-284>Listing 5-19 on page 5-53</A>) resets the view rectangle of text stored in an edit record by the amount of pixels specified by the application. The <CODE>TEPinScroll</CODE> procedure then generates an update event for the window. The TextEdit procedure <CODE>TEUpdate</CODE> should then be called in an application's update routine to draw the update region of the scrolled window.<A NAME=MARKER-2-556></A><P>
 <A HREF=Toolbox-340.html#MARKER-9-456>Listing 5-23</A> shows an application-defined procedure, <CODE>MyDrawWindow</CODE>, that uses <CODE>TEUpdate</CODE> to update the text in windows of type <CODE>kMyDocWindow</CODE>. The <CODE>TEUpdate</CODE> procedure manages all necessary shifting of coordinates during window updating, so <CODE>MyDrawWindow</CODE> does not have to call <CODE>SetOrigin</CODE> as it does when it uses <CODE>ScrollRect</CODE>.<P>
<B>Listing 5-23  <A NAME=MARKER-9-456></A>Redrawing a window after scrolling a TextEdit edit record</B><P>
<PRE>
PROCEDURE MyDrawWindow (window: WindowPtr);
VAR
   myData: MyDocRecHnd;
BEGIN
   SetPort(window);
   myData := MyDocRecHnd(GetWRefCon(window));
   HLock(Handle(myData));
   WITH window^ DO
      BEGIN
         EraseRect(portRect);
         UpdateControls(window, visRgn);
         DrawGrowIcon(window);
         TEUpdate(portRect, myData^^.editRec);
      END;
   HUnLock(Handle(myData));
END;  {of MyDrawWindow}
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-311.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-313.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
