<html>	<head>		<title>EOQualifier Concepts</title>	</head>	<BODY BGCOLOR="#FFFFFF">		<!-- start of header -->		<!--#include virtual="/includes/framesetheader" -->		<!-- end of header --><!-- start of path --><table cellspacing=0 border=0 width=600 valign="left"><tr><td scope="row"><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../../../../index.html" target="_top">Documentation</a> <b>></b> <a href="../../../../webobjects.html" target="_top">WebObjects</a></font></td></tr></table><br><!-- end of path -->		<a href="../../EOControlTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> 		<h1><font color="#000066"><a name="//apple_ref/UNKNOWN_LANGUAGE/cl/EOQualifier.Concepts">EOQualifier.Concepts</a></font></h1>		<br>		<br>		<a name="BCCBFIFH"></a>		<h2>Creating a Qualifier</h2>		<p>As described above, there are several EOQualifier subclasses, each of which represents a different semantic. However, in most cases you simply create a qualifier using the EOQualifier static method <b>qualifierWithQualifierFormat</b>:, as follows:</p>		<blockquote>			<pre>EOQualifier qual = Qualifier.qualifierWithQualifierFormat(&quot;lastName = 'Smith'&quot;, null);</pre>		</blockquote>		<br>		<p>The qualifier or group of qualifiers that result from such a statement is based on the contents of the format string you provide. For example, giving the format string &quot;lastName = 'Smith'&quot; as an argument to qualifierWithQualifierFormat returns an EOKeyValueQualifier object. But you don't normally need to be concerned with this level of detail.</p>		<p>The format strings you use to create a qualifier can be compound logical expressions, such as &quot;firstName = 'Fred' AND age &lt; 20&quot;. When you create a qualifier, compound logical expressions are translated into a tree of EOQualifier nodes. Logical operators such as AND and OR become EOAndQualifiers and EOOrQualifiers, respectively. These qualifiers conjoin (AND) or disjoin (OR) a group of sub-qualifiers. This is illustrated in <a href="#BBIBFCEI">Figure 0-1</a>, in which the format string &quot;salary &gt; 300 AND firstName = 'Angela' AND manager.name = 'Fred'&quot; has been translated into a tree of qualifiers.</p>		<center>			<a name="BBIBFCEI"></a>			<p><b>Figure 0-1 EOQualifier Tree for 'salary &gt; 300 AND firstName = &quot;Angela&quot; AND manager.name = &quot;Fred&quot;'</b></p>			<img src="Art/QualiferTree.GIF" alt="[image: Art/QualiferTree.GIF]"> </center>		<p>The <b>qualifierWithQualifierFormat</b> method can't be used to create an instance of EOSQLQualifier. This is because EOSQLQualifier uses a non-structured syntax. It also requires an entity. To create an instance of EOSQLQualifier, you'd use a statement such as the following:</p>		<blockquote>			<pre>EOQualifier myQual = new EOSQLQualifier(myEntity, myFormatString);</pre>		</blockquote>		<br>		<br>		<a name="BBICFCJF"></a>		<h2>Constructing Format Strings</h2>		<p>As described above, you typically create a qualifier from a format string by using qualifierWithQualifierFormat. This method takes as an argument a format string somewhat like that used with the standard C <b>printf()</b> function. The format string can embed strings, numbers, and other objects using the conversion specification %@. The second argument to qualifierWithQualifierFormat is an array that contains the value or result to substitute for any %@ conversion specifications. This allows qualifiers to be built dynamically. The following table lists the conversion specifications you can use in a format string and their corresponding data types.</p>		<br>		<table border="1">			<tr>				<td scope="row"><b>Conversion Specification</b></td>				<td><b>Expected Value or Result</b></td>			</tr>			<tr>				<td scope="row">%@</td>				<td>It can either be an object whose <b>toString</b> (or <b>description</b>) method returns a key (in other words, a String), or a value object such as an String, Number, java.util.CalendarDate, and so on.</td>			</tr>			<tr>				<td scope="row">%%</td>				<td>Results in a literal % character.</td>			</tr>		</table><br>		<br>		<table border="1">			<tr>				<td scope="row"><b>Conversion Specification</b></td>				<td><b>Expected Value or Result</b></td>			</tr>			<tr>				<td scope="row">%s</td>				<td>A constant C string (<b>const char *</b>).</td>			</tr>			<tr>				<td scope="row">%d</td>				<td>An <b>int</b>.</td>			</tr>			<tr>				<td scope="row">%f</td>				<td>A <b>float</b> or <b>double</b>.</td>			</tr>			<tr>				<td scope="row">%@</td>				<td>An <b>id</b> argument. The behavior of this conversion specification depends on its position. It can either be an object whose description method returns a key (in other words, an NSString), or a value such as an NSString, NSNumber, NSCalendarDate, and so on.</td>			</tr>			<tr>				<td scope="row">%%</td>				<td>Results in a literal <b>%</b> character.</td>			</tr>		</table><br>		<p>If you use an unrecognized character in a conversion specification (for example, %x), an exception is thrown.</p>		<p>For example, suppose you have an Employee entity with the properties <b>empID</b>, <b>firstName</b>, <b>lastName</b>, <b>salary</b>, and <b>department</b> (representing a to-one relationship to the employee's department), and a Department entity with properties deptID, and name. You could construct simple qualifier strings like the following:</p>		<blockquote>			<pre>lastName = 'Smith'salary &gt; 2500department.name = 'Personnel'</pre>		</blockquote>		<br>		<p>The following examples build qualifiers similar to the qualifier strings described above, but take the specific values from already-fetched enterprise objects:</p>		<blockquote>			<pre>Employee anEmployee;    // Assume this exists.Department aDept;       // Assume this exists.EOQualifier myQualifier;NSMutableArray args = new MutableVector();args.addObject(&quot;lastName&quot;);args.addObject(anEmployee.lastName());myQualifier = EOQualifier.qualifierWithQualifierFormat(&quot;%@ = %@&quot;, args);args.removeAllObjects();args.addObject(&quot;salary&quot;);args.addObject(anEmployee.salary());myQualifier = EOQualifier.qualifierWithQualifierFormat(&quot;%@ &gt; %f&quot;, args);args.removeAllElements();args.addElement(&quot;department.name&quot;);args.addElement(aDept.name());myQualifier = EOQualifier.qualifierWithQualifierFormat(&quot;%@ = %@&quot;, args);</pre>		</blockquote>		<br>		<p>The enterprise objects here implement methods for directly accessing the given attributes: <b>lastName</b> and <b>salary</b> for Employee objects, and <b>name</b> for Department objects. Note that unlike a string literal, the %@ conversion specification is never surrounded by single quotes:</p>		<blockquote>			<pre>// For a literal string value such as Smith, you use single quotes.EOQualifier.qualifierWithQualifierFormat(&quot;lastName = 'Smith'&quot;, null);// For the conversion specification %@, you don't use quotesargs.removeAllElements();args.addElement(&quot;Jones&quot;);EOQualifier.qualifierWithQualifierFormat(&quot;lastName = %@&quot;, args);</pre>		</blockquote>		<br>		<p>Typically format strings include only two data types: strings and numbers. Single-quoted or double-quoted strings correspond to String objects in the argument array, non-quoted numbers correspond to Numbers, and non-quoted strings are keys. You can get around this limitation by performing explicit casting.</p>		<p>The operators you can use in constructing qualifiers are =, ==, !=, &lt;, &gt;, &lt;=, &gt;=, &quot;like&quot;, and &quot;caseInsensitiveLike&quot;. The <b>like</b> and <b>caseInsensitiveLike</b> operators can be used with wildcards to perform pattern matching, as described in <a href="#BBIBIBAB">&quot;Using Wildcards and the like Operator&quot; on page 99</a>.</p>		<br>		<a name="BCCDHDCI"></a>		<h2>Checking for NULL Values</h2>		<p>To construct a qualifier that fetches rows matching NULL, use either of the approaches shown in the following example:</p>		<blockquote>			<pre>NSMutableArray args = new NSMutableArray();// Approach 1EOQualifier.qualifierWithQualifierFormat(&quot;bonus = nil&quot;, null);// Approach 2args.addElement(NullValue.nullValue());EOQualifier.qualifierWithQualifierFormat(&quot;bonus = %@&quot;, args);</pre>		</blockquote>		<br>		<br>		<a name="BBIBIBAB"></a>		<h2>Using Wildcards and the like Operator</h2>		<p>When you use the <b>like</b> or <b>caseInsensitiveLike</b> operator in a qualifier expression, you can use the wildcard characters * and ? to perform pattern matching, for example:</p>		<blockquote>			<pre>@&quot;lastName like 'Jo*'&quot;</pre>		</blockquote>		<br>		<p>matches Jones, Johnson, Jolsen, Josephs, and so on.</p>		<p>The ? character just matches a single character, for example:</p>		<blockquote>			<pre>@&quot;lastName like 'Jone?'&quot;</pre>		</blockquote>		<br>		<p>matches Jones.</p>		<p>The asterisk character (*) is only interpreted as a wildcard in expressions that use the <b>like</b> or <b>caseInsensitiveLike</b> operator. For example, in the following statement, the character * is treated as a literal value, not as a wildcard:</p>		<blockquote>			<pre>&quot;lastName = 'Jo*'&quot;</pre>		</blockquote>		<br>		<br>		<a name="BCCDDGCJ"></a>		<h2>Using Selectors in Qualifier Expressions</h2>		<p>The format strings you use to initialize a qualifier can include methods. The parser recognizes an unquoted string followed by a colon (such as <b>myMethod:</b>) as a method. For example:</p>		<blockquote>			<pre>point1 isInside: areafirstName isAnagramOfString: &quot;Computer&quot;</pre>		</blockquote>		<br>		<p>Methods specified in a qualifier are parsed and applied only in memory; that is, they can't be used in to qualify fetches in a database.</p>		<br>		<a name="BCCBHHGC"></a>		<h2>Using EOQualifier's Subclasses</h2>		<p>You rarely need to explicitly create an instance of EOAndQualifier, EOOrQualifier, or EONotQualifier. However, you may want to create instances of EOKeyValueQualifier and EOKeyComparisionQualifier. The primary advantage of this is that it lets you exercise more control over how the qualifier is constructed.</p>		<p>If you want to explicitly create a qualifier subclass, you can do it using code such as the following excerpt, which uses EOKeyValueQualifier to select all objects whose &quot;isOut&quot; key is equal to 1 (meaning <code>true</code>)<code></code>. In the excerpt, the qualifier is used to filter an in-memory array.</p>		<blockquote>			<pre>// Create the qualifierEOQualifier qual = new EOKeyValueQualifier(&quot;isOut&quot;, EOQualifier.QualifierOperatorEqual,    new Integer(1));// Filter an array and return it return Qualifier.filteredVectorWithQualifier(allRentals(), qual);</pre>		</blockquote>		<br>		<p>filteredArrayWithQualifier is a method that returns an array containing objects from the provided array that match the provided qualifier.</p>		<br>		<a name="BCCDDGCH"></a>		<h2>Creating Subclasses</h2>		<p>A custom subclass of EOQualifier must implement the EOQualifierEvaluation interface if they are to be evaluated in memory.</p>		<p>&copy; 2001 Apple Computer, Inc. (Last Published April 19, 2001)</p>		<br>		<a href="../../EOControlTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <!-- start of footer -->		<!--#include virtual="/includes/framesetfooter" -->		<!-- end of footer -->	</body></html>