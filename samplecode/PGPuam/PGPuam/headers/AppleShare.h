/* 	File:		AppleShare.h  	Contains:	Public Header file for the AppleShare Client API (AFP Protocol)  	Version:	3.7  	DRI:		Leland Wallace  	Copyright:	© 1997 by Apple Computer, Inc., all rights reserved.  	Warning:	*** APPLE INTERNAL USE ONLY *** 				This file may contain unreleased API's  	BuildInfo:	Built by:			Leland Wallace 				With Interfacer:	3.0d3   (PowerPC native) 				From:				AppleShare.i 					Revision:		4 					Dated:			2/03/98 					Last change by:	law 					Last comment:	¥ Moved the SMB insert/remove calls into the public header.  	Bugs:		Report bugs to Radar component "System Interfaces", "Latest" 				List the version information (from above) in the Problem Description. */#ifndef __APPLESHARE__#define __APPLESHARE__#ifndef __CONDITIONALMACROS__#include <ConditionalMacros.h>#endif#ifndef __MIXEDMODE__#include <MixedMode.h>#endif#ifndef __DEVICES__#include <Devices.h>#endif#ifndef __APPLETALK__#include <AppleTalk.h>#endif#ifndef __OPENTRANSPORT__#include <OpenTransport.h>#endif#ifndef __OPENTPTINTERNET__#include <OpenTptInternet.h>#endif#ifndef __OPENTPTAPPLETALK__#include <OpenTptAppleTalk.h>#endif#if PRAGMA_ONCE#pragma once#endif#ifdef __cplusplusextern "C" {#endif#if PRAGMA_IMPORT#pragma import on#endif#if PRAGMA_STRUCT_ALIGN	#pragma options align=mac68k#elif PRAGMA_STRUCT_PACKPUSH	#pragma pack(push, 2)#elif PRAGMA_STRUCT_PACK	#pragma pack(2)#endif/*	-------------------------------------------------------------------------	csCodes	------------------------------------------------------------------------- *//* for PBControl calls*/enum {	afpGetAttnRoutine			= 252,							/*	Get the default AFP Attention routine*/	dsOpenSession				= 244,							/*	Open an AFP session to the server*/	dsGetStatus					= 243,							/*	Send a GetSrvrInfo request to the server*/	dsSendRequest				= 240,							/*	Send an AFP command to the server*/	dsCloseSession				= 237,							/*	Close the specified session*/	dsCloseAll					= 232,							/*	Close all sessions*/																/* these will not be needed after Client 3.8	*/	AFPInsSessMemBlk			= 246,							/* insert the SMB into the drviers Queue	*/	AFPRemSessMemBlk			= 245							/* remove the SMB from the drviers Queue	*/};/* for PBStatus calls*/enum {	afpGetFSID					= 127,							/*	returns the File System ID	*/	afpSVolInfo					= 124,							/* 	returns basic info about the server volume (address, servername, username...)*/	afpXGetVolInfo				= 121,							/*	returns extended info about the volume (server time offset, volume grade...)*/	dsGetXPortInfo				= 236							/*	returns information about the transport used for the given session*/};/*	-------------------------------------------------------------------------	Data Stream Parameter Block	------------------------------------------------------------------------- */typedef CALLBACK_API( void , DSIOCompletionProcPtr )(void *pb);/*	WARNING: DSIOCompletionProcPtr uses register based parameters under classic 68k			 and cannot be written in a high-level language without 			 the help of mixed mode or assembly glue.*/typedef REGISTER_UPP_TYPE(DSIOCompletionProcPtr) 				DSIOCompletionUPP;/* csCode = dsSendRequest*/struct DSWritePB {	UInt32 							dsWriteDataOffset;			/* <- specifies the write offset in the data*/	UInt32 							dsWriteBufferSize;			/* <- size of the data to be written*/	Byte *							dsWriteBuffer;				/* <- ptr to data to be written*/};typedef struct DSWritePB DSWritePB;/* csCode = dsGetStatus*/struct DSGetStatusPB {	OTAddress *						dsGSSrvrAddress;			/* <- OT Address of server to GetStatus() from (you also need to fill in the reply buffer & size)*/	const char *					dsGSEpString;				/* <- endpoint string for the connection (nil == default)		*/};typedef struct DSGetStatusPB DSGetStatusPB;/* csCode = dsOpenSession*/struct DSOpenPB {	AttnRoutineUPP 					dsOSAttnRoutine;			/* <- Custom attention routine (nil == default)*/	OTAddress *						dsOSSrvrAddress;			/* <- OT Address of server to open a session to*/	Ptr 							dsOSSessionBlock;			/* <- ptr to the SMB; memory reserved for the session.*/	const char *					dsOSEpString;				/* <- endpoint string for the connection (nil == default)		*/};typedef struct DSOpenPB DSOpenPB;enum {	SMBSize						= 2560							/* size of the session memory block*/};struct DSParamBlock {	QElem *							qLink;						/* - standard header stuff*/	short 							qType;						/* - standard header stuff*/	short 							ioTrap;						/* - standard header stuff*/	Ptr 							ioCmdAddr;					/* - standard header stuff*/	DSIOCompletionUPP 				ioCompletion;				/* <- completion rtn point*/	OSErr 							ioResult;					/* -> result from Async call*/	long 							cmdResult;					/* -> result from the Server for the AFP Cmd*/	short 							ioVRefNum;					/* - standard header stuff */	short 							ioCRefNum;					/* <- RefNum of the ".AFPTranslator"*/	short 							csCode;						/* <- DS Command code*/	short 							dsTimeout;					/* <- ASP - How long to wait before retrying request, TCP - resv for internal use*/	short 							dsReserved1;				/* -  resv for internal use*/	long 							dsRetry;					/* <- ASP - How many times to retry the request, TCP - unused*/	UInt16 							dsReserved2;				/* -  resv for internal use*/	short 							dsSessRefNum;				/* <- AFP Session number*/	short 							dsReserved3;				/* -  resv for internal use*/	short 							dsCmdBufferSize;			/* <- size of the command buffer*/	UInt8 *							dsCmdBuffer;				/* <- ptr to the command buffer*/	UInt32 							dsReplyBufferSize;			/* <- size of the reply buffer*/	UInt8 *							dsReplyBuffer;				/* <- ptr to the reply buffer*/	union {		DSOpenPB 						open;		DSWritePB 						write;		DSGetStatusPB 					status;	} 								csParam;};typedef struct DSParamBlock DSParamBlock;typedef DSParamBlock *					DSParamBlockPtr;struct DSXPortInfo {	long 							dsXPortType;				/* Transport Type (kASPXport, kTCPXport)*/	short 							dsXPortSessRefNum;			/* Session ref number for ASP or TCP*/	union {		InetAddress 					ipAddr;		DDPAddress 						ddpAddr;	} 								addr;};typedef struct DSXPortInfo DSXPortInfo;typedef DSXPortInfo *					DSXPortInfoPtr;/* definitions for 	dsXPortType */enum {	kASPXport					= 0x00,	kTCPXport					= 0x01};struct GetVolSessInfoRec {	short 							sessAFPVersion;				/*	AFP version number: */	short 							sessReferenceNumber;		/*	AFP session reference number*/	short 							sessAFPVolID;				/*	AFP volume identifier*/	OTAddress *						sessServerAddress;			/*	server internet address*/	short 							sessUAMType;				/*	user authentication method*/	StringPtr 						sessUserNamePtr;			/*	ptr to user name string*/	Ptr 							sessVolIconPtr;				/*	ptr to server volume icon/mask*/	StringPtr 						sessWhereStringPtr;			/*	ptr to "where" information string, shown in the Get Info window*/};typedef struct GetVolSessInfoRec GetVolSessInfoRec;typedef GetVolSessInfoRec *				GetVolSessInfoRecPtr;enum {	kAFPVersion11				= 1,	kAFPVersion20				= 2,	kAFPVersion21				= 3,	kAFPVersion22				= 4};enum {	kNoUserAuth					= 1,							/*	'No User Authent' UAM (Guest)*/	kCleartextAuth				= 2,							/*	'Cleartxt Passwrd' UAM 	(types 2 & 3 will be automatically upgraded to 6)*/	kRandnumAuth				= 3,							/*	'Randnum Exchange' UAM */	k2WayRandnumAuth			= 6,							/*	'2-Way Randnum exchange' */	kMinCustomUAM				= 128							/*	Minimum type value for a Custom UAM*/};struct GetVolSessInfoPB {	QElemPtr 						qLink;						/*  -  standard header stuff*/	short 							qType;						/*  -  standard header stuff*/	short 							ioTrap;						/*  -  standard header stuff*/	Ptr 							ioCmdAddr;					/*  -  standard header stuff*/	IOCompletionUPP 				ioCompletion;				/* <-  completion rtn pointer*/	OSErr 							ioResult;					/*  -> result from Async call*/	StringPtr 						ioNamePtr;					/*  -  standard header stuff*/	short 							ioVRefNum;					/*  -  standard header stuff*/	short 							ioRefNum;					/* <-  RefNum of the ".AFPTranslator"*/	short 							csCode;						/* <-  allways afpSVolInfo*/	Ptr 							vcbPtr;						/* <-  pointer to the VCB that you want info about*/	GetVolSessInfoRecPtr 			sessInfoBuffer;				/* <-  pointer to the GetVolSessInfoRec to be filled*/	long 							sessInfoSize;				/* <-  size of the GetVolSessInfoRec*/	long 							actSessInfoSize;			/*  -> actual size of the data returned*/};typedef struct GetVolSessInfoPB GetVolSessInfoPB;typedef GetVolSessInfoPB *				GetVolSessInfoPBPtr;/* the AFPInsSessMemBlk & AFPRemSessMemBlk  calls are currently (pre Client 3.8) required   when opening or closing a session. Make the AFPInsSessMemBlk call after the dsOpenSession   call succeeds (or returns afpAuthContinue), with the same dsOSSessionBlock that you   sent into dsOpenSession. You need to call AFPRemSessMemBlk with that same pointer after   calling dsCloseSession or dsCloseAll. In Client 3.8 these will be called for you   during the dsOpenSession & dsCloseSession calls.*/struct AFPInsRemSMBParam {	QElemPtr 						qLink;						/*  -  standard header stuff	*/	short 							qType;						/*  -  standard header stuff	*/	short 							ioTrap;						/*  -  standard header stuff	*/	Ptr 							ioCmdAddr;					/*  -  standard header stuff	*/	IOCompletionUPP 				ioCompletion;				/* <-  completion rtn pointer	*/	OSErr 							ioResult;					/*  -> result from Async call	*/	StringPtr 						ioNamePtr;					/*  -  standard header stuff	*/	short 							ioVRefNum;					/*  -  standard header stuff	*/	short 							ioRefNum;					/* <-  RefNum of the ".AFPTranslator"			*/	short 							csCode;						/* <-  AFPInsSessMemBlk or AFPRemSessMemBlk 	*/	Ptr 							smbPtr;						/* <-> pointer to the SMB to insert or remove	*/};typedef struct AFPInsRemSMBParam AFPInsRemSMBParam;typedef AFPInsRemSMBParam *				AFPInsRemSMBPBPtr;/* Server Info Buffer returned from the dsGetStatus call 	*//* you should make your buffer at least 1024 bytes in size.	*//* a partial definition of the AFPSrvrInfo data structure (the fixed portion) */struct AFPSrvrInfo {	short 							fMachineOffset;	short 							fVerCountOffset;	short 							fUAMCountOffset;	short 							fIconOffset;	short 							fFlags;	unsigned char 					fSrvrName[2];};typedef struct AFPSrvrInfo AFPSrvrInfo;/* definitions for the fFlags word	*/enum {	srvSCopyFile				= 0,							/* Server supports FPCopyFile call*/	srvSChangePswd				= 1,							/* Server supports FPChangePassword call*/	srvNoPswdSave				= 2,							/* Workstation should not save password*/	srvSServerMsgs				= 3,							/* Server supports server messages*/	srvSSrvrSig					= 4,							/* Server supports Server Signatures  (AFP 2.2)*/	srvSupportsTCP				= 5,							/* Server may be connected to via TCP/IP (AFP 2.2)*/	srvSNotification			= 6								/* Server will send notifications (AFP 2.2)*/};/* Gestalt selectors & definitions	(will go into gestalt.h soon) */#if 0enum {	gestaltAFPClient			= FOUR_CHAR_CODE('afps'),	gestaltAFPClientVersionMask	= 0x0000FFFF,					/* lo word is version*/	gestaltAFPClient3_5			= 1,	gestaltAFPClient3_6			= 2,	gestaltAFPClient3_6_1		= 3,	gestaltAFPClient3_6_2		= 4,	gestaltAFPClient3_6_3		= 5,							/* including 3.6.4, 3.6.5*/	gestaltAFPClient3_7			= 6,							/* including 3.7.1*/	gestaltAFPClient3_7_2		= 7,							/* including 3.7.3*/	gestaltAFPClient3_8			= 8,	gestaltAFPClientCfgMask		= (long)0xFFFF0000,				/* hi word is config*/	gestaltAFPClientCfgRsrc		= 16,							/* Client uses config resources*/	gestaltAFPClientUAMv2		= 28,							/* Client supports the 2.0 UAM interfaces*/	gestaltAFPClientSupportsIP	= 29,							/* Client supports AFP over TCP/IP*/	gestaltAFPClientVMUI		= 30,							/* Client can put up UI from the PBVolMount trap*/	gestaltAFPClientMultiReq	= 31							/* Client supports multiple outstanding requests*/};#endif																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandSync(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandSync(DSParamBlockPtr paramBlock)																							ONEWORDINLINE(0xA004);																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandAsync(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandAsync(DSParamBlockPtr paramBlock)																							ONEWORDINLINE(0xA404);/* use only for dsCloseAll	*/																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandImmediate(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandImmediate(DSParamBlockPtr paramBlock)																							ONEWORDINLINE(0xA204);#if PRAGMA_STRUCT_ALIGN	#pragma options align=reset#elif PRAGMA_STRUCT_PACKPUSH	#pragma pack(pop)#elif PRAGMA_STRUCT_PACK	#pragma pack()#endif#ifdef PRAGMA_IMPORT_OFF#pragma import off#elif PRAGMA_IMPORT#pragma import reset#endif#ifdef __cplusplus}#endif#endif /* __APPLESHARE__ */