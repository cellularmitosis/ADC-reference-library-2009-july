<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>The Objective-C 2.0 Programming Language: Remote Messaging</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Remote Messaging"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001163-CH21" title="Remote Messaging"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ObjectiveCLanguage-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000856" target="_top">Objective-C Language</a> &gt; <a href="../Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163-CH1-SW2">The Objective-C 2.0 Programming Language</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocThreading.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocCPlusPlus.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001163-CH21-SW1" title="Remote Messaging"></a><h1>Remote Messaging</h1><p><a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_409"></a>Like most other programming languages, Objective-C was initially designed for programs that are executed as a single process in a single address space.</p><p>Nevertheless, the object-oriented model, where communication takes place between relatively self-contained units through messages<a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_410"></a> that are resolved at runtime, would seem well suited for interprocess communication as well. It’s not hard to imagine Objective-C messages between objects that reside in different address spaces (that is, in different tasks) or in different threads of execution of the same task.</p><p>For example, in a typical server-client interaction, the client task might send its requests to a designated object in the server, and the server might target specific client objects for the notifications and other information it sends. Or imagine an interactive application that needs to do a good deal of computation to carry out a user command. It could simply display a dialog telling the user to wait while it was busy, or it could isolate the processing work in a subordinate task, leaving the main part of the application free to accept user input. Objects in the two tasks would communicate through Objective-C messages.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ocRemoteMessaging.html#//apple_ref/doc/uid/TP30001163-CH21-TPXREF154">Distributed Objects</a>
				
			<br/>
			
        
			
			
				<a href="ocRemoteMessaging.html#//apple_ref/doc/uid/TP30001163-CH21-TPXREF155">Language Support</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001163-CH21-103681" title="Distributed Objects"></a><a name="//apple_ref/doc/uid/TP30001163-CH21-TPXREF154" title="Distributed Objects"></a><h2>Distributed Objects</h2><p>Remote messaging in Objective-C requires a runtime system that can establish connections between objects in different address spaces, recognize when a message is intended for an object in a remote address space, and transfer data from one address space to another. It must also mediate between the separate schedules of the two tasks; it has to hold messages until their remote receivers are free to respond to them.</p><p>Cocoa includes a <strong>distributed objects</strong><a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_411"></a> architecture that is essentially this kind of extension to the runtime system. Using distributed objects, you can send Objective-C messages to objects in other tasks or have messages executed in other threads of the same task. (When remote messages are sent between two threads of the same task, the threads are treated exactly like threads in different tasks.) Note that Cocoa’s distributed objects system is built on top of the runtime system; it doesn’t alter the fundamental behavior<a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_412"></a> of your Cocoa objects.</p><p>To send a remote message, an application must first establish a connection with the remote receiver. Establishing the connection gives the application a proxy<a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_413"></a> for the remote object in its own address space. It then communicates with the remote object through the proxy. The proxy assumes the identity of the remote object; it has no identity of its own. The application is able to regard the proxy as if it were the remote object; for most purposes, it is the remote object.</p><p>Remote messaging is illustrated in <span class="content_text"><a href="ocRemoteMessaging.html#//apple_ref/doc/uid/TP30001163-CH21-103717">Figure 12-1</a></span>, where object A communicates with object B through a proxy, and messages for B wait in a queue until B is ready to respond to them:</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH21-103717" title="Figure 12-1Remote Messages"></a><a name="//apple_ref/doc/uid/TP30001163-CH21-BCIEGADD" title="Figure 12-1Remote Messages"></a><p><strong>Figure 12-1&nbsp;&nbsp;</strong>Remote Messages</p><img src = "../Art/messageproxy.gif" alt = "" width="438" height="108"></div><br/><p>The sender and receiver are in different tasks and are scheduled independently of each other. So there’s no guarantee that the receiver is free to accept a message when the sender is ready to send it. Therefore, arriving messages are placed in a queue and retrieved at the convenience of the receiving application.</p><p>A proxy doesn’t act on behalf of the remote object or need access to its class. It isn’t a copy of the object, but a lightweight substitute for it. In a sense, it’s transparent; it simply passes the messages it receives on to the remote receiver and manages the interprocess communication. Its main function is to provide a local address for an object that wouldn’t otherwise have one. A proxy isn’t fully transparent, however. For instance, a proxy doesn’t allow you to directly set and get an object’s instance variables.</p><p>A remote receiver is typically anonymous. Its class is hidden inside the remote application. The sending application doesn’t need to know how that application is designed or what classes it uses. It doesn’t need to use the same classes itself. All it needs to know is what messages the remote object responds to.</p><p>Because of this, an object that’s designated to receive remote messages advertises its interface in a formal protocol. Both the sending and the receiving application declare the protocol—they both import the same protocol declaration. The receiving application declares it because the remote object must conform to the protocol. The sending application declares it to inform the compiler about the messages it sends and because it may use the <code>conformsToProtocol:</code><a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_414"></a> method and the <code>@protocol()</code><a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_415"></a><a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_416"></a> directive to test the remote receiver. The sending application doesn’t have to implement any of the methods in the protocol; it declares the protocol only because it initiates messages to the remote receiver.</p><p>The distributed objects architecture, including the <code><a href="../../../Reference/Foundation/Classes/NSProxy_Class/Reference/Reference.html#//apple_ref/occ/cl/NSProxy" target="_top">NSProxy</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSConnection_Class/Reference/Reference.html#//apple_ref/occ/cl/NSConnection" target="_top">NSConnection</a></code> classes, is documented in the Foundation framework reference and <em><a href="../../DistrObjects/index.html#//apple_ref/doc/uid/10000102i" target="_top">Distributed Objects Programming Topics</a></em>.</p><a name="//apple_ref/doc/uid/TP30001163-CH21-103764" title="Language Support"></a><a name="//apple_ref/doc/uid/TP30001163-CH21-TPXREF155" title="Language Support"></a><h2>Language Support</h2><p>Remote messaging raises not only a number of intriguing possibilities for program design, it also raises some interesting issues for the Objective-C language. Most of the issues are related to the efficiency of remote messaging and the degree of separation that the two tasks should maintain while they’re communicating with each other.</p><p>So that programmers can give explicit instructions about the intent of a remote message, Objective-C defines six type qualifiers that can be used when declaring methods inside a formal protocol:</p><ul class="simple"><li><p><code>oneway</code></p></li><li><p><code>in</code></p></li><li><p><code>out</code></p></li><li><p><code>inout</code></p></li><li><p><code>bycopy</code></p></li><li><p><code>byref</code></p></li></ul><p>These modifiers are restricted to formal protocols; they can’t be used inside class and category declarations. However, if a class or category adopts a protocol, its implementation of the protocol methods can use the same modifiers that are used to declare the methods.</p><p>The following sections explain how these modifiers are used.</p><a name="//apple_ref/doc/uid/TP30001163-CH21-103850" title="Synchronous and Asynchronous Messages"></a><a name="//apple_ref/doc/uid/TP30001163-CH21-TPXREF156" title="Synchronous and Asynchronous Messages"></a><h3>Synchronous and Asynchronous Messages</h3><p>Consider first a method with just a simple return value:</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)canDance;<span></span></pre></td></tr></table></div><p>When a <code>canDance</code> message is sent to a receiver in the same application, the method is invoked and the return value provided directly to the sender. But when the receiver is in a remote application, two underlying messages are required—one message to get the remote object to invoke the method, and the other message to send back the result of the remote calculation. This is illustrated in the figure below:</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH21-103885" title="Figure 12-2Round-Trip Message"></a><a name="//apple_ref/doc/uid/TP30001163-CH21-BCIDEFID" title="Figure 12-2Round-Trip Message"></a><p><strong>Figure 12-2&nbsp;&nbsp;</strong>Round-Trip Message</p><img src = "../Art/messagingproxyreturn.gif" alt = "" width="434" height="97"></div><br/><p>Most remote messages are, at bottom, two-way (or “round trip”) remote procedure calls<a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_417"></a> (RPCs) like this one. The sending application waits for the receiving application to invoke the method, complete its processing, and send back an indication that it has finished, along with any return information requested. Waiting for the receiver to finish, even if no information is returned, has the advantage of coordinating the two communicating applications, of keeping them both “in sync.” For this reason, round-trip messages are often called <strong>synchronous</strong><a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_418"></a>. Synchronous messages are the default.</p><p>However, it’s not always necessary or a good idea to wait for a reply. Sometimes it’s sufficient simply to dispatch the remote message and return, allowing the receiver to get to the task when it can. In the meantime, the sender can go on to other things. Objective-C provides a return type modifier, <code>oneway</code>, to indicate that a method is used only for <strong>asynchronous</strong><a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_419"></a> messages:</p><div class="codesample"><table><tr><td scope="row"><pre>- (oneway void)waltzAtWill;<span></span></pre></td></tr></table></div><p>Although <code>oneway</code> is a type qualifier (like <code>const</code>) and can be used in combination with a specific type name, such as <code>oneway float</code> or <code>oneway id</code>, the only such combination that makes any sense is <code>oneway void</code>. An asynchronous message can’t have a valid return value.</p><a name="//apple_ref/doc/uid/TP30001163-CH21-103959" title="Pointer Arguments"></a><a name="//apple_ref/doc/uid/TP30001163-CH21-TPXREF157" title="Pointer Arguments"></a><h3>Pointer Arguments</h3><p>Next, consider methods that take pointer arguments<a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_420"></a>. A pointer can be used to pass information to the receiver by reference. When invoked, the method looks at what’s stored in the address it’s passed.</p><div class="codesample"><table><tr><td scope="row"><pre>- setTune:(struct tune *)aSong<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    tune = *aSong;<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The same sort of argument can also be used to return information by reference. The method uses the pointer to find where it should place information requested in the message.</p><div class="codesample"><table><tr><td scope="row"><pre>- getTune:(struct tune *)theSong<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    *theSong = tune;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The way the pointer is used makes a difference in how the remote message is carried out. In neither case can the pointer simply be passed to the remote object unchanged; it points to a memory location in the sender’s address space and would not be meaningful in the address space of the remote receiver. The runtime system for remote messaging must make some adjustments behind the scenes.</p><p>If the argument is used to pass information by reference, the runtime system must dereference the pointer, ship the value it points to over to the remote application, store the value in an address local to that application, and pass that address to the remote receiver.</p><p>If, on the other hand, the pointer is used to return information by reference, the value it points to doesn’t have to be sent to the other application. Instead, a value from the other application must be sent back and written into the location indicated by the pointer.</p><p>In the first case, information is passed on the first leg of the round trip. In the second case, information is returned on the second leg of the round trip. Because these cases result in very different actions on the part of the runtime system for remote messaging, Objective-C provides type modifiers that can clarify the programmer’s intention:</p><ul class="spaceabove"><li class="li"><p>The type modifier<a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_421"></a><code>in</code> indicates that information is being passed in a message:</p><div class="codesample"><table><tr><td scope="row"><pre>- setTune:(in struct tune *)aSong;<span></span></pre></td></tr></table></div></li><li class="li"><p>The modifier <code>out</code> indicates that an argument is being used to return information by reference:</p><div class="codesample"><table><tr><td scope="row"><pre>- getTune:(out struct tune *)theSong;<span></span></pre></td></tr></table></div></li><li class="li"><p>A third modifier, <code>inout</code>, indicates that an argument is used both to provide information and to get information back:</p><div class="codesample"><table><tr><td scope="row"><pre>- adjustTune:(inout struct tune *)aSong;<span></span></pre></td></tr></table></div></li></ul><p>The Cocoa distributed objects system takes <code>inout</code> to be the default modifier for all pointer arguments except those declared <code>const</code>, for which <code>in</code> is the default. <code>inout</code> is the safest assumption but also the most time-consuming since it requires passing information in both directions. The only modifier that makes sense for arguments passed by value (non-pointers) is <code>in</code>. While <code>in</code> can be used with any kind of argument, <code>out</code> and <code>inout</code> make sense only for pointers.</p><p>In C, pointers are sometimes used to represent composite values. For example, a string is represented as a character pointer (<code>char *</code>). Although in notation and implementation there’s a level of indirection here, in concept there’s not. Conceptually, a string is an entity in and of itself, not a pointer to something else.</p><p>In cases like this, the distributed objects system automatically dereferences the pointer and passes whatever it points to as if by value. Therefore, the <code>out</code> and <code>inout</code> modifiers make no sense with simple character pointers. It takes an additional level of indirection in a remote message to pass or return a string by reference:</p><div class="codesample"><table><tr><td scope="row"><pre>- getTuneTitle:(out char **)theTitle;<span></span></pre></td></tr></table></div><p>The same is true of objects:</p><div class="codesample"><table><tr><td scope="row"><pre>- adjustRectangle:(inout Rectangle **)theRect;<span></span></pre></td></tr></table></div><p>These conventions are enforced at runtime, not by the compiler.</p><a name="//apple_ref/doc/uid/TP30001163-CH21-104225" title="Proxies and Copies"></a><a name="//apple_ref/doc/uid/TP30001163-CH21-TPXREF158" title="Proxies and Copies"></a><h3>Proxies and Copies</h3><p>Finally, consider a method that takes an object as an argument:</p><div class="codesample"><table><tr><td scope="row"><pre>- danceWith:(id)aPartner;<span></span></pre></td></tr></table></div><p>A <code>danceWith:</code> message passes an object <code>id</code> to the receiver. If the sender and the receiver are in the same application, they would both be able to refer to the same <em>aPartner</em> object.</p><p>This is true even if the receiver is in a remote application, except that the receiver needs to refer to the object through a proxy (since the object isn’t in its address space). The pointer that <code>danceWith:</code> delivers to a remote receiver is actually a pointer to the proxy. Messages sent to the proxy would be passed across the connection to the real object and any return information would be passed back to the remote application.</p><p>There are times when proxies may be unnecessarily inefficient, when it’s better to send a copy of the object to the remote process so that it can interact with it directly in its own address space. To give programmers a way to indicate that this is intended, Objective-C provides a <code>bycopy</code> type modifier:</p><div class="codesample"><table><tr><td scope="row"><pre>- danceWith:(bycopy id)aClone;<span></span></pre></td></tr></table></div><p><code>bycopy</code> can also be used for return values:</p><div class="codesample"><table><tr><td scope="row"><pre>- (bycopy)dancer;<span></span></pre></td></tr></table></div><p>It can similarly be used with <code>out</code> to indicate that an object returned by reference should be copied rather than delivered in the form of a proxy:</p><div class="codesample"><table><tr><td scope="row"><pre>- getDancer:(bycopy out id *)theDancer;<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH21-SW2" title="Note"></a><p><strong>Note:</strong>&nbsp;When a copy of an object is passed to another application, it cannot be anonymous. The application that receives the object must have the class of the object loaded in its address space.</p></div><p><code>bycopy</code> makes so much sense for certain classes—classes that are intended to contain a collection of other objects, for instance—that often these classes are written so that a copy is sent to a remote receiver, instead of the usual reference. You can override this behavior<a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_422"></a> with <code>byref</code>, however, thereby specifying that objects passed to a method or objects returned from a method should be passed or returned by reference. Since passing by reference is the default behavior for the vast majority of Objective-C objects, you will rarely, if ever, make use of the <code>byref</code> keyword.</p><p>The only type that it makes sense for <code>bycopy</code> or <code>byref</code> to modify is an object, whether dynamically typed <code>id</code> or statically typed by a class name.</p><p>Although <code>bycopy</code> and <code>byref</code> can’t be used inside class and category declarations, they can be used within formal protocols. For instance, you could write a formal protocol <code>foo</code> as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>@Protocol foo<span></span></pre></td></tr><tr><td scope="row"><pre>- (bycopy)array;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>A class or category can then adopt your protocol <code>foo</code>. This allows you to construct protocols so that they provide “hints” as to how objects should be passed and returned by the methods described by the protocol.<a name="//apple_ref/doc/uid/TP30001163-CH21-DontLinkElementID_423"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocThreading.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocCPlusPlus.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocRemoteMessaging.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocRemoteMessaging.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocRemoteMessaging.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>