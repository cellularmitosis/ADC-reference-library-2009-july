<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About DrawSprocket (GameSprockets)</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" ="A" NAME="HEADING86"></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="GameSprockets-85.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="GameSprockets-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="GameSprockets-318.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="GameSprockets-87.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<FONT SIZE="-1"><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="GameSprockets-2.html"><B>Apple Game Sprockets Guide</B></A> / <BR><DD><A HREF="GameSprockets-85.html"><B>Chapter 2 - DrawSprocket</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME="HEADING86-0"></A>
<H1>About DrawSprocket</H1>
 <A NAME="MARKER-2-7"></A>DrawSprocket provides an application interface that lets your game easily access and manipulate system display resources. The features supported by DrawSprocket include the following:<P>
<UL>
<LI>Display configuration: convenient, optimized selection of display devices and resolution and pixel depth
<LI>Blanking window: a convenient way to hide and show the desktop, menu bar, and other system tools such as the control strip
<LI>Double- or triple-buffered drawing: page flipping when supported by the video hardware or software buffering when page flipping is not available
<LI>Display fading: sophisticated gamma fading capability
<LI>Overlays and underlays: creation of foreground and background images
<LI>Back buffer scaling: support for pixel scaling with optional bilinear interpolation
<LI>Color-table management: easy retrieval and modification of entries in color lookup tables
<LI>Frame skipping: support for evening the frame display rate across your game
<LI>Debugging support: access to the screen and system resources at all times, even when the screen is blanked and faded<P>
</UL>
 When your game uses DrawSprocket, it becomes the "owner" of the system display resources. All video devices in the system are hidden, and you can freely change pixel depths, color palettes, and screen resolutions at will.<P>
<A NAME="HEADING86-12"></A>
<H2>Display Configuration</H2>
 <A NAME="MARKER-2-8"></A><A NAME="MARKER-2-9"></A>An individual Macintosh computer can simultaneously support more than one monitor, and many monitors can support several different combinations of resolution (horizontal and vertical timing of a display mode) and <B>pixel depth</B> (number of bits per pixel). In DrawSprocket, each combination of resolution and pixel depth is known as a context. At any one time, a given system may allow one or more graphics devices, each with its associated contexts, as well as other characteristics such as color support, hardware acceleration, and display buffering.<P>
 Your game, on the other hand, has its own display requirements and preferences, and also may want to take advantage of special display features when they are available. An important aspect of DrawSprocket is that it coordinates your game's needs with the currently supported display characteristics and features of the user's system. <P>
 <A NAME="MARKER-2-10"></A>The key to this selection system is the <B>context attributes structure</B>, a structure that both your game and DrawSprocket use to pass information to each other. You use certain fields of the context attributes structure to request a context of a given size (width and height, in pixels), pixel depth, color capabilities, and so on. DrawSprocket then finds the closest match to your requests using the <CODE>DSPFindBestContext</CODE> function. Alternatively, you can use other routines to let the user or the game determine which context to use. Once a context is identified, you refer to it with the <CODE>DSpContextReference</CODE> type. <P>
 See <A HREF="GameSprockets-97.html#MARKER-9-98">"Context Attributes Structure" (page 2-27)</A> for descriptions of the structure's fields. See <A HREF="GameSprockets-87.html#MARKER-9-28">"Choosing a Context" (page 2-12)</A> for examples of its use.<P>
<A NAME="HEADING86-17"></A>
<H2>Contexts and the Play State</H2>
 After you find a context that best suits your needs, you must reserve it before using it. Reserving a context for a display device tells that device to use a particular display depth and resolution. Once a context is reserved, all other contexts for the device become unavailable. When you are finished using a context you release it, making all contexts associated with the display available again. <P>
 When you reserve a context, its <B>play state </B>is initially inactive. In that play state, the context has no effect on the screen display. However, as soon as you make the play state active, the context's resolution, pixel depth, and other characteristics take effect. At that point, DrawSprocket also covers the entire display with a <B>blanking window,</B> which completely hides the desktop, menu bar, and other system adornments to provide a uniform background color for your game to draw over. <P>
 When your game is finished using a display, you can make the context's play state inactive. In that state, DrawSprocket removes the blanking window and restores the user's original display characteristics. See <A HREF="GameSprockets-95.html#MARKER-9-91">"Play State" (page 2-25)</A> for descriptions of a context's play states. <P>
 A context reference is not consistent across executions of your game. This means that every time your game executes you must relocate the best context for your game. DrawSprocket does provide calls to enable you to save a particular context description to disk and then attempt to restore it later. Restoration may fail if the user reconfigured the displays in the system. See the <CODE>DSpContext_Flatten</CODE> function <A HREF="GameSprockets-111.html#MARKER-9-115">(page 2-39)</A> for more information.<A NAME="MARKER-2-11"></A><P>
<A NAME="HEADING86-22"></A>
<H2>Page Flipping and Software Buffering</H2>
 <A NAME="MARKER-2-12"></A><A NAME="MARKER-2-13"></A>During execution your game does all its drawing to a <B>back buffer,</B> an offscreen buffer DrawSprocket draws into while another image buffer is being displayed. DrawSprocket transfers the completed offscreen images to the display in response to a <CODE>DSpContext_SwapBuffers</CODE> call. DrawSprocket supports page flipping, in which the back buffer DrawSprocket provides is a video page located in VRAM that can be displayed by the video controller in rotation with other VRAM pages. Page flipping is a very fast way change an entire graphics display without tearing artifacts, because the game only needs to tell the video controller to begin displaying the new page--the actual page data (which can be very large) does not need to be copied.<P>
 If page flipping is not available, or you have told DrawSprocket that you prefer not to use page flipping, the back buffer is located in DRAM. When the game tells DrawSprocket to make the buffer visible to the user, DrawSprocket copies it using a highly optimized blitter that is customized to your game's needs.<P>
 For both page flipping and software buffering, you can tell DrawSprocket to use double buffering or triple buffering during the execution of your game. With double buffering you have two buffers--one that is displayed and one that is hidden (used for rendering). With triple buffering you have three buffers--one that is displayed, and two that are hidden. Requests for page flipping and double or triple buffering are made in the context attributes structure passed in when you reserve a context for play.<P>
<A NAME="HEADING86-26"></A>
<H3>How Triple Buffering Works</H3>
 <A NAME="MARKER-2-14"></A>When the game is using double buffering and tells DrawSprocket to make the back buffer visible, you may want the game to begin drawing the next frame right away. If the game is fast enough, it could even be rendering while DrawSprocket is moving the back buffer to the display. But when DrawSprocket is drawing to the display, the back buffer is busy, so the game has to wait, wasting precious CPU cycles. You can request that, if DrawSprocket detects this occurring, it will throw another buffer into the available buffer queue, so that the game may begin rendering into it while the first back buffer is in use. This is called triple buffering.<P>
 The flip side of triple buffering is that the game may retrieve a back buffer (buffer #1), tell DrawSprocket to show it, retrieve a new back buffer (buffer #2), and then tell DrawSprocket to show buffer #2 before buffer #1 has been displayed. In this case, the game is rendering too fast for its own good and can introduce video lag. DrawSprocket can detect such a situation and will queue the buffer swap and drop the game back to double buffering. The next time the game retrieves the back buffer, all the buffers may be busy and the call may block (avoid blocking by using <CODE>DSpContext_IsBusy</CODE> before retrieving the back buffer).<P>
 A possible scenario is a game riding the edge between the need for double and triple buffering, which causes DrawSprocket to alternate between the two buffering methods. There is no performance penalty for this condition, and the transitions will not affect game performance. The net effect is that the game will always be triple buffered, because it will always be using the next available back buffer.<P>
 A side effect of running your game faster than the achievable display frame rate (and hence, faster than can be triple buffered) is that your game will always run two frames behind what the user sees. Consider what happens when you have two buffers queued for a display swap: a frame is currently visible on the display, the first queued buffer will be displayed at the next (first) VBL, and the second queued buffer will be displayed at the second VBL.<A NAME="MARKER-2-15"></A><P>
<A NAME="HEADING86-31"></A>
<H2><A NAME="MARKER-9-16"></A>Gamma Fading</H2>
 <A NAME="MARKER-2-17"></A>When a monitor switches resolution modes, there is typically a visible flash or flicker that can be annoying to the user. When your game starts it usually switches resolution modes, and when it quits it switches back. Depending on its features, your game might also switch modes during execution.<P>
 To hide the flicker, you can fade the display to black, make the switch, and then bring the display back to full intensity. A typical procedure for fading out is called <I>indexed fading,</I> in which you repeatedly draw the screen with all colors at proportionally lesser and lesser RGB intensities, reaching zero intensity over the course of a second or so. You then wait about half a second for the mode switch to take effect on the monitor, and fade the intensity back in.<P>
 DrawSprocket provides a facility to achieve a superior, more convenient, and more flexible fading process. Using the DrawSprocket functions, you can fade out one or all displays in the system and achieve a variety of interesting effects at the same time. The three functions--<CODE>DSpContext_FadeGamma</CODE>, <CODE>DSpContext_FadeGammaIn</CODE>, and <CODE>DSpContext_FadeGammaOut</CODE>--perform a gamma fade.<B> A gamma fade is a fade based on a gamma table, </B>which accounts for nonlinearities in the display's color response. With a gamma fade, bright colors won't remain visible after the darker colors have already disappeared, as can happen with indexed fading. <P>
 Because of its flexibility, you might want to use DrawSprocket's gamma fading for other transitions besides switches in resolution mode. The DrawSprocket gamma fade functions provides these advantages:<P>
<UL>
<LI>You can fade direct devices as well as indexed devices.
<LI>You can fade all the graphics devices in your system at once, or one at a time. 
<LI>When fading out, you don't have to fade to black. You can define any RGB color as the "zero intensity" color.
<LI>You can overdrive the gamma table by specifying an intensity greater than 100 percent. This feature is good for those blinding flashes that occur when a rocket detonates in the player's face.
<LI>You can automatically fade smoothly and gradually to zero intensity with a single call to <CODE>DSpContext_FadeGammaOut</CODE>, and fade smoothly back in with a second call to <CODE>DSpContext_FadeGammaIn</CODE>.
<LI>For more direct control over the fading process, you can make repeated calls to <CODE>DSpContext_FadeGamma</CODE> and manually control the amount of fade for each step.
<LI>By combining manual control with manipulation of the zero-intensity color, you can achieve special effects. For example, you could fade halfway to red and then the rest of the way to black. <P>
</UL>
 See the description of the <CODE>DSpContext_FadeGamma</CODE> function <A HREF="GameSprockets-120.html#MARKER-9-133">(page 2-45)</A> for more information. <A NAME="MARKER-2-18"></A><P>
<A NAME="HEADING86-44"></A>
<H2>Underlays, Overlays, and Transparency Masks</H2>
 <A NAME="MARKER-2-19"></A>An underlay is an image that is used as a background for the back buffer and is restored automatically whenever the back buffer is returned from <CODE>DSpContext_GetBackBuffer</CODE>. Typically, you use an underlay where you have a static background (or a background that may stay static for at least a few frames), such as in a sprite-based game, or in a scroller game where the background only moves when the player crosses a threshold near the edge of the screen.<P>
 <A NAME="MARKER-2-20"></A>An overlay is an image that is superimposed on the back buffer before it is displayed. This occurs during the call to <CODE>DSpContext_SwapBuffers</CODE>. You can use an overlay as a control panel type of image, such as that of an airplane cockpit or a radar screen, or decorative scenery such as a border around the active playing area. An overlay must have transparent areas, known as a transparency mask, in order for the back buffer to show through. For more information on how underlays and overlays work see <A HREF="GameSprockets-87.html#MARKER-9-36">"Creating Underlays and Overlays" (page 2-16)</A>.<P>
<A NAME="HEADING86-47"></A>
<H2>Pixel Scaling</H2>
 <A NAME="MARKER-2-21"></A>Your game may scale the back buffer. With scaling, the resolution of the underlay, overlay, and display all remain the same, but the area of the back buffer that is used is reduced. For example, with a 2x scaling factor, DrawSprocket uses only the upper-left quadrant of the back buffer when it composites the image and displays it. However, that quadrant is doubled horizontally and vertically to fill the entire display.<P>
 <A NAME="MARKER-2-22"></A>You have the option of using bilinear interpolation with pixel scaling. <B>Bilinear interpolation</B> averages the pixels and determines a pixel value that falls between the two original pixels. This results in smoother images, but as scaling is increased images begin to look out of focus (but at least they won't look chunky). For each scaling factor that DrawSprocket provides, there is an identical factor with bilinear interpolation enabled. For more information see <A HREF="GameSprockets-94.html#MARKER-9-82">"Pixel Scaling" (page 2-25)</A> and the DSpContext_SetScale function on <A HREF="GameSprockets-133.html#MARKER-9-161">(page 2-58)</A>.<P>
<A NAME="HEADING86-50"></A>
<H2>Other Features</H2>
 <A NAME="MARKER-2-23"></A><A NAME="MARKER-2-24"></A>DrawSprocket allows you set a maximum frame-refresh rate for your game, so that it will not appear to run at uneven speeds, slowing down in portions that require complex rendering and speeding up during simpler drawing. By using the <CODE>DSpContext_SetMaxFrameRate</CODE> function <A HREF="GameSprockets-130.html#MARKER-9-156">(page 2-55)</A>, you can give yourself enough time to render each frame before the screen is refreshed.<P>
 You can easily manipulate the colors in a color lookup table with a DrawSprocket convenience function. See the DSpContext_SetCLUTEntries function <A HREF="GameSprockets-151.html#MARKER-9-198">(page 2-70)</A> for more information.<P>
 Finally, DrawSprocket provides two utility functions. The special function <CODE>DSpSetDebugMode</CODE> <A HREF="GameSprockets-156.html#MARKER-9-206">(page 2-73)</A> helps you when debugging. When you use this function, the display screen and system resources remain visible at all times, even behind the blanking window and even if your code has performed a fade to zero intensity. This feature exists to give you access to the debugger screen at all times. The <CODE>DSpContext_SetVBLProc</CODE> function <A HREF="GameSprockets-157.html#MARKER-9-208">(page 2-74)</A> allows you to piggyback your own VBL tasks to a particular context.<P>
<A NAME="HEADING86-54"></A>
<H2>Video Driver Support</H2>
 <A NAME="MARKER-2-25"></A>DrawSprocket never communicates directly with the Macintosh video hardware. Instead, it relies on standard Macintosh video drivers to provide access to any special hardware features. Video drivers that do not currently support page flipping must be revised so that video games that use DrawSprocket can have access to this capability when it is present in the hardware.<P>
 The Apple Computer video drivers are being revised, and third-party card and driver developers are strongly encouraged to follow suit. Documentation on how driver developers can best support DrawSprocket is in preparation.<P>
 If you are developing a driver to work with DrawSprocket, make sure that, if your video hardware does not support a feature, your driver does not emulate that feature in software. DrawSprocket itself provides highly optimized emulations of hardware capabilities. For example, if page-flipping is not supported by the hardware, your video driver should not attempt to simulate it. If page-flipping is not present, DrawSprocket manages the transition of the background page to the display in as efficient a manner as possible, and the game need not be aware of how the transition occurs.<A NAME="MARKER-2-26"></A><P>

</BLOCKQUOTE>
<HR>
<CENTER>
<A HREF="GameSprockets-85.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="GameSprockets-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="GameSprockets-318.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="GameSprockets-87.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<CENTER><FONT SIZE="-1"><A HREF="GameSprockets-3.html">&copy; Apple Computer, Inc.</A><BR>2 JUL 1996</CENTER></FONT><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
