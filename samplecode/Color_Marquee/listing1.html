<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Color Marquee - /RedAnts.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Color Marquee</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Color Marquee</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/RedAnts.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/RedAnts.c</option></select>
				</p>
				</form>
				<p><strong><a href="Color_Marquee.zip">Download Sample</a></strong> (&#147;Color_Marquee.zip&#148;, 22.8K)<BR>
<strong><a href="Color_Marquee.dmg">Download Sample</a></strong> (&#147;Color_Marquee.dmg&#148;, 83.9K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    RedAnts.c  Contains:  This is a very basic snippet to illustrate how to implement a marquee.          there are two good references that cover this stuff.  Macintosh Programming Fundamentals        by Knaster and Rollin, and Programming QuickDraw by Surovell, Hall and Othmer.  Both these        works are published by addison wesley and both have sample code.           What we do here is track the mouse.  Periodically during tracking, and after we finish, we        animate the selection rectangle.  We do this by working on a pattern, gMarqueePattern, shifting        and rotating each row in the pattern, and setting this as the current pattern to use with the         call to frame rect.          For added spice we set the foreground color to red, this draws the marquee in the red color.  Written by: Nick Thompson    Copyright:  Copyright &copy; 1994-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/8/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        4/21/94    nick  added facility to show a pict file and draw the marquee over that                  this allows a demo of how to do the updating in the mouse tracker                  routine.        */#include &lt;QuickDraw.h&gt;#include &lt;Palettes.h&gt;#include &lt;menus.h&gt;#include &lt;PictUtils.h&gt;#include &lt;QDOffScreen.h&gt;#include &lt;Windows.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Fonts.h&gt;#include &lt;TextEdit.h&gt;#include &lt;Menus.h&gt;#include &lt;DiskInit.h&gt;#include &lt;StandardFile.h&gt;#include &lt;Devices.h&gt;#define HiWrd(aLong)  (((aLong) &gt;&gt; 16) &amp; 0xFFFF)#define LoWrd(aLong)  ((aLong) &amp; 0xFFFF)const RGBColor  kRGBBlack = {0, 0, 0};const RGBColor  kRGBWhite = {0xFFFF, 0xFFFF, 0xFFFF};const char kEnter  = 0x03 ;const char kReturn  = 0x0D ;const char kEscape  = 0x1B ;const char kPeriod  = '.' ;typedef struct {  WindowRecord  theWindow ;    // the window  Rect      selRect ;    // the current selection rect in the window} MyWindow, *MyWindowPtr ;enum {  mApple = 128,  mFile,  mPalette} ;enum {  iAbout = 1} ;enum {  iOpen = 1,  iClose,  iUnused1,  iQuit = 4} ;enum {  iUsePictPalette = 1} ;static Point gStaggerPos = {50,50} ;static Boolean gUsePictPalette = true ;Boolean    gQuitFlag = false ;       // set to true to quit the applicationRect    gLastRect = { 0, 0, 0, 0 } ;  // the last one we drew (used to clean up and for the marquee)long    gLastAnim ;// pattern used for the marquee // translate this to binary to see it!!Pattern     gMarqueePattern = { 0x1f ,    // 00011111                  0x3e ,    // 00111110                  0x7c ,    // 01111100                  0xf8 ,    // 11111000                  0xf1 ,    // 11110001                  0xe3 ,    // 11100011                  0xc7 ,    // 11000111                  0x8f } ;  // 10001111                  const  int  kTimeToAnimate = 1 ;              void main( void ) ;void MainEventLoop( void ) ;void TrackMouse( Point  Anchor, WindowPtr theWindow )  ;Rect *CheckRect( Rect *theRect ) ;void  AnimateMarquee( Rect *theSelectionRect, WindowPtr whichWindow, Boolean mustDraw ) ;void InitToolbox( void ) ;void HandleKeyPress(EventRecord *event) ;void HandleMenuCommand(long menuResult) ;PicHandle DoReadPICT( short theRef, OSErr *theErr ) ;void AdjustMenus( void ) ;OSErr DoCreateWindow( PicHandle thePicture ) ;void UpdateWindow( WindowPtr theWindow, Rect *refreshArea ) ;pascal Boolean OurFilter(DialogPtr dlg, EventRecord *event, short *itemHit) ;void  FlashDialogItem(DialogPtr dlg, short itemToFlash);void main( void ){  InitToolbox() ;    MainEventLoop();}void InitToolbox(){  Handle    menuBar = nil;  InitGraf((Ptr) &amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(0L);  InitCursor();  // initialize application globals    gQuitFlag = false;      menuBar = GetNewMBar(128);        // Read menus into menu bar, MBAR res id is 128    if ( menuBar == nil )     ExitToShell();            // if we dont have it then quit - your app                        // needs a dialog here   SetMenuBar(menuBar);          // Install menus  DisposeHandle(menuBar);    AppendResMenu(GetMenuHandle(mApple), 'DRVR');  // Add DA names to Apple menu, ID 128  DrawMenuBar();}void MainEventLoop(){  EventRecord   event;//  WindowPtr     window;  short         thePart;  Rect          screenRect;  Point      aPoint = {100, 100};  Rect       refreshArea ;  MyWindowPtr    window ;      while( !gQuitFlag )  {    WaitNextEvent( everyEvent, &amp;event, 0, nil ) ;    AdjustMenus() ;    switch (event.what) {          default:        if(( window = (MyWindowPtr)FrontWindow()) != nil ) {          SetPort((WindowPtr)window) ;           AnimateMarquee( CheckRect( &amp;(((MyWindowPtr)window)-&gt;selRect) ), (WindowPtr)window, false ) ;        }        break ;              case mouseDown:              thePart = FindWindow( event.where,((WindowPtr *) &amp;window) );                switch( thePart ) {          case inMenuBar:             HandleMenuCommand(MenuSelect(event.where));            break;                    case inDrag:                    screenRect = (**GetGrayRgn()).rgnBBox;            DragWindow( (WindowPtr)window, event.where, &amp;screenRect );            break ;                  case inContent:                    if ((WindowPtr)window != FrontWindow())              SelectWindow( (WindowPtr)window );            else {              GlobalToLocal( &amp;event.where ) ;              TrackMouse( event.where, (WindowPtr)window ) ;            }            break ;                  case inGoAway:            if (TrackGoAway( (WindowPtr)window, event.where )) {                          // lose the GWorld              DisposeGWorld((GWorldPtr)GetWRefCon((WindowPtr)window)) ;                            // lose the window              DisposeWindow ( (WindowPtr)window );            }            break ;                      default:            break ;        }        break ;                            case updateEvt:              window = (MyWindowPtr)event.message;                BeginUpdate( (WindowPtr)window );                refreshArea = ((**(window-&gt;theWindow.port.visRgn)).rgnBBox);                UpdateWindow( (WindowPtr)window, &amp;refreshArea ) ;        EndUpdate( (WindowPtr)window );        break ;              case keyDown:      case autoKey:        HandleKeyPress(&amp;event);        break;              case diskEvt:        if ( HiWrd(event.message) != noErr )           (void) DIBadMount(aPoint, event.message);        break;              case osEvt:      case activateEvt:        break;    }  }}void HandleKeyPress(EventRecord *event){  char  key;  key = event-&gt;message &amp; charCodeMask;    // just check to see if we want to quit...    if ( event-&gt;modifiers &amp; cmdKey ) {    /* Command key down? */    HandleMenuCommand(MenuKey(key));  } }void HandleMenuCommand(long menuResult){  short    menuID;  short    menuItem;  Str255    daName;  DialogPtr  theDialog ;   short    itemHit ;  SFTypeList  myTypes = { 'PICT' } ;  PicHandle  thePicture ;  OSErr    err ;  short    theRef ;    StandardFileReply  theSFReply ;  menuID = HiWrd(menuResult);  menuItem = LoWrd(menuResult);  switch ( menuID ) {    case mApple:      switch ( menuItem ) {        case iAbout:          theDialog = GetNewDialog ( 128, nil, (WindowPtr)-1 );          do {            ModalDialog ( NewModalFilterProc(OurFilter), &amp;itemHit );          } while( itemHit != ok ) ;          DisposeDialog ( theDialog );          break;                  default:          GetMenuItemText(GetMenuHandle(mApple), menuItem, daName);          (void) OpenDeskAcc(daName);          break;      }      break;    case mFile:      switch ( menuItem ) {        case iOpen:          // Get the file name to open          StandardGetFile( nil, 1, myTypes, &amp;theSFReply ) ;                    // did the user cancel?          if(!theSFReply.sfGood)            break ;                    // open the file          err = FSpOpenDF( &amp;theSFReply.sfFile, fsRdPerm, &amp;theRef ) ;                    if( err != noErr )            break ;   // should handle this properly                      thePicture = DoReadPICT( theRef, &amp;err ) ;                    if( err != noErr )            break ;   // should handle this properly                  // display the contents          err = DoCreateWindow( thePicture ) ;                    break ;                  case iClose:          DisposeWindow ( FrontWindow() );          break ;        case iQuit:          gQuitFlag = true;          break;      }      break;          case mPalette:      switch ( menuItem ) {        case iUsePictPalette :          // toggle the check mark and the global boolean          gUsePictPalette = !gUsePictPalette ;          CheckItem ( GetMenuHandle ( mPalette ), iUsePictPalette, gUsePictPalette );          break ;      }      break ;  }  HiliteMenu(0);    // Unhighlight whatever MenuSelect or MenuKey hilited}void  FlashDialogItem(DialogPtr dlg, short itemToFlash){  short  iKind;  Handle  iHandle;  Rect  iRect;  unsigned long  ignored;  GetDialogItem(dlg, itemToFlash, &amp;iKind, &amp;iHandle, &amp;iRect);  HiliteControl((ControlHandle) iHandle, 1);  Delay(8, &amp;ignored);  HiliteControl((ControlHandle) iHandle, 0);}pascal Boolean OurFilter(DialogPtr dlg, EventRecord *event, short *itemHit){  short  iKind;  Handle  iHandle;  Rect  iRect;  char  key;  short  radius;  switch (event-&gt;what) {    case nullEvent:      break;    case keyDown:    case autoKey:      key = event-&gt;message &amp; charCodeMask;      if (event-&gt;modifiers &amp; cmdKey) {    /* Command key down */        if (key == kPeriod) {          *itemHit = ok;          FlashDialogItem(dlg, *itemHit);        }        return true;      /* This says we handle ALL command keys */      } else {        if ((key == kReturn) || (key == kEnter)) {          *itemHit = ok;          FlashDialogItem(dlg, *itemHit);          return true;        }        if (key == kEscape) {          *itemHit = ok;          FlashDialogItem(dlg, *itemHit);          return true;        }      }      return false;    case updateEvt:      SetPort(dlg);              GetDialogItem(dlg, ok, &amp;iKind, &amp;iHandle, &amp;iRect);            InsetRect(&amp;iRect, -4, -4);      radius = (iRect.bottom - iRect.top) / 2;      if (radius &lt; 16)        radius = 16;              PenSize(3,3);      FrameRoundRect(&amp;iRect, radius, radius);      PenNormal();      return false;    default:      return false;  }    return false;}void AdjustMenus( void ) {  WindowPtr  theWindow ;  theWindow = FrontWindow() ;  if( theWindow != nil ) {    EnableItem ( GetMenuHandle ( mFile ), iClose );  }  else {    DisableItem ( GetMenuHandle ( mFile ), iClose );  }  // make sure the check marks are correct  CheckItem ( GetMenuHandle ( mPalette ), iUsePictPalette, gUsePictPalette );}PicHandle DoReadPICT( short theRef, OSErr *theErr ) {  long    theFileSize ;  PicHandle  thePicture ;    // pict files have a 512 byte header at the front - we dont care about this  // we can find the size of the pict by subtracting 512 bytes from the length  // of the file.  We then want to resize the handle to that and read the data  // into the resized handle.    if(( *theErr = GetEOF( theRef, &amp;theFileSize )) != noErr ) {    FSClose( theRef ) ;    return nil ;   }    if(( *theErr = SetFPos( theRef, fsFromStart, 512)) != noErr ) {    FSClose( theRef ) ;    return nil ;   }  theFileSize -= 512 ;    thePicture = (PicHandle)NewHandle( theFileSize ) ;  if( thePicture == nil ) {    FSClose( theRef ) ;    *theErr = MemError() ;    return nil ;     // what ever the mem manager error was  }    HLock( (Handle)thePicture ) ;  *theErr = FSRead( theRef, &amp;theFileSize, (Ptr)*thePicture ) ;  HUnlock(  (Handle)thePicture ) ;    if( *theErr != noErr ) {    FSClose( theRef ) ;    return nil ;   }  return thePicture ;  }OSErr DoCreateWindow( PicHandle thePicture ){  Rect    theRect ;  OSErr    theErr ;  GWorldPtr  theNewWorld ;  CGrafPtr  savedPort ;  GDHandle  oldDevice ;  MyWindowPtr  myWindowPtr ;  Rect    selectionRect  = {0,0,0,0} ;    PictInfo    thePictInfo ;  PaletteHandle  thePictPalette = nil ;  CTabHandle    thePictCTab = nil ;    // make an offscreen environment and image the pict into this  // Make a window the size of the pict  // store a reference to the GWorld in the Refcon of the window  // invalidate the window content area.    theRect.top = (**thePicture).picFrame.top ;  theRect.left = (**thePicture).picFrame.left ;  theRect.bottom = (**thePicture).picFrame.bottom ;  theRect.right = (**thePicture).picFrame.right ;    // to we want to attempt to sample the picture...   if( gUsePictPalette ) {      // use the picture utilities to get the palette for the window    theErr = GetPictInfo( thePicture, &amp;thePictInfo, returnColorTable, 256, systemMethod, 0) ;        // set up the palette and color table for later use    thePictPalette = NewPalette( 256, thePictInfo.theColorTable, pmTolerant, 0x5000 ) ;    thePictCTab = thePictInfo.theColorTable ;  }    // we are going to cheat a bit here, I only want to deal with  // 8 bit images for the purposes of this snippet  theErr = NewGWorld( &amp;theNewWorld, 8, &amp;theRect, thePictCTab, nil, 0L ) ;    if( theErr != noErr )     return theErr ;    // save the world  GetGWorld( &amp;savedPort, &amp;oldDevice ) ;  SetGWorld( theNewWorld, nil ) ;    // render the image into the offscreen buffer  DrawPicture( thePicture, &amp;theRect ) ;    SetGWorld( savedPort, oldDevice ) ;    // create the window  OffsetRect( &amp;theRect, gStaggerPos.h, gStaggerPos.v) ;  gStaggerPos.h += 16 ;  gStaggerPos.v += 16 ;    // heh - should roll these around, but you wont                 // create more than a couple of windows, will you  :-)    myWindowPtr = (MyWindowPtr)NewPtr ( sizeof( MyWindow ) );                   myWindowPtr  = (MyWindowPtr)NewCWindow( (Ptr)myWindowPtr,                       &amp;theRect,                       &quot;\pplayTime&quot;,                       true,                       documentProc,                       (WindowPtr)-1,                       true,                       (long)theNewWorld );                    myWindowPtr-&gt;selRect = selectionRect ;           // and if we set up the palette earlier assign it to the window          if( thePictPalette != nil ) {    SetPalette ( (GrafPtr)myWindowPtr, thePictPalette, true );  }    // make sure it is visible  ShowWindow( (GrafPtr)myWindowPtr ) ;    SetGWorld( (CGrafPtr)myWindowPtr, nil ) ;    // invalidate the content region of the window - we don't do any drawing to it here.  InvalRect ( &amp;theRect );    SetGWorld( savedPort, oldDevice ) ;  return noErr;}void UpdateWindow( WindowPtr theWindow, Rect *refreshArea ){  GrafPtr      savedPort ;  Rect      copyRect ;  GWorldPtr    theNewWorld ;  PixMapHandle  offPixMap ;    GetPort( &amp;savedPort ) ;  SetPort( theWindow ) ;    // get the GWorld from the window refcon  theNewWorld = (GWorldPtr)GetWRefCon ( theWindow );  offPixMap = GetGWorldPixMap( theNewWorld ) ;    SectRect( refreshArea, &amp;(**offPixMap).bounds, &amp;copyRect ) ;    (void) LockPixels( offPixMap ) ;  RGBForeColor( &amp;kRGBBlack ) ;  RGBBackColor( &amp;kRGBWhite ) ;    CopyBits( &amp;((GrafPtr)theNewWorld)-&gt;portBits,        &amp;theWindow-&gt;portBits,        &amp;copyRect,        &amp;copyRect,        srcCopy,        nil ) ;          (void) UnlockPixels( offPixMap ) ;  SetPort( savedPort ) ;}void TrackMouse( Point  Anchor, WindowPtr theWindow ) {  Rect   theSelection = { 0, 0, 0, 0 };  Point  thePoint ;    SetPort( theWindow ) ;    // get rid of the (possibly) old selection  if( !EmptyRect( &amp;(((MyWindowPtr)theWindow)-&gt;selRect)) )    UpdateWindow( theWindow, CheckRect( &amp;(((MyWindowPtr)theWindow)-&gt;selRect)) ) ;  while(  StillDown () ) {    // remove any old ants that were there before!!    if( !EmptyRect(  &amp;theSelection ))      UpdateWindow( theWindow, CheckRect(&amp;theSelection) ) ;          GetMouse ( &amp;thePoint );        theSelection.top = Anchor.v ;    theSelection.left = Anchor.h ;    theSelection.bottom = thePoint.v ;    theSelection.right = thePoint.h ;        AnimateMarquee( CheckRect(&amp;theSelection), theWindow, true ) ;  }  ((MyWindowPtr)theWindow)-&gt;selRect = theSelection ;}Rect *CheckRect( Rect *theRect ){  short  temp;  if (theRect-&gt;top &gt; theRect-&gt;bottom)    // Need to reverse top and bottom?  {    temp = theRect-&gt;top;    theRect-&gt;top = theRect-&gt;bottom;    theRect-&gt;bottom = temp;  }  if (theRect-&gt;left &gt; theRect-&gt;right)    // Need to reverse left and right?  {    temp = theRect-&gt;left;    theRect-&gt;left = theRect-&gt;right;    theRect-&gt;right = temp;  }    return theRect;              // This makes nested calls easier.}void  AnimateMarquee( Rect *theSelectionRect, WindowPtr whichWindow, Boolean mustDraw ){  #pragma unused (whichWindow)  short       index ;  unsigned char  lastPart ;  if( mustDraw || TickCount() &gt; gLastAnim + kTimeToAnimate ) {    if( !EmptyRect ( theSelectionRect ) ) {          // we will have a Red marquee for the selection...      ForeColor( redColor ) ;            // shuffle the bits in the pattern around      lastPart = gMarqueePattern.pat[7] ;            for( index = 7; index &gt; 0; --index )         gMarqueePattern.pat[index] = gMarqueePattern.pat[ index-1 ] ;              gMarqueePattern.pat[0] = lastPart ;      PenNormal() ;      PenPat( &amp;gMarqueePattern ) ;      FrameRect( theSelectionRect ) ;      gLastAnim = TickCount() ;            // reset the port's color to black      ForeColor( blackColor ) ;    }  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Color_Marquee/listing1.html%3Fid%3DDTS10000072-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Color_Marquee/listing1.html%3Fid%3DDTS10000072-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Color_Marquee/listing1.html%3Fid%3DDTS10000072-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>