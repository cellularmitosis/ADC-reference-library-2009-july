<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoreIsBetter - /MIB-Libraries/MoreDebugging/MoreBacktraceTest/MoreBacktraceTest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MoreIsBetter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoreIsBetter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MIB-Libraries/MoreDebugging/MoreBacktraceTest/MoreBacktraceTest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MIB-Clients/Demos/MoreOpenAndSaveDemo/AnswerShell.c</option>
<option value="listing2.html">/MIB-Clients/MacCVSProTool/MacCVSProTool.c</option>
<option value="listing3.html">/MIB-Clients/SampleSubmit/SampleSubmit.c</option>
<option value="listing4.html">/MIB-Documentation/index.html</option>
<option value="listing5.html">/MIB-Documentation/MoreDocumentation/0ReleaseNotes.html</option>
<option value="listing6.html">/MIB-Documentation/MoreDocumentation/0toc.html</option>
<option value="listing7.html">/MIB-Documentation/MoreDocumentation/banner.html</option>
<option value="listing8.html">/MIB-Documentation/MoreDocumentation/BuildingAndUsing.html</option>
<option value="listing9.html">/MIB-Documentation/MoreDocumentation/ContributingToMoreIsBetter.html</option>
<option value="listing10.html">/MIB-Documentation/MoreDocumentation/copyright.html</option>
<option value="listing11.html">/MIB-Documentation/MoreDocumentation/index.html</option>
<option value="listing12.html">/MIB-Documentation/MoreDocumentation/intro.html</option>
<option value="listing13.html">/MIB-Documentation/MoreDocumentation/MoreAppearance.html</option>
<option value="listing14.html">/MIB-Documentation/MoreDocumentation/MoreAppleEvents.html</option>
<option value="listing15.html">/MIB-Documentation/MoreDocumentation/MoreCDs.html</option>
<option value="listing16.html">/MIB-Documentation/MoreDocumentation/MoreCodeFragments.html</option>
<option value="listing17.html">/MIB-Documentation/MoreDocumentation/MoreControls.html</option>
<option value="listing18.html">/MIB-Documentation/MoreDocumentation/MoreDevices.html</option>
<option value="listing19.html">/MIB-Documentation/MoreDocumentation/MoreDialogs.html</option>
<option value="listing20.html">/MIB-Documentation/MoreDocumentation/MoreDisks.html</option>
<option value="listing21.html">/MIB-Documentation/MoreDocumentation/MoreErrors.html</option>
<option value="listing22.html">/MIB-Documentation/MoreDocumentation/MoreEvents.html</option>
<option value="listing23.html">/MIB-Documentation/MoreDocumentation/MoreInterfaceLib.html</option>
<option value="listing24.html">/MIB-Documentation/MoreDocumentation/MoreLists.html</option>
<option value="listing25.html">/MIB-Documentation/MoreDocumentation/MoreMemory.html</option>
<option value="listing26.html">/MIB-Documentation/MoreDocumentation/MoreMenus.html</option>
<option value="listing27.html">/MIB-Documentation/MoreDocumentation/MoreMultiprocessing.html</option>
<option value="listing28.html">/MIB-Documentation/MoreDocumentation/MoreNavigation.html</option>
<option value="listing29.html">/MIB-Documentation/MoreDocumentation/MoreNetworkSetup.html</option>
<option value="listing30.html">/MIB-Documentation/MoreDocumentation/MoreOpenAndSave.html</option>
<option value="listing31.html">/MIB-Documentation/MoreDocumentation/MoreOpenTransport.html</option>
<option value="listing32.html">/MIB-Documentation/MoreDocumentation/MoreOSL.html</option>
<option value="listing33.html">/MIB-Documentation/MoreDocumentation/MoreOSUtils.html</option>
<option value="listing34.html">/MIB-Documentation/MoreDocumentation/MorePatches.html</option>
<option value="listing35.html">/MIB-Documentation/MoreDocumentation/MorePreferences.html</option>
<option value="listing36.html">/MIB-Documentation/MoreDocumentation/MoreProcesses.html</option>
<option value="listing37.html">/MIB-Documentation/MoreDocumentation/MoreQuickDraw.html</option>
<option value="listing38.html">/MIB-Documentation/MoreDocumentation/MoreResources.html</option>
<option value="listing39.html">/MIB-Documentation/MoreDocumentation/MoreTextUtils.html</option>
<option value="listing40.html">/MIB-Documentation/MoreDocumentation/MoreToolbox.html</option>
<option value="listing41.html">/MIB-Documentation/MoreDocumentation/MoreWindows.html</option>
<option value="listing42.html">/MIB-Libraries/MIB_Carbon.h</option>
<option value="listing43.html">/MIB-Libraries/MIB_SourceHeader.txt</option>
<option value="listing44.html">/MIB-Libraries/MoreAppearance/MoreAppearance.cp</option>
<option value="listing45.html">/MIB-Libraries/MoreAppearance/MoreAppearance.h</option>
<option value="listing46.html">/MIB-Libraries/MoreAppleEvents/MoreAEDataModel.c</option>
<option value="listing47.html">/MIB-Libraries/MoreAppleEvents/MoreAEDataModel.h</option>
<option value="listing48.html">/MIB-Libraries/MoreAppleEvents/MoreAEObjects.c</option>
<option value="listing49.html">/MIB-Libraries/MoreAppleEvents/MoreAEObjects.h</option>
<option value="listing50.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEvents.cp</option>
<option value="listing51.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEvents.h</option>
<option value="listing52.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEventsPlus.c</option>
<option value="listing53.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEventsPlus.h</option>
<option value="listing54.html">/MIB-Libraries/MoreAppleEvents/MoreFinderEvents.c</option>
<option value="listing55.html">/MIB-Libraries/MoreAppleEvents/MoreFinderEvents.h</option>
<option value="listing56.html">/MIB-Libraries/MoreAppleEvents/MoreOSA.c</option>
<option value="listing57.html">/MIB-Libraries/MoreAppleEvents/MoreOSA.h</option>
<option value="listing58.html">/MIB-Libraries/MoreAppleEvents/ProductInfo.txt</option>
<option value="listing59.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/Carbon.r</option>
<option value="listing60.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/HelloWorld.c</option>
<option value="listing61.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/Info.plist.r</option>
<option value="listing62.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/TestMoreAppleEvents.c</option>
<option value="listing63.html">/MIB-Libraries/MoreAppleEvents/VersionInfo.r</option>
<option value="listing64.html">/MIB-Libraries/MoreCarbonEvents/MoreCarbonEvents.c</option>
<option value="listing65.html">/MIB-Libraries/MoreCarbonEvents/MoreCarbonEvents.h</option>
<option value="listing66.html">/MIB-Libraries/MoreCFQ/MoreCFQ.c</option>
<option value="listing67.html">/MIB-Libraries/MoreCFQ/MoreCFQ.h</option>
<option value="listing68.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/CallMachOFramework.c</option>
<option value="listing69.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/CallMachOFramework.r</option>
<option value="listing70.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/Read Me CallMachOFramework.txt</option>
<option value="listing71.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/System Framework Stub/Stub Library Read Me.txt</option>
<option value="listing72.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CFMLateImport.c</option>
<option value="listing73.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CFMLateImport.h</option>
<option value="listing74.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/LateImportTest.c</option>
<option value="listing75.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/TestLibrary/TestLibrary.h</option>
<option value="listing76.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/TestLibrary/TestLibraryImpl.c</option>
<option value="listing77.html">/MIB-Libraries/MoreControls/MoreControls.cp</option>
<option value="listing78.html">/MIB-Libraries/MoreControls/MoreControls.h</option>
<option value="listing79.html">/MIB-Libraries/MoreCRC/MoreCRC.c</option>
<option value="listing80.html">/MIB-Libraries/MoreCRC/MoreCRC.h</option>
<option value="listing81.html">/MIB-Libraries/MoreDebugging/MoreAddrToSym.c</option>
<option value="listing82.html">/MIB-Libraries/MoreDebugging/MoreAddrToSym.h</option>
<option value="listing83.html">/MIB-Libraries/MoreDebugging/MoreBacktrace.c</option>
<option value="listing84.html">/MIB-Libraries/MoreDebugging/MoreBacktrace.h</option>
<option value="listing85.html">/MIB-Libraries/MoreDebugging/MoreBacktraceTest/MoreBacktraceTest.c</option>
<option value="listing86.html">/MIB-Libraries/MoreDebugging/MoreBBLog.c</option>
<option value="listing87.html">/MIB-Libraries/MoreDebugging/MoreBBLog.h</option>
<option value="listing88.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/GenerateFont/GenerateFont.c</option>
<option value="listing89.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.c</option>
<option value="listing90.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.h</option>
<option value="listing91.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.s</option>
<option value="listing92.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/TestInterruptSafeDebug/TestInterruptSafeDebug.c</option>
<option value="listing93.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/ReadMe.html</option>
<option value="listing94.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TestTradDriverLoaderLib/TestDriver/TestDriverMain.c</option>
<option value="listing95.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TestTradDriverLoaderLib/TestTradDriverLoader.c</option>
<option value="listing96.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TradDriverLoaderLib.c</option>
<option value="listing97.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TradDriverLoaderLib.h</option>
<option value="listing98.html">/MIB-Libraries/MoreDialogs/MoreDialogs.cp</option>
<option value="listing99.html">/MIB-Libraries/MoreDialogs/MoreDialogs.h</option>
<option value="listing100.html">/MIB-Libraries/MoreDisks/MoreCDs.c</option>
<option value="listing101.html">/MIB-Libraries/MoreDisks/MoreCDs.h</option>
<option value="listing102.html">/MIB-Libraries/MoreDisks/MoreDisks.c</option>
<option value="listing103.html">/MIB-Libraries/MoreDisks/MoreDisks.h</option>
<option value="listing104.html">/MIB-Libraries/MoreDisks/TestMoreDisks/TestMoreDisks.c</option>
<option value="listing105.html">/MIB-Libraries/MoreErrors/MoreErrors.c</option>
<option value="listing106.html">/MIB-Libraries/MoreErrors/MoreErrors.h</option>
<option value="listing107.html">/MIB-Libraries/MoreErrors/MoreErrors.r</option>
<option value="listing108.html">/MIB-Libraries/MoreEvents/MoreEvents.h</option>
<option value="listing109.html">/MIB-Libraries/MoreInterfaceLib/MoreInterfaceLib.c</option>
<option value="listing110.html">/MIB-Libraries/MoreInterfaceLib/MoreInterfaceLib.h</option>
<option value="listing111.html">/MIB-Libraries/MoreInterfaceLib/RemoteAccessInterface.h</option>
<option value="listing112.html">/MIB-Libraries/MoreInterfaceLib/TestMoreInterfaceLib/TestMoreInterfaceLib.c</option>
<option value="listing113.html">/MIB-Libraries/MoreIsBetter.h</option>
<option value="listing114.html">/MIB-Libraries/MoreLists/MoreLists.c</option>
<option value="listing115.html">/MIB-Libraries/MoreLists/MoreLists.h</option>
<option value="listing116.html">/MIB-Libraries/MoreMemory/MoreMemory.c</option>
<option value="listing117.html">/MIB-Libraries/MoreMemory/MoreMemory.h</option>
<option value="listing118.html">/MIB-Libraries/MoreMemory/TestMoreMemory/TestMoreMemory.c</option>
<option value="listing119.html">/MIB-Libraries/MoreMenus/MenuKeyGlyphs.h</option>
<option value="listing120.html">/MIB-Libraries/MoreMenus/MoreMenus.c</option>
<option value="listing121.html">/MIB-Libraries/MoreMenus/MoreMenus.h</option>
<option value="listing122.html">/MIB-Libraries/MoreMenus/MoreSystemMenus.c</option>
<option value="listing123.html">/MIB-Libraries/MoreMenus/MoreSystemMenus.h</option>
<option value="listing124.html">/MIB-Libraries/MoreMenus/TestMoreSystemMenus/TestMoreSystemMenus.c</option>
<option value="listing125.html">/MIB-Libraries/MoreMultiprocessing/MoreBlueActions.c</option>
<option value="listing126.html">/MIB-Libraries/MoreMultiprocessing/MoreBlueActions.h</option>
<option value="listing127.html">/MIB-Libraries/MoreMultiprocessing/MoreMPLog.c</option>
<option value="listing128.html">/MIB-Libraries/MoreMultiprocessing/MoreMPLog.h</option>
<option value="listing129.html">/MIB-Libraries/MoreNavigation/MoreNavigation.c</option>
<option value="listing130.html">/MIB-Libraries/MoreNavigation/MoreNavigation.h</option>
<option value="listing131.html">/MIB-Libraries/MoreOpenAndSave/MoreOpenAndSave.cp</option>
<option value="listing132.html">/MIB-Libraries/MoreOpenAndSave/MoreOpenAndSave.h</option>
<option value="listing133.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPush.c</option>
<option value="listing134.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPush.h</option>
<option value="listing135.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPushTest/MoreAutoPushTest.c</option>
<option value="listing136.html">/MIB-Libraries/MoreOpenTransport/OTClassicContext.h</option>
<option value="listing137.html">/MIB-Libraries/MoreOpenTransport/OTClassicContextTest/OTClassicContextTest.c</option>
<option value="listing138.html">/MIB-Libraries/MoreOpenTransport/OTMP.c</option>
<option value="listing139.html">/MIB-Libraries/MoreOpenTransport/OTMP.h</option>
<option value="listing140.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTP.c</option>
<option value="listing141.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTP.h</option>
<option value="listing142.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTPTest.c</option>
<option value="listing143.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTPTest.r</option>
<option value="listing144.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/Sample HTTP Source/index.html</option>
<option value="listing145.html">/MIB-Libraries/MoreOpenTransport/OTMPTest/OTMPTest.c</option>
<option value="listing146.html">/MIB-Libraries/MoreOpenTransport/Read_Me_About_OTMP.html</option>
<option value="listing147.html">/MIB-Libraries/MoreOpenTransport/ReadMeOTClassicContext.html</option>
<option value="listing148.html">/MIB-Libraries/MoreOSL/MoreOSL.c</option>
<option value="listing149.html">/MIB-Libraries/MoreOSL/MoreOSL.h</option>
<option value="listing150.html">/MIB-Libraries/MoreOSL/MoreOSLHelpers.c</option>
<option value="listing151.html">/MIB-Libraries/MoreOSL/MoreOSLHelpers.h</option>
<option value="listing152.html">/MIB-Libraries/MoreOSL/MoreOSLStringComp.applescript</option>
<option value="listing153.html">/MIB-Libraries/MoreOSL/MoreOSLStringCompare.c</option>
<option value="listing154.html">/MIB-Libraries/MoreOSL/MoreOSLStringCompare.h</option>
<option value="listing155.html">/MIB-Libraries/MoreOSL/MoreOSLTokens.c</option>
<option value="listing156.html">/MIB-Libraries/MoreOSL/MoreOSLTokens.h</option>
<option value="listing157.html">/MIB-Libraries/MoreOSL/ReadMe.html</option>
<option value="listing158.html">/MIB-Libraries/MoreOSL/TestMoreOSL/Test Script.applescript</option>
<option value="listing159.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSL.c</option>
<option value="listing160.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.h</option>
<option value="listing161.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.r</option>
<option value="listing162.html">/MIB-Libraries/MoreOSUtils/MoreOSUtils.c</option>
<option value="listing163.html">/MIB-Libraries/MoreOSUtils/MoreOSUtils.h</option>
<option value="listing164.html">/MIB-Libraries/MoreOSUtils/TestMoreOSUtils/TestMoreOSUtils.c</option>
<option value="listing165.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.c</option>
<option value="listing166.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.h</option>
<option value="listing167.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.s</option>
<option value="listing168.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatchesTest/MoreCFMPatchesTest.c</option>
<option value="listing169.html">/MIB-Libraries/MorePreferences/MorePreferences.cp</option>
<option value="listing170.html">/MIB-Libraries/MorePreferences/MorePreferences.h</option>
<option value="listing171.html">/MIB-Libraries/MoreProcesses/MoreProcesses.cp</option>
<option value="listing172.html">/MIB-Libraries/MoreProcesses/MoreProcesses.h</option>
<option value="listing173.html">/MIB-Libraries/MoreProcesses/MoreScheduledExec.c</option>
<option value="listing174.html">/MIB-Libraries/MoreProcesses/MoreScheduledExec.h</option>
<option value="listing175.html">/MIB-Libraries/MoreProcesses/TestMoreScheduledExec/TestMoreScheduledExec.c</option>
<option value="listing176.html">/MIB-Libraries/MoreQuickDraw/MoreQuickDraw.cp</option>
<option value="listing177.html">/MIB-Libraries/MoreQuickDraw/MoreQuickDraw.h</option>
<option value="listing178.html">/MIB-Libraries/MoreResources/MoreResources.c</option>
<option value="listing179.html">/MIB-Libraries/MoreResources/MoreResources.h</option>
<option value="listing180.html">/MIB-Libraries/MoreSCF/MoreSCF.c</option>
<option value="listing181.html">/MIB-Libraries/MoreSCF/MoreSCF.h</option>
<option value="listing182.html">/MIB-Libraries/MoreSCF/MoreSCFCCLScanner.c</option>
<option value="listing183.html">/MIB-Libraries/MoreSCF/MoreSCFCCLScanner.h</option>
<option value="listing184.html">/MIB-Libraries/MoreSCF/MoreSCFDigest.c</option>
<option value="listing185.html">/MIB-Libraries/MoreSCF/MoreSCFDigest.h</option>
<option value="listing186.html">/MIB-Libraries/MoreSCF/MoreSCFHelpers.c</option>
<option value="listing187.html">/MIB-Libraries/MoreSCF/MoreSCFHelpers.h</option>
<option value="listing188.html">/MIB-Libraries/MoreSCF/MoreSCFPortScanner.c</option>
<option value="listing189.html">/MIB-Libraries/MoreSCF/MoreSCFPortScanner.h</option>
<option value="listing190.html">/MIB-Libraries/MoreSCF/MoreSCFTest/MoreSCFTest.c</option>
<option value="listing191.html">/MIB-Libraries/MoreSCF/ReadMeAboutMoreSCF.html</option>
<option value="listing192.html">/MIB-Libraries/MoreSecurity/MoreSecurity.c</option>
<option value="listing193.html">/MIB-Libraries/MoreSecurity/MoreSecurity.h</option>
<option value="listing194.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTest.c</option>
<option value="listing195.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTestCommon.h</option>
<option value="listing196.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTestTool.c</option>
<option value="listing197.html">/MIB-Libraries/MoreSecurity/ReadMeAboutMoreAuthSample.html</option>
<option value="listing198.html">/MIB-Libraries/MoreSetup.h</option>
<option value="listing199.html">/MIB-Libraries/MoreSetup.r</option>
<option value="listing200.html">/MIB-Libraries/MoreSound/MoreSound.cp</option>
<option value="listing201.html">/MIB-Libraries/MoreSound/MoreSound.h</option>
<option value="listing202.html">/MIB-Libraries/MoreTextUtils/MoreTextUtils.cp</option>
<option value="listing203.html">/MIB-Libraries/MoreTextUtils/MoreTextUtils.h</option>
<option value="listing204.html">/MIB-Libraries/MoreTextUtils/TestMoreTextUtils/TestMoreTextUtils.c</option>
<option value="listing205.html">/MIB-Libraries/MoreTextUtils/TestMoreTextUtils/TestMoreTextUtils.r</option>
<option value="listing206.html">/MIB-Libraries/MoreToolbox/MoreToolbox.cp</option>
<option value="listing207.html">/MIB-Libraries/MoreToolbox/MoreToolbox.h</option>
<option value="listing208.html">/MIB-Libraries/MoreUNIX/MoreUNIX.c</option>
<option value="listing209.html">/MIB-Libraries/MoreUNIX/MoreUNIX.h</option>
<option value="listing210.html">/MIB-Libraries/MoreWindows/MoreWindows.cp</option>
<option value="listing211.html">/MIB-Libraries/MoreWindows/MoreWindows.h</option>
<option value="listing212.html">/MIB-Libraries/NetworkSetup/MoreNetworkSetup.c</option>
<option value="listing213.html">/MIB-Libraries/NetworkSetup/MoreNetworkSetup.h</option>
<option value="listing214.html">/MIB-Libraries/NetworkSetup/Network Setup SDK Bits/ Read Me.txt</option>
<option value="listing215.html">/MIB-Libraries/NetworkSetup/Network Setup SDK Bits/NetworkSetupBigPicture.html</option>
<option value="listing216.html">/MIB-Libraries/NetworkSetup/NetworkSetupHelpers.c</option>
<option value="listing217.html">/MIB-Libraries/NetworkSetup/NetworkSetupHelpers.h</option>
<option value="listing218.html">/MIB-Libraries/NetworkSetup/NetworkSetupTest/NetworkSetupTest.c</option>
<option value="listing219.html">/MIB-Libraries/NetworkSetup/OldStyleAPI/OldOTConfigLib.h</option>
<option value="listing220.html">/MIB-Libraries/NetworkSetup/ReadMe.html</option>
<option value="listing221.html">/MIB-Libraries/PascalInterfaces/MoreSetup.p</option>
<option value="listing222.html">/MIB-Libraries/PascalInterfaces/TradDriverLoaderLib.p</option></select>
				</p>
				</form>
				<p><strong><a href="MoreIsBetter.zip">Download Sample</a></strong> (&#147;MoreIsBetter.zip&#148;, 1.61M)<BR>
<strong><a href="MoreIsBetter.dmg">Download Sample</a></strong> (&#147;MoreIsBetter.dmg&#148;, 2.04M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    MoreBacktraceTest.c

  Contains:  A simple program to test MoreBacktrace.

  Written by:  DTS

  Copyright:  Copyright &copy; 2003 by Apple Computer, Inc., All Rights Reserved.

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Change History (most recent first):

*/

/////////////////////////////////////////////////////////////////

#include &quot;MoreSetup.h&quot;

// System prototypes

// Include &lt;mach/mach.h&gt; for the Mach-O build.  Put it inside
// extern &quot;C&quot; guards for the C++ build because the Mach header 
// files don't have them.  Put it before main includes because 
// Carbon includes Mach via I/O Kit via CG.

#if TARGET_RT_MAC_MACHO
  #if defined(__cplusplus)
    extern &quot;C&quot; {
  #endif

  #include &lt;mach/mach.h&gt;

  #if defined(__cplusplus)
    }
  #endif
#endif

#if MORE_FRAMEWORK_INCLUDES
  #include &lt;Carbon/Carbon.h&gt;
#else
  #include &lt;MacTypes.h&gt;
  #include &lt;IBCarbonRuntime.h&gt;
  #include &lt;Debugging.h&gt;
  #include &lt;Gestalt.h&gt;
  #include &lt;TextEdit.h&gt;
#endif

#if TARGET_RT_MAC_MACHO
  #include &lt;unistd.h&gt;
  #include &lt;signal.h&gt;
#endif

#include &lt;stdlib.h&gt;

// MIB Prototypes

#include &quot;MoreOSUtils.h&quot;
#include &quot;MoreProcesses.h&quot;
#include &quot;MoreCFQ.h&quot;
#include &quot;MoreControls.h&quot;
#include &quot;MoreBacktrace.h&quot;
#include &quot;MoreAddrToSym.h&quot;

#if TARGET_RT_MAC_MACHO
  #include &quot;MoreUNIX.h&quot;
#endif

/////////////////////////////////////////////////////////////////

#if TARGET_API_MAC_CARBON

  static UInt8  gOutputFont[] = &quot;\pMonaco&quot;;
  static SInt16 gOutputSize = 10;

  enum {
    kFrameCount = 70
  };
  
  static ControlRef gOutputText = NULL;
  static ControlRef gOutputUser = NULL;      // NULL indicates that gOutputText is in use
  static ControlRef gPIDText = NULL;

  static void DoAbout(void)
    // Displays the about box.
  {
    SInt16 junkHit;
    
    (void) StandardAlert(kAlertPlainAlert, &quot;\pMoreBacktraceTest&quot;, &quot;\pA simple program to test MoreBacktrace.\r\rDTS\r\r&copy; 2003 Apple Computer, Inc.&quot;, NULL, &amp;junkHit);
  }
  
  static void DisplayError(OSStatus errNum)
  {
    OSStatus  junk;
    Str255     errStr;
    SInt16     junkHit;
    
    if ( (errNum != noErr) &amp;&amp; (errNum != userCanceledErr) ) {
      NumToString(errNum, errStr);

      junk = StandardAlert(kAlertStopAlert, &quot;\pError.&quot;, errStr, NULL, &amp;junkHit);
      assert(junk == noErr);
    }
  }

  static ControlUserPaneDrawUPP gOutputUserPaneDrawUPP;    // -&gt; OutputUserPaneDrawProc

  static pascal void OutputUserPaneDrawProc(ControlRef control, SInt16 part)
    // The draw procedure for gOutputUser.  This only runs on traditional 
    // Mac OS.  It calls TETextBox to draw the contents of the user pane 
    // control.  The text is stored in a CFStringRef in the control's 
    // refCon.
  {
    OSStatus  err;
    CFStringRef controlStr;
    CFIndex    unicodeLength;
    Handle    textH;
    CFIndex    textHSize;
    CFIndex    numberConverted;
    #pragma unused(part)
    
    // Get the text, calculate the number of bytes need to convert it to 
    // MacRoman, and allocate a handle of that size.  Note that hard coding 
    // MacRoman is OK in this case because, on traditional Mac OS, text 
    // encoding is related to font choice, and we hard code Monaco, which is 
    // a MacRoman font.  Further note that hard coding a font is a really 
    // bad idea in a production application.
    
    controlStr = (CFStringRef) GetControlReference(control);
    assert( (controlStr != NULL) &amp;&amp; (CFGetTypeID(controlStr) == CFStringGetTypeID()) );
    
    unicodeLength = CFStringGetLength(controlStr);
    textHSize = CFStringGetMaximumSizeForEncoding(unicodeLength, kCFStringEncodingMacRoman);
    
    textH = NewHandle(textHSize);
    err = MemError();
    
    // Get the MacRoman bytes out of the CFString into the handle.  Resize 
    // the handle to encompass just the bytes that we got.
    
    if (err == noErr) {
      HLock(textH);
      assert(MemError() == noErr);
      
      numberConverted = CFStringGetBytes(controlStr, CFRangeMake(0, unicodeLength), 
                         kCFStringEncodingMacRoman, 0, false, 
                         (UInt8 *) *textH, textHSize, &amp;textHSize);

      HUnlock(textH);
      assert(MemError() == noErr);

      if ( numberConverted == unicodeLength ) {
        SetHandleSize(textH, textHSize);
        assert(MemError() == noErr);
      } else {
        err = coreFoundationUnknownErr;
      }
    }
    
    // Draw the handle of text into the control's bounding box using 
    // TETextBox.
    
    if (err == noErr) {
      GrafPtr oldPort;
      SInt16  monacoFontNum;
      Rect  bounds;
      
      HLock(textH);
      
      GetPort(&amp;oldPort);
      SetPort(GetWindowPort(GetControlOwner(control)));
      
      (void) GetControlBounds(control, &amp;bounds);
      
      GetFNum(gOutputFont, &amp;monacoFontNum);
      
      EraseRect(&amp;bounds);
      
      TextFont(monacoFontNum);
      TextFace(0);
      TextMode(srcOr);
      TextSize(gOutputSize);
      
      TETextBox(*textH, textHSize, &amp;bounds, teJustLeft);
      
      SetPort(oldPort);
    }

    // Clean up.
    
    if (textH != NULL) {
      DisposeHandle(textH);
      assert(MemError() == noErr);
    }
    
    assert(err == noErr);
  }

  static OSStatus SetOutputText(CFStringRef newText)
    // Put newText into the output control.  This is either 
    // an edit text control (gOutputText) or a user pane 
    // control (gOutputUser) depending on the system version. 
    // We use an edit text control on Mac OS X because it's 
    // a) easy, b) handles multiple lines of text, and 
    // c) allows the user to copy the results.  We use an 
    // user pane control on traditional Mac OS because the 
    // edit text control can't handle more than 255 
    // characters (at least when we set its contents using 
    // SetTextControlTextCompat).
  {
    OSStatus err;
    
    assert(newText != NULL);
    
    if (gOutputUser == NULL) {
      err = SetTextControlTextCompat(gOutputText, false, newText);
      Draw1Control(gOutputText);
    } else {
      CFStringRef oldText;
      
      // Get the old text and release it.
      
      oldText = (CFStringRef) GetControlReference(gOutputUser);
      assert( (oldText == NULL) || (CFGetTypeID(oldText) == CFStringGetTypeID()) );
      CFQRelease(oldText);
      
      // Retain the new text and install it.
      
      CFRetain(newText);
      SetControlReference(gOutputUser, (SInt32) newText);

      Draw1Control(gOutputUser);
      
      err = noErr;
    }
    return err;
  }

  static void ClearOutput(void)
    // Clear the output text.
  {
    OSStatus junk;
    
    junk = SetOutputText(CFSTR(&quot;&quot;));
    assert(junk == noErr);
  }

  static OSStatus OutputFrames(const MoreBTPPCFrame *frameArray, ItemCount frameCount, Boolean lookupSymbolNames)
    // Output a textual description of frameCount frames from frameArray 
    // into the output text control.  If lookupSymbolNames is true, 
    // we look up the symbol names of the PCs of each of the frames 
    // (currently on Mach-O builds only).
  {
    OSStatus      err;
    CFMutableStringRef   result;
    ItemCount      frameIndex;
    ItemCount      row;
    ItemCount      col;
    MoreAToSSymInfo *  symbols;

    result = NULL;
    
    // Create an array of NULL CFStringRefs to hold the symbol pointers.
    
    err = noErr;
    symbols = (MoreAToSSymInfo *) malloc(frameCount * sizeof(*symbols));
    if (symbols == NULL) {
      err = memFullErr;
    }
    if (err == noErr) {
      MoreAToSCreate(frameCount, symbols);
    }
    
    // If we've been asked to look up the symbols, do so.
    
    if (err == noErr &amp;&amp; lookupSymbolNames) {
      MoreAToSAddr *addresses;
      
      addresses = (MoreAToSAddr *) malloc(frameCount * sizeof(*addresses));
      if (addresses == NULL) {
        err = memFullErr;
      }
      if (err == noErr) {  
        for (frameIndex = 0; frameIndex &lt; frameCount; frameIndex++) {
          if (frameArray[frameIndex].flags &amp; kMoreBTPCBadMask) {
            addresses[frameIndex] = NULL;
          } else {
            addresses[frameIndex] = (MoreAToSAddr) frameArray[frameIndex].pc;
          }
        }
      }
      
      if (err == noErr) {
        #if TARGET_RT_MAC_MACHO
          err = MoreAToSCopySymbolNamesUsingDyld(frameCount, addresses, symbols);
        #else
          // do nothing
        #endif
      }
      
      free(addresses);
    }
    
    // Create the output string, starting with an empty string and then 
    // appending an entry for each frame.
    
    if (err == noErr) {
      result = CFStringCreateMutable(NULL, 0);
      err = CFQError(result);
    }
    if (err == noErr) {
      for (row = 0; row &lt; (kFrameCount / 2); row++) {
        for (col = 0; col &lt; 2; col++) {
          frameIndex = col * (kFrameCount / 2) + row;
          
          if ( frameIndex &lt; frameCount ) {
            CFStringRef  thisSymbol;
            enum {
              kStringWidth = 23
            };
            
            CFStringAppendFormat(result, NULL, CFSTR(&quot;%2d %c%c%c %08x %08x &quot;), 
                 frameIndex,
                 (frameArray[frameIndex].flags &amp; kMoreBTFrameBadMask)      ? 'F' : 'f',
                 (frameArray[frameIndex].flags &amp; kMoreBTPCBadMask)         ? 'P' : 'p',
                 (frameArray[frameIndex].flags &amp; kMoreBTSignalHandlerMask) ? 'S' : 's',
                 frameArray[frameIndex].sp, 
                 frameArray[frameIndex].pc);
                       
            thisSymbol = symbols[frameIndex].symbolName;
            
            if (thisSymbol != NULL) {
              CFStringRef tmpStr;
              CFStringRef tmpStr2;
              CFIndex strLen;

              tmpStr = NULL;
              tmpStr2 = NULL;
              
              strLen = CFStringGetLength(thisSymbol);
              
              if ( strLen &gt; kStringWidth ) {
                tmpStr = CFStringCreateWithSubstring(NULL, thisSymbol, CFRangeMake(0, kStringWidth));
                tmpStr2 = CFSTR(&quot;&quot;);
                CFRetain(tmpStr2);
              } else {
                tmpStr = thisSymbol;
                CFRetain(tmpStr);
                tmpStr2 = CFStringCreateWithFormat(NULL, NULL, CFSTR(&quot;%*.*s&quot;), kStringWidth - strLen, kStringWidth - strLen, &quot;&quot;);
              }
              CFStringAppendFormat(result, NULL, CFSTR(&quot;%@+%04x%@    &quot;), 
                         tmpStr,
                         symbols[frameIndex].symbolOffset,
                         tmpStr2
                        );
              CFQRelease(tmpStr);
              CFQRelease(tmpStr2);
            } else {
              CFStringAppendFormat(result, NULL, CFSTR(&quot;%*.*s&quot;), 
                         kStringWidth + 1 + 4 + 4,
                         kStringWidth + 1 + 4 + 4,
                         &quot;&quot;
                        );
            }
          }
        }
        CFStringAppendFormat(result, NULL, CFSTR(&quot;\r&quot;));
      }
    }
    
    // Put the string into the control.
    
    if (err == noErr) {
      err = SetOutputText(result);
    }
    
    // Clean up.

    if (symbols != NULL) {
      MoreAToSDestroy(frameCount, symbols);
    }
    free(symbols);
    CFQRelease(result);
        
    return err;
  }

  static void TestMoreBacktracePPCCarbonSelf(void)
  {
    OSStatus    err;
    MoreBTPPCFrame   frames[kFrameCount];
    ItemCount    frameCount;
    ItemCount    validFrames;

    ClearOutput();
    
    frameCount = sizeof(frames) / sizeof(*frames);
    err = MoreBacktracePPCCarbonSelf(0, 0, frames, frameCount, &amp;validFrames);
    if (err == noErr) {
      if (validFrames &gt; frameCount) {
        validFrames = frameCount;
      }
      err = OutputFrames(frames, validFrames, true);
    }
    DisplayError(err);
  }

  #if TARGET_RT_MAC_MACHO

    static void TestMoreBacktracePPCMachSelf(void)
    {
      OSStatus    err;
      MoreBTPPCFrame   frames[kFrameCount];
      ItemCount    frameCount;
      ItemCount    validFrames;

      ClearOutput();
      
      frameCount = sizeof(frames) / sizeof(*frames);
      err = MoreBacktracePPCMachSelf(0, 0, frames, frameCount, &amp;validFrames);
      if (err == noErr) {
        if (validFrames &gt; frameCount) {
          validFrames = frameCount;
        }
        err = OutputFrames(frames, validFrames, true);
      }
      DisplayError(err);
    }

    static void TestMoreBacktracePPCMachThread(void)
    {
      OSStatus    err;
      OSStatus    junk;
      MoreBTPPCFrame   frames[kFrameCount];
      ItemCount    frameCount;
      ItemCount    validFrames;
      CFStringRef    pidStr;
      Str255      pidPStr;
      long      pidLong;
      pid_t      pid;
      task_t      targetTask;
      Boolean      didSuspend;
      thread_array_t  threadList;
      mach_msg_type_number_t  threadCount;

      ClearOutput();

      targetTask = MACH_PORT_NULL;
      pidStr = NULL;
      threadList = NULL;
      
      didSuspend = false;
      
      // Get the PID of the process to sample from the 
      // gPIDText edit text control and convert that to 
      // the Mach task control port.
      
      err = CopyTextControlTextCompat(gPIDText, false, &amp;pidStr);
      if (err == noErr) {
        err = CFQErrorBoolean( CFStringGetPascalString(pidStr, pidPStr, sizeof(pidPStr), kCFStringEncodingASCII) );
      }
      if (err == noErr) {
        StringToNum(pidPStr, &amp;pidLong);
        pid = (pid_t) pidLong;
      }
      if (err == noErr) {
        err = task_for_pid(mach_task_self(), pid, &amp;targetTask);
      }
      if (err == noErr) {
        if (targetTask == mach_task_self()) {
          err = -1;      // this won't go well
        }
      }
      
      // Suspend the task while we sample it.  Otherwise the 
      // list of threads might change.
      
      if (err == noErr) {
        err = task_suspend(targetTask);
        didSuspend = (err == noErr);
      }
      if (err == noErr) {
        err = task_threads(targetTask, &amp;threadList, &amp;threadCount);
      }
      if (err == noErr) {
        // A task without any threads makes no sense.
        
        assert(threadCount &gt; 0);
        
        // We always sample the first thread.  This has no real 
        // significance because Mach doesn't guarantee to return 
        // the threads in any particular order.  In a real tool 
        // you'd iterate over all of the threads and sample each, 
        // but I have no way of displaying the results in my 
        // test application.
        
        frameCount = sizeof(frames) / sizeof(*frames);
        err = MoreBacktracePPCMachThread(targetTask, threadList[0], 0, 0, frames, frameCount, &amp;validFrames);
      }
      
      // Resume the task as quickly as possibly after the backtrace.
      
      if (didSuspend) {
        junk = task_resume(targetTask);
        assert(junk == noErr);
      }
      
      if (err == noErr) {
        if (validFrames &gt; frameCount) {
          validFrames = frameCount;
        }
        err = OutputFrames(frames, validFrames, false);
      }
      DisplayError(err);
      
      // Clean up.
      
      CFQRelease(pidStr);
      junk = mach_port_deallocate(mach_task_self(), targetTask); 
      assert(junk == 0);
      if (threadList != NULL) {
        mach_msg_type_number_t thisThread;
        
        for (thisThread = 0; thisThread &lt; threadCount; thisThread++) {
          junk = mach_port_deallocate(mach_task_self(), threadList[thisThread]);
          assert(junk == noErr);
        }
        junk = vm_deallocate(mach_task_self(), (vm_address_t) threadList, threadCount * sizeof(*threadList));
        assert(junk == noErr);
      }
    }
    
    static void MySIGUSR1Handler(int signal)
      // Handle SIGUSR1.  Note that we call many functions 
      // here that aren't &quot;signal safe&quot;.  However, we know 
      // that this signal isn't happening asynchronously, 
      // we're sending it to ourselves via a call to &quot;kill&quot;, 
      // so most of the unsafeness is moot.  Still, if this 
      // wasn't a just test program I'd figure out a better way.
    {
      assert(signal == SIGUSR1);
      
      TestMoreBacktracePPCMachSelf();
    }

    static OSStatus TestSignalBacktraceNested(void)
      // Send a SIGUSR1 to ourselves.  Ideally I'd like to send 
      // this to our specific thread using pthread_kill, but that 
      // function doesn't existing on 10.1.  So, instead we rely 
      // on the behaviour documented in DTS Q&amp;A 1184, which 
      // indicates that the main thread will catch the signal.
      // Of course, the Q&amp;A says that you shouldn't rely on this 
      // behaviour, but hey, this is only a test program.
      //
      // &lt;http://developer.apple.com/qa/qa2001/qa1184.html&gt;
    {
      OSStatus err;
      
        err = kill(getpid(), SIGUSR1);
        err = MoreUNIXErrno(err);
        return err;
    }

    static void TestSignalBacktrace(void)
    {
        OSStatus       err;
        OSStatus       junk;
        struct sigaction   oldSig;
        struct sigaction   newSig;

      // Install MySIGUSR1Handler as the SIGUSR1 handler.
      
        newSig.sa_handler = &amp;MySIGUSR1Handler;
        sigemptyset(&amp;newSig.sa_mask);
        newSig.sa_flags   = SA_RESTART;
        err = sigaction(SIGUSR1, &amp;newSig, &amp;oldSig);
        err = MoreUNIXErrno(err);
        
        if (err == 0) {
        
          // Call a routine that sends a signal to us.
          
            err = TestSignalBacktraceNested();
            
            // Restore the old signal handler.
            
            junk = sigaction(SIGUSR1, &amp;oldSig, NULL);
            assert(junk == noErr);
        }

      // Complain if we got an error.
      
      DisplayError(err);
    }

  #endif

  // Code to sample the current PC and SP.  I copied this directly 
  // out of &quot;MoreBacktrace.c&quot;.  In an ideal world I'd only have one 
  // copy of this, but I don't want to export it from MoreBackTrace 
  // because it's so ugly.  So, for the moment, we have two copies.
  //
  // See the code &quot;MoreBacktrace.c&quot; for comments about how this works.
  //
  // Gosh, it'd be nice if GCC and CodeWarrior could agree about 
  // inline assembler.
  
  #if defined(__MWERKS__)

        #define MoreBTPPCGetStackPointer(result)            \
                asm {  addi  result,sp,0    }

    asm static const void * MoreBTPPCGetProgramCounter(void)
    {
      mflr    r3
      blr
    }
  
  #elif defined(__GNUC__) &amp;&amp; ( defined(__APPLE_CPP__) || defined(__APPLE_CC__) || defined(__MACOS_CLASSIC__) )

        #define MoreBTPPCGetStackPointer(result)            \
                __asm__ volatile(&quot;mr    %0,r1&quot; : &quot;=r&quot; (result));

        static const void * MoreBTPPCGetProgramCounter(void)
    {
            const void * result;
            __asm__ volatile(&quot;mflr    %0&quot; : &quot;=r&quot; (result));
            return result;
    }

  #else
    #error MoreBacktrace: What compiler are you using?
  #endif
  
  static Boolean           gDeadThreadReady = false;
  static MPQueueID         gReadyQueue;
  static const void *  volatile   gDeadThreadSP;
  static const void *  volatile   gDeadThreadPC;
  
  static void DeadThreadNested4(void)
    // The victim routine itself.  It stores its PC and SP 
    // in globals, notifies gReadyQueue so that the main 
    // thread can continue, and then blocks indefinitely on 
    // waitForeverQ.
  {
    OSStatus         err;
    MPQueueID         waitForeverQ;
    register const void *  mySP;
    const void *      myPC;
    
    MoreBTPPCGetStackPointer(mySP);
    myPC = MoreBTPPCGetProgramCounter();
    
    gDeadThreadSP = mySP;
    gDeadThreadPC = myPC;
    
    err = MPCreateQueue(&amp;waitForeverQ);
    if (err == noErr) {
      err = MPNotifyQueue(gReadyQueue, NULL, NULL, NULL);
    }
    if (err == noErr) {
      err = MPWaitOnQueue(waitForeverQ, NULL, NULL, NULL, kDurationForever);
    }
    assert(err == noErr);
  }

  static void DeadThreadNested3(void)
    // A few nested procedures so you get an interesting trace.
  {
    DeadThreadNested4();
  }
  
  static void DeadThreadNested2(void)
    // A few nested procedures so you get an interesting trace.
  {
    DeadThreadNested3();
  }
  
  static void DeadThreadNested1(void)
    // A few nested procedures so you get an interesting trace.
  {
    DeadThreadNested2();
  }
  
  static OSStatus DeadThread(void *param)
    // The thread entry point for the victim thread.
  {
    #pragma unused(param)
    DeadThreadNested1();
    return noErr;
  }

  static OSStatus StartDeadThread(void)
    // Start a victim thread whose stack we intend to smash 
    // in order to test our handling of bad pointers in a 
    // stack crawl.  When the thread starts up it initialises 
    // gDeadThreadSP and gDeadThreadPC, signals gReadyQueue, 
    // and then blocks forever.  We wait for the signal on 
    // gReadyQueue so that we know that gDeadThreadSP and 
    // gDeadThreadPC are set up before we return to our caller.
  {
    OSStatus   err;

    err = noErr;
    if ( ! MPLibraryIsLoaded() ) {
      err = unimpErr;
    }
    if (err == noErr) {
      err = MPCreateQueue(&amp;gReadyQueue);
    }
    if (err == noErr) {
      err = MPCreateTask(DeadThread, NULL, 0, kInvalidID, NULL, NULL, kNilOptions, NULL);
    }
    if (err == noErr) {
      err = MPWaitOnQueue(gReadyQueue, NULL, NULL, NULL, kDurationForever);
    }
    
    gDeadThreadReady = (err == noErr);
    
    return err;
  }
  
  static void TestStackSmash(void)
  {
    OSStatus        err;
    MoreBTPPCFrame       frames[kFrameCount];
    ItemCount        frameCount;
    ItemCount        validFrames;
    static const void *    sBusErrorAddress = NULL;
    
    ClearOutput();
    
    if (sBusErrorAddress == NULL) {
      if ( MoreRunningOnMacOSX() ) {

        // I don't want to use 0 for the Mac OS X bus error value, because 
        // it's a little obvious.  Instead I use a value that's in the bottom 
        // page (ie is less than 0x1000) and is easily recognisable.
        
        sBusErrorAddress = (const void *) 0x0FEC;
        
      } else {
      
        // On traditional Mac OS we don't want to use 0 because it's mapped, 
        // so we used the blessed bus error value.
        
        sBusErrorAddress = (const void *) kBlessedBusErrorBait;
      }
    }
    
    // Start a thread that just blocks indefinitely.  This is the 
    // thread whose stack we're going to smash.
    
    err = noErr;
    if ( ! gDeadThreadReady ) {
      err = StartDeadThread();
    }
    assert( (err != noErr) || gDeadThreadReady );
    
    if (err == noErr) {
      int        i;
      const void **  thisFrame;
      
      frameCount = sizeof(frames) / sizeof(*frames);
      
      // We smash the stack in three different ways.
      //
      // 1. We smash the current PC address pointer.
      
      gDeadThreadPC = (const void *) sBusErrorAddress;
      
      // 2. We go down 3 frames on the stack and smash the next 
      //    frame pointer.
      
      thisFrame = (const void **) gDeadThreadSP;
      for (i = 0; i &lt; 3; i++) {
        thisFrame = (const void **) *thisFrame;
      }
      *thisFrame = sBusErrorAddress;
      
      // 3. We go down 2 frames on the stack and smash the 
      //    return address.

      thisFrame = (const void **) gDeadThreadSP;
      for (i = 0; i &lt; 2; i++) {
        thisFrame = (const void **) *thisFrame;
      }
      *((const void **)((const char *) thisFrame + 8)) = sBusErrorAddress;
      
      // Now let's do the backtrace and see what happens.
      
      err = MoreBacktracePPCCarbon((MoreBTPPCAddr) gDeadThreadPC, (MoreBTPPCAddr) gDeadThreadSP, 0, 0, frames, frameCount, &amp;validFrames);
      if (err == noErr) {
        if (validFrames &gt; frameCount) {
          validFrames = frameCount;
        }
        err = OutputFrames(frames, validFrames, true);
      }
    }

    DisplayError(err);
  }

  static EventHandlerUPP gApplicationEventHandlerUPP;    // -&gt; ApplicationEventHandler

  static const EventTypeSpec kApplicationEvents[] = { {kEventClassCommand, kEventCommandProcess} };

  static pascal OSStatus ApplicationEventHandler(EventHandlerCallRef inHandlerCallRef, 
                           EventRef inEvent, void *inUserData)
    // Dispatches HICommands to their implementations.
  {
    OSStatus   err;
    HICommand   command;
    Boolean    displayMachAlert;
    #pragma unused(inHandlerCallRef)
    #pragma unused(inUserData)
    
    displayMachAlert = false;
    
    assert( GetEventClass(inEvent) == kEventClassCommand  );
    assert( GetEventKind(inEvent)  == kEventCommandProcess);
    
    err = GetEventParameter(inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof(command), NULL, &amp;command);
    if (err == noErr) {
      switch (command.commandID) {
        case kHICommandAbout:
          DoAbout();
          break;
        case 'btCS':
          TestMoreBacktracePPCCarbonSelf();
          break;
        case 'btMS':
          #if TARGET_RT_MAC_MACHO
            TestMoreBacktracePPCMachSelf();
          #else
            displayMachAlert = true;
          #endif
          break;
        case 'btMT':
          #if TARGET_RT_MAC_MACHO
            TestMoreBacktracePPCMachThread();
          #else
            displayMachAlert = true;
          #endif
          break;
        case 'btST':
          #if TARGET_RT_MAC_MACHO
            TestSignalBacktrace();
          #else
            displayMachAlert = true;
          #endif
          break;
        case 'btSS':
          TestStackSmash();
          break;
        default:
          err = eventNotHandledErr;
          break;
      }
    }
    
    if (displayMachAlert) {
      SInt16       junkHit;
      (void) StandardAlert(kAlertPlainAlert, &quot;\pCan't test Mach in CFM build.&quot;, &quot;\p&quot;, NULL, &amp;junkHit);
    }
    
    return err;
  }

  int main(int argc, char* argv[])
  {
      OSStatus    err;
      OSStatus    junk;
      UInt32      attr;
      IBNibRef     nibRef;
      WindowRef     window;
      #pragma unused(argc)
      #pragma unused(argv)
      
      // DebugStr(&quot;\pmain&quot;);
      
      nibRef = NULL;
      
      // Create menu bar from NIB.
      
    if ( (Gestalt(gestaltMenuMgrAttr, (SInt32 *) &amp;attr) == noErr) &amp;&amp; (attr &amp; (1 &lt;&lt; gestaltMenuMgrAquaLayoutBit)) ) {
        err = CreateNibReference(CFSTR(&quot;main&quot;), &amp;nibRef);      // Mac OS X menus 
    } else {
        err = CreateNibReference(CFSTR(&quot;main9&quot;), &amp;nibRef);      // traditional Mac OS menu bar
    }
      if (err == noErr) {
        err = SetMenuBarFromNib(nibRef, CFSTR(&quot;MenuBar&quot;));
      }
      if (nibRef != NULL) {
        DisposeNibReference(nibRef);
        nibRef = NULL;
    }

    // Create main window from NIB.
    
    if (err == noErr) {
        err = CreateNibReference(CFSTR(&quot;MainWindow&quot;), &amp;nibRef);
    }
      if (err == noErr) {
        err = CreateWindowFromNib(nibRef, CFSTR(&quot;MainWindow&quot;), &amp;window);
    }
      if (nibRef != NULL) {
        DisposeNibReference(nibRef);
        nibRef = NULL;
    }

    // Install our HICommand handler.
    
    if (err == noErr) {
      gApplicationEventHandlerUPP = NewEventHandlerUPP(ApplicationEventHandler);
      assert(gApplicationEventHandlerUPP != NULL);

      err = InstallApplicationEventHandler(gApplicationEventHandlerUPP, 
                         GetEventTypeCount(kApplicationEvents), 
                         kApplicationEvents, NULL, NULL);
    }

    // Get the output static text control and set it to Monaco 9.
    
    if (err == noErr) {
      err = GetControlByIDQ(window, 'ETXT', 0, &amp;gOutputText);
    }
    if (err == noErr) {
      err = GetControlByIDQ(window, 'UTXT', 0, &amp;gOutputUser);
    }
    if (err == noErr) {
      if ( MoreRunningOnMacOSX() ) {
        ControlFontStyleRec styleRec;
        SInt16 monacoFontNum;

        HideControl(gOutputUser);
        gOutputUser = NULL;
        
        GetFNum(gOutputFont, &amp;monacoFontNum);
        
        styleRec.flags = kControlUseFontMask | kControlUseSizeMask;
        styleRec.font = monacoFontNum;
        styleRec.size = gOutputSize;

        err = SetControlData(gOutputText, kControlEntireControl, kControlStaticTextStyleTag,
                   sizeof(styleRec), &amp;styleRec);
      } else {
        HideControl(gOutputText);
        err = SetOutputText(CFSTR(&quot;&quot;));
        if (err == noErr) {

          gOutputUserPaneDrawUPP = NewControlUserPaneDrawUPP(OutputUserPaneDrawProc);
          assert(gOutputUserPaneDrawUPP != NULL);
          
          err = SetControlData(gOutputUser, kControlEntireControl, kControlUserPaneDrawProcTag,
                     sizeof(gOutputUserPaneDrawUPP), &amp;gOutputUserPaneDrawUPP);
        }
      }
    }

    // Get the PID edit text field and initialise it to the Finder's PID.
    
    if (err == noErr) {
      err = GetControlByIDQ(window, 'PIDT', 0, &amp;gPIDText);
    }
    if (err == noErr) {
      #if TARGET_RT_MAC_MACHO
        ProcessSerialNumber psnFinder;
        pid_t        pidFinder;
        CFStringRef      pidFinderStr;
        #pragma unused(junk)
        
        pidFinderStr = NULL;
        
        err = MoreProcFindProcessByCreator(kSignatureFinder, &amp;psnFinder);
        if (err == noErr) {
          err = GetProcessPID(&amp;psnFinder, &amp;pidFinder);
        }
        if (err == noErr) {
          pidFinderStr = CFStringCreateWithFormat(NULL, NULL, CFSTR(&quot;%ld&quot;), (long) pidFinder);
          err = CFQError(pidFinderStr);
        }
        if (err == noErr) {
          err = SetTextControlTextCompat(gPIDText, false, pidFinderStr);
        }
        
        CFQRelease(pidFinderStr);
        
        // I don't want to refuse to start up just because this code failed, 
        // so swallow any error.
        
        assert(err == noErr);
        err = noErr;
      #else
        junk = DeactivateControl(gPIDText);
        assert(junk == noErr);
      #endif
    }

      if (err == noErr) {
        // The window was created hidden so show it.
      
        ShowWindow( window );
      
        // Call the event loop

        RunApplicationEventLoop();
    }

    return (err != noErr);
  }

#else

    // At the moment only the Carbon targets actually run.  The InterfaceLib 
    // target is only present to check for compilation errors in the 
    // MoreBacktrace module.

  int main(int argc, char* argv[])
  {
    #pragma unused(argc)
    #pragma unused(argv)
    return 1;
  }

#endif    // TARGET_API_MAC_CARBON
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoreIsBetter/listing85.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoreIsBetter/listing85.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoreIsBetter/listing85.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>