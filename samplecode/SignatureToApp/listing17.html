<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SignatureToApp - /MoreFiles Bits/Sources/Search.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxFileManagement-date.html">File Management</a> &gt; <A HREF="javascript:location.replace('index.html');">SignatureToApp</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxFileManagement-date.html" target="_blank">Carbon > File Management</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SignatureToApp</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoreFiles Bits/Sources/Search.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CarbonPrefix.h</option>
<option value="listing2.html">/Launch.c</option>
<option value="listing3.html">/MoreFiles Bits/CHeaders/DirectoryCopy.h</option>
<option value="listing4.html">/MoreFiles Bits/CHeaders/FileCopy.h</option>
<option value="listing5.html">/MoreFiles Bits/CHeaders/FSpCompat.h</option>
<option value="listing6.html">/MoreFiles Bits/CHeaders/FullPath.h</option>
<option value="listing7.html">/MoreFiles Bits/CHeaders/IterateDirectory.h</option>
<option value="listing8.html">/MoreFiles Bits/CHeaders/MoreDesktopMgr.h</option>
<option value="listing9.html">/MoreFiles Bits/CHeaders/MoreFiles.h</option>
<option value="listing10.html">/MoreFiles Bits/CHeaders/MoreFilesExtras.h</option>
<option value="listing11.html">/MoreFiles Bits/CHeaders/Search.h</option>
<option value="listing12.html">/MoreFiles Bits/Sources/MoreDesktopMgr.c</option>
<option value="listing13.html">/MoreFiles Bits/Sources/MoreFiles.c</option>
<option value="listing14.html">/MoreFiles Bits/Sources/MoreFilesExtras.c</option>
<option value="listing15.html">/MoreFiles Bits/Sources/Optimization.h</option>
<option value="listing16.html">/MoreFiles Bits/Sources/OptimizationEnd.h</option>
<option value="listing17.html">/MoreFiles Bits/Sources/Search.c</option>
<option value="listing18.html">/SignatureToApp.c</option>
<option value="listing19.html">/SignatureToApp.h</option>
<option value="listing20.html">/Standard.r</option></select>
				</p>
				</form>
				<p><strong><a href="SignatureToApp.zip">Download Sample</a></strong> (&#147;SignatureToApp.zip&#148;, 188.2K)<BR>
<strong><a href="SignatureToApp.dmg">Download Sample</a></strong> (&#147;SignatureToApp.dmg&#148;, 267.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    Search.c  Contains:  IndexedSearch and the PBCatSearch compatibility function.  Version:  MoreFiles  Copyright:  &copy; 1992-2001 by Apple Computer, Inc., all rights reserved.  You may incorporate this sample code into your applications without  restriction, though the sample code has been provided &quot;AS IS&quot; and the  responsibility for its operation is 100% yours.  However, what you are  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;  after having made changes. If you're going to re-distribute the source,  we require that you make it clear in the source that the code was  descended from Apple Sample Code, but that you've made changes.  File Ownership:    DRI:        Jim Luther    Other Contact:    Apple Macintosh Developer Technical Support              &lt;http://developer.apple.com/bugreporter/&gt;    Technology:      DTS Sample Code  Writers:    (JL)  Jim Luther  Change History (most recent first):     &lt;2&gt;    2/7/01  JL    Added standard header. Updated names of includes. Updated                  various routines to use new calling convention of the                  MoreFilesExtras accessor functions. Added TARGET_API_MAC_CARBON                  conditional checks around TimeOutTask.    &lt;1&gt;    12/06/99  JL    MoreFiles 1.5.*/#include &lt;MacTypes.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Timer.h&gt;#include &lt;MacErrors.h&gt;#include &lt;MacMemory.h&gt;#include &lt;Files.h&gt;#include &lt;TextUtils.h&gt;#define  __COMPILINGMOREFILES#include &quot;MoreFiles.h&quot;#include &quot;MoreFilesExtras.h&quot;#include &quot;Search.h&quot;/*****************************************************************************/enum{  /* Number of LevelRecs to add each time the searchStack is grown */  /* 20 levels is probably more than reasonable for most volumes. */  /* If more are needed, they are allocated 20 levels at a time. */  kAdditionalLevelRecs = 20};/*****************************************************************************//***  LevelRecs are used to store the directory ID and index whenever**  IndexedSearch needs to either scan a sub-directory, or return control**  to the caller because the call has timed out or the number of**  matches requested has been found. LevelRecs are stored in an array**  used as a stack.*/struct  LevelRec{  long  dirModDate;  /* for detecting most (but not all) catalog changes */  long  dirID;  short  index;};typedef struct LevelRec LevelRec;typedef LevelRec *LevelRecPtr, **LevelRecHandle;/***  SearchPositionRec is my version of a CatPositionRec. It holds the**  information I need to resuming searching.*/#if PRAGMA_STRUCT_ALIGN#pragma options align=mac68k#endifstruct SearchPositionRec{  long      initialize;    /* Goofy checksum of volume information used to make */                  /* sure we're resuming a search on the same volume. */  unsigned short  stackDepth;    /* Current depth on searchStack. */  short      priv[11];    /* For future use... */};#if PRAGMA_STRUCT_ALIGN#pragma options align=reset#endiftypedef struct SearchPositionRec SearchPositionRec;typedef SearchPositionRec *SearchPositionRecPtr;/***  ExtendedTMTask is a TMTask record extended to hold the timer flag.*/#if PRAGMA_STRUCT_ALIGN#pragma options align=mac68k#endifstruct ExtendedTMTask{  TMTask      theTask;  Boolean      stopSearch;    /* the Time Mgr task will set stopSearch to */                  /* true when the timer expires */};#if PRAGMA_STRUCT_ALIGN#pragma options align=reset#endiftypedef struct ExtendedTMTask ExtendedTMTask;typedef ExtendedTMTask *ExtendedTMTaskPtr;/*****************************************************************************/static  OSErr  CheckVol(ConstStr255Param pathname,             short vRefNum,             short *realVRefNum,             long *volID);static  OSErr  CheckStack(unsigned short stackDepth,               LevelRecHandle searchStack,               Size *searchStackSize);static  OSErr  VerifyUserPB(CSParamPtr userPB,               Boolean *includeFiles,               Boolean *includeDirs,               Boolean *includeNames);static  Boolean  IsSubString(ConstStr255Param aStringPtr,              ConstStr255Param subStringPtr);static  Boolean  CompareMasked(const long *data1,                const long *data2,                const long *mask,                short longsToCompare);static  void  CheckForMatches(CInfoPBPtr cPB,                CSParamPtr userPB,                const Str63 matchName,                Boolean includeFiles,                Boolean includeDirs);#if  __WANTPASCALELIMINATION#undef  pascal#endif#if TARGET_RT_MAC_CFM || TARGET_API_MAC_CARBONstatic  pascal  void  TimeOutTask(TMTaskPtr tmTaskPtr);#elsestatic  pascal  TMTaskPtr  GetTMTaskPtr(void);static  void  TimeOutTask(void);#endif#if  __WANTPASCALELIMINATION#define  pascal  #endifstatic  long  GetDirModDate(short vRefNum,                long dirID);/*****************************************************************************//***  CheckVol gets the volume's real vRefNum and builds a volID. The volID**  is used to help insure that calls to resume searching with IndexedSearch**  are to the same volume as the last call to IndexedSearch.*/static  OSErr  CheckVol(ConstStr255Param pathname,             short vRefNum,             short *realVRefNum,             long *volID){  HParamBlockRec pb;  OSErr error;  error = GetVolumeInfoNoName(pathname, vRefNum, &amp;pb);  if ( error == noErr )  {    /* Return the real vRefNum */    *realVRefNum = pb.volumeParam.ioVRefNum;    /* Add together a bunch of things that aren't supposed to change on */    /* a mounted volume that's being searched and that should come up with */    /* a fairly unique number */    *volID = pb.volumeParam.ioVCrDate +         pb.volumeParam.ioVRefNum +         pb.volumeParam.ioVNmAlBlks +         pb.volumeParam.ioVAlBlkSiz +         pb.volumeParam.ioVFSID;  }  return ( error );}/*****************************************************************************//***  CheckStack checks the size of the search stack (array) to see if there's**  room to push another LevelRec. If not, CheckStack grows the stack by**  another kAdditionalLevelRecs elements.*/static  OSErr  CheckStack(unsigned short stackDepth,               LevelRecHandle searchStack,               Size *searchStackSize){  OSErr  result;    if ( (*searchStackSize / sizeof(LevelRec)) == (stackDepth + 1) )  {    /* Time to grow stack */    SetHandleSize((Handle)searchStack, *searchStackSize + (kAdditionalLevelRecs * sizeof(LevelRec)));    result = MemError();  /* should be noErr */    *searchStackSize = GetHandleSize((Handle)searchStack);  }  else  {    result = noErr;  }    return ( result );}/*****************************************************************************//***  VerifyUserPB makes sure the parameter block passed to IndexedSearch has**  valid parameters. By making this check once, we don't have to worry about**  things like NULL pointers, strings being too long, etc.**  VerifyUserPB also determines if the search includes files and/or**  directories, and determines if a full or partial name search was requested.*/static  OSErr  VerifyUserPB(CSParamPtr userPB,               Boolean *includeFiles,               Boolean *includeDirs,               Boolean *includeNames){  CInfoPBPtr  searchInfo1;  CInfoPBPtr  searchInfo2;    searchInfo1 = userPB-&gt;ioSearchInfo1;  searchInfo2 = userPB-&gt;ioSearchInfo2;    /* ioMatchPtr cannot be NULL */  if ( userPB-&gt;ioMatchPtr == NULL )  {    goto ParamErrExit;  }    /* ioSearchInfo1 cannot be NULL */  if ( searchInfo1 == NULL )  {    goto ParamErrExit;  }    /* If any bits except partialName, fullName, or negate are set, then */  /* ioSearchInfo2 cannot be NULL because information in ioSearchInfo2 is required  */  if ( ((userPB-&gt;ioSearchBits &amp; ~(fsSBPartialName | fsSBFullName | fsSBNegate)) != 0) &amp;&amp;     ( searchInfo2 == NULL ))  {    goto ParamErrExit;  }    *includeFiles = false;  *includeDirs = false;  *includeNames = false;    if ( (userPB-&gt;ioSearchBits &amp; (fsSBPartialName | fsSBFullName)) != 0 )  {    /* If any kind of name matching is requested, then ioNamePtr in */    /* ioSearchInfo1 cannot be NULL or a zero-length string */    if ( (searchInfo1-&gt;hFileInfo.ioNamePtr == NULL) ||       (searchInfo1-&gt;hFileInfo.ioNamePtr[0] == 0) ||       (searchInfo1-&gt;hFileInfo.ioNamePtr[0] &gt; (sizeof(Str63) - 1)) )    {      goto ParamErrExit;    }        *includeNames = true;  }    if ( (userPB-&gt;ioSearchBits &amp; fsSBFlAttrib) != 0 )  {    /* The only attributes you can search on are the directory flag */    /* and the locked flag. */    if ( (searchInfo2-&gt;hFileInfo.ioFlAttrib &amp; ~(kioFlAttribDirMask | kioFlAttribLockedMask)) != 0 )    {      goto ParamErrExit;    }        /* interested in the directory bit? */    if ( (searchInfo2-&gt;hFileInfo.ioFlAttrib &amp; kioFlAttribDirMask) != 0 )    {      /* yes, so do they want just directories or just files? */      if ( (searchInfo1-&gt;hFileInfo.ioFlAttrib &amp; kioFlAttribDirMask) != 0 )      {        *includeDirs = true;      }      else      {        *includeFiles = true;      }    }    else    {      /* no interest in directory bit - get both files and directories */      *includeDirs = true;      *includeFiles = true;    }  }  else  {    /* no attribute checking - get both files and directories */    *includeDirs = true;    *includeFiles = true;  }    /* If directories are included in the search, */  /* then the locked attribute cannot be requested. */  if ( *includeDirs &amp;&amp;     ((userPB-&gt;ioSearchBits &amp; fsSBFlAttrib) != 0) &amp;&amp;     ((searchInfo2-&gt;hFileInfo.ioFlAttrib &amp; kioFlAttribLockedMask) != 0) )  {    goto ParamErrExit;  }    /* If files are included in the search, then there cannot be */  /* a search on the number of files. */  if ( *includeFiles &amp;&amp;     ((userPB-&gt;ioSearchBits &amp; fsSBDrNmFls) != 0) )  {    goto ParamErrExit;  }    /* If directories are included in the search, then there cannot */  /* be a search on file lengths. */  if ( *includeDirs &amp;&amp;     ((userPB-&gt;ioSearchBits &amp; (fsSBFlLgLen | fsSBFlPyLen | fsSBFlRLgLen | fsSBFlRPyLen)) != 0) )  {    goto ParamErrExit;  }    return ( noErr );     ParamErrExit:  return ( paramErr );}/*****************************************************************************//***  IsSubString checks to see if a string is a substring of another string.**  Both input strings have already been converted to all uppercase using**  UprString (the same non-international call the File Manager uses).*/static  Boolean  IsSubString(ConstStr255Param aStringPtr,              ConstStr255Param subStringPtr){  short  strLength;    /* length of string */  short  subStrLength;  /* length of subString */  Boolean  found;      /* result of test */  short  index;      /* current index into string */    found = false;  strLength = aStringPtr[0];  subStrLength = subStringPtr[0];      if ( subStrLength &lt;= strLength)  {    register short  count;      /* search counter */    register short  strIndex;    /* running index into string */    register short  subStrIndex;  /* running index into subString */        /* start looking at first character */    index = 1;        /* continue looking until remaining string is shorter than substring */    count = strLength - subStrLength + 1;        do    {      strIndex = index;  /* start string index at index */      subStrIndex = 1;  /* start subString index at 1 */            while ( !found &amp;&amp; (aStringPtr[strIndex] == subStringPtr[subStrIndex]) )      {        if ( subStrIndex == subStrLength )        {          /* all characters in subString were found */          found = true;        }        else        {          /* check next character of substring against next character of string */          ++subStrIndex;          ++strIndex;        }      }            if ( !found )      {        /* start substring search again at next string character */        ++index;        --count;      }    } while ( count != 0 &amp;&amp; (!found) );  }    return ( found );}/*****************************************************************************//***  CompareMasked does a bitwise comparison with mask on 1 or more longs.**  data1 and data2 are first exclusive-ORed together resulting with bits set**  where they are different. That value is then ANDed with the mask resulting**  with bits set if the test fails. true is returned if the tests pass.*/static  Boolean  CompareMasked(const long *data1,                const long *data2,                const long *mask,                short longsToCompare){  Boolean  result = true;    while ( (longsToCompare != 0) &amp;&amp; (result == true) )  {    /* (*data1 ^ *data2) = bits that are different, so... */    /* ((*data1 ^ *data2) &amp; *mask) = bits that are different that we're interested in */        if ( ((*data1 ^ *data2) &amp; *mask) != 0 )      result = false;        ++data1;    ++data2;    ++mask;    --longsToCompare;  }    return ( result );}/*****************************************************************************//***  Check for matches compares the search criteria in userPB to the file**  system object in cPB. If there's a match, then the information in cPB is**  is added to the match array and the actual match count is incremented.*/static  void  CheckForMatches(CInfoPBPtr cPB,                CSParamPtr userPB,                const Str63 matchName,                Boolean includeFiles,                Boolean includeDirs){  long    searchBits;  CInfoPBPtr  searchInfo1;  CInfoPBPtr  searchInfo2;  Str63    itemName;    /* copy of object's name for partial name matching */  Boolean    foundMatch;    foundMatch = false;      /* default to no match */    searchBits = userPB-&gt;ioSearchBits;  searchInfo1 = userPB-&gt;ioSearchInfo1;  searchInfo2 = userPB-&gt;ioSearchInfo2;    /* Into the if statements that go on forever... */    if ( (cPB-&gt;hFileInfo.ioFlAttrib &amp; kioFlAttribDirMask) == 0 )  {    if (!includeFiles)    {      goto Failed;    }  }  else  {    if (!includeDirs)    {      goto Failed;    }  }    if ( (searchBits &amp; fsSBPartialName) != 0 )  {    if ( (cPB-&gt;hFileInfo.ioNamePtr[0] &gt; 0) &amp;&amp;       (cPB-&gt;hFileInfo.ioNamePtr[0] &lt;= (sizeof(Str63) - 1)) )    {      /* Make uppercase copy of object name */      BlockMoveData(cPB-&gt;hFileInfo.ioNamePtr,              itemName,              cPB-&gt;hFileInfo.ioNamePtr[0] + 1);      /* Use the same non-international call the File Manager uses */      UpperString(itemName, true);    }    else    {      goto Failed;    }        {      if ( !IsSubString(itemName, matchName) )      {        goto Failed;      }      else if ( searchBits == fsSBPartialName )      {        /* optimize for name matching only since it is most common way to search */        goto Hit;      }    }  }    if ( (searchBits &amp; fsSBFullName) != 0 )  {    /* Use the same non-international call the File Manager uses */    if ( !EqualString(cPB-&gt;hFileInfo.ioNamePtr, matchName, false, true) )    {      goto Failed;    }    else if ( searchBits == fsSBFullName )    {      /* optimize for name matching only since it is most common way to search */      goto Hit;    }  }    if ( (searchBits &amp; fsSBFlParID) != 0 )  {    if ( ((unsigned long)(cPB-&gt;hFileInfo.ioFlParID) &lt; (unsigned long)(searchInfo1-&gt;hFileInfo.ioFlParID)) ||       ((unsigned long)(cPB-&gt;hFileInfo.ioFlParID) &gt; (unsigned long)(searchInfo2-&gt;hFileInfo.ioFlParID)) )    {      goto Failed;    }  }    if ( (searchBits &amp; fsSBFlAttrib) != 0 )  {    if ( ((cPB-&gt;hFileInfo.ioFlAttrib ^ searchInfo1-&gt;hFileInfo.ioFlAttrib) &amp;        searchInfo2-&gt;hFileInfo.ioFlAttrib) != 0 )    {      goto Failed;    }  }    if ( (searchBits &amp; fsSBDrNmFls) != 0 )  {    if ( ((unsigned long)(cPB-&gt;dirInfo.ioDrNmFls) &lt; (unsigned long)(searchInfo1-&gt;dirInfo.ioDrNmFls)) ||       ((unsigned long)(cPB-&gt;dirInfo.ioDrNmFls) &gt; (unsigned long)(searchInfo2-&gt;dirInfo.ioDrNmFls)) )    {      goto Failed;    }  }  if ( (searchBits &amp; fsSBFlFndrInfo) != 0 )  /* fsSBFlFndrInfo is same as fsSBDrUsrWds */  {    if ( !CompareMasked((long *)&amp;(cPB-&gt;hFileInfo.ioFlFndrInfo),              (long *)&amp;(searchInfo1-&gt;hFileInfo.ioFlFndrInfo),              (long *)&amp;(searchInfo2-&gt;hFileInfo.ioFlFndrInfo),              sizeof(FInfo) / sizeof(long)) )    {      goto Failed;    }  }    if ( (searchBits &amp; fsSBFlXFndrInfo) != 0 )  /* fsSBFlXFndrInfo is same as fsSBDrFndrInfo */  {    if ( !CompareMasked((long *)&amp;(cPB-&gt;hFileInfo.ioFlXFndrInfo),              (long *)&amp;(searchInfo1-&gt;hFileInfo.ioFlXFndrInfo),              (long *)&amp;(searchInfo2-&gt;hFileInfo.ioFlXFndrInfo),              sizeof(FXInfo) / sizeof(long)) )    {      goto Failed;    }  }    if ( (searchBits &amp; fsSBFlLgLen) != 0 )  {    if ( ((unsigned long)(cPB-&gt;hFileInfo.ioFlLgLen) &lt; (unsigned long)(searchInfo1-&gt;hFileInfo.ioFlLgLen)) ||       ((unsigned long)(cPB-&gt;hFileInfo.ioFlLgLen) &gt; (unsigned long)(searchInfo2-&gt;hFileInfo.ioFlLgLen)) )    {      goto Failed;    }  }  if ( (searchBits &amp; fsSBFlPyLen) != 0 )  {    if ( ((unsigned long)(cPB-&gt;hFileInfo.ioFlPyLen) &lt; (unsigned long)(searchInfo1-&gt;hFileInfo.ioFlPyLen)) ||       ((unsigned long)(cPB-&gt;hFileInfo.ioFlPyLen) &gt; (unsigned long)(searchInfo2-&gt;hFileInfo.ioFlPyLen)) )    {      goto Failed;    }  }  if ( (searchBits &amp; fsSBFlRLgLen) != 0 )  {    if ( ((unsigned long)(cPB-&gt;hFileInfo.ioFlRLgLen) &lt; (unsigned long)(searchInfo1-&gt;hFileInfo.ioFlRLgLen)) ||       ((unsigned long)(cPB-&gt;hFileInfo.ioFlRLgLen) &gt; (unsigned long)(searchInfo2-&gt;hFileInfo.ioFlRLgLen)) )    {      goto Failed;    }  }  if ( (searchBits &amp; fsSBFlRPyLen) != 0 )  {    if ( ((unsigned long)(cPB-&gt;hFileInfo.ioFlRPyLen) &lt; (unsigned long)(searchInfo1-&gt;hFileInfo.ioFlRPyLen)) ||       ((unsigned long)(cPB-&gt;hFileInfo.ioFlRPyLen) &gt; (unsigned long)(searchInfo2-&gt;hFileInfo.ioFlRPyLen)) )    {      goto Failed;    }  }  if ( (searchBits &amp; fsSBFlCrDat) != 0 )  /* fsSBFlCrDat is same as fsSBDrCrDat */  {    if ( ((unsigned long)(cPB-&gt;hFileInfo.ioFlCrDat) &lt; (unsigned long)(searchInfo1-&gt;hFileInfo.ioFlCrDat)) ||       ((unsigned long)(cPB-&gt;hFileInfo.ioFlCrDat) &gt; (unsigned long)(searchInfo2-&gt;hFileInfo.ioFlCrDat)) )    {      goto Failed;    }  }  if ( (searchBits &amp; fsSBFlMdDat) != 0 )  /* fsSBFlMdDat is same as fsSBDrMdDat */  {    if ( ((unsigned long)(cPB-&gt;hFileInfo.ioFlMdDat) &lt; (unsigned long)(searchInfo1-&gt;hFileInfo.ioFlMdDat)) ||       ((unsigned long)(cPB-&gt;hFileInfo.ioFlMdDat) &gt; (unsigned long)(searchInfo2-&gt;hFileInfo.ioFlMdDat)) )    {      goto Failed;    }  }  if ( (searchBits &amp; fsSBFlBkDat) != 0 )  /* fsSBFlBkDat is same as fsSBDrBkDat */  {    if ( ((unsigned long)(cPB-&gt;hFileInfo.ioFlBkDat) &lt; (unsigned long)(searchInfo1-&gt;hFileInfo.ioFlBkDat)) ||       ((unsigned long)(cPB-&gt;hFileInfo.ioFlBkDat) &gt; (unsigned long)(searchInfo2-&gt;hFileInfo.ioFlBkDat)) )    {      goto Failed;    }  }  /* Hey, we passed all of the tests! */  Hit:  foundMatch = true;/* foundMatch is false if code jumps to Failed */Failed:  /* Do we reverse our findings? */  if ( (searchBits &amp; fsSBNegate) != 0 )  {    foundMatch = !foundMatch;  /* matches are not, not matches are */  }    if ( foundMatch )  {    /* Move the match into the match buffer */    userPB-&gt;ioMatchPtr[userPB-&gt;ioActMatchCount].vRefNum = cPB-&gt;hFileInfo.ioVRefNum;    userPB-&gt;ioMatchPtr[userPB-&gt;ioActMatchCount].parID = cPB-&gt;hFileInfo.ioFlParID;    if ( cPB-&gt;hFileInfo.ioNamePtr[0] &gt; 63 )    {      cPB-&gt;hFileInfo.ioNamePtr[0] = 63;    }    BlockMoveData(cPB-&gt;hFileInfo.ioNamePtr,            userPB-&gt;ioMatchPtr[userPB-&gt;ioActMatchCount].name,            cPB-&gt;hFileInfo.ioNamePtr[0] + 1);        /* increment the actual count */    ++(userPB-&gt;ioActMatchCount);  }}/*****************************************************************************//***  TimeOutTask is executed when the timer goes off. It simply sets the**  stopSearch field to true. After each object is found and possibly added**  to the matches buffer, stopSearch is checked to see if the search should**  continue.*/#if  __WANTPASCALELIMINATION#undef  pascal#endif#if TARGET_RT_MAC_CFM || TARGET_API_MAC_CARBONstatic  pascal  void  TimeOutTask(TMTaskPtr tmTaskPtr){  ((ExtendedTMTaskPtr)tmTaskPtr)-&gt;stopSearch = true;}#elsestatic  pascal  TMTaskPtr  GetTMTaskPtr(void)  ONEWORDINLINE(0x2e89);  /* MOVE.L A1,(SP) */  static  void  TimeOutTask(void){  ((ExtendedTMTaskPtr)GetTMTaskPtr())-&gt;stopSearch = true;}#endif#if  __WANTPASCALELIMINATION#define  pascal  #endif/*****************************************************************************//***  GetDirModDate returns the modification date of a directory. If there is**  an error getting the modification date, -1 is returned to indicate**  something went wrong.*/static  long  GetDirModDate(short vRefNum,                long dirID){  CInfoPBRec pb;  Str31 tempName;  long modDate;  /* Protection against File Sharing problem */  tempName[0] = 0;  pb.dirInfo.ioNamePtr = tempName;  pb.dirInfo.ioVRefNum = vRefNum;  pb.dirInfo.ioDrDirID = dirID;  pb.dirInfo.ioFDirIndex = -1;  /* use ioDrDirID */    if ( PBGetCatInfoSync(&amp;pb) == noErr )  {    modDate = pb.dirInfo.ioDrMdDat;  }  else  {    modDate = -1;  }    return ( modDate );}/*****************************************************************************/pascal  OSErr  IndexedSearch(CSParamPtr pb,                long dirID){  static LevelRecHandle  searchStack = NULL;    /* static handle to LevelRec stack */  static Size        searchStackSize = 0;  /* size of static handle */  SearchPositionRecPtr  catPosition;  long          modDate;  short          index;  ExtendedTMTask      timerTask;  OSErr          result;  short          realVRefNum;  Str63          itemName;  CInfoPBRec        cPB;  long          tempLong;  Boolean          includeFiles;  Boolean          includeDirs;  Boolean          includeNames;  Str63          upperName;    timerTask.stopSearch = false;  /* don't stop yet! */    /* If request has a timeout, install a Time Manager task. */  if ( pb-&gt;ioSearchTime != 0 )  {    /* Start timer */    timerTask.theTask.tmAddr = NewTimerUPP(TimeOutTask);    InsTime((QElemPtr)&amp;(timerTask.theTask));    PrimeTime((QElemPtr)&amp;(timerTask.theTask), pb-&gt;ioSearchTime);  }    /* Check the parameter block passed for things that we don't want to assume */  /* are OK later in the code. For example, make sure pointers to data structures */  /* and buffers are not NULL.  And while we're in there, see if the request */  /* specified searching for files, directories, or both, and see if the search */  /* was by full or partial name. */  result = VerifyUserPB(pb, &amp;includeFiles, &amp;includeDirs, &amp;includeNames);  if ( result == noErr )  {    pb-&gt;ioActMatchCount = 0;  /* no matches yet */      if ( includeNames )    {      /* The search includes seach by full or partial name. */      /* Make an upper case copy of the match string to pass to */      /* CheckForMatches. */      BlockMoveData(pb-&gt;ioSearchInfo1-&gt;hFileInfo.ioNamePtr,              upperName,              pb-&gt;ioSearchInfo1-&gt;hFileInfo.ioNamePtr[0] + 1);      /* Use the same non-international call the File Manager uses */      UpperString(upperName, true);    }        /* Prevent casting to my type throughout code */    catPosition = (SearchPositionRecPtr)&amp;pb-&gt;ioCatPosition;        /* Create searchStack first time called */    if ( searchStack == NULL )    {      searchStack = (LevelRecHandle)NewHandle(kAdditionalLevelRecs * sizeof(LevelRec));    }        /* Make sure searchStack really exists */    if ( searchStack != NULL )    {      searchStackSize = GetHandleSize((Handle)searchStack);            /* See if the search is a new search or a resumed search. */      if ( catPosition-&gt;initialize == 0 )      {        /* New search. */                /* Get the real vRefNum and fill in catPosition-&gt;initialize. */         result = CheckVol(pb-&gt;ioNamePtr, pb-&gt;ioVRefNum, &amp;realVRefNum, &amp;catPosition-&gt;initialize);        if ( result == noErr )        {          /* clear searchStack */          catPosition-&gt;stackDepth = 0;                    /* use dirID parameter passed and... */          index = -1;  /* start with the passed directory itself! */        }      }      else      {        /* We're resuming a search. */          /* Get the real vRefNum and make sure catPosition-&gt;initialize is valid. */         result = CheckVol(pb-&gt;ioNamePtr, pb-&gt;ioVRefNum, &amp;realVRefNum, &amp;tempLong);        if ( result == noErr )        {          /* Make sure the resumed search is to the same volume! */          if ( catPosition-&gt;initialize == tempLong )          {            /* For resume, catPosition-&gt;stackDepth &gt; 0 */            if ( catPosition-&gt;stackDepth &gt; 0 )            {              /* Position catPosition-&gt;stackDepth to access last saved level */              --(catPosition-&gt;stackDepth);                    /* Get the dirID and index for the next item */              dirID = (*searchStack)[catPosition-&gt;stackDepth].dirID;              index = (*searchStack)[catPosition-&gt;stackDepth].index;                            /* Check the dir's mod date against the saved mode date on our &quot;stack&quot; */              modDate = GetDirModDate(realVRefNum, dirID);              if ( modDate != (*searchStack)[catPosition-&gt;stackDepth].dirModDate )              {                result = catChangedErr;              }            }            else            {              /* Invalid catPosition record was passed */              result = paramErr;            }          }          else          {            /* The volume is not the same */            result = catChangedErr;          }        }      }            if ( result == noErr )      {        /* ioNamePtr and ioVRefNum only need to be set up once. */        cPB.hFileInfo.ioNamePtr = itemName;        cPB.hFileInfo.ioVRefNum = realVRefNum;                /*        **  Here's the loop that:        **    Finds the next item on the volume.        **    If noErr, calls the code to check for matches and add matches        **      to the match buffer.        **    Sets up dirID and index for to find the next item on the volume.        **        **  The looping ends when:        **    (a) an unexpected error is returned by PBGetCatInfo. All that        **      is expected is noErr and fnfErr (after the last item in a        **      directory is found).        **    (b) the caller specified a timeout and our Time Manager task        **      has fired.        **    (c) the number of matches requested by the caller has been found.        **    (d) the last item on the volume was found.        */        do        {          /* get the next item */          cPB.hFileInfo.ioFDirIndex = index;          cPB.hFileInfo.ioDirID = dirID;          result = PBGetCatInfoSync(&amp;cPB);          if ( index != -1 )          {            if ( result == noErr )            {              /* We found something */                  CheckForMatches(&amp;cPB, pb, upperName, includeFiles, includeDirs);                            ++index;              if ( (cPB.dirInfo.ioFlAttrib &amp; kioFlAttribDirMask) != 0 )              {                /* It's a directory */                                result = CheckStack(catPosition-&gt;stackDepth, searchStack, &amp;searchStackSize);                if ( result == noErr )                {                  /* Save the current state on the searchStack */                  /* when we come back, this is where we'll start */                  (*searchStack)[catPosition-&gt;stackDepth].dirID = dirID;                  (*searchStack)[catPosition-&gt;stackDepth].index = index;                  (*searchStack)[catPosition-&gt;stackDepth].dirModDate = GetDirModDate(realVRefNum, dirID);                                    /* position catPosition-&gt;stackDepth for next saved level */                  ++(catPosition-&gt;stackDepth);                                    /* The next item to get is the 1st item in the child directory */                  dirID = cPB.dirInfo.ioDrDirID;                  index = 1;                }              }              /* else do nothing for files */            }            else            {              /* End of directory found (or we had some error and that */              /* means we have to drop out of this directory). */              /* Restore last thing put on stack and */              /* see if we need to continue or quit. */              if ( catPosition-&gt;stackDepth &gt; 0 )              {                /* position catPosition-&gt;stackDepth to access last saved level */                --(catPosition-&gt;stackDepth);                                dirID = (*searchStack)[catPosition-&gt;stackDepth].dirID;                index = (*searchStack)[catPosition-&gt;stackDepth].index;                                /* Check the dir's mod date against the saved mode date on our &quot;stack&quot; */                modDate = GetDirModDate(realVRefNum, dirID);                if ( modDate != (*searchStack)[catPosition-&gt;stackDepth].dirModDate )                {                  result = catChangedErr;                }                else                {                  /* Going back to ancestor directory. */                  /* Clear error so we can continue. */                  result = noErr;                }              }              else              {                /* We hit the bottom of the stack, so we'll let the */                /* the eofErr drop us out of the loop. */                result = eofErr;              }            }          }          else          {            /* Special case for index == -1; that means that we're starting */            /* a new search and so the first item to check is the directory */            /* passed to us. */            if ( result == noErr )            {              /* We found something */                  CheckForMatches(&amp;cPB, pb, upperName, includeFiles, includeDirs);                            /* Now, set the index to 1 and then we're ready to look inside */              /* the passed directory. */              index = 1;            }          }        } while ( (!timerTask.stopSearch) &amp;&amp;  /* timer hasn't fired */              (result == noErr) &amp;&amp;      /* no unexpected errors */              (pb-&gt;ioReqMatchCount &gt; pb-&gt;ioActMatchCount) ); /* we haven't found our limit */                /* Did we drop out of the loop because of timeout or */        /* ioReqMatchCount was found? */        if ( result == noErr )        {          result = CheckStack(catPosition-&gt;stackDepth, searchStack, &amp;searchStackSize);          if ( result == noErr )          {            /* Either there was a timeout or ioReqMatchCount was reached. */            /* Save the dirID and index for the next time we're called. */                        (*searchStack)[catPosition-&gt;stackDepth].dirID = dirID;            (*searchStack)[catPosition-&gt;stackDepth].index = index;            (*searchStack)[catPosition-&gt;stackDepth].dirModDate = GetDirModDate(realVRefNum, dirID);                        /* position catPosition-&gt;stackDepth for next saved level */                        ++(catPosition-&gt;stackDepth);          }        }      }    }    else    {      /* searchStack Handle could not be allocated */      result = memFullErr;    }  }    if ( pb-&gt;ioSearchTime != 0 )  {    /* Stop Time Manager task here if it was installed */    RmvTime((QElemPtr)&amp;(timerTask.theTask));    DisposeTimerUPP(timerTask.theTask.tmAddr);  }    return ( result );}/*****************************************************************************/pascal OSErr PBCatSearchSyncCompat(CSParamPtr paramBlock){  OSErr           result;  Boolean          supportsCatSearch;  GetVolParmsInfoBuffer  volParmsInfo;  long          infoSize;#if !__MACOSSEVENORLATER  static Boolean      fullExtFSDispatchingtested = false;  static Boolean      hasFullExtFSDispatching = false;  long          response;#endif    result = noErr;#if !__MACOSSEVENORLATER  /* See if File Manager will pass CatSearch requests to external file systems */  /* we'll store the results in a static variable so we don't have to call Gestalt */  /* everytime we're called. (System 7.0 and later always do this) */  if ( !fullExtFSDispatchingtested )  {    fullExtFSDispatchingtested = true;    if ( Gestalt(gestaltFSAttr, &amp;response) == noErr )    {      hasFullExtFSDispatching = ((response &amp; (1L &lt;&lt; gestaltFullExtFSDispatching)) != 0);    }  }#endif    /* CatSearch is a per volume attribute, so we have to check each time we're */  /* called to see if it is available on the volume specified. */  supportsCatSearch = false;#if !__MACOSSEVENORLATER  if ( hasFullExtFSDispatching )#endif  {    infoSize = sizeof(GetVolParmsInfoBuffer);    result = HGetVolParms(paramBlock-&gt;ioNamePtr, paramBlock-&gt;ioVRefNum,              &amp;volParmsInfo, &amp;infoSize);    if ( result == noErr )    {      supportsCatSearch = hasCatSearch(&amp;volParmsInfo);    }  }    /* noErr or paramErr is OK here. */  /* paramErr just means that GetVolParms isn't supported by this volume */  if ( (result == noErr) || (result == paramErr) )  {    if ( supportsCatSearch )    {      /* Volume supports CatSearch so use it. */      /* CatSearch is faster than an indexed search. */      result = PBCatSearchSync(paramBlock);    }    else    {      /* Volume doesn't support CatSearch so */      /* search using IndexedSearch from root directory. */      result = IndexedSearch(paramBlock, fsRtDirID);    }  }    return ( result );}/*****************************************************************************/pascal  OSErr  NameFileSearch(ConstStr255Param volName,                 short vRefNum,                 ConstStr255Param fileName,                 FSSpecPtr matches,                 long reqMatchCount,                 long *actMatchCount,                 Boolean newSearch,                 Boolean partial){  CInfoPBRec    searchInfo1, searchInfo2;  HParamBlockRec  pb;  OSErr      error;  static CatPositionRec catPosition;  static short  lastVRefNum = 0;    /* get the real volume reference number */  error = DetermineVRefNum(volName, vRefNum, &amp;vRefNum);  if ( error != noErr )    return ( error );    pb.csParam.ioNamePtr = NULL;  pb.csParam.ioVRefNum = vRefNum;  pb.csParam.ioMatchPtr = matches;  pb.csParam.ioReqMatchCount = reqMatchCount;  if ( partial )  /* tell CatSearch what we're looking for: */  {    pb.csParam.ioSearchBits = fsSBPartialName + fsSBFlAttrib;  /* partial name file matches or */  }  else  {    pb.csParam.ioSearchBits =  fsSBFullName + fsSBFlAttrib;    /* full name file matches */  }  pb.csParam.ioSearchInfo1 = &amp;searchInfo1;  pb.csParam.ioSearchInfo2 = &amp;searchInfo2;  pb.csParam.ioSearchTime = 0;  if ( (newSearch) ||        /* If caller specified new search */     (lastVRefNum != vRefNum) )  /* or if last search was to another volume, */  {    catPosition.initialize = 0;  /* then search from beginning of catalog */  }  pb.csParam.ioCatPosition = catPosition;  pb.csParam.ioOptBuffer = GetTempBuffer(0x00004000, &amp;pb.csParam.ioOptBufSize);  /* search for fileName */  searchInfo1.hFileInfo.ioNamePtr = (StringPtr)fileName;  searchInfo2.hFileInfo.ioNamePtr = NULL;    /* only match files (not directories) */  searchInfo1.hFileInfo.ioFlAttrib = 0x00;  searchInfo2.hFileInfo.ioFlAttrib = kioFlAttribDirMask;  error = PBCatSearchSyncCompat((CSParamPtr)&amp;pb);    if ( (error == noErr) ||              /* If no errors or the end of catalog was */     (error == eofErr) )              /* found, then the call was successful so */  {    *actMatchCount = pb.csParam.ioActMatchCount;  /* return the match count */  }  else  {    *actMatchCount = 0;              /* else no matches found */  }    if ( (error == noErr) ||            /* If no errors */     (error == catChangedErr) )          /* or there was a change in the catalog */  {    catPosition = pb.csParam.ioCatPosition;    lastVRefNum = vRefNum;      /* we can probably start the next search where we stopped this time */  }  else  {    catPosition.initialize = 0;      /* start the next search from beginning of catalog */  }    if ( pb.csParam.ioOptBuffer != NULL )  {    DisposePtr(pb.csParam.ioOptBuffer);  }      return ( error );}/*****************************************************************************/pascal  OSErr  CreatorTypeFileSearch(ConstStr255Param volName,                    short vRefNum,                    OSType creator,                    OSType fileType,                    FSSpecPtr matches,                    long reqMatchCount,                    long *actMatchCount,                    Boolean newSearch){  CInfoPBRec    searchInfo1, searchInfo2;  HParamBlockRec  pb;  OSErr      error;  static CatPositionRec catPosition;  static short  lastVRefNum = 0;    /* get the real volume reference number */  error = DetermineVRefNum(volName, vRefNum, &amp;vRefNum);  if ( error != noErr )    return ( error );    pb.csParam.ioNamePtr = NULL;  pb.csParam.ioVRefNum = vRefNum;  pb.csParam.ioMatchPtr = matches;  pb.csParam.ioReqMatchCount = reqMatchCount;  pb.csParam.ioSearchBits = fsSBFlAttrib + fsSBFlFndrInfo;  /* Looking for finder info file matches */  pb.csParam.ioSearchInfo1 = &amp;searchInfo1;  pb.csParam.ioSearchInfo2 = &amp;searchInfo2;  pb.csParam.ioSearchTime = 0;  if ( (newSearch) ||        /* If caller specified new search */     (lastVRefNum != vRefNum) )  /* or if last search was to another volume, */  {    catPosition.initialize = 0;  /* then search from beginning of catalog */  }  pb.csParam.ioCatPosition = catPosition;  pb.csParam.ioOptBuffer = GetTempBuffer(0x00004000, &amp;pb.csParam.ioOptBufSize);  /* no fileName */  searchInfo1.hFileInfo.ioNamePtr = NULL;  searchInfo2.hFileInfo.ioNamePtr = NULL;    /* only match files (not directories) */  searchInfo1.hFileInfo.ioFlAttrib = 0x00;  searchInfo2.hFileInfo.ioFlAttrib = kioFlAttribDirMask;    /* search for creator; if creator = 0x00000000, ignore creator */  searchInfo1.hFileInfo.ioFlFndrInfo.fdCreator = creator;  if ( creator == (OSType)0x00000000 )  {    searchInfo2.hFileInfo.ioFlFndrInfo.fdCreator = (OSType)0x00000000;  }  else  {    searchInfo2.hFileInfo.ioFlFndrInfo.fdCreator = (OSType)0xffffffff;  }    /* search for fileType; if fileType = 0x00000000, ignore fileType */  searchInfo1.hFileInfo.ioFlFndrInfo.fdType = fileType;  if ( fileType == (OSType)0x00000000 )  {    searchInfo2.hFileInfo.ioFlFndrInfo.fdType = (OSType)0x00000000;  }  else  {    searchInfo2.hFileInfo.ioFlFndrInfo.fdType = (OSType)0xffffffff;  }    /* zero all other FInfo fields */  searchInfo1.hFileInfo.ioFlFndrInfo.fdFlags = 0;  searchInfo1.hFileInfo.ioFlFndrInfo.fdLocation.v = 0;  searchInfo1.hFileInfo.ioFlFndrInfo.fdLocation.h = 0;  searchInfo1.hFileInfo.ioFlFndrInfo.fdFldr = 0;    searchInfo2.hFileInfo.ioFlFndrInfo.fdFlags = 0;  searchInfo2.hFileInfo.ioFlFndrInfo.fdLocation.v = 0;  searchInfo2.hFileInfo.ioFlFndrInfo.fdLocation.h = 0;  searchInfo2.hFileInfo.ioFlFndrInfo.fdFldr = 0;  error = PBCatSearchSyncCompat((CSParamPtr)&amp;pb);    if ( (error == noErr) ||              /* If no errors or the end of catalog was */     (error == eofErr) )              /* found, then the call was successful so */  {    *actMatchCount = pb.csParam.ioActMatchCount;  /* return the match count */  }  else  {    *actMatchCount = 0;              /* else no matches found */  }    if ( (error == noErr) ||            /* If no errors */     (error == catChangedErr) )          /* or there was a change in the catalog */  {    catPosition = pb.csParam.ioCatPosition;    lastVRefNum = vRefNum;      /* we can probably start the next search where we stopped this time */  }  else  {    catPosition.initialize = 0;      /* start the next search from beginning of catalog */  }    if ( pb.csParam.ioOptBuffer != NULL )  {    DisposePtr(pb.csParam.ioOptBuffer);  }      return ( error );}/*****************************************************************************/</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SignatureToApp/listing17.html%3Fid%3DDTS10000755-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SignatureToApp/listing17.html%3Fid%3DDTS10000755-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SignatureToApp/listing17.html%3Fid%3DDTS10000755-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>