<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Audio Device Driver Programming Guide: Audio on Mac OS X</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Audio on Mac OS X"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000730" title="Audio on Mac OS X"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/MusicAudio-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000452" target="_top">Audio</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30000729-CH204-DontLinkElementID_4">Audio Device Driver Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../About/About.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AudioFamilyDesign/AudioFamilyDesign.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000730-DontLinkElementID_8" title="Audio on Mac OS X"></a><h1><a name="//apple_ref/doc/uid/TP30000730-TPXREF101" title="Audio on Mac OS X"></a>Audio on Mac OS X</h1><p>This chapter gives an overview of audio on Mac OS X, describing its capabilities, its interrelated technologies, and its architecture. Reading this chapter will help you to understand how the I/O Kit’s Audio family fits together and interacts with the other pieces of audio software on Mac OS X. </p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-TPXREF102">Mac OS X Audio Capabilities</a>
				
			<br/>
			
        
			
			
				<a href="AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-TPXREF103">Architecture of Mac OS X Audio</a>
				
			<br/>
			
        
			
			
				<a href="AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-BBCCCFFA">The Audio I/O Model on Mac OS X</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000730-TPXREF102" title="Mac OS X Audio Capabilities"></a><h2>Mac OS X Audio Capabilities</h2>
<p>In versions of Macintosh system software prior to Mac OS X, the sound capabilities of a system largely depended on the availability of third-party audio and MIDI protocols and services. Apple has designed the Mac OS X audio system to consolidate, integrate, and standardize these services and protocols, thereby streamlining configuration of audio and MIDI devices and development of future audio and MIDI technologies.</p>
<p>Audio on Mac OS X comprises several audio technologies that, taken together, offer the following capabilities:</p>
<ul class="ul"><li class="li"><p>Built-in support for a variety of audio formats, including formats based on pulse code modulation (PCM) and encoded formats such as AC-3 and MP3</p></li>
<li class="li"><p>Multi-channel audio I/O that is scalable to a virtually unlimited number of channels</p></li>
<li class="li"><p>Variable sample rates</p></li>
<li class="li"><p>A remarkably clean signal path requiring little overhead</p></li>
<li class="li"><p>Simultaneous access for multiple clients to all of the audio devices attached to the host, no matter how the connection is made (PCI, USB, FireWire, and so on)</p></li></ul>
<p>Outside the kernel, Mac OS X represents audio as 32-bit floating point data; this format allows efficient processing of data with today’s advanced audio peripherals (for example, those capable of 24-bit, 192 kHz operation) and ensures that the system can scale to future high-resolution formats.</p>
<a name="//apple_ref/doc/uid/TP30000730-TPXREF103" title="Architecture of Mac OS X Audio"></a><h2>Architecture of Mac OS X Audio</h2>
<p>The audio capabilities of Mac OS X arise from several software technologies that are accessible through their public programming interfaces. These technologies are situated at different levels of the operating system where their relationships with each other can be characterized as client and provider. In other words, Mac OS X audio software is layered, with one layer dependent on the layer “under” it and communicating, through defined interfaces, with adjoining layers (see <span class="content_text"><a href="AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-BBCFCGJF">Figure 1-1</a></span>).</p>
<p>The relative locations of these technologies within the layers of system software suggest their degree of abstraction and their proximity to audio hardware. Some audio technologies in Mac OS X are incorporated into the kernel environment (that is, Darwin) while others are packaged as frameworks for use by application environments, applications, and other user processes.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000730-BBCFCGJF" title="Figure 1-1Mac OS X audio layers"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Mac OS X audio layers</p>
<img src = "../Art/audioarchitecture.gif" alt = "Mac OS X audio layers" width="445" height="251"></div><br/>
<p>At the lowest level of the Mac OS X audio stack is the driver that controls audio hardware. The driver is based on the I/O Kit’s audio family, which provides much of the functionality and data structures needed by the driver. For example, the Audio family implements the basic timing mechanisms, provides the user-client objects that communicate with the upper layers, and maintains the sample and mix buffers (which hold audio data for the hardware and the hardware’s clients, respectively).</p>
<p>The basic role of the audio driver is to control the process that moves audio data between the hardware and the sample buffer. It is responsible for providing that sample data to the upper layers of the system when necessary, making any necessary format conversions in the process. In addition, an audio driver must make the necessary calls to audio hardware in response to format and control changes (for example, volume and mute).</p>
<p>Immediately above the driver and the I/O Kit’s Audio family—and just across the boundary between kernel and user space—is the Audio Hardware Abstraction Layer (HAL). The Audio HAL functions as the device interface for the I/O Kit Audio family and its drivers. For input streams, its job is to make the audio data it receives from drivers accessible to its clients. For output streams, its job is to take the audio data from its clients and pass it to a particular audio driver.</p>
<p>The Audio Units and Audio Toolbox frameworks are two other frameworks that provide specialized audio services. They are both built on top of the Audio HAL, which is implemented in the Core Audio framework.</p>
<p>MIDI System Services, which comprises two other frameworks, is not directly dependent on the Audio HAL. As its name suggests, MIDI System Services makes MIDI services available to applications and presents an API for creating MIDI drivers.</p>
<p>Finally, the ultimate clients of audio on Mac OS X—applications, frameworks, and other user processes—can directly access the Audio HAL or indirectly access it through one of the higher-level audio frameworks. They can also indirectly access the Audio HAL through the audio-related APIs of the application environments they belong to: Sound Manager in Carbon, <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSSound_Class/Reference/Reference.html#//apple_ref/doc/uid/20000393" target="_top">NSSound</a></code> in Cocoa, and the Java sound APIs.</p>
<p>The following sections examine each of these audio technologies of Mac OS X in more detail.</p>
<a name="//apple_ref/doc/uid/TP30000730-TPXREF104" title="Audio HAL (Core Audio)"></a><h3>Audio HAL (Core Audio)</h3>
<p>The Audio Hardware Abstraction Layer (HAL) is the layer of the Mac OS X audio system that acts as an intermediary between the I/O Kit drivers controlling audio hardware and the programs and frameworks in user space that are clients of the hardware. More specifically, the Audio HAL is the standardized device interface for the I/O Kit’s Audio family. It is implemented in the Core Audio framework (<code>CoreAudio.framework</code>) and presents both C-language and Java APIs. In the Audio HAL, all audio data is in 32-bit floating point format.</p>
<p>The API of the Audio HAL includes three main abstractions: audio hardware, audio device, and audio stream.</p>
<ul class="spaceabove"><li class="li"><p>The audio hardware API gives clients access to audio entities that exist in the “global” space, such as the list of current devices and the default device.</p></li>
<li class="li"><p>The audio device API enables clients to manage and query a specific audio device and the I/O engines that it contains. An audio device in the Audio HAL represents a single I/O cycle, a clock source based on it, and all the buffers that are synchronized to this cycle. The audio device methods permit a client to, among other things, start and stop audio streams, retrieve and translate the time, and get and set properties of the audio device. </p></li>
<li class="li"><p>The audio stream API enables a client to control and query an audio stream. Each audio device has one or more audio streams, which encapsulate the buffer of memory used for transferring audio data across the user/kernel boundary. They also specify the format of the audio data.</p></li></ul>
<p>The abstractions of audio device and audio stream loosely correspond to different I/O Kit Audio family objects in the kernel (see <span class="content_text"><a href="AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-BBCECIDI">“The Audio Family”</a></span>). For example, the entity referred to as “audio device” in the Audio HAL corresponds to a combination of an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> in the kernel. For each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> the Audio HAL finds in the kernel, it generates an audio-device identifier. However, there is considerable overlap of role among the various Audio family and Audio HAL objects and entities.</p>
<p>A critical part of the APIs for audio hardware, devices, and streams involves audio properties and their associated notifications. These APIs allow clients to get and set properties of audio hardware. The “get” methods are synchronous, but the “set” methods work in an asynchronous manner that makes use of notifications. Clients of the Audio HAL implement “listener procs”—callback functions for properties associated with audio hardware, audio devices, or audio streams. When an audio driver changes a property of the hardware, either as a result of user manipulation of a physical control or in response to a “set” method, it sends notifications to interested Audio HAL clients. This results in the appropriate “listener procs” being called.</p>
<p>Just as important as the property APIs is the callback prototype (<code><a href="../../../../MusicAudio/Reference/CACoreAudioReference/AudioHardware/CompositePage.html#//apple_ref/c/tdef/AudioDeviceIOProc" target="_top">AudioDeviceIOProc</a></code>) that the audio-device subset of the Audio HAL API defines for I/O management. Clients of the Audio HAL must implement a function or method conforming to this prototype to perform I/O transactions for a given device. Through this function, the Audio HAL presents all inputs and outputs simultaneously in an I/O cycle to the client for processing. In this function, a client of the Audio HAL must send audio data to the audio device (for output), or copy and process the audio data received from the audio device (for input).</p>
<a name="//apple_ref/doc/uid/TP30000730-TPXREF105" title="Secondary Audio Frameworks"></a><h3>Secondary Audio Frameworks</h3>
<p>Mac OS X has several frameworks other than the Core Audio framework that offer audio-related functionality to applications. Two of these frameworks—Audio Units and Audio Toolbox—are built directly on the Core Audio framework. MIDI System Services (consisting of the Core MIDI and Core MIDI Server frameworks) does not directly depend on the Core Audio framework, but is still a consumer of the services of the audio frameworks.</p>
<p>All of these secondary frameworks are implemented in the C language and present their public programming interfaces in C. Thus, any application or other program in any application environment can take advantage of their capabilities.</p>
<a name="//apple_ref/doc/uid/TP30000730-TPXREF106" title="Audio Units"></a><h4>Audio Units</h4>
<p>The Audio Units framework (<code>AudioUnits.framework</code>) provides support for generating, processing, receiving, and manipulating or transforming streams of audio data. This functionality is based on the notion of audio units.</p>
<p>Audio units are one form of a building block called a component. A component is a piece of code that provides a defined set of services to one or more clients. In the case of audio units, these clients can use audio unit components either singly or connected together to form an audio signal graph. To compose an audio signal graph, clients can use the AUGraph API in the Audio Toolbox framework—see <span class="content_text"><a href="AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-BBCEDJHG">“Audio Toolbox”</a></span> for details.</p>
<p>An audio unit can have one or more inputs and outputs. The inputs can accept either encoded audio data or MIDI data. The output is generally a buffer of audio data. Using a “pull I/O” model, an audio unit specifies the number and format of its inputs and outputs through its properties. Each output is in itself a stream of an arbitrary number of interleaved audio channels derived from the audio unit’s inputs. Clients also manage the connections between units through properties.</p>
<p>Examples of audio units are DSP processors (such as reverbs, filters, and mixers), format converters (for example, 16-bit integer to floating-point converters), interleavers-deinterleavers, and sample rate converters. In addition to defining the interface for custom audio units in the Audio Units framework, Apple ships a set of audio units. One of these is the MusicDevice component, which presents an API targeted specifically toward software synthesis. </p>
<a name="//apple_ref/doc/uid/TP30000730-BBCEDJHG" title="Audio Toolbox"></a><h4>Audio Toolbox</h4>
<p>The Audio Toolbox framework (<code>AudioToolbox.framework</code>) complements the Audio Units framework with two major abstractions: the AUGraph and the Music Player.</p>
<p>An AUGraph provides a complete description of an audio signal processing network. It is a programmatic entity that represents a set of audio units and the connections (input and output) among them. With the AUGraph APIs, you can construct arbitrary signal paths through which audio can be processed. Audio graphs enact real-time routing changes while audio is being processed, creating and breaking connections between audio units “on the fly,” thus maintaining the representation of the graph even when constituent audio units have not been instantiated.</p>
<p>The Music Player APIs use AUGraphs to provide the services of a sequencing toolbox that collects audio events into tracks, which can then be copied, pasted, and looped within a sequence. The APIs themselves consist of a number of related programmatic entities. A Music Player plays a Music Sequence, which can be created from a standard MIDI file. A Music Sequence contains an arbitrary number of tracks (Music Tracks), each of which contains timestamped audio events in ascending temporal order. A Music Sequence usually has an AUGraph associated with it, and a Music Track usually addresses its audio events to a specific Audio Unit within the graph. Events can involve tempo and extended events, as well as regular MIDI events.</p>
<p>The Audio Toolbox framework also includes APIs for converting audio data between different formats. </p>
<a name="//apple_ref/doc/uid/TP30000730-TPXREF107" title="MIDI System Services"></a><h4>MIDI System Services</h4>
<p>MIDI System Services is a technology that allows applications and MIDI devices to communicate with each other in a single, unified way. It comprises two frameworks: Core MIDI (<code><a href="../../../../MusicAudio/Reference/CACoreMIDIRef/index.html#//apple_ref/doc/uid/TP40002091" target="_top">CoreMIDI.framework</a></code>) and Core MIDI Server (<code><a href="../../../../MusicAudio/Reference/CACoreMIDIServerRef/index.html#//apple_ref/doc/uid/TP40002092" target="_top">CoreMIDIServer.framework</a></code>).</p>
<p>MIDI System Services gives user processes high-performance access to MIDI hardware. In a manner similar to the Audio HAL, MIDI System Services implements a plug-in interface that enables clients to communicate with a MIDI device driver.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000730-DontLinkElementID_9" title="Note"></a><p><strong>Note:</strong>&nbsp; MIDI device drivers are not I/O Kit drivers. The MIDI device driver model is based on the CFPlugIn architecture and typically loads a CFPlugIn bundle from <code>/System/Library/Extensions</code> or <code>Library/Audio/MIDI Drivers</code>.</p>For MIDI devices that cannot be directly addressed from a user-space device driver (for example, a MIDI interface built into a PCI card), you must split your driver into two parts: an I/O Kit device driver that matches against the device and a CFPlugIn bundle that manipulates the I/O Kit driver using a user client.</p>The details of implementing such a mechanism are beyond the scope of this document. For information on user clients, see <span class="content_text"><a href="../../AccessingHardware/AH_IOKitLib_API/AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABEFFID" target="_top">Device-Interface Development</a></span>.</p></div>
<p>Apple provides several default MIDI drivers for interfaces that comply with USB and FireWire MIDI interface standards. Using the Core MIDI Server framework, third-party MIDI manufacturers can create their own driver plug-ins to support additional device-specific features. A MIDI server can then load and manage those drivers.</p>
<p>Applications can communicate with MIDI drivers through the client-side APIs of the Core MIDI framework.</p>
<a name="//apple_ref/doc/uid/TP30000730-BBCECIDI" title="The Audio Family"></a><h3>The Audio Family</h3>
<p>The I/O Kit’s Audio family facilitates the creation of drivers for audio hardware. Drivers created through the Audio family can support any hardware on the system, including PCI, USB, and FireWire devices. Essentially, an I/O Kit audio driver transfers audio data between the hardware and the Audio HAL. It provides one or more sample buffers along with a process that moves data between the hardware and those sample buffers. Typically this is done with the audio hardware’s DMA engine.</p>
<p>Because the native format of audio data on Mac OS X is 32-bit floating point, the driver must provide routines to convert between the hardware format of the data in the sample buffer and 32-bit floating point. The sequence of steps that a driver follows depends on the direction of the stream. For example, with input audio data, the driver is asked for a block of data. It obtains it from the sample buffer, converts it to the expected client format (32-bit floating point), and returns it. That data is then passed by the family to the Audio HAL through a user-client mechanism.</p>
<p>The interactions between the DMA engine, the driver, and the Audio HAL, are based on the assumption that, in any one direction, the stream of audio data proceeds continuously at the same rate. The Audio family sets up several timers (based on regularly taken timestamps) to synchronize the actions of the agents involved in this transfer of data. These timing mechanisms ensure that the audio data is processed at maximum speed and with minimum latency.</p>
<p>Take again an input stream as an example. Shortly after the DMA engine writes sample frames to the driver’s sample buffer, the driver reads that data, converts the integer format to 32-bit floating point, and writes the resulting frames to the mixer buffer, from whence they are passed on to the Audio HAL. Optionally, just before the DMA engine writes new frames to the same location in the sample buffer, an “erase head” zero-initializes the just-processed frames. (By default, however, the erase head only runs on output streams.)</p>
<p>For more on the sample buffer and the timer mechanisms used by the Audio family, see <span class="content_text"><a href="AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-BBCCCFFA">“The Audio I/O Model on Mac OS X.”</a></span> </p>
<p>An I/O Kit audio driver consists of a number of objects, the most important of which are derived from the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code>, and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> classes. These objects perform the following roles for the driver:</p>
<ul class="spaceabove"><li class="li"><p>A single instance of a custom subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> represents the audio device itself. The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass is the root object of a complete audio driver. It is responsible for mapping all hardware resources from the service-provider’s nub and for controlling all access to the hardware (handled automatically through a provided command gate). An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object manages one or more <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> objects.</p></li>
<li class="li"><p>An audio driver must contain one or more instances of a custom subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>. This custom subclass manages each audio I/O engine associated with the audio device. Its job is to control the process that transfers data between the hardware and a sample buffer. Typically the I/O process is implemented as a hardware DMA engine (although it doesn’t have to be). The sample buffer must be implemented as a ring buffer so that when the I/O process of a running <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> reaches the end of the buffer, it wraps back around to the beginning and keeps going.</p><p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object is also responsible for starting and stopping the engine, and for taking a timestamp each time the sample buffer wraps around to the beginning. It contains one or more <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects and can contain any number of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects.</p><p>All sample buffers within a single <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> must be the same size and running at the same rate. If you need to handle more than one buffer size or sampling rate, you must use more than one <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>.</p></li>
<li class="li"><p>An instance of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> represents a sample buffer, the associated mix buffer, and the direction of the stream. The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object also contains a representation of the current format of the sample buffer as well as a list of allowed formats for that buffer.</p></li>
<li class="li"><p>An instance of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> represents any controllable attribute of an audio device, such as volume or mute.</p></li></ul>
<p>An I/O Kit audio driver uses two user-client objects to communicate with the Audio HAL layer. The Audio HAL communicates with the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects through the <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> and <code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code> objects, respectively. The audio family creates these objects as they are needed. The <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> class provides the main linkage to an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass; it allows the Audio HAL to control the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> and it enables the engine to pass notifications of changes back to the Audio HAL. For each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object in the driver, an <code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code> object passes notifications of value changes to the Audio HAL.</p>
<p>For more detailed information on the classes and general architecture of the Audio family, see the chapter <span class="content_text"><a href="../AudioFamilyDesign/AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBBAGJF">“Audio Family Design.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000730-TPXREF108" title="Apple Audio Drivers"></a><h3>Apple Audio Drivers</h3>
<p>Apple ships several audio device drivers with a standard Mac OS X installation. These drivers are suitable for much of the audio hardware commonly found on Power PC computers. The “onboard driver” kernel extension—<code>AppleOnboardAudio.kext</code>—contains almost a half dozen audio drivers packaged as plug-ins. Each of these drivers is based on a specific subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> and each uses the code in the AppleDBDMAAudio kernel extension for the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass. The I/O Kit, through its matching process, finds and loads the appropriate plug-ins based on existing audio hardware. For USB audio hardware, Apple includes the driver defined in the <code>AppleUSBAudio.kext</code> kernel extension.</p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP30000730-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;

The set of audio drivers provided by Apple may change at any time. Your drivers should thus avoid depending on the presence or absence of specific drivers.</p><p></p></div>
<a name="//apple_ref/doc/uid/TP30000730-BBCCCFFA" title="The Audio I/O Model on Mac OS X"></a><h2>The Audio I/O Model on Mac OS X</h2>
<p>Mac OS 9 and Mac OS X perform audio I/O in very different ways. The differences between them are most salient in the lower layers of the audio stack, particularly the audio driver model and the audio access libraries. </p>
<p>In Mac OS 9, an audio driver’s DMA engine transfers audio data between a sample buffer, which is provided by the driver, and the hardware. The buffer holds a segment of the audio data containing a sequence of sample frames in temporal order.</p>
<p>The Mac OS 9 driver model uses double buffering to exchange audio data between the driver and its clients, so there are actually two sample buffers. In the case of audio output, after the driver’s clients (using the Sound Manager API) fill one of the buffers, the hardware (usually through its DMA engine) signals the driver (typically through an interrupt) that it is finished playing the other buffer and ready for more data. The driver then gives the hardware the buffer it just filled, receives the just-played buffer from the hardware, and signals the application that it needs more data.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000730-TPXREF109" title="Figure 1-2Access to the sample buffer on Mac OS 9"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Access to the sample buffer on Mac OS 9</p><img src = "../Art/os9audio.gif" alt = "Access to the sample buffer on Mac OS 9" width="253" height="331"></div><br/>
<p>The architecture and goals of Mac OS X made this design untenable. With the Mac OS X kernel, an audio driver incurs a greater cost than on Mac OS 9 when it signals an application that more audio data is needed (or that new data is available). Moreover, a major goal of the Mac OS X audio system is to support multiple simultaneous clients, which is not possible with the Mac OS 9 model. A new audio I/O model was needed not only for this goal but also to provide the highest possible performance and the lowest possible latency. <span class="content_text"><a href="AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-BBCHIFCF">Figure 1-3</a></span> depicts the audio I/O model on Mac OS X.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000730-BBCHIFCF" title="Figure 1-3The Mac OS X audio model"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>The Mac OS X audio model</p>
<img src = "../Art/osXaudio.gif" alt = "The Mac OS X audio model" width="289" height="351"></div><br/>
<p>The key facet of the Mac OS X audio I/O model involves predictive timing mechanisms. Instead of requiring the driver to message an application directly when an I/O cycle has completed, the timing mechanisms enable the Audio HAL to predict when the cycle will complete. The Audio HAL uses the extremely accurate timing code on Mac OS X to ensure that clients perform their I/O at the proper time, based on the size of their buffers. The audio driver does its part to make this possible by setting up the hardware’s sample buffer as a ring buffer and by taking an accurate timestamp every time the I/O engine wraps to the beginning of the buffer.</p>
<p>The Audio HAL keeps track of each timestamp and uses the sequence of timestamps to predict the current location of the audio I/O engine (in terms of sample frame read or written) at any time. Given that information, it can predict when a cycle will complete and sets its wake-up timestamp accordingly. This model, combined with the ability of the I/O Kit Audio family to receive audio data from each client asynchronously, allows any number of clients to provide audio data that gets mixed into the final output. It also allows different client buffer sizes; one client can operate at a very low buffer size (and a correspondingly low latency) while at the same time another client may use a much larger buffer. As long as the timestamps provided by the driver are accurate, the family and the Audio HAL do all of the work to make this possible.</p>
<p>Another important difference between the audio I/O model on Mac OS 9 and the one on Mac OS X is the native format of audio data in the system. In Mac OS 9, because the application (through the Sound Manager) has direct access to the hardware buffer, it has to deal with the native hardware format. Because of this reality, the Mac OS 9 audio libraries only support 16-bit one-channel or two-channel PCM audio data to simplify things.</p>
<p>In Mac OS X, an application cannot directly access the sample buffer. This indirection permits the use of the 32-bit floating point format between the Audio HAL and an audio driver. Consequently, the driver is responsible for providing a routine that can clip and convert that 32-bit floating point output data into the buffer’s native format. It might also have to implement a routine to convert input data into 32-bit floating point. Both routines are called asynchronously as Audio HAL clients pass audio data to the driver and receive data from it.</p>
<p>For detailed information on the Mac OS X audio I/O model, see <span class="content_text"><a href="../AudioFamilyDesign/AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBIDABE">“The Audio I/O Model Up Close.”</a></span></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../About/About.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AudioFamilyDesign/AudioFamilyDesign.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/AudioOnMacOSX/AudioOnMacOSX.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/AudioOnMacOSX/AudioOnMacOSX.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/AudioOnMacOSX/AudioOnMacOSX.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>