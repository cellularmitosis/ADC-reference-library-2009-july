<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>OpenGL Programming Guide for Mac OS X: Drawing Offscreen</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Drawing Offscreen"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001987-CH403" title="Drawing Offscreen"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../OpenGL-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000549" target="_top">OpenGL</a> &gt; <a href="../opengl_intro/opengl_intro.html#//apple_ref/doc/uid/TP40001987-CH207-TP9">OpenGL Programming Guide for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_fullscreen/opengl_cgl.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_general/opengl_gen_tasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001987-CH403-SW2" title="Drawing Offscreen"></a><h1>Drawing Offscreen</h1><p>OpenGL programs draw offscreen for many reasons. They may need to store intermediate rendering results as a scene is built or they may need to store data that is used repeatedly, such as a texture. Mac OS X provides several options for rendering offscreen:</p><ul class="ul"><li class="li"><p>Offscreen drawable objects. The Apple-specific OpenGL APIs provide routines that support drawing to  CPU memory and are supported only by the software renderer. These objects are available in Mac OS X v10.0 and later, but are not recommended for performance-critical applications.  See <span class="content_text"><a href="opengl_offscreen.html#//apple_ref/doc/uid/TP40001987-CH403-SW5">“Setting Up an Offscreen Drawable Object.”</a></span></p></li><li class="li"><p>Hidden Cocoa views or Carbon windows. Starting in Mac OS X v10.2, the <code>NSOpenGLContext</code> class and AGL API provide routines that use the GPU to draw to hidden windows or views and then draw that content to an onscreen rendering context. See <span class="content_text"><a href="opengl_offscreen.html#//apple_ref/doc/uid/TP40001987-CH403-SW6">“Using a Hidden View  or Window.”</a></span></p></li><li class="li"><p>Pixel buffer drawable objects. Each of the Apple-specific OpenGL APIs provides routines for drawing to offscreen memory that's located on the GPU. An application can render an image into a pixel buffer once and then use the buffer contents multiple times to texture a variety of surfaces without copying the image data. Pixel buffers are available starting in Mac OS X v10.3. See <span class="content_text"><a href="opengl_offscreen.html#//apple_ref/doc/uid/TP40001987-CH403-SW3">“Rendering to a Pixel Buffer.”</a></span></p></li><li class="li"><p>Framebuffer objects. A recently added OpenGL extension, these objects allow you to draw to buffers other than the usual buffers provided by OpenGL or the Mac OS X windowing system. Because these objects are window-system agnostic, they are easier to set up and more efficient to use than pixel buffers. Framebuffer objects are available in Mac OS X v10.4.3 and later, but not all hardware supports their use. See <span class="content_text"><a href="opengl_offscreen.html#//apple_ref/doc/uid/TP40001987-CH403-SW7">“Rendering to a Framebuffer Object.”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH403-SW5" title="Setting Up an Offscreen Drawable Object"></a><h2>Setting Up an Offscreen Drawable Object</h2><p>Offscreen drawable objects reside in CPU memory and are supported only by the software renderer.  If you must support versions of Mac OS X prior to 10.2, you may need to use offscreen drawable objects. Otherwise, you should consider one of the other options for drawing offscreen.</p><p>The general procedure for setting up an offscreen drawable object is similar to setting up other drawable objects: </p><ol class="ol"><li class="li"><p>Specify renderer and buffer attributes, making sure to specify the offscreen attribute.</p></li><li class="li"><p>Obtain a pixel format object.</p></li><li class="li"><p>Create a context and make it current.</p></li><li class="li"><p>Bind the context to an offscreen drawable object.</p></li></ol><p>Each of the Apple-specific OpenGL APIs provides a routine for binding the context to an offscreen drawable object:</p><ul class="ul"><li class="li"><p>The <code>setOffScreen:width:height:rowbytes:</code> method of the <code>NSOpenGLContext</code> class instructs the receiver to render into an offscreen buffer.</p></li><li class="li"><p>The AGL function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglSetOffScreen" target="_top">aglSetOffScreen</a></code> attaches an AGL rendering context to an offscreen buffer.</p></li><li class="li"><p>The CGL function <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLSetOffScreen" target="_top">CGLSetOffScreen</a></code> attaches a CGL rendering context to an offscreen buffer. </p></li></ul><p>After creating and drawing to an offscreen context, call the OpenGL function <code><!--a-->glFinish<!--/a--></code> to ensure that all submitted OpenGL commands have finished rendering into the memory buffer  before you access the data. You can read the buffer contents by calling the OpenGL function <code>glReadPixels</code>, or you can use the buffer contents as a texture by calling the appropriate copy and surface texture functions.</p><p>The code in <span class="content_text">Listing 4-1</span> shows how to use the CGL API to create  an offscreen drawable object that has a resolution of 1024 x 768 pixels and a depth of 32 bits per pixel. A detailed explanation for each numbered line of code appears following the listing. </p><a name="//apple_ref/doc/uid/TP40001987-CH403-SW1" title="Listing 4-1Using CGL to draw to an offscreen drawable object"></a><p class="codesample"><strong>Listing 4-1&nbsp;&nbsp;</strong>Using CGL to draw to an offscreen drawable object</p><div class="codesample"><table><tr><td scope="row"><pre>CGLPixelFormatAttribute attribs[] = <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kCGLPFAOffScreen,<span></span></pre></td></tr><tr><td scope="row"><pre>    kCGLPFAColorSize, 32,<span></span></pre></td></tr><tr><td scope="row"><pre>    NULL<span></span></pre></td></tr><tr><td scope="row"><pre>} ;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLPixelFormatObj pixelFormatObj;<span></span></pre></td></tr><tr><td scope="row"><pre>long numPixelFormats;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLChoosePixelFormat (attribs, &amp;pixelFormatObj, &amp;numPixelFormats); <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGLContextObj contextObj;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLCreateContext (pixelFormatObj, NULL, &amp;contextObj); <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>CGLDestroyPixelFormat (pixelFormatObj);<span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetCurrentContext (contextObj); <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>void* memBuffer = (void *) malloc (1024 * 768 * 32 / 8); <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>CGLSetOffScreen (contextObj, 1024, 768, 1024 * 4, memBuffer); <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>//***** Perform offscreen drawing<span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetCurrentContext (NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>CGLClearDrawable (contextObj);<span></span></pre></td></tr><tr><td scope="row"><pre>CGLDestroyContext (contextObj);<span></span></pre></td></tr></table></div><p>Here's what the code does:</p><ol class="ol"><li class="li"><p>Sets up an array of pixel format attributes—an offscreen drawable object and a color buffer with a size of 32 bytes. Note that the list must be terminated by <code>NULL</code>.</p></li><li class="li"><p>Creates a pixel format object that has the specified renderer and buffer attributes.</p></li><li class="li"><p>Creates a CGL context using the newly created pixel format object.</p></li><li class="li"><p>Sets the current context to the newly created offscreen CGL context.</p></li><li class="li"><p>Allocates memory for the offscreen drawable object. </p></li><li class="li"><p>Binds the CGL context to the newly allocated offscreen memory buffer. You need to specify the width and height of the offscreen buffer (in pixels), the number of bytes per row, and a pointer to the block of memory you want to render the context into. The number of bytes per row must be at least the width times the bytes per pixels. </p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH403-SW6" title="Using a Hidden View  or Window"></a><h2>Using a Hidden View  or Window</h2> <p>Starting in Mac OS X v10.2, you can use a hidden Carbon window or Cocoa view as a texture source. Cocoa supports this kind of offscreen drawing through the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/createTexture:fromView:internalFormat:" target="_top">createTexture:fromView:internalFormat:</a></code> method of the <code>NSOpenGLContext</code> class. Carbon provides the function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglSurfaceTexture" target="_top">aglSurfaceTexture</a></code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH403-SW11" title="Note"></a><p><strong>Note:</strong>&nbsp;Although these routines provide a flexible way to render to an offscreen texture and then use that texture as a source, you should consider using pixel buffers and framebuffers instead. If your application provides support for Mac OS X v10.2, however, you must use hidden views and windows if you want accelerated offscreen drawing, because the other hardware-accelerated options are not available for Mac OS X v10.2</p></div><p>The crucial concept behind using hidden views and windows is that there are two rendering contexts involved, as shown in <span class="content_text">Figure 4-1</span>: one that's bound to the hidden drawable object and the other that's bound to the destination window. You must make sure that the current rendering context is set to the appropriate context prior to drawing.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH403-SW8" title="Figure 4-1Using the content from a hidden window as a texture source"></a><p><strong>Figure 4-1&nbsp;&nbsp;</strong>Using the content from a hidden window as a texture source</p><img src = "../art/aglSurfaceContext_1.jpg" alt = "Using the content from a hidden window as a texture source" ></div><br/><p>Drawing the texture content is just like drawing to an offscreen window. The content is treated as a texture only when you actually use it for the destination rendering context. You generate a texture name, bind it, and set the texture environment after you set the current context to the destination context. Once the texture is set, you call the routine that makes the texture content available to the destination window (either  the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSOpenGLContext/createTexture:fromView:internalFormat:" target="_top">createTexture:fromView:internalFormat:</a></code> method of the <code>NSOpenGLContext</code> class or the AGL function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglSurfaceTexture" target="_top">aglSurfaceTexture</a></code>). Then you can draw using the texture.</p><p><span class="content_text">Figure 4-1</span> depicts the steps, explained below, that are required to use an offscreen window as a texture source:</p><ol class="ol"><li class="li"><p>Create a window to use as the texture source. The window should specify a hidden attribute.</p></li><li class="li"><p>Create a destination window to use the texture in.</p></li><li class="li"><p>Set up each window as a drawable object attached to an AGL context. That is, set up buffer and renderer attributes, get a pixel format object, create an AGL context, and attach the window to the context. For details, see <span class="content_text"><a href="../opengl_drawing/opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW8">“Drawing to a Window or View.”</a></span> The pixel format object for each context must be compatible, but the contexts do not need to be shared. </p></li><li class="li"><p>Set the current rendering context to the texture source context and draw the texture. OpenGL draws the contents to the hidden window.</p></li><li class="li"><p>Set the current rendering context to the destination window.</p></li><li class="li"><p>Enable texturing by calling the function <code>glEnable</code>.</p></li><li class="li"><p>Generate a texture name and bind the name to a texture target, using code similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>glGenTextures (1, &amp;mySurfaceTexName);<span></span></pre></td></tr><tr><td scope="row"><pre>glBindTexture (GL_TEXTURE_2D, mySurfaceTexName);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<span></span></pre></td></tr></table></div><p>This code sets up a power-of-two texture. You can just as easily use a rectangular texture by providing the <code>GL_TEXTURE_RECTANGLE_ARB</code> option.</p></li><li class="li"><p>Map the contents of the texture source window to the texture target bound in the destination window, using code similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>aglSurfaceTexture (myDestinationContext,GL_TEXTURE_2D,<span></span></pre></td></tr><tr><td scope="row"><pre>            GL_RGBA8, mySurfaceTextureContext);<span></span></pre></td></tr></table></div></li><li class="li"><p>Draw to the destination window, using the texture just as you would any other texture.</p></li><li class="li"><p>When you are done using the texture, unbind it by calling <code>glBindTexture</code> with the texture set to <code>0</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>glBindTexture (GL_TEXTURE_2D, 0);<span></span></pre></td></tr></table></div></li><li class="li"><p>Flush the content to the destination window by calling the function <code>aglSwapBuffers</code>.</p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH403-SW3" title="Rendering to a Pixel Buffer"></a><h2>Rendering to a Pixel Buffer</h2><p>The OpenGL extension string <code>GL_APPLE_pixel_buffer</code> provides hardware-accelerated offscreen rendering to a pixel buffer. A pixel buffer is typically used as a texture source. It can also be used for remote rendering. </p><p>When you are using a pixel buffer as a texture source, keep in mind that you must manage two rendering contexts. One is the rendering context attached to the pixel buffer. That's the context that you must draw to when you create the texture content. The other is the rendering context attached to the onscreen drawable object that will use the texture. </p><p>The first step in using a pixel buffer is to create it. The Apple-specific OpenGL APIs each provide a routine for this purpose: </p><ul class="ul"><li class="li"><p>The <code>NSOpenGLPixelBuffer</code> method <code><!--a  -->initWithTextureTarget:textureInternalFormat:textureMaxMipMapLevel:pixelsWide:pixelsHigh:<!--/a--></code></p></li><li class="li"><p>The AGL function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglCreatePBuffer" target="_top">aglCreatePBuffer</a></code></p></li><li class="li"><p>The CGL function <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLCreatePBuffer" target="_top">CGLCreatePBuffer</a></code></p></li></ul><p>Each of these routines requires that you provide a texture target, an internal format, a maximum mipmap level, and the width and height of the texture. </p><p>The texture target must be one of these OpenGL texture constants: <code>GL_TEXTURE_2D</code> for a 2D texture, <code>GL_TEXTURE_RECTANGLE_ARB</code> for a rectangular (not power-of-two) texture, or <code>GL_TEXTURE_CUBE_MAP</code> for a cube map texture. </p><p>The internal format specifies how to interpret the data for texturing operations. You can supply any of these options: <code>GL_RGB</code> (each pixel is a three-component group), <code>GL_RGBA</code> (each pixel is a four-component group), or <code>GL_DEPTH_COMPONENT</code> (each pixel is a single depth component).</p><p>The maximum mipmap level should be <code>0</code> for a pixel buffer that does not have a mipmap. The value that you supply should not exceed the actual maximum number of mipmap levels that can be represented with the given width and height.</p><p>Note that none of the routines that create a pixel buffer allocate the storage needed. The storage is allocated by the system at the time that you attach the pixel buffer to a rendering context. </p><a name="//apple_ref/doc/uid/TP40001987-CH403-SW12" title="Setting Up a Pixel Buffer for Offscreen Drawing"></a><h3>Setting Up a Pixel Buffer for Offscreen Drawing</h3><p>After you create a pixel buffer, the general procedure for using a pixel buffer for drawing is similar to the way you set up windows and views for drawing: </p><ol class="ol"><li class="li"><p>Specify renderer and buffer attributes.</p></li><li class="li"><p>Obtain a pixel format object.</p></li><li class="li"><p>Create a rendering context and make it current.</p></li><li class="li"><p>Attach a pixel buffer to the context using the appropriate Apple OpenGL attachment function:</p><ul class="ul"><li class="li"><p>The <code><!--a  -->setPixelBuffer:cubeMapFace:mipMapLevel:currentVirtualScreen:<!--/a--></code> method of the <code>NSOpenGLContext</code> class instructs the receiver to render into a pixel buffer.</p></li><li class="li"><p>The AGL function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglSetPBuffer" target="_top">aglSetPBuffer</a></code> attaches an AGL rendering context to a pixel buffer.</p></li><li class="li"><p>The CGL function <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLSetPBuffer" target="_top">CGLSetPBuffer</a></code> attaches a CGL rendering context to a pixel buffer. </p></li></ul></li><li class="li"><p>Draw, as you normally would, using OpenGL.</p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH403-SW13" title="Using a Pixel Buffer as a Texture Source"></a><h3>Using a Pixel Buffer as a Texture Source</h3><p>Pixel buffers let you perform direct texturing without incurring the cost of extra copies. After drawing to a pixel buffer, you can create a texture by following these steps:</p><ol class="ol"><li class="li"><p>Generate a texture name by calling the OpenGL function <code><!--a-->glGenTextures<!--/a--></code>.</p></li><li class="li"><p>Bind the named texture to a target by calling the OpenGL function <code>glBindTexture</code>.</p></li><li class="li"><p>Set the texture parameters by calling OpenGL function <code><!--a-->glTexEnvParameter<!--/a--></code>.</p></li><li class="li"><p>Set up the pixel buffer as the source for the texture by calling one of the following Apple OpenGL functions:</p><ul class="ul"><li class="li"><p>The <code><!--a  -->setTextureImageToPixelBuffer:colorBuffer:<!--/a--></code> method of the <code>NSOpenGLContext</code> class attaches the image data in the pixel buffer to the texture object currently bound by the receiver.</p></li><li class="li"><p>The AGL function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglTexImagePBuffer" target="_top">aglTexImagePBuffer</a></code> binds the contents of an AGL pixel buffer as the data source for a texture object.</p></li><li class="li"><p>The CGL function <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLTexImagePBuffer" target="_top">CGLTexImagePBuffer</a></code> binds the contents of a CGL pixel buffer as the data source for a texture object.</p></li></ul><p>The context that you attach to the pixel buffer is the target rendering context: the context that uses the pixel buffer as the source of the texture data. Each of these routines requires a <code>source</code> parameter, which is an OpenGL constant that specifies the source buffer to texture from. The source parameter must be a valid OpenGL buffer, such as <code>GL_FRONT</code>, <code>GL_BACK</code>, or <code>GL_AUX0</code>, and should be compatible with the buffer attributes used to create the OpenGL context associated with the pixel buffer. This means that the pixel buffer must possess the buffer in question for texturing to succeed. For example, if the buffer attribute  used with the pixel buffer is only single buffered, then  texturing from the <code>GL_BACK</code> buffer will fail.</p><p>If you modify content of any pixel buffer that contains mipmap levels, you must call the  appropriate Apple OpenGL function again (<code><!--a  -->setTextureImageToPixelBuffer:colorBuffer:<!--/a--></code>, <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglTexImagePBuffer" target="_top">aglTexImagePBuffer</a></code>, or <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLTexImagePBuffer" target="_top">CGLTexImagePBuffer</a></code>) before drawing with the pixel buffer  to ensure that the content is synchronized with OpenGL. To synchronize the content of pixel buffers without mipmaps, simply rebind to the texture object using <code>glBind</code>.</p></li><li class="li"><p>Draw primitives using the appropriate texture coordinates. (See "The Redbook"—<em>OpenGL Programming Guide</em>—for details.)</p></li><li class="li"><p>Call <code>glFlush</code> to cause all drawing commands to be executed.</p></li><li class="li"><p>When you no longer need the texture object, call the OpenGL function <code><!--a-->glDeleteTextures<!--/a--></code>.</p></li><li class="li"><p>Set the current context to <code>NULL</code> using one of the Apple OpenGL routines:</p><ul class="ul"><li class="li"><p>The <code><!--a  -->makeCurrentContext<!--/a--></code> method of the <code>NSOpenGLContext</code> class</p></li><li class="li"><p>The AGL function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/aglSetCurrentContext" target="_top">aglSetCurrentContext</a></code></p></li><li class="li"><p>The CGL function <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLSetCurrentContext" target="_top">CGLSetCurrentContext</a></code></p></li></ul></li><li class="li"><p>Destroy the pixel buffer by calling <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLDestroyPBuffer" target="_top">CGLDestroyPBuffer</a></code>.</p></li><li class="li"><p>Destroy the context by calling <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLDestroyContext" target="_top">CGLDestroyContext</a></code>.</p></li><li class="li"><p>Destroy the pixel format by calling <code><a href="../../../Reference/CGL_OpenGL/Reference/reference.html#//apple_ref/doc/c_ref/CGLDestroyPixelFormat" target="_top">CGLDestroyPixelFormat</a></code>.</p></li></ol><p>You might find these guidelines useful when using pixel buffers for texturing:</p><ul class="spaceabove"><li class="li"><p>You cannot make OpenGL texturing calls that modify pixel buffer content  (such as <code>glTexSubImage2D</code> or <code>glCopyTexImage2D</code>) with the pixel buffer as the destination. You can use texturing commands to read data from a pixel buffer, such as <code>glCopyTexImage2D</code>, with the pixel buffer texture as the source. You can also use OpenGL functions such as <code>glReadPixels</code> to read the contents of a pixel buffer directly from the pixel buffer context.</p></li><li class="li"><p>Texturing can fail  to produce the intended results without reporting an error. You must make sure that you enable the proper texture target, set  a compatible filter mode, and adhere to other requirements described in the OpenGL specification.</p></li><li class="li"><p>You are not required to set up context sharing when you texture from a pixel buffer. You can have different pixel format objects and rendering contexts for both the pixel buffer and the target drawable object, without sharing resources, and still texture using a pixel buffer in the target context.</p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH403-SW14" title="Rendering to a Pixel Buffer on a Remote System"></a><h3>Rendering to a Pixel Buffer on a Remote System</h3><p>Follow these steps to render to a pixel buffer on a remote system. The remote system does not need to have a display attached to it.</p><ol class="ol"><li class="li"><p>When you set the renderer and buffer attributes, include the remote pixel buffer attribute <code>kCGLPFARemotePBuffer</code>.</p></li><li class="li"><p>Log in to the remote machine using the <code>ssh</code> command to ensure security.</p></li><li class="li"><p>Run the application on the target system.</p></li><li class="li"><p>Retrieve the content.</p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH403-SW7" title="Rendering to a Framebuffer Object"></a><h2>Rendering to a Framebuffer Object</h2><p>The OpenGL framebuffer extension provides a mechanism for applications to render offscreen  to a destination other than the usual OpenGL buffers or destinations provided by the windowing system. This destination is called a framebuffer object.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH403-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;Extensions are available on a per-renderer basis. Before you use the framebuffer extension  you must check each renderer to make sure that it supports the extension.</p></div><p>A <strong>framebuffer object</strong> (FBO) contains state information for the OpenGL framebuffer and its set of images. A framebuffer object is similar to a drawable object, except that a drawable object is a window-system-specific object, whereas a framebuffer object is a window-agnostic object that's defined in the OpenGL standard, not by Apple. After drawing to a framebuffer object it is straightforward to display the content onscreen. A single command redirects all subsequent drawing back to the drawable object provided by the window system, where the FBO content can then be used as a texture. </p><p>Framebuffer objects offer a number of benefits over using pixel buffers.</p><ul class="ul"><li class="li"><p>They are window-system independent, which makes porting code easier.</p></li><li class="li"><p>They are easy to set up and save memory. There is no need to set up attributes and obtain a pixel format object.</p></li><li class="li"><p>They use a single OpenGL context, whereas each pixel buffer must be bound to a context.</p></li><li class="li"><p>You can switch between them faster since there is no context switch as with pixel buffers. What this means is that an application doesn't need to ensure that all rendering commands to the offscreen context are complete before using the results in the window context. Since there is only one context, commands are guaranteed to be serialized.</p></li><li class="li"><p>They can share depth buffers; pixel buffers cannot.</p></li><li class="li"><p>You can use them for 2D pixel images and for texture images. </p></li></ul><p>Completeness is a key concept to understanding framebuffer objects. <strong>Completeness</strong> is a state that indicates whether a framebuffer object meets all the requirements for drawing. You test for this state after performing all the necessary setup work. If a framebuffer object is not complete, it cannot be used effectively as the destination for rendering operations and the source for read operations. </p><p>Completeness is dependent on many factors that are not possible to condense into one or two statements, but these factors are thoroughly defined in the <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_object.txt" target="_blank">OpenGL specification for the framebuffer object extension</a></span>. The specification describes the requirements for internal formats of images attached to the framebuffer, how to determine if a format is color-, depth-, and stencil-renderable, as well as a number of other requirements. </p><p>Prior to using framebuffer objects, you should take a look at the OpenGL specification, which not only defines the framebuffer object API, but provides detailed definitions of all the terms necessary to understand their use and shows several code examples. </p><p>The remainder of this section provides an overview of how to use a framebuffer in the simplest case. You'll get an idea of how the setup of a framebuffer object compares to the other methods described in this chapter. To learn how powerful framebuffer objects are and to see examples of how to use them for a variety of purposes (such as for mipmaps) you'll want to read the OpenGL specification.</p><p>Similar to pixel buffers, framebuffer objects are suited for two types of drawing: textures and images. The functions used to set up textures and images are slightly different. The API for images uses the renderbuffer terminology defined in the OpenGL specification. A  <strong>renderbuffer image</strong> is simply a 2D pixel image. The API for textures uses texture terminology, as you might expect. For example, one of the calls for setting up a framebuffer object for a texture is <code>glFramebufferTexture2DEXT</code>, whereas the call for setting up a framebuffer object for an image is <code>glFramebufferRenderbufferEXT</code>. You'll see how to set up a simple framebuffer object for each type of drawing, starting first with textures.</p><a name="//apple_ref/doc/uid/TP40001987-CH403-SW10" title="Drawing a Texture Offscreen"></a><h3>Drawing a Texture Offscreen</h3><p>These are the basic steps needed to set up a framebuffer object for drawing a texture offscreen:</p><ol class="ol"><li class="li"><p>Make sure the framebuffer extension (<code>GL_EXT_framebuffer_object</code>) is supported on the system that your code runs on. See <span class="content_text"><a href="../opengl_general/opengl_gen_tasks.html#//apple_ref/doc/uid/TP40001987-CH211-SW7">“Determining the OpenGL Capabilities Supported by the Hardware.”</a></span></p></li><li class="li"><p>Check the renderer limits. For example, you might want to call the OpenGL function <code><!--a-->glGetIntegerv<!--/a--></code> to check the maximum texture size (<code>GL_MAX_TEXTURE_SIZE</code>) or find out the maximum number of color buffers (<code>GL_MAX_COLOR_ATTACHMENTS_EXT</code>).</p></li><li class="li"><p>Generate a framebuffer object name by calling the following function:</p><div class="codesample"><table><tr><td scope="row"><pre>void glGenFramebuffersEXT (GLsizei n, GLuint *ids);<span></span></pre></td></tr></table></div><p><code>n</code> is the number of framebuffer object names that you want to create.</p><p>On return, <code>*ids</code>  points to the generated names.</p></li><li class="li"><p>Bind the  framebuffer object name to a framebuffer target by calling the following function:</p><div class="codesample"><table><tr><td scope="row"><pre>void glBindFramebufferEXT(GLenum target, GLuint framebuffer);<span></span></pre></td></tr></table></div><p><code>target</code> should be the constant <code>GL_FRAMEBUFFER_EXT</code>.</p><p><code>framebuffer</code> is set to an unused framebuffer object name.</p><p>On return, the framebuffer object is initialized to the state values described in the <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_object.txt" target="_blank">OpenGL specification for the framebuffer object extension</a></span>. Each attachment point of the framebuffer is initialized to the attachment point state values described in the specification.  The number of attachment points is equal to <code>GL_MAX_COLOR_ATTACHMENTS_EXT</code> plus 2 (for depth and stencil attachment points).</p></li><li class="li"><p>Generate a texture name.</p></li><li class="li"><p>Bind the texture name  to a texture target.</p></li><li class="li"><p>Set up the texture environment and parameters.</p></li><li class="li"><p>Define the texture by calling the appropriate OpenGL function to specify the target, level of detail, internal format, dimensions, border, pixel data format, and texture data storage.</p></li><li class="li"><p>Attach the texture to the framebuffer by calling the following function: </p><div class="codesample"><table><tr><td scope="row"><pre>void glFramebufferTexture2DEXT (GLenum target, GLenum attachment,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 GLenum textarget, GLuint texture,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 GLint level);<span></span></pre></td></tr></table></div><p><code>target</code> must be <code>GL_FRAMEBUFFER_EXT</code>. </p><p><code>attachment</code> must be one of the attachment points of the framebuffer: <code>GL_STENCIL_ATTACHMENT_EXT</code>, <code>GL_DEPTH_ATTACHMENT_EXT</code>, or  <code>GL_COLOR_ATTACHMENTn_EXT</code>, where <code>n</code> is a number from <code>0</code> to <code>GL_MAX_COLOR_ATTACHMENTS_EXT-1</code>.</p><p><code>textarget</code> is the texture target.</p><p><code>texture</code> is an existing texture object.</p><p><code>level</code> is the mipmap level of the texture image to attach  to the framebuffer.</p></li><li class="li"><p>Check to make sure that the framebuffer is complete by calling the following function: </p><div class="codesample"><table><tr><td scope="row"><pre>GLenum glCheckFramebufferStatusEXT(GLenum target);<span></span></pre></td></tr></table></div><p><code>target</code> must be the constant <code>GL_FRAMEBUFFER_EXT</code>.</p><p>This function returns a status constant. You must test to make sure that the constant is <code>GL_FRAMEBUFFER_COMPLETE_EXT</code>. If it isn't, see the  <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_object.txt" target="_blank">OpenGL specification for the framebuffer object extension</a></span> for a description of the other constants in the status enumeration.</p></li><li class="li"><p>Render content to the texture. You must make sure to bind a different texture to the framebuffer object or disable texturing before you render content. That is, if you render to a framebuffer object texture attachment with that same texture currently bound and enabled, the result is undefined.</p></li><li class="li"><p>To view the contents of the texture, make the window the target of all rendering commands by calling the function <code>glBindFramebufferEXT</code> and passing the constant <code>GL_FRAMEBUFFER_EXT</code> and <code>0</code>. The window is always specified as  <code>0</code>.</p></li><li class="li"><p>Use the texture attachment as a normal texture by binding it, enabling texturing, and drawing.</p></li><li class="li"><p>Delete the texture.</p></li><li class="li"><p>Delete the framebuffer object by calling the following function:</p><div class="codesample"><table><tr><td scope="row"><pre>void  glDeleteFramebuffersEXT (GLsizei n, const GLuint *framebuffers);<span></span></pre></td></tr></table></div><p><code>n</code> is the number of framebuffer objects to delete.</p><p><code>*framebuffers</code> points to an array that contains the framebuffer object names.</p></li></ol><p><span class="content_text">Listing 4-2</span> shows code that performs these tasks. This example sets up and draws to a single framebuffer object. Your application can set up more than one framebuffer object if it requires them.</p><a name="//apple_ref/doc/uid/TP40001987-CH403-SW4" title="Listing 4-2Setting up a framebuffer for texturing"></a><p class="codesample"><strong>Listing 4-2&nbsp;&nbsp;</strong>Setting up a framebuffer for texturing</p><div class="codesample"><table><tr><td scope="row"><pre>GLuint framebuffer, texture;<span></span></pre></td></tr><tr><td scope="row"><pre>GLenum status;<span></span></pre></td></tr><tr><td scope="row"><pre>glGenFramebuffersEXT(1, &amp;framebuffer);<span></span></pre></td></tr><tr><td scope="row"><pre>// Set up the FBO with one texture attachment<span></span></pre></td></tr><tr><td scope="row"><pre>glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffer);<span></span></pre></td></tr><tr><td scope="row"><pre>glGenTextures(1, &amp;texture);<span></span></pre></td></tr><tr><td scope="row"><pre>glBindTexture(GL_TEXTURE_2D, texture);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, TEXWIDE, TEXHIGH, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                GL_RGBA, GL_UNSIGNED_BYTE, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,<span></span></pre></td></tr><tr><td scope="row"><pre>                GL_TEXTURE_2D, texture, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);<span></span></pre></td></tr><tr><td scope="row"><pre>if (status != GL_FRAMEBUFFER_COMPLETE_EXT)<span></span></pre></td></tr><tr><td scope="row"><pre>                // Handle error here<span></span></pre></td></tr><tr><td scope="row"><pre>// Your code to draw content to the FBO<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>// Make the window the target<span></span></pre></td></tr><tr><td scope="row"><pre>glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>//Your code to use the contents of the FBO<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>//Tear down the FBO and texture attachment<span></span></pre></td></tr><tr><td scope="row"><pre>glDeleteTextures(1, &amp;texture);<span></span></pre></td></tr><tr><td scope="row"><pre>glDeleteFramebuffersEXT(1, &amp;framebuffer);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH403-SW16" title="Drawing a Renderbuffer Image Offscreen"></a><h3>Drawing a Renderbuffer Image Offscreen</h3><p>There is a lot of similarity between setting up a framebuffer object for drawing images and setting one up to draw textures. These are the basic steps needed to set up a framebuffer object for drawing a 2D pixel image (a renderbuffer image) offscreen:</p><ol class="ol"><li class="li"><p>Make sure the framebuffer extension (<code>EXT_framebuffer_object</code>) is supported on the renderer that your code runs on. See <span class="content_text"><a href="../opengl_general/opengl_gen_tasks.html#//apple_ref/doc/uid/TP40001987-CH211-SW7">“Determining the OpenGL Capabilities Supported by the Hardware.”</a></span></p></li><li class="li"><p>Check the renderer limits. For example, you might want to call the OpenGL function <code><!--a-->glGetIntegerv<!--/a--></code> to  find out the maximum number of color buffers (<code>GL_MAX_COLOR_ATTACHMENTS_EXT</code>).</p></li><li class="li"><p>Generate a framebuffer object name by calling the function <code>glGenFramebuffersEXT</code>. (See Step 3 in  <span class="content_text"><a href="opengl_offscreen.html#//apple_ref/doc/uid/TP40001987-CH403-SW10">“Drawing a Texture Offscreen.”</a></span>)</p></li><li class="li"><p>Bind the  framebuffer object name to a framebuffer target by calling the function <code>glBindFramebufferEXT</code>. (See Step 4 in  <span class="content_text"><a href="opengl_offscreen.html#//apple_ref/doc/uid/TP40001987-CH403-SW10">“Drawing a Texture Offscreen.”</a></span>)</p></li><li class="li"><p>Generate a renderbuffer object name by calling the following function:</p><div class="codesample"><table><tr><td scope="row"><pre>void  glGenRenderbuffersEXT (GLsizei n, GLuint *renderbuffers );<span></span></pre></td></tr></table></div><p><code>n</code> is the number of renderbuffer object names to create.</p><p><code>*renderbuffers</code> points to storage for the generated names.</p></li><li class="li"><p>Bind the  renderbuffer object name to a renderbuffer target by calling the following function:</p><div class="codesample"><table><tr><td scope="row"><pre>void glBindRenderbufferEXT (GLenum target, GLuint renderbuffer);<span></span></pre></td></tr></table></div><p><code>target</code> must be the constant <code>GL_RENDERBUFFER_EXT</code></p><p><code>renderbuffer</code> is the renderbuffer object  name  generated previously.</p></li><li class="li"><p>Create data storage and establish the pixel format and dimensions of the renderbuffer image by calling the following function:</p><div class="codesample"><table><tr><td scope="row"><pre>void glRenderbufferStorageEXT (GLenum target, GLenum internalformat,<span></span></pre></td></tr><tr><td scope="row"><pre>                                GLsizei width, GLsizei height);<span></span></pre></td></tr></table></div><p><code>target</code> must be the constant <code>GL_RENDERBUFFER_EXT</code>.</p><p><code>internalformat</code> is the pixel format of the image. The value must be <code>RGB</code>, <code>RGBA</code>, <code>DEPTH_COMPONENT</code>, <code>STENCIL_INDEX</code>, or one of the other formats listed in the OpenGL specification.</p><p><code>width</code> is the width of the image, in pixels.</p><p><code>height</code> is the height of the image, in pixels.</p></li><li class="li"><p>Attach the renderbuffer to a framebuffer target by calling the function <code><!--a-->glFramebufferRenderbufferEXT<!--/a--></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment,<span></span></pre></td></tr><tr><td scope="row"><pre>                             GLenum renderbuffertarget, GLuint renderbuffer);<span></span></pre></td></tr></table></div><p><code>target</code> must be the constant <code>GL_FRAMEBUFFER_EXT</code>.</p><p><code>attachment</code> should be one of the attachment points of the framebuffer: <code>GL_STENCIL_ATTACHMENT_EXT</code>, <code>GL_DEPTH_ATTACHMENT_EXT</code>, or GL_<code>COLOR_ATTACHMENTn_EXT</code>, where n is a number from <code>0</code> to <code>GL_MAX_COLOR_ATTACHMENTS_EXT–1</code>.</p><p><code>renderbuffertarget</code> must be the constant <code>GL_RENDERBUFFER_EXT</code>.</p><p><code>renderbuffer</code> should be set to the name of the renderbuffer object that you want to attach  to the framebuffer.</p></li><li class="li"><p>Check to make sure that the framebuffer is complete by calling the following function:</p><div class="codesample"><table><tr><td scope="row"><pre>enum  glCheckFramebufferStatusEXT(GLenum target);<span></span></pre></td></tr></table></div><p><code>target</code> must be the constant <code>GL_FRAMEBUFFER_EXT</code>.</p><p>This function returns a status constant. You must test to make sure that the constant is <code>GL_FRAMEBUFFER_COMPLETE_EXT</code>. If it isn't, see the  <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_object.txt" target="_blank">OpenGL specification for the framebuffer object extension</a></span> for a description of the other constants in the status enumeration.</p></li><li class="li"><p>Draw the 2D pixel image to the renderbuffer.</p></li><li class="li"><p>To view the contents of the renderbuffer, make the window the target of all rendering commands by calling the function <code>glBindFramebufferEXT</code> and passing the constant <code>GL_FRAMEBUFFER_EXT</code> and <code>0</code>. The window is always specified as  <code>0</code>.</p></li><li class="li"><p>To access the contents of the renderbuffer object, use OpenGL functions such as <code>glReadPixels</code> or <code>glCopyTexImage2D</code>.</p></li><li class="li"><p>Delete the framebuffer object with its renderbuffer attachment.</p></li></ol><p><span class="content_text">Listing 4-3</span> shows code that  sets up and draws to a single renderbuffer object. Your application can set up more than one renderbuffer object if it requires them.</p><a name="//apple_ref/doc/uid/TP40001987-CH403-SW9" title="Listing 4-3Setting up a renderbuffer for drawing images"></a><p class="codesample"><strong>Listing 4-3&nbsp;&nbsp;</strong>Setting up a renderbuffer for drawing images</p><div class="codesample"><table><tr><td scope="row"><pre>GLuint framebuffer, renderbuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>GLenum status;<span></span></pre></td></tr><tr><td scope="row"><pre>// Set the width and height appropriately for you image<span></span></pre></td></tr><tr><td scope="row"><pre>GLuint texWidth = 1024,<span></span></pre></td></tr><tr><td scope="row"><pre>       texHeight = 1024;<span></span></pre></td></tr><tr><td scope="row"><pre>//Set up a FBO with one renderbuffer attachment<span></span></pre></td></tr><tr><td scope="row"><pre>glGenFramebuffersEXT(1, &amp;framebuffer);<span></span></pre></td></tr><tr><td scope="row"><pre>glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffer);<span></span></pre></td></tr><tr><td scope="row"><pre>glGenRenderbuffersEXT(1, &amp;renderbuffer);<span></span></pre></td></tr><tr><td scope="row"><pre>glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, renderbuffer);<span></span></pre></td></tr><tr><td scope="row"><pre>glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_RGBA8, texWidth, texHeight);<span></span></pre></td></tr><tr><td scope="row"><pre>glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,<span></span></pre></td></tr><tr><td scope="row"><pre>                 GL_RENDERBUFFER_EXT, renderbuffer);<span></span></pre></td></tr><tr><td scope="row"><pre>status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);<span></span></pre></td></tr><tr><td scope="row"><pre>if (status != GL_FRAMEBUFFER_COMPLETE_EXT)<span></span></pre></td></tr><tr><td scope="row"><pre>                // Handle errors<span></span></pre></td></tr><tr><td scope="row"><pre>//Your code to draw content to the renderbuffer<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>// Make the window the target<span></span></pre></td></tr><tr><td scope="row"><pre>glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>//Your code to use the contents<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>// Delete the renderbuffer attachment<span></span></pre></td></tr><tr><td scope="row"><pre>glDeleteRenderbuffersEXT(1, &amp;renderbuffer);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH403-SW17" title="See Also"></a><h2>See Also</h2><p>This chapter provided an overview of the various ways to perform offscreen OpenGL drawing. It's only a starting point, especially for those who want to use textures and who are concerned with performance. You'll also want to read the following:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../opengl_texturedata/opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW1">“Techniques for Working with Texture Data”</a></span></p></li><li class="li"><p><span class="content_text"><a href="../opengl_performance/opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW1">“Improving Performance”</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_object.txt" target="_blank">OpenGL specification for the framebuffer object extension</a></span> describes the framebuffer API in detail and provides sample code for setting up and using framebuffer objects and renderbuffers.</p></li></ul><p>OpenGL sample code projects (<span class="content_text"><a href="../../../../../referencelibrary/" target="_top">ADC Reference Library</a></span>):</p><ul class="ul"><li class="li"><p><em><a href="../../../../../samplecode/AGLSurfaceTexture/index.html#//apple_ref/doc/uid/DTS10000508" target="_top">AGLSurfaceTexture</a></em> shows how to render to a texture.</p></li><li class="li"><p><em><a href="../../../../../samplecode/GLCarbon1ContextPbuffer/index.html#//apple_ref/doc/uid/DTS10003144" target="_top">GLCarbon1ContextPbuffer</a></em> renders surfaces into a pixel buffer and uses it as a texture to draw on a cube; uses a single context.</p></li><li class="li"><p><em><a href="../../../../../samplecode/GLCarbonSharedPbuffer/index.html#//apple_ref/doc/uid/DTS10003149" target="_top">GLCarbonSharedPbuffer</a></em> shares a single pixel buffer with multiple other contexts.</p></li><li class="li"><p><em><a href="../../../../../samplecode/QuartzComposerOffline/index.html#//apple_ref/doc/uid/DTS10003648" target="_top">Quartz Composer Offline Rendering</a></em> shows how to render a Quartz Composer composition as a series of images using an OpenGL pixel buffer.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_fullscreen/opengl_cgl.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_general/opengl_gen_tasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_offscreen/opengl_offscreen.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_offscreen/opengl_offscreen.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_offscreen/opengl_offscreen.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>