{	File:		print.p	Contains:	Print multipage PICT:  Takes a PICT larger than one page and "tiles" it so that				it prints across the right number of sheets of paper to tape together and make				a poster, like many drawing applications.  You can find a slightly cleaner				version of this routine as part of Pascal Sample 3.0.	Written by: 		Copyright:	Copyright © 1984-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/26/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				}{	This file has been processed by The THINK Pascal Source Converter, v1.1.2.	}{	This file has been processed by The THINK Pascal Source Converter, v1.1.2.	}unit print;                                     { printing unit based on Luke's caring print loop }interfaceuses	Printing,Resources,ToolUtils;function Print (thePrRecHdl: THPrint): boolean;function PageSetup (thePrRecHdl: THPrint): boolean;implementationtype	heightAndWidth = record			height: integer;			width: integer;		end;var	theStatus: TPrStatus;	pageDims: heightAndWidth;	documentPicture: PicHandle;procedure AlertUser (rTheAlert: integer);EXTERNAL;function GetPages (theDocBounds: Rect; thePrintRecord: THPrint): heightAndWidth;	var		pageLength, docLength, height, width: integer;{ Note that we'll use these "length" variables twice -- once for the width, and once for the height. }{ They're just one-dimensional, so why use stack space to declare two copies? }	begin		with theDocBounds do			docLength := right - left;		with thePrintRecord^^.prInfo.rPage do			pageLength := right - left;		width := docLength div pageLength;		if docLength mod pageLength <> 0 then			width := width + 1;		with theDocBounds do			docLength := bottom - top;		with thePrintRecord^^.prInfo.rPage do			pageLength := bottom - top;		height := docLength div pageLength;		if docLength mod pageLength <> 0 then			height := height + 1;		GetPages.width := width;		GetPages.height := height;	end;procedure UnLoadTheWorld;  {Nothing here right now for segmentation}{	UnLoadTheWorld will swap out ALL unneeded code segments and data that are NOT required during print time.}{Your print code must be a separate code segment.  }	begin	end;function DetermineRealNumberOfPagesInDoc (documentSize: Rect; printRecord: THPrint): integer;	begin		pageDims := GetPages(documentSize, printRecord);		DetermineRealNumberOfPagesInDoc := pageDims.height * pageDims.width;		;	end;procedure DrawStuff (thePage: rect; thePort: GrafPtr; pageNumber: integer; thePicture: PicHandle);	var		offsetPage: Rect;	begin{ We draw pages horizontally first, then vertically, so if there are four pages, page 2 is to the right of page 1. }{ First, get the offset rectangle for the page we're drawing }		offsetPage := thePicture^^.picFrame;		OffsetRect(offsetPage, -((pageNumber - 1) mod pageDims.width) * (thePage.right - thePage.left), -((pageNumber - 1) div pageDims.width) * (thePage.bottom - thePage.top));		DrawPicture(thePicture, offsetPage);	end;procedure MyPIdleProcedure;	var		pIdleEventRecord: EventRecord;	begin		if GetNextEvent(keyDownMask, pIdleEventRecord) then			begin				if ((BitAnd(pIdleEventRecord.message, charCodeMask) = longint('.')) and (BitAnd(longint(pIdleEventRecord.modifiers), cmdKey) = cmdKey)) then					PrSetError(iPrAbort);			end;	end;function PageSetup (thePrRecHdl: THPrint): boolean;	var		PrintError: LongInt;		oldPort: GrafPtr;		printmgrsResFile: integer;	begin		GetPort(oldPort);		printmgrsResFile := CurResFile;		if thePrRecHdl <> nil then			begin				PrOpen;				if (PrError = noErr) then					begin						if (PrError = noErr) then							begin								if (PrStlDialog(thePrRecHdl)) then				{ Do any post-processing on the style dialog results you need to here }								else									PrSetError(iPrAbort);   {**  Cancel from the style dialog  **}							end;					end;				PrintError := PrError;				PrClose;											{**}{											You do not want to report any printing errors}{											until you}{											have fallen through the printing loop . This will make sure that ALL of the Print Manager 's open calls have their corresponding close calls, thereby}{											enabling the Print Manager to close properly and that all temporary memory allocations are released . * *}				if (PrintError <> noErr) and (PrintError <> iPrAbort) then { PostPrintingErrors(PrintError); Need to add this }			end;		UseResFile(printmgrsResFile);		SetPort(oldPort);		return true;	end; {PageSetup}function Print (thePrRecHdl: THPrint): boolean;	var		copies, firstPage, lastPage, numberOfCopies, pageNumber, printmgrsResFile, realNumberOfPagesInDoc: Integer;		PrintError: LongInt;		oldPort: GrafPtr;		thePrPort: TPPrPort;{theStatus: TPrStatus;}		PrintingStatusDialog: DialogPtr;		documentBounds: Rect;	begin		GetPort(oldPort);		PrintingStatusDialog := nil;	{**}		UnLoadTheWorld;		if (MemError = noErr) and (thePrRecHdl <> nil) then			begin				PrOpen;				if (PrError = noErr) then					begin{					Save the current resource file ( i . e . the printer driver's) so the driver will not lose its resources}{					upon return from the pIdleProc.  }						printmgrsResFile := CurResFile;						if (PrError = noErr) then							begin									{**}{									DetermineNumberOfPagesinDoc determines the number of pages contained in the document by comparing the size of the document}{									with rPage from the TPrInfo}{									record}{											( IM II - 150 ) . It returns the number of pages required to print the document}{											for the currently selected printer . * *}								documentPicture := GetPicture(256);								documentBounds := documentPicture^^.picFrame;								realNumberOfPagesinDoc := DetermineRealNumberOfPagesinDoc(documentBounds, thePrRecHdl);								;								if PrJobDialog(thePrRecHdl) then									begin{                                                  Get the number of copies of the document that the user wants printed from iCopies of the TPrJob }{													record}{															( IM II - 151 ) . * *}										numberOfCopies := thePrRecHdl^^.prJob.iCopies;{															Get the first and last pages of the document that were requested to be printed by the user from iFstPage and iLastPage from the TPrJob}{															record}{																	( IM II - 151 ) . * *}										firstPage := thePrRecHdl^^.prJob.iFstPage;										lastPage := thePrRecHdl^^.prJob.iLstPage;{																	Print "}{																	all "}{																	pages in the print loop * *}										thePrRecHdl^^.prJob.iFstPage := 1;										thePrRecHdl^^.prJob.iLstPage := 9999;{																	Determine the "}{																	real "}{																	number of pages contained in the document . Without this test , you would print 9999 pages . * *}										if (realNumberOfPagesinDoc < lastPage) then											lastPage := realNumberOfPagesinDoc;										PrintingStatusDialog := GetNewDialog(257, nil, POINTER(-1));																	{**}{																	Print the number of copies of the document requested by the user from the Print Job Dialog . * *}										for copies := 1 to numberOfCopies do											begin																			{**}{																			Install a pointer to your pIdle proc in my print}{																			record}{																					. * *}												thePrRecHdl^^.prJob.pIdleProc := @MyPIdleProcedure;																					{**}{																					Restore the resource}{																					file to the printer driver 's.}{																					* *}												UseResFile(printmgrsResFile);												thePrPort := PrOpenDoc(thePrRecHdl, nil, nil);												SetPort(GrafPtr(thePrPort));												if (PrError = noErr) then													begin																							{**}{																							Print the range of pages of the document requested by the user from the Print Job Dialog . * *}														pageNumber := firstPage;														while ((pageNumber <= lastPage) and (PrError = noErr)) do															begin																PrOpenPage(thePrPort, nil);																if (PrError = noErr) then																	begin																											{**}{																											rPage ( IM II - 150 ) is the printable area}{																											for the currently selected printer . By passing the current enables your app to use the same routine to draw to the screen and the printer 's GrafPort.}{																											* *}																		DrawStuff(thePrRecHdl^^.prInfo.rPage, GrafPtr(thePrPort), pageNumber, documentPicture);																	end;																PrClosePage(thePrPort);																pageNumber := pageNumber + 1;															end;  {**  End pagenumber loop  **}													end;												PrCloseDoc(thePrPort);											end; {**  End copies loop  **}																			{**}{																			The printing job is being canceled by the request of the user from the Print Style Dialog or the Print Job Dialog . PrError will be}{																			set to iPrAbort to tell the Print Manager to abort the current printing job . * *}									end								else									PrSetError(iPrAbort);   {**  Cancel from the job dialog  **}							end;					end;				if (thePrRecHdl^^.prJob.bJDocLoop = bSpoolLoop) and (PrError = noErr) then					PrPicFile(thePrRecHdl, nil, nil, nil, @theStatus);											{**}{											Grab the printing error before you close the Print Manager and the error disappears . * *}				PrintError := PrError;				PrClose;											{**}{											You do not want to report any printing errors}{											until you}{											have fallen through the printing loop . This will make sure that ALL of the Print Manager 's open calls have their corresponding close calls, thereby}{											enabling the Print Manager to close properly and that all temporary memory allocations are released . * *}				if (PrintError <> noErr) then { PostPrintingErrors(PrintError); Need to add this }			end;		if (PrintingStatusDialog <> nil) then			DisposeDialog(PrintingStatusDialog);		SetPort(oldPort);		return true;	end;  {**  print stuff  **}end.