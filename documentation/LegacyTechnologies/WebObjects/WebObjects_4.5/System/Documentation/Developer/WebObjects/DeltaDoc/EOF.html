<HTML>		<HEAD>		<TITLE>What's New in EnterpriseObjects Framework					</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b> What's New in WebObjects</font><br><br><!--end of path --><hr><a href="NewInWebObjects.html"><img src="../../../../../images/up.gif" border="0" width="36" height="16"></A></A></a><a name = "CBGHIHIB"></a><h1>What's New in EnterpriseObjects Framework</h1><p>This chapter describes changes made to the Enterprise ObjectsFramework (EOF) between release 3.0 and 4.5. It describes changesmade to existing features and describes new features you may wantto start using in your applications.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Tosynchronize the version numbers of WebObjects and EOF, the versionnumber of EOF was increased from 3.0 in the last release to 4.5in this release.</td></tr></table><br><br><a name = "CBGBIECE"></a><h2>Schema Synchronization</h2><p>In EOF 4.5, EOModeler supports synchronization of a databaseschema with the current state of a model.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>TheInformix and ODBC adaptors do not provide schema synchronization support.</td></tr></table><br><p>To initiate the process of synchronizing a model and schema,select "Synchronize Schema" from the Model menu. Note that beforesynchronizing, you need to save your model. Because the operationcannot be undone, the "Synchronize Schema" menu item is only enabledwhen the model has no unsaved changes.</p><p>After starting the synchroniztion process, EOModeler reverseengineers the database's schema and assembles the adaptor operationsnecessary to synchronize it with the model. These operations arepresented to the user for confirmation before execution.</p><p>For example, if you add simple attributes (attributes representingdatabase columns) to an entity, schema synchronization adds thecolumns to the underlying table. Similarly new columns or tablescreated in the database can be selected for incorporation into themodel. External type changes for attributes and the renaming ofcolumns and tables are also supported.</p><br><a name = "CBGCJHFH"></a><h3>Related API Changes</h3><p>EOModeler makes use of the schema synchronization API to synchronizeyour database with your model. You don't need to use the API yourselfunless you're implementing the API for a custom adaptor.</p><p>If you do need to use or implement this API (very unlikely),see the related documentation in the following class and interface/protocolspecifications:</p><ul><li>EOAdaptor</li><li>EOAdaptorChannel</li><li>EOAdaptorChannel Delegate</li><li>EOSQLExpression</li></ul><br><a name = "CBGCFGEE"></a><h2>Event Logging</h2><p>WebObjects 4.5 introduces event logging. The goal for thisfeature is to allow the measurement of how long certain operationsin EOF and WebObjects take. Measurements allow you to profile anapplication and optimize its execution time. For this, the EOF and WebObjectsframeworks instrument key portions of their code to measure theelapsed time of functions and methods.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Theevent logging feature, related classes, and related API are notavailable in the com.apple.client packages. Therefore, you can'ttime the client side of a Java Client application.</td></tr></table><br><p>To support this feature, EOF adds two new classes: EOEventand EOEventCenter. An EOEvent keeps information (such as duration)about a logged event, and EOEventCenter manages the events. EOEventis an abstract class whose subclasses are responsible for definingthe events they track. For example, there are (private) subclassesfor Sybase adaptor events, editing context events, WOApplicationevents, and so on.</p><p>To enable event logging in an application, simply open theWOEventSetup page as described in  <a href="#CBGCAACH">"WOEventSetup page" </a> and enablelogging for the event classes you want to see.</p><p>In addition to the framework support, the WOExtensions frameworkprovides components for using the feature. WOEventSetup is a pageyou use to configure event logging, and WOEventDisplay is a pagethe displays event information. Both pages can be accessed in anyWebObjects 4.5 application with a direct action, as described inthe following sections.</p><br><a name = "CBGCAACH"></a><h3>WOEventSetup page</h3><p> The page used to set up the logging properties is accessedthrough a direct action named "WOEventSetup". So for example,you can access the WOEventSetup page for an application named "MyApp"with a URL such as the following:</p><blockquote><pre>http://myhost:aPort/cgi-bin/WebObjects/MyApp.woa/wa/WOEventSetup</pre></blockquote><br><p>On the WOEventSetup page, you can see all families of eventsthat are registered for the application. Since the event classesare registered dynamically as the program executes, it is a goodidea to "warm up" an application before accessing WOEventSetup.</p><p>The page lists the registered event classes, their subcategories,and a description of the kinds of events that can be logged. Forinstance, the EOEditingContext event class logs events for the <code>saveChanges</code> and <code>objectsWithFetchSpecification:</code> methods.Logging for each class can be enabled and disabled with the correspondingcheck box; it isn't possible to disable individual subcategoriesof an event class.</p><br><a name = "TP503410707"></a><h3>WOEventDisplay page</h3><p>The page that displays collected events, WOEventDisplay, isalso accessed through a direct action. For example, you can accessthe WOEventSetup page for an application named "MyApp" witha URL such as the following:</p><blockquote><pre>http://myhost:aPort/cgi-bin/WebObjects/MyApp.woa/wa/WOEventDisplay</pre></blockquote><br><p>On this page, you can view events in four different ways:</p><ul><li><b>Raw root events</b>. This view,the most verbose, displays all events at the root level (eventswithout an encompassing event). WOEventDisplay shows each event individually,which means that its possible for an event to appear multiple timesif the thread of execution crosses its point more than once.<br><br></li><li><b>Aggregated root events</b>. This view is similarto the raw root event view, except that multiple identical eventsare <b>aggregated</b> or grouped in a single entry,and their combined time is displayed. In addition, the "Calls"column shows how many times an event was executed (in other words,how many events contributed to the displayed aggregate event).<br><br></li><li><b>Events grouped by page and component</b>. Inthis view, the first level of display shows only page names. Byexpanding a page, you get a list of components in that page. Expandinga component shows all the events within that component. This meansthat even events which were collected "deep" within a componentare shown immediately below the component name. All identical eventsare aggregated as in the aggregated root event view for easier reading.It's possible to traverse the component event hierarchy by expandingthe hyperlinks within a component.<br><br>	Note that since a page isalso a component, a page with no dynamic subcomponents seems asif it's nested one level too deep. This is the correct behavior.<br><br></li><li><b>Events grouped by page only</b>. This displayis similar to the grouped by page and component view, except theevents do not have a by-component subgrouping.</li></ul><p>In any of these displays, if an event or event group has subevents,it can be expanded by clicking the hyperlink or triangle image.</p><p>Each view orders events by duration (in milliseconds) fromthe longest to the shortest. Aggregation reduces rounding errors,which are a maximum of 1ms per event. In other words, an aggregateevent consisting of ten events has at most 1ms deviation from the actualrun time; however, manually adding ten individual events as displayedin the table might have up to a 10ms deviation. Therefore, any displayedsum is always more accurate than adding up the durations of individualevents. Also note that the sub-events of an event branch doesn'tnecessarily add up to the duration of the branch event-the branch event'sduration might be larger. This because the parent event generallyconsists of more than just calling the methods causing the sub-events.</p><br><a name = "TP503410708"></a><h3>Event System User Defaults</h3><p>The event system provides three defaults for configuring itsbehavior:</p><dl><dt>EOEventLoggingEnabled</dt><dd>A boolean value that determines whether event loggingis enabled. The default is NO, logging isn't enabled. <br>	Youcan enable logging with EOEventLoggingEnabled, but the WOEventSetup pagegives you more flexibility. The EOEventLoggingEnabled default enables loggingfor every class, whereas with WOEventSetup you can enable logging ona class by class basis.</dd></dl><dl><dt>EOEventLoggingLimit</dt><dd>An integer value that sets the maximum number of eventsthe event system logs. The default logging limit is 200,000 perthread.<br>	When the logging limit is reached, the event systemattempts to purge old events before logging new ones. If the systemis unable to purge old events, event logging is aborted.</dd></dl><dl><dt>EOEventLoggingOverflowDisplay</dt><dd>A boolean value that determines whether the event systemlogs a message when the event logging limit is reached. If enabled,the system logs messages when the event center truncates the logand also when event logging is aborted due to overflow.</dd></dl><br><a name = "TP503410709"></a><h3>Event Logging Questionsand Answers</h3><dl><dt>Question</dt><dd>What happens to an EOEvent if an exception is raisedbefore the event is completed?</dd></dl><dl><dt>Answer</dt><dd>As soon as you close another event, the system detectsthat a previous event was not closed properly and closes it foryou. All events logged between an unclosed event (due to an exceptionor improper coding) and the closing of another event are loggedat the wrong place in the event hierarchy, but they are logged.<br>	Animproperly closed event can have another negative side effect: the improperlyclosed event can't be pruned with the automatic memory manager. Thisis virtually the only thing that can completely abort event logging.<br>	Ifyou have reason to believe that you might raise while an event isin progress, you should cancel the event in an exception handler.</dd></dl><dl><dt>Question</dt><dd> What's the overhead of enabling event logging?</dd></dl><dl><dt>Answer</dt><dd>The logging mechanism is extremely fast and memory efficient.A standard 300 MHz G3 system can log more than 300,000 events persecond. Thus, the creation and logging of events is negligible comparedto the time required to generate dynamic web pages. The only expensiveoperations are tree pruning when memory overflows (which takes aboutas long as logging ten events), and handling exceptions (which islinear to the depth of the tree-rarely more than 5 levels deepunder normal circumstances). Therefore, the overhead is not reallymeasurable.</dd></dl><dl><dt>Question</dt><dd>Can I enable event logging for a single-user applicationin production?</dd></dl><dl><dt>Answer</dt><dd>You shouldn't, because it would use a lot of memory:about 4 MB per thread for the default event log limit (200,000 events).Also, throughout the lifetime of an application, the system mustcontinuously prune the event tree to keep the log size under thelimit. As stated above, pruning the tree is a relatively expensiveoperation.</dd></dl><dl><dt>Question</dt><dd>Is performance impacted by the size of the event log?Does performance degrade if logging isn't reset periodically?</dd></dl><dl><dt>Answer</dt><dd>No. As stated above, the size of the event log is limited.Once you warm up the application and the logging framework, eventlogging overhead is constant-not per event, but over an averageof a series of events.</dd></dl><br><a name = "TP503410710"></a><h3>Custom Event Logging</h3><p>To define and log custom events, you create an event class, definethe event's categories and subcategories, register the event classwith the WOEvent center, and instrument the portions of code youwant to log. This section describes these steps.</p><p>To create a custom event:</p><ol><li>Create a subclass of EOEvent or an appropriatesubclass. <br><br>	For example, to log events for a custom adaptoryou've written, say MyAdaptor, create an EOEvent subclass namedMyAdaptorEvent.<br><br>	Your subclass doesn't usually haveto override any of the inherited methods, but you can customizethe default behavior.</li><br><br><li>Create a description file for your event and add it to yourproject's Resources folder.<br><br>	An event's description filedefines the event categories and subcategories used in the WOEventDisplaypage. The file's contents is a dictionary in plist format. Forthe MyAdaptorEvent class, the file's name is <tt>MyAdaptorEvent.description</tt>,and it might look like the following:<blockquote><pre>{    EOEventGroupName = "MyAdaptor Event";    connect = "Connect";    openChannel = "Open Channel";    evaluateExpression = "Evaluate Expression";    fetchRow = "Fetch Row";    commitTransaction = "Commit Transaction";}</pre></blockquote><br>	The EOEventGroupNameentry is mandatory. It describes the family of events logged bythe event class. Any other keys are self defined by the event class.In this example, the other keys (<code>connect</code>, <code>openChannel</code>,and so on) are the names of the events MyAdaptorEvent logs.</li><br><br><li>Register the event class with the EOEventCenter.<br><br>	Typicallyyou register the event class in the <code>initialize</code> methodof the class whose code you're instrumenting-MyAdaptor in thisexample.<blockquote><pre>static Class MyAdaptorEventLoggingClass = Nil;static NSString *connectEvent = @"connect";static NSString *openChannelEvent = @"openChannel";static NSString *evaluateExpressionEvent = @"evaluateExpression";static NSString *fetchRowEvent = @"fetchRow";static NSString *commitTransactionEvent = @"commitTransaction";+ (void)initialize {    [EOEventCenter registerEventClass:[MyAdaptorEvent class]            classPointer:&MyAdaptorEventLoggingClass];}</pre></blockquote><br>	As in this example,you might want to define string constants for the keys in your event'sdescription dictionary.</li><br><br><li>Instrument the methods.<br><br>	In any method you want to instrument,add the following code, substituting the appropriate event key.This code instruments the "connect" event of MyAdaptorEvent.<blockquote><pre>MyAdaptorEvent *event=nil;// Setup and start loggingif(MyAdaptorEventLoggingClass) {    event = EONewEventOfClass(MyAdaptorEventLoggingClass, connectEvent);    EOMarkStartOfEvent(event, nil);}// Code to be timed goes here.// Finish logging.if(event) {    EOMarkEndOfEvent(event);</pre></blockquote><br>	Thesecond argument to <tt>EONewEventOfClass</tt> isan event key corresponding with an entry in the <tt>.description</tt> file.The corresponding value is used in the Title column of the WOEventDisplaypage. If the argument isn't a key in the description dictionary, <tt>EONewEventOfClass</tt> usesthe argument instead.<br>	<br>For more information on the methodsused in this example, see the class descriptions for EOEvent andEOEventCenter. To see a complete example of timing events, referto the ODBC Adaptor source code that's distributed with WebObjects.</li></ol><br><a name = "TP503410711"></a><h3>Related API Changes</h3><p>Three new classes and one interface have been added to supportevent logging. They are:</p><ul><li>EOEventCenter (<tt>EOControl/EOEventCenter.h</tt>)</li><li>EOEvent (<tt>EOControl/EOEvent.h</tt>)</li><li>EOAggregateEvent (<tt>EOControl/EOAggregateEvent.h</tt>)</li><li>EOEventCenter.EventRecordingHandler (Java) or EOEventRecordingHandler (Objective-C; <tt>EOControl/EOEventCenter.h</tt>)</li></ul><p>For more information, see the corresponding class or interfacespecifications.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Theseclasses and interfaces aren't available in the com.apple.client.eocontrol package.</td></tr></table><br><br><a name = "CBGCHAIA"></a><h2>Object Sharing</h2><p>EOF 4.5 introduces a new technique for sharingread-only enterprise objects. The new subclass of EOEditingContext,EOSharedEditingContext, defines a mechanism that allows editingcontexts to share enterprise objects for reading. This mechanismcan reduce both the number of fetches an application makes and theamount of redundant data it requires. </p><p>As an example, consider the FeeType entity in the samle Rentalsmodel that ships with EOF 4.5. A FeeType enterprise objects describesa type of fee that a video store can charge its customers-"Rental"and "Late", are the two FeeTypes in the sample database. Itis very uncommon to add or remove FeeTypes, and it's perhaps evenmore uncommon to modify an existing FeeType (to rename it, for example).For the most part, FeeTypes are read-only.</p><p>With 4.5, you can fetch read-only objects such as FeeTypesinto a shared editing context once, when an application starts,and all the application's sessions can share those objects. Forexample, objects in any session can create relationships to theshared FeeType objects even though the FeeTypes are in a differentediting context from the source objects. Using previous releases,you would have to make local copies of the read-only FeeTypes ineach of the editing contexts that use them.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Supportfor shared editing contexts is not implemented in the com.apple.client packages.Therefore, shared editing contexts are not available in the clientside of a Java Client application.</td></tr></table><br><br><a name = "TP503410712"></a><h3>How It Works</h3><p>The idea behind shared editing contexts is to load read-only(or read-mostly) objects into a central context that all sessionshave transparent access to. It works like this.</p><ol><li>A model file identifies any objects to be shared.<br><br>	Modelsidentify shared objects by defining <b>shared object fetchspecifications</b>, which define criteria for fetching objectsthat are to be shared. For information on creating shared objectfetch specifications, see  <a href="#CBGEDEHH">"Setting Up Object Sharing" </a>.<br><br>	The first time yourapplication accesses a model's entities, it checks the model for sharedobject fetch specifications. If any are found, they are evaluatedand the corresponding fetched objects are loaded into the defaultshared editing context. Any existing editing contexts that don'thave any registered objects begin using the default shared editingcontext. Similarly, any editing contexts subsequently created usethe default shared editing context.<br><br>	Note that if youdon't specify any shared fetch specifications, a shared editingcontext is never created and no object sharing occurs. Conversely,if you do specify shared object fetch specifications, a shared editingcontext is automatically created and object sharing is enabled forall standard editing contexts.<br><br></li><li>The application's shared editing context is created andpopulated the first time a model containing shared object fetchspecifications is accessed.<br><br>	Generally an application's sharedediting context is initialized when the first editing context attemptsto access the database. At this time, all the application's modelsare loaded, and any shared object fetch specifications are detected.If any of the application's models have shared object fetch specifications,a shared editing context is created and populated and is set asthe shared editing context for all empty editing contexts.<br><br>	Youcan disable object sharing on individual editing contexts as describedin  <a href="#CBGEHFBE">"Inserting, Updating, and Deleting Shared Objects" </a> or you can disable objectsharing altogether as described in  <a href="#CBGBCEHG">"Disabling Sharing During Development" </a>.<br><br></li><li>Standard editing contexts use objects in the shared editingcontext as if they were local.<br><br>	When a standard editing contextfetches, any relationships to shared objects are automatically resolvedto the shared editing context's objects. Similarly, an objectin any standard editing context can create a relationship to a sharedediting context's object.<br><br>	This all works transparently.EOEditingContext's implementations of <code>objectForGlobalID</code> and <code>faultForGlobalID</code> lookfor an object in the shared editing context when a standard editingcontext doesn't find the object locally. If the methods findsthe object in the shared editing context, they return the sharedobject as they would if the object were local.</li></ol><p>To allow object sharing to work, EOF makes the following assumptions:</p><ul><li>Shared objects are read-only (or read-mostly).</li><li>Objects must be unique in their editing contexts and theirediting context's shared editing context.</li></ul><p>The following sections describe why these assumptions arenecessary and how they are enforced.</p><br><a name = "TP503410713"></a><h4>Shared Objects AreRead-Only</h4><p>If you could update a shared object, all of an application'susers would see the changes immediately since all sessions sharethe exact same object. This behavior is undesirable. You only wantusers to see <em>committed</em> changes to objects.For example, suppose you make a change to a shared object in a webapplication, but you haven't yet saved it to the database. Thechanges are written to the object as soon as the request-responseloop begins, and every other web user sees the change you made,even if you undo them later or make further changes before saving.</p><p>For this reason EOF enforces the read-only quality of sharedobjects. Shared objects can't be inserted, updated, or deletedin a shared editing context the same way that normal enterpriseobjects can be inserted, updated, or deleted when they're in astandard editing context. EOSharedEditingContext overrides EOEditingContextmethods that mutate data (<code>takeValueForKey</code>, <code>saveChanges</code>, <code>deleteObject</code>,and <code>insertObject</code> for example) to raise exceptions.Correspondingly, methods that report on changes in a shared editingcontext return either <code>null</code>/<code>nil</code> oran empty array.</p><p>It would also be undesirable if you could delete a sharedobject. In Objective-C, it would be bad if a shared object werereleased while objects in standard editing contexts had relationshipsto it. Objects in a shared editing context are always retained.You are guaranteed that no object in a shared editing context willbe destroyed while the application is running (a shared object canbecome invalid, but it won't go away).</p><br><a name = "TP503410714"></a><h4>Shared Objects AreUniqued</h4><p>EOF uses object uniquing to ensure that a single editing contextnever has more than one object with the same global ID. Becauseevery standard editing context has access to the objects in a sharedediting context as if the objects were local, none of a shared editing context'sobjects can have the same global ID as any object in any standardediting context.</p><p>EOF does most of the work for you. A shared editing contextsends out notifications when it initializes new objects. Standardediting contexts listen for these notifications and raise exceptionsif they have local objects with the same global ID as the new sharedobject. However, you have to take some precautions not to fetchinto a shared editing context objects that have already been fetchedinto a standard editing context:</p><ul><li>Don't explicitly fetch into a standard editingcontext an object that is already shared <em>unless</em> youdisable sharing, as described in  <a href="#CBGEHFBE">"Inserting, Updating, and Deleting Shared Objects" </a>.</li><li>If a shared object has relationships to entities that aren'tshared, remove the relationships from the model. Otherwise, whenthe faults fire, the destination objects are fetched into the sharedediting context.</li></ul><br><a name = "CBGEDEHH"></a><h3>Setting Up Object Sharing</h3><p>EOModeler has a new entity inspector for specifying the objectsyou want to fetch into a shared editing context when an applicationstarts. To use it, select the entity whose objects you want to share,and open the Shared Objects Inspector.</p><p>To share all the entity's objects, select "Share all objects."If the entity has an unqualified fetch specification, that fetchspecification is selected. Otherwise, EOModeler creates an unqualifiedfetch specification and selects it.</p><p>To share only some objects, define fetch specifications thatselect the objects you want to share. In the Shared Objects Inspector,select "Share objects fetched with" and select your fetch specifications.</p><p>You can also prefetch relationships into the shared editingcontext. For example, suppose that Product has a relationship toProductPlatforms and that both entities should be shared. You cancreate a Product fetch specification that has a hint to prefetchthe Product's ProductPlatforms relationship. Using this fetchspecification to fetch Products into the shared editing contextalso causes ProductPlatforms to be loaded into the shared editing context.</p><br><a name = "TP503410715"></a><h3>Accessing Shared Objects</h3><p>Shared editing contexts maintain dictionaries of all the objectsthey have fetched, both by entity name and by the fetch specificationname they were retrieved with. This makes it easy to use sharedobjects for populating user interface controls. The two methodsfor accessing these dictionaries are:</p><blockquote><pre>objectsByEntityNameobjectsByEntityNameAndFetchSpecificationName</pre></blockquote><br><p>These two methods make it easy to use key-value coding andkey paths to bind data to WebObjects elements directly in a WebObjects <tt>.wod</tt> file.</p><p>For example: Say you have a model with the entity "Products"and an attribute called "isDiscontinued", which indicates whetheran item is unavailable. You could set up a fetch specification inEOModeler named "regularProducts" that fetches only objectsthat are available (the qualifier would specify that "isDiscontinued= 0"). To use the returned set of "regular products" ina WebObjects page, create a user interface control (such as a WOPopupor WOBrowser), and set its <code>list</code> attributelike this:</p><blockquote><pre>list =session.defaultSharedEditingContext.objectsByEntityNameAndFetchSpecificationName.Products.regularProducts</pre></blockquote><br><p>The user interface control's list is automatically filledwith data from shared objects.</p><br><a name = "CBGEHFBE"></a><h3>Inserting, Updating, andDeleting Shared Objects</h3><p>Generally shared objects are <em>read-mostly</em>.For example, an application could provide an administration modethat allows administrative users to insert, update, and delete otherwiseread-only shared objects. You can still use a shared editing contextin such an application, but you have to write special code. Sinceinsertions, updates, and deletions of shared objects are typicallyvery infrequent, the performance benefit of sharing objects can stillbe significant.</p><p>To insert new objects, create and insert a new object in astandard editing context. Once you do this, you need to fetch thenew object into the shared editing context as described in  <a href="#CBGDIDBE">"Refreshing the Shared Editing Context" </a>.</p><p>Updating and deleting them is a little trickier. To modifyshared objects, you need to disable object sharing for a particularediting context, as follows:</p><blockquote><pre>mySession.defaultEditingContext().setSharedEditingContext(null); // Java[[mySession defaultEditingContext] setSharedEditingContext:nil]; // ObjC</pre></blockquote><br><p>A session that does this doesn't have access to shared objectsand can explicitly fetch objects that would otherwise be shared.After fetching the objects, they are local, and you can update ordelete them. When you save the changes, the shared editing contextreceives ObjectsChangedInStoreNotifications. In response to thenotifications, the shared editing context refaults updated objectsand removes deleted objects from its <code>objectsByEntityName</code> and <code>objectsByEntityNameAndFetchSpecificationName</code> dictionaries.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Deletedobjects remain in the shared editing context so that Objective-Cobjects having relationships to them won't be left with danglingpointers.</td></tr></table><br><br><a name = "CBGDIDBE"></a><h3>Refreshing the SharedEditing Context</h3><p>You might want to refresh the shared editing context afteran administrative user inserts a new shared object or to periodicallysynchronize with a database. To refresh a shared editing context,use the method <code>bindObjectsWithFetchSpecification</code> (Java)or <code>bindObjectsWithFetchSpecification:toName:</code> (Objective-C).For example:</p><blockquote><pre>EOModelGroup modelGroup = EOModelGroup.defaultGroup();EOSharedEditingContext sharedEC =    EOSharedEditingContext.defaultSharedEditingContext();     EOFetchSpecification fs =    modelGroup.fetchSpecificationNamed("regularProducts", "Product");     if (fs == null) {    System.out.println("Couldn't get regularProducts fetch specification.");    } else {    sharedEC.bindObjectsWithFetchSpecification(fs, "regularProducts");}</pre></blockquote><br><p>This has the effect of refetching all the shared objects andbinding them to the <code>objectsByEntityName</code> and <code>objectsByEntityNameAndFetchSpecificationName</code> dictionaries.</p><br><a name = "CBGBCEHG"></a><h3>Disabling Sharing DuringDevelopment</h3><p>Initializing a shared editing context does increase the amountof time it takes for an application to start up. During developmentwhen you starting your application frequently, the additional startup time can become a nuisance. To make debugging passes quicker,you can essentially disable object sharing using the static method <code>setSharedObjectLoadingEnabled</code> (orthe equivalent class method in Objective-C).</p><p>This method specifies whether EOF looks for shared fetch specificationswhen it loads models. While a shared editing context can still becreated and referenced, it won't contain any objects unless youprogrammatically fetch them into it. The advantage of disabling sharedobject loading is that the application starts up more quickly.</p><br><a name = "TP503410716"></a><h3>Performance</h3><p>Using shared editing contexts can have the following positiveperformance impact on your application:</p><ul><li>Standard editing contexts don't have theirown copies of shared objects, so the memory footprint is smaller.</li><li>Fetching read-only data into an application is a lot simpler,so fewer database trips may be needed.</li></ul><p>However, there are potentially negative performance effectsas well. They are:</p><ul><li>Every editing context has to hash twice: onceto look up objects in their own tables, and again to look up objectsin the shared tables. Hashing is <em>very</em> fast,but with nested contexts it can add up.</li><li>On Windows NT, locking a thread is significantly slower thanit is on other platforms with similar hardware. Because shared editingcontexts generate a lot of locking activity, sharing objects canactually degrade the performance of an application on NT. If youplan to deploy on NT, test your server's performance carefully.</li><li>Fetching or firing faults in a shared editing context causesall other threads to block when they try to get shared data. Toavoid this problem, try to fetch everything when the applicationstarts up.</li></ul><br><a name = "TP503410717"></a><h3>Multithreaded Accessand Locking</h3><p>WebObjects applications take care of most multithreading issuesfor you. This is also the case with applications that use sharedediting contexts. Here are the basics of how EOF locks shared editingcontexts:</p><ul><li>Shared editing contexts use a new lock, EOMultiReaderLock,which allows multiple contexts to read data from the shared editingcontext concurrently. When the shared editing context needs to updateobjects (because of fetching or firing faults), the context waitsfor all reader locks to be surrendered and then issues a writerlock. There can only be one writer at a time.</li><li>Whenever an EOEditingContext <code>lock</code> methodis called, it also obtains a reader lock for its shared editingcontext.</li><li>When an EOEditingContext is about to call its parent objectstore, it surrenders its shared reader lock until the call is complete(this prevents deadlocks with the object store lock).</li></ul><p>From a WebObjects perspective, everything works automaticallyas long as you interact with a shared editing context from withinthe context of a session. This is because when a web session awakes,it locks its editing context, which reader-locks the shared editing context.If you need to interact with the shared editing context outsidethe context of a session, you should access it through a lockedEOEditingContext.</p><p>If you invoke methods on a shared editing context directly,you must obey a strict lock ordering protocol to avoid deadlocksand unsafe multithreaded access. If you directly invoke any methodbesides <code>objectsWithFetchSpecification</code>, <code>objectForGlobalID</code>,or <code>faultForGlobalID</code> on a shared editingcontext, you need to take the a reader or writer lock yourself beforecalling the method.</p><br><a name = "TP503410718"></a><h3>Related API Changes</h3><p>A new subclass of EOEditingContext, EOSharedEditingContext,has been added to support object sharing. For more information onthis class, see the corresponding class specification.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Withthis release of EOF, there is a subclass of EOEditingContext forthe first time. You might have to adjust your code if you ever assumethan an editing context is always an instance of EOEditingContext.</td></tr></table><br><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Supportfor shared editing contexts is not implemented in the com.apple.client packages.</td></tr></table><br><p>Additionally, new API has been added to existing classes assummarized in the following tables.</p><br><table border = "1" cellpadding = "3"><caption><strong>EODatabaseContext (EOAccess/EODatabaseContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setSharedObjectLoadingEnabled</code> (Java)<br>	<code>setSharedObjectLoadingEnabled:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that sets according to the specifiedflag whether or not to automatically load enterprise objects intothe default shared editing context when a database context loadsa model. The default is <code>true</code>/<code>YES</code> (thedatabase automatically loads shared objects).</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>isSharedObjectLoadingEnabled</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns <code>true</code>/<code>YES</code> ifdatabase contexts automatically load enterprise objects into the defaultshared editing context when database contexts load models, <code>false</code>/<code>NO</code> otherwise.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOEntity (EOAccess/EOEntity.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setSharedObjectFetchSpecificationsByName</code> (Java)<br>	<code>setSharedObjectFetchSpecificationsByName:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Sets the fetch specifications used to load objects intoa shared editing context to the fetch specifications identifiedby name in the specified array.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>sharedObjectFetchSpecificationNames</code></td><td rowspan = "1" colspan = "1" valign = "top">Returns an array of strings, which are the names of the fetchspecifications used to load objects into a shared editing context.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>addSharedObjectFetchSpecificationByName</code> (Java)<br>	<code>addSharedObjectFetchSpecificationByName:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Adds the fetch specification identified by the specified nameto the set of fetch specifications used to load objects into a sharedediting context.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>removeSharedObjectFetchSpecificationByName</code> (Java)<br>	<code>removeSharedObjectFetchSpecificationByName:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Removes the fetch specification identified by the specifiedname from the set of fetch specifications used to load objects intoa shared editing context.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOModel (EOAccess/EOModel.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>entitiesWithSharedObjects</code></td><td rowspan = "1" colspan = "1" valign = "top">Returns an array of entities that have objects to load intoa shared editing context.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOModelGroup (EOAccess/EOModelGroup.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>entitiesWithSharedObjects</code></td><td rowspan = "1" colspan = "1" valign = "top">Returns an array of entities that have objects to load intoa shared editing context.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOEditingContext (EOControl/EOEditingContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setSharedEditingContext</code> (Java)<br>	<code>setSharedEditingContext:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Sets the receiver's shared editing context. If thereceiver is listening for (<code>EO)DefaultSharedEditingContextWasInitializedNotification</code>,it removes itself as an observer. <br>	By default, the shared editingcontext is <code>null</code>/<code>nil</code> butis set when an <code>(EO)DefaultSharedEditingContextWasInitializedNotification</code> isposted.<br>	Changing the shared editing context to <code>null</code>/<code>nil</code> allows thereceiver to obtain private, editable copies of objects that wouldotherwise be shared. If both the receiver and the specified sharedediting context have registered objects, the objects of both contextsare compared to verify that the objects are unique. If the objectsare not unique, an exception is raised by the editing context.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>sharedEditingContext</code></td><td rowspan = "1" colspan = "1" valign = "top">Returns the shared editing context used by the receiver.</td></tr></table><br><br><a name = "CBGDJHCD"></a><h2>Subclassing EOGenericRecord</h2><p>EOF 4.5 adds a new option for creating custom enterprise objects:rather than creating a subclass of EOCustomObject (Java) or NSObject(Objective-C), you can now subclass EOGenericRecord.</p><p>This feature is most significant in applications that usethe Java bridge. By default, a subclass of EOGenericRecord storesits properties in a dictionary on the Objective-C side of thebridge instead of in individual instance variables on the Java side.This allows EOF to access enterprise object properties with manyfewer trips across the bridge, which reduces memory usage and improvesperformance.</p><p>More specifically, subclassing EOGenericRecord provides thefollowing advantages over subclassing EOCustomObject (Java):</p><ul><li>Java enterprise objects don't incur a performancepenalty relative to Objective-C. Previously, each call to an EOKeyValueCodingmethod (such as <code>valueForKey</code>) resulted ina bridged method invocation and possibly the creation of a new object.Because EOGenericRecord provides the storage for an enterprise object'svalues, the values don't need to cross the bridge during a fetch.This results in a dramatic performance improvement in EOKeyValueCoding-boundoperations such as fetching, snapshotting, and validation.</li><li>Java enterprise objects don't use more memory than Objective-Centerprise objects. Since an enterprise object's values were previouslystored in its instance variables, each value object had to be morphedbetween Java and ObjC when interacting with the EOF frameworks.This meant that the values couldn't be shared between an enterprise objectand its snapshots in the EOEditingContext and EODatabase. Consequently, manymore objects were resident in memory than would be the case in thenon-bridged case.</li><li>Enterprise object classes are more flexible and easier tomaintain. As you edit your model by adding or removing keys, youonly have to update your enterprise object class if you want toadd or remove custom accessors or validation methods. You don't haveto maintain instance variables since property values are storedin a dictionary. <br>	Also, you can use a specific subclass ofEOGenericRecord for multiple entities as you can when you use EOGenericRecord.In previous releases, a single enterprise object class (other thanEOGenericRecord) could correspond to only one entity. Subclassesof EOGenericRecord can now correspond to multiple entities the sameway EOGenericRecord can. This might be useful for providing commonbehavior such as validation logic. Note that a "generic" subclassof EOGenericRecord (that is, a subclass which is shared among entities) <em>must</em> beinstantiated using EOClassDescription's <code>createInstanceWithEditingContext</code> methodin the same way that EOGenericRecord must. If it isn't, the resultinginstance won't be properly initialized.</li><li>Subclasses of EOGenericRecord automatically use deferred faulting,which increases performance and decreases memory usage even further.For more information on deferred faulting, see  <a href="#CBGBFBJB">"Deferred Faulting" </a>.</li></ul><p>Given all the advantages of subclassing EOGenericRecord, youmight wonder if there's ever a reason to subclass EOCustomObject.Subclassing EOGenericRecord usually yields better performance. Evenif it doesn't yield <em>better</em> performance, youcan design it to be at least as fast and to have the same levelof functionality as a subclass of EOCustomObject by storing propertiesin instance variables. Therefore, you really don't ever need to subclassEOCustomObject.</p><br><a name = "TP503410719"></a><h3>Property Storage: Dictionaryor Instance Variables</h3><p>A subclass of EOGenericRecord can take three approaches tostoring property values:</p><ol><li>Store them in the EOGenericRecord dictionary.</li><li>Store them in instance variables.</li><li>Store them in a combination of the above.</li></ol><p>Generally the first approach is the best because it reducesthe number of trips across the Java bridge, improving performanceand reducing memory usage. Enterprise objects are accessed fromObjective-C much more frequently than from Java. A typical enterprise objectis populated from Objective-C when it's fetched from the database,snapshotted from Objective-C each time the object is changed,and accessed from Objective-C to provide values for bindings inWebObjects components.</p><p>On the other hand, access from Java is typically limited tocustom validation (implemented in the enterprise object class) andto accesses by other enterprise objects to obtain property valuesexplicitly (for example, to check the department budget before validatinga new salary).</p><p>The second approach might be appropriate if your applicationaccesses and manipulates enterprise objects from Java quite frequently,however this case is probably rare.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Whenyou create an instance variable for an EOGenericRecord subclass,ensure that the accessor methods read and write the instance variableinstead of invoking <code>valueForKey</code> and <code>takeValueForKey</code>,which is what the implementations do if the code is generated byEOModeler.</td></tr></table><br><p>The third approach is to create instance variables for someof your enterprise object's properties and leave the rest in theEOGenericRecord dictionary. This approach is the most difficultto maintain, because the implementation of accessor methods dependson the way the property is stored.</p><br><a name = "TP503410720"></a><h3>Creating a Subclass</h3><p>EOModeler has been updated with templates that take advantageof this feature, so new enterprise object classes are automaticallysubclasses of EOGenericRecord. To re-parent existing business objects,perform the following steps in your source files:</p><ol><li>Set the enterprise object class's superclassto EOGenericRecord.</li><li>Delete all EOKeyValueCoding-related instance variables (thatis, instance variables that store values for attribute and relationshipkeys).</li><li>(Optional) For maximum performance, delete the three-argumentconstructor if you don't use the arguments. If you need customlogic in your constructor but don't need the three arguments,implement a custom default constructor. If you don't need a customconstructor, don't implement one at all; the compiler insertsthe default constructor for you. If the three-argument constructoris present, EOF uses it; otherwise the default constructor is invoked.</li><li>(Optional) For maximum performance, delete all accessors thatdon't contain custom logic. If you want strong typing to simplifybusiness logic, implement accessors using <code>storedValueForKey</code>,such as:<blockquote><pre>public NSGregorianDate dateReleased() {    return (NSGregorianDate)storedValueForKey("dateReleased");}</pre></blockquote><br></li></ol><p>In lieu of (or in addition to) adding custom accessors, itmight be convenient to add and use String constants for an enterpriseobject class's keys, as shown in the following:</p><blockquote><pre>public class Movie extends EOGenericRecord {    public static final String Title = "title";    public static final String DateReleased = "dateReleased";    public static final String Studio = "studio";    public NSGregorianDate dateReleased() {        return (NSGregorianDate)storedValueForKey(DateReleased);    }}</pre></blockquote><br><br><a name = "CBGBFBJB"></a><h2>Deferred Faulting</h2><p>EOF uses faults as stand-ins for objects whose data has notyet been fetched. Although fault creation is much faster than fetching,fault instantiation still takes time. To improve performance, EOF4.5 has the ability to use <b>deferred faults</b> (whichare more efficient) for enterprise object classes that enable thefeature.</p><p>In an object whose class enables deferred faulting, the object'srelationships are initially set to deferred faults. For a particularrelationship, a single deferred fault is shared between all instancesof an enterprise object class. This sharing of deferred faults cansignificantly reduce the number of faults that need to be created,and usually reduces the overhead of fault creation during a fetch.</p><p>For example, consider a Movie class with a <code>studio</code> relationship.Assuming the worst case in which each movie has a different studio,without deferred faulting, during a fetch of twenty Movie objects,twenty faults are created for the <code>studio</code> relationship-onefault for each movie. With deferred faulting, only one fault iscreated-a deferred fault that is shared by all the movies. </p><p>Deferred faults have a special fault handler, which knowshow to replace the deferred fault with a standard fault. Once thedeferred fault is replaced with a normal fault, the normal faultingbehavior applies.</p><p>In 4.5, EOGenericRecord enables deferred faulting; you getthe behavior without making any changes to existing code. Non-EOGenericRecordenterprise object classes don't enable deferred faulting by default.To enable it on a custom class, implement the class method <code>useDeferredFaultCreation</code> toreturn <code>true</code>/<code>YES</code> (thedefault is <code>false</code>/<code>NO</code>).Additionally, invoke the method <code>willReadRelationship</code> beforeaccessing a relationship that might be a deferred fault. The <code>willReadRelationship</code> methodallows the special fault handler to instantiate a normal fault beforeit is accessed.</p><br><a name = "TP503410721"></a><h3>Deferred Faulting andInheritance</h3><p>In Java programming, there's an additional benefit of deferredfaulting: Deferred faulting allows you to have to-one relationshipsinto an inheritance hierarchy. Without deferred faulting, a to-onerelationship to a non-leaf entity is impossible without implementing workarounds(because of strong typing in the Java language). The workaroundsare not necessary if you use deferred faulting. For more informationon the inheritance limitation in Java and the workarounds, referto the <i>Enterprise Objects Framework Developer's Guide</i>.</p><br><a name = "TP503410722"></a><h3>Related API Changes</h3><p>New API added to support the deferred faulting feature issummarized in this section.</p><br><table border = "1" cellpadding = "3"><a name = "CBGGHAEG"></a><caption><strong>EODeferredFaulting interface/informalprotocol (EOControl/EOFault.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>useDeferredFaultCreation</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that defaults to <code>false</code>/<code>NO</code>. Overrideto return <code>true</code>/<code>YES</code> onyour enterprise object class to use deferred fault creation.<br>	EOGenericRecord'simplementation returns <code>true</code>/<code>YES</code>, indicatingthat it uses the more efficient deferred fault technique.<br>	Notethat in Java, this static method is not a formal part of the EODeferredFaultinginterface because the Java language doesn't support the inclusionof static methods in an interface. It is, however, an informal part ofthe interface. A static method implemented in a custom enterpriseobject class will be invoked automatically to determine whetheror not to use deferred fault creation.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>willReadRelationship</code> (Java)<br>	<code>willReadRelationship:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Invoke this before using any relationship in an enterpriseobject that uses deferred fault creation. This method sets the correspondinginstance variable of the receiver using <code>takeStoredValueForKey</code>/<code>takeStoredValue:forKey:</code>.Returns a newly instantiated fault if the object is a fault andhas a deferred fault handler. Returns the object otherwise.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOFaultHandler (EOControl/EOFaultHandler.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>createFaultForDeferredFault</code> (Java) <br>	<code>createFaultForDeferredFault:sourceObject:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Invoked by <code>willReadRelationship</code> toensure that a fault is valid. EOFaultHandler's implementationsimply returns its fault.</td></tr></table><br><br><a name = "CBGDABII"></a><h2>Snapshot Reference Counting</h2><p>Snapshot reference counting is a new feature that removessnapshots from an EODatabase when they are no longer used by anyenterprise objects in an application. This feature reduces the memoryfootprint of WebObjects applications.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Snapshotreference counting is not available in the client side of Java Client applications.The corresponding API is in the Java Client packages, but the snapshotsare not released.</td></tr></table><br><p>The reference count on a snapshot is implicitly incrementedwhen you create an enterprise object, either by fetching it in abatch or by faulting it in. An EOEditingContext decrements the referencecount automatically when it forgets or refaults an enterprise object.</p><p>To support this feature, the method <code>editingContextDidForgetObjectWithGlobalID</code>/ <code>editingContext:didForgetObjectWithGlobalID:</code> hasbeen added to EOObjectStore. This method is not intended to be calleddirectly by your application.</p><p>As a developer you should not worry about this feature; itshould just work without any additional code on your part. Thereare only a few cases where it could be incompatible with pre-EOF4.5 applications:</p><ul><li>When the snapshots are removed because theirreference counts fall to zero, the globalID associated with thesesnapshots are also released. If your application is written in Objective-Cand you cache globalIDs in your application, make sure you retainthem. If you don't, your application will crash with "Messagesent to freed object" errors when you try to access globalIDsthat have been freed. Previously GlobalIDs were never released;they were kept with the snapshots. This is not a problem if youuse Java as your development language, since Java automatically retainsall referenced objects.</li><li>If your application assumes that snapshots for fetched objectsare always present, you could have a problem. This is no longerthe case, and asking for a snapshot might now return <code>null</code>/<code>nil</code>.</li></ul><p>Sometimes you want a snapshot to stay around for the lifetimeof your application. If you need this functionality there are threeways to force selected snapshots to stay around:</p><ul><li>Use the method <code>incrementSnapshotCountForGlobalID</code> onEODatabase to force the snapshot to stay around. If you use thisapproach, make sure to call <code>decrementSnapshotCountForGlobalID</code> whenyou don't need the snapshot anymore.</li><li>Fetch the objects whose snapshots you need. (Note that ifyour application is written in pure Objective-C and it's notmultithreaded, the EOEditingContext doesn't retain its enterpriseobjects-you have to retain them yourself.)</li><li>Turn on entity caching for the entity. This automaticallyincrements the reference count for all the snapshots your entitycaches.</li></ul><p>You can turn the whole feature off and revert to the previousbehavior of retaining snapshots forever by invoking the class method <code>disableSnapshotRefCounting</code> on EODatabase.Make sure to call this method early in your application initializationcode, before the creation of any EODatabase instances.</p><br><a name = "TP503410723"></a><h3>Related API Changes</h3><p>The following tables summarize new or changed API to supportthe snapshot reference counting feature.</p><br><table border = "1" cellpadding = "3"><caption><strong>EODatabase (EOAccess/EODatabase.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>incrementSnapshotCountForGlobalID</code> (Java)<br>	<code>incrementSnapshotCountForGlobalID:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">If the receiver releases unreferenced snapshots, incrementsthe reference count for the shared snapshot associated with thespecified globalID.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>decrementSnapshotCountForGlobalID</code> (Java)<br>	<code>decrementSnapshotCountForGlobalID:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">If the receiver releases unreferenced snapshots, decrementsthe reference count for shared snapshot associated with the specifiedglobalID; if no more objects refer to the snapshot, removes it fromthe snapshot table.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>disableSnapshotRefCounting</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that disables the snapshot referencecounting feature so that instances don't release snapshots.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOObjectStore (EOControl/EOObjectStore.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>editingContextDidForgetObjectWithGlobalID</code> (Java)<br>	<code>editingContext:didForgetObjectWithGlobalID:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Invoked to inform the object store that it can stop keepingdata about an object it passed to a child. Don't invoke this method;it is invoked automatically by the Framework.</td></tr></table><br><br><a name = "CBGBBEEF"></a><h2>Snapshot Timestamping</h2><p>EOF caches database snapshots and uses the cached values toinitialize objects. This significantly improves performance, sinceusing the cached values is much faster than making round-trips tothe database for fetches. However, this behavior can lead to stalenessof the cached data; and it sometimes produces confusing results,especially when new values available from a fetch are ignored infavor of the stale snapshots.</p><p>A new snapshot timestamping feature updates snapshots appropriatelywhen fetching and allows an editing context to request that thesnapshots used to build enterprise objects are no older than theediting context's <code>fetchTimestamp</code>. Thedefault value for the <code>fetchTimestamp</code> ofa new editing context is one hour earlier than the creation timeof the editing context. So any snapshots that are less than an hourold are acceptable to the editing context; older cached values areignored. The default "lag" can be adjusted using the static method <code>setDefaultFetchTimestampLag</code> (orthe corresponding Objective-C class method), and the <code>fetchTimestamp</code> fora specific editing context can be set directly with <code>setFetchTimestamp</code>.</p><p>Note that the <code>fetchTimestamp</code> is significantonly when fetching data (typically by sending <code>objectsWithFetchSpecification</code>).An existing enterprise object is unaffected by changes to the editingcontext's <code>fetchTimestamp</code>.</p><p>When an EODatabase records a snapshot, it now also recordsa timestamp for that snapshot. The timestamp is an NSTimeInterval(relative to the reference date as documented for the NSDate class).Methods that return a snapshot from EODatabase or EODatabaseContextnow have variants that take an extra argument to specify a minimal timestampfor the snapshot. If the recorded snapshot's timestamp is earlierthan the requested time, <code>null</code>/<code>nil</code> isreturned. If the snapshot is recent enough for the request, the snapshotis returned as usual.</p><br><a name = "CBGJHDGC"></a><h3>Related API Changes</h3><p>The following tables summarize new API added to support thesnapshot timestamp feature.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Supportfor snapshot timestamping is not available in the com.apple.client packages.However, since snapshots are maintained only on the server, no timestampingtakes place on the client side of a Java Client application. Inother words, this feature can be used to its fullest potential ina Java Client application.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EODatabase (EOAccess/EODatabase.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>DistantPastTimeInterval</code>(Java)<br>	<code>EODistantPastTimeInterval</code> (Objective-C)<br>	(constant)</td><td rowspan = "1" colspan = "1" valign = "top">The NSTimeInterval used as a lower bound on timestamps. </td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setTimestampToNow</code></td><td rowspan = "1" colspan = "1" valign = "top">Sets the internal timestamp to value returned by NSDate's <code>timeIntervalSinceReferenceDate</code> method. Usedfor recording subsequent snapshots.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>snapshotForGlobalID(EOGlobalID)</code> <code>snapshotForGlobalID(EOGlobalID, double)</code><br>	(Java)</td><td rowspan = "1" colspan = "1" valign = "top">The new, overloaded version of this method takes a doubleargument to use as a timestamp. It returns the snapshot associatedwith the specified globalID. Returns <code>null</code> ifthere isn't a snapshot or if its timestamp is less than the specifiedtimestamp.<br>	The old version that only takes a globalID has been reimplementedto invoke the new version using <code>DistantPastTimeInterval</code> asthe timestamp.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>snapshotForSourceGlobalID(EOGlobalID, String)</code><code><br>	snapshotForSourceGlobalID(<br>&nbsp;&nbsp;&nbsp;&nbsp;EOGlobalID, <br>&nbsp;&nbsp;&nbsp;&nbsp;String, <br>&nbsp;&nbsp;&nbsp;&nbsp;double)</code><br>	(Java)</td><td rowspan = "1" colspan = "1" valign = "top">The new, overloaded version of this method takes a doubleargument to use as a timestamp. It returns the to-many snapshotfor the specified globalID and relationship name. Returns <code>null</code> ifthere isn't a to-many snapshot or if the timestamp is less thanthe specified timestamp.<br>	The old version that only takes aglobalID and a String has been reimplemented to invoke the new version using <code>DistantPastTimeInterval</code> asthe timestamp.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><br>	<code>snapshotForGlobalID:after:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Returns the snapshot associated with the specified globalID.Returns <code>nil</code> if thereisn't a snapshot or if its timestamp is less than the specifiedtimestamp. <br>	Note that <code>snapshotForGlobalID:</code> hasbeen reimplemented to invoke <code>snapshotForGlobalID:after:</code> with <code>EODistantPastTimeInterval</code> asthe timestamp.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><br>	<code>snapshotForSourceGlobalID:relationshipName:after:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Returns the to-many snapshot for the specified globalID andrelationship name. Returns <code>nil</code> ifthere isn't a to-many snapshot or if the timestamp is less thanthe specified timestamp. <br>	Note that <code>snapshotForSourceGlobalID:relationshipName:</code> hasbeen reimplemented to invoke <code>snapshotForSourceGlobalID:relationshipName:after:</code> with <code>EODistantPastTimeInterval</code> asthe timestamp.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>timestampForGlobalID</code> (Java)<br>	<code>timestampForGlobalID:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Returns the timestamp of the snapshot for the specified globalID.Returns <code>(EO)DistantPastTimeInterval</code> ifthere isn't a snapshot.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><br>	<code>timestampForSourceGlobalID</code> (Java)<br>	<code>timestampForSourceGlobalID:relationshipName:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Returns the timestamp of the to-many snapshot for the specifiedglobalID. Returns <code>(EO)DistantPastTimeInterval</code> ifthere isn't a snapshot.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EODatabaseContext (EOAccess/EODatabaseContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>snapshotForGlobalID(EOGlobalID)</code> <code>snapshotForGlobalID(EOGlobalID, double)</code><br>	(Java)</td><td rowspan = "1" colspan = "1" valign = "top">The new, overloaded version of this method takes a doubleargument to use as a timestamp. It returns the snapshot associatedwith the specified globalID. Returns <code>null</code> ifthere isn't a snapshot or if its timestamp is less than the specifiedtimestamp. Searches first locally (in the transaction scope) andthen in the receiver's EODatabase.<br>	The old version that onlytakes a globalID has been reimplemented to invoke the new versionusing <code>DistantPastTimeInterval</code> asthe timestamp.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>snapshotForSourceGlobalID(EOGlobalID, String)</code> <code><br>	snapshotForSourceGlobalID(    <br>&nbsp;&nbsp;&nbsp;EOGlobalID,    <br>&nbsp;&nbsp;&nbsp;String,    <br>&nbsp;&nbsp;&nbsp;double)</code><br>	(Java)</td><td rowspan = "1" colspan = "1" valign = "top">The new, overloaded version of this method takes a doubleargument to use as a timestamp. It returns the to-many snapshotfor the specified globalID and relationship name. Returns <code>null</code> ifthere isn't a to-many snapshot or if the timestamp is less thanthe specified timestamp.<br>	The old version that only takes aglobalID and a String has been reimplemented to invoke the new version using <code>DistantPastTimeInterval</code> asthe timestamp.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>snapshotForGlobalID:after:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Returns the snapshot associated with the specified globalID.Returns <code>nil</code> if thereisn't a snapshot or if its timestamp is less than the specifiedtimestamp. Searches first locally (in the transaction scope) andthen in the receiver's EODatabase.<br>	Note that <code>snapshotForGlobalID:</code> hasbeen reimplemented to invoke <code>snapshotForGlobalID:after:</code> with <code>EODistantPastTimeInterval</code> asthe timestamp.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>snapshotForSourceGlobalID:relationshipName:after:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Returns the to-many snapshot for the specified globalID andrelationship name. Returns <code>nil</code> ifthere isn't a to-many snapshot or if the timestamp is less thanthe specified timestamp.<br>	Note that <code>snapshotForSourceGlobalID:relationshipName:</code> hasbeen reimplemented to invoke <code>snapshotForSourceGlobalID:relationshipName:after:</code> with <code>EODistantPastTimeInterval</code> asthe timestamp.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOEditingContext (EOControl/EOEditingContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setDefaultFetchTimestampLag</code> (Java)<br>	<code>setDefaultFetchTimestampLag:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that assigns the default timestamplag for new editing contexts. The default value is 3600.0 seconds(one hour).<br>	When a new editing context is initialized, it isassigned a fetch timestamp equal to the current time less the defaulttimestamp lag. Setting the lag too high might cause every new editingcontext to accept very old cached data. Setting the lag too lowmight degrade performance due to excessive fetching. A negativelag value is treated as 0.0.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>defaultFetchTimestampLag</code> (Java)<br>	<code>defaultFetchTimestampLag</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns the default timestamplag.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setFetchTimestamp</code> (Java)<br>	<code>setFetchTimestamp:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Sets the receiver's fetch timestamp. When an editing contextfetches objects from its parent object store, the parent objectstore can use the timestamp to determine whether to use cached dataor to refetch the most current values. An editing context prefersthat fetched values are at least as recent as its fetch timestamp.Note that the parent object store is free to ignore the timestamp;so this value should be considered a hint or request and not a guarantee.<br>	Changingthe fetch timestamp has no effect on existing objects in the editingcontext; it can affect only subsequent fetches. To refresh existingobjects, invoke <code>refaultObjects</code> before youinvoke <code>setFetchTimestamp</code>.The initial valuefor the fetch timestamp of a new non-nested editing context is thecurrent time less the <code>defaultFetchTimestampLag</code>.A nested editing context always uses its parent's fetch timestamp. <code>setFetchTimestamp</code> raisesif it's invoked on a nested editing context.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>fetchTimestamp</code></td><td rowspan = "1" colspan = "1" valign = "top">Returns the receiver's fetch timestamp.</td></tr></table><br><br><a name = "CBGCGEJG"></a><h2>Handling Missing Faults</h2><p>In previous versions of EOF, if a fault fired but no correspondingdatabase row could be found (for example because of a referentialintegrity problem or because the row was deleted without EOF'sknowledge), the delegate method <code>databaseContextFailedToFetchObject</code>/<code>databaseContext:failedToFetchObject:globalID:</code> wascalled. If the delegate didn't fix the problem, an exception wasraised immediately. In 4.5, The delegate is invoked, but the exceptionis delayed or avoided, and an empty enterprise object is returned.If the application later tries to save an object graph that requiresthe missing fault, the exception is raised during <code>saveChanges</code>.If the object is never needed, no exception is raised.</p><br><a name = "TP503410724"></a><h3>Related API Changes</h3><p>The following tables summarize new API added to support thebetter handling of missing faults.</p><br><table border = "1" cellpadding = "3"><caption><strong>EODatabaseContext (EOAccess/EODatabaseContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>missingObjectGlobalIDs</code></td><td rowspan = "1" colspan = "1" valign = "top">Returns the globalIDs of any "missing" enterprise objects.Returns an empty array if no missing objects are known to the receiver.An object is "missing" when a fault fires and the correspondingrow for the fault isn't found in the database.<br>	To be notifiedwhen a missing object is discovered, implement the delegate method <code>databaseContextFailedToFetchObject</code>/<code>databaseContext:failedToFetchObject:globalID:</code>.<br>	Ifan application tries to save a missing object, an exception is raised. </td></tr></table><br><br><table border = "1" cellpadding = "3"><a name = "CBGHIFEJ"></a><caption><strong>EODatabaseContext Delegate(EOAccess/EODatabaseContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>databaseContextFailedToFetchObject</code> (Java)<br>	<code>databaseContext:failedToFetchObject:globalID:</code> (Objective-C)<br>	(changed behavior)</td><td rowspan = "1" colspan = "1" valign = "top">Invoked when a to-one fault can't find its data inthe database. Now if the method returns <code>false</code>/<code>NO</code>,the specified database context doesn't immediately raise as before.Instead, it simply tracks the globalID of the offending object.If the tracked globalID is in the list of updated objects when <code>prepareForSaveWithCoordinator</code>/<code>prepareForSaveWithCoordinator:editingContext:</code> is invoked(<code>saveChanges</code> invokes this method), an exceptionis raised. <br>	To get a list of the objects that failed to fetch,see the method <code>missingObjectGlobalIDs</code>.</td></tr></table><br><br><a name = "CBGCGIIG"></a><h2>Automatic Database Reconnection</h2><p>In EOF 4.5, a concrete adaptor can now implement methods thatcause EOF to automatically attempt to reconnect to a database serverwhen a connection is unexpectedly dropped. This behavior handlesthe problem of transient communication failures. By default reconnectionis attempted by all of the adaptors that ship with EOF 4.5.</p><p>EOF now sends <code>isDroppedConnectionException</code> tothe adaptor if an exception is raised during fetching or saving.If the adaptor returns <code>true</code>/<code>YES</code>,then it attempts to reconnect to the database and retry the operation.(The adaptor context must also implement <code>handleDroppedConnetion</code> toclean up the state of the context and its channels before the reconnectionis attempted.) If the reconnection attempt fails, the exceptionfrom the failure is raised as usual.</p><p>The delegate method <code>reconnectionDictionaryForAdaptor</code> canbe used to provide a new connection dictionary for the reconnectionattempt. If the delegate is not implemented, the adaptor uses itsexisting connection dictionary when reconnecting to the server.</p><p>You can completely override the database reconnection behaviorwith the delegate method <code>databaseContextShouldHandleDatabaseException</code> (Java)or <code>databaseContext: shouldHandleDatabaseException</code> (Objective-C).For more information, see  <a href="#CBGEHEGD">Table 5-20 </a>.</p><br><a name = "TP503410725"></a><h3>Related API Changes</h3><p>The following tables summarize new API added to support thedatabase reconnection feature.</p><br><table border = "1" cellpadding = "3"><caption><strong>EOAdaptor (EOAccess/EOAdaptor.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>handleDroppedConnection</code></td><td rowspan = "1" colspan = "1" valign = "top">The adaptor cleans up after a dropped connection by sending <code>handleDroppedConnection</code> toall of its adaptor contexts and then clearing its array of contexts.<br>	Ifthe receiver's delegate implements <code>reconnectionDictionaryForAdaptor</code>,that method is invoked and the result is used as the new connection dictionaryfor the adaptor. Otherwise, the adaptor attempts new connectionsusing the original connection dictionary.<br>	You shouldnever invoke this method; it is invoked automatically by the Framework.Subclasses don't normally need to override the superclass implementation.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>isDroppedConnectionException</code> (Java)<br>	<code>isDroppedConnectionException:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Returns <code>true</code>/<code>YES</code> ifthe exception is one that the adaptor can attempt to recover fromby reconnecting to the database, <code>false</code>/<code>NO</code> otherwise.The default implementation returns <code>false</code>/<code>NO</code>.Subclasses should implement it to allow for automatic database reconnection.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOAdaptor Delegate (EOAccess/EOAdaptor.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>reconnectionDictionaryForAdaptor</code> (Java)<br>	<code>reconnectionDictionaryForAdaptor:</code>(Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Invoked from <code>handleDroppedConnection</code>.If this method returns a non-<code>null</code>/<code>nil</code> value,the value is used as the adaptor's new connection dictionary. <br>	Thedelegate is responsible for guaranteeing that the new connectiondictionary is compatible with any EODatabase that is using the adaptor.If reconnection succeeds, the EODatabase continues to use its database snapshotsas if nothing had happened. Therefore, the new database server shouldhave the same data as the original.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOAdaptorContext (EOAccess/EOAdaptorContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>handleDroppedConnection</code></td><td rowspan = "1" colspan = "1" valign = "top">Implemented by subclasses to provide automatic databasereconnection support. If database reconnection is not supported,subclasses don't have to implement it.<br>	Subclass implementationsshould clean up the state of the adaptor context and its associatedadaptor channels so that they can be safely released and deallocated withoutany errors.<br>	Don't invoke this method; it's invokedautomatically by the Framework.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EODatabase (EOAccess/EODatabase.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>handleDroppedConnection</code></td><td rowspan = "1" colspan = "1" valign = "top">Received when a dropped connection is detected to initiatecleanup. It cleans up by sending <code>handleDroppedConnection</code> toits adaptor, and then sending <code>handleDroppedConnection</code> toall of its registered database contexts. When the cleanup procedureis complete, the Framework can automatically reconnect to the database.<br>	Don'tinvoke this method; it's invoked automatically by the Framework.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EODatabaseContext (EOAccess/EODatabaseContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>handleDroppedConnection</code></td><td rowspan = "1" colspan = "1" valign = "top">Cleans up after a dropped connection by effectively releasingadaptor context and database channels, and then creating a new adaptorcontext.<br>	Don't invoke this method; it's invoked automaticallyby the Framework.</td></tr></table><br><br><table border = "1" cellpadding = "3"><a name = "CBGEHEGD"></a><caption><strong>EODatabaseContext Delegate(EOAccess/EODatabaseContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>databaseContextShouldHandleDatabaseException</code> (Java)<br>	<code>databaseContext:shouldHandleDatabaseException:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Invoked when an exception is thrown in response to a lostdatabase connection. Implement this method only if you want to overridethe default reconnection behavior. If the delegate method is notimplemented, the reconnection decision is made according to the adaptor'sresponse to <code>isDroppedConnectionException</code> (<code>isDroppedConnectionException:</code> inObjective-C).<br>	The implementation of this method should inspectthe exception to determine if the exception is a response to a droppedconnection. If not, the delegate should simply raise the specifiedexception. If the exception is in response to a dropped connection,the method can return <code>true</code>/<code>YES</code> toallow the database context to handle the exception by automaticallyreconnecting to the database or can return <code>false</code>/<code>NO</code> tocustomize connection behavior.<br>	If the delegate returns <code>false</code>/<code>NO</code>,then the delegate is responsible for handling the exception and implementingan appropriate reconnection strategy. The database context retriesthe operation that generated the original exception without doingany additional clean up and without attempting to reconnect to thedatabase.</td></tr></table><br><br><a name = "CBGBEFAG"></a><h2>Setting Access Layer Delegates</h2><p>EOAdaptor, EOAdaptorContext, and EODatabaseContext now implementthe static method <code>setDefaultDelegate</code> tosimplify the setting of delegates for new instances of those classes(there are corresponding class methods in Objective-C). By default,the default delegate for those classes is <code>null</code>/<code>nil</code>.However, <code>setDefaultDelegate</code> can be usedto establish a default delegate for a particular class that willbe assigned to any new instance of that class when the instanceis initialized.</p><br><a name = "TP503410726"></a><h3>Related API Changes</h3><p>The following tables summarize new API added to support thedatabase reconnection feature.</p><br><table border = "1" cellpadding = "3"><caption><strong>EOAdaptor (EOAccess/EOAdaptor.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setDefaultDelegate</code> (Java)<br>	<code>setDefaultDelegate:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that sets the default delegatefor all newly created EOAdaptor instances. That is, specifies theobject that is assigned as delegate to new adaptor objects.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>defaultDelegate</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns the default delegate.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOAdaptorContext (EOAccess/EOAdaptorContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setDefaultDelegate</code> (Java)<br>	<code>setDefaultDelegate:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that sets the default delegatefor all newly created EOAdaptorContext instances (and their EOAdaptorChannels).That is, specifies the object that is assigned as delegate to newadaptor context objects and their channels.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>defaultDelegate</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns the default delegate.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EODatabaseContext (EOAccess/EODatabaseContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setDefaultDelegate</code> (Java)<br>	<code>setDefaultDelegate:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that sets the default delegatefor all newly created EODatabaseContext instances. That is, specifiesthe object that is assigned as delegate to new database contextobjects.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>defaultDelegate</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns the default delegate.</td></tr></table><br><br><a name = "CBGFAFFH"></a><h2>Key Value Coding Changes</h2><p>EOF 4.5 introduces two improvements to key-value coding: Theaddition of key binding objects and the enforcement of lowercasekey names. The follow sections describe each.</p><br><a name = "TP503410727"></a><h3>Key Bindings</h3><p>New key-value coding primitives have been introduced. Thenew primitives are based on <b>bindings</b>, which associatea class/key pair to a mechanism for accessing the key. There are twotypes of bindings, <b>get bindings</b> and <b>setbindings</b>. They are represented by the new class EOKeyBinding.</p><p>To access an object's data with key-value coding, clientstypically use the EOKeyValueCoding and EOKeyValueCodingAdditionsmethods <code>valueForKey</code>, <code>takeValueForKey</code>,and so on. However, in EOF 4.5, clients can optimize access by obtaining andcaching bindings for particular class/key combinations and applyingthose bindings directly. Classes can override the EOKeyValueCodingmethods (such as <code>valueForKey)</code> directly,but overriding <code>keyValueBindingForKey</code> toreturn an appropriately initialized binder object provides the maximumperformance benefit.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Theneed to override the default key-value coding methods, particularlythe new binding primitives, is extremely rare. The default behavioris very efficient and should be well suited to almost any application.</td></tr></table><br><p>Clients caching bindings are responsible for checking thatthe class of the object to which a binding is applied matches thetarget class of the binding. Using a binding obtained from one classon an object of another results in undefined behavior.</p><br><a name = "TP503410728"></a><h3>Enforcing LowercaseKey Names</h3><p>EOF expects keys to begin with a lowercase letter. It nowlogs a warning if that restriction is violated. For backwards compatibilitywith previous releases which did not strictly check capitalization,you can use the EOKeyValueCoding.KeyBinding static method <code>suppressCapitalizedKeyWarning</code> tosuppress the warning for capitalized keys (EOKeyBinding class methodin Objective-C). However, note that this method is deprecatedand will be removed in a future release.</p><br><a name = "TP503410729"></a><h3>Related API Changes</h3><p>The following new classes have been added to support key valuebindings:</p><ul><li>EOKeyValueCoding.KeyBinding (Java) and EOKeyBinding(Objective-C)</li><li>EOKeyValueCoding.KeyGetBinding (Java) and EOKeyGetBinding(Objective-C)</li><li>EOKeyValueCoding.KeySetBinding (Java) and EOKeySetBinding(Objective-C)</li></ul><p>For more information, see the class specification for EOKeyValueCoding.KeyBinding/EOKeyBinding.</p><p>In addition, the EOKeyValueCoding interface/informal protocolhas been enhanced to create and return key bindings. In Java, thenew methods are defined in a new interface called EOKeyValueCoding.KeyBindingCreation.In Objective-C, the new methods are defined in <tt>EOKeyValueCoding.h</tt>.For more information, see the EOKeyValueCoding.KeyBindingCreationinterface specification (Java) or the EOKeyBindingCreation informalprotocol specification (Objective-C).</p><br><a name = "CBGDCIHC"></a><h2>Recursive Reader and WriterLocks</h2><p>A new class, EOMultiReaderLock, provides EOF with recursivereader and writer locks. The locks are recursive; a single threadcan request a lock many times, but a lock is actually taken onlyon the first request. Likewise, when a thread indicates it's finishedwith a lock, it takes an equal number of unlock calls to returnthe lock.</p><p>There is no limit on the number of reader locks that can betaken by a process. However, there can only be one writer lock ata time, and a writer lock is not issued until all reader locks arereturned. (Reader locks aren't issued to new threads when thereis a thread waiting for a writer lock, but threads that alreadyhave a reader lock can increment their lock count.)</p><p>Thread safety is maintained by using mutex locks (binary semaphores),which ensures that no more than one critical section of the classcan be processed at a time. The queueing order of requests for writerlocks is not managed by the class; the underlying implementationof mutex signaling manages the queue order.</p><p>EOMultiReaderLock correctly handles promotion of a read lockto a write lock, and the extension of a reader lock to the currentwriter. This prevents a thread from deadlocking on itself when requestinga combination of lock types.</p><p>EOMultiReaderLocks are slightly more time-expensive than NSRecursiveLocksbecause the recursion count has to be stored per-thread, causingeach request for a reader lock to incur a hash. Writer locks areeven more expensive because EOMultiReaderLock must poll the hashtableuntil all reader locks have been returned before the writer lockcan be taken.</p><br><a name = "TP503410730"></a><h3>Related API Changes</h3><p>A new class, EOMultiReaderLock, has been added to the Frameworkto support the new multi reader and writer lock feature. For moreinformation, see the corresponding class specification.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Thisclass doesn't exist in com.apple.client.eocontrol. Multithreadedclients aren't yet supported in Java Client applications. Allthe client-side locks in Java Client application's are no-ops.</td></tr></table><br><br><a name = "CBGBIBHF"></a><h2>LDAP Adaptor Example</h2><p>EOF 4.5 comes with a new sample adaptor: the LDAP adaptor.It provides read, modify, and delete access and limited supportfor inserting. Additionally it provides a simple way to verify auser's password on the Web with an LDAP server without requiringa model.</p><br><a name = "TP503410731"></a><h3>LDAP Client Libraries</h3><p>The LDAP adaptor is ready to use when you install WebObjects.The source code is provided so that you can use a different clientlibrary or enhance the adaptor yourself.</p><p>The LDAP adaptor consists of two pieces: The adaptor frameworkand an LDAP client library. Apple ships a client library based onthe public University of Michigan LDAP Client. You can build andinstall this library as a framework, or you can substitute your ownclient library, such as the Netscape LDAP library. (The latter hasnot been tested, but both libraries conform to RFC 1823, the LDAPclient API).</p><br><a name = "TP503410732"></a><h3>Creating Models</h3><p>You create a model for an LDAP server with EOModeler the wayyou create models for other adaptors. Simply choose New from theModel menu, and choose LDAP as the adaptor for the new model.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Note: </b>Ifall you are trying to do is authenticate users using an LDAP server'susernames and encrypted passwords, you don't need to create amodel. See  <a href="#CJADAEAG">"Performing Authentication" </a>.</td></tr></table><br><br><a name = "TP503410733"></a><h4>Logging In</h4><p>The LDAP adaptor defines the following connection keys, whichare represented in the login panel:</p><dl><dt>Server Name</dt><dd>The server's address. Either an IP address (e.g. 17.205.15.205)or a name (e.g. ldap.bigfoot.com). If you are inside a corporatefirewall, it might not allow LDAP traffic to pass through. Checkwith your administrator if you have trouble accessing LDAP serverson the open internet.</dd></dl><dl><dt>User Name</dt><dd>If your LDAP server requires you to login, enter a username.This version of the LDAP adaptor supports simple authenticationonly.</dd></dl><dl><dt>Password</dt><dd>If your LDAP server requires a password, enter it here.</dd></dl><dl><dt>Search Base</dt><dd>Entries on an LDAP server (roughly equivalent to rowsin a database) are organized in trees. The search base indicateswhat branch of the tree to begin searching in. Common designs areto have the top level of the tree have country or organization branches,so good search bases have the form "c=US" or "o=Apple Computer".An approximate database equivalent is to say the search base isANDed with any qualifiers you pass in.</dd></dl><dl><dt>Schema Base</dt><dd>This value is used only during reverse engineering theLDAP server. The Adaptor looks at this location for the subschemaentry. Note that during reverse engineering, the scope is temporarilyoverridden to Base because the subschema does not have any children.</dd></dl><dl><dt>Value Separator</dt><dd>The character used to separate multiple values for aproperty.</dd></dl><dl><dt>Port</dt><dd>LDAP servers are almost always on port 389, but secureservers might use a different port.</dd></dl><dl><dt>Timeout</dt><dd>Maximum time to wait during LDAP operations before raisingan exception. Timeouts come from the client library and are raisedas EOGeneralAdaptorExceptions.</dd></dl><dl><dt>Scope</dt><dd>LDAP entries belong to an object class. The Adaptormaps each class to an entity. Like classes in object-oriented programming,LDAP classes have an inheritance hierarchy. Depending on the scopeyou set, results include results from the that object class only(Base), its immediate children (One Level), or the entire subtree(Subtree). The more you include, the larger the result set is fora given search. Object class hierarchies and entry hierarchies worktogether to give order to the LDAP server's data, and the Adaptorprovides control over how ordered or chaotic the data appears.</dd></dl><br><a name = "TP503410734"></a><h4>If Reverse EngineeringFails</h4><p>The LDAP specification does not require LDAP servers to providea means of learning the server's layout; providing a schema toclients is optional. For this reason, the LDAP adaptor might notbe able to reverse-engineer your LDAP server to generate an EOModel automatically.If this is the case, you might need to create your model by hand.</p><p>Generally speaking, Netscape Directory Servers automaticallycreate and provide schemas to clients. So, if you have a NetscapeDirectory server, you should be fine.</p><p>However, if the adaptor can't find subschema information,it creates a default model with two entities: Person and NoSchemaDataAvailable.If the server is <tt>ldap.bigfoot.com</tt> (a well knownserver) and the scope is set to Subtree, this model works for findingnames. The NoSchemaDataAvailable entity is designed to be an errormessage and should be deleted from the model. (EOAdaptors aren'tallowed to return <code>null</code>/<code>nil</code> whenreverse engineering a database, so the best alternative is to returna minimal model.)</p><br><a name = "TP503410735"></a><h3>Adding Entries to theServer</h3><p>The LDAP adaptor provides limited support for adding entriesto the server. If you plan to use the adaptor to insert entries,keep the following points in mind:</p><ul><li>The LDAP adaptor doesn't provide automaticprimary key generation. so set the primary key (the distinguishedname, or "dn") as a class property and set an appropriate valueyourself before saving a new entry.</li><li>Consider adding an objectclass attribute to the entity soyour can add the entry to multiple classes at once.</li><li>You must enforce object rules in custom code. The adaptordetects object class violations once you attempt to save changes,but the violations cause the adaptor to raise an exception.</li></ul><br><a name = "CJADAEAG"></a><h3>Performing Authentication</h3><p>One of the common applications for LDAP is to verify a user'spassword on the Web. The authentication is generally done by theLDAP server, not by retrieving the user's password from an LDAPentry. So, in essence, all that is needed is a mutable connectiondictionary from a model and a request to validate the connection.The LDAP Adaptor provides a simple way to do this without a model:</p><blockquote><pre>java.lang.Throwable athenticateUser()</pre></blockquote><br><p>or in Objective-C,</p><blockquote><pre>+ (NSException *)authenticateUserString:(NSString *)userString    password:(NSString *)password    withServer:(NSString *)server    matchOnAttribute:(NSString *)searchAtt    searchBase:(NSString *)base    searchScope:(NSString *)scope;</pre></blockquote><br><p>The method is pretty easy to use and the header file containsspecifics on its use. Here is a sample code fragment from a WebObjectsapplication that has one page, "Main" with three instance variables: <code>userName1</code>, <code>password1</code>,and <code>isLoggedIn</code>. Thismethod is tied to the web page's Submit button.</p><blockquote><pre>- authenticateUser {    NSException *exception;    exception = [LDAPAdaptor authenticateUserString:userName1            password:password1            withServer:@"bigbird.apple.com"            matchOnAttribute:@"cn"            searchBase:@"o=apple computer" searchScope:@"Subtree"];\x93    if (exception) {        NSLog(@"Auth failed.");        isLoggedIn = NO;    } else {        NSLog(@"Auth successful.");        isLoggedIn = YES;    }    return self;}</pre></blockquote><br><p>Or, in Java (<code>isLoggedIn</code> isa string instead of a BOOL in this example):</p><blockquote><pre>public WOComponent authenticateUser() {    java.lang.Throwable ex = null;    ex = LDAPAdaptor.authenticateUser (        userName,        pswField,        "bigbird.apple.com",        "cn",        "o=Apple Computer",        "Subtree");    if (ex == null) {          isLoggedIn = "You are now logged in.";    } else {        isLoggedIn = ex.getMessage();    }    return this;}</pre></blockquote><br><br><a name = "CBGHEEDI"></a><h2>Miscellaneous API Enhancements	</h2><p>This section summarizes other miscellaneous methods addedin EOF 4.5 not covered in the other sections.</p><br><table border = "1" cellpadding = "3"><caption><strong>EOAdaptorContext (EOAccess/EOAdaptorContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>hasOpenTransaction</code></td><td rowspan = "1" colspan = "1" valign = "top">Returns <code>true</code>/<code>YES</code> ifa transaction is open (begun but not yet committed or rolled back).For more information on this addition, see the section  <a href="#CBGBFCJF">"Deprecated API" </a>.</td></tr></table><br><br><table border = "1" cellpadding = "3"><a name = "CBGIBICD"></a><caption><strong>EODatabaseContext Delegate(EOAccess/EODatabaseContext.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>databaseContextWillFireObjectFaultForGlobalID</code> (Java)<br>	<code>databaseContext:<br>&nbsp;&nbsp;&nbsp;&nbsp;willFireObjectFaultForGlobalID:<br>&nbsp;&nbsp;&nbsp;&nbsp;withFetchSpecification:<br>&nbsp;&nbsp;&nbsp;&nbsp;editingContext:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Invoked just before the Framework-generated fetch specification(provided as an argument) is used to clear the fault for the specifiedglobalID.<br>	Note that it is very dangerous to modify the fetch specification.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>databaseContextWillFireArrayFaultForGlobalID</code> (Java)<br>	<code>databaseContext:<br>&nbsp;&nbsp;&nbsp;&nbsp;willFireArrayFaultForGlobalID:<br>&nbsp;&nbsp;&nbsp;&nbsp;relationship:<br>&nbsp;&nbsp;&nbsp;&nbsp;withFetchSpecification:<br>&nbsp;&nbsp;&nbsp;&nbsp;editingContext:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Invoked just before the Framework-generated fetch specification(provided as an argument) is used to clear the fault for the specifiedglobalID and relationship.<br>	Note that it is very dangerous tomodify the fetch specification.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOEditingContext Additions (Objective-C only; EOAccess/EOUtilities.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>createAndInsertInstanceOfEntityNamed:</code></td><td rowspan = "1" colspan = "1" valign = "top">Creates a new enterprise object of the specified entity, insertsit into the receiving editing context, and returns the new object.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOUtilities (Java)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>createAndInsertInstance</code></td><td rowspan = "1" colspan = "1" valign = "top">Creates a new enterprise object of the specified entity, insertsit into the specified editing context, and returns the new object.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOClassDescription (EOControl/EOClassDescription.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>fetchSpecificationNamed</code> (Java)<br>	<code>fetchSpecificationNamed:</code>(Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">The receiver returns the fetch specification it associates withthe specified name. EOClassDescription's implementation returns <code>null</code>/<code>nil</code>;subclasses can override it to return a fetch specification.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOFetchSpecification (EOControl/EOFetchSpecification.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>fetchSpecificationNamed</code> (Java) <br>	<code>fetchSpecificationNamed:entityNamed:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns the fetch specificationthat the specified entity associates with the specified fetch specificationname.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOQualifier (EOControl/EOQualifier.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>evaluateWithObject</code> (Java)<br>	<code>evaluateWithObject:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Implemented by subclasses to return <code>true</code>/<code>YES</code> ifthe provided object matches the criteria specified in the receiver, <code>false</code>/<code>NO</code> otherwise.The argument should be an enterprise object, a snapshot dictionary,or something that implements key-value coding.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>allQualifierKeys</code></td><td rowspan = "1" colspan = "1" valign = "top">Returns an NSSet of strings, which are the left-hand sidesof all the qualifiers in the receiver. For example, if you havea qualifier<br>	 salary &gt; 10000 AND manager.lastName = 'smith'<br>	<code>allQualifierKeys</code> returnsan array containing the strings "salary" and "manager.lastName".<br>	Subclassesshould not override this method, instead they should   override <code>addQualifierKeysToSet</code>.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>addQualifierKeysToSet</code> (Java)<br>	<code>addQualifierKeysToSet:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">Adds the receiver's qualifier keys to the specified NSMutableSet.The subclasses in the EOControl framework do this by traversingthe tree of qualifiers. Node qualifiers (such as EOAndQualifier)recursively invoke this method until they reach a leaf qualifier (suchas EOKeyValueQualifier) which adds its key to the set. <br>	Subclassesof EOQualifier must implement this method.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOTemporaryGlobalID</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>assignGloballyUniqueBytes</code> (Javaonly)</td><td rowspan = "1" colspan = "1" valign = "top">This method, which was not wrapped in 4.0, is the equivalentof the Objective-C method, <code>assignGloballyUniqueBytes:</code>,which assigns a network-wide unique ID</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EOAssociation (EOInterface/EOAssociation.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>isExplicitlyDisabled</code>(Java Client only)<br>	<code>setExplicitlyDisabled</code>(Java Client only)</td><td rowspan = "1" colspan = "1" valign = "top">Returns or sets whether or not the association is explicitlydisabled. These methods are used by the new user interface generationlayer, which is described in  <a href="Java_Client.html#BFJJEJJB">"Direct To Java Client" </a>. An association is "explicitly disabled"when the display object shouldn't be editable, such as in thecase where the display object simply displays the results of a search.</td></tr></table><br><br><table border = "1" cellpadding = "3"><caption><strong>EODisplayGroup (EOInterface/EODisplayGroup.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>New or Changed API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>Description</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>globalDefaultStringMatchOperator</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns the default operator usedfor matching strings, one of <code>caseInsensitiveLike</code> or <code>like</code></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setGlobalDefaultStringMatchOperator</code> (Java)<br>	<code>setGlobalDefaultStringMatchOperator:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that sets the default operatorfor instances to use for string matching.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>globalDefaultStringMatchFormat</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns the default format usedfor matching strings ("<code>%@*</code>", for example).</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setGlobalDefaultStringMatchFormat</code> (Java)<br>	<code>setGlobalDefaultStringMatchFormat:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that sets the default format for instancesto use for string matching.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>globalDefaultForValidatesChangesImmediately</code></td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that returns <code>true</code>/<code>YES</code> ifinstances validate immediately by default.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>setGlobalDefaultForValidatesChangesImmediately</code> (Java)<br>	<code>setGlobalDefaultForValidatesChangesImmediately:</code> (Objective-C)</td><td rowspan = "1" colspan = "1" valign = "top">A static/class method that sets the default validation behaviorfor instances.</td></tr></table><br><br><a name = "CBGBFCJF"></a><h2>Deprecated API</h2><p>Nested transactions are no longer supported. EOF never actuallyused nested transactions. Furthermore, the concrete adaptors werenot guaranteed to support them, especially since the SQL/92 standarddoesn't allow nested transactions. New features in EOF 4.5 make nestedtransactions impossible to support.</p><p>Consequently, the following methods are deprecated.</p><br><table border = "1" cellpadding = "3"><caption><strong>EOAdaptorContext (EOAccess/EODeprecated.h)</strong></caption><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><b>Deprecated API</b></td><td rowspan = "1" colspan = "1" valign = "top"><b>New API or Workaround</b></td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>canNestTransactions:</code></td><td rowspan = "1" colspan = "1" valign = "top">None. <br>	No adaptor can nest transactions.</td></tr><tr><td rowspan = "1" colspan = "1" valign = "top" scope="row"><code>transactionNestingLevel</code></td><td rowspan = "1" colspan = "1" valign = "top"><code>hasOpenTransaction</code><br>	Returns <code>true</code>/<code>YES</code> ifa transaction is open (begun but not yet committed or rolled back).</td></tr></table><br><p>For backwards compatibility, the Sybase Adaptor still allowsyou to attempt to begin a nested transaction, but the implementationignores the nesting.</p><br><a href="NewInWebObjects.html"><img src="../../../../../images/up.gif" border="0" width="36" height="16"></A></A></a></BODY></HTML>