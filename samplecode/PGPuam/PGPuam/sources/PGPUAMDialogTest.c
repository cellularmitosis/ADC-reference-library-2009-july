//------------------------------------------------------------------------------------#pragma mark Includes//------------------------------------------------------------------------------------//#include <stdio.h>#include <time.h>#include <string.h>#include <console.h>#include <sioux.h>#include <Errors.h>#include <String.h>#include <A4Stuff.h>#include <Resources.h>#include <MixedMode.h>#include <CodeFragments.h>#include <Gestalt.h>#include <PLStringFuncs.h>#include "ClientUAM.h" #include "AFPPackets.h"#include <stdio.h>#include "TPGPkey.h"#include "TPGPException.h"#include "TMacException.h"#include "TASIPPGPkey.h"#include "ASIPChallenge.h"#include "PGPUAMclient.h"#include "PGPUAMclientLoginDialog.h"#include "PGPUAMclientProtocol.h"#include "PGPUAMmsgFormat.h"#include "PGPUAMclient.h"#include <Appearance.h>pascal 	OSStatus 	__pgpuam_client (UAMArgs *theArgs);// ---------------------------------------------------------------------------#pragma mark Globals// ---------------------------------------------------------------------------  	static TASIPPGPkey 		gsTheServerKey; 	static PGPKeyRef 		gsTheClientKeyRef	= kInvalidPGPKeyRef;	static Str255 	  		gsCounterChallengeString; 	 	static AFPClientInfo	gClientInfo;  		pascal OSStatus  simulateOpenSession(OTAddress *addr, const char *endpointString, UAMMessagePtr message);	pascal OSStatus  simulateSendRequest(UAMMessagePtr message);	pascal OSStatus  simulateCloseSession(short sessRefNum);	pascal OSStatus  simulateGetClientInfo (short infoType,ClientInfo	**infoPtr);		 	pascal void  	simulateEventCallback (EventRecord *theEvent);		 	pascal OSStatus  simulateOpenSession(OTAddress *addr, const char *endpointString, UAMMessagePtr message){	PGPError			err			= kPGPError_NoErr;	PGPFilterRef 		theFilter 	= kInvalidPGPFilterRef;	PGPKeySetRef		newKeySet 	= NULL;	PGPKeySetRef		singleSet 	= NULL;	PGPKeyRef 			theKeyRef	= kInvalidPGPKeyRef;	PGPKeyIterRef 		theIterator = kInvalidPGPKeyIterRef;	PGPKeyListRef 		theKeyListRef = kInvalidPGPKeyListRef;	PGPUInt32 			numKeys;	PGPSize				bufLen;	TPGPkey				theKey;		StringPtr 			p;	StringPtr 			challengeString;		Str255 	  			userName;	Str255 	  			counterChallengeString;	Str255 				fpString;	OSStatus			status = kFPAccessDenied;		p = message->cmdBuffer + message->cmdBuffer[1] + 2; 	p = p + p[0] +1;	PLstrcpy(userName, p);	p2cstr(userName);	 	challengeString = p + p[0] +1; 		// Find key in database 			ThrowIfPGPErr( PGPNewUserIDNameFilter(TPGPkey::fgContext, (char*) userName , kPGPMatchEqual, &theFilter));	ThrowIfPGPErr( PGPFilterKeySet(TPGPkey::fgPGPKeySetRef , theFilter, &newKeySet));	PGPFreeFilter(theFilter); 	ThrowIfPGPErr( PGPCountKeys(newKeySet, &numKeys));	if(numKeys > 0) 	{					err = PGPOrderKeySet(newKeySet,kPGPAnyOrdering, &theKeyListRef);		err = PGPNewKeyIter( theKeyListRef, &theIterator );				while( (err = PGPKeyIterNext( theIterator,&theKeyRef )) == kPGPError_NoErr)		{			Boolean canSign;			PGPGetKeyBoolean (theKeyRef, kPGPKeyPropCanSign,  &canSign);			if(canSign) break;		} 		 		 		ThrowIfPGPErr(err); 		gsTheClientKeyRef = theKeyRef; 				PGPGetKeyPropertyBuffer( theKeyRef, kPGPKeyPropFingerprint, sizeof( fpString ) - 1, &fpString[1], &bufLen);		fpString[0] = (bufLen & 0xFF);					PGPFreeKeyIter(theIterator );		PGPFreeKeyList(theKeyListRef );		PGPFreeKeySet(newKeySet ); 		ReplyToChallenge(&gsTheServerKey, "foo", challengeString, gsCounterChallengeString);		p = (StringPtr) FormatLoginResp( message->replyBuffer,  gsCounterChallengeString, fpString);								message->replyBufferSize =  p - message->replyBuffer;		status = kFPAuthContinue;	}					if(message->completion)		(message->completion)( message->contextPtr, status );		return noErr;}pascal OSStatus  simulateSendRequest(UAMMessagePtr message){	PUAM_LOGIN_CONT_CMD	cmd;	OSStatus err = kFPAccessDenied;		if( message->cmdBuffer[0]  == kFPLoginCont) 	{		message->cmdBuffer = message->cmdBuffer + 4;		// parse the reply		 	ParseLoginContinueCmd(message->cmdBuffer, &message->cmdBufferSize, &cmd);				if(gsTheClientKeyRef)		{			TPGPkey theKey;			theKey.Initialize(gsTheClientKeyRef);						if( VerifyCounterChallenge(&theKey, gsCounterChallengeString, cmd.SigPString) )				err = noErr;		}	}		 message->replyBufferSize = 0;	 	if(message->completion)		(message->completion)( message->contextPtr, err);	return noErr;}pascal OSStatus  simulateCloseSession(short sessRefNum){	return noErr;}  pascal OSStatus   simulateGetClientInfo (short infoType,ClientInfo	**infoPtr) 		 {	if (kAFPClientInfo != infoType) return -1;	*infoPtr = (ClientInfo*) & gClientInfo;	return noErr;}  pascal void  simulateEventCallback (EventRecord *theEvent) 	 { }  static pascal OSErr InitMac (void);static pascal OSErr InitMac (void){	MaxApplZone ( );	InitGraf (&(qd.thePort));	InitFonts ( );	InitWindows ( );	InitMenus ( );	TEInit ( );	InitDialogs (nil);	return noErr;}#pragma mark -  //------------------------------------------------------------------------------------void main(void)//------------------------------------------------------------------------------------////{// Initialize allocatable storage to  kInvalidPGP..	UAMArgs					theArgs; 	ClientUAMCallbackRec	theCallbacks;  	OSStatus				err = -1;		  	Str63					SavedUserName;  #if __MWERKS__	extern tSIOUXSettings	SIOUXSettings;	SIOUXSettings.asktosaveonclose = false;	SIOUXSettings.autocloseonquit	= true;	SIOUXSettings.rows = 40;	#endif	  	InitMac();// set up simulated callbacks..	theArgs.callbacks = &theCallbacks; 	theCallbacks.OpenSessionUPP 	=  NewRoutineDescriptor((ProcPtr) simulateOpenSession, kOpenSessionProcInfo, kPowerPCISA); 	theCallbacks.SendRequestUPP  	=  NewRoutineDescriptor((ProcPtr) simulateSendRequest, kSendRequestProcInfo, kPowerPCISA); 	theCallbacks.CloseSessionUPP  	=  NewRoutineDescriptor((ProcPtr) simulateCloseSession, kCloseSessionProcInfo, kPowerPCISA);	theCallbacks.GetClientInfoUPP  	=  NewRoutineDescriptor((ProcPtr) simulateGetClientInfo, kGetClientInfoProcInfo, kPowerPCISA);	theCallbacks.EventCallbackUPP  	=  NewRoutineDescriptor((ProcPtr) simulateEventCallback, kEventCallbackProcInfo, kPowerPCISA);	 	gClientInfo.fInfoType = kAFPClientInfo; 	gClientInfo.fVersion = 9; 	gClientInfo.fNumAFPVersions = 1; 	gClientInfo.fAFPVersionStrs = nil; 	{ 		StringHandle name;		name = GetString(-16096);		if(name) 		{ 			PLstrcpy( gClientInfo.fDefaultUserName, *name ); 		}		else 			PLstrcpy( gClientInfo.fDefaultUserName, "\pfoo"); 	}  	gAFPSrvrSig =  (UInt8 *) "\xb4\x37\xd4\x87\xa2\x63\xb4\x02\x65\x9b\x79\xb9\xC5\x21\xa2\x82"; 	try	{   	// open the keyring			TPGPkey::Initialize();		TPGPkey::OpenKeyDefaultRing();		// pickup the server key		gsTheServerKey.Initialize(gAFPSrvrSig);  		theArgs.Opt.open.srvrInfo = (AFPSrvrInfo*) "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x14When Diplomacy Fails\0"													"\x00\x22"  													"\xb4\x37\xd4\x87\xa2\x63\xb4\x02\x65\x9b\x79\xb9\xC5\x21\xa2\x82";		theArgs.command	= kUAMOpen;		err =  __pgpuam_client ( &theArgs );		 		if( err == noErr) 		{					SavedUserName[0] =  '\0';	 		theArgs.Opt.auth.userName =  SavedUserName;			theArgs.command	= kUAMLogin;			err = __pgpuam_client ( &theArgs );		}	}			// handle Mac errors	catch (TMacException &ex)	{		char 		errorBuf[256];		SInt16 			itemHit;			err = theArgs.result = ex.GetExceptionErr();  		sprintf(errorBuf, "PGPUAM SHELL Error: %d, %s, File: %s, Line: %d",  							 ex.GetExceptionErr(), ex.GetExceptionMessage(),  ex.GetExceptionFile(),  ex.GetExceptionLine());	 	StandardAlert(kAlertStopAlert,(UInt8 *)errorBuf, nil, nil , &itemHit);  		if(err == noErr) err = userCanceledErr;	}// handle PGP errors	catch (TPGPException &ex)	{		char 		errorBuf[256];		char 		explanationBuf[256];		SInt16 		itemHit; 		PGPGetErrorString ( ex.GetExceptionErr(), sizeof(explanationBuf), explanationBuf);				sprintf(errorBuf, "PGPUAM SHELL Error: %d, %s, File: %s, Line: %d",  							 ex.GetExceptionErr(), ex.GetExceptionMessage(),  ex.GetExceptionFile(),  ex.GetExceptionLine());			c2pstr(explanationBuf);		c2pstr(errorBuf); 		StandardAlert(kAlertStopAlert,(UInt8 *)errorBuf, (UInt8 *)explanationBuf, nil , &itemHit);		err = theArgs.result = userCanceledErr; 	}		catch(...)	{	}		theArgs.command	= kUAMClose;	__pgpuam_client ( &theArgs );	TPGPkey::CloseKeyRing();	 	DisposeRoutineDescriptor(theCallbacks.OpenSessionUPP); 	DisposeRoutineDescriptor(theCallbacks.SendRequestUPP);	if((err != noErr)  && (err != userCanceledErr))		{			SInt16  itemHit; 			StandardAlert(kAlertStopAlert,"\pAuthentication Failed!",  nil, nil , &itemHit);		} }  