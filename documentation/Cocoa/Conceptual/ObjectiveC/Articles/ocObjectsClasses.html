<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>The Objective-C 2.0 Programming Language: Objects, Classes, and Messaging</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Objects, Classes, and Messaging"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001163-CH11" title="Objects, Classes, and Messaging"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ObjectiveCLanguage-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000856" target="_top">Objective-C Language</a> &gt; <a href="../Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163-CH1-SW2">The Objective-C 2.0 Programming Language</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/introObjectiveC.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocDefiningClasses.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001163-CH11-SW1" title="Objects, Classes, and Messaging"></a><h1>Objects, Classes, and Messaging</h1><p>This chapter describes the fundamentals of objects, classes, and messaging as used and implemented by the Objective-C language. It also introduces the Objective-C runtime.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-SW33">Runtime</a>
				
			<br/>
			
        
			
			
				<a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-SW2">Objects</a>
				
			<br/>
			
        
			
			
				<a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-SW5">Object Messaging</a>
				
			<br/>
			
        
			
			
				<a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-BAJCDADF">Classes</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001163-CH11-SW33" title="Runtime"></a><h2>Runtime</h2><p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it dynamically performs operations such as creating objects and determining what method to invoke. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work. Typically, however, you don’t need to interact with the runtime directly. To understand more about the functionality it offers, though, see <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-111023" title="Objects"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW2" title="Objects"></a><h2>Objects</h2><p>As the name implies, object-oriented programs are built around <strong>objects</strong>. An object associates data with the particular operations that can use or affect that data. Objective-C provides a data type to identify an object variable without specifying a particular class of the object—this allows for dynamic typing. In a program, you should typically ensure that you dispose of objects that are no longer needed. </p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW31" title="Object Basics"></a><h3>Object Basics</h3><p>An object associates data with the particular operations that can use or affect that data. In Objective-C, these operations are known as the object’s <strong>methods</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_259"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_260"></a>; the data they affect are its <strong>instance variables</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_261"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_262"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_263"></a>. In essence, an object bundles a data structure (instance variables) and a group of procedures<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_264"></a> (methods) into a self-contained programming unit.</p><p>For example, if you are writing a drawing program that allows a user to create images composed of lines, circles, rectangles, text, bit-mapped images, and so forth, you might create classes<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_265"></a> for many of the basic shapes that a user can manipulate. A Rectangle object<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_266"></a>, for instance, might have instance variables that identify the position of the rectangle within the drawing along with its width and its height. Other instance variables could define the rectangle’s color, whether or not it is to be filled, and a line pattern that should be used to display the rectangle. A Rectangle class would have methods to set an instance’s position, size, color, fill status, and line pattern, along with a method that causes the instance to display itself.</p><p>In Objective-C, an object’s instance variables<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_267"></a> are internal to the object; generally, you get access to an object’s state only through the object’s methods (you can specify whether subclasses or other objects can access instance variables directly by using scope directives, see <span class="content_text"><a href="ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-88468">“The Scope of Instance Variables”</a></span>). For others to find out something about an object, there has to be a method to supply the information. For example, a Rectangle would have methods that reveal its size and its position.</p><p>Moreover, an object sees only the methods that were designed for it; it can’t mistakenly perform methods intended for other types of objects. Just as a C function protects its local variables, hiding them from the rest of the program, an object hides both its instance variables and its method implementations.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-115416" title="id"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW3" title="id"></a><h3>id</h3><p>In Objective-C, object identifiers<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_268"></a> are a distinct data type: <code>id</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_269"></a>. This is the general type for any kind of object regardless of class<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_270"></a>. (It can be used for both instances of a class and class objects themselves.) <code>id</code> is defined as pointer to an object data structure:</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct objc_object {<span></span></pre></td></tr><tr><td scope="row"><pre>    Class isa;<span></span></pre></td></tr><tr><td scope="row"><pre>} *id;<span></span></pre></td></tr></table></div><p>All objects thus have an <code>isa</code> variable that tells them of what class they are an instance.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH11-SW26" title="Terminology"></a><p><strong>Terminology:</strong>&nbsp;Since the Class type is itself defined as a pointer:</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct objc_class *Class;<span></span></pre></td></tr></table></div>the <code>isa</code> variable is frequently referred to as the “<code>isa</code> pointer.”</p></div><p>Like a C function or an array, an object is therefore identified by its address. All objects, regardless of their instance variables or methods, are of type <code>id</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject;<span></span></pre></td></tr></table></div><p>For the object-oriented constructs of Objective-C, such as method<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_271"></a> return values, <code>id</code> replaces <code>int</code> as the default data type. (For strictly C constructs, such as function return values, <code>int</code> remains the default type.)</p><p>The keyword <code>nil</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_272"></a> is defined as a null object, an <code>id</code> with a value of <code>0</code>. <code>id</code>, <code>nil</code>, and the other basic types of Objective-C are defined in the header file <code>objc/objc.h</code>.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-115349" title="Dynamic Typing"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW4" title="Dynamic Typing"></a><h3>Dynamic Typing</h3><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_273"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_274"></a><p>The <code>id</code> type is completely nonrestrictive. By itself, it yields no information about an object, except that it is an object.</p><p>But objects aren’t all the same. A Rectangle won’t have the same methods or instance variables as an object that represents a bit-mapped image. At some point, a program needs to find more specific information about the objects it contains—what the object’s instance variables are, what methods it can perform, and so on. Since the <code>id</code> type designator can’t supply this information to the compiler, each object has to be able to supply it at runtime.</p><p>The <code>isa</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_275"></a> instance variable identifies the object’s <strong>class</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_276"></a>—what kind of object it is. Every Rectangle object would be able to tell the runtime system that it is a Rectangle. Every Circle can say that it is a Circle. Objects with the same behavior (methods) and the same kinds of data (instance variables) are members of the same class.</p><p>Objects are thus <strong>dynamically typed</strong> at runtime. Whenever it needs to, the runtime system can find the exact class that an object belongs to, just by asking the object. (To learn more about the runtime, see <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em>.) Dynamic typing in Objective-C serves as the foundation for dynamic binding, discussed later.</p><p>The <code>isa</code> variable also enables objects to perform <strong>introspection</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_277"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_278"></a>—to find out about themselves (or other objects). The compiler records information about class definitions in data structures for the runtime system to use. The functions of the runtime system use <code>isa</code>, to find this information at runtime. Using the runtime system, you can, for example, determine whether an object implements a particular method, or discover the name of its superclass.</p><p>Object classes are discussed in more detail under <span class="content_text"><a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-86329">“Classes.”</a></span></p><p>It’s also possible to give the compiler information about the class of an object by statically typing it in source code using the class name. Classes are particular kinds of objects, and the class name can serve as a type name. See <span class="content_text"><a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-86632">“Class Types”</a></span> and <span class="content_text"><a href="ocStaticBehavior.html#//apple_ref/doc/uid/TP30001163-CH16-SW1">“Enabling Static Behavior.”</a></span></p><a name="//apple_ref/doc/uid/TP30001163-CH11-142945" title="Memory Management"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW29" title="Memory Management"></a><h3>Memory Management</h3><p>In an Objective-C program, it is important to ensure that objects are deallocated when they are no longer needed—otherwise your application’s memory footprint becomes larger than necessary. It is also important to ensure that you do not deallocate objects while they’re still being used.</p><p>Objective-C 2.0 offers two environments for memory management that allow you to meet these goals: </p><ul class="spaceabove"><li class="li"><p><strong>Reference counting</strong>, where you are ultimately responsible for determining the lifetime of objects.</p><p>Reference counting is described in <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em>.</p></li><li class="li"><p><strong>Garbage collection</strong>, where you pass responsibility for determining the lifetime of objects to an automatic “collector.”</p><p>Garbage collection is described in <em><a href="../../GarbageCollection/index.html#//apple_ref/doc/uid/TP40002431" target="_top">Garbage Collection Programming Guide</a></em>. (Not available on iPhone—you cannot access this document through the iPhone Dev Center.)</p></li></ul><a name="//apple_ref/doc/uid/TP30001163-CH11-85945" title="Object Messaging"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW5" title="Object Messaging"></a><h2>Object Messaging</h2><p>This section explains the syntax of sending messages, including how you can nest message expressions. It also discusses the “visibility” of an object’s instance variables, and the concepts of polymorphism and dynamic binding.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW6" title="Message Syntax"></a><h3>Message Syntax</h3><p>To get an object to do something, you send it a <strong>message</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_279"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_280"></a> telling it to apply a method<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_281"></a>. In Objective-C, <strong>message expressions</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_282"></a> are enclosed in brackets:</p><div class="codesample"><table><tr><td scope="row"><pre>[receiver message]<span></span></pre></td></tr></table></div><p>The receiver<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_283"></a> is an object, and the message tells it what to do. In source code, the message is simply the name of a method and any arguments that are passed to it. When a message<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_284"></a> is sent, the runtime system selects the appropriate method from the receiver’s repertoire and invokes it.</p><p>For example, this message tells the <code>myRectangle</code> object to perform its <code>display</code> method, which causes the rectangle to display itself:</p><div class="codesample"><table><tr><td scope="row"><pre>[myRectangle display];<span></span></pre></td></tr></table></div><p>The message is followed by a “<code>;</code>” as is normal for any line of code in C.</p><p>The method name in a message serves to “select” a method implementation. For this reason, method names in messages are often referred to as <strong>selectors</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_285"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_286"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_287"></a>.</p><p>Methods<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_288"></a> can also take parameters, or “arguments.” A message with a single argument affixes a colon (<code>:</code>) to the selector name and puts the argument right after the colon. This construct is called a keyword; a keyword ends with a colon, and an argument follows the colon, as shown in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>[myRectangle setWidth:20.0];<span></span></pre></td></tr></table></div><p>A selector name includes all keywords, including colons, but does not include anything else, such as return type or parameter types. The imaginary message below tells the <code>myRectangle</code> object to set its origin to the coordinates (30.0, 50.0):</p><div class="codesample"><table><tr><td scope="row"><pre>[myRectangle setOrigin:30.0 :50.0]; // This is a bad example of multiple arguments<span></span></pre></td></tr></table></div><p>Since the colons are part of the method name, the method is named <code>setOrigin::</code>. It has two colons as it takes two arguments. This particular method does not interleave the method name with the arguments and, thus, the second argument is effectively unlabeled and it is difficult to determine the kind or purpose of the method’s arguments.</p><p>Instead, method names should interleave the name with the arguments such that the method's name naturally describes the arguments expected by the method. For example, the Rectangle class could instead implement a <code>setOriginX:y:</code> method  that makes the purpose of its two arguments clear:</p><div class="codesample"><table><tr><td scope="row"><pre>[myRectangle setOriginX: 30.0 y: 50.0]; // This is a good example of multiple arguments<span></span></pre></td></tr></table></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_3" title="Important:"></a><p><strong>Important:</strong>&nbsp;The sub-parts of the method name—of the selector—are not optional, nor can their order be varied. “Named arguments” and “keyword arguments” often carry the implication that the arguments to a method can vary at runtime, can have default values, can be in a different order, can possibly have additional named arguments. This is not the case with Objective-C.</p><p>For all intents and purposes, an Objective-C method declaration is simply a C function that prepends two additional arguments (see <span class="content_text"><a href="../../ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104" target="_top">Messaging</a></span> in the <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em>). This is different from the named or keyword arguments available in a language like Python:</p><p><div class="codesample"><table><tr><td scope="row"><pre>def func(a, b, NeatMode=SuperNeat, Thing=DefaultThing):<span></span></pre></td></tr><tr><td scope="row"><pre>    pass<span></span></pre></td></tr></table></div>where Thing (and NeatMode) might be omitted or might have different values when called.</p><p></p></div><p>Methods that take a variable number of arguments<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_289"></a> are also possible, though they’re somewhat rare. Extra arguments are separated by commas after the end of the method name. (Unlike colons, the commas aren’t considered part of the name.) In the following example, the imaginary <code>makeGroup:</code> method is passed one required argument (<strong>group</strong>) and three that are optional:</p><div class="codesample"><table><tr><td scope="row"><pre>[receiver makeGroup:group, memberOne, memberTwo, memberThree];<span></span></pre></td></tr></table></div><p>Like standard C functions, methods<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_290"></a> can return values. The following example sets the variable <code>isFilled</code> to <code>YES</code> if <code>myRectangle</code> is drawn as a solid rectangle, or <code>NO</code> if it’s drawn in outline form only.</p><div class="codesample"><table><tr><td scope="row"><pre>BOOL isFilled;<span></span></pre></td></tr><tr><td scope="row"><pre>isFilled = [myRectangle isFilled];<span></span></pre></td></tr></table></div><p>Note that a variable and a method can have the same name.</p><p>One message expression can be nested inside another. Here, the color of one rectangle is set to the color of another:</p><div class="codesample"><table><tr><td scope="row"><pre>[myRectangle setPrimaryColor:[otherRect primaryColor]];<span></span></pre></td></tr></table></div><p>Objective-C 2.0 also provides a dot (<code>.</code>) operator that offers a compact and convenient syntax for invoking an object’s accessor methods. This is typically used in conjunction with the declared properties feature (see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW1">“Declared Properties”</a></span>), and is described in <span class="content_text"><a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-SW17">“Dot Syntax.”</a></span></p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW7" title="Sending Messages to nil"></a><h3>Sending Messages to nil</h3><p>In Objective-C, it is valid to send a message to <code>nil</code>—it simply has no effect at runtime. There are several patterns in Cocoa that take advantage of this fact. The value returned from a message<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_291"></a> to <code>nil</code> may also be valid:</p><ul class="spaceabove"><li class="li"><p>If the method returns an object, then a message sent to <code>nil</code> returns <code>0</code> (<code>nil</code>), for example:</p><div class="codesample"><table><tr><td scope="row"><pre>Person *motherInLaw = [[aPerson spouse] mother];<span></span></pre></td></tr></table></div><p>If <code>aPerson</code>’s spouse is <code>nil</code>, then <code>mother</code> is sent to <code>nil</code> and the method returns <code>nil</code>.</p></li><li class="li"><p>If the method returns any pointer type, any integer scalar of size less than or equal to <code>sizeof(void*)</code>, a <code>float</code>, a <code>double</code>, a <code>long double</code>, or a <code>long long</code>, then a message sent to <code>nil</code> returns <code>0</code>.</p></li><li class="li"><p>If the method returns a struct, as defined by the <em><a href="../../../../DeveloperTools/Conceptual/LowLevelABI/index.html#//apple_ref/doc/uid/TP40002521" target="_top">Mac OS X ABI Function Call Guide</a></em> to be returned in registers, then a message sent to <code>nil</code> returns <code>0.0</code> for every field in the data structure. Other struct data types will not be filled with zeros. </p></li><li class="li"><p>If the method returns anything other than the aforementioned value types the return value of a message sent to <code>nil</code> is undefined.</p></li></ul><p>The following code fragment illustrates valid use of sending a message to <code>nil</code>. </p><div class="codesample"><table><tr><td scope="row"><pre>id anObjectMaybeNil = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// this is valid<span></span></pre></td></tr><tr><td scope="row"><pre>if ([anObjectMaybeNil methodThatReturnsADouble] == 0.0)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // implementation continues...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH11-SW12" title="Note"></a><p><strong>Note:</strong>&nbsp;The behavior of sending messages to nil changed slightly with Mac OS X v10.5.</p>On Mac OS  X v10.4 and earlier, a message to <code>nil</code> also is valid, as long as the message returns an object, any pointer type, <code>void</code>, or any integer scalar of size less than or equal to <code>sizeof(void*)</code>; if it does, a message sent to <code>nil</code> returns <code>nil</code>. If the message sent to <code>nil</code> returns anything other than the aforementioned value types (for example, if it returns any struct type, any floating-point type, or any vector type) the return value is undefined. You should therefore not rely on the return value of messages sent to <code>nil</code> unless the method’s return type is an object, any pointer type, or any integer scalar of size less than or equal to <code>sizeof(void*)</code>.</p></div><a name="//apple_ref/doc/uid/TP30001163-CH11-86167" title="The Receiver&acirc;&#128;&#153;s Instance Variables"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW8" title="The Receiver&acirc;&#128;&#153;s Instance Variables"></a><h3>The Receiver’s Instance Variables</h3><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_292"></a><p>A method has automatic access to the receiving object’s<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_293"></a> instance variables<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_294"></a>. You don’t need to pass them to the method as arguments. For example, the <code>primaryColor</code> method illustrated above takes no arguments, yet it can find the primary color for <code>otherRect</code> and return it. Every method assumes the receiver and its instance variables, without having to declare them as arguments.</p><p>This convention simplifies Objective-C source code. It also supports the way object-oriented programmers think about objects and messages. Messages are sent to receivers much as letters are delivered to your home. Message arguments bring information from the outside to the receiver; they don’t need to bring the receiver to itself.</p><p>A method has automatic access only to the receiver’s instance variables. If it requires information about a variable stored in another object, it must send a message to the object asking it to reveal the contents of the variable. The <code>primaryColor</code> and <code>isFilled</code> methods shown above are used for just this purpose.</p><p>See <span class="content_text"><a href="ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-SW1">“Defining a Class”</a></span> for more information on referring to instance variables.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86216" title="Polymorphism"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW9" title="Polymorphism"></a><h3>Polymorphism</h3><p>As the examples above illustrate, messages in Objective-C appear in the same syntactic positions as function calls in standard C. But, because methods “belong to” an object, messages behave differently than function calls.</p><p>In particular, an object can be operated on by only those methods that were defined for it. It can’t confuse them with methods defined for other kinds of object, even if another object has a method with the same name. This means that two objects can respond differently to the same message. For example, each kind of object sent a <code>display</code> message could display itself in a unique way. A Circle and a Rectangle would respond differently to identical instructions to track the cursor.</p><p>This feature, referred to as <strong>polymorphism</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_295"></a>, plays a significant role in the design of object-oriented programs. Together with dynamic binding, it permits you to write code that might apply to any number of different kinds of objects, without you having to choose at the time you write the code what kinds of objects they might be. They might even be objects that will be developed later, by other programmers working on other projects. If you write code that sends a <code>display</code> message to an <code>id</code> variable, any object that has a <code>display</code> method is a potential receiver.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86260" title="Dynamic Binding"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW10" title="Dynamic Binding"></a><h3>Dynamic Binding</h3><p><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_296"></a>A crucial difference between function calls and messages is that a function and its arguments are joined together in the compiled code, but a message and a receiving object aren’t united until the program is running and the message is sent. Therefore, the exact method that’s invoked to respond to a message can only be determined at runtime, not when the code is compiled.</p><p>The precise method<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_297"></a> that a message invokes depends on the receiver. Different receivers may have different method implementations for the same method name (polymorphism). For the compiler to find the right method implementation for a message, it would have to know what kind of object the receiver is—what class it belongs to. This is information the receiver is able to reveal at runtime when it receives a message (dynamic typing), but it’s not available from the type declarations found in source code.</p><p>The selection<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_298"></a> of a method implementation happens at runtime. When a message is sent, a runtime messaging routine looks at the receiver and at the method named in the message. It locates the receiver’s implementation of a method matching the name, “calls” the method, and passes it a pointer to the receiver’s instance variables. (For more on this routine, see <span class="content_text"><a href="../../ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104" target="_top">Messaging</a></span> in the <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em>.)</p><p>This <strong>dynamic binding</strong> of methods to messages works hand-in-hand with polymorphism to give object-oriented programming much of its flexibility and power. Since each object can have its own version of a method, a program can achieve a variety of results, not by varying the message itself, but by varying just the object that receives the message. This can be done as the program runs; receivers can be decided “on the fly” and can be made dependent on external factors such as user actions.</p><p>When executing code based upon the Application Kit, for example, users determine which objects receive messages from menu commands like Cut, Copy, and Paste. The message goes to whatever object controls the current selection. An object that displays text would react to a <code>copy</code> message differently from an object that displays scanned images. An object that represents a set of shapes would respond differently from a Rectangle. Since messages don’t select methods (methods aren’t bound to messages) until runtime, these differences are isolated in the methods that respond to the message. The code that sends the message doesn’t have to be concerned with them; it doesn’t even have to enumerate the possibilities. Each application can invent its own objects that respond in their own way to <code>copy</code> messages.</p><p>Objective-C takes dynamic binding one step further and allows even the message that’s sent (the method selector) to be a variable<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_299"></a> that’s determined at runtime. This is discussed in the section <span class="content_text"><a href="../../ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104" target="_top">Messaging</a></span> in the <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW30" title="Dynamic Method Resolution"></a><h3>Dynamic Method Resolution</h3><p>You can provide implementations of class and instance methods at runtime using dynamic method resolution. See <span class="content_text"><a href="../../ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102" target="_top">Dynamic Method Resolution</a></span><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_300"></a> in the <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em> for more details.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW17" title="Dot Syntax"></a><h3>Dot Syntax</h3><p>Objective-C provides a dot (<code>.</code>) operator that offers a compact and convenient syntax you can use as an alternative to square bracket notation (<code>[]</code>s) to invoke accessor methods. It is particularly useful when you want to access or modify a property that is a property of another object (that is a property of another object, and so on). </p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW18" title="Using the Dot Syntax"></a><h4>Using the Dot Syntax</h4><a name="//apple_ref/doc/uid/TP30001163-CH11-SW19" title="Overview"></a><h5>Overview</h5><p>You can use the <strong>dot syntax</strong> to invoke accessor methods using the same pattern as accessing structure elements as illustrated in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>myInstance.value = 10;<span></span></pre></td></tr><tr><td scope="row"><pre>printf("myInstance value: %d", myInstance.value);<span></span></pre></td></tr></table></div><p>The dot syntax is purely “syntactic sugar”—it is transformed by the compiler into invocation of accessor methods (so you are not actually accessing an instance variable directly). The code example above is exactly equivalent to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>[myInstance setValue:10];<span></span></pre></td></tr><tr><td scope="row"><pre>printf("myInstance value: %d", [myInstance value]);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH11-SW20" title="General Use"></a><h5>General Use</h5><p>You can read and write properties using the dot (<code>.</code>) operator, as illustrated in the following example.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW21" title="Listing 1-1Accessing properties using the dot syntax"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>Accessing properties using the dot syntax</p><div class="codesample"><table><tr><td scope="row"><pre>Graphic *graphic = [[Graphic alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSColor *color = graphic.color;<span></span></pre></td></tr><tr><td scope="row"><pre>CGFloat xLoc = graphic.xLoc;<span></span></pre></td></tr><tr><td scope="row"><pre>BOOL hidden = graphic.hidden;<span></span></pre></td></tr><tr><td scope="row"><pre>int textCharacterLength = graphic.text.length;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (graphic.textHidden != YES) {<span></span></pre></td></tr><tr><td scope="row"><pre>    graphic.text = @"Hello";<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>graphic.bounds = NSMakeRect(10.0, 10.0, 20.0, 120.0);<span></span></pre></td></tr></table></div><p>(<code>@"Hello"</code> is a constant <code>NSString</code> object—see <span class="content_text"><a href="ocLanguageSummary.html#//apple_ref/doc/uid/TP30001163-CH3-149737">“Compiler Directives.”</a></span>)</p><p>Accessing a property <em>property</em> calls the get method associated with the property (by default, <em>property</em>) and setting it calls the set method associated with the property (by default, <code>set</code><em>Property</em><code>:</code>). You can change the methods that are invoked by using the Declared Properties feature (see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW1">“Declared Properties”</a></span>). Despite appearances to the contrary, the dot syntax therefore preserves encapsulation—you are not accessing an instance variable directly. </p><p>The following statements compile to exactly the same code as the statements shown in <span class="content_text"><a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-SW21">Listing 1-1</a></span>, but use square bracket syntax:</p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW22" title="Listing 1-2Accessing properties using bracket syntax"></a><p class="codesample"><strong>Listing 1-2&nbsp;&nbsp;</strong>Accessing properties using bracket syntax</p><div class="codesample"><table><tr><td scope="row"><pre>Graphic *graphic = [[Graphic alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSColor *color = [graphic color];<span></span></pre></td></tr><tr><td scope="row"><pre>CGFloat xLoc = [graphic xLoc];<span></span></pre></td></tr><tr><td scope="row"><pre>BOOL hidden = [graphic hidden];<span></span></pre></td></tr><tr><td scope="row"><pre>int textCharacterLength = [[graphic text] length];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ([graphic isTextHidden] != YES) {<span></span></pre></td></tr><tr><td scope="row"><pre>    [graphic setText:@"Hello"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>[graphic setBounds:NSMakeRect(10.0, 10.0, 20.0, 120.0)];<span></span></pre></td></tr></table></div><p>An advantage of the dot syntax is that the compiler can signal an error when it detects a write to a read-only property, whereas at best it can only generate an undeclared method warning that you invoked a non-existent <code>set</code><em>Property</em><code>:</code> method, which will fail at runtime. </p><p>For properties of the appropriate C language type, the meaning of compound assignments is well-defined. For example, you could update the length property of an instance of <code>NSMutableData</code> using compound assignments:</p><div class="codesample"><table><tr><td scope="row"><pre>NSMutableData *data = [NSMutableData dataWithLength:1024];<span></span></pre></td></tr><tr><td scope="row"><pre>data.length += 1024;<span></span></pre></td></tr><tr><td scope="row"><pre>data.length *= 2;<span></span></pre></td></tr><tr><td scope="row"><pre>data.length /= 4;<span></span></pre></td></tr></table></div><p>which is equivalent to:</p><div class="codesample"><table><tr><td scope="row"><pre>[data setLength:[data length] + 1024];<span></span></pre></td></tr><tr><td scope="row"><pre>[data setLength:[data length] * 2];<span></span></pre></td></tr><tr><td scope="row"><pre>[data setLength:[data length] / 4];<span></span></pre></td></tr></table></div><p>There is one case where properties cannot be used. Consider the following code fragment:</p><div class="codesample"><table><tr><td scope="row"><pre>id y;<span></span></pre></td></tr><tr><td scope="row"><pre>x = y.z;  // z is an undeclared property<span></span></pre></td></tr></table></div><p>Note that <code>y</code> is untyped and the <code>z</code> property is undeclared. There are several ways in which this could be interpreted. Since this is ambiguous, the statement is treated as an undeclared property error. If <code>z</code> is declared, then it is not ambiguous if there's only one declaration of a <code>z</code> property in the current compilation unit. If there are multiple declarations of a <code>z</code> property, as long as they all have the same type (such as <code>BOOL</code>) then it is legal. One source of ambiguity would also arise from one of them being declared <code>readonly</code>.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW23" title="nil Values"></a><h5>nil Values</h5><p>If a <code>nil</code> value is encountered during property traversal, the result is the same as sending the equivalent message to <code>nil</code>. For example, the following pairs are all equivalent:</p><div class="codesample"><table><tr><td scope="row"><pre>// each member of the path is an object<span></span></pre></td></tr><tr><td scope="row"><pre>x = person.address.street.name;<span></span></pre></td></tr><tr><td scope="row"><pre>x = [[[person address] street] name];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// the path contains a C struct<span></span></pre></td></tr><tr><td scope="row"><pre>// will crash if window is nil or -contentView returns nil<span></span></pre></td></tr><tr><td scope="row"><pre>y = window.contentView.bounds.origin.y;<span></span></pre></td></tr><tr><td scope="row"><pre>y = [[window contentView] bounds].origin.y;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// an example of using a setter....<span></span></pre></td></tr><tr><td scope="row"><pre>person.address.street.name = @"Oxford Road";<span></span></pre></td></tr><tr><td scope="row"><pre>[[[person address] street] setName: @"Oxford Road"];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH11-SW24" title="self"></a><h5>self</h5><p>If you want to access a property of <code>self</code> using accessor methods, you must explicitly call out <code>self</code> as illustrated in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>self.age = 10;<span></span></pre></td></tr></table></div><p>If you do not use <code>self.</code>, you access the instance variable directly. In the following example, the set accessor method for the <code>age</code> property is <em>not</em> invoked: </p><div class="codesample"><table><tr><td scope="row"><pre>age = 10;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH11-SW25" title="Performance and Threading"></a><h5>Performance and Threading</h5><p>The dot syntax generates code equivalent to the standard method invocation syntax. As a result, code using the dot syntax performs exactly the same as code written directly using the accessor methods. Since the dot syntax simply invokes methods, no additional thread dependencies are introduced as a result of its use.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW27" title="Usage Summary"></a><h4>Usage Summary</h4><div class="codesample"><table><tr><td scope="row"><pre>aVariable = anObject.aProperty;<span></span></pre></td></tr></table></div><p>Invokes the <code>aProperty</code> method and assigns the return value to <code>aVariable</code>. The type of the property <code>aProperty</code> and the type of <code>aVariable</code> must be compatible, otherwise you get a compiler warning.</p><div class="codesample"><table><tr><td scope="row"><pre>anObject.name = @"New Name";<span></span></pre></td></tr></table></div><p>Invokes the <code>setName</code>: method on <code>anObject</code>, passing <code>@"New Name"</code> as the argument.</p><p>You get a compiler warning if <code>setName</code>: does not exist, if the property <code>name</code> does not exist, or if <code>setName:</code> returns anything but <code>void</code>. </p><div class="codesample"><table><tr><td scope="row"><pre>xOrigin = aView.bounds.origin.x;<span></span></pre></td></tr></table></div><p>Invokes the <code>bounds</code> method and assigns <code>xOrigin</code> to be the value of the <code>origin.x</code> structure element of the <code>NSRect</code> returned by <code>bounds</code>. </p><div class="codesample"><table><tr><td scope="row"><pre>NSInteger i = 10;<span></span></pre></td></tr><tr><td scope="row"><pre>anObject.integerProperty = anotherObject.floatProperty = ++i;<span></span></pre></td></tr></table></div><p>Assigns <code>11</code> to both <code>anObject.integerProperty</code> and <code>anotherObject.floatProperty</code>. That is, the right hand side of the assignment is pre-evaluated and the result is passed to <code>setIntegerProperty:</code> and <code>setFloatProperty:</code>. The pre-evaluated result is coerced as required at each point of assignment. </p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW28" title="Incorrect Use"></a><h4>Incorrect Use</h4><p>The following patterns are strongly discouraged.</p><div class="codesample"><table><tr><td scope="row"><pre>anObject.retain;<span></span></pre></td></tr></table></div><p>Generates a compiler warning (<code>warning: value returned from property not used.</code>).</p><div class="codesample"><table><tr><td scope="row"><pre>/* method declaration */<span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL) setFooIfYouCan: (MyClass *)newFoo;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* code fragment */<span></span></pre></td></tr><tr><td scope="row"><pre>anObject.fooIfYouCan = myInstance;<span></span></pre></td></tr></table></div><p>Generates a compiler warning that <code>setFooIfYouCan:</code> does not appear to be a setter method because it does not return <code>(void)</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>flag = aView.lockFocusIfCanDraw;<span></span></pre></td></tr></table></div><p>Invokes <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/lockFocusIfCanDraw" target="_top">lockFocusIfCanDraw</a></code> and assigns the return value to <code>flag</code>. This does not generate a compiler warning unless <code>flag</code>’s type mismatches the method’s return type. </p><div class="codesample"><table><tr><td scope="row"><pre>/* property declaration */<span></span></pre></td></tr><tr><td scope="row"><pre>@property(readonly) NSInteger readonlyProperty;<span></span></pre></td></tr><tr><td scope="row"><pre>/* method declaration */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void) setReadonlyProperty: (NSInteger)newValue;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* code fragment */<span></span></pre></td></tr><tr><td scope="row"><pre>self.readonlyProperty = 5;<span></span></pre></td></tr></table></div><p>Since the property is declared <code>readonly</code>, this code generates a compiler warning (<code>warning: assignment to readonly property 'readonlyProperty'</code>). Because the setter method is present, it will work at runtime, but simply adding a setter for a property does not imply <code>readwrite</code>.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86329" title="Classes"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-BAJCDADF" title="Classes"></a><h2>Classes</h2><p><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_301"></a>An object-oriented program is typically built from a variety of objects. A program based on the Cocoa frameworks might use <code>NSMatrix</code> objects, <code>NSWindow</code> objects, <code>NSDictionary</code> objects, <code>NSFont</code> objects, <code>NSText</code> objects, and many others. Programs often use more than one object of the same kind or class—several <code>NSArray</code> objects or <code>NSWindow</code> objects, for example.</p><p>In Objective-C, you define objects by defining their class. The class definition is a prototype for a kind of object; it declares the instance variables that become part of every member of the class, and it defines a set of methods that all objects in the class can use.</p><p>The compiler creates just one accessible object for each class, a <strong>class object</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_302"></a> that knows how to build new objects belonging to the class. (For this reason it’s traditionally called a “factory object.”) The class object is the compiled version of the class<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_303"></a>; the objects it builds are <strong>instances</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_304"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_305"></a> of the class<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_306"></a>. The objects that do the main work of your program are instances created by the class object at runtime.</p><p>All instances of a class have the same set of methods, and they all have a set of instance variables cut from the same mold. Each object gets its own instance variables, but the methods are shared.</p><p>By convention, class names begin with an uppercase letter (such as “Rectangle”); the names of instances typically begin with a lowercase letter (such as “myRectangle”).</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86370" title="Inheritance"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-BAJCCBHC" title="Inheritance"></a><h3>Inheritance</h3><p><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_307"></a>Class definitions are additive; each new class that you define is based on another class<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_308"></a> from which it <strong>inherits</strong> methods and instance variables. The new class simply adds to or modifies what it inherits. It doesn’t need to duplicate inherited code.</p><p>Inheritance links all classes together in a hierarchical tree with a single class at its root<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_309"></a>. When writing code that is based upon the Foundation framework, that root class is typically <code>NSObject</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_310"></a>. Every class (except a root class) has a <strong>superclass</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_311"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_312"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_313"></a> one step nearer the root, and any class (including a root class) can be the superclass for any number of <strong>subclasses</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_314"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_315"></a> one step farther from the root. <span class="content_text">Figure 1-1</span> illustrates the hierarchy for a few of the classes used in the drawing program.</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH11-86405" title="Figure 1-1Some Drawing Program Classes"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-CJBCADJA" title="Figure 1-1Some Drawing Program Classes"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Some Drawing Program Classes</p><img src = "../Art/graphichierarchy.gif" alt = "" width="334" height="184"></div><br/><p>This figure shows that the Square class is a subclass of the Rectangle class, the Rectangle class is a subclass of Shape, Shape is a subclass of Graphic, and Graphic is a subclass of <code>NSObject</code>. Inheritance is cumulative. So a Square object has the methods and instance variables defined for Rectangle, Shape, Graphic, and <code>NSObject</code>, as well as those defined specifically for Square. This is simply to say that a Square object isn’t only a Square, it’s also a Rectangle, a Shape, a Graphic, and an <code>NSObject</code>.</p><p>Every class but <code>NSObject</code> can thus be seen as a specialization<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_316"></a> or an adaptation<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_317"></a> of another class. Each successive subclass further modifies the cumulative total of what’s inherited. The Square class defines only the minimum needed to turn a Rectangle into a Square.</p><p>When you define a class, you link it to the hierarchy by declaring its superclass; every class you create must be the subclass of another class (unless you define a new root class). Plenty of potential superclasses are available. Cocoa includes the <code>NSObject</code> class and several frameworks containing definitions for more than 250 additional classes. Some are classes that you can use “off the shelf”—incorporate into your program as is. Others you might want to adapt to your own needs by defining a subclass.</p><p>Some framework classes define almost everything you need, but leave some specifics to be implemented in a subclass. You can thus create very sophisticated objects by writing only a small amount of code, and reusing work done by the programmers of the framework.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86438" title="The NSObject Class"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-SW11" title="The NSObject Class"></a><h4>The NSObject Class</h4><p><code>NSObject</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_318"></a> is a root<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_319"></a> class, and so doesn’t have a superclass. It defines the basic framework for Objective-C objects and object interactions. It imparts to the classes and instances of classes that inherit from it the ability to behave as objects and cooperate with the runtime system.</p><p>A class that doesn’t need to inherit any special behavior from another class should nevertheless be made a subclass of the <code>NSObject</code> class. Instances of the class must at least have the ability to behave like Objective-C objects at runtime. Inheriting this ability from the <code>NSObject</code> class is much simpler and much more reliable than reinventing it in a new class definition.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH11-SW13" title="Note"></a><p><strong>Note:</strong>&nbsp;Implementing a new root class is a delicate task and one with many hidden hazards. The class must duplicate much of what the <code>NSObject</code> class does, such as allocate instances, connect them to their class, and identify them to the runtime system. For this reason, you should generally use the <code>NSObject</code> class provided with Cocoa as the root class. For more information, see the Foundation framework documentation for the <code>NSObject</code> class and the <code>NSObject</code> protocol.</p></div><a name="//apple_ref/doc/uid/TP30001163-CH11-86471" title="Inheriting Instance Variables"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF109" title="Inheriting Instance Variables"></a><h4>Inheriting Instance Variables</h4><p><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_320"></a>When a class object creates a new instance, the new object contains not only the instance variables that were defined for its class but also the instance variables defined for its superclass and for its superclass’s superclass, all the way back to the root class. Thus, the <code>isa</code> instance variable defined in the <code>NSObject</code> class becomes part of every object. <code>isa</code> connects each object to its class.</p><p><span class="content_text">Figure 1-2</span> shows some of the instance variables that could be defined for a particular implementation of Rectangle, and where they may come from. Note that the variables that make the object a Rectangle are added to the ones that make it a Shape, and the ones that make it a Shape are added to the ones that make it a Graphic, and so on.</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH11-86501" title="Figure 1-2Rectangle Instance Variables"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-CJBEBJFD" title="Figure 1-2Rectangle Instance Variables"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Rectangle Instance Variables</p><img src = "../Art/graphicinstvars.gif" alt = "" width="288" height="149"></div><br/><p>A class doesn’t have to declare instance variables<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_321"></a>. It can simply define new methods and rely on the instance variables it inherits, if it needs any instance variables at all. For example, Square might not declare any new instance variables of its own.<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_322"></a></p><a name="//apple_ref/doc/uid/TP30001163-CH11-86520" title="Inheriting Methods"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF110" title="Inheriting Methods"></a><h4>Inheriting Methods</h4><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_323"></a><p>An object<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_324"></a> has access not only to the methods defined for its class<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_325"></a>, but also to methods defined for its superclass, and for its superclass’s superclass, all the way back to the root of the hierarchy. For instance, a Square object can use methods defined in the Rectangle, Shape, Graphic, and <code>NSObject</code> classes as well as methods defined in its own class.</p><p>Any new class you define in your program can therefore make use of the code written for all the classes above it in the hierarchy. This type of inheritance is a major benefit of object-oriented programming. When you use one of the object-oriented frameworks provided by Cocoa, your programs can take advantage of the basic functionality coded into the framework classes. You have to add only the code that customizes the standard functionality to your application.</p><p>Class objects also inherit from the classes above them in the hierarchy. But because they don’t have instance variables (only instances do), they inherit only methods.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86544" title="Overriding One Method With Another"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF111" title="Overriding One Method With Another"></a><h4>Overriding One Method With Another</h4><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_326"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_327"></a><p>There’s one useful exception to inheritance: When you define a new class, you can implement a new method with the same name as one defined in a class farther up the hierarchy. The new method overrides the original; instances of the new class perform it rather than the original, and subclasses of the new class inherit it rather than the original.</p><p>For example, Graphic defines a <code>display</code> method that Rectangle overrides by defining its own version of <code>display</code>. The Graphic method is available to all kinds of objects that inherit from the Graphic class—but not to Rectangle objects, which instead perform the Rectangle version of <code>display</code>.</p><p>Although overriding a method blocks the original version from being inherited, other methods defined in the new class can skip over the redefined method and find the original (see <span class="content_text"><a href="ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-89660">“Messages to self and super”</a></span> to learn how).</p><p>A redefined method can also incorporate the very method it overrides. When it does, the new method serves only to refine or modify the method it overrides, rather than replace it outright. When several classes in the hierarchy define the same method, but each new version incorporates the version it overrides, the implementation of the method is effectively spread over all the classes.</p><p>Although a subclass can override inherited methods, it can’t override inherited instance variables. Since an object has memory allocated for every instance variable it inherits, you can’t override an inherited variable by declaring a new one with the same name. If you try, the compiler will complain.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86594" title="Abstract Classes"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF112" title="Abstract Classes"></a><h4>Abstract Classes</h4><p><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_328"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_329"></a>Some classes are designed only or primarily so that other classes can inherit from them. These <strong>abstract classes</strong> group methods and instance variables that can be used by a number of different subclasses into a common definition. The abstract class is typically incomplete by itself, but contains useful code that reduces the implementation burden of its subclasses. (Because abstract classes must have subclasses to be useful, they’re sometimes also called <strong>abstract superclasses</strong>.)<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_330"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_331"></a></p><p>Unlike some other languages, Objective-C does not have syntax to mark classes as abstract, nor does it prevent you from creating an instance of an abstract class.</p><p>The <code>NSObject</code> class is the canonical example of an abstract class in Cocoa. You never use instances of the <code>NSObject</code> class in an application—it wouldn’t be good for anything; it would be a generic object with the ability to do nothing in particular.</p><p>The <code>NSView</code> class, on the other hand, provides an example of an abstract class instances of which you might occasionally use directly. </p><p>Abstract classes often contain code that helps define the structure of an application. When you create subclasses of these classes, instances of your new classes fit effortlessly into the application structure and work automatically with other objects.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86632" title="Class Types"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-BAJCEHGF" title="Class Types"></a><h3>Class Types</h3><p>A class definition is a specification for a kind of object. The class, in effect, defines a data type. The type is based not just on the data structure the class defines (instance variables), but also on the behavior included in the definition (methods).</p><p>A class name can appear in source code wherever a type specifier is permitted in C—for example, as an argument to the <code>sizeof</code> operator:</p><div class="codesample"><table><tr><td scope="row"><pre>int i = sizeof(Rectangle);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH11-86668" title="Static Typing"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF113" title="Static Typing"></a><h4>Static Typing</h4><p>You can use a class name in place of <code>id</code> to designate an object’s type:</p><div class="codesample"><table><tr><td scope="row"><pre>Rectangle *myRectangle;<span></span></pre></td></tr></table></div><p>Because this way of declaring an object type gives the compiler information about the kind of object it is, it’s known as <strong>static typing</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_332"></a>. Just as <code>id</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_333"></a> is actually a pointer, objects are statically typed as pointers to a class. Objects are always typed by a pointer. Static typing makes the pointer explicit; <code>id</code> hides it.</p><p>Static typing permits the compiler to do some type checking—for example, to warn if an object could receive a message that it appears not to be able to respond to—and to loosen some restrictions that apply to objects generically typed <code>id</code>. In addition, it can make your intentions clearer to others who read your source code. However, it doesn’t defeat dynamic binding or alter the dynamic determination of a receiver’s class at runtime.</p><p>An object can be statically typed to its own class or to any class that it inherits from. For example, since inheritance makes a Rectangle a kind of Graphic, a Rectangle instance could be statically typed to the Graphic class:</p><div class="codesample"><table><tr><td scope="row"><pre>Graphic *myRectangle;<span></span></pre></td></tr></table></div><p>This is possible because a Rectangle is a Graphic. It’s more than a Graphic since it also has the instance variables and method capabilities of a Shape and a Rectangle, but it’s a Graphic nonetheless. For purposes of type checking, the compiler considers <code>myRectangle</code> to be a Graphic, but at runtime it’s treated as a Rectangle.</p><p>See <span class="content_text"><a href="ocStaticBehavior.html#//apple_ref/doc/uid/TP30001163-CH16-SW1">“Enabling Static Behavior”</a></span> for more on static typing and its benefits.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86761" title="Type Introspection"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF114" title="Type Introspection"></a><h4>Type Introspection</h4><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_334"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_335"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_336"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_337"></a><p>Instances can reveal their types at runtime. The <code>isMemberOfClass:</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_338"></a> method, defined in the <code>NSObject</code> class, checks whether the receiver is an instance of a particular class:</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anObject isMemberOfClass:someClass] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>The <code>isKindOfClass:</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_339"></a> method, also defined in the <code>NSObject</code> class, checks more generally whether the receiver inherits from or is a member of a particular class (whether it has the class in its inheritance path):</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anObject isKindOfClass:someClass] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>The set of classes for which <code>isKindOfClass:</code> returns <code>YES</code> is the same set to which the receiver can be statically typed.</p><p>Introspection isn’t limited to type information. Later sections of this chapter discuss methods that return the class object, report whether an object can respond to a message, and reveal other information.</p><p>See the <code>NSObject</code> class specification in the Foundation framework reference for more on <code>isKindOfClass:</code>, <code>isMemberOfClass:</code>, and related methods.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-86856" title="Class Objects"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF115" title="Class Objects"></a><h3>Class Objects</h3><p><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_340"></a>A class definition contains various kinds of information, much of it about instances of the class:</p><ul class="spaceabove"><li class="li"><p>The name of the class and its superclass</p></li><li class="li"><p>A template describing a set of instance variables</p></li><li class="li"><p>The declarations of method names and their return and argument types</p></li><li class="li"><p>The method implementations</p></li></ul><p>This information is compiled and recorded in data structures made available to the runtime system. The compiler creates just one object, a <strong>class object</strong>, to represent the class. The class object has access to all the information about the class, which means mainly information about what instances of the class are like. It’s able to produce new instances according to the plan put forward in the class definition.</p><p>Although a class object keeps the prototype of a class instance, it’s not an instance itself. It has no instance variables of its own and it can’t perform methods intended for instances of the class. However, a class definition can include methods intended specifically for the class object—<strong>class methods</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_341"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_342"></a> as opposed to <strong>instance methods</strong><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_343"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_344"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_345"></a>. A class object inherits class methods from the classes above it in the hierarchy, just as instances inherit instance methods.</p><p>In source code, the class object is represented by the class name. In the following example, the Rectangle class returns the class version number using a method inherited from the <code>NSObject</code> class:</p><div class="codesample"><table><tr><td scope="row"><pre>int versionNumber = [Rectangle version];<span></span></pre></td></tr></table></div><p>However, the class name stands for the class object only as the receiver in a message expression. Elsewhere, you need to ask an instance or the class to return the class <code>id</code>. Both respond to a <code>class</code> message:</p><div class="codesample"><table><tr><td scope="row"><pre>id aClass = [anObject class];<span></span></pre></td></tr><tr><td scope="row"><pre>id rectClass = [Rectangle class];<span></span></pre></td></tr></table></div><p>As these examples show, class objects can, like all other objects, be typed <code>id</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_346"></a>. But class objects can also be more specifically typed to the Class data type<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_347"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>Class aClass = [anObject class];<span></span></pre></td></tr><tr><td scope="row"><pre>Class rectClass = [Rectangle class];<span></span></pre></td></tr></table></div><p>All class objects are of type Class. Using this type name for a class is equivalent to using the class name to statically type an instance.</p><p>Class objects are thus full-fledged objects that can be dynamically typed, receive messages, and inherit methods from other classes. They’re special only in that they’re created by the compiler, lack data structures (instance variables) of their own other than those built from the class definition, and are the agents for producing instances at runtime.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH11-SW14" title="Note"></a><p><strong>Note:</strong>&nbsp;The compiler also builds a “metaclass object<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_348"></a>” for each class. It describes the class object just as the class object describes instances of the class. But while you can send messages to instances and to the class object, the metaclass object is used only internally by the runtime system.</p></div><a name="//apple_ref/doc/uid/TP30001163-CH11-87015" title="Creating Instances"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF116" title="Creating Instances"></a><h4>Creating Instances</h4><p>A principal function of a class object is to create new instances<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_349"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_350"></a>. This code tells the Rectangle class to create a new Rectangle instance and assign it to the <code>myRectangle</code> variable:</p><div class="codesample"><table><tr><td scope="row"><pre>id  myRectangle;<span></span></pre></td></tr><tr><td scope="row"><pre>myRectangle = [Rectangle alloc];<span></span></pre></td></tr></table></div><p>The <code>alloc</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_351"></a> method dynamically allocates memory for the new object’s instance variables and initializes them all to <code>0</code>—all, that is, except the <code>isa</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_352"></a> variable that connects the new instance<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_353"></a> to its class. For an object to be useful, it generally needs to be more completely initialized. That’s the function of an <code>init</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_354"></a> method. Initialization<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_355"></a> typically follows immediately after allocation:</p><div class="codesample"><table><tr><td scope="row"><pre>myRectangle = [[Rectangle alloc] init];<span></span></pre></td></tr></table></div><p>This line of code, or one like it, would be necessary before <code>myRectangle</code> could receive any of the messages that were illustrated in previous examples in this chapter. The <code>alloc</code> method returns a new instance and that instance performs an <code>init</code> method to set its initial state. Every class object has at least one method (like <code>alloc</code>) that enables it to produce new objects, and every instance has at least one method (like <code>init</code>) that prepares it for use. Initialization methods often take arguments to allow particular values to be passed and have keywords to label the arguments (<code>initWithPosition:size:</code>, for example, is a method that might initialize a new Rectangle instance), but they all begin with “init”.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-87110" title="Customization With Class Objects"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF117" title="Customization With Class Objects"></a><h4>Customization With Class Objects</h4><p><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_356"></a>It’s not just a whim of the Objective-C language that classes are treated as objects. It’s a choice that has intended, and sometimes surprising, benefits for design. It’s possible, for example, to customize an object with a class, where the class belongs to an open-ended set. In the Application Kit, for example, an <code>NSMatrix</code> object can be customized<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_357"></a> with a particular kind of <code>NSCell</code> object.</p><p>An <code>NSMatrix</code> object can take responsibility for creating the individual objects that represent its cells. It can do this when the matrix is first initialized and later when new cells are needed. The visible matrix that an <code>NSMatrix</code> object draws on the screen can grow and shrink at runtime, perhaps in response to user actions. When it grows, the matrix needs to be able to produce new objects to fill the new slots that are added.</p><p>But what kind of objects should they be? Each matrix displays just one kind of <code>NSCell</code>, but there are many different kinds. The inheritance hierarchy in <span class="content_text">Figure 1-3</span> shows some of those provided by the Application Kit. All inherit from the generic <code>NSCell</code> class:</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH11-87137" title="Figure 1-3Inheritance hierarchy for NSCell"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-CJBBDEEH" title="Figure 1-3Inheritance hierarchy for NSCell"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Inheritance hierarchy for NSCell</p><img src = "../Art/cellhierarchy.gif" alt = "" width="418" height="152"></div><br/><p>When a matrix creates <code>NSCell</code> objects, should they be <code>NSButtonCell</code> objects to display a bank of buttons or switches, <code>NSTextFieldCell</code> objects to display fields where the user can enter and edit text, or some other kind of <code>NSCell</code>? The <code>NSMatrix</code> object must allow for any kind of cell, even types that haven’t been invented yet.</p><p>One solution to this problem is to define the <code>NSMatrix</code> class as an abstract class and require everyone who uses it to declare a subclass and implement the methods that produce new cells. Because they would be implementing the methods, users of the class could be sure that the objects they created were of the right type.</p><p>But this requires others to do work that ought to be done in the <code>NSMatrix</code> class, and it unnecessarily proliferates the number of classes. Since an application might need more than one kind of <code>NSMatrix</code>, each with a different kind of <code>NSCell</code>, it could become cluttered with <code>NSMatrix</code> subclasses. Every time you invented a new kind of <code>NSCell</code>, you’d also have to define a new kind of <code>NSMatrix</code>. Moreover, programmers on different projects would be writing virtually identical code to do the same job, all to make up for <code>NSMatrix</code>'s failure to do it.</p><p>A better solution, the solution the <code>NSMatrix</code> class actually adopts, is to allow <code>NSMatrix</code> instances to be initialized with a kind of <code>NSCell</code>—with a class object. It defines a <code>setCellClass:</code> method that passes the class object for the kind of <code>NSCell</code> object an <code>NSMatrix</code> should use to fill empty slots:</p><div class="codesample"><table><tr><td scope="row"><pre>[myMatrix setCellClass:[NSButtonCell class]];<span></span></pre></td></tr></table></div><p>The <code>NSMatrix</code> object uses the class object to produce new cells when it’s first initialized and whenever it’s resized to contain more cells. This kind of customization would be difficult if classes weren’t objects that could be passed in messages and assigned to variables.<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_358"></a></p><a name="//apple_ref/doc/uid/TP30001163-CH11-87193" title="Variables and Class Objects"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF118" title="Variables and Class Objects"></a><h4>Variables and Class Objects</h4><p>When you define a new class, you can specify instance variables. Every instance of the class can maintain its own copy of the variables you declare—each object controls its own data. There is, however, no “class variable”<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_359"></a> counterpart to an instance variable. Only internal data structures, initialized from the class definition, are provided for the class. Moreover, a class object has no access to the instance variables of any instances; it can’t initialize, read, or alter them.</p><p>For all the instances of a class to share data, you must define an external variable of some sort. The simplest way to do this is to declare a variable in the class implementation file as illustrated in the following code fragment.</p><div class="codesample"><table><tr><td scope="row"><pre>int MCLSGlobalVariable;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre>// implementation continues<span></span></pre></td></tr></table></div><p>In a more sophisticated implementation, you can declare a variable to be <code>static</code>, and provide class methods<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_360"></a> to manage it. Declaring a variable <code>static</code> limits its scope to just the class—and to just the part of the class that’s implemented in the file. (Thus unlike instance variables, static variables cannot be inherited by, or directly manipulated by, subclasses.) This pattern is commonly used to define shared instances of a class (such as singletons, see <span class="content_text"><a href="../../CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW32" target="_top">“Creating a Singleton Instance”</a></span> in <em><a href="../../CocoaFundamentals/index.html#//apple_ref/doc/uid/TP40002974" target="_top">Cocoa Fundamentals Guide</a></em>).</p><div class="codesample"><table><tr><td scope="row"><pre>static MyClass *MCLSSharedInstance;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ (MyClass *)sharedInstance<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // check for existence of shared instance<span></span></pre></td></tr><tr><td scope="row"><pre>    // create if necessary<span></span></pre></td></tr><tr><td scope="row"><pre>    return MCLSSharedInstance;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>// implementation continues<span></span></pre></td></tr></table></div><p>Static variables help give the class object more functionality than just that of a “factory” producing instances; it can approach being a complete and versatile object in its own right. A class object can be used to coordinate the instances it creates, dispense instances from lists of objects already created, or manage other processes essential to the application. In the case when you need only one object of a particular class, you can put all the object’s state into static variables and use only class methods. This saves the step of allocating and initializing an instance.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH11-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;It is also possible to use external variables that are not declared <code>static</code>, but the limited scope of static variables better serves the purpose of encapsulating data into separate objects.</p></div><a name="//apple_ref/doc/uid/TP30001163-CH11-87244" title="Initializing a Class Object"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF119" title="Initializing a Class Object"></a><h4>Initializing a Class Object</h4><p>If you want to use a class object<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_361"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_362"></a> for anything besides allocating instances, you may need to initialize it just as you would an instance. Although programs don’t allocate class objects, Objective-C does provide a way for programs to initialize them.</p><p>If a class makes use of static or global variables, the <code>initialize</code> method is a good place to set their initial values. For example, if a class maintains an array of instances, the <code>initialize</code> method could set up the array and even allocate one or two default instances to have them ready.</p><p>The runtime system sends an <code>initialize</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_363"></a> message to every class object before the class receives any other messages and after its superclass has received the <code>initialize</code> message. This gives the class a chance to set up its runtime environment before it’s used. If no initialization is required, you don’t need to write an <code>initialize</code> method to respond to the message.</p><p>Because of inheritance, an <code>initialize</code> message sent to a class that doesn’t implement the <code>initialize</code> method is forwarded to the superclass, even though the superclass has already received the <code>initialize</code> message. For example, assume class A implements the <code>initialize</code> method, and class B inherits from class A but does not implement the <code>initialize</code> method. Just before class B is to receive its first message, the runtime system sends <code>initialize</code> to it. But, because class B doesn’t implement <code>initialize</code>, class A’s <code>initialize</code> is executed instead. Therefore, class A should ensure that its initialization logic is performed only once, and for the appropriate class.</p><p>To avoid performing initialization logic more than once, use the template in <span class="content_text">Listing 1-3</span> when implementing the <code>initialize</code> method.</p><a name="//apple_ref/doc/uid/TP30001163-CH11-204371" title="Listing 1-3Implementation of the initialize method"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-BBCBIGBG" title="Listing 1-3Implementation of the initialize method"></a><p class="codesample"><strong>Listing 1-3&nbsp;&nbsp;</strong>Implementation of the initialize method</p><div class="codesample"><table><tr><td scope="row"><pre>+ (void)initialize<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  if (self == [ThisClass class]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Perform initialization here.<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH11-SW16" title="Note"></a><p><strong>Note:</strong>&nbsp;Remember that the runtime system sends <code>initialize</code> to each class individually. Therefore, in a class’s implementation of the <code>initialize</code> method, you must not send the <code>initialize</code> message to its superclass.</p></div><a name="//apple_ref/doc/uid/TP30001163-CH11-87293" title="Methods of the Root Class"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF120" title="Methods of the Root Class"></a><h4>Methods of the Root Class</h4><p>All objects, classes and instances alike, need an interface to the runtime system. Both class objects and instances should be able to introspect about their abilities and to report their place in the inheritance hierarchy. It’s the province of the <code>NSObject</code> class to provide this interface.</p><p>So that <code>NSObject</code>'s methods don’t have to be implemented twice—once to provide a runtime interface for instances and again to duplicate that interface for class objects—class objects<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_364"></a> are given special dispensation to perform instance methods defined in the root class. When a class object receives a message that it can’t respond to with a class method<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_365"></a>, the runtime system determines whether there’s a root instance method<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_366"></a> that can respond. The only instance methods that a class object can perform are those defined in the root class, and only if there’s no class method that can do the job.</p><p>For more on this peculiar ability of class objects to perform root instance methods, see the <code>NSObject</code> class specification in the Foundation framework reference.<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_367"></a></p><a name="//apple_ref/doc/uid/TP30001163-CH11-87318" title="Class Names in Source Code"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-TPXREF121" title="Class Names in Source Code"></a><h3>Class Names in Source Code</h3><p>In source code<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_368"></a>, class names can be used in only two very different contexts. These contexts reflect the dual role of a class as a data type and as an object:</p><ul class="spaceabove"><li class="li"><p>The class name can be used as a type name for a kind of object. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>Rectangle *anObject;<span></span></pre></td></tr></table></div><p>Here <code>anObject</code> is statically typed to be a pointer to a Rectangle. The compiler expects it to have the data structure of a Rectangle instance and the instance methods defined and inherited by the Rectangle class. Static typing enables the compiler to do better type checking and makes source code more self-documenting. See <span class="content_text"><a href="ocStaticBehavior.html#//apple_ref/doc/uid/TP30001163-CH16-SW1">“Enabling Static Behavior”</a></span> for details.</p><p>Only instances can be statically typed; class objects<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_369"></a> can’t be, since they aren’t members of a class, but rather belong to the Class data type.</p></li><li class="li"><p>As the receiver<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_370"></a><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_371"></a> in a message expression, the class name refers to the class object. This usage was illustrated in several of the earlier examples. The class name can stand for the class object only as a message receiver. In any other context, you must ask the class object to reveal its <code>id</code> (by sending it a <code>class</code> message). The example below passes the Rectangle class as an argument in an <code>isKindOfClass:</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_372"></a> message.</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anObject isKindOfClass:[Rectangle class]] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>It would have been illegal to simply use the name “Rectangle” as the argument. The class name can only be a receiver.</p><p>If you don’t know the class name at compile time but have it as a string at runtime, you can use <code>NSClassFromString</code><a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_373"></a> to return the class object:</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *className;<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>if ( [anObject isKindOfClass:NSClassFromString(className)] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>This function returns <code>nil</code> if the string it’s passed is not a valid class name.</p></li></ul><p>Classnames exist in the same namespace as global variables and function names. A class and a global variable can’t have the same name. Classnames are about the only names with global visibility in Objective-C.<a name="//apple_ref/doc/uid/TP30001163-CH11-DontLinkElementID_374"></a></p><a name="//apple_ref/doc/uid/TP30001163-CH11-SW32" title="Testing Class Equality"></a><h3>Testing Class Equality</h3><p>You can test two class objects for equality using a direct pointer comparison. It is important, though, to get the correct class. There are several features in the Cocoa frameworks that dynamically and transparently subclass existing classes to extend their functionality (for example, key-value observing and Core Data—see <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em> and <em><a href="../../CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_top">Core Data Programming Guide</a></em> respectively). When this happens, the <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/class" target="_top">class</a></code> method is typically overridden such that the dynamic subclass masquerades as the class it replaces. When testing for class equality, you should therefore compare the values returned by the <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/class" target="_top">class</a></code> method rather those returned by lower-level functions. Put in terms of API:</p><div class="codesample"><table><tr><td scope="row"><pre>[object class] != object_getClass(object) != *((Class*)object)<span></span></pre></td></tr></table></div><p>You should therefore test two classes for equality as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>if ([objectA class] == [objectB class]) { //...<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/introObjectiveC.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocDefiningClasses.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocObjectsClasses.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocObjectsClasses.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocObjectsClasses.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>