<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>RAMDisk - /RamINIT.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">RAMDisk</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxMassStorageDevices-date.html" target="_blank">Hardware & Drivers > Storage</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">RAMDisk</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/RamINIT.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/RamCDev.c</option>
<option value="listing2.html">/RamDiskCommon.h</option>
<option value="listing3.html">/RAMDiskDriverMain.c</option>
<option value="listing4.html">/RamDRVR.c</option>
<option value="listing5.html">/RamINIT.c</option>
<option value="listing6.html">/ShowInitIcon/ShowInitIcon.c</option>
<option value="listing7.html">/ShowInitIcon/ShowInitIcon.h</option>
<option value="listing8.html">/TradDriverLoaderLib/TradDriverLoaderLib.c</option>
<option value="listing9.html">/TradDriverLoaderLib/TradDriverLoaderLib.h</option>
<option value="listing10.html">/TradDriverLoaderLib/TradDriverLoaderLib.p</option></select>
				</p>
				</form>
				<p><strong><a href="RAMDisk.zip">Download Sample</a></strong> (&#147;RAMDisk.zip&#148;, 46.2K)<BR>
<strong><a href="RAMDisk.dmg">Download Sample</a></strong> (&#147;RAMDisk.dmg&#148;, 103.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">#define __DebugVersion  1/***  Apple Macintosh Developer Technical Support****  RAMInit.c: An INIT which installs DRVR for RamDisk****  by Gordon Sheridan and Jim Luther**  modified incessantly by Brian Bechtel**  and even more so by Quinn &quot;The Eskimo!&quot;****  File:    RamINIT.c****  Copyright &copy; 1992-1996 Apple Computer, Inc.**  All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;DTS Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.****  Change History (most recent first):****     &lt;1.4&gt;  19970207    Quinn  Reworked to use new file layout and bring generally**                  up-to-date.**    &lt;1.4&gt;  19970207  Quinn  Rewrote to use TradDriverLoaderLib**                  Junked some unused prototypes**                  Renamed RemoveDrive to RemoveDriveFromQueue**    &lt;1.3&gt;  08/23/96  BL&iexcl;B  Change dcePtr to dceHandle. Thanks to**                  Tim Fredenburg for pointing out the error.**    &lt;1.3&gt;  06/20/96  BL&iexcl;B  Changes to new routine names**    &lt;1.2&gt;  07/03/95  BL&iexcl;B  Many changes for Universal Header 2.0 **                  compliance.  Changed how we install driver.**                  Other bug fixes. See &quot;Changes in 1.2&quot; for**                  details.**     &lt;7&gt;  06/10/94  BL&iexcl;B  Explicitly set zone to system zone before**                  getting the DRVR resource.  Symantec 7.0**                  doesn't set the System attribute on the DRVR**                  resource.  This can be hard to track down.**     &lt;6&gt;  05/19/94  BL&iexcl;B  Modified debugger macros to avoid use of ANSI**                   routines, and weird c-string dependencies.**     &lt;5&gt;  10/15/93  JML    Added code to resize unit table if needed.**     &lt;4&gt;  10/14/93  JML    Implement AddDebuggerLabels routine for MacsBug.**                   Added Panic debug macros.**     &lt;3&gt;   6/29/93  gs    Change AddDriveToQueue to start with drive number 5.**     &lt;2&gt;   6/28/93  gs    Change _DebugVersion to __DebugVersion**     &lt;1&gt;   6/13/93  gs    Implement AddDebuggerLabels routine for TMON.**     &lt;0&gt;   4/17/92  gs    Clean up for Sample Code release.**/#ifdef __MWERKS__#include &lt;A4Stuff.h&gt;#endif#ifdef THINK_C#include &lt;SetupA4.h&gt;#endif#include &lt;string.h&gt;#include &lt;TextUtils.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Traps.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Memory.h&gt;#include &lt;Resources.h&gt;#include &lt;DiskInit.h&gt;#include &quot;RamDiskCommon.h&quot;#include &quot;TradDriverLoaderLib.h&quot;#include &quot;ShowInitIcon.h&quot;///////////////////////////////////////////////////////////////////////////#define    kDriverName    &quot;\p.RamDRVR&quot;enum {  kMinUnitNum = 48    /* the lowest unit number we can use */};/////////////////////////////////////////////////////////////////////////////// Custom drive queue element.  Normally you might to extend this to have// extra drive-specific variables, but in this case we have no extra// variables.  Still, we define our own structure rather than use// the one in &lt;Files.h&gt; because our structure has the magic &quot;flags&quot;// field at the front.struct MyDrvQEl{  long      flags;    QElemPtr    qLink;    short      qType;    short      dQDrive;    short      dQRefNum;    short      dQFSID;    unsigned short  dQDrvSz;    unsigned short  dQDrvSz2;};typedef struct MyDrvQEl MyDrvQEl;typedef MyDrvQEl *MyDrvQElPtr;///////////////////////////////////////////////////////////////////////////enum {  // ICN#  rLoadOKIcon    =  -4064,  /* same as cdev icon */  rLoadBadIcon  =  -4033,  rPhysicalIcon  =  -4034,  rMediaIcon    =  -4035};///////////////////////////////////////////////////////////////////////////static OSErr InitializeGlobals (DrvrGlobals *driverGlobals)  // Initialize the globals using data read from resources.{  OSErr      result = -1;  Handle      physicalIconHandle;  Handle      mediaIconHandle;  VersRecHndl    versionHandle;  ConfigRecHandle  configHandle;  long      length;  driverGlobals-&gt;ramDisk = nil;  /* RAM disk memory isn't allocated yet */  /* Get the user configuration, icons, and the &quot;where&quot; string */  configHandle = (ConfigRecHandle)Get1Resource ('RDcf', rConfiguration);  physicalIconHandle = Get1Resource('ICN#', rPhysicalIcon);  mediaIconHandle = Get1Resource('ICN#', rMediaIcon);    versionHandle = (VersRecHndl) Get1Resource('vers', 1);    if (configHandle &amp;&amp; physicalIconHandle &amp;&amp; mediaIconHandle &amp;&amp; versionHandle)  {    /* See if we are supposed to install */    if ((**configHandle).install)    {            /* Copy the user's preferred volume name to the driver globals. */      length = (**configHandle).volumeName[0]+1;      BlockMoveData((**configHandle).volumeName, driverGlobals-&gt;volumeName, length);            /* Copy ICN# to driver globals so it has a physical location icon for volumes. */      BlockMoveData( &amp;(**physicalIconHandle), (Ptr)(driverGlobals-&gt;physicalIcon), kLargeIconSize);            /* Copy ICN# to driver globals so it has a default media icon for volumes. */      BlockMoveData( &amp;(**mediaIconHandle), (Ptr)(driverGlobals-&gt;mediaIcon), kLargeIconSize);            /* Put the drive location string into the driver globals. */      GetIndString(driverGlobals-&gt;locationStr, rStringList, strLocationStr);      if (ResError() != noErr)        BlockMoveData(&quot;\pIn RAM&quot;, driverGlobals-&gt;locationStr, 7);                  driverGlobals-&gt;ramSize = (**configHandle).size * 1024;            driverGlobals-&gt;driverVersion = (**versionHandle).numericVersion;            result = noErr;    }  }    if (configHandle)    ReleaseResource((Handle)configHandle);  else    Panic(&quot;\pYou forgot to turn settings on in control panel&quot;);  if (physicalIconHandle)    ReleaseResource(physicalIconHandle);  if (mediaIconHandle)    ReleaseResource(mediaIconHandle);    return (result);}///////////////////////////////////////////////////////////////////////////static OSErr AddDriveToQueue (long size, short drvrRef, short *driveNum)  // Find the first unused drive number greater than 4, allocate and initialize  // a drive queue element (including the drive flags), and add the drive queue  // element to the drive queue.{  OSErr    result = noErr;  QHdrPtr    driveQHdr;  DrvQEl    *drivePtr;  MyDrvQElPtr  newDrivePtr;  Boolean    driveNumFound = false;    driveQHdr = GetDrvQHdr();    /* find first free drive number */  *driveNum = 5;                      /* drive numbers 1-4 are reserved */  while (! driveNumFound)  {    drivePtr = (DrvQEl *)driveQHdr-&gt;qHead;        /* get first drive */    while (drivePtr &amp;&amp; *driveNum != drivePtr-&gt;dQDrive)  /* order of tests important! */      drivePtr = (DrvQEl *)drivePtr-&gt;qLink;      /* get next drive */        if (drivePtr == nil)      driveNumFound = true;    else      ++(*driveNum);  }  if (*driveNum &gt; 0)  /* must be a positive short */  {    /* allocate new drive queue element */    newDrivePtr = (MyDrvQElPtr)NewPtrSysClear(sizeof(MyDrvQEl));          if (newDrivePtr != nil)    {      newDrivePtr-&gt;flags    = 0x00080000;      /* non-ejectable, disk not locked */      newDrivePtr-&gt;qType    = 1;          /* see IM vol.4 p.181 */      newDrivePtr-&gt;dQDrive  = *driveNum;      /* ** dQDrive and dQRefNum are filled */      newDrivePtr-&gt;dQRefNum  = drvrRef;        /* ** in by AddDrive */      newDrivePtr-&gt;dQFSID    = 0;          /* HFS */      newDrivePtr-&gt;dQDrvSz  = size &amp; 0x0000FFFF;  /* dQDrvSz  = LoWord of size */      newDrivePtr-&gt;dQDrvSz2  = size &gt;&gt; 16;      /* dQDrvSz2 = HiWord of size */            AddDrive (drvrRef, *driveNum, (DrvQEl *)&amp;newDrivePtr-&gt;qLink);    }    else      result = memFullErr;  }  else    /* more than 32768 drives!?! */    result = nsDrvErr;    return (result);}///////////////////////////////////////////////////////////////////////////static OSErr RemoveDriveFromQueue (short driveNum, DrvQElPtr *drivePtr)  // Find the drive queue element for driveNum in the drive queue and Dequeue it.  // Return pointer to the drive queue element removed in *drivePtr.{  QHdrPtr    driveQHdr;  driveQHdr = GetDrvQHdr();  *drivePtr = (DrvQEl *)driveQHdr-&gt;qHead;          /* get first drive */  while (*drivePtr &amp;&amp; (driveNum != (*drivePtr)-&gt;dQDrive))  /* order of tests important! */    *drivePtr = (DrvQEl *)(*drivePtr)-&gt;qLink;      /* get next drive */    if (*drivePtr != nil)    return (Dequeue((QElemPtr)*drivePtr, driveQHdr));  else    return (nsDrvErr);}///////////////////////////////////////////////////////////////////////////static short NumToolboxTraps (void){  if (NGetTrapAddress(_InitGraf, ToolTrap) == NGetTrapAddress(0xAA6E, ToolTrap) )    return (0x200);  else    return (0x400);}///////////////////////////////////////////////////////////////////////////static TrapType GetTrapType (short theTrap){  if (theTrap &amp; 0x0800)    return (ToolTrap);  else    return (OSTrap);}///////////////////////////////////////////////////////////////////////////static Boolean TrapAvailable (short theTrap){  TrapType  tType;    tType = GetTrapType(theTrap);  if (tType == ToolTrap)  {    theTrap = theTrap &amp; 0x7FF;    if (theTrap &gt;= NumToolboxTraps() )      theTrap = _Unimplemented;  }    return (NGetTrapAddress(theTrap, tType) !=      NGetTrapAddress(_Unimplemented, ToolTrap) );}///////////////////////////////////////////////////////////////////////////#define kMacsbugMacroStr  &quot;\p;MC RamDisk 'DM #&quot;#define kMacsbugMacroStr2  &quot;\p';g&quot;#define kTMONMacroStr    &quot;\p(tm)AddLabel RamDisk,.&quot;#define kTMONMacroStr2    &quot;\p,.&quot;#define AddString(src, dst) {  BlockMoveData(&amp;src[1], dst+i, src[0]); i += src[0]; }static void AddDebuggerLabels (DrvrGlobals driverGlobals)  // Add TMON or MacsBug debugger macros for easy viewing of RamDisk{  Str255    strbuf = &quot;\p&quot;;  Str31    numstr;  long    tmonVal;  short    err;  Boolean   done = false;  SignedByte  debugFlags;  short    i;  if (TrapAvailable(_Gestalt))  /* check for TMON */  {    err = Gestalt('TMON',&amp;tmonVal);    if (err == 0)    {      /* Add TMON label */      i = 1;      AddString(kTMONMacroStr, strbuf);      NumToString((long)driverGlobals.ramDisk,numstr);      AddString(numstr, strbuf);      AddString(kTMONMacroStr2, strbuf);      NumToString(driverGlobals.ramSize,numstr);      AddString(numstr, strbuf);      strbuf[0] = i - 1;      DebugStr(strbuf);            done = true;    }  }  if (!done)  /* If TMON isn't installed, define a macro for MacsBug */  {    debugFlags = *(SignedByte *) 0x0BFF;    // MacJmpFlag    if (debugFlags == -1)      debugFlags = *(SignedByte *) 0x0120;  // MacJmp        if (debugFlags &amp; 0x20)    {      /* Define MacsBug macro */      i = 1;            AddString(kMacsbugMacroStr, strbuf);      NumToString((long)driverGlobals.ramDisk, numstr);      AddString(numstr, strbuf);      AddString(kMacsbugMacroStr2, strbuf);      strbuf[0] = i - 1;            DebugStr(strbuf);    }  }}///////////////////////////////////////////////////////////////////////////void  main (void){  DrvrGlobals  driverGlobals;  short    csParam[11];  short    drvrRefNum = 0;  short    driveNum = 0;  DrvQElPtr  driveQElPtr;  OSErr    result;  DCtlHandle  dceHandle;  Boolean    driverInstalled = false;  #ifdef THINK_C    RememberA0();    SetUpA4();  #endif  #ifdef __MWERKS__    long oldA4 = SetCurrentA4();  #endif  Panic(&quot;\pStarting RAMDisk&quot;);  ShowInitIcon(rLoadOKIcon,false);  /* show OK icon to indicate we're executing */    result = InitializeGlobals(&amp;driverGlobals);  if (result != noErr)  {    Panic(&quot;\pCould not initialize globals&quot;);    goto Done;  }  driverGlobals.ramDisk = NewPtrSysClear(driverGlobals.ramSize);  if (driverGlobals.ramDisk == nil)  {    Panic(&quot;\pNewSysPtr = nil&quot;);    result = memFullErr;    goto Done;  }  #if    __DebugVersion    AddDebuggerLabels(driverGlobals);  #endif  __DebugVersion    // &lt;1.4&gt;  result = TradInstallDriverFromResource(0, kDriverName,      kMinUnitNum,      TradHighestUnitNumber() + 1,      &amp;drvrRefNum);  if (result == noErr || result == dupFNErr) {    driverInstalled = (result == noErr);    result = TradOpenInstalledDriver(drvrRefNum, fsRdWrPerm);  } else {    Panic(&quot;\pTradInstallDriverFromResource failed!&quot;);    goto Done;  }  if (result != noErr)  {    Panic(&quot;\pTradOpenInstalledDriver failed&quot;);    goto Done;  }    /* put in drive queue */  result = AddDriveToQueue (driverGlobals.ramSize / 512, drvrRefNum, &amp;driveNum);  if (result != noErr)  {    Panic(&quot;\pAddMyDrive returned negative driveNum!&quot;);    goto Done;  }  /* driveNum now = drive number */    /*  Save driveNum in our globals so driver code can verify drive number in    Prime, Status and Control calls (if need be). The driver also checks     driveNum in the driver globals for a non-zero value before accepting    regular prime, control and status calls.  */  driverGlobals.driveNumber = driveNum;  /* set drivers globals */  *(Ptr *)csParam = (Ptr)&amp;driverGlobals;  result = Control(drvrRefNum, setGlobalsCC, (Ptr)csParam);  if (result != noErr)  {    Panic(&quot;\pControl returned err&quot;);    goto Done;  }    /* check to see if it got them */  result = Status(drvrRefNum, getGlobalsSC, (Ptr)csParam);  if ((result != noErr) || (driverGlobals.ramSize != *(long *)csParam))  {    Panic(&quot;\pStatus returned err&quot;);    goto Done;  }        /* zero &amp; mount */  result = DIZero(driveNum, driverGlobals.volumeName);  if (result != noErr)  {    Panic(&quot;\pDIZero returned err&quot;);    goto Done;  }  Done:  if (result == noErr)    ShowInitIcon(rLoadOKIcon,true);  /* draw OK icon and move pen */  else  {    dceHandle = GetDCtlEntry(drvrRefNum);    if (dceHandle != nil)        if ((**dceHandle).dCtlFlags &amp; dOpenedMask)      {        /* Driver is open - close it */        result = CloseDriver(drvrRefNum);        if (result == noErr)          /* If driver was closed, ramDisk memory was released! */          driverGlobals.ramDisk = nil;      }        if (driveNum != 0)    {      result = RemoveDriveFromQueue(driveNum, &amp;driveQElPtr);  /* ignore errors */      if (result == noErr)        /* Dispose of the DrvQEl. Since it was allocated as a          MyDrvQEl record, we have to subract 4 from the address */        DisposePtr((Ptr)((Ptr)(driveQElPtr) - 4));    }        // &lt;1.4&gt;    if (driverInstalled) {      (void) TradRemoveDriver(drvrRefNum, false);    }        if (driverGlobals.ramDisk != nil)      DisposePtr(driverGlobals.ramDisk);          #if    __DebugVersion      /* *** Need to add routine to remove TMON/MacsBug debugging macros */    #endif  __DebugVersion          ShowInitIcon(rLoadBadIcon,true);      /* draw bad load icon and move pen */  }  #ifdef THINK_C    RestoreA4();  #endif  #ifdef __MWERKS__    SetA4(oldA4);  #endif}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/RAMDisk/listing5.html%3Fid%3DDTS10000430-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/RAMDisk/listing5.html%3Fid%3DDTS10000430-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/RAMDisk/listing5.html%3Fid%3DDTS10000430-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>