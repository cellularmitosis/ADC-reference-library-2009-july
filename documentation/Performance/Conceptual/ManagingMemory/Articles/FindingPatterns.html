<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Memory Usage Performance Guidelines: Examining Memory Allocation Patterns</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Examining Memory Allocation Patterns"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001882" title="Examining Memory Allocation Patterns"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../DeveloperTools/index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../../DeveloperTools/Performance-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000901" target="_top">Performance</a> &gt; <a href="../index.html" target="_top">Memory Usage Performance Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="MemoryAlloc.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="FindingLeaks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20001882-CJBJFIDD" title="Examining Memory Allocation Patterns"></a><hr /><H1>Examining Memory Allocation Patterns</H1><p>Examining your application’s memory allocation patterns can help reveal algorithms that may not be the most efficient in their memory use. If you see a large number of allocations occurring during a loop, you may decide to go back and change the allocations to occur outside of the loop. This kind of reduction can have a significant increase in application performance. </p><p>Apple provides several tools for examining your memory usage. The MallocDebug tracks the location of memory allocations by recording the application call stack whenever a memory-related function is called. The <code>malloc_history</code> tool does many of the same things as MallocDebug but from a command-line interface. You can use these tools to look for unexpectedly large allocations or allocations that were made but are no longer needed.</p><p>If you are writing a Cocoa application, you should use the ObjectAlloc program and <code>heap</code> tool to see which Objective-C objects your program creates. The ObjectAlloc program is good for finding problems involving allocation trends, retain/release problems, or other problems involving object allocations. Similarly, the <code>heap</code> tool helps you examine the objects currently in use by a program. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-104937-TPXREF102">Debugging Allocations With MallocDebug</a>
				
			<br/>
			
        
			
			
				<a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-104290-BCICHJGD">Tracking Memory Allocations With malloc_history</a>
				
			<br/>
			
        
			
			
				<a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-97995-TPXREF162">Observing Allocations With ObjectAlloc</a>
				
			<br/>
			
        
			
			
				<a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-103964-TPXREF151">Examining Heaps With the heap Tool</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001882-104937" title="Debugging Allocations With MallocDebug"></a><a name="//apple_ref/doc/uid/20001882-104937-TPXREF102" title="Debugging Allocations With MallocDebug"></a><h2>Debugging Allocations With MallocDebug</h2><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_85"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_86"></a><p>The MallocDebug application provides tools for inspecting your program’s memory use and for finding memory leaks. MallocDebug shows currently allocated blocks of memory, organized by the call stack at the time of allocation. You can use MallocDebug to determine how much memory your application allocates, where it allocates that memory, and which functions allocated large amounts of memory. It gathers data from the Carbon Memory Manager, Core Foundation object allocations, Cocoa object allocations, and <code>malloc</code><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_87"></a>allocations. </p><p>MallocDebug does not require prior instrumentation of the program—that is, you don’t need to link with special libraries or call special functions. Instead, MallocDebug launches your application using its own instrumented version of the <code>malloc</code> library calls. </p><div class="notebox"><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_5" title="Note"></a><p><strong>Note:</strong>&nbsp;The custom malloc library used by MallocDebug may hold on to memory blocks longer than normal for analysis purposes. As a result, you should not try to gather metrics regarding the size of your program’s memory footprint while running it under MallocDebug.</p></div><p>MallocDebug includes a number of features you can use to refine your memory analysis:</p><ul class="ul"><li class="li"><p>It provides a hex-dump view for examining raw memory.</p></li><li class="li"><p>It allows you to mark off any period of execution for analysis.</p></li><li class="li"><p>It allows you to export performance data for detailed examination or for further analysis and refinement by command-line tools. The export feature gives you the freedom to look at or summarize the data in the form most relevant to your executable.</p></li></ul><p>For information on how to use MallocDebug to identify memory leaks in your program, see <span class="content_text"><a href="FindingLeaks.html#//apple_ref/doc/uid/20001883-CJBJFIDD">“Finding Memory Leaks.”</a></span> </p><a name="//apple_ref/doc/uid/20001882-96900" title="Using MallocDebug"></a><a name="//apple_ref/doc/uid/20001882-96900-TPXREF103" title="Using MallocDebug"></a><h3>Using MallocDebug</h3><p>After launching MallocDebug, the main window appears (<span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-104558-BAJFCDJF">Figure 1</a></span>). There are three basic sections in the MallocDebug window. Information about the launched program is at the top of the window. The center portion displays the call stack browser. The bottom portion displays the memory buffer browser.<a name="//apple_ref/doc/uid/20001882-DontLinkElementID_88"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_89"></a></p><br/><div><a name="//apple_ref/doc/uid/20001882-104558-BAJFCDJF" title="Figure 1MallocDebug main window"></a><p><a name="//apple_ref/doc/uid/20001882-104558" title="Figure 1MallocDebug main window"></a><strong>Figure 1&nbsp;&nbsp;</strong>MallocDebug main window</p><img src = "art/md_window_browse.gif" alt = "MallocDebug main window" width="537" height="355"></div><br/><p>To start a new MallocDebug session, you must select and launch the application you want to analyze by doing the following:</p><ol class="ol"><li class="li"><p>Enter the full path to the program in the Executable field, or click the Browse button and select the program using the file-system browser.</p></li><li class="li"><p>If you want to run the executable with command-line arguments, enter them in the Arguments field.</p></li><li class="li"><p>Click the Launch button.</p></li></ol><p>MallocDebug launches the program and performs an initial query about memory usage. Further updates occur whenever you press the Update button.</p><a name="//apple_ref/doc/uid/20001882-96963" title="The Call Stack Browser"></a><a name="//apple_ref/doc/uid/20001882-96963-TPXREF104" title="The Call Stack Browser"></a><h4>The Call Stack Browser</h4><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_90"></a><p>The main focus of memory analysis in MallocDebug is the call stack browser (see <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-104558-BAJFCDJF">Figure 1</a></span>). This browser shows you where memory allocations occurred by gathering stack snapshots whenever one of the malloc library routines was encountered. <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-99369-BAJCFDBD">Figure 2</a></span> shows a sample set of data for calls to the <code>malloc</code> routine.</p><br/><div><a name="//apple_ref/doc/uid/20001882-99369-BAJCFDBD" title="Figure 2Function call stacks gathered at runtime "></a><p><a name="//apple_ref/doc/uid/20001882-99369" title="Figure 2Function call stacks gathered at runtime "></a><strong>Figure 2&nbsp;&nbsp;</strong>Function call stacks gathered at runtime </p><img src = "art/md_functions_gathered.gif" alt = "Function call stacks gathered at runtime" width="385" height="63"></div><br/><p>MallocDebug coalesces the call stack information it gathers into a call tree by overlapping equivalent sequences of functions. It then presents this information in the call stack browser. The call stack browser has three display modes: standard, inverted, and flat. Each display mode presents the data in a different way to help you identify trends. You can choose which mode you want from the left-most pop-up menu and toggle back and forth as needed.</p><p><strong>Standard mode</strong> presents each call stack hierarchically from the function at the top of the stack (for instance, <code>main</code>) to the function that performs the allocation: <code>malloc</code>, <code>calloc</code>, and so on. Each element of the browser shows the amount of memory that has been allocated in the call stack involving that method or function. <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-99517-BAJBABIG">Figure 3</a></span> illustrates the structure of the call stack in standard mode.</p><br/><div><a name="//apple_ref/doc/uid/20001882-99517-BAJBABIG" title="Figure 3View of function call tree in standard mode "></a><p><a name="//apple_ref/doc/uid/20001882-99517" title="Figure 3View of function call tree in standard mode "></a><strong>Figure 3&nbsp;&nbsp;</strong>View of function call tree in standard mode </p><img src = "art/md_functions_normal.gif" alt = "View of function call tree in standard mode" width="378" height="63"></div><br/><p><strong>Inverted mode</strong> reverses the hierarchy of standard mode and shows the call tree from the allocation functions to the bottom of each stack. This mode is useful for highlighting the ways in which specific allocation functions are called. By seeing all the calls to <code>malloc</code> or the Core Foundation allocators, you can more easily detect wasteful patterns in lower-level libraries. Use inverted mode if you’re working on a low-level framework or if you want to focus on how you’re calling <code>malloc</code> in your own code. <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-97090-BAJBEEAI">Figure 4</a></span> illustrates the structure of the call stack in inverted mode.</p><br/><div><a name="//apple_ref/doc/uid/20001882-97090-BAJBEEAI" title="Figure 4View of function call tree in inverted mode "></a><p><a name="//apple_ref/doc/uid/20001882-97090" title="Figure 4View of function call tree in inverted mode "></a><strong>Figure 4&nbsp;&nbsp;</strong>View of function call tree in inverted mode </p><img src = "art/md_functions_inverse.gif" alt = "View of function call tree in inverted mode" width="378" height="63"></div><br/><p><strong>Flat mode</strong> shows memory usage for every method and function of an application in a single list, sorted by allocated amount. All of the instances of a function call are collapsed into one browser item corresponding to that function. A function’s memory use includes the sum of all the allocations performed in that function and all allocations performed in functions that it calls. This allows you to see the total amount of memory allocated by a specific function and every function it called, not just those at the top or bottom of the call stack.</p><p>The analysis mode pop-up menu (located to the right of the viewing-mode pop-up menu) affects the type of allocations that are displayed in the call stack browser. You have several options:</p><ul class="spaceabove"><li class="li"><p><strong>All Allocations</strong> Gives you the call trees for all currently allocated buffers in your application.</p></li><li class="li"><p><strong>Allocations since Mark</strong> Displays functions and methods in which an allocation has occurred since launch time or the last mark. See <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-97180">“Taking a Snapshot of Memory Usage”</a></span> for information on how to display allocations over a specific period of time.</p></li><li class="li"><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_91"></a><p><strong>Leaks</strong> This item displays a call tree showing leaked memory blocks in your program. For further discussion of this analysis mode, see <span class="content_text"><a href="FindingLeaks.html#//apple_ref/doc/uid/20001883-CJBJFIDD">“Finding Memory Leaks.”</a></span></p></li><li class="li"><p><strong>Overruns/underruns</strong> Displays a call tree with a list of buffers that were written to incorrectly, caused by writing to memory before or after the buffer boundary. If the program wrote past the end of a buffer, a right arrow (<code>></code>) appears by the buffer. Similarly, if the application wrote before the start of a buffer, a left arrow (<code>&lt;</code>) appears by the buffer. For more on MallocDebug’s memory-detail features, see <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-105331">“Analyzing Raw Memory.”</a></span> </p></li></ul><a name="//apple_ref/doc/uid/20001882-97180" title="Taking a Snapshot of Memory Usage"></a><a name="//apple_ref/doc/uid/20001882-97180-BAJCBJIF" title="Taking a Snapshot of Memory Usage"></a><h4>Taking a Snapshot of Memory Usage</h4><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_92"></a><p>When you launch a program with MallocDebug, the main window displays the allocation activity that occurred during launch time. When you click the Update button, MallocDebug shows memory usage up to the current point in time. If you want to display allocations from a particular point in time, you can do the following: </p><ol class="ol"><li class="li"><p>Press the Mark button.</p></li><li class="li"><p>Exercise a portion of your program.</p></li><li class="li"><p>Select the "Allocations from mark" item from the analysis mode pop-up list.</p></li></ol><p>MallocDebug shows the buffers allocated since the mark was set. Note that MallocDebug displays only the buffers that are still currently allocated, so you will see only those buffers allocated since you clicked the Mark button that have not been freed.</p><a name="//apple_ref/doc/uid/20001882-105331" title="Analyzing Raw Memory"></a><a name="//apple_ref/doc/uid/20001882-105331-BAJDDEHG" title="Analyzing Raw Memory"></a><h4>Analyzing Raw Memory</h4><p>When you select an allocation buffer in the call stack browser, the memory buffer list (shown in <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-104558-BAJFCDJF">Figure 1</a></span>) might show one or more lines of data. Each line in this list represents a block of memory allocated by the currently selected function or by a function eventually called by that function. Each line contains the address of the buffer, its size (in bytes), and the zone in which it was allocated. Double-clicking one of these lines opens the Memory Viewer Panel window, which you can use to inspect the contents of memory at that location. </p><p>If code attempts to write before the start or past the end of a buffer, the memory buffer list shows an appropriate indicator in the Status column. If bytes were written before the buffer, the column displays a less-than <code>&lt;</code> character. If bytes were written after the buffer, the column contains a greater-than <code>></code> character. Use the popup menu below the list to sort the list contents. </p><p>MallocDebug helps you catch some types of problems by writing certain hexadecimal patterns into the hex values displayed in the Memory Viewer Panel window. It overwrites freed memory with <code>0X55</code> and it guards against writing beyond a block’s boundaries by putting the values <code>0xDEADBEEF</code> and <code>0xBEEFDEAD</code>, respectively, at the beginning and end of each allocated buffer. </p><p>The memory buffer inspector can be particularly helpful for determining why an object is leaking. For example, if a string is being leaked, the text of the string might indicate where it was created. If an event structure is leaked, you might be able to identify the type of event from the contents of memory and thus find the corresponding event-handling code responsible for the leak.</p><a name="//apple_ref/doc/uid/20001882-97503" title="Evaluating MallocDebug Problem Reports"></a><a name="//apple_ref/doc/uid/20001882-97503-TPXREF107" title="Evaluating MallocDebug Problem Reports"></a><h3>Evaluating MallocDebug Problem Reports</h3><p>Some of the reports that <a name="//apple_ref/doc/uid/20001882-DontLinkElementID_93"></a>MallocDebug presents identify obvious problems that you should fix immediately. Some of these problems include leaks, buffer overruns, and references to freed memory. Other problems are more subjective in nature and require you to make a determination as to whether there is a problem. </p><p>To improve your program’s overall allocation behavior, use MallocDebug’s detailed accounting of memory usage to explore the memory usage of your program. This can help you identify wasted memory allocations or unexpected allocation patterns and thus optimize your program’s memory usage. As you analyze your memory allocations, consider the following items:</p><ul class="spaceabove"><li class="li"><p>Don’t ignore small buffers. A small leaked buffer might itself contain references to larger buffers, which then also become leaks. (The <code>leaks</code> tool is better at reporting leaks of this nature.)</p></li><li class="li"><p>Look at allocation patterns during specific intervals of typical program use, especially where you suspect memory usage might be a problem.</p></li><li class="li"><p>The inverted display mode for the call stack browser can sometimes yield results faster because it shows which routines are actually calling <code>malloc</code>. The normal display mode is better for seeing memory allocations in particular modules of your code.</p></li><li class="li"><p>Keep track of important statistics, such as private memory usage and total allocated memory, so you can compare them against previous measurements. </p></li></ul><a name="//apple_ref/doc/uid/20001882-97543" title="Limitations of MallocDebug"></a><a name="//apple_ref/doc/uid/20001882-97543-TPXREF145" title="Limitations of MallocDebug"></a><h3>Limitations of MallocDebug</h3><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_94"></a><p>The following section describes some of the issues you may run into when running MallocDebug.</p><a name="//apple_ref/doc/uid/20001882-97560" title="Allocated Memory Reporting"></a><a name="//apple_ref/doc/uid/20001882-97560-TPXREF146" title="Allocated Memory Reporting"></a><h4>Allocated Memory Reporting</h4><p>MallocDebug shows the <em>current</em> amount of allocated memory at a given point in a program’s execution; it does not show the <em>total</em> amount of memory allocated by the program during its entire span of execution. Memory that has been freed is not shown.</p><p>To see memory that your program has allocated and freed, use the <code>malloc_history</code><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_95"></a> tool. See <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-104290">“Tracking Memory Allocations With malloc_history”</a></span> for more information.</p><a name="//apple_ref/doc/uid/20001882-97599" title="Crashing Under MallocDebug"></a><a name="//apple_ref/doc/uid/20001882-97599-TPXREF108" title="Crashing Under MallocDebug"></a><h4>Crashing Under MallocDebug</h4><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_96"></a><p>If a program crashes under MallocDebug, a diagnostic message is printed to the console that explains why the program crashed. <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-97618-BAJDAFAD">Listing 1</a></span> gives an example of MallocDebug’s crash diagnostic message.</p><a name="//apple_ref/doc/uid/20001882-97618-BAJDAFAD" title="Listing 1Diagnostic output from crashing under MallocDebug"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001882-97618" title="Listing 1Diagnostic output from crashing under MallocDebug"></a><strong>Listing 1&nbsp;&nbsp;</strong>Diagnostic output from crashing under MallocDebug</p><div class="codesample"><table><tr><td scope="row"><pre>MallocDebug: Target application attempted to read address 0x55555555, which can’t be read.<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: MallocDebug trashes freed memory with the value 0x55,<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: strongly suggesting the application or a library is referencing<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: memory it already freed.<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: MallocDebug can’t do anything about this, so the app’s just going to have to be terminated.<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: libMallocDebug cannot help the application recover from this error,<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: so we’ll just have to shut down the application.<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: *************************************************<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: THIS IS A BUG IN THE PROGRAM BEING RUN UNDER MALLOC DEBUG,<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: NOT A BUG IN MALLOC DEBUG!<span></span></pre></td></tr><tr><td scope="row"><pre>MallocDebug: *************************************************<span></span></pre></td></tr></table></div>	<p>Usually a crash results from subtle memory problems, such as referencing freed memory or dereferencing pointers found outside an allocated buffer. Check suspected buffers of memory with the memory-buffer inspector (see <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-105331">“Analyzing Raw Memory”</a></span>). If your program is referencing memory at <code>0x55555555</code>, then it is referencing freed memory.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should always investigate and fix bugs that cause your program to crash. Subtle problems may indicate a design flaw that could cost more time to fix later.</p><p></p></div><a name="//apple_ref/doc/uid/20001882-97707" title="Programs Calling setuid or setgid"></a><a name="//apple_ref/doc/uid/20001882-97707-TPXREF109" title="Programs Calling setuid or setgid"></a><h4>Programs Calling setuid or setgid</h4><p>For security reasons, the operating system does not allow programs running <code>setuid</code> (set the user id at execution) or <code>setgid</code> (set the group id at execution) to load new libraries, such as the heap debugging library used by MallocDebug. As a result, MallocDebug cannot display information about these programs unless they are run by the target user or by a member of the target group.<a name="//apple_ref/doc/uid/20001882-DontLinkElementID_97"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_98"></a></p><p>If you want to examine a <code>setuid</code> or <code>setgid</code> program with MallocDebug, you have two options:</p><ul class="spaceabove"><li class="li"><p>Use MallocDebug on a copy of the program without the <code>setuid</code> or <code>setgid</code> permissions set. This approach may not work if the permissions are needed to access files normally not accessible by you.</p></li><li class="li"><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_99"></a><p>Run MallocDebug while logged in as the user who owns the file, or use the <code>su</code> tool to log in as another user. Note that you must run your program by calling the executable file directly in the latter case since the <code>open</code> tool runs the program as if it was launched by the user who logged in.</p></li></ul><a name="//apple_ref/doc/uid/20001882-97776" title="Running Under libMallocDebug"></a><a name="//apple_ref/doc/uid/20001882-97776-TPXREF110" title="Running Under libMallocDebug"></a><h4>Running Under libMallocDebug</h4><p>If you’re writing a simple program that runs from the command-line, you may need to statically link the <code>malloc</code> routines into your executable before MallocDebug can attach to your program. Most programs link to the System framework, which is instrumented for use by MallocDebug. If your program does not use this framework, you can explicitly link your program with the <code>/usr/lib/libMallocDebug.a</code> library. (If you are running in Mac OS X 10.3.9 or later, you can also execute the command <code>set env DYLD_INSERT_LIBRARIES /usr/lib/libMallocDebug.A.dylib</code> from Terminal to attach your program to <code>libMallocDebug</code> .) You should not notice any difference in your program’s allocation behavior when linking with this library. </p><p>If you do link your application to <code>libMallocDebug</code> , you should be aware of the following caveats:</p><ul class="spaceabove"><li class="li"><p>If your code runs in versions of Mac OS X prior to 10.4, you must need to set the <a name="//apple_ref/doc/uid/20001882-DontLinkElementID_100"></a><code>DYLD_FORCE_FLAT_NAMESPACE</code> environment variable to force the linker to use the malloc routines in <code>libMallocDebug</code>. If you are running in Mac OS X v10.4 or later, you do not need to set this variable.</p></li><li class="li"><p>When running your program in Mac OS X v10.4 or later under gdb with libMallocDebug installed, your program automatically drops into the debugger when <code>libMallocDebug</code> detects that memory has been corrupted by a <code>malloc</code> or <code>free</code> call. To continue running your program, execute the command " <code>set $PC+=4</code> " in gdb then continue. </p></li><li class="li"><p>If your program runs on a version of Mac OS X prior to version 10.3.9, you may need to execute the command " <code>set start-with-shell 0</code> " in gdb to debug your program with <code>libMallocDebug</code> . .</p></li><li class="li"><p>In Mac OS X v10.4 and later, child processes created by a <code>fork</code> and <code>exec</code> now properly inherit the <code>DYLD_INSERT_LIBRARIES</code> environment variable setting. Thus, if the parent is running under <code>libMallocDebug</code> , so will the child.  </p></li></ul><a name="//apple_ref/doc/uid/20001882-97800" title="Setting Environment Variables"></a><a name="//apple_ref/doc/uid/20001882-97800-TPXREF155" title="Setting Environment Variables"></a><h4>Setting Environment Variables</h4><p>MallocDebug does not contain any built-in mechanism for setting <a name="//apple_ref/doc/uid/20001882-DontLinkElementID_101"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_102"></a>environment variables. You can work around this limitation by setting your environment variables from Terminal and then launching MallocDebug from there. When launched in this manner, your application inherits the Terminal environment, including any environment variables. </p><p>Do not launch MallocDebug from Terminal using the <code>open</code> command. Instead, run the MallocDebug executable directly. The executable is located in the MallocDebug.app application bundle, usually in the <code>MallocDebug.app/Contents/MacOS</code> directory.<a name="//apple_ref/doc/uid/20001882-DontLinkElementID_103"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_104"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_105"></a></p><a name="//apple_ref/doc/uid/20001882-104290" title="Tracking Memory Allocations With malloc_history"></a><a name="//apple_ref/doc/uid/20001882-104290-BCICHJGD" title="Tracking Memory Allocations With malloc_history"></a><h2>Tracking Memory Allocations With malloc_history</h2><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_106"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_107"></a><p>The <code>malloc_history</code> tool displays backtrace data showing exactly where your program made calls to the <code>malloc</code> and <code>free</code> functions. If you specify an address when calling <code>malloc_history</code>, the tool tracks memory allocations occurring at that address only. If you specify the <code>-all_by_size</code> or <code>-all_by_count</code> options, the tool displays all allocations, grouping frequent allocations together. </p><p>Before using the <code>malloc_history</code> tool on your program, you must first enable the malloc library logging features by setting the <code>MallocStackLogging</code><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_108"></a> to <code>1</code>. You may also want to set the <code>MallocStackLoggingNoCompact</code><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_109"></a> environment variable to retain information about freed blocks. For more information on these variables, see <span class="content_text"><a href="MallocDebug.html#//apple_ref/doc/uid/20001884-CJBJFIDD">“Enabling the Malloc Debugging Features.”</a></span></p><p>The <code>malloc_history</code> tool is best used in situations where you need to find the previous owner of a block of memory. If you determine that a particular data is somehow becoming corrupted, you can put checks into your code to print the address of the block when the corruption occurs. You can then use <code>malloc_history</code> to find out who owns the block and identify any stale pointers.</p><p>The <code>malloc_history</code> tool is also suited for situations where Sampler or MallocDebug cannot be used. For example, you might use this tool from a remote computer or in situations where you want a minimal impact on the behavior of your program.</p><p>For more information on using <code>malloc_history</code>, see the man pages.</p><a name="//apple_ref/doc/uid/20001882-97995" title="Observing Allocations With ObjectAlloc"></a><a name="//apple_ref/doc/uid/20001882-97995-TPXREF162" title="Observing Allocations With ObjectAlloc"></a><h2>Observing Allocations With ObjectAlloc</h2><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_110"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_111"></a><p>ObjectAlloc allows you to observe memory allocation activity in an application. It shows you the allocations in terms of the number of objects created, rather than where the allocations occurred. Its real-time histograms allow you to directly perceive changes and trends in object counts. It also retains a history of allocations and deallocations, allowing you to identify overall allocation trends.</p><p>The information displayed by ObjectAlloc is recorded by an allocation statistics facility built into the Core Foundation framework. When this facility is active, every allocation and deallocation is recorded as it happens. For <a name="//apple_ref/doc/uid/20001882-DontLinkElementID_112"></a>Objective-C objects, copy, retain, release, and autorelease are recorded.</p><a name="//apple_ref/doc/uid/20001882-98021" title="Using ObjectAlloc"></a><a name="//apple_ref/doc/uid/20001882-98021-TPXREF163" title="Using ObjectAlloc"></a><h3>Using ObjectAlloc</h3><p>When you first launch ObjectAlloc, it asks you to choose the application you want to inspect. After selecting the application, ObjectAlloc displays the main window so that you can launch the application and start gathering data. The main window contains several buttons for controlling the launch and execution of the application, as well as for setting mark points from which to examine data. <span class="content_text"><a href="FindingPatterns.html#//apple_ref/doc/uid/20001882-106260-BCIHAEEA">Figure 5</a></span> shows the ObjectAlloc main window.</p><br/><div><a name="//apple_ref/doc/uid/20001882-106260-BCIHAEEA" title="Figure 5ObjectAlloc window "></a><p><a name="//apple_ref/doc/uid/20001882-106260" title="Figure 5ObjectAlloc window "></a><strong>Figure 5&nbsp;&nbsp;</strong>ObjectAlloc window </p><img src = "art/objectalloc.gif" alt = "ObjectAlloc window" width="322" height="384"></div><br/><p>When you click the Start button, ObjectAlloc launches the application and starts displaying object allocation data as it occurs. You can use the buttons along the top of the window to control the gathering and display of collection data. If you want to view past allocations, you must pause or stop the data gathering process before using the controls to step forward or backward through the allocation history. You can use the slider control just under the buttons to watch changes in allocation counts over time.</p><p>The Mark button sets a starting point from which to watch allocations. This starting point is a convenience that lets you view allocations over a more recent period of time. Use the “Show since mark” checkbox to toggle between displaying events that occurred since the mark was set and displaying events that occurred since the application was launched. </p><div class="notebox"><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_7" title="Note"></a><p><strong>Note:</strong>&nbsp;Due to the sheer quantity of information being processed, updating the ObjectAlloc main window can slow the system down noticeably. Uncheck the “Live update” checkbox to update the display only when the ObjectAlloc window is activated or deactivated. </p></div><a name="//apple_ref/doc/uid/20001882-106295" title="Browsing Global Allocations"></a><a name="//apple_ref/doc/uid/20001882-106295-TPXREF164" title="Browsing Global Allocations"></a><h4>Browsing Global Allocations</h4><p>The Global Allocations tab contains a table with a listing of all memory blocks ever allocated in the application. The Category column shows the type of the memory block—either an Objective-C class name or a Core Foundation object name. If ObjectAlloc cannot deduce type information for the block, it uses “GeneralBlock-” followed by the size of the block (in bytes).The Current column shows the number of blocks of each type allocated but not (yet) released. The Peak column shows the largest number of blocks of each type that existed at any given time. The Total column shows the total number of blocks of each type that have been allocated, including blocks that have since been released.</p><p>The histogram bars to the right of the Total column are graphical representations of the three columns: the dark portion of the bar indicates the Current value, the middle portion of the bar is the additional number under Peak, and the complete length of the bar indicates the value under Total. The Scale slider controls the number of objects represented by each pixel in a bar (the actual number is shown to the right of the bar).</p><p>The “Counts are bytes” checkbox changes the numbers in the Current, Peak, and Total columns to reflect the number of bytes allocated (per object type) instead of the number of objects allocated (per object type).</p><a name="//apple_ref/doc/uid/20001882-98100" title="Browsing Object Instances"></a><a name="//apple_ref/doc/uid/20001882-98100-TPXREF165" title="Browsing Object Instances"></a><h4>Browsing Object Instances</h4><p>The Instance Browser tab lists each type of block. Clicking a block type displays a list of all instances of that block. Clicking the address of a block instance displays a list of all allocation events pertaining to that block, including allocation, retain, release, autorelease, and free events. If the block has not yet been freed, the contents of the block are displayed in the bottom pane of the ObjectAlloc window. Clicking an event brings up a textual description of the event, including a function call stack.</p><a name="//apple_ref/doc/uid/20001882-98114" title="Browsing Call Stacks"></a><a name="//apple_ref/doc/uid/20001882-98114-TPXREF166" title="Browsing Call Stacks"></a><h4>Browsing Call Stacks</h4><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_113"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_114"></a><p>The Call Stacks tab displays a table of each block type along with the number of instances (Count) and the number of bytes allocated to those instances (Size). The furthest-right column of this table contains the first item of a hierarchical function call tree. Clicking the disclosure triangle displays the next level of the function call stack. When the function call stack is open, it displays the location of each allocation.</p><p>The Descend Unique Path button discloses the selected function call stack to the deepest function shared by each instance’s function call stack. The Descend Max Path button discloses the selected function call stack to the deepest function in the stack.</p><a name="//apple_ref/doc/uid/20001882-105858" title="Interpreting ObjectAlloc Data"></a><h3>Interpreting ObjectAlloc Data</h3><p>Here are some general guidelines for interpreting the data reported by ObjectAlloc:</p><ul class="spaceabove"><li class="li"><p>Does the number of instantiated objects match your expectations? If not, you might be creating more temporary objects than anticipated.</p></li><li class="li"><p>Examine the relationships between different objects. If you allocate one custom object, did you expect to see several other objects created along with it?</p></li><li class="li"><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_115"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_116"></a><p>Examine the colored bars in the allocation graph. Large differences between the peak and current allocations (or between the total and current allocations) indicate a surge in allocations. This could reflect a large number of autoreleased objects needing to be released earlier from a loop.</p></li></ul><a name="//apple_ref/doc/uid/20001882-103964" title="Examining Heaps With the heap Tool"></a><a name="//apple_ref/doc/uid/20001882-103964-TPXREF151" title="Examining Heaps With the heap Tool"></a><h2>Examining Heaps With the heap Tool</h2><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_117"></a><a name="//apple_ref/doc/uid/20001882-DontLinkElementID_118"></a><p>The <code>heap</code> tool displays a snapshot of the memory allocated by the malloc library and located in the address space of a specified process. For Cocoa applications, this tool identifies Objective-C objects by name; For both memory blocks and objects, the tool organizes the information by heap, showing all items in the same heap together. </p><p>The <code>heap</code> tool provides much of the same information as the ObjectAlloc application, but does so in a much less intrusive manner. You can use this tool from a remote session or in situations where the use of ObjectAlloc might slow the system down enough to affect the resulting output.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="MemoryAlloc.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="FindingLeaks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-06-28<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingPatterns.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingPatterns.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingPatterns.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
