<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Handling Recognition Notifications</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING16></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="srec-15.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="srec-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="srec-87.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="srec-17.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="srec-2.html"><B>Speech Recognition Manager</B></A> / <BR><DD><A HREF="srec-4.html"><B>Chapter 1 - Speech Recognition Manager</B></A> / <A HREF="srec-9.html"><B>Using the Speech Recognition Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING16-0></A>
<H2><A NAME=MARKER-9-126></A>Handling Recognition Notifications</H2>
 By default, a recognizer sends recognition notifications to your application's Apple event handler. If you wish, you can instruct a recognizer to send notifications to a speech recognition callback routine. See <A HREF=#MARKER-9-136>"Using Callback Routines" on page 1-28</A> for information on using callback routines.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>You should use an Apple event handler to receive and process recognition notifications, unless your software is not an application (for example, a control panel or other software that cannot easily accept Apple events).<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You need to specify to the recognizer what events you want to be notified about. By default, your application is notified when the recognizer has finished recognizing an utterance. You can also be notified when the recognizer begins the process of recognizing an utterance (that is, when the user begins speaking). You do this by setting the notification property of a recognizer, as shown in <A HREF=#MARKER-9-129>Listing 1-9</A>.<P>
<B>Listing 1-9  <A NAME=MARKER-9-129></A>Requesting notification of a recognition beginning</B><P>
<PRE>
unsigned long myFlags;

myFlags = kSRNotifyRecognitionBeginning | kSRNotifyRecognitionDone;
myErr = SRSetProperty(gRecognizer, kSRNotificationParam, 
                                 &amp;myFlags, sizeof(myFlags));
</PRE>
<DL>
<DT><B>IMPORTANT</B>
<DD>If you enable recognizer notification for the beginning of a recognition, then each time your application receives a recognition notification, you <I>must</I> call either <CODE>SRContinueRecognition</CODE> or <CODE>SRCancelRecognition</CODE> before speech recognition can continue. Otherwise, the recognizer will suspend its operations while waiting for you to call one of these functions.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 In general, you need to receive <CODE>kSRNotifyRecognitionBeginning</CODE> notifications only if you want to update or modify the active language model according to context at the start of each utterance.<P>
<A NAME=HEADING16-8></A>
<H3>Using Apple Events</H3>
 <A NAME=MARKER-2-132></A>By default, the Speech Recognition Manager uses Apple events to inform your application of recognizer events. To receive notifications through Apple events, you need to install Apple event handlers for the events in the speech suite during application startup, as illustrated in <A HREF=#MARKER-9-133>Listing 1-10</A>.<P>
<B>Listing 1-10  <A NAME=MARKER-9-133></A>Installing an Apple event handler for speech events</B><P>
<PRE>
myErr = AEInstallEventHandler(kAESpeechSuite, kAESpeechDetected,
            NewAEEventHandlerProc(MyHandleSpeechDetected), 0, FALSE);
if (!myErr) 
   myErr = AEInstallEventHandler(kAESpeechSuite, kAESpeechDone,
            NewAEEventHandlerProc(MyHandleSpeechDone), 0, FALSE);
</PRE>
 <A HREF=#MARKER-9-134>Listing 1-11</A> illustrates how to respond to a recognizer notification of type <CODE>kSRNotifyRecognitionDone</CODE> sent to an Apple event handler.<P>
<B>Listing 1-11  <A NAME=MARKER-9-134></A>Handling recognition done notifications with an Apple event handler</B><P>
<PRE>
pascal OSErr MyHandleSpeechDone (AppleEvent *theAEevt, AppleEvent *reply, long refcon)
{
   long                 actualSize;
   DescType             actualType;
   OSErr                recStatus = 0, myErr = noErr
   SRRecognitionResult  recResult;
   SRRecognizer         myRec;

   /* Get recognition result status and recognizer. */
   myErr = AEGetParamPtr(theAEevt, keySRSpeechStatus, typeShortInteger,
            &amp;actualType, (Ptr)&amp;recStatus, sizeof(recStatus), &amp;actualSize);
   if (!myErr)
      myErr = recStatus;

   if (!myErr) {
      myErr = AEGetParamPtr(theAEevt, keySRRecognizer, typeSRRecognizer, 
            &amp;actualType, (Ptr)&amp;myRec, sizeof(myRec), &amp;actualSize);

      if (!myErr) {
         myErr = AEGetParamPtr(theAEevt, keySRSpeechResult, typeSRSpeechResult,
               &amp;actualType, (Ptr)&amp;recResult, sizeof(recResult), &amp;actualSize);
         if (!myErr) {
            /* Process the recognition result here.*/
            MyProcessRecognitionResult(recResult);
            SRReleaseObject(recResult);
         }
      }
   }

   return(myErr);
}
</PRE>
 <A HREF=#MARKER-9-135>Listing 1-12</A> illustrates how to respond to a recognition notification of type <CODE>kSRNotifyRecognitionBeginning</CODE> sent to an Apple event handler.<P>
<B>Listing 1-12  <A NAME=MARKER-9-135></A>Handling recognition beginning notifications with an Apple event handler</B><P>
<PRE>
pascal OSErr MyHandleSpeechDetected (AppleEvent *theAEevt, 
                                    AppleEvent *reply, long refcon)
{
   OSErr       myErr = noErr, recStatus = 0;
   DescType    actualType;
   long        actualSize;
   SRRecognizermyRec;

   /* Get status and recognizer. */
   myErr = AEGetParamPtr(theAEevt, keySRSpeechStatus, typeShortInteger,
               &amp;actualType, (Ptr)&amp;recStatus, sizeof(recStatus), &amp;actualSize);
   if (!myErr)
      myErr = recStatus;

   if (!myErr) {
      myErr = AEGetParamPtr(theAEevt, keySRRecognizer, typeSRRecognizer, 
                  &amp;actualType, (Ptr)&amp;myRec, sizeof(myRec), &amp;actualSize);
      if (!myErr) {
         /* The user has started speaking. We can adjust the language model */
         /* to reflect the current context. Then we must call either */
         /* SRContinueRecognition or SRCancelRecognition. */
         
         myErr = SRContinueRecognition(myRec);
      }
   }
   
   return(myErr);
}
</PRE>
<A NAME=HEADING16-18></A>
<H3><A NAME=MARKER-9-136></A>Using Callback Routines</H3>
 To instruct a recognizer to send notifications using a speech recognition callback routine instead of using Apple events, you set the <CODE>kSRCallBackParam</CODE> property of the recognizer to the address of a <B>callback routine parameter structure,</B> which specifies the address of your callback routine, as shown in <A HREF=#MARKER-9-139>Listing 1-13</A>.<A NAME=MARKER-2-138></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>You should use an Apple event handler to receive and process recognition notifications, unless your software cannot easily accept Apple events.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Listing 1-13  <A NAME=MARKER-9-139></A>Installing a speech recognition callback routine</B><P>
<PRE>
pascal OSErr MyInstallSRCallBack (void)
{
   SRCallBackParam      myCallBackPB;
   
   myCallBackPB.callBack = NewSRCallBackProc(MySRCallBack);
   
   return SRSetProperty(gRecognizer, kSRCallBackParam, 
                        &amp;myCallBackPB, sizeof(myCallBackPB));
}
</PRE>
<DL>
<DT><B>Note</B>
<DD>See <A HREF=srec-34.html#MARKER-9-294>page 1-51</A> for details on the callback routine parameter structure (of type <CODE>SRCallBackParam</CODE>).<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 You can remove a speech recognition callback routine, as shown in <A HREF=#MARKER-9-140>Listing 1-14</A>.<P>
<B>Listing 1-14  <A NAME=MARKER-9-140></A>Removing a speech recognition callback routine</B><P>
<PRE>
pascal void MyRemoveSRCallBack (void)
{
   SRCallBackParam      myCallBackPB;
   SRCallBackUPP        mySavedCallBack;
   Size                 myLen;
   OSErr                myErr = noErr;
   
   myLen = sizeof(myCallBackPB);
   myErr = SRGetProperty(gRecognizer, kSRCallBackParam, 
                        &amp;myCallBackPB, &amp;myLen);
   if (myErr == noErr) {
      if (myCallBackPB.callBack != nil) {
         mySavedCallBack = myCallBackPB.callBack;
         myCallBackPB.callBack = nil;
         myErr = SRSetProperty(gRecognizer, kSRCallBackParam, 
                        &amp;myCallBackPB, sizeof(myCallBackPB));
         DisposeRoutineDescriptor(mySavedCallBack);
      }
   }
}
</PRE>
<DL>
<DT><B>IMPORTANT</B>
<DD>You should not call any Speech Recognition Manager routines other than <CODE>SRContinueRecognition</CODE> or <CODE>SRCancelRecognition</CODE> in your speech recognition callback routine. Usually, your callback routine should simply queue the notification it receives for later processing by your software (for instance, when you receive background processing time).<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You can queue the notification by setting a global flag that indicates the recognition result to process, as shown in <A HREF=#MARKER-9-141>Listing 1-15</A>.<P>
<B>Listing 1-15  <A NAME=MARKER-9-141></A>Handling notifications with a callback routine</B><P>
<PRE>
SRRecognitionResultgLastRecResult;/* last rec result received */

pascal void MySRCallBack (SRCallBackStruct *param)
{
   OSErr             myErr = param-&gt;status;
   
   if (!myErr) {
      /* Handle recognition beginning event. */
      /* Here we just continue speech recognition. */
      if ((param-&gt;what) &amp; kSRNotifyRecognitionBeginning) {
         SRRecognizermyRec = (SRRecognizer) (param-&gt;instance);

         myErr = SRContinueRecognition(myRec);
   }
      /* Handle recognition done event. */
      /* Here we save the rec result in gLastRecResult. */
      /* At idle time in our event loop, if gLastRecResult != NULL, */
      /* we call MyHandleRecognitionResult(gLastRecResult) */
   else if (param-&gt;what &amp; kSRNotifyRecognitionDone) {
      SRRecognitionResult myResult = 
                        (SRRecognitionResult) (param-&gt;message);
      if (myResult)
         gLastRecResult = myResult;
         /* Note that we might get more than one result  */
         /* before we get to our idle check,  */
         /* so we should really be putting this in a queue. */
      }
   }
}
</PRE>
 The <CODE>MySRCallBack</CODE> function simply determines what event prompted the recognition notification and sets a global flag to signal the application to do the correct thing (for example, process the recognition result). Your application needs to examine that flag periodically to determine whether to handle the result. <A HREF=#MARKER-9-142>Listing 1-16</A> shows an example of a routine that does this.<P>
<B>Listing 1-16  <A NAME=MARKER-9-142></A>Checking whether a recognition result needs processing</B><P>
<PRE>
pascal void MyIdleCheckForSpeechResult (void)
{
   if (gLastRecResult != NULL)
      MyProcessRecognitionResult(gLastRecResult);
   
   gLastRecResult = NULL;
}
</PRE>
 If a recognition result is pending, the application calls its routine to handle recognition results, <CODE>MyProcessRecognitionResult</CODE> (defined in the next section).<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>See <A HREF=srec-83.html#MARKER-9-447>"Speech Recognition Callback Routines" on page 1-85</A> for a complete description of the limitations of using callback routines.<EM></EM><A NAME=MARKER-2-145></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="srec-15.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="srec-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="srec-87.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="srec-17.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="srec-3.html">&copy; Apple Computer, Inc.</A><br>22 JAN 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
