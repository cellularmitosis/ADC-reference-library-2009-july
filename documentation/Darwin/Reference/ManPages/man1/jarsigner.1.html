<html><head><title>Mac OS X Developer Tools
 Manual Page For jarsigner(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/jarsigner" title="Mac OS X Developer Tools
 Manual Page for jarsigner(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/jarsigner"; name=jarsigner(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac&nbsp;OS&nbsp;X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>

<p style='text-align:justify;'>This manual page is associated with the Mac&nbsp;OS&nbsp;X
developer tools.  The software or headers described may not be present on your
Mac&nbsp;OS&nbsp;X installation until you install the developer tools
package.  This package is available on your Mac&nbsp;OS&nbsp;X installation DVD,
and the latest versions can be downloaded from
<a href="http://developer.apple.com/tools/download/">developer.apple.com</a>.</p>

<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
jarsigner(1)                                                                                    jarsigner(1)



<b>NAME</b>
       jarsigner - JAR signing and verification tool

<b>SYNOPSIS</b>
       <b>jarsigner</b> [ <u>options</u> ] <u>jar-file</u> <u>alias</u>
       <b>jarsigner</b> <b>-verify</b> [ <u>options</u> ] <u>jar-file</u> <u>alias</u>

<b>DESCRIPTION</b>
       The <b>jarsigner</b> tool is used for two purposes:

       1.   to sign Java ARchive (JAR) files, and

       2.   to verify the signatures and integrity of signed JAR files.

       The  JAR  feature  enables  the packaging of class files, images, sounds, and other digital data in a
       single file for faster and easier distribution. A tool named <b>jar</b> enables developers  to  produce  JAR
       files.

       A digital signature is a string of bits that is computed from some data (the data being "signed") and
       the private key of an entity (a person, company, etc.). Like a handwritten signature, a digital  sig-<font color="#ffffff" class="whiteout">nature&nbsp;signature</font>
       nature has many useful characteristics:

        Its  authenticity  can be verified, via a computation that uses the public key corresponding to the
         private key used to generate the signature.

        It cannot be forged, assuming the private key is kept secret.

        It is a function of the data signed and thus can't be claimed to be the signature for other data as
         well.

        The  signed  data cannot be changed; if it is, the signature will no longer verify as being authen-<font color="#ffffff" class="whiteout">tic.&nbsp;authentic.</font>
         tic.

       In order for an entity's signature to be generated for a file, the entity  must  first  have  a  pub-<font color="#ffffff" class="whiteout">lic/private&nbsp;public/private</font>
       lic/private  key pair associated with it, and also one or more certificates authenticating its public
       key. A certificate is a digitally signed statement from one entity, saying that  the  public  key  of
       some other entity has a particular value.

       <b>jarsigner</b> uses key and certificate information from a keystore to generate digital signatures for JAR
       files. A keystore is a database of private keys and their associated X.509 certificate chains authen-<font color="#ffffff" class="whiteout">ticating&nbsp;authenticating</font>
       ticating  the  corresponding  public  keys. The <b>keytool</b> utility is used to create and administer key-<font color="#ffffff" class="whiteout">stores.&nbsp;keystores.</font>
       stores.

       <b>jarsigner</b> uses an entity's private key to generate a signature.  The signed JAR file contains,  among
       other  things,  a  copy  of the certificate from the keystore for the public key corresponding to the
       private key used to sign the file.  <b>jarsigner</b> can verify the digital signature of the signed JAR file
       using the certificate inside it (in its signature block file).

       At  this time, <b>jarsigner</b> can only sign JAR files created by the JDK <b>jar</b> tool or zip files. (JAR files
       are the same as zip files, except they also have a <b>META-INF/MANIFEST.MF</b> file. Such a file will  auto-<font color="#ffffff" class="whiteout">matically&nbsp;automatically</font>
       matically be created when <b>jarsigner</b> signs a zip file.)

       The  default <b>jarsigner</b> behavior is to sign a JAR file. Use the <b>-verify</b> option to instead have it ver-<font color="#ffffff" class="whiteout">ify&nbsp;verify</font>
       ify a signed JAR file.

   <b>Compatibility</b> <b>with</b> <b>JDK</b> <b>1.1</b>
       The <b>keytool</b> and <b>jarsigner</b> tools completely replace the <b>javakey</b> tool provided in JDK  1.1.  These  new
       tools  provide  more features than <b>javakey</b>, including the ability to protect the keystore and private
       keys with passwords, and the ability to verify signatures in addition to generating them.

       The new keystore architecture replaces the identity database that <b>javakey</b> created and managed.  There
       is  no backwards compatibility between the keystore format and the database format used by <b>javakey</b> in
       1.1. However:

        It is possible to import the information from an identity database into a keystore, via the <b>keytool</b>
         <b>-identitydb</b> command

        <b>jarsigner</b> can sign JAR files also previously signed using <b>javakey</b>

        <b>jarsigner</b>  can  verify  JAR files signed using <b>javakey</b> Thus, it recognizes and can work with signer
         aliases that are from a JDK 1.1 identity database rather than a JDK 1.2 keystore.

       The following table explains how JAR files that were signed in JDK 1.1.x are treated in  the  Java  2
       Platform.


                                <b>Trusted</b>
                               <b>Identity</b>
                               <b>imported</b>     <b>Policy</b> <b>File</b>
       <b>JAR</b> <b>File</b>  <b>Identity</b> <b>in</b>   <b>into</b> <b>1.2</b>       <b>grants</b>        <b>Privileges</b>
         <b>Type</b>   <b>1.1</b> <b>database</b>   <b>keystore</b>    <b>privileges</b> <b>to</b>     <b>Granted</b>
                               <b>from</b> <b>1.1</b>   <b>Identity/Alias</b>
                               <b>database</b>
                                  <b>(4)</b>

       <b>Signed</b>                                             <b>Default</b>
       <b>JAR</b>      <b>NO</b>            <b>NO</b>         <b>NO</b>               <b>privaleges</b>
                                                          <b>granted</b> <b>to</b>
                                                          <b>all</b> <b>code.</b>

       <b>Unsigned</b>                                           <b>Default</b>
       <b>JAR</b>      <b>NO</b>            <b>NO</b>         <b>NO</b>               <b>privileges</b>
                                                          <b>granted</b> <b>to</b>
                                                          <b>all</b> <b>code.</b>

       <b>Signed</b>                                             <b>Default</b>
       <b>JAR</b>      <b>NO</b>            <b>YES</b>        <b>NO</b>               <b>privileges</b>
                                                          <b>granted</b> <b>to</b>
                                                          <b>all</b> <b>code.</b>

       <b>Signed</b>                                             <b>Default</b>
       <b>JAR</b>      <b>YES/Untrusted</b> <b>NO</b>         <b>NO</b>               <b>privileges</b>
                                                          <b>granted</b> <b>to</b>
                                                          <b>all</b> <b>code.</b> <b>(3)</b>

       <b>Signed</b>                                             <b>Default</b>
       <b>JAR</b>      <b>YES/Untrusted</b> <b>NO</b>         <b>YES</b>              <b>privileges</b>
                                                          <b>granted</b> <b>to</b>
                                                          <b>all</b> <b>code.</b>
                                                          <b>(1,3)</b>

       <b>Signed</b>                                             <b>Default</b>
       <b>JAR</b>      <b>NO</b>            <b>YES</b>        <b>YES</b>              <b>privileges</b>
                                                          <b>granted</b> <b>to</b>
                                                          <b>all</b> <b>code</b> <b>plus</b>
                                                          <b>privileges</b>
                                                          <b>granted</b> <b>in</b>
                                                          <b>policy</b> <b>file.</b>

       <b>Signed</b>                                             <b>Default</b>
       <b>JAR</b>      <b>YES/Trusted</b>   <b>YES</b>        <b>YES</b>              <b>privileges</b>
                                                          <b>granted</b> <b>to</b>
                                                          <b>all</b> <b>code</b> <b>plus</b>
                                                          <b>privileges</b>
                                                          <b>granted</b> <b>in</b>
                                                          <b>policy</b> <b>file.</b>
                                                          <b>(2)</b>

       <b>Signed</b>                                             <b>All</b>
       <b>JAR</b>      <b>YES/Trusted</b>   <b>NO</b>         <b>NO</b>               <b>privileges</b>

       <b>Signed</b>                                             <b>All</b>
       <b>JAR</b>      <b>YES/Trusted</b>   <b>YES</b>        <b>NO</b>               <b>privileges</b>
                                                          <b>(1)</b>

       <b>Signed</b>                                             <b>All</b>
       <b>JAR</b>      <b>YES/Trusted</b>   <b>NO</b>         <b>YES</b>              <b>privileges</b>
                                                          <b>(1)</b>


       Notes:

       1.   If  an identity/alias is mentioned in the policy file, it must be imported into the keystore for
            the policy file to have any effect on privileges granted.

       1.   If an identity/alias is mentioned in the policy file, it must be imported into the keystore  for
            the policy file to have any effect on privileges granted.

       2.   The  policy  file/keystore  combination  has  precedence over a trusted identity in the identity
            database.

       3.   Untrusted identities are ignored in the Java 2 platform.

       4.   Only trusted identities can be imported into Java 2 SDK keystores.

   <b>Keystore</b> <b>Aliases</b>
       All keystore entities are accessed via unique aliases.

       When using <b>jarsigner</b> to sign a JAR file, you must specify the alias for the keystore entry containing
       the  private  key needed to generate the signature. For example, the following will sign the JAR file
       named <b>MyJARFile.jar</b>, using the private key associated with the alias <b>duke</b> in the keystore named  <b>mys</b>-<font color="#ffffff" class="whiteout">tore&nbsp;mystore</font>
       <b>tore</b>  in the "working" directory. Since no output file is specified, it overwrites <b>MyJARFile.jar</b> with
       the signed JAR file.

       <b>jarsigner</b> <b>-keystore</b> <b>/working/mystore</b> <b>-storepass</b>
          <b>myspass</b> <b>-keypass</b> <b>dukekeypasswd</b> <b>MyJARFile.jar</b> <b>duke</b>

       Keystores are protected with a password, so the store password (in this case <b>myspass</b>) must be  speci-<font color="#ffffff" class="whiteout">fied.&nbsp;specified.</font>
       fied.  You  will  be  prompted for it if you don't specify it on the command line. Similarly, private
       keys are protected in a keystore with a password,  so  the  private  key's  password  (in  this  case
       <b>dukekeypasswd</b>) must be specified, and you will be prompted for it if you don't specify it on the com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
       mand line and it isn't the same as the store password.

   <b>Keystore</b> <b>Location</b>
       <b>jarsigner</b> has a <b>-keystore</b> option for specifying the name and location of the keystore to be used. The
       keystore  is  by default stored in a file named <b>.keystore</b> in the user's home directory, as determined
       by the <b>user.home</b> system property.

       Note that the input stream from the -keystore option is passed to the <b>KeyStore.load</b> method.  If  NONE
       is  specified  as  the  URL, then a null stream is passed to the <b>KeyStore.load</b> method. NONE should be
       specified if the KeyStore is not file-based, for example, if it resides on a hardware token device.

   <b>Keystore</b> <b>Implementation</b>
       The KeyStore class provided in the <b>java.security</b> package supplies well-defined interfaces  to  access
       and  modify the information in a keystore. It is possible for there to be multiple different concrete
       implementations, where each implementation is that for a particular type of keystore.

       Currently, there are two command-line tools that make use of <b>KeyStore</b>:  <b>keytool</b>  and  <b>jarsigner</b>,  and
       also  a  GUI-based  tool named <b>policytool</b>.  Since <b>KeyStore</b> is publicly available, JDK users can write
       additional security applications that use it.

       There is a built-in default implementation, provided by Sun Microsystems. It implements the  keystore
       as  a  file, utilizing a proprietary keystore type (format) named "JKS". It protects each private key
       with its individual password, and also protects the integrity of the entire keystore with a (possibly
       different) password.

       Keystore  implementations  are provider-based. More specifically, the application interfaces supplied
       by <b>KeyStore</b> are implemented in terms of a "Service Provider Interface" (SPI). That  is,  there  is  a
       corresponding  abstract  <b>KeystoreSpi</b> class, also in the <b>java.security</b> package, which defines the Ser-<font color="#ffffff" class="whiteout">vice&nbsp;Service</font>
       vice Provider Interface methods that "providers" must implement. (The term  "provider"  refers  to  a
       package  or  a set of packages that supply a concrete implementation of a subset of services that can
       be accessed by the Java Security API.) Thus, to  provide  a  keystore  implementation,  clients  must
       implement  a provider and supply a <b>KeystoreSpi</b> subclass implementation, as described in <u>How</u> <u>to</u> <u>Imple</u>-<font color="#ffffff" class="whiteout">ment&nbsp;Implement</font>
       <u>ment</u> <u>a</u> <u>Provider</u> <u>for</u> <u>the</u> <u>Java</u> <u>Cryptography</u> <u>Architecture</u>.

       Applications can choose different types of keystore implementations from different  providers,  using
       the  <b>getInstance</b>  factory  method supplied in the <b>KeyStore</b> class. A keystore type defines the storage
       and data format of the keystore information, and the algorithms used to protect private keys  in  the
       keystore  and  the  integrity of the keystore itself. Keystore implementations of different types are
       not compatible.

       <b>keytool</b> works on any file-based keystore implementation.  (It treats the  keytore  location  that  is
       passed  to  it  at the command line as a filename and converts it to a <b>FileInputStream</b>, from which it
       loads the keystore information.) The <b>jarsigner</b> and <b>policytool</b> tools, on the other hand,  can  read  a
       keystore from any location that can be specified using a URL.

       For  <b>jarsigner</b>  and  <b>keytool</b>, you can specify a keystore type at the command line, via the <b>-storetype</b>
       option. For <b>policytool</b>, you can specify a keystore type via the "Change Keystore" command in the Edit
       menu.

       If  you  don't  explicitly  specify a keystore type, the tools choose a keystore implementation based
       simply on the value of the <b>keystore.type</b> property specified in the  security  properties  file.   The
       security  properties  file  is called <b>java.security</b>, and it resides in the security properties direc-<font color="#ffffff" class="whiteout">tory,&nbsp;directory,</font>
       tory, <b>java.home/lib/security</b>, where <b>java.home</b> is the runtime environment's directory (the jre  direc-<font color="#ffffff" class="whiteout">tory&nbsp;directory</font>
       tory in the SDK or the top-level directory of the Java 2 Runtime Environment).

       Each  tool gets the <b>keystore.type</b> value and then examines all the currently-installed providers until
       it finds one that implements keystores of that type. It then uses the  keystore  implementation  from
       that provider.

       The  <b>KeyStore</b>  class  defines a static method named <b>getDefaultType</b> that lets applications and applets
       retrieve the value of the <b>keystore.type</b> property. The following line of code creates an  instance  of
       the default keystore type (as specified in the <b>keystore.type</b> property):

            <b>KeyStore</b> <b>keyStore</b> <b>=</b> <b>KeyStore.getInstance(KeyStore.getDefaultType());</b>

       The  default  keystore type is "jks" (the proprietary type of the keystore implementation provided by
       Sun). This is specified by the following line in the security properties file:

            <b>keystore.type=jks</b>

       To have the tools utilize a keystore implementation other than the default, change that line to spec-<font color="#ffffff" class="whiteout">ify&nbsp;specify</font>
       ify a different keystore type.

       For  example,  if  you have a provider package that supplies a keystore implementation for a keystore
       type called "pkcs12", change the line to

       <b>keystore.type=pkcs12</b>

       Note: case doesn't matter in keystore type designations.  For example, "JKS" would be considered  the
       same as "jks".

   <b>Supported</b> <b>Algorithms</b> <b>and</b> <b>Key</b> <b>Sizes</b>
       At this time, <b>jarsigner</b> can sign a JAR file using either

        DSA (Digital Signature Algorithm) with the SHA-1 digest algorithm, or

        the RSA algorithm with the MD5 digest algorithm.

       That is, if the signer's public and private keys are DSA keys, <b>jarsigner</b> will attempt to sign the JAR
       file using the SHA-1/DSA algorithm. If the signer's keys are RSA keys, <b>jarsigner</b> will  sign  the  JAR
       file  using  the MD5/RSA algorithm. This is only possible if there is a statically installed provider
       supplying an implementation for the MD5/RSA algorithm. (There is always a SHA-1/DSA algorithm  avail-<font color="#ffffff" class="whiteout">able,&nbsp;available,</font>
       able, from the default "SUN" provider.)


   <b>The</b> <b>Signed</b> <b>JAR</b> <b>File</b>
       When  <b>jarsigner</b>  is  used  to  sign a JAR file, the output signed JAR file is exactly the same as the
       input JAR file, except that it has two additional files placed in the <b>META-INF</b> directory:

        a signature file, with a <b>.SF</b> extension, and

        a signature block file, with a <b>.DSA</b> extension.

       The base file names for these two files come from the value of the <b>-sigFile</b> option. For  example,  if
       the option appears as

       <b>-sigFile</b> <b>MKSIGN</b>

       the files are named <b>MKSIGN.SF</b> and <b>MKSIGN.DSA</b>.

       If no <b>-sigfile</b> option appears on the command line, the base file name for the <b>.SF</b> and <b>.DSA</b> files will
       be the first 8 characters of the alias name specified on the command line,  all  converted  to  upper
       case.  If  the alias name has fewer than 8 characters, the full alias name is used. If the alias name
       contains any characters that are not allowed in a signature file name, each such  character  is  con-<font color="#ffffff" class="whiteout">verted&nbsp;converted</font>
       verted  to  an underscore ("_") character in forming the file name. Legal characters include letters,
       digits, underscores, and hyphens.

       The Signature (<b>.SF</b>) File

       A signature file (the <b>.SF</b> file) looks similar to the manifest file that is always included in  a  JAR
       file  generated by the <b>jar</b> tool. That is, for each source file included in the JAR file, the <b>.SF</b> file
       has three lines, just as in the manifest file, listing the following:

        the file name,

        the name of the digest algorithm used (SHA), and

        a SHA digest value.

       In the manifest file, the SHA digest value for each source file is the digest (hash)  of  the  binary
       data in the source file. In the <b>.SF</b> file, on the other hand, the digest value for a given source file
       is the hash of the three lines in the manifest file for the source file.

       The signature file also, by default, includes a header containing a hash of the whole manifest  file.
       The  presence of the header enables verification optimization, as described in JAR File Verification.

       The Signature Block (<b>.DSA</b>) File

       The <b>.SF</b> file is signed and the signature is placed in the <b>.DSA</b> file. The  <b>.DSA</b>  file  also  contains,
       encoded  inside it, a certificate authenticating the public key corresponding to the private key used
       for signing.


   <b>JAR</b> <b>File</b> <b>Verification</b>
       A successful JAR file verification occurs if the <!-- a -->signature(s)<!-- /a --> are valid, and none of the  files  that
       were  in the JAR file when the signatures were generated have been changed since then. JAR file veri-<font color="#ffffff" class="whiteout">fication&nbsp;verification</font>
       fication involves the following steps:

       1.   Verify the signature of the <b>.SF</b> file itself.

            That is, the verification ensures that the signature stored in each signature block (<b>.DSA</b>)  file
            was  in  fact  generated using the private key corresponding to the public key whose certificate
            also appears in the <b>.DSA</b> file. It also ensures that the signature is a valid  signature  of  the
            corresponding signature (<b>.SF</b>) file, and thus the <b>.SF</b> file has not been tampered with.

       2.   Verify  the  digest  listed in each entry in the <b>.SF</b> file with each corresponding section in the
            manifest.

            The <b>.SF</b> file by default includes a header containing a hash of the entire  manifest  file.  When
            the  header  is  present,  then the verification can check to see whether or not the hash in the
            header indeed matches the hash of the manifest file. If that is the case, verification  proceeds
            to the next step.

            If  that  is  not the case, a less optimized verification is required to ensure that the hash in
            each source file information section in the <b>.SF</b> file equals the hash of its  corresponding  sec-<font color="#ffffff" class="whiteout">tion&nbsp;section</font>
            tion in the manifest file (see The Signature (<b>.SF</b>) File).

            One reason the hash of the manifest file that is stored in the <b>.SF</b> file header may not equal the
            hash of the current manifest file would be because one or more files were added to the JAR  file
            (using  the  <b>jar</b>  tool)  after the signature (and thus the <b>.SF</b> file) was generated. When the <b>jar</b>
            tool is used to add files, the manifest file is changed (sections are added to it  for  the  new
            files),  but  the  <b>.SF</b> file is not. A verification is still considered successful if none of the
            files that were in the JAR file when the signature was generated have been changed  since  then,
            which  is  the case if the hashes in the non-header sections of the <b>.SF</b> file equal the hashes of
            the corresponding sections in the manifest file.

       3.   Read each file in the JAR file that has an entry in the <b>.SF</b> file.  While  reading,  compute  the
            file's  digest,  and  then compare the result with the digest for this file in the manifest sec-<font color="#ffffff" class="whiteout">tion.&nbsp;section.</font>
            tion. The digests should be the same, or verification fails.

       If any serious verification failures occur during the verification process, the  process  is  stopped
       and a security exception is thrown. It is caught and displayed by <b>jarsigner</b>.


   <b>Multiple</b> <b>Signatures</b> <b>for</b> <b>a</b> <b>JAR</b> <b>File</b>
       A JAR file can be signed by multiple people simply by running the <b>jarsigner</b> tool on the file multiple
       times, specifying the alias for a different person each time, as in:

       <b>jarsigner</b> <b>myBundle.jar</b> <b>susan</b>
       <b>jarsigner</b> <b>myBundle.jar</b> <b>kevin</b>

       When a JAR file is signed multiple times, there are multiple <b>.SF</b> and <b>.DSA</b> files in the resulting  JAR
       file,  one  pair  for  each signature. Thus, in the example above, the output JAR file includes files
       with the following names:

       <b>SUSAN.SF</b>
       <b>SUSAN.DSA</b>
       <b>KEVIN.SF</b>
       <b>KEVIN.DSA</b>

       Note: It is also possible for a JAR file to have mixed signatures, some  generated  by  the  JDK  1.1
       javakey tool and others by jarsigner. That is, jarsigner can be used to sign JAR files already previ-<font color="#ffffff" class="whiteout">ously&nbsp;previously</font>
       ously signed using javakey.

<b>OPTIONS</b>
       The various <b>jarsigner</b> options are listed and described below.  Note:

        All option names are preceded by a minus sign (-).

        The options may be provided in any order.

        Items in italics (option values) represent the actual values that must be supplied.

        The <b>-keystore</b>, <b>-storepass</b>, <b>-keypass</b>, <b>-sigfile</b>, and <b>-signedjar</b> options are only relevant when  sign-<font color="#ffffff" class="whiteout">ing&nbsp;signing</font>
         ing  a JAR file, not when verifying a signed JAR file. Similarly, an alias is only specified on the
         command line when signing a JAR file.

       <b>-keystore</b> <u>url</u>  Specifies the URL that tells the keystore location. This defaults to  the  file  <b>.key</b>-<font color="#ffffff" class="whiteout">store&nbsp;.keystore</font>
                      <b>store</b> in the user's home directory, as determined by the <b>user.home</b> system property.

                      A keystore is required when signing, so you must explicitly specify one if the default
                      keystore does not exist (or you want to use one other than the default).

                      A keystore is not required when verifying, but if one is  specified,  or  the  default
                      exists,  and  the <b>-verbose</b> option was also specified, additional information is output
                      regarding whether or not any of the certificates used to verify the JAR file are  con-<font color="#ffffff" class="whiteout">tained&nbsp;contained</font>
                      tained in that keystore.

                      Note:  the  <b>-keystore</b>  argument  can  actually be a file name (and path) specification
                      rather than a URL, in which case it will be treated the same as a  "file:"  URL.  That
                      is,

                      <b>-keystore</b> <b>filePathAndName</b>

                      is treated as equivalent to

                      <b>-keystore</b> <b>file:filePathAndName</b>


       <b>-storetype</b> <u>storetype</u>
                      Specifies  the  type  of keystore to be instantiated. The default keystore type is the
                      one that is specified as the value of the "keystore.type"  property  in  the  security
                      properties  file,  which is returned by the static <b>getDefaultType</b> method in <b>java.secu</b>-<font color="#ffffff" class="whiteout">rity.KeyStore.&nbsp;java.security.KeyStore.</font>
                      <b>rity.KeyStore</b>.

       <b>-storepass</b> <u>password</u>
                      Specifies the password which is required to access the keystore. This is  only  needed
                      when  signing  (not verifying) a JAR file. In that case, if a <b>-storepass</b> option is not
                      provided at the command line, the user is prompted for the password.

                      Note: The password shouldn't be specified on the command line or in a script unless it
                      is  for  testing purposes, or you are on a secure system. Also, when typing in a pass-<font color="#ffffff" class="whiteout">word&nbsp;password</font>
                      word at the password prompt, the password is echoed (displayed exactly as  typed),  so
                      be careful not to type it in front of anyone.

       <b>-keypass</b> <u>password</u>
                      Specifies the password used to protect the private key of the keystore entry addressed
                      by the alias specified on the command line. The password is required when  using  <b>jar</b>-<font color="#ffffff" class="whiteout">signer&nbsp;jarsigner</font>
                      <b>signer</b>  to  sign  a  JAR file. If no password is provided on the command line, and the
                      required password is different from the store password, the user is prompted for it.

                      Note: The password shouldn't be specified on the command line or in a script unless it
                      is  for  testing purposes, or you are on a secure system. Also, when typing in a pass-<font color="#ffffff" class="whiteout">word&nbsp;password</font>
                      word at the password prompt, the password is echoed (displayed exactly as  typed),  so
                      be careful not to type it in front of anyone.

       <b>-sigfile</b> <u>file</u>  Specifies  the  base  file  name  to be used for the generated <b>.SF</b> and <b>.DSA</b> files. For
                      example, if file is <b>DUKESIGN</b>, the generated <b>.SF</b> and <b>.DSA</b> files  will  be  named  <b>DUKE</b>-<font color="#ffffff" class="whiteout">SIGN.SF&nbsp;DUKESIGN.SF</font>
                      <b>SIGN.SF</b>  and  <b>DUKESIGN.DSA</b>, and will be placed in the <b>META-INF</b> directory of the signed
                      JAR file.

                      The characters in file must come from the set "a-zA-Z0-9_-".  That is,  only  letters,
                      numbers,  underscore,  and hyphen characters are allowed.  Note: All lowercase charac-<font color="#ffffff" class="whiteout">ters&nbsp;characters</font>
                      ters will be converted to uppercase for the <b>.SF</b> and <b>.DSA</b> file names.

                      If no <b>-sigfile</b> option appears on the command line, the base file name for the <b>.SF</b>  and
                      <b>.DSA</b>  files  will be the first 8 characters of the alias name specified on the command
                      line, all converted to upper case. If the alias name has fewer than 8 characters,  the
                      full alias name is used.  If the alias name contains any characters that are not legal
                      in a signature file name, each such character is  converted  to  an  underscore  ("_")
                      character in forming the file name.

       <b>-signedjar</b> <u>file</u>
                      Specifies the name to be used for the signed JAR file.

                      If  no  name  is specified on the command line, the name used is the same as the input
                      JAR file name (the name of the JAR file to be signed); in other words,  that  file  is
                      overwritten with the signed JAR file.

       <b>-verify</b>        If  this  appears  on  the  command line, the specified JAR file will be verified, not
                      signed. If the verification is successful, "jar verified" will be  displayed.  If  you
                      try to verify an unsigned JAR file, or a JAR file signed with an unsupported algorithm
                      (for example, RSA when you don't have an RSA provider  installed),  the  following  is
                      displayed: "jar is unsigned. (signatures missing or not parsable)"

                      It  is  possible  to  verify  JAR  files  signed using either <b>jarsigner</b> or the JDK 1.1
                      <b>javakey</b> tool, or both.

                      For further information on verification, see JAR File Verification.

       <b>-certs</b>         If this appears on the command line, along with the <b>-verify</b> and <b>-verbose</b> options,  the
                      output includes certificate information for each signer of the JAR file. This informa-<font color="#ffffff" class="whiteout">tion&nbsp;information</font>
                      tion includes:

                       the name of the type of certificate (stored in the <b>.DSA</b>  file)  that  certifies  the
                        signer's public key

                       if  the  certificate  is  an  X.509  certificate  (more specifically, an instance of
                        java.security.cert.X509Certificate): the distinguished name of the signer

                      The keystore is also examined. If no keystore value is specified on the command  line,
                      the  default keystore file (if any) will be checked. If the public key certificate for
                      a signer matches an entry in the keystore, then the following information will also be
                      displayed:

                       in parentheses, the alias name for the keystore entry for that signer. If the signer
                        actually comes from a JDK 1.1 identity database instead  of  from  a  keystore,  the
                        alias name will appear in brackets instead of parentheses.

       <b>-verbose</b>       If  this  appears  on the command line, it indicates "verbose" mode, which causes <b>jar</b>-<font color="#ffffff" class="whiteout">signer&nbsp;jarsigner</font>
                      <b>signer</b> to output extra information as to the progress of the JAR signing or  verifica-<font color="#ffffff" class="whiteout">tion.&nbsp;verification.</font>
                      tion.

       <b>-internalsf</b>    In the past, the <b>.DSA</b> (signature block) file generated when a JAR file was signed used
                      to include a complete encoded copy of the <b>.SF</b> file (signature  file)  also  generated.
                      This behavior has been changed. To reduce the overall size of the output JAR file, the
                      <b>.DSA</b> file by default doesn't contain a copy of the <b>.SF</b> file anymore.  But  if  <b>-inter</b>-<font color="#ffffff" class="whiteout">nalsf&nbsp;-internalsf</font>
                      <b>nalsf</b> appears on the command line, the old behavior is utilized. This option is mainly
                      useful for testing; in practice, it should not be used, since doing  so  eliminates  a
                      useful optimization.

       <b>-sectionsonly</b>  If  this  appears  on the command line, the <b>.SF</b> file (signature file) generated when a
                      JAR file is signed does not include a header containing a hash of the  whole  manifest
                      file.  It  just contains information and hashes related to each individual source file
                      included in the JAR file, as described in The Signature (<b>.SF</b>) File .

                      By default, this header is added, as an optimization. When the header is present, then
                      whenever  the JAR file is verified, the verification can first check to see whether or
                      not the hash in the header indeed matches the hash of the whole manifest file. If  so,
                      verification proceeds to the next step. If not, it is necessary to do a less optimized
                      verification that the hash in each source file information section  in  the  <b>.SF</b>  file
                      equals the hash of its corresponding section in the manifest file.

                      For further information, see JAR File Verification.

                      This  option  is  mainly useful for testing; in practice, it should not be used, since
                      doing so eliminates a useful optimization.

       <b>-provider</b> <u>provider</u><b>_</b><u>class</u><b>_</b><u>name</u>
                      Used to specify the name of the cryptographic service  provider's  master  class  file
                      when the service provider is not listed in the security properties file.

       <b>-J</b><u>javaoption</u>   Passes  the specified javaoption string directly to the runtime system.  (<b>jarsigner</b> is
                      actually a "wrapper" around the interpreter.) This option should not contain any  spa-<font color="#ffffff" class="whiteout">ces.&nbsp;spaces.</font>
                      ces.   It  is  useful  for adjusting the execution environment or memory usage.  For a
                      list of possible flags, type <b>java</b> <b>-h</b> or <b>java</b> <b>-X</b> at the command line.

<b>EXAMPLES</b>
   <b>Signing</b> <b>a</b> <b>JAR</b> <b>File</b>
       Suppose you have a JAR file named <b>bundle.jar</b> and you'd like to sign it using the private key  of  the
       user  whose keystore alias is "jane" in the keystore named "mystore" in the "working" directory. Sup-<font color="#ffffff" class="whiteout">pose&nbsp;Suppose</font>
       pose the keystore password is "myspass" and the password for jane's private key is "j638klm". You can
       use the following to sign the JAR file and name the signed JAR file "sbundle.jar":

       <b>jarsigner</b> <b>-keystore</b> <b>"/working/mystore"</b> <b>-storepass</b> <b>myspass</b>
          <b>-keypass</b> <b>j638klm</b> <b>-signedjar</b> <b>sbundle.jar</b> <b>bundle.jar</b> <b>jane</b>

       Note that there is no <b>-sigfile</b> specified in the command above, so the generated <b>.SF</b> and <b>.DSA</b> files to
       be placed in the signed JAR file will have default names based on the alias name. That is, they  will
       be named <b>JANE.SF</b> and <b>JANE.DSA</b>.

       If you want to be prompted for the store password and the private key password, you could shorten the
       above command to

       <b>jarsigner</b> <b>-keystore</b> <b>/working/mystore</b>
          <b>-signedjar</b> <b>sbundle.jar</b> <b>bundle.jar</b> <b>jane</b>

       If the keystore to be used is the default keystore (the one named <b>.keystore</b> in your home  directory),
       you don't need to specify a keystore, as in:

       <b>jarsigner</b> <b>-signedjar</b> <b>sbundle.jar</b> <b>bundle.jar</b> <b>jane</b>

       Finally,  if  you  want  the signed JAR file to simply overwrite the input JAR file (bundle.jar), you
       don't need to specify a <b>-signedjar</b> option:

       <b>jarsigner</b> <b>bundle.jar</b> <b>jane</b>

   <b>Verifying</b> <b>a</b> <b>Signed</b> <b>JAR</b> <b>File</b>
       To verify a signed JAR file, that is, to verify that the signature is valid and the JAR file has  not
       been tampered with, use a command such as the following:

       <b>jarsigner</b> <b>-verify</b> <b>sbundle.jar</b>

       If the verification is successful,

       <b>jar</b> <b>verified.</b>

       is displayed. Otherwise, an error message appears.

       You can get more information if you use the <b>-verbose</b> option. A sample use of <b>jarsigner</b> with the <b>-ver</b>-<font color="#ffffff" class="whiteout">bose&nbsp;-verbose</font>
       <b>bose</b> option is shown below, along with sample output:

       <b>jarsigner</b> <b>-verify</b> <b>-verbose</b> <b>sbundle.jar</b>

                    <b>198</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:14:06</b> <b>PDT</b> <b>1997</b> <b>META-INF/MANIFEST.MF</b>
                    <b>199</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:22:10</b> <b>PDT</b> <b>1997</b> <b>META-INF/JANE.SF</b>
                   <b>1013</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:22:10</b> <b>PDT</b> <b>1997</b> <b>META-INF/JANE.DSA</b>
             <b>smk</b>   <b>2752</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:12:30</b> <b>PDT</b> <b>1997</b> <b>AclEx.class</b>
             <b>smk</b>    <b>849</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:12:46</b> <b>PDT</b> <b>1997</b> <b>test.class</b>

               <b>s</b> <b>=</b> <b>signature</b> <b>was</b> <b>verified</b>
               <b>m</b> <b>=</b> <b>entry</b> <b>is</b> <b>listed</b> <b>in</b> <b>manifest</b>
               <b>k</b> <b>=</b> <b>at</b> <b>least</b> <b>one</b> <b>certificate</b> <b>was</b> <b>found</b> <b>in</b> <b>keystore</b>

             <b>jar</b> <b>verified.</b>


   <b>Verification</b> <b>with</b> <b>Certificate</b> <b>Information</b>
       If you specify the <b>-certs</b> option when verifying, along with the <b>-verify</b>  and  <b>-verbose</b>  options,  the
       output  includes  certificate  information for each signer of the JAR file, including the certificate
       type, the signer distinguished name information (if it's an X.509 certificate), and, in  parentheses,
       the  keystore  alias  for  the signer if the public key certificate in the JAR file matches that in a
       keystore entry. For example,

       <b>example%</b> <b>jarsigner</b> <b>-keystore</b> <b>/working/mystore</b> <b>-verify</b> <b>-verbose</b> <b>-certs</b> <b>myTest.jar</b>

             <b>198</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:14:06</b> <b>PDT</b> <b>1997</b> <b>META-INF/MANIFEST.MF</b>
             <b>199</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:22:10</b> <b>PDT</b> <b>1997</b> <b>META-INF/JANE.SF</b>
            <b>1013</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:22:10</b> <b>PDT</b> <b>1997</b> <b>META-INF/JANE.DSA</b>
             <b>208</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:23:30</b> <b>PDT</b> <b>1997</b> <b>META-INF/JAVATEST.SF</b>
            <b>1087</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:23:30</b> <b>PDT</b> <b>1997</b> <b>META-INF/JAVATEST.DSA</b>
       <b>smk</b>   <b>2752</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:12:30</b> <b>PDT</b> <b>1997</b> <b>Tst.class</b>

        <b>X.509,</b> <b>CN=Test</b> <b>Group,</b> <b>OU=Java</b> <b>Software,</b> <b>O=Sun</b> <b>Microsystems,</b> <b>L=CUP,</b> <b>S=CA,</b> <b>C=US</b> <b>(javatest)</b>
        <b>X.509,</b> <b>CN=Jane</b> <b>Smith,</b> <b>OU=Java</b> <b>Software,</b> <b>O=Sun,</b> <b>L=cup,</b> <b>S=ca,</b> <b>C=us</b> <b>(jane)</b>

        <b>s</b> <b>=</b> <b>signature</b> <b>was</b> <b>verified</b>
        <b>m</b> <b>=</b> <b>entry</b> <b>is</b> <b>listed</b> <b>in</b> <b>manifest</b>
        <b>k</b> <b>=</b> <b>at</b> <b>least</b> <b>one</b> <b>certificate</b> <b>was</b> <b>found</b> <b>in</b> <b>keystore</b>

       <b>jar</b> <b>verified.</b>

       If the certificate for a signer is not an X.509 certificate, there is no distinguished name  informa-<font color="#ffffff" class="whiteout">tion.&nbsp;information.</font>
       tion.   In that case, just the certificate type and the alias are shown. For example, if the certifi-<font color="#ffffff" class="whiteout">cate&nbsp;certificate</font>
       cate is a PGP certificate, and the alias is "bob", you'd get

       <b>PGP,</b> <b>(bob)</b>


   <b>Verification</b> <b>of</b> <b>a</b> <b>JAR</b> <b>File</b> <b>that</b> <b>Includes</b> <b>Idnetity</b> <b>Database</b> <b>Signers</b>
       If a JAR file has been signed using the JDK 1.1 <b>javakey</b> tool, and thus the signer is an alias  in  an
       identity database, the verification output includes an "i" symbol. If the JAR file has been signed by
       both an alias in an identity database and an alias in a keystore, both "k" and "i" appear.

       When the <b>-certs</b> option is used, any identity database aliases are shown  in  square  brackets  rather
       than the parentheses used for keystore aliases. For example:

       <b>jarsigner</b> <b>-keystore</b> <b>/working/mystore</b> <b>-verify</b> <b>-verbose</b> <b>-certs</b> <b>writeFile.jar</b>

             <b>198</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:14:06</b> <b>PDT</b> <b>1997</b> <b>META-INF/MANIFEST.MF</b>
             <b>199</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:22:10</b> <b>PDT</b> <b>1997</b> <b>META-INF/JANE.SF</b>
            <b>1013</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:22:10</b> <b>PDT</b> <b>1997</b> <b>META-INF/JANE.DSA</b>
             <b>199</b> <b>Fri</b> <b>Sep</b> <b>27</b> <b>12:22:30</b> <b>PDT</b> <b>1997</b> <b>META-INF/DUKE.SF</b>
            <b>1013</b> <b>Fri</b> <b>Sep</b> <b>27</b> <b>12:22:30</b> <b>PDT</b> <b>1997</b> <b>META-INF/DUKE.DSA</b>
       <b>smki</b>   <b>2752</b> <b>Fri</b> <b>Sep</b> <b>26</b> <b>16:12:30</b> <b>PDT</b> <b>1997</b> <b>writeFile.html</b>

        <b>X.509,</b> <b>CN=Jane</b> <b>Smith,</b> <b>OU=Java</b> <b>Software,</b> <b>O=Sun,</b> <b>L=cup,</b> <b>S=ca,</b> <b>C=us</b> <b>(jane)</b>
        <b>X.509,</b> <b>CN=Duke,</b> <b>OU=Java</b> <b>Software,</b> <b>O=Sun,</b> <b>L=cup,</b> <b>S=ca,</b> <b>C=us</b> <b>[duke]</b>

        <b>s</b> <b>=</b> <b>signature</b> <b>was</b> <b>verified</b>
        <b>m</b> <b>=</b> <b>entry</b> <b>is</b> <b>listed</b> <b>in</b> <b>manifest</b>
        <b>k</b> <b>=</b> <b>at</b> <b>least</b> <b>one</b> <b>certificate</b> <b>was</b> <b>found</b> <b>in</b> <b>keystore</b>
        <b>i</b> <b>=</b> <b>at</b> <b>least</b> <b>one</b> <b>certificate</b> <b>was</b> <b>found</b> <b>in</b> <b>identity</b> <b>scope</b>

       <b>jar</b> <b>verified.</b>

       Note that the alias "duke" is in brackets to denote that it is an identity database alias, not a key-<font color="#ffffff" class="whiteout">store&nbsp;keystore</font>
       store alias.

<b>SEE</b> <b>ALSO</b>
       <a href="jar.1.html#//apple_ref/doc/man/1/jar"><b>jar</b>(1)</a>, <a href="keytool.1.html#//apple_ref/doc/man/1/keytool"><b>keytool</b>(1)</a>



                                                 23 Jun 2004                                    jarsigner(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/jarsigner.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/jarsigner.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/jarsigner.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
