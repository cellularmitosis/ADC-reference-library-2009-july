<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Porting Drivers to Mac OS X: I/O Kit Considerations</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="I/O Kit Considerations"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001169-CH206" title="I/O Kit Considerations"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../Darwin/index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../intro/intro.html#//apple_ref/doc/uid/TP30001169-CH204-TPXREF101">Porting Drivers to Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../unix-model/unix-model.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../other-language/other-language.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001169-CH206-TPXREF106" title="I/O Kit Considerations"></a><h1>I/O Kit Considerations</h1><p>The I/O Kit is a powerful and relatively straightforward driver environment. However, as with most things that are powerful, there are a few things that won’t behave the way you might expect, particularly if you are used to writing drivers for other platforms.</p><p>This chapter describes some of the things you should consider when porting a driver from another operating system, including ways to avoid potential kernel panics, driver loading failures, and so on down the road</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="other-iokit.html#//apple_ref/doc/uid/TP30001169-CH206-TPXREF107">IOLog vs. multi-level logging</a>
				
			<br/>
			
        
			
			
				<a href="other-iokit.html#//apple_ref/doc/uid/TP30001169-CH206-TPXREF108">Asynchronicity and Synchronous Returns</a>
				
			<br/>
			
        
			
			
				<a href="other-iokit.html#//apple_ref/doc/uid/TP30001169-CH206-TPXREF109">timeout,  sleep and  untimeout</a>
				
			<br/>
			
        
			
			
				<a href="other-iokit.html#//apple_ref/doc/uid/TP30001169-CH206-TPXREF112">Namespace Pollution</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001169-CH206-TPXREF107" title="IOLog vs. multi-level logging"></a><h2>IOLog vs. multi-level logging</h2><p>Some UNIX driver models provide additional support for logging, such as the use of multiple levels of verbosity. The I/O Kit does not provide such support, relying on the developer to implement such a scheme if it is desired.</p><p>A convenient way to simulate this is to replace calls to <code><!--a-->printf<!--/a--></code> with calls to the a macro like this one:</p><div class="codesample"><table><tr><td scope="row"><pre>#define dIOLog(level, a, b...) {if (org_mklinux_iokit_swim3_debug &amp; \<span></span></pre></td></tr><tr><td scope="row"><pre>    level) IOLog(a, ## b); }<span></span></pre></td></tr></table></div><p>and then define various level macros as powers of two. This provides even greater control over debugging than a level-based scheme, allowing you to have up to 32 distinct log options (or 64 if you declare the debug variable as a 64-bit type) that can be turned on or off individually by changing the value of a global variable (in this case, called <code>org_mklinux_iokit_swim3_debug</code>).</p><p>Note that if you are going to use this sort of debugging in a C driver core, you must either use a global variable, pass the variable’s value as an argument, or pass a pointer to the variable as an argument, since the C code cannot access class variables directly.</p><a name="//apple_ref/doc/uid/TP30001169-CH206-TPXREF108" title="Asynchronicity and Synchronous Returns"></a><h2>Asynchronicity and Synchronous Returns</h2><p>In many parts of the I/O Kit, the template class includes both synchronous and asynchronous methods. In these cases, it is absolutely necessary to implement both asynchronous and synchronous calls. Asynchronous calls usually include a callback for a completion routine. If you call the <code>complete</code> method on this completion routine from the same thread that called your function, you may get random kernel panics or stack corruption.</p><p>The problem is that most traditional driver architectures are not designed with asynchronous I/O in mind. There are a number of ways to retrofit asynchronous support into a driver. Each has its own difficulties.</p><p>The most obvious solution is to spawn a temporary helper thread to perform the operation. However, this runs into problems with concurrency. Specifically, the helper thread needs to be able to obtain data from the main thread, which means that the buffer must be in a shared location (for example as part of the class instance). However, some other thread could be in the same code at the same time, resulting in corruption of the request.</p><p>The obvious (but wrong) fix for this is to use a lock. Mach locks, however, do not like it when you lock them in one thread and release them in another. Instead, you should use an <code>IOCommandGate</code>.</p><p>In your class declaration, you should include a place to store the command gate:</p><div class="codesample"><table><tr><td scope="row"><pre>IOCommandGate *myGate;<span></span></pre></td></tr></table></div><p>In your start routine, you must initialize the command gate. To do this, you might add code that looks like this:</p><div class="codesample"><table><tr><td scope="row"><pre>myGate = new IOCommandGate();<span></span></pre></td></tr></table></div><p>You need a wrapper function to pass arguments to the doSyncReadWrite function. It might look like this:</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>struct asyncAction {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOMemoryDescriptor *buffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 block;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 nblks;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" static void org_mklinux_iokit_swim3_driver_doAsyncWrapper(<span></span></pre></td></tr><tr><td scope="row"><pre>        void *selfref,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *actref,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *completionptr,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int retval;<span></span></pre></td></tr><tr><td scope="row"><pre>    org_mklinux_iokit_swim3_driver *driver = selfref;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    retval = driver->doSyncReadWrite(myaction->buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>        myaction->block,<span></span></pre></td></tr><tr><td scope="row"><pre>        myaction->nblks);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOStorage::complete(completion, retval, (retval ? 0 :<span></span></pre></td></tr><tr><td scope="row"><pre>        (args.nblks * 512)));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In <code>doAsyncReadWrite</code>, you would do something like:</p><div class="codesample"><table><tr><td scope="row"><pre>org_mklinux_iokit_swim3_driver::doAsyncReadWrite(IOMemoryDescriptor *buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                UInt32 block,UInt32 nblks,<span></span></pre></td></tr><tr><td scope="row"><pre>                                IOStorageCompletion completion)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    struct asyncAction myaction;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    myaction.buffer = buffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    myaction.block = block;<span></span></pre></td></tr><tr><td scope="row"><pre>    myaction.nblks = nblks;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (myGate->runAction(<span></span></pre></td></tr><tr><td scope="row"><pre>        (Action)&amp;org_mklinux_iokit_swim3_driver_doAsyncWrapper<span></span></pre></td></tr><tr><td scope="row"><pre>        (void *)self,<span></span></pre></td></tr><tr><td scope="row"><pre>        (void *)&amp;myaction,<span></span></pre></td></tr><tr><td scope="row"><pre>        (void *)&amp;completion,<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001169-CH206-TPXREF109" title="timeout,  sleep and  untimeout"></a><h2>timeout,  sleep and  untimeout</h2><p>Many traditional BSD-style drivers use the functions <code><!--a-->sleep<!--/a--></code>, <code><!--a-->timeout<!--/a--></code>, and <code><!--a-->untimeout<!--/a--></code> as synchronization primitives akin to condition variables. You might have a block of code that looks something like this:</p><div class="codesample"><table><tr><td scope="row"><pre>timeout((timeout_fcn_t) wakeup, event, (2 * timeOut * HZ + 999) / 1000);<span></span></pre></td></tr><tr><td scope="row"><pre>sleep((char *)event, PZERO);<span></span></pre></td></tr></table></div><p>where <code>event</code> is a pointer to an integer where the result of the wait will be stored, <code>wakeup</code> is a (bogus) function pointer called when the event occurs, the timeout is usually measured in some fraction of a second, and <code><!--a  -->PZERO<!--/a--></code> is the priority level of the current operation. This ensures that lower-priority interrupts do not wake this code prior to timeout. In such a system, interrupts are lower than PZERO, so they could still result in a wakeup.</p><p>Such code would also typically contain something like the following:</p><div class="codesample"><table><tr><td scope="row"><pre>untimeout((timeout_fcn_t) wakeup, (void *) event);<span></span></pre></td></tr></table></div><p>in a different part of the code (generally in an interrupt handler). This part of the code wakes up the part of the code that is waiting for an event.</p><p>Mac OS X uses similar constructs in the BSD part of the kernel. However, these are not exposed to the I/O Kit. Instead, you need to use an alternative mechanism.</p><p>If you are not using timeouts, you could simply use an <code>IOCommandGate</code> instance. However, this is rarely the case in code ported from BSD.</p><p>There are two recommended solutions to this: <code>IOLock</code> locks and an <code>IOTimerEventSource</code>/<code>IOCommandGate</code> combination</p><dl class="termdef">	<dt><code>IOLock</code> locks</dt><dd><p>This is the easiest way to replace the <code><!--a-->timeout<!--/a--></code>/<code><!--a-->sleep<!--/a--></code>/<code><!--a-->untimeout<!--/a--></code> combination. Instead of setting the timeout and sleeping, you calculate the time stamp when you want to wake, take a lock, and sleep on the lock.</p></dd><dt><code>IOCommandGate</code> with an <code>IOTimerEventSource</code></dt><dd><p>If you are rearchitecting your code, this provides some additional flexibility at the cost of complexity. This will be described in a forthcoming code example.</p></dd></dl><p>This code sample assumes that the use of priority is strictly to prevent stray wakeups. If your code is doing something more sophisticated with priority levels, you will have to substantially enhance this code.</p><p>This code also assumes that there is only one request in flight at any given time, and one thread doing a sleep wait at any given time. Otherwise, you will need to add some sort of queue in place of simply having a single variable to hold the return status of the wait.</p><div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP30001169-CH206-DontLinkElementID_2" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;If you use this code, you <em>must</em> change the names of <em>all</em> functions and global variables to something appropriate to your driver. You may also, if desired, use macros to change the names of these functions transparently.</p><p>Remember that the C function namespace is shared, and that if you pollute it, you will eventually run into some other driver that uses the same name.</p><p>For more information on namespace pollution, read about C naming conventions in the style chapter of <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em></p><p></p><div class="clear"></div></div><p>With those caveats, an alternative to sleep and wakeup follows:</p><a name="//apple_ref/doc/uid/TP30001169-CH206-TPXREF111" title="Listing 2-1Use of IOLock for sleep/timeout/untimeout"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Use of IOLock for sleep/timeout/untimeout</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;kern/kern_types.h>    /* for THREAD_UNINT */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/IOLocks.h>      /* for IOLock */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;osfmk/kern/clock.h>   /* for time manipulation functions */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* instance-specific driver state structure */<span></span></pre></td></tr><tr><td scope="row"><pre>struct driverstate_t {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLock *lock;<span></span></pre></td></tr><tr><td scope="row"><pre>    int wait_return;<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* This function waits */<span></span></pre></td></tr><tr><td scope="row"><pre>dosomething( ... , driverstate_t mydriverstate)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLock *lock = mydriverstate->unitlock;<span></span></pre></td></tr><tr><td scope="row"><pre>    int nanoseconds_to_delay = 1000000; # 1 msec for an example<span></span></pre></td></tr><tr><td scope="row"><pre>    AbsoluteTime absinterval, deadline;<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    // timeout((timeout_fcn_t) wakeup, event, (2*timeOut * HZ + 999) / 1000);<span></span></pre></td></tr><tr><td scope="row"><pre>    // sleep((char *)event, PZERO);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockLock(lock);<span></span></pre></td></tr><tr><td scope="row"><pre>    nanoseconds_to_absolutetime(nanoseconds_to_delay, (uint64_t *)&amp;absinterval);<span></span></pre></td></tr><tr><td scope="row"><pre>    clock_absolutetime_interval_to_deadline(absinterval, (uint64_t *)&amp;deadline);<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockSleepDeadline(lock, event, deadline, THREAD_UNINT);<span></span></pre></td></tr><tr><td scope="row"><pre>    wakeup = mydriverstate->wait_return;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockUnlock(lock);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* This function wakes up the waiting thread */<span></span></pre></td></tr><tr><td scope="row"><pre>interrupt_handler( ... , driverstate_t mydriverstate)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // untimeout((timeout_fcn_t) wakeup, (void *) event);<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockLock(lock);<span></span></pre></td></tr><tr><td scope="row"><pre>    mydriverstate->wait_return =<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockUnlock(lock);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001169-CH206-TPXREF112" title="Namespace Pollution"></a><h2>Namespace Pollution</h2><p>There are two major fundamental namespace problems with porting drivers from UNIX to Mac OS X: sharing between drivers and sharing between driver instances.</p><p>Namespace pollution is a problem for any driver developer that is using C code. The problem is that your function namespace is potentially shared with other drivers. If you name a C function or global variable with the same name as that of a function or global variable in someone else’s driver, one of the two drivers will fail to load.</p><p>Namespace pollution also is a problem for drivers that depend on global variables if it is possible for more than one instance of the driver to be loaded at a time. Because C global variables are shared across driver instances, the two instances will end up clobbering each other’s data. (Since the driver is already loaded, there will be no linking problems, unlike the case where two different drivers have variables or functions with the same name.)</p><p>This section describes solutions to both of these problems in detail.</p><a name="//apple_ref/doc/uid/TP30001169-CH206-TPXREF113" title="Using Data Structures to Avoid Cross-Instance Namespace Pollution"></a><h3>Using Data Structures to Avoid Cross-Instance Namespace Pollution</h3><p>The biggest problem with using a C core for an I/O Kit driver is the issue of a shared namespace. While this won’t prevent multiple instances from being instantiated, it will mean that they will share any global variables across those multiple instances. For this reason, special care is needed when working with global variables.</p><p>Most UNIX-based driver architectures solve this by providing some sort of unit argument to their core functions. As a quick fix, the addition of a “used” flag in the data structure can be used to allow the C++ core to provide this same functionality, with some fixed limit to the number of concurrent instances. This is not an ideal long-term solution, however, and should only be used during early development.</p><p>To do this, however, multiple driver instances must cooperate. This requires a shared lock between them. Sharing the lock is easy. Initializing the lock without race conditions, however, requires a little more effort, specifically a static initializer. An example of this methodology is show in <span class="content_text"><a href="other-iokit.html#//apple_ref/doc/uid/TP30001169-CH206-BABEGHJD">Listing 2-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30001169-CH206-BABEGHJD" title="Listing 2-2Use of instance table for global variables"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Use of instance table for global variables</p><div class="codesample"><table><tr><td scope="row"><pre>/**** in the header ****/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Added "used" since there are no fixed interface numbers */<span></span></pre></td></tr><tr><td scope="row"><pre>struct scsipi {<span></span></pre></td></tr><tr><td scope="row"><pre>    int used = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>struct scsipi interface[NSCSI];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t read(int unit, ...)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>.<span></span></pre></td></tr><tr><td scope="row"><pre>.<span></span></pre></td></tr><tr><td scope="row"><pre>.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>class org_mklinux_driver_IOLockClass : public OSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    org_mklinux_driver_IOLockClass();<span></span></pre></td></tr><tr><td scope="row"><pre>    ~org_mklinux_driver_IOLockClass();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    public:<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLock *lock;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/**** in the C++ wrapper ****/<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLock *org_mklinux_driver_swim3_lock = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    int org_mklinux_driver_swim3_lock_refcount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    extern scsipi *interface;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  declare a statically-initialized instance of the class so that<span></span></pre></td></tr><tr><td scope="row"><pre>    its constructor will be called on driver load and its destructor<span></span></pre></td></tr><tr><td scope="row"><pre>    will be called on unload. */<span></span></pre></td></tr><tr><td scope="row"><pre>class org_mklinux_driver_IOLockClass org_mklinux_driver_swim3_lock;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>class org_mklinux_driver_IOLockClass : public OSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    org_mklinux_driver_IOLockClass()<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        lock = IOLockAlloc();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    ~org_mklinux_driver_IOLockClass();<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLockFree(lock);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    public:<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLock *lock;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int org_mklinux_driver_swim3::new_unit() {<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockLock(org_mklinux_driver_swim3_lock->lock);<span></span></pre></td></tr><tr><td scope="row"><pre>        for (i=0; i&lt;NSCSI; i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (!interface[i]->used) {<span></span></pre></td></tr><tr><td scope="row"><pre>                interface[i]->used = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>                IOLockUnlock(org_mklinux_driver_swim3_lock->lock);<span></span></pre></td></tr><tr><td scope="row"><pre>                return i;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockUnlock(org_mklinux_driver_swim3_lock->lock);<span></span></pre></td></tr><tr><td scope="row"><pre>    return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void org_mklinux_driver_swim3::free_unit(int unit) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockLock(org_mklinux_driver_swim3_lock->lock);<span></span></pre></td></tr><tr><td scope="row"><pre>    interface[unit]->used = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLockUnlock(org_mklinux_driver_swim3_lock->lock);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>org_mklinux_driver_swim3::init(){<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    .<span></span></pre></td></tr><tr><td scope="row"><pre>    /* unit should be an instance variable in your c++ wrapper class */<span></span></pre></td></tr><tr><td scope="row"><pre>    unit = new_unit()<span></span></pre></td></tr><tr><td scope="row"><pre>    if (unit == -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Maybe print a warning here */<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>org_mklinux_driver_swim3::free(){<span></span></pre></td></tr><tr><td scope="row"><pre>    unit_free(unit)<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>A better long-term solution, however, is to declare the data structure as a member of the C++ wrapper class, then rewrite the functions to pass a pointer instead of an integer argument, and use pointer dereferencing (<code>mystructptr->field</code>) instead of structure dereferencing (<code>mystruct.field</code>).</p><a name="//apple_ref/doc/uid/TP30001169-CH206-TPXREF110" title="Using Macros to Avoid Cross-Driver Namespace Pollution"></a><h3>Using Macros to Avoid Cross-Driver Namespace Pollution</h3><p></p><p>To avoid confusion, you should always name your functions in ways that prevent namespace pollution. It is not always practical to name functions with names like <code><!--a-->org_mklinux_iokit_swim3_foo<!--/a--></code>, though, as this quickly becomes unreadable. Instead, a more sane solution is to use macros to rename the functions at compile time.</p><p>For example, say you have functions called <code><!--a-->bingo<!--/a--></code>, <code><!--a-->nameo<!--/a--></code>, and <code><!--a-->dog<!--/a--></code>. You want to rename then with the prefix <code>farmer_had_a_</code>. You might include macros in a project-wide header file that look like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#define dog(a, b, c) farmer_had_a_dog(a, b, c)<span></span></pre></td></tr><tr><td scope="row"><pre>#define bingo(a, b, c) farmer_had_a_bingo(a, b, c)<span></span></pre></td></tr><tr><td scope="row"><pre>#define nameo(a, b, c) farmer_had_a_nameo(a, b, c)<span></span></pre></td></tr></table></div><p>Now there is some risk that you will forget to include these defines for a function. There is a simple fix for that problem, though. First, instead of just including the macros, intersperse the prototypes for the functions in the same file. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>void farmer_had_a_dog(int and, int bingo, void *was_his, char *nameo);<span></span></pre></td></tr><tr><td scope="row"><pre>#define dog(a, b, c) farmer_had_a_dog(a, b, c)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void farmer_had_a_bingo(int clap_i_n_g_o);<span></span></pre></td></tr><tr><td scope="row"><pre>#define bingo(a, b, c) farmer_had_a_bingo(a, b, c)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void farmer_had_a_nameo(int dog);<span></span></pre></td></tr><tr><td scope="row"><pre>#define nameo(a, b, c) farmer_had_a_nameo(a, b, c)<span></span></pre></td></tr></table></div><p>Now this is only a partial solution. To make it a complete solution, add the compiler flag <code>-Wmissing-prototypes</code> to the <code>gcc</code> compiler options (<code>CFLAGS</code>) in your driver’s <code>Makefile</code> or in its Project Builder plist. If you see notices of missing prototypes, you’ll know that you forgot one (or more).</p><p>For more information about namespace pollution, see <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em> in Apple’s Developer Documentation.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../unix-model/unix-model.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../other-language/other-language.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Porting/Conceptual/PortingDrivers/other-iokit/other-iokit.html%3Fid%3DTP30001169-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Porting/Conceptual/PortingDrivers/other-iokit/other-iokit.html%3Fid%3DTP30001169-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Porting/Conceptual/PortingDrivers/other-iokit/other-iokit.html%3Fid%3DTP30001169-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>