<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Working With Date and Time Strings(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING290></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-289.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-291.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-279.html"><B>Chapter 5 - Text Utilities</B></A> / <A HREF="Text-284.html"><B>Using the Text Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING290-0></A>
<H2><A NAME=MARKER-2-184></A><A NAME=MARKER-2-185></A>Working With Date and Time Strings</H2>
 Applications that address international audiences must work with how the numeric-format (<CODE>'itl0'</CODE>) resource and long-date-format (<CODE>'itl1'</CODE>) resource handle the differences in date and time formats used in different countries and regions of the world.<P>
 <A NAME=MARKER-2-125></A>The numeric-format resource contains general conventions for formatting numeric strings. It provides several different definitions, including separators for decimals, thousands, and lists; currency information; time values; and short date formats. Some of the variations in date and time formats are shown in <A HREF=#MARKER-9-10>Table 5-3</A>.<A NAME=MARKER-2-278></A>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-10></A><B>Table 5-3 Variations in time and short date formats</B><A NAME=MARKER-9-769></A></CAPTION>
<TH>Morning<TH>Afternoon<TH>Short date<TH>System software<TR>
<TD>1:02 AM<TD>1:02 PM<TD>2/1/90<TD>United States<TR>
<TD>1:02<TD>13:02<TD>02/01/90<TD>Canadian French<TR>
<TD>1:02 AM<TD>1:02 PM<TD>90.01.02<TD>Chinese<TR>
<TD>1:02<TD>13:02<TD>02-01-1990<TD>Dutch<TR>
<TD>1:02 Uhr<TD>13:02 Uhr<TD>2.1.1990<TD>German<TR>
<TD>1:02<TD>13:02<TD>2-01-1990<TD>Italian<TR>
<TD>01.02<TD>13.02<TD>90-02-01<TD>Swedish</TABLE>
<P>
 For time and date values, the numeric-format resource includes values that specify this information:<A NAME=MARKER-2-259></A><P>
<UL>
<LI>the order of the month, day, and year values in short date formats
<LI>which separator to use in the short date format (for example, : or <I>/</I> or <I>-</I>)
<LI>the trailing string to display for morning (for example, <I>A.M.</I>)
<LI>the trailing string to display for evening (for example, <I>P.M.</I>)
<LI>up to 4 trailing bytes to display for 24-hour times before noon, and another 4 bytes <BR>to display for 24-hour times at noon and after. For example, the German string <I>Uhr</I> <BR>is used for both purposes.
<LI>whether or not to indicate leading zeros in each of the time elements (hours, <BR>minutes, and seconds)<P>
</UL>
 The long-date-format resource includes conventions for long date formats, abbreviated date formats, and the regional version of the script the resource is associated with. Some of the variations in long and abbreviated date formats are shown in <A HREF=#MARKER-9-12>Table 5-4</A><A NAME=MARKER-2-182></A>.<A NAME=MARKER-2-190></A>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-12></A><B>Table 5-4 Variations in long and abbreviated date formats</B><A NAME=MARKER-2-333></A> (Continued)</CAPTION>
<TH>Long date<TH>Abbreviated date<TH>System software<TR>
<TD>Tuesday, January 2, 1990<TD>Tue, Jan 2, 1990<TD>United States<TR>
<TD>Tuesday, 2 January 1990<TD>Tue, 2 Jan 1990<TD>Australian<TR>
<TD>Mardi 02 janvier 1990<TD>Mard 02 janv 1990<TD>Canadian French<TR>
<TD>tirsdag 2. januar 1990<TD>tir 2. jan 1990<TD>Danish<TR>
<TD>Mardi 2 Janvier 1990<TD>Mar 2 Jan 1990<TD>French</TABLE>
  <P>
 The long-date-format resource includes values that specify this information:<P>
<UL>
<LI>the names of the days
<LI>the names of the months
<LI>which punctuation to use for abbreviated day names and month names<P>
</UL>
 You can optionally add an extension to a long-date-format resource that adds a number of other specification capabilities, including the following:<A NAME=MARKER-2-262></A><P>
<UL>
<LI>a calendar code for the specification of calendars other than the standard Gregorian calendar, such as the Arabic calendar
<LI>a list of extra day names for calendars with more than seven days
<LI>a list of extra month names for calendars with more than twelve months
<LI>a list of abbreviated day names
<LI>a list of abbreviated month names
<LI>a list of additional date separators<P>
</UL>
 Many of the Apple-supplied long-date-format resources already include such extensions.<P>
 The Text Utilities routines that work with dates and times use the information in the long-date-format and numeric-format resources to create different string representations of date and time values. The Macintosh Operating System provides routines that return the current date and time to you in numeric format; you can then use the Text Utilities routines to convert those values into strings that can be presented in different international formats.<P>
 The Text Utilities also include routines that can parse date and time strings as entered by users and fill in the fields of a record with the components of the date and time, including the month, day, year, hours, minutes, and seconds.<P>
 For more details on the numeric-format (<CODE>'itl0'</CODE>) and long-date-format (<CODE>'itl1'</CODE>) resources, see the appendix "International Resources" in this book. For information on obtaining the current date and time values from the Macintosh Operating System, see <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.<A NAME=MARKER-2-770></A><A NAME=MARKER-2-193></A><P>
<A NAME=HEADING290-26></A>
<H3><A NAME=MARKER-9-194></A>Converting Formatted Date and Time Strings <BR>Into Internal Numeric Representations<A NAME=MARKER-2-136></A><A NAME=MARKER-2-134></A></H3>
 When your application works with date and time values, it must convert string versions of dates and times into internal numeric representations that it can manipulate. You might, for example, need to convert a date typed by the user into a numeric representation so that you can compute another date some number of days ahead. You can then format the new value for display as a formatted date string.<A NAME=MARKER-2-15></A><P>
 The Text Utilities contains two routines that you can use to parse formatted date and time values from input strings and create an internal numeric representation of the <BR>date and time. The <CODE>StringToDate</CODE> function parses an input string for a date, and <BR>the <CODE>StringToTime</CODE> function parses an input string (possibly the same input string) for time information.<P>
 Both of these functions pass a date cache record as one of the parameters. A date cache record is a data structure of type <CODE>DateCacheRec</CODE> that you must declare in your application. Because you must pass this record as a parameter, you must initialize it by calling the <CODE>InitDateCache</CODE> function before calling <CODE>StringToDate</CODE> or <CODE>StringToTime</CODE>. You need to call <CODE>InitDateCache</CODE> only once--typically in your main program initialization code. For more information about the date cache record and the <CODE>InitDateCache</CODE> function, see the section <A HREF=Text-335.html#MARKER-9-394>"InitDateCache" on page 5-83</A>. <A NAME=MARKER-2-57></A><A NAME=MARKER-2-41></A> <P>
 Both the <CODE>StringToDate</CODE> and the <CODE>StringToTime</CODE> functions fill in fields in a long date-time record, which is defined by a <CODE>LongDateRec</CODE> data structure. This data type is described in the book <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.<P>
 You usually use <CODE>StringToDate</CODE> and <CODE>StringToTime</CODE> sequentially to parse the date and time values from an input string and fill in these fields. <A HREF=#MARKER-9-200>Listing 5-5</A> shows how to first call <CODE>StringToDate</CODE> to parse the date, then offset the starting address of the string, and finally, call <CODE>StringToTime</CODE> to parse the time.<P>
<A NAME=MARKER-9-200></A><B>Listing 5-5  Using <CODE>StringToDate</CODE> and <CODE>StringToTime</CODE></B><P>
<PRE>
str := &quot;March 27, 1992 08:14 p.m.&quot;;

strPtr := ptr(ord(@str) + 1); {Pointer to 1st char of str}
strLen := length(str);
status := StringToDate(strPtr, strLen, myDateCache,
                                       numBytes, lDateRec);
strPtr := ptr(ord(@str)+numBytes+1);
strLen := strLen - numBytes;
status := StringToTime(strPtr, strLen, myDateCache, 
                                       numBytes, lDateRec);
</PRE>
 StringToDate parses the text string until it has finished finding all date information or until it has examined the number of bytes specified by textLen. It returns a status value that indicates the confidence level for the success of the conversion. StringToDate recognizes date strings in many formats, including "September 1, 1987," "1 Sept 1987," "1/9/1987," and "1 1987 sEpT."<P>
 Note that <CODE>StringToDate</CODE> fills in only the year, month, day, and day of the week; <CODE>StringToTime</CODE> fills in the hour, minute, and second. You can use these two routines sequentially to fill in all of the values in a <CODE>LongDateRec</CODE> record.<A NAME=MARKER-2-945></A><P>
 <CODE>StringToDate</CODE> assigns to its <CODE>lengthUsed</CODE> parameter the number of bytes that it uses to parse the date; use this value to compute the starting location of the text that you can pass to <CODE>StringToTime</CODE>.<P>
 <CODE>StringToDate</CODE> interprets the date and <CODE>StringToTime</CODE> interprets the time based on values that are defined in the long-date-format (<CODE>'itl1'</CODE>) resource. These values, which include the tokens used for separators and the month and day names, are described in the appendix "International Resources" in this book.<A NAME=MARKER-9-946></A><P>
 <CODE>StringToDate</CODE> uses the <CODE>IntlTokenize</CODE> function, as described in the chapter "Script Manager" in this book, to separate the components of the strings. It assumes that the names of the months and days, as specified in the international long-date-format resource, are single alphanumeric tokens.<A NAME=MARKER-2-203></A><P>
 When one of the date components is missing, such as the year, the current date value is used as a default. If the value of the input year is less than 100, <CODE>StringToDate</CODE> determines the year as follows.<A NAME=MARKER-2-300></A><P>
<OL>
<LI><A NAME=MARKER-9-205></A>If (current year) MOD 100 is greater than or equal to 90 and the input year is less than or equal to 10, the input year is assumed to be in the next century.
<LI>If (current year) MOD 100 is less than or equal to 10 and the input year is greater than or equal to 90, the input year is assumed to be in the previous century.
<LI>Otherwise, the input year is assumed to be in the current century.<P>
</OL>
 If the value of the input year is between 100 and 1000, then 1000 is added to it. Thus the dates 1/9/87, 1/9/987, and 1/9/1987 are equivalent.<P>
 Both <CODE>StringToDate</CODE> and <CODE>StringToTime</CODE> return a value of type <CODE>StringToDateStatus</CODE>, which is a set of bit values that indicate confidence levels, with higher numbers indicating low confidence in how closely the input string matched what the routine expected. Each <CODE>StringToDateStatus</CODE> value can contain a number of the possible bit values that have been OR'ed together. For example, specifying a date with nonstandard separators may work, but it returns a message indicating that the separator was not standard. <BR><BR>The possible values of this type are described in <A HREF=#MARKER-9-7>Table 5-5</A><A NAME=MARKER-21-403></A>.
<A NAME=MARKER-9-7></A><TABLE BORDER="0" CELLPADDING=3>
<CAPTION><CODE><A NAME=MARKER-2-8></A>StringToDateStatus</CODE> values and their meanings (Continued)</CAPTION>
<TH><CODE>StringToDateStatus</CODE> <BR>value<TH>Result of the conversion<BR><TR>
<TD>fatalDateTime<TD>A fatal error occurred during the parse.<TR>
<TD>tokenErr<TD>The token processing software could not find a token.<TR>
<TD>cantReadUtilities<TD>The resources needed to parse the date or time value could not be read.<TR>
<TD>dateTimeNotFound<TD>A valid date or time value could not be found in the string.<TR>
<TD>dateTimeInvalid<TD>The start of a valid date or time value was found, but a valid date or time value could not be parsed from the string.<TR>
<TD>longDateFound<TD>A valid long date was found. This bit is not set when a short date or time was found.<TR>
<TD>leftOverChars<TD>A valid date or time value was found, and there were characters remaining in the input string.<TR>
<TD>sepNotIntlSep<TD>A valid date or time value was found; however, one or more of the separator characters in the string was not an expected separator character for the script system in use.<TR>
<TD>fieldOrderNotIntl<TD>A valid date or time value was found; however, the order of the fields did not match the expected order for the script system in use.<TR>
<TD>extraneousStrings<TD>A valid date or time value was found; however, one or more unparsable strings was encountered and skipped while parsing the string.<TR>
<TD>tooManySeps<TD>A valid date or time value was found; however, one or more extra separator characters was encountered and skipped while parsing the string.<TR>
<TD>sepNotConsistent<TD>A valid date or time value was found; however, the separator <BR>characters did not consistently match the expected separators for the script system in use<A NAME=MARKER-2-364></A>.</TABLE>
<P>
 For example, if <CODE>StringToDate</CODE> and <CODE>StringToTime</CODE> successfully parse date and <BR>time values from the input string and more characters remain in the string, then the function result will be the constant <CODE>leftOverChars</CODE>. If <CODE>StringToDate</CODE> discovers two separators in sequence, the parse will be successful and the return value will be the constant <CODE>tooManySeps</CODE>. If <CODE>StringToDate</CODE> finds a perfectly valid short date, it <BR>returns the value <CODE>noErr</CODE>; if <CODE>StringToDate</CODE> finds a perfectly valid long date, it returns the value <CODE>longDateFound</CODE>.<A NAME=MARKER-2-16></A><A NAME=MARKER-2-208></A><A NAME=MARKER-2-209></A><P>
<A NAME=HEADING290-46></A>
<H3>Date and Time Value Representations</H3>
 The Macintosh Operating System provides several different representations of date and time values. One representation is the standard date-time value that is returned by the Macintosh Operating system routine <CODE>GetDateTime</CODE>. This is a 32-bit integer that represents the number of seconds between midnight, January 1, 1904 and the current time. Another is the date-time record, which includes integer fields for each date and time component value.<P>
 The Macintosh Operating System also provides two data types that allow for longer spans of time than do the standard date-time value and date-time record: the long date-time value and the long-date record. The long date-time value, of data type <CODE>LongDateTime</CODE>, is a 64-bit, signed representation of the number of seconds since Jan. 1, 1904, which allows for coverage of a much longer span of time (approximately 30,000 years) than does the standard date-time representation. The long date-time record, of data type <CODE>LongDateRec</CODE>, is similar to the date-time record, except that it adds several additional fields, including integer values for the era, the day of the year, and the week of the year.<A NAME=MARKER-2-128></A><A NAME=MARKER-2-211></A><P>
 The Macintosh Operating System provides four routines for converting among the different date and time data types:<P>
<UL>
<LI><CODE>DateToSeconds</CODE>, which converts a date-time record into a standard date-time value<A NAME=MARKER-2-107></A>
<LI><CODE>SecondsToDate</CODE>, which converts a standard date-time value into a date-time record<A NAME=MARKER-2-213></A>
<LI><CODE>LongDateToSeconds</CODE>, which converts a long-date record into a long date-time value<A NAME=MARKER-2-214></A>
<LI><CODE>LongSecondsToDate</CODE>, which converts a long date-time value into a long-date record<A NAME=MARKER-2-215></A><P>
</UL>
 The standard date-time value, the long date-time value, and each of the data structures and routines mentioned in this section are described in the book <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.<A NAME=MARKER-2-17></A><P>
<A NAME=HEADING290-55></A>
<H3><A NAME=MARKER-9-217></A>Converting Standard Date and Time Values Into Strings<A NAME=MARKER-2-73></A></H3>
 When you want to present a date or time value as a string, you need to convert from one of the numeric date-time representations into a formatted string. The Text Utilities include the <CODE>DateString</CODE> and <CODE>TimeString</CODE> procedures for converting standard date-time values into formatted strings, and the <CODE>LongDateString</CODE> and <CODE>LongTimeString</CODE> procedures for converting long date-time values into formatted strings. Each of these routines uses information from a long-date-format or numeric-format resource that you specify as a parameter.<A NAME=MARKER-2-219></A><A NAME=MARKER-2-421></A><P>
 When you use the <CODE>DateString</CODE> and <CODE>LongDateString</CODE> procedures, you can request an output format for the resulting date string. The output format can be one of the three values of the <CODE>DateForm</CODE> enumerated data type:<A NAME=MARKER-2-677></A><P>
<PRE>
DateForm = (shortDate,longDate,abbrevDate);
</PRE>
 Here are examples of the date strings that these specifications produce.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Value<TH>Date string produced<TR>
<TD>shortDate<TD>1/31/92<TR>
<TD>abbrevDate<TD>Fri, Jan 31, 1992<TR>
<TD>longDate<TD>Friday, January 31, 1992</TABLE>
<P>
 When you request a long or abbreviated date format, the formatting information in a long-date-format resource is used. For short date formats, the information is found in a numeric-format resource. The <CODE>DateString</CODE> and <CODE>LongDateString</CODE> procedures use the long-date-format or numeric-format resource that you specify. If you request a long or abbreviated date format, you must include the handle to a long-date-format resource, and if you request a short date format, you must include the handle to a numeric-format resource. If you specify <CODE>NIL</CODE> for the value of the resource handle parameter, both routines uses the appropriate resource from the current script.<A NAME=MARKER-9-97></A><P>
 When you use the <CODE>TimeString</CODE> and <CODE>LongTimeString</CODE> procedures to produce a formatted time string, you can request an output format for the resulting string. You specify whether or not you want the time string to include the seconds by passing a Boolean parameter to these procedures.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Value<TH>Time string produced<TR>
<TD>FALSE<TD>03:24 P.M.<TR>
<TD>TRUE<TD>03:24:17 P.M.<A NAME=MARKER-2-303></A></TABLE>
<P>
 The <CODE>TimeString</CODE> and <CODE>LongTimeString</CODE> procedures use the time formatting information in the numeric-format resource that you specify. This information defines which separator to use between the elements of the time string, which suffix strings to use, and whether or not to add leading zeros in each of the time elements. If you specify <CODE>NIL</CODE> in place of a resource handle, these procedures use the numeric-format resource from the current script.<A NAME=MARKER-2-308></A><A NAME=MARKER-2-351></A><A NAME=MARKER-2-875></A><A NAME=MARKER-2-227></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-289.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-291.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
