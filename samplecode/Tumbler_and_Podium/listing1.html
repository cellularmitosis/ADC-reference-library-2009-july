<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Tumbler and Podium - /TumblerSource/Tumbler_AEVT.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Tumbler and Podium</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Tumbler and Podium</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TumblerSource/Tumbler_AEVT.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/TumblerSource/Tumbler_AEVT.c</option>
<option value="listing2.html">/TumblerSource/Tumbler_AEVT.h</option>
<option value="listing3.html">/TumblerSource/Tumbler_camera.c</option>
<option value="listing4.html">/TumblerSource/Tumbler_camera.h</option>
<option value="listing5.html">/TumblerSource/Tumbler_cursor.c</option>
<option value="listing6.html">/TumblerSource/Tumbler_cursor.h</option>
<option value="listing7.html">/TumblerSource/Tumbler_document.c</option>
<option value="listing8.html">/TumblerSource/Tumbler_document.h</option>
<option value="listing9.html">/TumblerSource/Tumbler_drag.c</option>
<option value="listing10.html">/TumblerSource/Tumbler_drag.h</option>
<option value="listing11.html">/TumblerSource/Tumbler_ErrorHandler.c</option>
<option value="listing12.html">/TumblerSource/Tumbler_ErrorHandler.h</option>
<option value="listing13.html">/TumblerSource/Tumbler_event.c</option>
<option value="listing14.html">/TumblerSource/Tumbler_event.h</option>
<option value="listing15.html">/TumblerSource/Tumbler_file.c</option>
<option value="listing16.html">/TumblerSource/Tumbler_file.h</option>
<option value="listing17.html">/TumblerSource/Tumbler_globals.h</option>
<option value="listing18.html">/TumblerSource/Tumbler_HideMenuBar.c</option>
<option value="listing19.html">/TumblerSource/Tumbler_HideMenuBar.h</option>
<option value="listing20.html">/TumblerSource/Tumbler_initialize.c</option>
<option value="listing21.html">/TumblerSource/Tumbler_initialize.h</option>
<option value="listing22.html">/TumblerSource/Tumbler_main.c</option>
<option value="listing23.html">/TumblerSource/Tumbler_main.h</option>
<option value="listing24.html">/TumblerSource/Tumbler_menus.c</option>
<option value="listing25.html">/TumblerSource/Tumbler_menus.h</option>
<option value="listing26.html">/TumblerSource/Tumbler_offscreen.c</option>
<option value="listing27.html">/TumblerSource/Tumbler_offscreen.h</option>
<option value="listing28.html">/TumblerSource/Tumbler_PICTImport.c</option>
<option value="listing29.html">/TumblerSource/Tumbler_PICTImport.h</option>
<option value="listing30.html">/TumblerSource/Tumbler_podium.c</option>
<option value="listing31.html">/TumblerSource/Tumbler_podium.h</option>
<option value="listing32.html">/TumblerSource/Tumbler_prototypes.h</option>
<option value="listing33.html">/TumblerSource/Tumbler_resources.h</option>
<option value="listing34.html">/TumblerSource/Tumbler_teutilities.c</option>
<option value="listing35.html">/TumblerSource/Tumbler_teutilities.h</option>
<option value="listing36.html">/TumblerSource/Tumbler_traps.c</option>
<option value="listing37.html">/TumblerSource/Tumbler_traps.h</option>
<option value="listing38.html">/TumblerSource/Tumbler_utility.c</option>
<option value="listing39.html">/TumblerSource/Tumbler_utility.h</option>
<option value="listing40.html">/TumblerSource/Tumbler_windows.c</option>
<option value="listing41.html">/TumblerSource/Tumbler_windows.h</option></select>
				</p>
				</form>
				<p><strong><a href="Tumbler_and_Podium.zip">Download Sample</a></strong> (&#147;Tumbler_and_Podium.zip&#148;, 1.07M)<BR>
<strong><a href="Tumbler_and_Podium.dmg">Download Sample</a></strong> (&#147;Tumbler_and_Podium.dmg&#148;, 1.15M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//  Tumbler_AEVT.c////  Apple Event Routines for the Tumbler App.  Contains AppleEvent Handlers and senders for//  the Tumbler app.//    //  Author:    Nick Thompson, 11/24/94////  Modification History:////  11/26/94    nick    clean up, remove old TE references from dragtext, remove//                all other dead code//  11/24/94    nick    Initial Cut - factored code from Tumbler event, added//                 Drag related events for debugging (you can't debug the //                handler, but if the handler sends an event you can debug//                the AE handler).////  Copyright &copy; 1992-95 Apple Computer, Inc., All Rights Reserved////  To Do://    a number of items are &quot;duplicated&quot; in the event we send to ourselves//    we send the window and the document (the doc reference is stored in the//    window refcon, window is stored in the doc)//#include &lt;AppleEvents.h&gt;#include &lt;Drag.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Memory.h&gt;#include &lt;SegLoad.h&gt;#include &quot;Tumbler_prototypes.h&quot;#include &quot;Tumbler_resources.h&quot;#include &quot;Tumbler_offscreen.h&quot;#include &quot;Tumbler_globals.h&quot;#include &quot;Tumbler_AEVT.h&quot;#include &quot;Tumbler_Traps.h&quot;#include &quot;Tumbler_Document.h&quot;#include &quot;Tumbler_file.h&quot;#include &quot;Tumbler_PICTImport.h&quot;#include &quot;Tumbler_camera.h&quot;#include &quot;Tumbler_file.h&quot;#ifdef PODIUM_APP#include &quot;Tumbler_Podium.h&quot;#endif#include &quot;QD3D.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DGroup.h&quot;#include &quot;QD3DIO.h&quot;#include &quot;QD3DPick.h&quot;#include &quot;QD3DShader.h&quot;#include &quot;QD3DStorage.h&quot;#include &quot;QD3DTransform.h&quot;#include &quot;QD3DView.h&quot;#define  kGestaltTrap  0xA0AD#include &quot;Tumbler_AEVT.h&quot;// local variables - to this filestatic AEAddressDesc    pSelfAddress;      // A self-addressed address descriptor recordstatic ProcessSerialNumber  pSelfPSN;        // This application's psnstatic AEDesc        pnilDesc;        // A nil descriptor record// this defines a suite of events for dispatching dragsstatic const AEEventClass  kDraggingClass       = 'drag' ;  static const AEEventID    kDragDrawID        = 'draw' ;  static const AEEventID    kDragSendID        = 'send' ;  static const AEEventID    kDragReceiveID      = 'recv' ;  static const AEEventID    kDragTrackID      = 'trak' ;  static const AEEventID    kDragDragID        = 'drag' ;  //static const AEKeyword  keyPrivateData        = 'priv' ;// AppleEvent Error Handling....//----------------------------------------------------------------------------------//  If an error has occurred, I check the user interaction level. If I can      //  interact with the user, I put up a dialog and exit the application; otherwise,//  I just exit the application.////  ***NOTE: Real applications would not handle errors in this fashion!  If they//  cannot interact with the user, they should abort the Apple event handler and// return the error in the reply parameter.void FailIfErr (OSErr  error){  OSErr    interactErr = noErr ;  if (error != noErr)  {    if ((interactErr = AEInteractWithUser(kNoTimeOut, nil, nil)) == noErr) {                    // Can we interact?      AlertUser(error);    // Yes, so put up the dialog.      ExitToShell();    }  }}//----------------------------------------------------------------------------------// Display an alert for the user to indicate that an error has occurred.// This approach would not really be good for a real app - hard coding // strings in this manner would be really hard to localise.   But this approach// is good for programming because it gives us the error code.  void AlertUser (short  error){  short    itemHit;  Str255    defaultMessage = &quot;\pAn error was encountered&quot; ;  Str255    message ;  Str255    errNo ;  if( error &lt; 0 ) {    BlockMove( &amp;defaultMessage[1], &amp;message[1], defaultMessage[0] );    message[0] = defaultMessage[0] ;  }  else {    GetIndString(message, rErrorStringIndex, error);  }    NumToString( error, errNo ) ;    ParamText(  message,        (ConstStr255Param)&quot;\p (&quot;,        errNo,        (ConstStr255Param)&quot;\p).&quot;);  // [pwpc]  itemHit = Alert(rUserAlert, nil);}//----------------------------------------------------------------------------------void  FatalError(short error){  Str255    message ;  GetIndString(message, rFatalErrorStringIndex, error);  ParamText(message, (ConstStr255Param)&quot;\p&quot;, (ConstStr255Param)&quot;\p&quot;, (ConstStr255Param)&quot;\p&quot;);  // [pwpc]  (void)StopAlert( rFatalAlert, nil ) ;  ExitToShell() ;}//-----------------------------------------------------------------------// call this to init the AE stuff in this filevoid InitAEStuff( void ) {  // Set up the self-addressed descriptor record.  pSelfPSN.highLongOfPSN = 0;  pSelfPSN.lowLongOfPSN = kCurrentProcess;    // Use this instead of GetCurrentProcess  FailIfErr(AECreateDesc(typeProcessSerialNumber,(Ptr)&amp;pSelfPSN,sizeof(ProcessSerialNumber),&amp;pSelfAddress));  pnilDesc.descriptorType = typeNull;      // Initialize the global nil descriptor record.  pnilDesc.dataHandle = nil;    RegisterMyEvents() ;              // and finally register appleEvent handlers  }//-----------------------------------------------------------------------// returns true if the platform supports appleevents - we won't run// if it doesn'tBoolean SupportsAEVT(void){  OSErr err;  long response;    if (!myTrapAvailable(kGestaltTrap))    return false;    err = Gestalt(gestaltAppleEventsAttr,&amp;response);  if (err!=noErr)    return false;      return (response &amp;&amp; (response &lt;&lt; gestaltAppleEventsPresent));}//-----------------------------------------------------------------------// called to process high level appleeventsvoid DoHighLevelEvent(EventRecord *ev){  OSErr err;    err = AEProcessAppleEvent(ev);  }//-----------------------------------------------------------------------// called to register our appleevent handlersvoid RegisterMyEvents(void){  OSErr err;    if (!SupportsAEVT())    return;    err = AEInstallEventHandler(kCoreEventClass,kAEOpenApplication,NewAEEventHandlerProc(MyAEHandleOAPP),0L,false);  if (err!=noErr)    return;          err = AEInstallEventHandler(kCoreEventClass,kAEOpenDocuments,NewAEEventHandlerProc(MyAEHandleODOC),0L,false);  if (err!=noErr)    return;          err = AEInstallEventHandler(kCoreEventClass,kAEPrintDocuments,NewAEEventHandlerProc(MyAEHandlePDOC),0L,false);  if (err!=noErr)    return;          err = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,NewAEEventHandlerProc(MyAEHandleQUIT),0L,false);  if (err!=noErr)    return;        // drag stuff handlers  err = AEInstallEventHandler(kDraggingClass,kDragReceiveID,NewAEEventHandlerProc(MyAEHandleDragRecv),0L,false);  if (err!=noErr)    return;      }//-----------------------------------------------------------------------// open application event handler for the core event suite, // by default we just want a blank new documentpascal OSErr MyAEHandleOAPP(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon){  OSErr err = noErr ;#ifndef PODIUM_APP  DoNewDocument();#endif  return err;}//-----------------------------------------------------------------------// handler for the open document appleevent handlerpascal OSErr MyAEHandleODOC(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon){  FSSpec     myFSS;  AEDescList  docList;  OSErr    err,        ignoreErr;  long    index,        itemsInList;  Size     actualSize;  AEKeyword  keywd;  DescType  returnedType;    err = AEGetParamDesc(theAppleEvent,keyDirectObject,typeAEList,&amp;docList);  if (err == noErr) {      // see how many descriptor items are in the list    // this is the number of documents we want to open    err = AECountItems(&amp;docList,&amp;itemsInList);    // now get each descriptor record from the list    // coerce the returned data to an FSSpec record, and    // open the asoociated file        for (index=1; index &lt;= itemsInList &amp;&amp; err == noErr; index++) {          err = AEGetNthPtr(  &amp;docList,                 index,                typeFSS,                &amp;keywd,                &amp;returnedType,                (Ptr)&amp;myFSS,                sizeof(myFSS),                &amp;actualSize);        if (err == noErr)  {              FInfo    fndrInfo ;                // we now have a valid FSSpec to reference the file, we need to know         // what type the file is to determine which file open function to call        // we can determine this from the finder info for the file                err = FSpGetFInfo( &amp;myFSS, &amp;fndrInfo );                  // if we got that ok, then we switch on the file          // type (we don't care about the creator type)                      if (err == noErr)  {                  switch( fndrInfo.fdType ) {            case 'PICT':              break ;                          case 'TEXT':            case '3DMF':              err = DoOpenFile(&amp;myFSS);              break ;                        default:              break ;          }        }      }    }    ignoreErr = AEDisposeDesc(&amp;docList);  }  return err ;}//-----------------------------------------------------------------------// handler for the print document event handlerpascal OSErr MyAEHandlePDOC(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon){  FSSpec     myFSS;  AEDescList  docList;  OSErr    err;  long    index,        itemsInList;  Size     actualSize;  AEKeyword  keywd;  DescType  returnedType;    err = AEGetParamDesc(theAppleEvent,keyDirectObject,typeAEList,&amp;docList);  if (err == noErr) {      // see how many descriptor items are in the list    // this is the number of documents we want to open    err = AECountItems(&amp;docList,&amp;itemsInList);    // now get each descriptor record from the list    // coerce the returned data to an FSSpec record, and    // open the asoociated file        for (index=1; index &lt;= itemsInList &amp;&amp; err == noErr; index++) {          err = AEGetNthPtr(  &amp;docList,                 index,                typeFSS,                &amp;keywd,                &amp;returnedType,                (Ptr)&amp;myFSS,                sizeof(myFSS),                &amp;actualSize);        if (err == noErr)  {                  // err = HandlePrintDoc( &amp;myFSS );        err = errAEEventNotHandled ;     // we don't do this yet...      }    }    err = AEDisposeDesc(&amp;docList);  }  return err ;}//-----------------------------------------------------------------------// quit appleevent handlerpascal OSErr MyAEHandleQUIT(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon){  OSErr       err = noErr ;    // used as return value    // close all windows and signal to Quit  gQuitting = true;      // attempt to close all documents  if( CloseAllDocuments() == false )    return userCanceledErr ;  // couldn't close them, so indicate the user cancelled      // if we closed everything up successfully, we can return noErr, otherwise  // indicate to sender of the 'quit' aevt that we canceled    if (gQuitting) {    gQuit = true;            // user didn't cancel    err = AEDisposeDesc(&amp;pSelfAddress);  // Dispose of my self-addressed descriptor.  }  else {    err = userCanceledErr ;  }        return err ;}//-----------------------------------------------------------------------// drag receive appleevent handlerpascal OSErr MyAEHandleDragRecv(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon){  AEDesc        myDesc;  OSErr        err;  OSErr        ignoreErr ;  TQ3Object       objects = nil;  err = AEGetParamDesc(theAppleEvent,keyPrivateData,typeChar,&amp;myDesc);  if (err == noErr) {      // try to load all of the items we stuffed into the apple event    myPrivateDataHdl    thePrivateData = (myPrivateDataHdl)myDesc.dataHandle ;    OSType          theDragType = (**thePrivateData).myTypeOfData ;    DocumentPtr       theDocument = (**thePrivateData).myDocument ;    long          dataSize = (**thePrivateData).myDataSize ;    WindowPtr        theWindow = (**thePrivateData).myWindow  ;    Point          theLocation = (**thePrivateData).myLocation ;    Handle          dataHdl = NewHandle( dataSize ) ;        // sanity check    if( dataSize &gt; GetHandleSize( myDesc.dataHandle )) {      ignoreErr = AEDisposeDesc(&amp;myDesc);      return paramErr ;    }        // check we could create the data handle OK    if( dataHdl == nil ) {      ignoreErr = AEDisposeDesc(&amp;myDesc);      return MemError() ;    }    // copy the data from the descriptor to our handle    BlockMove( &amp;(**thePrivateData).myData, *dataHdl, dataSize );        // we need to get rid of the descriptor, to save on memory    err = AEDisposeDesc(&amp;myDesc);        // process the information from the drag    if( theDragType == '3DMF' ) {          TQ3SharedObject  viewHints ;          // do this on receipt of a drag of type 3DMF        TQ3FileObject     fd;      TQ3StorageObject     storage;      // Lock and load      MoveHHi( dataHdl ) ;      HLock(  dataHdl ) ;            storage = Q3MemoryStorage_New((const unsigned char *) *dataHdl,        (unsigned long) dataSize );              HUnlock( dataHdl ) ;            if (storage == nil)        goto bail;            fd = Q3File_New();      Q3File_SetStorage(fd, storage);      Q3Object_Dispose(storage);            if (fd == nil)        goto bail;      Tumbler_ReadScene(        fd,        false,        &amp;viewHints,        &amp;theDocument-&gt;documentGroup) ;              TumblerDocument_UpdateView( theDocument,  viewHints ) ;#ifdef PODIUM_APP      {      // we really want the obect to be centered about the       // drop location.      GrafPtr    savedPort ;            extern void Podium_UpdateDrawContextFromDropRect( DocumentPtr theDocument ) ;      GetPort( &amp;savedPort ) ;      SetPort( theWindow ) ;      GlobalToLocal(&amp;theLocation) ;            // make the droprect be located top left at (0, 0)      OffsetRect( &amp;theDocument-&gt;dropArea, -theDocument-&gt;dropArea.left,  -theDocument-&gt;dropArea.top );      OffsetRect( &amp;theDocument-&gt;dropArea,               (theLocation.h - ((theDocument-&gt;dropArea.right - theDocument-&gt;dropArea.left)/2)),               (theLocation.v - ((theDocument-&gt;dropArea.bottom - theDocument-&gt;dropArea.top)/2)) );      Podium_UpdateDrawContextFromDropRect( theDocument ) ;      SetPort(savedPort) ;      }#endif            TumblerDocument_UpdateView( theDocument, viewHints ) ;            AdjustLightsPositions(theDocument) ;          if (viewHints)        Q3Object_Dispose(viewHints);          Q3Object_Dispose(fd);    }        else if( theDragType == 'PICT' ){      // do this on receipt of a drag of type PICT      TQ3StoragePixmap textureImage;      PicHandle    thePicture = (PicHandle)dataHdl ;      //Create a texture pixmap      MoveHHi((Handle) thePicture );      HLock((Handle) thePicture );      if( TextureFromPICT((PicHandle) thePicture, &amp;textureImage) == kQ3False ) {        Alert(130, 0L);        goto bail;      }            if( AddTextureToDocument( theDocument, &amp;textureImage) != kQ3Success ) {        Alert(130, 0L);        goto bail;      }      HUnlock((Handle)thePicture);          }        else if( theDragType == flavorTypeHFS ){          // do this on receipt of an HFS flavor (a file from the finder)      HFSFlavor    theHFSFlavor ;      // lock down the handle      MoveHHi( dataHdl ) ;      HLock( dataHdl ) ;            theHFSFlavor = *((HFSFlavor *)*dataHdl) ;            if( theHFSFlavor.fileType == 'TEXT' || theHFSFlavor.fileType == '3DMF') {              OSErr        result;        short        refNum;        DocumentPtr     theDocument;        FInfo        fndrInfo ;        TQ3Boolean      isText ;              // we assume the FSSpec passed in was valid, get the file information        // we need to know the file type, this routine may get called by an appleEvent        // handler, so we can't assume a type, we need to get it from the fsspec.                FSpGetFInfo( &amp;theHFSFlavor.fileSpec, &amp;fndrInfo ) ;                // pull out the file type                isText = ( fndrInfo.fdType == 'TEXT') ;                if ((result = FSpOpenDF(&amp;theHFSFlavor.fileSpec, fsRdWrPerm, &amp;refNum)) != noErr)          return(result);            theDocument-&gt;fRefNum = refNum;        theDocument-&gt;theFileSpec = theHFSFlavor.fileSpec ;        SetCursor(*GetCursor(watchCursor));        ReadDocumentFile( theDocument, isText ) ;        SetCursor(&amp;qd.arrow);            } else if( theHFSFlavor.fileType == 'PICT' &amp;&amp; theDocument &amp;&amp; theDocument-&gt;documentGroup) {        PicHandle    thePict;        TQ3StoragePixmap textureImage;                // get the picture from the file        thePict = OpenPICTFile(&amp;theHFSFlavor.fileSpec);                // make a texture        TextureFromPICT( thePict, &amp;textureImage);        AddTextureToDocument( theDocument, &amp;textureImage);                // and free the space occupied by the picture        KillPicture(thePict) ;            }      else        dataSize = 0;  // need better handling here...            }    // we can free up the memory now...    DisposeHandle( dataHdl ) ;    dataHdl = nil ;        //  If we actually received something, insert it into the destination.      if (dataSize != 0) {        theDocument-&gt;dirty = true;        AdjustLightsPositions( theDocument);                AdjustCamera(theDocument,          theWindow-&gt;portRect.right - theWindow-&gt;portRect.left,          theWindow-&gt;portRect.bottom - theWindow-&gt;portRect.top);      //  Draw everything into offscreen pixmap.      if (DrawOffscreen(theDocument)) {        SetPort( theWindow ) ;        InvalRect( &amp;theWindow-&gt;portRect ) ;        DrawOnscreen(theDocument);      }     }    }  return err ;  bail:  return(memFullErr);}//-----------------------------------------------------------------------// A P P L E E V E N T   S E N D E R   R O U T I N E S . . .//-----------------------------------------------------------------------// These routines are used to send ourselves AppleEvents, this is useful // for a number of reasons, ultimately it would help make us scriptable if// we implemented some of the OSL, also it's a big help for debugging drags.//// Its not really easy to do source level debugging of drag handlers and // trackers.  By packaging up the information into an appleevent and sending// it to ourselves, we can to source level debugging of the drag in the AE // handler.//----------------------------------------------------------------------------------////  Send a Quit Application Apple Event to myself to terminate this app.    void SendQuitApp( void ){  AppleEvent  myAppleEvent, reply;    //  Create the Apple Event.  FailIfErr(AECreateAppleEvent( kCoreEventClass,                   kAEQuitApplication,                   &amp;pSelfAddress,                  kAutoGenerateReturnID,                   kAnyTransactionID,                   &amp;myAppleEvent));                    //  Send the Apple Event.    FailIfErr(AESend( &amp;myAppleEvent,               &amp;reply,               kAENoReply+kAENeverInteract,               kAENormalPriority,              kAEDefaultTimeout,               nil,               nil));                  AEDisposeDesc(&amp;myAppleEvent);        // Dispose of the Apple Event.} // SendQuitApp//----------------------------------------------------------------------------------////  Send a Open Document Application Apple Event to myself to open a document.    void SendOpenDoc(FSSpec *myFSSpec){   AppleEvent    myAppleEvent;  AppleEvent    defReply;  AEDescList    docList;  OSErr         ignoreErr;    myAppleEvent.dataHandle = nil;  docList.dataHandle  = nil;  defReply.dataHandle = nil;      // Create empty list and add one file spec  FailIfErr(AECreateList(nil,0,false, &amp;docList));    FailIfErr(AEPutPtr(&amp;docList,1,typeFSS,(Ptr)myFSSpec,sizeof(FSSpec)));      FailIfErr(AECreateAppleEvent(  kCoreEventClass,                  kAEOpenDocuments,                  &amp;pSelfAddress,                  kAutoGenerateReturnID,                  kAnyTransactionID,                  &amp;myAppleEvent));  // Put Params into our event and send it  FailIfErr(AEPutParamDesc( &amp;myAppleEvent,                keyDirectObject,                &amp;docList));  FailIfErr(AESend( &amp;myAppleEvent,            &amp;defReply,            kAENoReply+kAENeverInteract,            kAENormalPriority,            kAEDefaultTimeout,            nil,            nil));          if (myAppleEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAppleEvent);      if (docList.dataHandle)     ignoreErr = AEDisposeDesc(&amp;docList);      }  // SendOpenDoc //----------------------------------------------------------------------------------////  Send a Print Document Application Apple Event to myself to open a document.    void SendPrintDoc(FSSpec *myFSSpec){   AppleEvent    myAppleEvent;  AppleEvent    defReply;  AEDescList    docList;  OSErr         ignoreErr;    myAppleEvent.dataHandle = nil;  docList.dataHandle  = nil;  defReply.dataHandle = nil;      // Create empty list and add one file spec  FailIfErr(AECreateList(nil,0,false, &amp;docList));    FailIfErr(AEPutPtr(&amp;docList,1,typeFSS,(Ptr)myFSSpec,sizeof(FSSpec)));      FailIfErr(AECreateAppleEvent(  kCoreEventClass,                  kAEPrintDocuments,                  &amp;pSelfAddress,                  kAutoGenerateReturnID,                  kAnyTransactionID,                  &amp;myAppleEvent));  // Put Params into our event and send it  FailIfErr(AEPutParamDesc( &amp;myAppleEvent,                keyDirectObject,                &amp;docList));  FailIfErr(AESend( &amp;myAppleEvent,            &amp;defReply,            kAENoReply+kAENeverInteract,            kAENormalPriority,            kAEDefaultTimeout,            nil,            nil));          if (myAppleEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAppleEvent);      if (docList.dataHandle)     ignoreErr = AEDisposeDesc(&amp;docList);      }  // SendOpenDoc //----------------------------------------------------------------------------------//  Send a drag receive Apple Event to myself to handle the receipt of a drag.    void SendDragRecv( myPrivateDataHdl privateHdl ){   AppleEvent    myAppleEvent;  AppleEvent    defReply;  OSErr         ignoreErr;    ProcessSerialNumber    myPSN ;    AEDesc      myAddress ;  char      cMemTags = HGetState((Handle)privateHdl);  // save the state of the handle in case                                // it was already locked before we were                                // called    myAppleEvent.dataHandle = nil;  defReply.dataHandle = nil;  // the static pSelfAddress that we create an usually use will cause the   // AE handler to be caused directly (less overhead).  We DON'T WANT THAT  // to happen here.  The reason being that the handler for this event needs  // to be called in our main event loop, not directly at the send.  Doing things  // this way lets us get out of the Drag Managers context, back into our own.  // that in turn lets us use a high level debugger.      FailIfErr(GetCurrentProcess(&amp;myPSN)) ;  FailIfErr(AECreateDesc(typeProcessSerialNumber,(Ptr)&amp;myPSN,sizeof(ProcessSerialNumber),&amp;myAddress));  FailIfErr(AECreateAppleEvent(  kDraggingClass,                  kDragReceiveID,                  &amp;myAddress,                  kAutoGenerateReturnID,                  kAnyTransactionID,                  &amp;myAppleEvent));  // lock down the handle  MoveHHi( (Handle)privateHdl );  HLock( (Handle)privateHdl );    // Put Params into our event and send it  FailIfErr(AEPutParamPtr( &amp;myAppleEvent,               keyPrivateData,               typeChar,               *privateHdl,               GetHandleSize( (Handle)privateHdl )));  // restore the state of the handle (effectively the same as HUnlock)  HSetState((Handle)privateHdl, cMemTags) ;  FailIfErr(AESend( &amp;myAppleEvent,            &amp;defReply,            kAENoReply+kAENeverInteract,            kAENormalPriority,            kAEDefaultTimeout,            nil,            nil));          if (myAddress.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAddress);  if (myAppleEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAppleEvent);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Tumbler_and_Podium/listing1.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Tumbler_and_Podium/listing1.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Tumbler_and_Podium/listing1.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>