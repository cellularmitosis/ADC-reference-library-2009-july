<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>AlwaysPreview - /Sample Components/SGChannelPict.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMovieBasics-date.html">Movie Basics</a> &gt; <A HREF="javascript:location.replace('index.html');">AlwaysPreview</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">AlwaysPreview</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sample Components/SGChannelPict.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AlwaysPreview.c</option>
<option value="listing2.html">/Sample Components/ExportPICS.c</option>
<option value="listing3.html">/Sample Components/ImportScrapbook.c</option>
<option value="listing4.html">/Sample Components/PictMediaHandler.c</option>
<option value="listing5.html">/Sample Components/PreviewPICS.c</option>
<option value="listing6.html">/Sample Components/SampleCode.r</option>
<option value="listing7.html">/Sample Components/SGChannelPict.c</option>
<option value="listing8.html">/Sample Components/SGPictPanel.c</option></select>
				</p>
				</form>
				<p><strong><a href="AlwaysPreview.zip">Download Sample</a></strong> (&#147;AlwaysPreview.zip&#148;, 120.9K)<BR>
<strong><a href="AlwaysPreview.dmg">Download Sample</a></strong> (&#147;AlwaysPreview.dmg&#148;, 185.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SGChannelPict.r  Written by:  Peter Hoddie  Copyright:  &copy; 1992 by Apple Computer, Inc., all rights reserved.*/#include &lt;Errors.h&gt;#include &lt;Memory.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Packages.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Resources.h&gt;#include &lt;QuickTimeComponents.h&gt;#define kMediaTimeScale 600typedef struct {  ComponentInstance    self;  SeqGrabComponent    grabber;  long          usage;  Boolean          paused;  CGrafPtr        destPort;  GDHandle        destGD;  CGrafPtr        tempPort;  MatrixRecord      displayMatrix;  Rect          destRect;  Rect          srcRect;  RgnHandle        clip;  Boolean          inPreview;  Boolean          inRecord;  TimeBase        base;  long          bytesWritten;  Boolean          showTickCount;  long          saveUsage;} SGPictGlobalsRecord, *SGPictGlobals;pascal ComponentResult SGPictOpen (SGPictGlobals store, ComponentInstance self);pascal ComponentResult SGPictClose (SGPictGlobals store, ComponentInstance self);pascal ComponentResult SGPictCanDo (SGPictGlobals store, short ftnNumber );pascal ComponentResult SGPictVersion (SGPictGlobals store);pascal ComponentResult SGPictSetGWorld (SGPictGlobals store, CGrafPtr gp, GDHandle gd);pascal ComponentResult SGPictSetChannelUsage (SGPictGlobals store, long usage);pascal ComponentResult SGPictGetChannelUsage (SGPictGlobals store, long *usage);pascal ComponentResult SGPictGetChannelInfo (SGPictGlobals store, long *channelInfo);pascal ComponentResult SGPictSetChannelMatrix (SGPictGlobals store, const MatrixRecord *m);pascal ComponentResult SGPictGetChannelMatrix (SGPictGlobals store, MatrixRecord *m);pascal ComponentResult SGPictSetChannelBounds (SGPictGlobals store, const Rect *bounds);pascal ComponentResult SGPictGetChannelBounds (SGPictGlobals store, Rect *bounds);pascal ComponentResult SGPictSetChannelClip (SGPictGlobals store, RgnHandle theClip);pascal ComponentResult SGPictGetChannelClip (SGPictGlobals store, RgnHandle *theClip);pascal ComponentResult SGPictStartPreview (SGPictGlobals store);pascal ComponentResult SGPictStartRecord (SGPictGlobals store);pascal ComponentResult SGPictIdle (SGPictGlobals store);pascal ComponentResult SGPictStop (SGPictGlobals store);pascal ComponentResult SGPictPause (SGPictGlobals store, Byte pause);pascal ComponentResult SGPictPrepare (SGPictGlobals store, Boolean prepareForPreview,         Boolean prepareForRecord);pascal ComponentResult SGPictRelease (SGPictGlobals store);pascal ComponentResult SGPictGetChannelSampleDescription (SGPictGlobals store, Handle sampleDesc);pascal ComponentResult SGPictGetChannelDeviceList (SGPictGlobals store, long selectionFlags,         SGDeviceList *list);pascal ComponentResult SGPictSetChannelDevice (SGPictGlobals store, StringPtr name);pascal ComponentResult SGPictGetChannelTimeScale (SGPictGlobals store, TimeScale *scale);pascal ComponentResult SGPictInitChannel (SGPictGlobals store, SeqGrabComponent owner);pascal ComponentResult SGPictWriteSamples (SGPictGlobals store, Movie m, AliasHandle theFile);pascal ComponentResult SGPictGetDataRate (SGPictGlobals store, long *bytesPerSecond);pascal ComponentResult SGPictPanelGetDitl (SGPictGlobals store, Handle *ditl);pascal ComponentResult SGPictPanelInstall (SGPictGlobals store, SGChannel c, DialogPtr d, short itemOffset);pascal ComponentResult SGPictPanelEvent (SGPictGlobals store, SGChannel c, DialogPtr d,         short itemOffset, EventRecord *theEvent, short *itemHit, Boolean *handled);pascal ComponentResult SGPictPanelRemove (SGPictGlobals store, SGChannel c, DialogPtr d, short itemOffset);pascal ComponentResult SGPictPanelGetSettings (SGPictGlobals store, SGChannel c, UserData *ud, long flags);pascal ComponentResult SGPictPanelSetSettings (SGPictGlobals store, SGChannel c, UserData ud, long flags);pascal ComponentResult SGPictSetShowTickCount (SGPictGlobals store, Boolean show);pascal ComponentResult SGPictGetShowTickCount (SGPictGlobals store, Boolean *show);pascal ComponentResult SGPICTDispatcher(ComponentParameters *params, Handle storage);/************************  Component Management************************/pascal ComponentResult SGPICTDispatcher(ComponentParameters *params, Handle storage){  OSErr err = badComponentSelector;  ComponentFunction componentProc = 0;  switch (params-&gt;what) {    case kComponentOpenSelect: componentProc = SGPictOpen; break;    case kComponentCloseSelect: componentProc = SGPictClose; break;    case kComponentCanDoSelect: componentProc = SGPictCanDo; break;    case kComponentVersionSelect: componentProc = SGPictVersion; break;    case kSGSetGWorldSelect: componentProc = SGPictSetGWorld; break;    case kSGStartPreviewSelect: componentProc = SGPictStartPreview; break;    case kSGStartRecordSelect: componentProc = SGPictStartRecord; break;    case kSGIdleSelect: componentProc = SGPictIdle; break;    case kSGStopSelect: componentProc = SGPictStop; break;    case kSGPauseSelect: componentProc = SGPictPause; break;    case kSGPrepareSelect: componentProc = SGPictPrepare; break;    case kSGReleaseSelect: componentProc = SGPictRelease; break;    case kSGCSetChannelUsageSelect: componentProc = SGPictSetChannelUsage; break;    case kSGCGetChannelUsageSelect: componentProc = SGPictGetChannelUsage; break;    case kSGCSetChannelBoundsSelect: componentProc = SGPictSetChannelBounds; break;    case kSGCGetChannelBoundsSelect: componentProc = SGPictGetChannelBounds; break;    case kSGCGetChannelInfoSelect: componentProc = SGPictGetChannelInfo; break;    case kSGCSetChannelMatrixSelect: componentProc = SGPictSetChannelMatrix; break;    case kSGCGetChannelMatrixSelect: componentProc = SGPictGetChannelMatrix; break;    case kSGCSetChannelClipSelect: componentProc = SGPictSetChannelClip; break;    case kSGCGetChannelClipSelect: componentProc = SGPictGetChannelClip; break;    case kSGCGetChannelSampleDescriptionSelect: componentProc = SGPictGetChannelSampleDescription; break;    case kSGCGetChannelDeviceListSelect: componentProc = SGPictGetChannelDeviceList; break;    case kSGCSetChannelDeviceSelect: componentProc = SGPictSetChannelDevice; break;    case kSGCGetChannelTimeScaleSelect: componentProc = SGPictGetChannelTimeScale; break;    case kSGCInitChannelSelect: componentProc = SGPictInitChannel; break;    case kSGCWriteSamplesSelect: componentProc = SGPictWriteSamples; break;    case kSGCGetDataRateSelect: componentProc = SGPictGetDataRate; break;    case kSGCPanelGetDitlSelect: componentProc = SGPictPanelGetDitl; break;    case kSGCPanelInstallSelect: componentProc = SGPictPanelInstall; break;    case kSGCPanelEventSelect: componentProc = SGPictPanelEvent; break;    case kSGCPanelRemoveSelect: componentProc = SGPictPanelRemove; break;    case kSGCPanelGetSettingsSelect: componentProc = SGPictPanelGetSettings; break;    case kSGCPanelSetSettingsSelect: componentProc = SGPictPanelSetSettings; break;    // Private component calls    case 0x0100: componentProc = SGPictSetShowTickCount ;break;    case 0x0101: componentProc = SGPictGetShowTickCount ;break;  }  if (componentProc)    err = CallComponentFunctionWithStorage(storage, params, componentProc);  return err;}pascal ComponentResult SGPictCanDo (SGPictGlobals store, short ftnNumber ){  switch (ftnNumber) {    case kComponentOpenSelect:    case kComponentCloseSelect:    case kComponentCanDoSelect:    case kComponentVersionSelect:        case kSGSetGWorldSelect:     case kSGStartPreviewSelect:    case kSGStartRecordSelect:     case kSGIdleSelect:     case kSGStopSelect:     case kSGPauseSelect:     case kSGPrepareSelect:     case kSGReleaseSelect:     case kSGCSetChannelUsageSelect:     case kSGCGetChannelUsageSelect:     case kSGCSetChannelBoundsSelect:     case kSGCGetChannelBoundsSelect:     case kSGCGetChannelInfoSelect:     case kSGCSetChannelMatrixSelect:     case kSGCGetChannelMatrixSelect:     case kSGCSetChannelClipSelect:     case kSGCGetChannelClipSelect:     case kSGCGetChannelSampleDescriptionSelect:     case kSGCGetChannelDeviceListSelect:     case kSGCSetChannelDeviceSelect:     case kSGCGetChannelTimeScaleSelect:     case kSGCInitChannelSelect:     case kSGCWriteSamplesSelect:     case kSGCGetDataRateSelect:     case kSGCPanelGetDitlSelect:     case kSGCPanelInstallSelect:     case kSGCPanelEventSelect:     case kSGCPanelRemoveSelect:     case kSGCPanelGetSettingsSelect:     case kSGCPanelSetSettingsSelect:     // Private component calls    case 0x0100:     case 0x0101:       return true;    default:      return false;  }}pascal ComponentResult SGPictVersion (SGPictGlobals store){  return 0x00020001;}pascal ComponentResult SGPictOpen (SGPictGlobals store, ComponentInstance self){  OSErr err;  Rect r;  CGrafPtr tempPort;  GrafPtr savePort;  // allocate globals  store = (SGPictGlobals)NewPtrClear(sizeof(SGPictGlobalsRecord));  if (err = MemError()) goto bail;  // create a temporary port for drawing to in the idle routine  tempPort = (CGrafPtr)NewPtr(sizeof(CGrafPort));  if (err = MemError()) {    DisposePtr((Ptr)store);    goto bail;  }  GetPort(&amp;savePort);  OpenCPort(tempPort);  SetPort((GrafPtr)tempPort);  PortSize(4096, 4096);    // randomly big port  SetRect(&amp;r, 0, 0, 4096, 4096);  RectRgn(tempPort-&gt;visRgn, &amp;r);  ClipRect(&amp;r);  SetPort(savePort);  store-&gt;self = self;  store-&gt;tempPort = tempPort;  store-&gt;showTickCount = false;  SetComponentInstanceStorage(self, (Handle)store);bail:  return err;}pascal ComponentResult SGPictClose (SGPictGlobals store, ComponentInstance self){  if (store) {    if (store-&gt;clip) DisposeRgn(store-&gt;clip);    if (store-&gt;tempPort) {      CloseCPort(store-&gt;tempPort);      DisposePtr((Ptr)store-&gt;tempPort);    }    DisposPtr((Ptr)store);  }  return noErr;}/************************  Required SG Channel Calls************************/pascal ComponentResult SGPictSetGWorld (SGPictGlobals store, CGrafPtr gp, GDHandle gd){// remember the destination GWorld  store-&gt;destPort = gp;  store-&gt;destGD = gd;  return noErr;}pascal ComponentResult SGPictSetChannelUsage (SGPictGlobals store, long usage){  store-&gt;usage = usage;  return noErr;}pascal ComponentResult SGPictGetChannelUsage (SGPictGlobals store, long *usage){  *usage = store-&gt;usage;  return noErr;}pascal ComponentResult SGPictGetChannelInfo (SGPictGlobals store, long *channelInfo){  *channelInfo = seqGrabHasBounds;  return noErr;}pascal ComponentResult SGPictSetChannelMatrix (SGPictGlobals store, const MatrixRecord *m){  OSErr err = noErr;  MatrixRecord mat;  short matType;  // determine the matrix being set  if (m)    mat = *m;  else    SetIdentityMatrix(&amp;mat);  // validate it  matType = GetMatrixType(&amp;mat);  if ((mat.matrix[0][0] &lt; 0) || (mat.matrix[1][1] &lt; 0) || (matType &gt;= linearMatrixType))    return paramErr;  // update the matrix and destination rect  store-&gt;displayMatrix = mat;  store-&gt;destRect = store-&gt;srcRect;  TransformRect(&amp;mat, &amp;store-&gt;destRect, nil);  return err;}pascal ComponentResult SGPictGetChannelMatrix (SGPictGlobals store, MatrixRecord *m){  *m = store-&gt;displayMatrix;  return noErr;}pascal ComponentResult SGPictSetChannelBounds (SGPictGlobals store, const Rect *bounds){  // remember destination rect  store-&gt;destRect = *bounds;  // recalculate display matrix from it  RectMatrix(&amp;store-&gt;displayMatrix, &amp;store-&gt;srcRect, &amp;store-&gt;destRect);  return noErr;}pascal ComponentResult SGPictGetChannelBounds (SGPictGlobals store, Rect *bounds){  *bounds = store-&gt;destRect;  return noErr;}pascal ComponentResult SGPictSetChannelClip (SGPictGlobals store, RgnHandle theClip){  OSErr err = noErr;  if (store-&gt;clip) {    DisposeRgn(store-&gt;clip);    store-&gt;clip = nil;  }  if (theClip) {    err = HandToHand((Handle *)&amp;theClip);    store-&gt;clip = theClip;  }  return err;}pascal ComponentResult SGPictGetChannelClip (SGPictGlobals store, RgnHandle *theClip){  OSErr err = noErr;  if (*theClip = store-&gt;clip)    err = HandToHand((Handle *)theClip);  return err;}pascal ComponentResult SGPictStartPreview (SGPictGlobals store){  store-&gt;inPreview = (store-&gt;usage &amp; seqGrabPreview) != 0;  return noErr;}pascal ComponentResult SGPictStartRecord (SGPictGlobals store){  store-&gt;inRecord = (store-&gt;usage &amp; seqGrabRecord) != 0;  store-&gt;inPreview = (store-&gt;usage &amp; seqGrabPlayDuringRecord) != 0;  return noErr;}pascal ComponentResult SGPictIdle (SGPictGlobals store){  OSErr err = noErr;  if (!store-&gt;paused &amp;&amp; (store-&gt;inRecord || store-&gt;inPreview)) {    Point mouseLoc;    Rect r;    PicHandle tempPict = nil;    TimeRecord tr;    CGrafPtr savePort;    GDHandle saveGD;    Rect maxR;      GetGWorld(&amp;savePort, &amp;saveGD);    GetTimeBaseTime(store-&gt;base, kMediaTimeScale, &amp;tr);          // figure the current area around the mouse (only on main screen)    SetGWorld(store-&gt;tempPort, GetMainDevice());    GetMouse(&amp;mouseLoc);    LocalToGlobal(&amp;mouseLoc);    r.top = r.bottom = mouseLoc.v;    r.left = r.right = mouseLoc.h;    InsetRect(&amp;r, -(store-&gt;srcRect.right &gt;&gt; 1), -(store-&gt;srcRect.bottom &gt;&gt; 1));    maxR = (**GetMainDevice()).gdRect;    if (r.left &lt; maxR.left) OffsetRect(&amp;r, -r.left + maxR.left, 0);    if (r.top &lt; maxR.top) OffsetRect(&amp;r, 0, -r.top + maxR.top);    if (r.right &gt; maxR.right) OffsetRect(&amp;r, maxR.right - r.right, 0);    if (r.bottom &gt; maxR.bottom) OffsetRect(&amp;r, 0, maxR.bottom - r.bottom);    // copy the screen into a picture    tempPict = OpenPicture(&amp;r);      CopyBits((BitMap *)&amp;store-&gt;tempPort-&gt;portPixMap,             (BitMap *)&amp;store-&gt;tempPort-&gt;portPixMap, &amp;r, &amp;r, srcCopy, nil);      if (store-&gt;showTickCount) {        // if they want to see ticks, draw them        Str63 str;        NumToString(TickCount(), str);        r.right = r.left + StringWidth(str) + 4; // do some magic positioning        r.bottom = r.top + 14;        EraseRect(&amp;r);        MoveTo(r.left + 2, r.bottom - 3);        TextSize(12);        DrawString(str);      }    ClosePicture();    // if recording, add data to movie    if (store-&gt;inRecord) {      long offset;      long pictSize = GetHandleSize((Handle)tempPict);      HLock((Handle)tempPict);      err = SGAddMovieData(store-&gt;grabber, store-&gt;self,             (Ptr)*tempPict, pictSize, &amp;offset, 0, tr.value.lo, seqGrabWriteAppend);      store-&gt;bytesWritten += pictSize;    }    // if we need to show the preview image, do that    if (store-&gt;inPreview) {      RgnHandle saveClip;      SetGWorld(store-&gt;destPort, store-&gt;destGD);      if (store-&gt;clip) {        saveClip = NewRgn();        GetClip(saveClip);        SetClip(store-&gt;clip);      }      DrawPicture(tempPict, &amp;store-&gt;destRect);      if (store-&gt;clip) {        SetClip(saveClip);        DisposeRgn(saveClip);      }    }    KillPicture(tempPict);    SetGWorld(savePort, saveGD);  }  return err;}pascal ComponentResult SGPictStop (SGPictGlobals store){  store-&gt;inRecord = store-&gt;inPreview = false;  return noErr;}pascal ComponentResult SGPictPause (SGPictGlobals store, Byte pause){  store-&gt;paused = pause;  return noErr;}pascal ComponentResult SGPictPrepare (SGPictGlobals store, Boolean prepareForPreview, Boolean prepareForRecord){  store-&gt;bytesWritten = 0;  return noErr;}pascal ComponentResult SGPictRelease (SGPictGlobals store){  return noErr;}pascal ComponentResult SGPictGetChannelSampleDescription (SGPictGlobals store, Handle sampleDesc){  OSErr err;  SampleDescriptionPtr sdp;  SetHandleSize(sampleDesc, sizeof(SampleDescription));  if (err = MemError()) goto bail;  // make up a minimal sample description  sdp = (SampleDescriptionPtr)*sampleDesc;  sdp-&gt;descSize = sizeof(SampleDescription);  sdp-&gt;dataFormat = 'PICT';  sdp-&gt;resvd1 = 0;  sdp-&gt;resvd2 = 0;  sdp-&gt;dataRefIndex = 0;bail:  return err;}pascal ComponentResult SGPictGetChannelDeviceList (SGPictGlobals store, long selectionFlags, SGDeviceList *list){  *list = (SGDeviceList)NewHandleClear(sizeof(SGDeviceListRecord));    // no devices  return MemError();}pascal ComponentResult SGPictSetChannelDevice (SGPictGlobals store, StringPtr name){  return noErr;}pascal ComponentResult SGPictGetChannelTimeScale (SGPictGlobals store, TimeScale *scale){  *scale = kMediaTimeScale;  return noErr;}pascal ComponentResult SGPictInitChannel (SGPictGlobals store, SeqGrabComponent owner){  // initialize any variable here  SetRect(&amp;store-&gt;srcRect, 0, 0, 160, 120);   // size around mouse that we capture  SetIdentityMatrix(&amp;store-&gt;displayMatrix);  store-&gt;grabber = owner;  SGGetTimeBase(owner, &amp;store-&gt;base);  return noErr;}pascal ComponentResult SGPictWriteSamples (SGPictGlobals store, Movie m, AliasHandle theFile){  OSErr err = 0;  Track pictT;  Media pictM;  long i;  MatrixRecord aMatrix;  Rect from, to;  seqGrabFrameInfo fi;  TimeRecord tr;  TimeValue mediaDuration;  SampleDescriptionHandle sampleDesc = 0;  if (!(store-&gt;usage &amp; seqGrabRecord))    return err;  sampleDesc = (SampleDescriptionHandle)NewHandle(4);  if (err = MemError()) goto bail;  if (err = SGGetChannelSampleDescription(store-&gt;self, (Handle)sampleDesc)) goto bail;  SetRect(&amp;from, 0, 0, store-&gt;srcRect.right, store-&gt;srcRect.bottom);  to = from;  TransformRect(&amp;store-&gt;displayMatrix, &amp;to, nil);  pictT = NewMovieTrack(m, (long)from.right &lt;&lt; 16, (long)from.bottom &lt;&lt; 16, 0);  pictM = NewTrackMedia(pictT, 'PICT', kMediaTimeScale, (Handle)theFile, rAliasType);  fi.frameChannel = store-&gt;self;  i = -1;  do {    TimeValue frameDuration;    err = SGGetNextFrameReference(store-&gt;grabber, &amp;fi, &amp;frameDuration, &amp;i);    if (err) {      if (err == paramErr)        err = 0;      break;    }    err = AddMediaSampleReference(pictM,         fi.frameOffset, fi.frameSize,        frameDuration,        sampleDesc, 1,        0, 0);    if (err == invalidDuration) {      err = noErr;      break;    }  } while (!err);done:  if (err) goto bail;  GetTimeBaseTime(store-&gt;base, 0, &amp;tr);  ConvertTimeScale(&amp;tr, kMediaTimeScale);    // trim media inserted to not extend beyond end time  mediaDuration = GetMediaDuration(pictM);  if (tr.value.lo &gt; mediaDuration)    tr.value.lo = mediaDuration;    // this should never happen,                   // but avoiding an error at this step seems like a good idea  err = InsertMediaIntoTrack(pictT, 0, 0, tr.value.lo, kFix1);  RectMatrix(&amp;aMatrix, &amp;from, &amp;to);  SetTrackMatrix( pictT, &amp;aMatrix );  if (store-&gt;clip) SetTrackClipRgn(pictT, store-&gt;clip);bail:  DisposHandle((Handle)sampleDesc);  return err;}pascal ComponentResult SGPictGetDataRate (SGPictGlobals store, long *bytesPerSecond){  // take a guess at our data rate  *bytesPerSecond = 24 * 1024;  if (store-&gt;bytesWritten) {    TimeValue timeNow = GetTimeBaseTime(store-&gt;base, 8, nil); // 1/8th second resolution    if (!timeNow)      return seqGrabInfoNotAvailable;    *bytesPerSecond = (store-&gt;bytesWritten / timeNow) * 8;  // convert back to seconds  }  return noErr;}/************************  SG Pict Channel  Specific Calls************************/pascal ComponentResult SGPictSetShowTickCount (SGPictGlobals store, Boolean show){  store-&gt;showTickCount = show;  return noErr;}pascal ComponentResult SGPictGetShowTickCount (SGPictGlobals store, Boolean *show){  *show = store-&gt;showTickCount;  return noErr;}/************************  Panel Calls************************/pascal ComponentResult SGPictPanelGetDitl (SGPictGlobals store, Handle *ditl){  *ditl = GetResource('DITL', 7000);   if (!*ditl) return resNotFound;  DetachResource(*ditl);  return noErr;}pascal ComponentResult SGPictPanelInstall (SGPictGlobals store, SGChannel c, DialogPtr d, short itemOffset){  Rect newBounds;  short kind;  Handle h;  // reset this channel to use the dialog window and be in preview mode with no clip  SGSetGWorld(store-&gt;self, (CGrafPtr)d, GetMainDevice());  SGGetChannelUsage(store-&gt;self, &amp;store-&gt;saveUsage);  SGSetChannelUsage(store-&gt;self, seqGrabPreview);  SGSetChannelClip(c, nil);  GetDItem(d, 1 + itemOffset, &amp;kind, &amp;h, &amp;newBounds);  SGSetChannelBounds(c, &amp;newBounds);  SGStartPreview(store-&gt;self);  return noErr;}pascal ComponentResult SGPictPanelEvent (SGPictGlobals store, SGChannel c, DialogPtr d, short itemOffset,       EventRecord *theEvent, short *itemHit, Boolean *handled){  if (theEvent-&gt;what == nullEvent)    return SGIdle(store-&gt;self);  return noErr;}pascal ComponentResult SGPictPanelRemove (SGPictGlobals store, SGChannel c, DialogPtr d, short itemOffset){  SGStop(store-&gt;self);  SGRelease(store-&gt;self);  // note that the clip and bounds are automatically restored for us because they were stored by us with the  //  SGGetSettings call  SGSetChannelUsage(store-&gt;self, store-&gt;saveUsage);  return noErr;}pascal ComponentResult SGPictPanelGetSettings (SGPictGlobals store, SGChannel c, UserData *result, long flags){  OSErr err = noErr;  UserData ud = 0;  MatrixRecord matrix;  RgnHandle clip;  if (err = NewUserData(&amp;ud)) goto bail;  // add matrix to user data  if (SGGetChannelMatrix(c, &amp;matrix) == noErr) {    if (err = SetUserDataItem(ud, &amp;matrix, sizeof(matrix), sgMatrixType, 1)) goto bail;  }  // store clip, if there is one  if (SGGetChannelClip(c, &amp;clip) == noErr) {    if (clip)      err = AddUserData(ud, (Handle)clip, sgClipType);    else      err = SetUserDataItem(ud, nil, 0, sgClipType, 1);  // add a dummy to indicate none    DisposeRgn(clip);    if (err) goto bail;  }bail:  if (err) {    DisposeUserData(ud);    ud = 0;  }  *result = ud;  return err;}pascal ComponentResult SGPictPanelSetSettings (SGPictGlobals store, SGChannel c, UserData ud, long flags){  OSErr err;  RgnHandle clip = NewRgn();  MatrixRecord matrix;  // restore clip, if one was stored  if (GetUserData(ud, (Handle)clip, sgClipType, 1) == noErr) {    if (err = SGSetChannelClip(c, GetHandleSize((Handle)clip) ? clip : 0)) goto bail;  }  // restore matrix  if (err = GetUserDataItem(ud, &amp;matrix, sizeof(matrix), sgMatrixType, 1)) goto bail;  if (err = SGSetChannelMatrix(c, &amp;matrix)) goto bail;bail:  DisposeRgn(clip);  return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/AlwaysPreview/listing7.html%3Fid%3DDTS10000761-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/AlwaysPreview/listing7.html%3Fid%3DDTS10000761-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/AlwaysPreview/listing7.html%3Fid%3DDTS10000761-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>