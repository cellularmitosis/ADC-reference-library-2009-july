<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Creating Paths With Multiple Contours and Fills</TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><!-- QTnavbar start --><P><I>Inside Macintosh: QuickTime Reference</I><P>| <A HREF="refVectors.36.htm">Previous</A> | <A HREF="refVectors.1.htm">Chapter Contents</A> | <A HREF="refVectors.htm">Chapter Top</A> | <A HREF="refVectors.38.htm">Next</A> | <!-- QTnavbar end --><H1 CLASS="H2.Heading2"><A NAME="pgfId=35762"> </A>Creating Paths With Multiple Contours and Fills</H1><P CLASS="T1.Text1"><A NAME="pgfId=35768"> </A><A NAME="marker=35763"> </A><A NAME="marker=35764"> </A><A HREF="refVectors.37.htm#36470" CLASS="XRef">Listing 4</A> shows how a single path shape can contain more than one path contour. The path shape defined in this example includes the round path from the previous example as well as a second round path, entirely contained within the first.</P><P CLASS="L.Listing"><A NAME="pgfId=35770"> </A>Listing 4	<A NAME="36470"> </A>Creating a path with concentric contours</P><CODE CLASS="Cv.Code"><A NAME="pgfId=43566"> </A>ComponentInstance vectorCodec;<BR>Handle streamH;<BR>Handle pathH;<BR>gxPoint points[4];<BR>Boolean isOnCurve[4];<BR>int i;<BR>long value;<BR><BR>/* open the vector codec component */<BR>OpenADefaultComponent (decompressorComponentType,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kVectorCodecType, &amp;vectorCodec);<BR><BR>/* create a new vector data stream */<BR>CurveCreateVectorStream (vectorCodec, streamH);<BR>value=gxClosedFrameFill<BR><BR>/* add an atom to the vector data stream that specifies that <BR>&nbsp;&nbsp;&nbsp;subsequent paths are to be drawn with closed frame fill */<BR>CurveAddAtomToVectorStream (ci, kCurveFillTypeAtom,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(long), &amp;value, streamH);<BR><BR>/* create the path */<BR>CurveNewPath (vectorCodec, &amp;pathH);<BR><BR>/* specify the points for the first contour and whether each one is <BR>&nbsp;&nbsp;&nbsp;on the path */<BR>points[0].x = ff(50);<BR>points[0].y = ff(50);<BR>isOnCurve[0] = FALSE;<BR>points[1].x = ff(150);<BR>points[1].y = ff(50);<BR>isOnCurve[1] = FALSE;<BR>points[2].x = ff(150);<BR>points[2].y = ff(150);<BR>isOnCurve[2] = FALSE;<BR>points[3].x = ff(50);<BR>points[3].y = ff(150);<BR>isOnCurve[3] = FALSE;<BR><BR>/* add the points for the first contour to the path */<BR>for (i = 0; i &lt;= 3; i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;CurveInsertPointIntoPath (vectorCodec, &amp;points[i], pathH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, i, isOnCurve[i]);<BR><BR>/* specify the points for the second contour and whether each one is <BR>&nbsp;&nbsp;&nbsp;on the path */<BR>points[0].x = ff(65);<BR>points[0].y = ff(65);<BR>isOnCurve[0] = FALSE;<BR>points[1].x = ff(135);<BR>points[1].y = ff(65);<BR>isOnCurve[1] = FALSE;<BR>points[2].x = ff(135);<BR>points[2].y = ff(135);<BR>isOnCurve[2] = FALSE;<BR>points[3].x = ff(65);<BR>points[3].y = ff(135);<BR>isOnCurve[3] = FALSE;<BR><BR>/* add the points for the second contour to the path */<BR>for (i = 0; i &lt;= 3; i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;CurveInsertPointIntoPath (vectorCodec, &amp;points[i], pathH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2, i, isOnCurve[i]);<BR><BR>/* add the path to the vector data stream */<BR>CurveAddPathAtomToVectorStream (vectorCodec, pathH, streamH);<BR><BR>/* mark the end of the vector data stream by adding a <BR>&nbsp;&nbsp;&nbsp;kCurveEndAtom atom to the stream */<BR>CurveAddZeroAtomToVectorStream (vectorCodec, streamH);<BR><BR>/* use the vector codec here to decompress and display the vector data */<BR><BR>/* dispose of stream and path handles when done */<BR>DisposeHandle (streamH);<BR>DisposeHandle (pathH);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=35776"> </A><A NAME="marker=35772"> </A>The result is shown in <A HREF="refVectors.37.htm#29921" CLASS="XRef">Figure 60</A>.</P><P CLASS="Fg.Figure"><A NAME="pgfId=35782"> </A>Figure 60	<A NAME="29921"> </A><A NAME="marker=35777"> </A>A path with two concentric clockwise contours and closed-frame fill</P><DIV><IMG SRC="GR2-L-31.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=35783"> </A>You can change the shape fill for this path by removing these lines from <A HREF="refVectors.37.htm#36470" CLASS="XRef">Listing 4</A>:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=43570"> </A>/* add an atom to the vector data stream that specifies that <BR>&nbsp;&nbsp;&nbsp;subsequent paths are to be drawn with closed frame fill */<BR>CurveAddAtomToVectorStream (ci, kCurveFillTypeAtom, sizeof(long),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;value, streamH);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=35789"> </A><A NAME="marker=35788"> </A>If you don't specify a fill type, you get the default fill type, which is the even-odd fill. The path shape resulting from an even-odd fill is shown in <A HREF="refVectors.37.htm#23625" CLASS="XRef">Figure 61</A>.</P><P CLASS="Fg.Figure"><A NAME="pgfId=35798"> </A>Figure 61	<A NAME="23625"> </A>A path with two contours<A NAME="marker=35797"> </A> and even-odd shape fill</P><DIV><IMG SRC="GR2-L-32.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=35801"> </A><A NAME="marker=35799"> </A><A NAME="marker=35800"> </A>Notice that the even-odd shape fill causes the vector codec to fill in the outer contour, but not the inner contour. You can specify a winding fill by adding the following code before the code to draw a path:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=43574"> </A>/* add an atom to the vector data stream that specifies that <BR>&nbsp;&nbsp;&nbsp;subsequent paths are to be drawn with winding fill */<BR>CurveAddAtomToVectorStream (ci, kCurveFillTypeAtom, sizeof(long),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;value, streamH);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=35806"> </A>The path drawn with a winding fill is shown in <A HREF="refVectors.37.htm#12891" CLASS="XRef">Figure 62</A>.</P><P CLASS="Fg.Figure"><A NAME="pgfId=35811"> </A>Figure 62	<A NAME="12891"> </A>A path with two contours and winding fill</P><DIV><IMG SRC="GR2-L-33.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=35812"> </A>Unlike the even-odd shape fill, the winding shape fill causes the vector codec to fill inner contours --<I CLASS="italics">as long as the inner contour has the same contour direction as the outer contour.</I> If the inner contour and the outer contour have opposite contour directions, neither the even-odd shape fill nor the winding shape fill will fill the inner contour.<A NAME="marker=35813"> </A></P><P CLASS="T1.Text1"><A NAME="pgfId=35814"> </A>For example, if you change the direction of the inner contour from the previous example by reversing the order of the second contour's geometric points, as in the following code</P><CODE CLASS="Cv.Code"><A NAME="pgfId=43578"> </A>/* specify the points for the second contour and whether each one is <BR>&nbsp;&nbsp;&nbsp;on the path */<BR>points[0].x = ff(65);<BR>points[0].y = ff(135);<BR>isOnCurve[0] = FALSE;<BR>points[1].x = ff(135);<BR>points[1].y = ff(135);<BR>isOnCurve[1] = FALSE;<BR>points[2].x = ff(135);<BR>points[2].y = ff(65);<BR>isOnCurve[2] = FALSE;<BR>points[3].x = ff(65);<BR>points[3].y = ff(65);<BR>isOnCurve[3] = FALSE;<BR><BR>/* add the points for the second contour to the path */<BR>for (i = 0; i &lt;= 3; i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;CurveInsertPointIntoPath (vectorCodec, &amp;points[i], pathH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2, i, isOnCurve[i]);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=35816"> </A>and you specify a closed-frame fill by adding the following code before the code to draw a path:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=43582"> </A>/* add an atom to the vector data stream that specifies that <BR>&nbsp;&nbsp;&nbsp;subsequent paths are to be drawn with winding fill */<BR>CurveAddAtomToVectorStream (ci, kCurveFillTypeAtom, sizeof(long),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;value, streamH);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=35818"> </A>the resulting path has contours with opposite contour directions, as depicted in <A HREF="refVectors.37.htm#41061" CLASS="XRef">Figure 63</A>.</P><P CLASS="Fg.Figure"><A NAME="pgfId=35827"> </A>Figure 63	<A NAME="41061"> </A>Path with internal counterclockwise contour and closed-frame fill</P><DIV><IMG SRC="GR2-L-34.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=35828"> </A>Since the outer contour and the inner contour have opposite contour directions, neither the even-odd shape fill nor the winding shape fill cause the vector codec to fill the inner contour, as shown in <A HREF="refVectors.37.htm#16457" CLASS="XRef">Figure 64</A>.</P><P CLASS="Fg.Figure"><A NAME="pgfId=35837"> </A>Figure 64	<A NAME="16457"> </A>A path with <A NAME="marker=35836"> </A>even-odd or winding shape fill</P><DIV><IMG SRC="GR2-L-35.gif"></DIV><hr>&#169; 1999 Apple Computer, Inc.<!-- QTnavbar start --><P><I>Inside Macintosh: QuickTime Reference</I><P>| <A HREF="refVectors.36.htm">Previous</A> | <A HREF="refVectors.1.htm">Chapter Contents</A> | <A HREF="refVectors.htm">Chapter Top</A> | <A HREF="refVectors.38.htm">Next</A> | <!-- QTnavbar end --></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>